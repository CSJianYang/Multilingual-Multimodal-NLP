[
    {
        "title": "Find First and Last Position of Element in Sorted Array",
        "question_content": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\nIf target is not found in the array, return [-1, -1].\nYou must&nbsp;write an algorithm with&nbsp;O(log n) runtime complexity.\n&nbsp;\nExample 1:\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\nExample 2:\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\nExample 3:\nInput: nums = [], target = 0\nOutput: [-1,-1]\n&nbsp;\nConstraints:\n\n\t0 <= nums.length <= 105\n\t-109&nbsp;<= nums[i]&nbsp;<= 109\n\tnums is a non-decreasing array.\n\t-109&nbsp;<= target&nbsp;<= 109",
        "solutions": [
            {
                "id": 14699,
                "title": "clean-iterative-solution-with-two-binary-searches-with-explanation",
                "content": "The problem can be simply broken down as two binary searches for the begining and end of the range, respectively:\\n\\nFirst let's find the left boundary of the range. We initialize the range to [i=0, j=n-1]. In each step, calculate the middle element [mid = (i+j)/2]. Now according to the relative value of A[mid] to target, there are three possibilities:\\n\\n   1. If A[mid] < target, then the range must begins on the ***right*** of mid (hence i = mid+1 for the next iteration)\\n   2. If A[mid] > target, it means the range must begins on the ***left*** of mid (j = mid-1)\\n   3. If A[mid] = target, then the range must begins ***on the left of or at*** mid  (j= mid)\\n\\nSince we would move the search range to the same side for case 2 and 3, we might as well merge them as one single case so that less code is needed:\\n\\n   2*. If A[mid] >= target, j = mid;\\n\\nSurprisingly, 1 and 2* are the only logic you need to put in loop while (i < j). When the while loop terminates, the value of i/j is where the start of the range is. Why? \\n\\nNo matter what the sequence originally is, as we narrow down the search range, eventually we will be at a situation where there are only two elements in the search range. Suppose our target is 5, then we have only 7 possible cases:\\n\\n    case 1: [5 7] (A[i] = target < A[j])\\n\\tcase 2: [5 3] (A[i] = target > A[j])\\n    case 3: [5 5] (A[i] = target = A[j])\\n    case 4: [3 5] (A[j] = target > A[i])\\n    case 5: [3 7] (A[i] < target < A[j])\\n\\tcase 6: [3 4] (A[i] < A[j] < target)\\n\\tcase 7: [6 7] (target < A[i] < A[j])\\n\\nFor case 1, 2 and 3, if we follow the above rule, since mid = i => A[mid] = target in these cases, then we would set j = mid. Now the loop terminates and i and j both point to the first 5.  \\n\\nFor case 4, since A[mid] < target, then set i = mid+1. The loop terminates and both i and j point to 5.\\n\\nFor all other cases, by the time the loop terminates, A[i] is not equal to 5. So we can easily know 5 is not in the sequence if the comparison fails.\\n\\nIn conclusion, when the loop terminates, if A[i]==target, then i is the left boundary of the range; otherwise, just return -1;\\n\\nFor the right of the range, we can use a similar idea. Again we can come up with several rules:\\n\\n   1. If A[mid] > target, then the range must begins on the ***left*** of mid (j = mid-1)\\n   2. If A[mid] < target, then the range must begins on the ***right*** of mid (hence i = mid+1 for the next iteration)\\n   3. If A[mid] = target, then the range must begins ***on the right of or at*** mid  (i= mid) \\n\\nAgain, we can merge condition 2 and 3 into:\\n\\n    2* If A[mid] <= target, then i = mid;\\n\\nHowever, the terminate condition on longer works this time. Consider the following case:\\n\\n    [5 7], target = 5\\n\\t\\nNow A[mid] = 5, then according to rule 2, we set i = mid. This practically does nothing because i is already equal to mid. As a result, the search range is not moved at all!\\n\\nThe solution is by using a small trick: instead of calculating mid as mid = (i+j)/2, we now do:\\n\\n    mid = (i+j)/2+1\\n\\t\\nWhy does this trick work? When we use mid = (i+j)/2, the mid is rounded to the lowest integer. In other words, mid is always *biased* towards the left. This means we could have i == mid when j - i == mid, but we NEVER have j == mid. So in order to keep the search range moving, you must make sure the new i is set to something different than mid, otherwise we are at the risk that i gets stuck. But for the new j, it is okay if we set it to mid, since it was not equal to mid anyways. Our two rules in search of the left boundary happen to satisfy these requirements, so it works perfectly in that situation. Similarly, when we search for the right boundary, we must make sure i won't get stuck when we set the new i to i = mid. The easiest way to achieve this is by making mid *biased* to the right, i.e. mid = (i+j)/2+1.\\n\\nAll this reasoning boils down to the following simple code:\\n\\n    vector<int> searchRange(int A[], int n, int target) {\\n        int i = 0, j = n - 1;\\n        vector<int> ret(2, -1);\\n        // Search for the left one\\n        while (i < j)\\n        {\\n            int mid = (i + j) /2;\\n            if (A[mid] < target) i = mid + 1;\\n            else j = mid;\\n        }\\n        if (A[i]!=target) return ret;\\n        else ret[0] = i;\\n        \\n        // Search for the right one\\n        j = n-1;  // We don't have to set i to 0 the second time.\\n        while (i < j)\\n        {\\n            int mid = (i + j) /2 + 1;\\t// Make mid biased to the right\\n            if (A[mid] > target) j = mid - 1;  \\n            else i = mid;\\t\\t\\t\\t// So that this won't make the search range stuck.\\n        }\\n        ret[1] = j;\\n        return ret; \\n    }",
                "solutionTags": [],
                "code": "The problem can be simply broken down as two binary searches for the begining and end of the range, respectively:\\n\\nFirst let's find the left boundary of the range. We initialize the range to [i=0, j=n-1]. In each step, calculate the middle element [mid = (i+j)/2]. Now according to the relative value of A[mid] to target, there are three possibilities:\\n\\n   1. If A[mid] < target, then the range must begins on the ***right*** of mid (hence i = mid+1 for the next iteration)\\n   2. If A[mid] > target, it means the range must begins on the ***left*** of mid (j = mid-1)\\n   3. If A[mid] = target, then the range must begins ***on the left of or at*** mid  (j= mid)\\n\\nSince we would move the search range to the same side for case 2 and 3, we might as well merge them as one single case so that less code is needed:\\n\\n   2*. If A[mid] >= target, j = mid;\\n\\nSurprisingly, 1 and 2* are the only logic you need to put in loop while (i < j). When the while loop terminates, the value of i/j is where the start of the range is. Why? \\n\\nNo matter what the sequence originally is, as we narrow down the search range, eventually we will be at a situation where there are only two elements in the search range. Suppose our target is 5, then we have only 7 possible cases:\\n\\n    case 1: [5 7] (A[i] = target < A[j])\\n\\tcase 2: [5 3] (A[i] = target > A[j])\\n    case 3: [5 5] (A[i] = target = A[j])\\n    case 4: [3 5] (A[j] = target > A[i])\\n    case 5: [3 7] (A[i] < target < A[j])\\n\\tcase 6: [3 4] (A[i] < A[j] < target)\\n\\tcase 7: [6 7] (target < A[i] < A[j])\\n\\nFor case 1, 2 and 3, if we follow the above rule, since mid = i => A[mid] = target in these cases, then we would set j = mid. Now the loop terminates and i and j both point to the first 5.  \\n\\nFor case 4, since A[mid] < target, then set i = mid+1. The loop terminates and both i and j point to 5.\\n\\nFor all other cases, by the time the loop terminates, A[i] is not equal to 5. So we can easily know 5 is not in the sequence if the comparison fails.\\n\\nIn conclusion, when the loop terminates, if A[i]==target, then i is the left boundary of the range; otherwise, just return -1;\\n\\nFor the right of the range, we can use a similar idea. Again we can come up with several rules:\\n\\n   1. If A[mid] > target, then the range must begins on the ***left*** of mid (j = mid-1)\\n   2. If A[mid] < target, then the range must begins on the ***right*** of mid (hence i = mid+1 for the next iteration)\\n   3. If A[mid] = target, then the range must begins ***on the right of or at*** mid  (i= mid) \\n\\nAgain, we can merge condition 2 and 3 into:\\n\\n    2* If A[mid] <= target, then i = mid;\\n\\nHowever, the terminate condition on longer works this time. Consider the following case:\\n\\n    [5 7], target = 5\\n\\t\\nNow A[mid] = 5, then according to rule 2, we set i = mid. This practically does nothing because i is already equal to mid. As a result, the search range is not moved at all!\\n\\nThe solution is by using a small trick: instead of calculating mid as mid = (i+j)/2, we now do:\\n\\n    mid = (i+j)/2+1\\n\\t\\nWhy does this trick work? When we use mid = (i+j)/2, the mid is rounded to the lowest integer. In other words, mid is always *biased* towards the left. This means we could have i == mid when j - i == mid, but we NEVER have j == mid. So in order to keep the search range moving, you must make sure the new i is set to something different than mid, otherwise we are at the risk that i gets stuck. But for the new j, it is okay if we set it to mid, since it was not equal to mid anyways. Our two rules in search of the left boundary happen to satisfy these requirements, so it works perfectly in that situation. Similarly, when we search for the right boundary, we must make sure i won't get stuck when we set the new i to i = mid. The easiest way to achieve this is by making mid *biased* to the right, i.e. mid = (i+j)/2+1.\\n\\nAll this reasoning boils down to the following simple code:\\n\\n    vector<int> searchRange(int A[], int n, int target) {\\n        int i = 0, j = n - 1;\\n        vector<int> ret(2, -1);\\n        // Search for the left one\\n        while (i < j)\\n        {\\n            int mid = (i + j) /2;\\n            if (A[mid] < target) i = mid + 1;\\n            else j = mid;\\n        }\\n        if (A[i]!=target) return ret;\\n        else ret[0] = i;\\n        \\n        // Search for the right one\\n        j = n-1;  // We don't have to set i to 0 the second time.\\n        while (i < j)\\n        {\\n            int mid = (i + j) /2 + 1;\\t// Make mid biased to the right\\n            if (A[mid] > target) j = mid - 1;  \\n            else i = mid;\\t\\t\\t\\t// So that this won't make the search range stuck.\\n        }\\n        ret[1] = j;\\n        return ret; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 14734,
                "title": "easy-java-o-logn-solution",
                "content": "There must be two indices in the array. Which means, we can just simply apply to binary search twice to find each index of the target element.\\n\\n\\n    public class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] result = new int[2];\\n        result[0] = findFirst(nums, target);\\n        result[1] = findLast(nums, target);\\n        return result;\\n    }\\n    \\n    private int findFirst(int[] nums, int target){\\n        int idx = -1;\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while(start <= end){\\n            int mid = (start + end) / 2;\\n            if(nums[mid] >= target){\\n                end = mid - 1;\\n            }else{\\n                start = mid + 1;\\n            }\\n            if(nums[mid] == target) idx = mid;\\n        }\\n        return idx;\\n    }\\n    \\n    private int findLast(int[] nums, int target){\\n        int idx = -1;\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while(start <= end){\\n            int mid = (start + end) / 2;\\n            if(nums[mid] <= target){\\n                start = mid + 1;\\n            }else{\\n                end = mid - 1;\\n            }\\n            if(nums[mid] == target) idx = mid;\\n        }\\n        return idx;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] result = new int[2];\\n        result[0] = findFirst(nums, target);\\n        result[1] = findLast(nums, target);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 14701,
                "title": "a-very-simple-java-solution-with-only-one-binary-search-algorithm",
                "content": "    public class Solution {\\n    \\tpublic int[] searchRange(int[] A, int target) {\\n    \\t\\tint start = Solution.firstGreaterEqual(A, target);\\n    \\t\\tif (start == A.length || A[start] != target) {\\n    \\t\\t\\treturn new int[]{-1, -1};\\n    \\t\\t}\\n    \\t\\treturn new int[]{start, Solution.firstGreaterEqual(A, target + 1) - 1};\\n    \\t}\\n    \\n    \\t//find the first number that is greater than or equal to target.\\n    \\t//could return A.length if target is greater than A[A.length-1].\\n    \\t//actually this is the same as lower_bound in C++ STL.\\n    \\tprivate static int firstGreaterEqual(int[] A, int target) {\\n    \\t\\tint low = 0, high = A.length;\\n    \\t\\twhile (low < high) {\\n    \\t\\t\\tint mid = low + ((high - low) >> 1);\\n    \\t\\t\\t//low <= mid < high\\n    \\t\\t\\tif (A[mid] < target) {\\n    \\t\\t\\t\\tlow = mid + 1;\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\t//should not be mid-1 when A[mid]==target.\\n    \\t\\t\\t\\t//could be mid even if A[mid]>target because mid<high.\\n    \\t\\t\\t\\thigh = mid;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn low;\\n    \\t}\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    \\tpublic int[] searchRange(int[] A, int target) {\\n    \\t\\tint start = Solution.firstGreaterEqual(A, target);\\n    \\t\\tif (start == A.length || A[start] != target) {\\n    \\t\\t\\treturn new int[]{-1, -1}",
                "codeTag": "Java"
            },
            {
                "id": 14707,
                "title": "9-11-lines-o-log-n",
                "content": "Solution 1 : **Divide and Conquer with early breaks** : 56 ms\\n\\nThe O(log n) time isn't quite obvious, so I'll explain it below. Or you can take the challenge and prove it yourself :-)\\n\\n    def searchRange(self, nums, target):\\n        def search(lo, hi):\\n            if nums[lo] == target == nums[hi]:\\n                return [lo, hi]\\n            if nums[lo] <= target <= nums[hi]:\\n                mid = (lo + hi) / 2\\n                l, r = search(lo, mid), search(mid+1, hi)\\n                return max(l, r) if -1 in l+r else [l[0], r[1]]\\n            return [-1, -1]\\n        return search(0, len(nums)-1)\\n\\nThe `search` helper function returns an index range just like the requested `searchRange` function, but only searches in `nums[lo..hi]`. It first compares the end points and immediately returns `[lo, hi]` if that whole part of `nums` is full of `target`, and immediately returns `[-1, -1]` if `target` is outside the range. The interesting case is when `target` can be in the range but doesn't fill it completely.\\n\\nIn that case, we split the range in left and right half, solve them recursively, and combine their results appropriately. Why doesn't this explode exponentially? Well, let's call the numbers in the left half `A, ..., B` and the numbers in the right half `C, ..., D`. Now if one of them immediately return their `[lo, hi]` or `[-1, -1]`, then this doesn't explode. And if neither immediately returns, that means we have `A <= target <= B` and `C <= target <= D`. And since `nums` is sorted, we actually have `target <= B <= C <= target`, so `B = C = target`. **The left half thus ends with `target` and the right half starts with it.** I highlight that because it's important. Now consider what happens further. The left half gets halved again. Call the middle elements `a` and `b`, so the left half is `A, ..., a, b, ..., B`. Then `a <= target` and:\\n\\n - If `a < target`, then the call analyzing `A, ..., a` immediately returns `[-1, -1]` and we only look further into `b, ..., B` **which is again a part that ends with `target`**.\\n - If `a == target`, then `a = b = ... = B = target` and thus the call analyzing `b, ..., B` immediately returns its `[lo, hi]` and we only look further into `A, ..., a` **which is again a part that ends with `target`**.\\n\\nSame for the right half `C, ..., D`. So in the beginning of the search, as long as `target` is only in at most one of the two halves (so the other immediately stops), we have a single path. And if we ever come across the case where `target` is in both halves, then we split into *two* paths, but then each of those remains a single path. And both paths are only O(log n) long, so we have overall runtime O(log n).\\n\\nThis is btw based on [us917's solution](https://leetcode.com/discuss/4238/can-solution-be-obtained-in-one-pass?show=4425#a4425).\\n\\n---\\n\\nSolution 2 : **Two binary searches** : 56 ms\\n\\n    def searchRange(self, nums, target):\\n        def search(n):\\n            lo, hi = 0, len(nums)\\n            while lo < hi:\\n                mid = (lo + hi) / 2\\n                if nums[mid] >= n:\\n                    hi = mid\\n                else:\\n                    lo = mid + 1\\n            return lo\\n        lo = search(target)\\n        return [lo, search(target+1)-1] if target in nums[lo:lo+1] else [-1, -1]\\n\\nHere, my helper function is a simple binary search, telling me the first index where I could insert a number `n` into `nums` to keep it sorted. Thus, if `nums` contains `target`, I can find the first occurrence with `search(target)`. I do that, and if `target` isn't actually there, then I return `[-1, -1]`. Otherwise, I ask `search(target+1)`, which tells me the first index where I could insert `target+1`, which of course is one index behind the last index containing `target`, so all I have left to do is subtract 1.\\n\\n---\\n\\nSolution 3 : **Two binary searches, using the library**\\n\\nBinary search is so good and common that many languages have it in their standard library and you just need to figure out how to apply it to the problem at hand.\\n\\n**Python:**\\n\\n    def searchRange(self, nums, target):\\n        lo = bisect.bisect_left(nums, target)\\n        return [lo, bisect.bisect(nums, target)-1] if target in nums[lo:lo+1] else [-1, -1]\\n\\n**C++:**\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        auto bounds = equal_range(nums.begin(), nums.end(), target);\\n        if (bounds.first == bounds.second)\\n            return {-1, -1};\\n        return {bounds.first - nums.begin(), bounds.second - nums.begin() - 1};\\n    }\\n\\nOr:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int lo = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n        if (lo == nums.size() || nums[lo] != target)\\n            return {-1, -1};\\n        int hi = upper_bound(nums.begin(), nums.end(), target) - nums.begin() - 1;\\n        return {lo, hi};\\n    }\\n\\n**Java:**\\n\\nWell, Java decided to be annoying and offer `Arrays.binSearch` but with *\"If the array contains multiple elements with the specified value, there is no guarantee which one will be found\"*. So it's useless for us. I'm not good at Java, though, so maybe I'm overlooking a way to still make it work. If you manage to do so, please let me know.",
                "solutionTags": [],
                "code": "Solution 1 : **Divide and Conquer with early breaks** : 56 ms\\n\\nThe O(log n) time isn't quite obvious, so I'll explain it below. Or you can take the challenge and prove it yourself :-)\\n\\n    def searchRange(self, nums, target):\\n        def search(lo, hi):\\n            if nums[lo] == target == nums[hi]:\\n                return [lo, hi]\\n            if nums[lo] <= target <= nums[hi]:\\n                mid = (lo + hi) / 2\\n                l, r = search(lo, mid), search(mid+1, hi)\\n                return max(l, r) if -1 in l+r else [l[0], r[1]]\\n            return [-1, -1]\\n        return search(0, len(nums)-1)\\n\\nThe `search` helper function returns an index range just like the requested `searchRange` function, but only searches in `nums[lo..hi]`. It first compares the end points and immediately returns `[lo, hi]` if that whole part of `nums` is full of `target`, and immediately returns `[-1, -1]` if `target` is outside the range. The interesting case is when `target` can be in the range but doesn't fill it completely.\\n\\nIn that case, we split the range in left and right half, solve them recursively, and combine their results appropriately. Why doesn't this explode exponentially? Well, let's call the numbers in the left half `A, ..., B` and the numbers in the right half `C, ..., D`. Now if one of them immediately return their `[lo, hi]` or `[-1, -1]`, then this doesn't explode. And if neither immediately returns, that means we have `A <= target <= B` and `C <= target <= D`. And since `nums` is sorted, we actually have `target <= B <= C <= target`, so `B = C = target`. **The left half thus ends with `target` and the right half starts with it.** I highlight that because it's important. Now consider what happens further. The left half gets halved again. Call the middle elements `a` and `b`, so the left half is `A, ..., a, b, ..., B`. Then `a <= target` and:\\n\\n - If `a < target`, then the call analyzing `A, ..., a` immediately returns `[-1, -1]` and we only look further into `b, ..., B` **which is again a part that ends with `target`**.\\n - If `a == target`, then `a = b = ... = B = target` and thus the call analyzing `b, ..., B` immediately returns its `[lo, hi]` and we only look further into `A, ..., a` **which is again a part that ends with `target`**.\\n\\nSame for the right half `C, ..., D`. So in the beginning of the search, as long as `target` is only in at most one of the two halves (so the other immediately stops), we have a single path. And if we ever come across the case where `target` is in both halves, then we split into *two* paths, but then each of those remains a single path. And both paths are only O(log n) long, so we have overall runtime O(log n).\\n\\nThis is btw based on [us917's solution](https://leetcode.com/discuss/4238/can-solution-be-obtained-in-one-pass?show=4425#a4425).\\n\\n---\\n\\nSolution 2 : **Two binary searches** : 56 ms\\n\\n    def searchRange(self, nums, target):\\n        def search(n):\\n            lo, hi = 0, len(nums)\\n            while lo < hi:\\n                mid = (lo + hi) / 2\\n                if nums[mid] >= n:\\n                    hi = mid\\n                else:\\n                    lo = mid + 1\\n            return lo\\n        lo = search(target)\\n        return [lo, search(target+1)-1] if target in nums[lo:lo+1] else [-1, -1]\\n\\nHere, my helper function is a simple binary search, telling me the first index where I could insert a number `n` into `nums` to keep it sorted. Thus, if `nums` contains `target`, I can find the first occurrence with `search(target)`. I do that, and if `target` isn't actually there, then I return `[-1, -1]`. Otherwise, I ask `search(target+1)`, which tells me the first index where I could insert `target+1`, which of course is one index behind the last index containing `target`, so all I have left to do is subtract 1.\\n\\n---\\n\\nSolution 3 : **Two binary searches, using the library**\\n\\nBinary search is so good and common that many languages have it in their standard library and you just need to figure out how to apply it to the problem at hand.\\n\\n**Python:**\\n\\n    def searchRange(self, nums, target):\\n        lo = bisect.bisect_left(nums, target)\\n        return [lo, bisect.bisect(nums, target)-1] if target in nums[lo:lo+1] else [-1, -1]\\n\\n**C++:**\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        auto bounds = equal_range(nums.begin(), nums.end(), target);\\n        if (bounds.first == bounds.second)\\n            return {-1, -1};\\n        return {bounds.first - nums.begin(), bounds.second - nums.begin() - 1};\\n    }\\n\\nOr:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int lo = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n        if (lo == nums.size() || nums[lo] != target)\\n            return {-1, -1};\\n        int hi = upper_bound(nums.begin(), nums.end(), target) - nums.begin() - 1;\\n        return {lo, hi};\\n    }\\n\\n**Java:**\\n\\nWell, Java decided to be annoying and offer `Arrays.binSearch` but with *\"If the array contains multiple elements with the specified value, there is no guarantee which one will be found\"*. So it's useless for us. I'm not good at Java, though, so maybe I'm overlooking a way to still make it work. If you manage to do so, please let me know.",
                "codeTag": "Python3"
            },
            {
                "id": 3188625,
                "title": "best-c-2-solution-binary-search-linear-search-brute-force-optimize-one-stop-solu",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can Solved this question using Two approach. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Linear Search (Brute Force Approach).\\n2. Solved using Binary Search (Optimized Approach).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N), because in the worst case we traverse the <= N element. Where N is the size of the\\n    Array(nums).\\n                    \\n    Space Complexity : O(1), the space complexity is constant.\\n\\n    Solved using Linear Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int startingPosition = -1, endingPosition = -1;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == target){\\n                startingPosition = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0; i--){\\n            if(nums[i] == target){\\n                endingPosition = i;\\n                break;\\n            }\\n        }\\n        return {startingPosition, endingPosition};\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity\\n    is logarithmic.\\n\\n    Space Complexity : O(1), since we stored only some constant number of elements, the space complexity is\\n    constant.\\n\\n    Solved using Binary Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 First Code *****************************************/\\n\\nclass Solution {\\nprivate:\\n    int lower_bound(vector<int>& nums, int low, int high, int target){\\n        while(low <= high){\\n            int mid = (low + high) >> 1;\\n            if(nums[mid] < target){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return low;\\n    }\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size()-1;\\n        int startingPosition = lower_bound(nums, low, high, target);\\n        int endingPosition = lower_bound(nums, low, high, target + 1) - 1;\\n        if(startingPosition < nums.size() && nums[startingPosition] == target){\\n            return {startingPosition, endingPosition};\\n        }\\n        return {-1, -1};\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 2 Second Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int startingPosition = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n        int endingPosition = lower_bound(nums.begin(), nums.end(), target+1) - nums.begin() - 1;\\n        if(startingPosition < nums.size() && nums[startingPosition] == target){\\n            return {startingPosition, endingPosition};\\n        }\\n        return {-1, -1};\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N), because in the worst case we traverse the <= N element. Where N is the size of the\\n    Array(nums).\\n                    \\n    Space Complexity : O(1), the space complexity is constant.\\n\\n    Solved using Linear Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int startingPosition = -1, endingPosition = -1;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == target){\\n                startingPosition = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0; i--){\\n            if(nums[i] == target){\\n                endingPosition = i;\\n                break;\\n            }\\n        }\\n        return {startingPosition, endingPosition};\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity\\n    is logarithmic.\\n\\n    Space Complexity : O(1), since we stored only some constant number of elements, the space complexity is\\n    constant.\\n\\n    Solved using Binary Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 First Code *****************************************/\\n\\nclass Solution {\\nprivate:\\n    int lower_bound(vector<int>& nums, int low, int high, int target){\\n        while(low <= high){\\n            int mid = (low + high) >> 1;\\n            if(nums[mid] < target){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return low;\\n    }\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size()-1;\\n        int startingPosition = lower_bound(nums, low, high, target);\\n        int endingPosition = lower_bound(nums, low, high, target + 1) - 1;\\n        if(startingPosition < nums.size() && nums[startingPosition] == target){\\n            return {startingPosition, endingPosition};\\n        }\\n        return {-1, -1};\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 2 Second Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int startingPosition = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n        int endingPosition = lower_bound(nums.begin(), nums.end(), target+1) - nums.begin() - 1;\\n        if(startingPosition < nums.size() && nums[startingPosition] == target){\\n            return {startingPosition, endingPosition};\\n        }\\n        return {-1, -1};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14717,
                "title": "c-binary-search-solution-lower-bound-implementation",
                "content": "        \\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int idx1 = lower_bound(nums, target);\\n        int idx2 = lower_bound(nums, target+1)-1;\\n        if (idx1 < nums.size() && nums[idx1] == target)\\n            return {idx1, idx2};\\n        else\\n            return {-1, -1};\\n    }\\n    \\n    int lower_bound(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size()-1;\\n        while (l <= r) {\\n            int mid = (r-l)/2+l;\\n            if (nums[mid] < target)\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        return l;\\n    }",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "        \\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int idx1 = lower_bound(nums, target);\\n        int idx2 = lower_bound(nums, target+1)-1;\\n        if (idx1 < nums.size() && nums[idx1] == target)\\n            return {idx1, idx2};\\n        else\\n            return {-1, -1};\\n    }\\n    \\n    int lower_bound(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size()-1;\\n        while (l <= r) {\\n            int mid = (r-l)/2+l;\\n            if (nums[mid] < target)\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        return l;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 573123,
                "title": "c-how-to-nail-binary-search-the-very-first-time-explained",
                "content": "I used to be afraid about getting binary searches not working the first time. I had the opportunity to see a great programmer code it out in front of my eyes a few times. Here is what I learnt from the way he did it. \\n\\n1) Use a variable to **store the temporary result** during the search(let\\'s call it ans). Every time you hit a not found condition AND if there is a possibility of one of the mid or its neighbours being the desired answer **store it**. \\nReason : storing can\\'t harm you if its constant space, the later points will show you how it reduces a burden while writing binary search. Also it ensures an answer.\\n\\n2) Whenever you hit not found condition **do `s = mid+1` or `e = mid-1`** according to the condition without worrying. \\nReason : You have stored your value if the loop ends, can\\'t go wrong. This also ensures you don\\'t go into infinite loops.\\n\\n3) Default to writing **`mid = s + (e-s)/2`** and NOT **`mid = (s+e)/2`**. \\nReason : The later can result in an overflow when you are not searching in an array but rather on an answer space, specially because binary search if it can be applied is a great tool for huge numbers.\\n\\n4) Write your if and elses well, and don\\'t worry about adding extra conditions with the neighbours, at the same time don\\'t forget to check whether the neighbour exists.\\nReason : This is the only thing you should be worrying about coding right, because this depends on the problem. If it is a easy or medium sometimes even medium-hard, this part shouldnt cause much trouble.\\n\\nThis is not the only way to approach binary search in a fail-safe way every time, there are others too. Choose any and code a lot of problems using that, but don\\'t mix two ways up.\\n\\nHere is a basic code to the problem using the above way.\\n\\n```cpp\\nvector<int> searchRange(vector<int>& a, int target) {\\n\\tint s = 0, e = a.size()-1;\\n\\tvector<int> ans(2, -1);\\n\\t//first occurrence\\n\\twhile(s <= e){\\n\\t\\tint m = s + (e-s)/2;\\n\\t\\tif(a[m] < target)\\n\\t\\t\\ts = m+1;\\n\\t\\telse if(a[m] > target)\\n\\t\\t\\te = m-1;\\n\\t\\telse{\\n\\t\\t\\tif(m == s || a[m] != a[m-1]){\\n\\t\\t\\t\\tans[0] = m;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\te = m-1;\\n\\t\\t\\t\\tans[0] = m-1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t//last occurrence\\n\\ts = 0, e = a.size()-1;\\n\\twhile(s <= e){\\n\\t\\tint m = s + (e-s)/2;\\n\\t\\tif(a[m] < target)\\n\\t\\t\\ts = m+1;\\n\\t\\telse if(a[m] > target)\\n\\t\\t\\te = m-1;\\n\\t\\telse{\\n\\t\\t\\tif(m == e || a[m] != a[m+1]){\\n\\t\\t\\t\\tans[1] = m;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\ts = m+1;\\n\\t\\t\\t\\tans[1] = m+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ans; \\n}\\n```\\nIf you\\'re wondering why I have written `m == s` and again `m == e` in my conditions. This is because I am sure my answer cannot be outside the range s and e and if it is it has been stored. If you\\'re more comfortable you can replace with `m == 0` or `m == a.size()-1`\\n\\nI hope you found this helpful.\\n\\n**Update:**\\nSolved this again 2 years from the time I first wrote this post as part of daily challenge, found it more elegant than quite a few of the other most voted solutions, that have implemented the solution using two binary searchs. Using library lower_bound or solving using one binary search by calling twice for target and target + 1, beats the purpose of practising this question, unless your only aim is to make your solution short.\\n\\nThat said if you want to learn binary search, you should still go through the earlier solution I wrote as it demonstrates the point of checking neighbours(which can be useful in other problems and hence more general). The solution below avoids that and hence you may miss getting practise for that.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans(2, -1);\\n        int start = 0, end = (int)nums.size() - 1;\\n        while(start <= end) {\\n            int mid = start + (end-start)/2;\\n            if(nums[mid] < target) start = mid+1;\\n            else {\\n                if(nums[mid] == target) ans[0] = mid;\\n                end = mid-1;\\n            }\\n        }\\n        start = 0, end = (int)nums.size() - 1;\\n        while(start <= end) {\\n            int mid = start + (end-start)/2;\\n            if(nums[mid] > target) end = mid-1;\\n            else {\\n                if(nums[mid] == target) ans[1] = mid;\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIt makes me happy that I decided to share this 2 years back, over 10k people have read this, and atleast 100 people have found this helpful. \\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```cpp\\nvector<int> searchRange(vector<int>& a, int target) {\\n\\tint s = 0, e = a.size()-1;\\n\\tvector<int> ans(2, -1);\\n\\t//first occurrence\\n\\twhile(s <= e){\\n\\t\\tint m = s + (e-s)/2;\\n\\t\\tif(a[m] < target)\\n\\t\\t\\ts = m+1;\\n\\t\\telse if(a[m] > target)\\n\\t\\t\\te = m-1;\\n\\t\\telse{\\n\\t\\t\\tif(m == s || a[m] != a[m-1]){\\n\\t\\t\\t\\tans[0] = m;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\te = m-1;\\n\\t\\t\\t\\tans[0] = m-1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t//last occurrence\\n\\ts = 0, e = a.size()-1;\\n\\twhile(s <= e){\\n\\t\\tint m = s + (e-s)/2;\\n\\t\\tif(a[m] < target)\\n\\t\\t\\ts = m+1;\\n\\t\\telse if(a[m] > target)\\n\\t\\t\\te = m-1;\\n\\t\\telse{\\n\\t\\t\\tif(m == e || a[m] != a[m+1]){\\n\\t\\t\\t\\tans[1] = m;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\ts = m+1;\\n\\t\\t\\t\\tans[1] = m+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ans; \\n}\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans(2, -1);\\n        int start = 0, end = (int)nums.size() - 1;\\n        while(start <= end) {\\n            int mid = start + (end-start)/2;\\n            if(nums[mid] < target) start = mid+1;\\n            else {\\n                if(nums[mid] == target) ans[0] = mid;\\n                end = mid-1;\\n            }\\n        }\\n        start = 0, end = (int)nums.size() - 1;\\n        while(start <= end) {\\n            int mid = start + (end-start)/2;\\n            if(nums[mid] > target) end = mid-1;\\n            else {\\n                if(nums[mid] == target) ans[1] = mid;\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14714,
                "title": "16-line-python-solution-symmetric-and-clean-binary-search-52ms",
                "content": "    def searchRange(self, nums, target):\\n        def binarySearchLeft(A, x):\\n            left, right = 0, len(A) - 1\\n            while left <= right:\\n                mid = (left + right) / 2\\n                if x > A[mid]: left = mid + 1\\n                else: right = mid - 1\\n            return left\\n\\n        def binarySearchRight(A, x):\\n            left, right = 0, len(A) - 1\\n            while left <= right:\\n                mid = (left + right) / 2\\n                if x >= A[mid]: left = mid + 1\\n                else: right = mid - 1\\n            return right\\n            \\n        left, right = binarySearchLeft(nums, target), binarySearchRight(nums, target)\\n        return (left, right) if left <= right else [-1, -1]",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "    def searchRange(self, nums, target):\\n        def binarySearchLeft(A, x):\\n            left, right = 0, len(A) - 1\\n            while left <= right:\\n                mid = (left + right) / 2\\n                if x > A[mid]: left = mid + 1\\n                else: right = mid - 1\\n            return left\\n\\n        def binarySearchRight(A, x):\\n            left, right = 0, len(A) - 1\\n            while left <= right:\\n                mid = (left + right) / 2\\n                if x >= A[mid]: left = mid + 1\\n                else: right = mid - 1\\n            return right\\n            \\n        left, right = binarySearchLeft(nums, target), binarySearchRight(nums, target)\\n        return (left, right) if left <= right else [-1, -1]",
                "codeTag": "Python3"
            },
            {
                "id": 1054742,
                "title": "python-o-logn",
                "content": "```python\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        \\n        def search(x):\\n            lo, hi = 0, len(nums)           \\n            while lo < hi:\\n                mid = (lo + hi) // 2\\n                if nums[mid] < x:\\n                    lo = mid+1\\n                else:\\n                    hi = mid                    \\n            return lo\\n        \\n        lo = search(target)\\n        hi = search(target+1)-1\\n        \\n        if lo <= hi:\\n            return [lo, hi]\\n                \\n        return [-1, -1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        \\n        def search(x):\\n            lo, hi = 0, len(nums)           \\n            while lo < hi:\\n                mid = (lo + hi) // 2\\n                if nums[mid] < x:\\n                    lo = mid+1\\n                else:\\n                    hi = mid                    \\n            return lo\\n        \\n        lo = search(target)\\n        hi = search(target+1)-1\\n        \\n        if lo <= hi:\\n            return [lo, hi]\\n                \\n        return [-1, -1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717306,
                "title": "python3-solution-with-detailed-explanation",
                "content": "First thing first! When you hear `O(logn)` or sorted array, your mind should go back to [**binary search**](https://leetcode.com/problems/binary-search/)  example! \\n\\nI think the problem statement is not hard to understand, right? Check out the examples provided in case you have problem digesting it. \\n\\nThe idea is that we have to return two indices, one for start of the `target` and one for end of the `target` in an array. So, we use two different functions, one would go and try to find the starting index, the other to find the end index. as simple as that! We have two helper functions in the code below which are responsible for these tasks. The `main function` is just a wrapper that initializa (line `#1`)  the output and assign updated values  (line `#2, 3`) from helper functions and `return results`  (line `#4`) at the end. \\n\\n\\n\\n``` \\nclass Solution(object): \\n\\n#### Main function\\n\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        result = [-1, -1] #1\\n        \\n        result[0] = self.findStartingIndex(nums, target)  #2 \\n        result[1] = self.findEndingIndex(nums, target)  #3\\n        \\n        return result #4\\n\\t\\t\\n#### Helper function 1 \\n\\n    def findStartingIndex(self, nums, target):\\n        index = -1 #5 \\n        low, high = 0, len(nums) -1 #6\\n        \\n        while low <= high: #7\\n            mid = low + (high - low)/2 #8\\n\\t\\t\\t\\n            if nums[mid] == target: #9\\n                index = mid #10\\n                high = mid - 1 #11\\n            elif nums[mid] > target:  #12\\n                high = mid - 1 #13\\n            else:  #14\\n                low = mid + 1 #15       \\n        \\n        return index\\n        \\n#### Helper function 2\\n  \\n    def findEndingIndex(self, nums, target):\\n        index = -1\\n        low, high = 0, len(nums) -1\\n        \\n        while low <= high:\\n            \\n            mid = low + (high - low)/2\\n            \\n            if nums[mid] == target:\\n                index = mid\\n                low = mid + 1 #16\\n            elif nums[mid] > target: \\n                high = mid - 1\\n            else:\\n                 low = mid + 1\\n            \\n            \\n        \\n        return index\\n```\\n\\nNote: the two helper functions are exactly the same except for one line (there are ways to actually combine the two, but, I though it\\'s much easier to read and understand this way). The only difference is between line `#11` and line `#16` because the `findStartingIndex` would try to find the starting value and need to go to the left most target value in the array. However, `findEndingIndex` would try to find the right most one. So, in the first helper function, we try to narrow the limit of search (by changing `low` and `high`. We make `high = mid - 1 ` in line `#11`) to focus on the left side of mid while we do the same for right side in the second helper function (`low = mid + 1 `, line `#16`), does this make sense? Good. From now on, I\\'ll focus on the `findStartingIndex` function. \\n\\n\\nIt\\'s binary search! you set limits first, try to narrow it down using `mid` and focus on one side to find your `target` value. We want to return an `index` which would be `-1` in case we don\\'t find the `target`. So, we initialize it to be `-1` (line `#5`) and we will return the `index` at the end of the function, meaning that if the `index` variable doesn\\'t get updated, it will be `-1` and `target` doesn\\'t exist in the array we\\'re searching in. \\n\\nWe define a `while` loop (line `#7`) which is accurate at most when `low` and `high` are equal. You know why is that? No? Try to understand [this](https://leetcode.com/problems/binary-search/) before moving forward! If you know binary search, the rest should be easy! \\n\\nWe define a `mid` variable (line `#8`, this way of defining `mid` is to prevent overflow problem, you don\\'t need to worry about this. `mid  = (low + high) /2` or `mid = (low + high) //2` or `mid = (low + high) >> 1` also works) and compare it with `target` (line `#9`). If it\\'s the `target`, update the `index` variable (line `#10`). However, we\\'re not done here. Think about this example [1,3,3,3,5]. `mid` is 3 here. But, it\\'s not the left most 3, is it? So, you update `index` but at the same time, try to move to the left side of `mid` to find the left most `target` value (line `#11`, for the `findEndingIndex` function, you want to move to the right of `mid`, so you make `low = mid + 1`, line `#16`), 3 in this example. Make sense? Good. \\n\\nThere are two more cases in the function. If middle number is less than `target` or larger than `target`. The first case is dealth with in line `#13` and the other in line `#15`. How? If `nums[mid]` is larger than `target`, it means that `target` is on the left side of `mid`, right? Remember it is a sorted array. So, we update the `high` to be `mid - 1` so that we focus on the left side. Similar to the left, if `nums[mid]` is less than `target`, we need to focus on the right side of the `mid` value, correct? So, we update `low` to be `mid + 1`. You migh ask why `mid + 1 ` or `mid -1` and not just `mid` when we\\'re updating in lines `#11` and `#15`? Since we already dealth with `mid` in lines `#9` and `#10` and we moved to `#12` or `14` when `nums[mid]` was not equal to `target`. So, why bother and update to the `mid` value since we know it is not equal to `target`, right? \\n\\nThat\\'s it. You\\'re done! Go to the next problem. \\n\\n\\n=========================================================\\nFinal note: Please let me know if you found any typo, etc. I\\'ll try to fix them\\n\\nFinal note 2: I\\'ve found explaning stuff in the simplest way is helpful for my own learning. Thanks for reading this!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` \\nclass Solution(object): \\n\\n#### Main function\\n\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        result = [-1, -1] #1\\n        \\n        result[0] = self.findStartingIndex(nums, target)  #2 \\n        result[1] = self.findEndingIndex(nums, target)  #3\\n        \\n        return result #4\\n\\t\\t\\n#### Helper function 1 \\n\\n    def findStartingIndex(self, nums, target):\\n        index = -1 #5 \\n        low, high = 0, len(nums) -1 #6\\n        \\n        while low <= high: #7\\n            mid = low + (high - low)/2 #8\\n\\t\\t\\t\\n            if nums[mid] == target: #9\\n                index = mid #10\\n                high = mid - 1 #11\\n            elif nums[mid] > target:  #12\\n                high = mid - 1 #13\\n            else:  #14\\n                low = mid + 1 #15       \\n        \\n        return index\\n        \\n#### Helper function 2\\n  \\n    def findEndingIndex(self, nums, target):\\n        index = -1\\n        low, high = 0, len(nums) -1\\n        \\n        while low <= high:\\n            \\n            mid = low + (high - low)/2\\n            \\n            if nums[mid] == target:\\n                index = mid\\n                low = mid + 1 #16\\n            elif nums[mid] > target: \\n                high = mid - 1\\n            else:\\n                 low = mid + 1\\n            \\n            \\n        \\n        return index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14770,
                "title": "the-standard-and-clean-c-binary-search-implementation",
                "content": "Yeah, binary search is quite simple, but many people write complex and error-prone code.\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int start = 0, end = nums.size(), mid, left, right;\\n        while (start < end) {\\n            mid = (start + end) / 2;\\n            if (nums[mid] >= target)\\n                end = mid;\\n            else\\n                start = mid + 1;\\n        }\\n        left = start;\\n        start = 0, end = nums.size();\\n        while (start < end) {\\n            mid = (start + end) / 2;\\n            if (nums[mid] > target)\\n                end = mid;\\n            else\\n                start = mid + 1;\\n        }\\n        right = start;\\n        return left == right ? vector<int> {-1,-1} : vector<int> {left,right-1};\\n    }",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "Yeah, binary search is quite simple, but many people write complex and error-prone code.\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int start = 0, end = nums.size(), mid, left, right;\\n        while (start < end) {\\n            mid = (start + end) / 2;\\n            if (nums[mid] >= target)\\n                end = mid;\\n            else\\n                start = mid + 1;\\n        }\\n        left = start;\\n        start = 0, end = nums.size();\\n        while (start < end) {\\n            mid = (start + end) / 2;\\n            if (nums[mid] > target)\\n                end = mid;\\n            else\\n                start = mid + 1;\\n        }\\n        right = start;\\n        return left == right ? vector<int> {-1,-1} : vector<int> {left,right-1};\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 519580,
                "title": "c-o-log-n-fast-runtime-binary-search",
                "content": "```\\nRuntime: 4 ms, faster than 99.18% of C++ online submissions for Find First and Last Position of Element in Sorted Array.\\nMemory Usage: 8.8 MB, less than 100.00% of C++ online submissions for Find First and Last Position of Element in Sorted Array.\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        return {BinarySearch(nums, target, \"FIRST\"), BinarySearch(nums, target, \"LAST\")};\\n    }\\n    \\n    int BinarySearch(vector<int> nums, int num, string find) {\\n        int left = 0, right = nums.size() - 1, mid;\\n        int result = -1;\\n\\n        while (left <= right) {\\n            mid = (left + right) / 2;\\n\\n            if (nums[mid] == num) {\\n                result = mid;\\n                (find == \"FIRST\") ? right = mid - 1 : left = mid + 1;\\n            }\\n            else if (nums[mid] > num) {\\n                right = mid - 1;\\n            }\\n            else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nRuntime: 4 ms, faster than 99.18% of C++ online submissions for Find First and Last Position of Element in Sorted Array.\\nMemory Usage: 8.8 MB, less than 100.00% of C++ online submissions for Find First and Last Position of Element in Sorted Array.\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        return {BinarySearch(nums, target, \"FIRST\"), BinarySearch(nums, target, \"LAST\")};\\n    }\\n    \\n    int BinarySearch(vector<int> nums, int num, string find) {\\n        int left = 0, right = nums.size() - 1, mid;\\n        int result = -1;\\n\\n        while (left <= right) {\\n            mid = (left + right) / 2;\\n\\n            if (nums[mid] == num) {\\n                result = mid;\\n                (find == \"FIRST\") ? right = mid - 1 : left = mid + 1;\\n            }\\n            else if (nums[mid] > num) {\\n                right = mid - 1;\\n            }\\n            else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329415,
                "title": "c-stl-5-line-code-bits-100-test-time-saving-method",
                "content": "**Time Complexity :-** `O(Log(n))`\\n**Space Complexity :-** `O(1)`\\n\\n**If you like my approch please upvote**\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        auto low = lower_bound(nums.begin(),nums.end(),target);\\n        auto up = upper_bound(nums.begin(),nums.end(),target);\\n        \\n        if(low == nums.end() || *low != target)    return {-1,-1};\\n        \\n        int first = low - nums.begin();\\n        int last = up - nums.begin()-1;\\n        \\n        return {first ,last};\\n    }\\n};\\n```\\n**If you like my approch please upvote**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        auto low = lower_bound(nums.begin(),nums.end(),target);\\n        auto up = upper_bound(nums.begin(),nums.end(),target);\\n        \\n        if(low == nums.end() || *low != target)    return {-1,-1};\\n        \\n        int first = low - nums.begin();\\n        int last = up - nums.begin()-1;\\n        \\n        return {first ,last};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181832,
                "title": "js-python-java-c-easy-binary-search-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThis problem is very nearly the definition of a **binary search**. A binary search allows us to find the insertion index for a target number in a sorted array. It\\'s called a \"binary\" search because in each step it halves the input array and determines in which half the number belongs. Since a binary search is able to eliminate half the remaining array in each iteration, it can accomplish its objective with a **time complexity** of **O(log N)**.\\n\\nIn this case, however, we don\\'t just want to find out where the target number (**T**) would be placed in the nums array (**N**), we want to additionally find out if **T** _actually_ exists in **N**, as well as the starting and end indexes.\\n\\nThe standard implementation of a binary search will find the left-most index in which **T** could be placed, though many languages have functions for both sides. Rather than having to define two sets of functions here, however, we can, with a little creativity, use a single function to find our answer.\\n\\nFirst, we can perform the standard left binary search (**find**) on **T**. Next, we can easily check to see if **T** exists in **N** already by checking the value stored at the result of that first search (**N[Tleft]**). If we don\\'t find **T** at that index, then **T** does not exist in **N** and we should **return [-1, -1]**.\\n\\nOtherwise, we still need to find the right end of the range of **T** values in **N**. To do this, we can just use **find** again, this time with the next integer (**T + 1**). Since this will find the index _after_ the end of the range of **T** values, we can just move back one position to find the end of the **T** range.\\n\\nNow that we have our range, we can **return** it.\\n\\n - _**Time Complexity: O(log N)** for the binary search_\\n - _**Space Complexity: O(1)**_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython has built-in binary search functions for both sides: **bisect_left()** and **bisect_right()**.\\n\\nThe built-in function for Java, **Arrays.binarySearch()** does not find the left-most insertion point, so it\\'s easier to define our own binary search function.\\n\\nC++ can use the built-in function **equal_range()**, which returns iterator pointers to the range of T values.\\n\\n---\\n\\n#### ***Javascript Code:***\\n```javascript\\nvar searchRange = function(N, T) {\\n    const find = (target, arr, left=0, right=arr.length) => {\\n        while (left <= right) {\\n            let mid = left + right >> 1\\n            if (arr[mid] < target) left = mid + 1\\n            else right = mid - 1\\n        }\\n        return left\\n    } \\n    let Tleft = find(T, N)\\n    if (N[Tleft] !== T) return [-1,-1]\\n    return [Tleft, find(T+1, N, Tleft) - 1]\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\n\\n##### ***w/ bisect_left() & bisect_right():***\\n```python\\nclass Solution:\\n    def searchRange(self, N: List[int], T: int) -> List[int]:\\n        Tleft = bisect_left(N, T)\\n        if Tleft == len(N) or N[Tleft] != T: return [-1, -1]\\n        return [Tleft, bisect_right(N, T) - 1]\\n```\\n##### ***w/ Custom Binary Search:***\\n```python\\nclass Solution:\\n    def searchRange(self, N: List[int], T: int) -> List[int]:\\n        def find(target, arr, left=0):\\n            right = len(arr) - 1\\n            while left <= right:\\n                mid = left + right >> 1\\n                if arr[mid] < target: left = mid + 1\\n                else: right = mid - 1\\n            return left\\n        Tleft = find(T, N)\\n        if Tleft == len(N) or N[Tleft] != T: return [-1, -1]\\n        return [Tleft, find(T+1, N, Tleft) - 1]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    public int[] searchRange(int[] N, int T) {\\n        int Tleft = find(T, N, 0);\\n        if (Tleft == N.length || N[Tleft] != T) return new int[] {-1, -1};\\n        return new int[] {Tleft, find(T+1, N, Tleft) - 1};\\n    }\\n    public int find(int target, int[] arr, int left) {\\n        int right = arr.length - 1;\\n        while (left <= right) {\\n            int mid = left + right >> 1;\\n            if (arr[mid] < target) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return left;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\n##### ***w/ equal_range():***\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& N, int T) {\\n        pair<vector<int>::iterator,vector<int>::iterator> range;\\n        range = equal_range(N.begin(), N.end(), T);\\n        int Tleft = distance(N.begin(), range.first);\\n        if (Tleft == N.size() || N[Tleft] != T) return {-1, -1};\\n        return {Tleft, (int)distance(N.begin(), range.second) - 1};\\n    }\\n};\\n```\\n##### ***w/ Custom Binary Search:***\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& N, int T) {\\n        int Tleft = find(T, N);\\n        if (Tleft == N.size() || N[Tleft] != T) return {-1, -1};\\n        return {Tleft, find(T+1, N, Tleft) - 1};\\n    }\\n    int find(int target, vector<int> arr, int left=0) {\\n        int right = arr.size() - 1;\\n        while (left <= right) {\\n            int mid = left + right >> 1;\\n            if (arr[mid] < target) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar searchRange = function(N, T) {\\n    const find = (target, arr, left=0, right=arr.length) => {\\n        while (left <= right) {\\n            let mid = left + right >> 1\\n            if (arr[mid] < target) left = mid + 1\\n            else right = mid - 1\\n        }\\n        return left\\n    } \\n    let Tleft = find(T, N)\\n    if (N[Tleft] !== T) return [-1,-1]\\n    return [Tleft, find(T+1, N, Tleft) - 1]\\n};\\n```\n```python\\nclass Solution:\\n    def searchRange(self, N: List[int], T: int) -> List[int]:\\n        Tleft = bisect_left(N, T)\\n        if Tleft == len(N) or N[Tleft] != T: return [-1, -1]\\n        return [Tleft, bisect_right(N, T) - 1]\\n```\n```python\\nclass Solution:\\n    def searchRange(self, N: List[int], T: int) -> List[int]:\\n        def find(target, arr, left=0):\\n            right = len(arr) - 1\\n            while left <= right:\\n                mid = left + right >> 1\\n                if arr[mid] < target: left = mid + 1\\n                else: right = mid - 1\\n            return left\\n        Tleft = find(T, N)\\n        if Tleft == len(N) or N[Tleft] != T: return [-1, -1]\\n        return [Tleft, find(T+1, N, Tleft) - 1]\\n```\n```java\\nclass Solution {\\n    public int[] searchRange(int[] N, int T) {\\n        int Tleft = find(T, N, 0);\\n        if (Tleft == N.length || N[Tleft] != T) return new int[] {-1, -1};\\n        return new int[] {Tleft, find(T+1, N, Tleft) - 1};\\n    }\\n    public int find(int target, int[] arr, int left) {\\n        int right = arr.length - 1;\\n        while (left <= right) {\\n            int mid = left + right >> 1;\\n            if (arr[mid] < target) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return left;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& N, int T) {\\n        pair<vector<int>::iterator,vector<int>::iterator> range;\\n        range = equal_range(N.begin(), N.end(), T);\\n        int Tleft = distance(N.begin(), range.first);\\n        if (Tleft == N.size() || N[Tleft] != T) return {-1, -1};\\n        return {Tleft, (int)distance(N.begin(), range.second) - 1};\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& N, int T) {\\n        int Tleft = find(T, N);\\n        if (Tleft == N.size() || N[Tleft] != T) return {-1, -1};\\n        return {Tleft, find(T+1, N, Tleft) - 1};\\n    }\\n    int find(int target, vector<int> arr, int left=0) {\\n        int right = arr.size() - 1;\\n        while (left <= right) {\\n            int mid = left + right >> 1;\\n            if (arr[mid] < target) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14999,
                "title": "simple-and-strict-o-logn-solution-in-java-using-recursion",
                "content": "    public class Solution {\\n        public int[] searchRange(int[] A, int target) {\\n            int[] range = {A.length, -1};\\n            searchRange(A, target, 0, A.length - 1, range);\\n            if (range[0] > range[1]) range[0] = -1; \\n            return range;\\n        }\\n        \\n        public void searchRange(int[] A, int target, int left, int right, int[] range) {\\n            if (left > right) return;\\n            int mid = left + (right - left) / 2;\\n            if (A[mid] == target) {\\n                if (mid < range[0]) {\\n                    range[0] = mid;\\n                    searchRange(A, target, left, mid - 1, range);\\n                }\\n                if (mid > range[1]) {\\n                    range[1] = mid;\\n                    searchRange(A, target, mid + 1, right, range);\\n                }\\n            } else if (A[mid] < target) {\\n                searchRange(A, target, mid + 1, right, range);\\n            } else {\\n                searchRange(A, target, left, mid - 1, range);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int[] searchRange(int[] A, int target) {\\n            int[] range = {A.length, -1}",
                "codeTag": "Java"
            },
            {
                "id": 1608890,
                "title": "clean-and-easy-c",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int start=0,end=nums.size()-1,res=-1;\\n        vector<int>ans;\\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target)\\n            {\\n                res=mid;\\n                end=mid-1;\\n            }\\n            else if(target<nums[mid])\\n                end=mid-1;\\n            else\\n                start=mid+1;   \\n        }\\n        ans.push_back(res);\\n        start=0,end=nums.size()-1,res=-1;\\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target)\\n            {\\n                res=mid;\\n                start=mid+1;\\n            }\\n            else if(target<nums[mid])\\n                end=mid-1;\\n            else\\n                start=mid+1;   \\n        }\\n        ans.push_back(res);\\n        return ans;\\n    }\\n};\\n\\npls upvote if it was helpful:)",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 702162,
                "title": "python-let-s-implement-python-s-bisect-algorithm",
                "content": "Thinking in terms of pythons bisect_left and bisect right is helpful for this problem. Since binary search is the central feature of this problem, I believe an interviewer would also expect you to know how to implement bisect_left and bisect_right if you want to use them. Reading python source code is a great way to learn algorithms with python: https://github.com/python/cpython/blob/3.8/Lib/bisect.py#L49\\n```python\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        left, right = self.bisect_left(nums, target), self.bisect_right(nums, target) - 1\\n        return [\\n            left if left < len(nums) and nums[left] == target else -1,\\n            right if 0 <= right < len(nums) and nums[right] == target else -1\\n        ]\\n      \\n    def bisect_left(self, a, x):\\n\\t\\t\\'\\'\\'returns i where all a[:i] is less than x\\'\\'\\'\\n        lo, hi = 0, len(a)\\n        while lo < hi:\\n            mid = lo + (hi - lo) // 2\\n            if a[mid] < x: lo = mid + 1\\n            else: hi = mid\\n        return lo\\n    \\n    def bisect_right(self, a, x):\\n\\t\\t\\'\\'\\'returns i where all a[:i] is less than or equal to x\\'\\'\\'\\n        lo, hi = 0, len(a)\\n        while lo < hi:\\n            mid = lo + (hi - lo) // 2\\n            if a[mid] > x: hi = mid\\n            else: lo = mid + 1\\n        return lo\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        left, right = self.bisect_left(nums, target), self.bisect_right(nums, target) - 1\\n        return [\\n            left if left < len(nums) and nums[left] == target else -1,\\n            right if 0 <= right < len(nums) and nums[right] == target else -1\\n        ]\\n      \\n    def bisect_left(self, a, x):\\n\\t\\t\\'\\'\\'returns i where all a[:i] is less than x\\'\\'\\'\\n        lo, hi = 0, len(a)\\n        while lo < hi:\\n            mid = lo + (hi - lo) // 2\\n            if a[mid] < x: lo = mid + 1\\n            else: hi = mid\\n        return lo\\n    \\n    def bisect_right(self, a, x):\\n\\t\\t\\'\\'\\'returns i where all a[:i] is less than or equal to x\\'\\'\\'\\n        lo, hi = 0, len(a)\\n        while lo < hi:\\n            mid = lo + (hi - lo) // 2\\n            if a[mid] > x: hi = mid\\n            else: lo = mid + 1\\n        return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15056,
                "title": "my-2-binary-search-solution-without-too-many-if-checks",
                "content": "\\n\\n        public int[] searchRange(int[] A, int target) {\\n        int[] ret = {-1, -1};\\n        \\n        // the first binary search to find the left boundary\\n        int l = 0, r = A.length-1;\\n        while(l < r) {\\n            int mid = (l+r)/2;\\n            if (A[mid] < target)\\n                l = mid + 1;\\n            else\\n                r = mid;\\n        }\\n        \\n        // if target can not be found, return {-1, -1}\\n        if (A[l] != target)\\n            return ret;\\n        \\n        ret[0] = l;\\n        // second binary search to find the right boundary\\n        r = A.length-1;\\n        while(l < r) {\\n            // mid is calculated differently\\n            int mid = (l + r+1)/2;\\n            if (A[mid] > target)\\n                r = mid - 1;\\n            else\\n                l = mid;\\n        }\\n        ret[1] = l;\\n        return ret;\\n    }",
                "solutionTags": [],
                "code": "\\n\\n        public int[] searchRange(int[] A, int target) {\\n        int[] ret = {-1, -1};\\n        \\n        // the first binary search to find the left boundary\\n        int l = 0, r = A.length-1;\\n        while(l < r) {\\n            int mid = (l+r)/2;\\n            if (A[mid] < target)\\n                l = mid + 1;\\n            else\\n                r = mid;\\n        }\\n        \\n        // if target can not be found, return {-1, -1}\\n        if (A[l] != target)\\n            return ret;\\n        \\n        ret[0] = l;\\n        // second binary search to find the right boundary\\n        r = A.length-1;\\n        while(l < r) {\\n            // mid is calculated differently\\n            int mid = (l + r+1)/2;\\n            if (A[mid] > target)\\n                r = mid - 1;\\n            else\\n                l = mid;\\n        }\\n        ret[1] = l;\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2330593,
                "title": "binary-search-beats-99-fully-explained-with-intuition-image-explanation",
                "content": "If you found this post helpful, please upvote <3\\n\\n<hr />\\n\\nWe are given a sorted array of integers, and required to find some `target`.\\n\\nSince the array is sorted, an intuition to do a binary search should pop into our head, but there\\'s a trick.\\n\\nIt\\'s not enough to find the target, we need to find the **left most index**, and **right most index** of the target in the given nums array.\\n\\nLet\\'s take the following array as an example, say `target = 7` (red numbers are the indexes)\\n\\n![image](https://assets.leetcode.com/users/images/87be2062-76ef-4f64-8033-7723cf7a7099_1658733561.213248.png)\\n\\nAfter we find the `target=7` we don\\'t know if it\\'s the left most, or right most. We could iterate to the left and right indexes, but potentially the array consists of only 7\\'s like: `[7,7,7,7,7,7,7,7]` and then end up in O(n) complexity.\\n\\nInstead we should separate our logic into 2 binary searches.\\n\\nOne binary search searches for the **left most index**, whenever we find the `target`, we \"mark\" it as the potential answer and continue binary searching left.\\n\\nSame logic for the other side, whenever we find the target we \"mark\" and continue searching right.\\n\\nIn the end we return the best matches we found in each binary search. \\n\\nThis will perform 2 binary searches as `2*log(n)` which is asymptotically `O(logn)`\\n\\nNote: we could exit after 1 binary search if we **didn\\'t** find any target in our array. Both indexes will be `[-1, -1]`\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        left_target_index = self.binary_search_on_left(nums, target, 0, len(nums) - 1)\\n        if left_target_index == -1:\\n            return [-1, -1]\\n        \\n        right_target_index = self.binary_search_on_right(nums, target, 0, len(nums) - 1)\\n        return [left_target_index, right_target_index]\\n    \\n    def binary_search_on_left(self, nums: list[int], target: int, left: int, right: int):\\n        index_on_left = -1\\n        \\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            \\n            if nums[mid] == target:\\n                index_on_left = mid\\n            \\n            if nums[mid] >= target:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n            \\n        return index_on_left\\n            \\n    \\n    def binary_search_on_right(self, nums: list[int], target: int, left: int, right: int):\\n        index_on_right = -1\\n        \\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            \\n            if nums[mid] == target:\\n                index_on_right = mid\\n            \\n            if nums[mid] <= target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n            \\n        return index_on_right\\n```\\n\\n# Cleaner code\\nWe could clean the code by passing a callback as a parameter for the condition checks.\\n\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        left_target_index = self.binary_search(\\n            nums,\\n            target,\\n            0,\\n            len(nums) - 1,\\n            lambda mid_value: mid_value >= target\\n        )\\n        \\n        if left_target_index == -1:\\n            return [-1, -1]\\n        \\n        right_target_index = self.binary_search(\\n            nums,\\n            target,\\n            0,\\n            len(nums) - 1,\\n            lambda mid_value: mid_value > target\\n        )\\n        \\n        return [left_target_index, right_target_index]\\n    \\n    def binary_search(self, nums: list[int], target: int, left: int, right: int, predicate):\\n        best_index_match = -1\\n        \\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            \\n            if nums[mid] == target:\\n                best_index_match = mid\\n            \\n            if predicate(nums[mid]):\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n            \\n        return best_index_match\\n```\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        left_target_index = self.binary_search_on_left(nums, target, 0, len(nums) - 1)\\n        if left_target_index == -1:\\n            return [-1, -1]\\n        \\n        right_target_index = self.binary_search_on_right(nums, target, 0, len(nums) - 1)\\n        return [left_target_index, right_target_index]\\n    \\n    def binary_search_on_left(self, nums: list[int], target: int, left: int, right: int):\\n        index_on_left = -1\\n        \\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            \\n            if nums[mid] == target:\\n                index_on_left = mid\\n            \\n            if nums[mid] >= target:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n            \\n        return index_on_left\\n            \\n    \\n    def binary_search_on_right(self, nums: list[int], target: int, left: int, right: int):\\n        index_on_right = -1\\n        \\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            \\n            if nums[mid] == target:\\n                index_on_right = mid\\n            \\n            if nums[mid] <= target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n            \\n        return index_on_right\\n```\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        left_target_index = self.binary_search(\\n            nums,\\n            target,\\n            0,\\n            len(nums) - 1,\\n            lambda mid_value: mid_value >= target\\n        )\\n        \\n        if left_target_index == -1:\\n            return [-1, -1]\\n        \\n        right_target_index = self.binary_search(\\n            nums,\\n            target,\\n            0,\\n            len(nums) - 1,\\n            lambda mid_value: mid_value > target\\n        )\\n        \\n        return [left_target_index, right_target_index]\\n    \\n    def binary_search(self, nums: list[int], target: int, left: int, right: int, predicate):\\n        best_index_match = -1\\n        \\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            \\n            if nums[mid] == target:\\n                best_index_match = mid\\n            \\n            if predicate(nums[mid]):\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n            \\n        return best_index_match\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182518,
                "title": "4-different-approach-easy-understanding",
                "content": "* Using Binary Search\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans;\\n        int i = 0, j = nums.size()-1;\\n        int start = -1, end = -1;\\n        while(i <= j)\\n        {\\n            int mid = (i+j)/2;\\n            if(nums[mid] == target){\\n               int temp = mid;\\n                while(mid > 0 && nums[mid-1] == target) //iterating left side of mid until target value is found\\n                    mid--;\\n                start = mid;\\n                while(temp < nums.size()-1 && nums[temp+1] == target) //iterating right side of mid until target value is found (here temp is equal to mid)\\n                    temp++;\\n                end = temp;\\n                \\n                ans.push_back(start);\\n                ans.push_back(end);\\n                return ans;\\n            }\\n            else if(nums[mid] > target)\\n                j = mid-1;\\n            else\\n                i = mid+1;\\n        }\\n        \\n        ans.push_back(-1);\\n        ans.push_back(-1);\\n        return ans;\\n    }\\n};\\n```\\n* Using Unordered map\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans(2, -1);\\n        unordered_map<int,int>mp;\\n        for(int i = 0; i < nums.size(); i++)\\n            mp[nums[i]]++;\\n        \\n        int index = -1;\\n        for(int i = 0; i < nums.size(); i++)\\n            if(nums[i] == target){\\n                index = i;\\n                break;\\n            }\\n        if(index != -1){\\n            ans[0] = index;\\n            ans[1] = index + mp[target] - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n* Using inbuilt lower and upper bound functions\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans;\\n        vector<int>::iterator it, lower, upper;\\n        it = find(nums.begin(), nums.end(), target);\\n        if(it != nums.end()){\\n            lower = lower_bound(nums.begin(), nums.end(), target);\\n            upper = upper_bound(nums.begin(), nums.end(), target);\\n            ans.push_back(lower - nums.begin());\\n            ans.push_back(upper - nums.begin() - 1);\\n        }\\n        else{\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n* By iterating over nums array\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans;\\n        int first = -1, last = -1;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] == target){\\n                if(first == -1){\\n                    first = i;\\n                    last = i;\\n                }\\n                else\\n                    last = i;\\n            }\\n        }\\n        ans.push_back(first);\\n        ans.push_back(last);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans;\\n        int i = 0, j = nums.size()-1;\\n        int start = -1, end = -1;\\n        while(i <= j)\\n        {\\n            int mid = (i+j)/2;\\n            if(nums[mid] == target){\\n               int temp = mid;\\n                while(mid > 0 && nums[mid-1] == target) //iterating left side of mid until target value is found\\n                    mid--;\\n                start = mid;\\n                while(temp < nums.size()-1 && nums[temp+1] == target) //iterating right side of mid until target value is found (here temp is equal to mid)\\n                    temp++;\\n                end = temp;\\n                \\n                ans.push_back(start);\\n                ans.push_back(end);\\n                return ans;\\n            }\\n            else if(nums[mid] > target)\\n                j = mid-1;\\n            else\\n                i = mid+1;\\n        }\\n        \\n        ans.push_back(-1);\\n        ans.push_back(-1);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans(2, -1);\\n        unordered_map<int,int>mp;\\n        for(int i = 0; i < nums.size(); i++)\\n            mp[nums[i]]++;\\n        \\n        int index = -1;\\n        for(int i = 0; i < nums.size(); i++)\\n            if(nums[i] == target){\\n                index = i;\\n                break;\\n            }\\n        if(index != -1){\\n            ans[0] = index;\\n            ans[1] = index + mp[target] - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans;\\n        vector<int>::iterator it, lower, upper;\\n        it = find(nums.begin(), nums.end(), target);\\n        if(it != nums.end()){\\n            lower = lower_bound(nums.begin(), nums.end(), target);\\n            upper = upper_bound(nums.begin(), nums.end(), target);\\n            ans.push_back(lower - nums.begin());\\n            ans.push_back(upper - nums.begin() - 1);\\n        }\\n        else{\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans;\\n        int first = -1, last = -1;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] == target){\\n                if(first == -1){\\n                    first = i;\\n                    last = i;\\n                }\\n                else\\n                    last = i;\\n            }\\n        }\\n        ans.push_back(first);\\n        ans.push_back(last);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181777,
                "title": "python-solution-using-bisect-explained",
                "content": "Use binary search with adaptation twice: once to find the left place and once to find the right place. I understand that goal is to write binary search from scratch if you are on the interview, but here is solution, using already existing `bisect` library in python. \\nThe idea is to use `bisect` (which is also `bisect_right`) and `bisect_left` to get the range of numbers: first one will return index before all repetitions of `target` and the second one: after. So, if these two indexes are equal, it means that we did not found this element, so we return `[-1, -1]`. If we found, we return `[l, r - 1]`.\\n\\n#### Complexity\\nTime complexity is `O(log n)`, space is `O(1)`.\\n\\n#### Code\\n```\\nfrom bisect import bisect, bisect_left\\n\\nclass Solution:\\n    def searchRange(self, nums, target):\\n        l = bisect_left(nums,target)\\n        r = bisect(nums,target)\\n        return [-1, -1] if l == r else [l, r - 1]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect, bisect_left\\n\\nclass Solution:\\n    def searchRange(self, nums, target):\\n        l = bisect_left(nums,target)\\n        r = bisect(nums,target)\\n        return [-1, -1] if l == r else [l, r - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14708,
                "title": "share-my-concise-java-o-logn-solution-just-1-time-binary-search-easy-to-understand",
                "content": "This solution is to find the start and end index of target number with using just one time binary search\\n    \\n    public int[] searchRange(int[] nums, int target) {\\n    \\t\\tint[] res = {-1, -1};\\n    \\t\\tint lo = 0, hi = nums.length - 1;\\n    \\n    \\t\\t//lo is the start index of target\\n    \\t\\t//hi is the end index of target\\n    \\t\\twhile(nums[lo] < nums[hi]) {\\n    \\t\\t\\tint mid = lo + (hi - lo)/2;\\n    \\t\\t\\tif(nums[mid] > target) {//target is in the left half\\n    \\t\\t\\t\\thi = mid - 1;\\n    \\t\\t\\t} else if(nums[mid] < target) {// target is in the right half\\n    \\t\\t\\t\\tlo = mid + 1;\\n    \\t\\t\\t} else {//find target, then need to find the start and end point\\n    \\t\\t\\t\\tif(nums[lo] == nums[mid]) {\\n    \\t\\t\\t\\t\\thi--;\\n    \\t\\t\\t\\t}else {\\n    \\t\\t\\t\\t\\tlo++;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t//check whether find the target number\\n    \\t\\tif(nums[lo] == nums[hi] && nums[lo]== target) {\\n    \\t\\t\\tres[0] = lo;\\n    \\t\\t\\tres[1] = hi;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn res;\\n    \\t}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "This solution is to find the start and end index of target number with using just one time binary search\\n    \\n    public int[] searchRange(int[] nums, int target) {\\n    \\t\\tint[] res = {-1, -1};\\n    \\t\\tint lo = 0, hi = nums.length - 1;\\n    \\n    \\t\\t//lo is the start index of target\\n    \\t\\t//hi is the end index of target\\n    \\t\\twhile(nums[lo] < nums[hi]) {\\n    \\t\\t\\tint mid = lo + (hi - lo)/2;\\n    \\t\\t\\tif(nums[mid] > target) {//target is in the left half\\n    \\t\\t\\t\\thi = mid - 1;\\n    \\t\\t\\t} else if(nums[mid] < target) {// target is in the right half\\n    \\t\\t\\t\\tlo = mid + 1;\\n    \\t\\t\\t} else {//find target, then need to find the start and end point\\n    \\t\\t\\t\\tif(nums[lo] == nums[mid]) {\\n    \\t\\t\\t\\t\\thi--;\\n    \\t\\t\\t\\t}else {\\n    \\t\\t\\t\\t\\tlo++;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t//check whether find the target number\\n    \\t\\tif(nums[lo] == nums[hi] && nums[lo]== target) {\\n    \\t\\t\\tres[0] = lo;\\n    \\t\\t\\tres[1] = hi;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn res;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 694526,
                "title": "binary-search-o-log-n-even-for-worst-case-with-explanation",
                "content": "Thanks for @hon9g, I finally found a real O(log n) solution for all cases\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[]}\\n */\\nvar searchRange = function (nums, target) {\\n    // initiate binary search\\n    let l = 0, r = nums.length - 1;\\n\\n    // search for the first appearance index of target\\n    while (l < r) {\\n        let mid = Math.floor((l + r) / 2);\\n\\n        // try to push the array to the left smaller half\\n        // that\\'s why even when nums[mid] == target, we still set r = mid\\n        nums[mid] >= target ? r = mid : l = mid + 1;\\n    }\\n\\n    // after the first while loop, the small index l should already be the first appearance index of target\\n    // otherwise, target is not in the array and [-1, -1] should be returned\\n    if (nums[l] !== target) return [-1, -1];\\n\\n    // now we have the first appearance index of target, and it is the small index l\\n    // we can store it to a new variable for further usage\\n    let start = l;\\n\\n    // since both of the indices were changed (both of them are at the first appearance index of target)\\n    // we need to reset the big index to the end of the array to do the second binary search\\n    // to find the last appearance index of the target\\n    r = nums.length - 1;\\n\\n    // search for the last appearance index of the target\\n    while (l < r) {\\n        let mid = Math.floor((l + r) / 2);\\n\\n        // nums[mid] <= target? l = mid : r = mid -1\\n        // the above will not work as it will run into infinite loop\\n        nums[mid] <= target ? l = mid + 1 : r = mid;\\n    }\\n\\n    // after the second while loop, now l == nums.length - 1\\n    // now there are 2 conditions: target is also appeared at the last index of the array, or not\\n    // store the last appearance index of target to another variable\\n    let end = nums[l] === target ? l : l - 1;\\n\\n    // finally return the two indices into an array\\n    return [start, end];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[]}\\n */\\nvar searchRange = function (nums, target) {\\n    // initiate binary search\\n    let l = 0, r = nums.length - 1;\\n\\n    // search for the first appearance index of target\\n    while (l < r) {\\n        let mid = Math.floor((l + r) / 2);\\n\\n        // try to push the array to the left smaller half\\n        // that\\'s why even when nums[mid] == target, we still set r = mid\\n        nums[mid] >= target ? r = mid : l = mid + 1;\\n    }\\n\\n    // after the first while loop, the small index l should already be the first appearance index of target\\n    // otherwise, target is not in the array and [-1, -1] should be returned\\n    if (nums[l] !== target) return [-1, -1];\\n\\n    // now we have the first appearance index of target, and it is the small index l\\n    // we can store it to a new variable for further usage\\n    let start = l;\\n\\n    // since both of the indices were changed (both of them are at the first appearance index of target)\\n    // we need to reset the big index to the end of the array to do the second binary search\\n    // to find the last appearance index of the target\\n    r = nums.length - 1;\\n\\n    // search for the last appearance index of the target\\n    while (l < r) {\\n        let mid = Math.floor((l + r) / 2);\\n\\n        // nums[mid] <= target? l = mid : r = mid -1\\n        // the above will not work as it will run into infinite loop\\n        nums[mid] <= target ? l = mid + 1 : r = mid;\\n    }\\n\\n    // after the second while loop, now l == nums.length - 1\\n    // now there are 2 conditions: target is also appeared at the last index of the array, or not\\n    // store the last appearance index of target to another variable\\n    let end = nums[l] === target ? l : l - 1;\\n\\n    // finally return the two indices into an array\\n    return [start, end];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1651676,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func searchRange(_ nums: [Int], _ t: Int) -> [Int] {\\n        var arr = [-1,-1]\\n        if nums.isEmpty { return arr }\\n        \\n        var lhs = 0, rhs = nums.count - 1\\n        \\n        while lhs < rhs {\\n            let mid = lhs + (rhs - lhs) / 2\\n            nums[mid] < t ? (lhs = mid + 1) : (rhs = mid)\\n        }\\n        \\n        guard nums[lhs] == t else { return arr }\\n        arr[0] = lhs\\n        \\n        rhs = nums.count - 1\\n        while lhs < rhs {\\n            let mid = lhs + (rhs - lhs) / 2 + 1\\n            nums[mid] > t ? (rhs = mid - 1) : (lhs = mid)\\n        }\\n        arr[1] = lhs\\n        return arr\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.009 (0.011) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.searchRange([5,7,7,8,8,10], 8)\\n        XCTAssertEqual(value, [3,4])\\n    }\\n    \\n    func test1() {\\n        let value = solution.searchRange([5,7,7,8,8,10], 6)\\n        XCTAssertEqual(value, [-1,-1])\\n    }\\n    \\n    func test2() {\\n        let value = solution.searchRange([], 0)\\n        XCTAssertEqual(value, [-1,-1])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func searchRange(_ nums: [Int], _ t: Int) -> [Int] {\\n        var arr = [-1,-1]\\n        if nums.isEmpty { return arr }\\n        \\n        var lhs = 0, rhs = nums.count - 1\\n        \\n        while lhs < rhs {\\n            let mid = lhs + (rhs - lhs) / 2\\n            nums[mid] < t ? (lhs = mid + 1) : (rhs = mid)\\n        }\\n        \\n        guard nums[lhs] == t else { return arr }\\n        arr[0] = lhs\\n        \\n        rhs = nums.count - 1\\n        while lhs < rhs {\\n            let mid = lhs + (rhs - lhs) / 2 + 1\\n            nums[mid] > t ? (rhs = mid - 1) : (lhs = mid)\\n        }\\n        arr[1] = lhs\\n        return arr\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.searchRange([5,7,7,8,8,10], 8)\\n        XCTAssertEqual(value, [3,4])\\n    }\\n    \\n    func test1() {\\n        let value = solution.searchRange([5,7,7,8,8,10], 6)\\n        XCTAssertEqual(value, [-1,-1])\\n    }\\n    \\n    func test2() {\\n        let value = solution.searchRange([], 0)\\n        XCTAssertEqual(value, [-1,-1])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224587,
                "title": "python-binary-search-bisect-left-and-bisect-right-from-scratch",
                "content": "Offering my two cents of understanding.\\nOverall TC: O( 2 * logN) ~ O(logN)\\nOverall SC: O(1)\\n\\nBisect left finds the leftmost insertion point in the sorted array.\\nE.g. target = 7\\n\\n```\\n5   7   7   8   8    10\\nl           m         r\\nl    m      r                  # nums[mid] < target, hence move right to mid\\nl/m  r\\n    l/r                          # break, return left\\n```\\n\\t\\nBisect right finds the rightmost insertion point in the sorted array.\\nE.g. target = 7\\n```\\n5   7   7   8   8    10\\nl           m         r\\nl    m      r                         # nums[mid] <= target, hence move left = mid + 1. Key difference to find right bound\\n       l/m  r\\n           l/r                          # break, return left\\n```\\n\\nThe only condition where bisect_left and bisect_right will return the same result is if the element does exist in the array.\\nHence we can check if both binary search functions return the same result. If they do, we know the element doesn\\'t exist in the array.\\n\\nIf they are different, then there is at least one occurrence of the element in the array.\\nWe return [left_bound, right_bound - 1] as bisect_right will always return the rightmost insertion point (i.e. index of rightmost occurrence of target + 1).\\n\\nAlso, took me a while to figure this out.\\nFor most binary search variations, the right pointer is initialized with the value of the last index of the sorted array (i.e. right = len(nums) - 1).\\nHowever, in this case, len(nums) is a valid return result due to the behaviour of bisect_right when the element to be inserted is larger than than all elements in the array, or equal to the greatest element in the array.\\n\\n```\\nclass Solution(object):\\n    def bisectLeft(self, nums, target):\\n        \"\"\"\\n        Returns leftmost insertion point that target should be inserted in the sorted array\\n        \"\"\"\\n        left, right = 0, len(nums)\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            \\n            if nums[mid] < target:\\n                left = mid + 1\\n            else:\\n                right = mid\\n            \\n        return left\\n    \\n    def bisectRight(self, nums, target):\\n        \"\"\"\\n        Returns rightmost insertion point that target should be inserted in the sorted array\\n        \"\"\"\\n        left, right = 0, len(nums)\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            \\n            if nums[mid] <= target:\\n                left = mid + 1\\n            else:\\n                right = mid\\n            \\n        return left\\n        \\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(nums) == 0:\\n            return [-1, -1]\\n        \\n        left_bound = self.bisectLeft(nums, target) # O(logN)\\n        right_bound = self.bisectRight(nums, target) # O(logN)\\n        \\n        return [left_bound, right_bound - 1] if left_bound != right_bound else [-1, -1]\\n```",
                "solutionTags": [],
                "code": "```\\n5   7   7   8   8    10\\nl           m         r\\nl    m      r                  # nums[mid] < target, hence move right to mid\\nl/m  r\\n    l/r                          # break, return left\\n```\n```\\n5   7   7   8   8    10\\nl           m         r\\nl    m      r                         # nums[mid] <= target, hence move left = mid + 1. Key difference to find right bound\\n       l/m  r\\n           l/r                          # break, return left\\n```\n```\\nclass Solution(object):\\n    def bisectLeft(self, nums, target):\\n        \"\"\"\\n        Returns leftmost insertion point that target should be inserted in the sorted array\\n        \"\"\"\\n        left, right = 0, len(nums)\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            \\n            if nums[mid] < target:\\n                left = mid + 1\\n            else:\\n                right = mid\\n            \\n        return left\\n    \\n    def bisectRight(self, nums, target):\\n        \"\"\"\\n        Returns rightmost insertion point that target should be inserted in the sorted array\\n        \"\"\"\\n        left, right = 0, len(nums)\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            \\n            if nums[mid] <= target:\\n                left = mid + 1\\n            else:\\n                right = mid\\n            \\n        return left\\n        \\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(nums) == 0:\\n            return [-1, -1]\\n        \\n        left_bound = self.bisectLeft(nums, target) # O(logN)\\n        right_bound = self.bisectRight(nums, target) # O(logN)\\n        \\n        return [left_bound, right_bound - 1] if left_bound != right_bound else [-1, -1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757366,
                "title": "python-clean-binary-search-solution-one-pass-80",
                "content": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        start = 0; end = len(nums)-1\\n        while start <= end:\\n            mid = (start+end) // 2\\n            if nums[start] == nums[end] == target:\\n                return [start, end]\\n            if nums[mid] < target:\\n                start = mid+1\\n            elif nums[mid] > target:\\n                end = mid-1\\n            else:\\n                if nums[start] != target: start += 1\\n                if nums[end] != target: end -= 1\\n        return [-1,-1]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        start = 0; end = len(nums)-1\\n        while start <= end:\\n            mid = (start+end) // 2\\n            if nums[start] == nums[end] == target:\\n                return [start, end]\\n            if nums[mid] < target:\\n                start = mid+1\\n            elif nums[mid] > target:\\n                end = mid-1\\n            else:\\n                if nums[start] != target: start += 1\\n                if nums[end] != target: end -= 1\\n        return [-1,-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512879,
                "title": "c-java-python-javascript-iterative-solution-with-two-binary-searches-with-explanation",
                "content": "# Intuition\\nA binary search algorithm to find the starting and ending indices of a target value in a sorted array. It performs two binary searches: one to find the starting index and another to find the ending index.\\n\\n# Approach\\n1. Initialize the answer vector `ans` with [-1, -1] to represent the starting and ending indices of the target value.\\n2. Initialize `start` as 0, `end` as the last index of the `nums` array.\\n3. Calculate `mid` as the floor division of `(start + end) / 2`.\\n4. Run a binary search loop until `start` becomes greater than `end`.\\n   - Check if the target value is equal to the element at the `mid` index of `nums`.\\n     - If true, update `ans[0]` (starting index) with `mid` and move the `end` pointer to `mid - 1` to continue searching for the leftmost occurrence of the target.\\n     - If false, check if the target value is less than the element at the `mid` index of `nums`.\\n       - If true, update `end` to `mid - 1` to narrow down the search range to the left half.\\n       - If false, update `start` to `mid + 1` to narrow down the search range to the right half.\\n5. Reset `start` to 0 and `end` to the last index of the `nums` array.\\n6. Calculate `mid` as the floor division of `(start + end) / 2`.\\n7. Run another binary search loop until `start` becomes greater than `end`.\\n   - Check if the target value is equal to the element at the `mid` index of `nums`.\\n     - If true, update `ans[1]` (ending index) with `mid` and move the `start` pointer to `mid + 1` to continue searching for the rightmost occurrence of the target.\\n     - If false, check if the target value is less than the element at the `mid` index of `nums`.\\n       - If true, update `end` to `mid - 1` to narrow down the search range to the left half.\\n       - If false, update `start` to `mid + 1` to narrow down the search range to the right half.\\n8. Return the `ans` vector containing the starting and ending indices of the target value.\\n\\n# Complexity\\n- Time complexity: O(log N) since it performs two binary searches on the sorted array `nums`, where N is the size of `nums`.\\n- Space complexity: O(1) since only a constant amount of extra space is used to store the variables.\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans={-1,-1};\\n        //First Occurence\\n        int start=0,end=nums.size()-1;\\n        int mid=(start+end)/2;\\n        while(start<=end){\\n            mid=(start+end)/2;\\n            if(target==nums[mid]){\\n                ans[0]=mid;\\n                end=mid-1;\\n            }\\n            else if(target<nums[mid]){\\n                end=mid-1;\\n            }\\n            else if(target>nums[mid]){\\n                start=mid+1;\\n            }\\n        }\\n        //last occurence\\n        start=0,end=nums.size()-1;\\n        while(start<=end){\\n            mid=(start+end)/2;\\n            if(target==nums[mid]){\\n                ans[1]=mid;\\n                start=mid+1;\\n            }\\n            else if(target<nums[mid]){\\n                end=mid-1;\\n            }\\n            else if(target>nums[mid]){\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] ans = {-1, -1};\\n        // First Occurrence\\n        int start = 0, end = nums.length - 1;\\n        int mid = (start + end) / 2;\\n        while (start <= end) {\\n            mid = (start + end) / 2;\\n            if (target == nums[mid]) {\\n                ans[0] = mid;\\n                end = mid - 1;\\n            } else if (target < nums[mid]) {\\n                end = mid - 1;\\n            } else if (target > nums[mid]) {\\n                start = mid + 1;\\n            }\\n        }\\n        // Last Occurrence\\n        start = 0;\\n        end = nums.length - 1;\\n        while (start <= end) {\\n            mid = (start + end) / 2;\\n            if (target == nums[mid]) {\\n                ans[1] = mid;\\n                start = mid + 1;\\n            } else if (target < nums[mid]) {\\n                end = mid - 1;\\n            } else if (target > nums[mid]) {\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        ans = [-1, -1]\\n        start, end = 0, len(nums) - 1\\n        # First occurrence\\n        while start <= end:\\n            mid = (start + end) / 2\\n            if target == nums[mid]:\\n                ans[0] = mid\\n                end = mid - 1\\n            elif target < nums[mid]:\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n        # Last occurrence\\n        start, end = 0, len(nums) - 1\\n        while start <= end:\\n            mid = (start + end) / 2\\n            if target == nums[mid]:\\n                ans[1] = mid\\n                start = mid + 1\\n            elif target < nums[mid]:\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n        return ans\\n\\n```\\n---\\n# JavaScript\\n```\\nvar searchRange = function(nums, target) {\\n    let ans = [-1, -1];\\n    let start = 0, end = nums.length - 1, mid;\\n    // First occurrence\\n    while (start <= end) {\\n        mid = Math.floor((start + end) / 2);\\n        if (target == nums[mid]) {\\n            ans[0] = mid;\\n            end = mid - 1;\\n        } else if (target < nums[mid]) {\\n            end = mid - 1;\\n        } else {\\n            start = mid + 1;\\n        }\\n    }\\n    // Last occurrence\\n    start = 0;\\n    end = nums.length - 1;\\n    while (start <= end) {\\n        mid = Math.floor((start + end) / 2);\\n        if (target == nums[mid]) {\\n            ans[1] = mid;\\n            start = mid + 1;\\n        } else if (target < nums[mid]) {\\n            end = mid - 1;\\n        } else {\\n            start = mid + 1;\\n        }\\n    }\\n    return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans={-1,-1};\\n        //First Occurence\\n        int start=0,end=nums.size()-1;\\n        int mid=(start+end)/2;\\n        while(start<=end){\\n            mid=(start+end)/2;\\n            if(target==nums[mid]){\\n                ans[0]=mid;\\n                end=mid-1;\\n            }\\n            else if(target<nums[mid]){\\n                end=mid-1;\\n            }\\n            else if(target>nums[mid]){\\n                start=mid+1;\\n            }\\n        }\\n        //last occurence\\n        start=0,end=nums.size()-1;\\n        while(start<=end){\\n            mid=(start+end)/2;\\n            if(target==nums[mid]){\\n                ans[1]=mid;\\n                start=mid+1;\\n            }\\n            else if(target<nums[mid]){\\n                end=mid-1;\\n            }\\n            else if(target>nums[mid]){\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] ans = {-1, -1};\\n        // First Occurrence\\n        int start = 0, end = nums.length - 1;\\n        int mid = (start + end) / 2;\\n        while (start <= end) {\\n            mid = (start + end) / 2;\\n            if (target == nums[mid]) {\\n                ans[0] = mid;\\n                end = mid - 1;\\n            } else if (target < nums[mid]) {\\n                end = mid - 1;\\n            } else if (target > nums[mid]) {\\n                start = mid + 1;\\n            }\\n        }\\n        // Last Occurrence\\n        start = 0;\\n        end = nums.length - 1;\\n        while (start <= end) {\\n            mid = (start + end) / 2;\\n            if (target == nums[mid]) {\\n                ans[1] = mid;\\n                start = mid + 1;\\n            } else if (target < nums[mid]) {\\n                end = mid - 1;\\n            } else if (target > nums[mid]) {\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        ans = [-1, -1]\\n        start, end = 0, len(nums) - 1\\n        # First occurrence\\n        while start <= end:\\n            mid = (start + end) / 2\\n            if target == nums[mid]:\\n                ans[0] = mid\\n                end = mid - 1\\n            elif target < nums[mid]:\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n        # Last occurrence\\n        start, end = 0, len(nums) - 1\\n        while start <= end:\\n            mid = (start + end) / 2\\n            if target == nums[mid]:\\n                ans[1] = mid\\n                start = mid + 1\\n            elif target < nums[mid]:\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n        return ans\\n\\n```\n```\\nvar searchRange = function(nums, target) {\\n    let ans = [-1, -1];\\n    let start = 0, end = nums.length - 1, mid;\\n    // First occurrence\\n    while (start <= end) {\\n        mid = Math.floor((start + end) / 2);\\n        if (target == nums[mid]) {\\n            ans[0] = mid;\\n            end = mid - 1;\\n        } else if (target < nums[mid]) {\\n            end = mid - 1;\\n        } else {\\n            start = mid + 1;\\n        }\\n    }\\n    // Last occurrence\\n    start = 0;\\n    end = nums.length - 1;\\n    while (start <= end) {\\n        mid = Math.floor((start + end) / 2);\\n        if (target == nums[mid]) {\\n            ans[1] = mid;\\n            start = mid + 1;\\n        } else if (target < nums[mid]) {\\n            end = mid - 1;\\n        } else {\\n            start = mid + 1;\\n        }\\n    }\\n    return ans;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437150,
                "title": "best-solution-java-in-runtime-1-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public int[] searchRange(int[] nums, int target) {\\n       int left = 0 ;\\n        int right = nums.length -1;\\n        int output [] = new int[2];\\n            while (left <= right){\\n               if (nums[left] == target){\\n                   output[0] = left;\\n                    while (left < right){\\n                        if (nums[right] == target ){\\n                            output[1] = right;\\n                            return output;\\n                        }else {\\n                            right = right - 1;\\n                        }\\n                    }\\n                    output[1] = left;\\n                   return output;\\n               }else if (nums[left] < target){\\n                   left = left + 1;\\n               }else if (nums[right] > target) {\\n                   right = right - 1;\\n               }\\n\\n            }\\n\\n\\n        return new int[] {-1 , -1};\\n    }\\n}\\n\\n```\\n\\n\\n![b0e5afaa-48ec-4dcc-bd96-e39aa7a524f8_1681948924.2890832.png](https://assets.leetcode.com/users/images/e2a42d89-c9f8-40a3-a1f5-05931328411d_1681972741.4489026.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int[] searchRange(int[] nums, int target) {\\n       int left = 0 ;\\n        int right = nums.length -1;\\n        int output [] = new int[2];\\n            while (left <= right){\\n               if (nums[left] == target){\\n                   output[0] = left;\\n                    while (left < right){\\n                        if (nums[right] == target ){\\n                            output[1] = right;\\n                            return output;\\n                        }else {\\n                            right = right - 1;\\n                        }\\n                    }\\n                    output[1] = left;\\n                   return output;\\n               }else if (nums[left] < target){\\n                   left = left + 1;\\n               }else if (nums[right] > target) {\\n                   right = right - 1;\\n               }\\n\\n            }\\n\\n\\n        return new int[] {-1 , -1};\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1142841,
                "title": "c-with-lower-bound-upper-bound-implementation",
                "content": "While this problem can be solved with 5 lines of C++ code using lower/upper bound STL calls, I thought that in an interview, the interviewer may add additional requirement of implementing those calls. So here it is with the implementation. Note that the STL calls return an interator, in order to keep things simple, I am only returning the index from my implementation.\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if(!nums.size()) return {-1,-1};\\n        auto pos = lower_bound(nums, target);\\n        if(nums[pos] != target)\\n            return {-1,-1};\\n        int l = pos;\\n        pos = upper_bound(nums, target);\\n        if(nums[pos] != target)\\n            pos--;\\n        int r = pos;\\n        return {l,r};\\n    }\\n    int lower_bound(vector<int> nums, int target){\\n        int l = 0, r = nums.size()-1, m = 0;\\n        while(l < r) {\\n            m = (l+r)/2;\\n            if(nums[m] < target)\\n                l = m+1;\\n            else \\n                r = m;\\n        }\\n        return r;\\n    }\\n    int upper_bound(vector<int> nums, int target){\\n        int l = 0, r = nums.size()-1, m = 0;\\n        while(l < r) {\\n            m = (l+r)/2;\\n            if(nums[m] <= target)\\n                l = m+1;\\n            else \\n                r = m;\\n        }\\n        return r;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if(!nums.size()) return {-1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 14877,
                "title": "easy-to-understand-java-ac-solution",
                "content": "I see some of the answers involving two separate methods for finding first index position and last index position. I just combine them into one method and use boolean to check whether it is the last index that we are looking for. \\n\\n\\n    public int[] searchRange(int[] A, int target) {\\n    \\tint start = findPosition(A, target, false);\\n    \\tint end = findPosition(A, target, true);\\n    \\treturn new int[]{start, end};\\n    }\\n\\n    private int findPosition(int[] A, int target, boolean isLast) {\\n    \\tint low = 0, high = A.length-1, index = -1;\\n    \\twhile (low <= high) {\\n    \\t\\tint mid = low + ((high - low) >> 1);\\n    \\t\\tif(isLast){\\n    \\t\\t\\tif (A[mid] <= target) low = mid + 1;\\n    \\t\\t\\telse high = mid-1;\\n    \\t\\t} else{\\n    \\t\\t\\tif (A[mid] < target) low = mid + 1;\\n    \\t\\t\\telse high = mid-1;\\n    \\t\\t}\\n    \\t\\tif(A[mid] == target) index = mid; /** update index */\\n    \\t}\\n    \\treturn index;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "I see some of the answers involving two separate methods for finding first index position and last index position. I just combine them into one method and use boolean to check whether it is the last index that we are looking for. \\n\\n\\n    public int[] searchRange(int[] A, int target) {\\n    \\tint start = findPosition(A, target, false);\\n    \\tint end = findPosition(A, target, true);\\n    \\treturn new int[]{start, end};\\n    }\\n\\n    private int findPosition(int[] A, int target, boolean isLast) {\\n    \\tint low = 0, high = A.length-1, index = -1;\\n    \\twhile (low <= high) {\\n    \\t\\tint mid = low + ((high - low) >> 1);\\n    \\t\\tif(isLast){\\n    \\t\\t\\tif (A[mid] <= target) low = mid + 1;\\n    \\t\\t\\telse high = mid-1;\\n    \\t\\t} else{\\n    \\t\\t\\tif (A[mid] < target) low = mid + 1;\\n    \\t\\t\\telse high = mid-1;\\n    \\t\\t}\\n    \\t\\tif(A[mid] == target) index = mid; /** update index */\\n    \\t}\\n    \\treturn index;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 236386,
                "title": "python-solution",
                "content": "Time complexity: `O(log n)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"            \\n        def search_for(nums, target, left = True):\\n            i = 0\\n            j = len(nums) \\n            while i < j:\\n                mid = (i+j) / 2\\n                if nums[mid] == target:\\n                    if left:\\n                        j = mid \\n                    else:\\n                        i = mid + 1\\n                elif nums[mid] < target:\\n                    i = mid + 1\\n                else:\\n                    j = mid \\n            return i\\n        left = search_for(nums, target, True)\\n        right = search_for(nums, target, False)\\n        if not nums:\\n            return[-1,-1]\\n        elif 0 <= left < len(nums) and nums[left] == target:\\n            return [left, right-1]\\n        else:\\n            return [-1,-1]\\n```\\n\\nA more succinct solution using the built-in methods `bisect_left` and `bisect_right` in the `bisect` module.\\n\\n```\\nclass Solution:\\n    def searchRange(self, nums: \\'List[int]\\', target: \\'int\\') -> \\'List[int]\\':\\n        if not nums:\\n            return [-1, -1]\\n        left = bisect.bisect_left(nums, target)\\n        if left >= len(nums) or nums[left] != target:\\n            return [-1, -1]\\n        right = bisect.bisect_right(nums, target)\\n        return [left, right-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"            \\n        def search_for(nums, target, left = True):\\n            i = 0\\n            j = len(nums) \\n            while i < j:\\n                mid = (i+j) / 2\\n                if nums[mid] == target:\\n                    if left:\\n                        j = mid \\n                    else:\\n                        i = mid + 1\\n                elif nums[mid] < target:\\n                    i = mid + 1\\n                else:\\n                    j = mid \\n            return i\\n        left = search_for(nums, target, True)\\n        right = search_for(nums, target, False)\\n        if not nums:\\n            return[-1,-1]\\n        elif 0 <= left < len(nums) and nums[left] == target:\\n            return [left, right-1]\\n        else:\\n            return [-1,-1]\\n```\n```\\nclass Solution:\\n    def searchRange(self, nums: \\'List[int]\\', target: \\'int\\') -> \\'List[int]\\':\\n        if not nums:\\n            return [-1, -1]\\n        left = bisect.bisect_left(nums, target)\\n        if left >= len(nums) or nums[left] != target:\\n            return [-1, -1]\\n        right = bisect.bisect_right(nums, target)\\n        return [left, right-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14713,
                "title": "search-for-the-position-target-0-5-and-target-0-5-a-simple-python-code-with-a-little-trick",
                "content": "    class Solution:\\n    # @param A, a list of integers\\n    # @param target, an integer to be searched\\n    # @return a list of length 2, [index1, index2]\\n    def searchRange(self, arr, target):\\n        start = self.binary_search(arr, target-0.5)\\n        if arr[start] != target:\\n            return [-1, -1]\\n        arr.append(0)\\n        end = self.binary_search(arr, target+0.5)-1\\n        return [start, end]\\n\\n    def binary_search(self, arr, target):\\n        start, end = 0, len(arr)-1\\n        while start < end:\\n            mid = (start+end)//2\\n            if target < arr[mid]:\\n                end = mid\\n            else:\\n                start = mid+1\\n        return start\\n\\nfor search the target+0.5 position we add something whatever to the list end\\n to get the right position for the edge case\\n\\ntake ([0,1,2,3,4,5], 5) for example:\\n\\nwe append 0 to the list end\\n\\n[0,1,2,3,4,5,0]\\n\\n[4,5,0]# start now is 4, end is 6, mid is 5,  start = mid+1 = 6, end the while loop\\n\\nfinally we get the 5.5 position == start == 6",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @param A, a list of integers\\n    # @param target, an integer to be searched\\n    # @return a list of length 2, [index1, index2]\\n    def searchRange(self, arr, target):\\n        start = self.binary_search(arr, target-0.5)\\n        if arr[start] != target:\\n            return [-1, -1]\\n        arr.append(0)\\n        end = self.binary_search(arr, target+0.5)-1\\n        return [start, end]\\n\\n    def binary_search(self, arr, target):\\n        start, end = 0, len(arr)-1\\n        while start < end:\\n            mid = (start+end)//2\\n            if target < arr[mid]:\\n                end = mid\\n            else:\\n                start = mid+1\\n        return start\\n\\nfor search the target+0.5 position we add something whatever to the list end\\n to get the right position for the edge case\\n\\ntake ([0,1,2,3,4,5], 5) for example:\\n\\nwe append 0 to the list end\\n\\n[0,1,2,3,4,5,0]\\n\\n[4,5,0]# start now is 4, end is 6, mid is 5,  start = mid+1 = 6, end the while loop\\n\\nfinally we get the 5.5 position == start == 6",
                "codeTag": "Java"
            },
            {
                "id": 1596093,
                "title": "34-find-first-and-last-position-of-element-in-sorted-array-java-solution",
                "content": "Brute Force Approach:\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] ans = new int[2];\\n        int start = -1;\\n        int end = -1;\\n        \\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==target){\\n                if(start == -1){\\n                    start = i; \\n                }\\n                end = i;\\n            }\\n            \\n            if(nums[i]>target){\\n                break;\\n            }\\n        }\\n        \\n        \\n        ans[0] = start;\\n        ans[1] = end;\\n        return ans;\\n    }\\n}\\n```\\nOptimal Approach:\\n```\\nclass Solution {\\n\\tpublic int[] searchRange(int[] nums, int target) {\\n\\t\\tint[] ans = new int[2];\\n\\t\\tans[0] = findFirst(nums, target, 0, nums.length - 1);\\n\\t\\tans[1] = findLast(nums, target, 0, nums.length - 1);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate int findFirst(int[] nums, int target, int start, int end) {\\n\\t\\tint position = -1;\\n\\t\\twhile (start <= end) {\\n\\t\\t\\tint mid = (start + end) / 2;\\n            \\n\\t\\t\\tif (nums[mid] >= target) {\\n\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[mid] == target){\\n                position = mid;\\n            }\\n\\t\\t}\\n\\t\\treturn position;\\n\\t}\\n\\n\\tprivate int findLast(int[] nums, int target, int start, int end) {\\n\\t\\tint position = -1;\\n\\t\\twhile (start <= end) {\\n\\t\\t\\tint mid = (start + end) / 2;\\n            \\n\\t\\t\\tif (nums[mid] <= target) {\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[mid] == target){\\n                position = mid;\\n            }\\n\\t\\t}\\n\\t\\treturn position;\\n\\t}\\n}\\n```\\nIf it helped, please UPVOTE. Happy Coding and keep up the good work.\\nFeel free to give your suggestions or correct me in the comments.\\nThanks for reading.\\uD83D\\uDE43",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] ans = new int[2];\\n        int start = -1;\\n        int end = -1;\\n        \\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==target){\\n                if(start == -1){\\n                    start = i; \\n                }\\n                end = i;\\n            }\\n            \\n            if(nums[i]>target){\\n                break;\\n            }\\n        }\\n        \\n        \\n        ans[0] = start;\\n        ans[1] = end;\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\tpublic int[] searchRange(int[] nums, int target) {\\n\\t\\tint[] ans = new int[2];\\n\\t\\tans[0] = findFirst(nums, target, 0, nums.length - 1);\\n\\t\\tans[1] = findLast(nums, target, 0, nums.length - 1);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate int findFirst(int[] nums, int target, int start, int end) {\\n\\t\\tint position = -1;\\n\\t\\twhile (start <= end) {\\n\\t\\t\\tint mid = (start + end) / 2;\\n            \\n\\t\\t\\tif (nums[mid] >= target) {\\n\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[mid] == target){\\n                position = mid;\\n            }\\n\\t\\t}\\n\\t\\treturn position;\\n\\t}\\n\\n\\tprivate int findLast(int[] nums, int target, int start, int end) {\\n\\t\\tint position = -1;\\n\\t\\twhile (start <= end) {\\n\\t\\t\\tint mid = (start + end) / 2;\\n            \\n\\t\\t\\tif (nums[mid] <= target) {\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[mid] == target){\\n                position = mid;\\n            }\\n\\t\\t}\\n\\t\\treturn position;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716664,
                "title": "javascript-clean-binary-search-o-logn",
                "content": "```javascript\\nvar searchRange = function(nums, target) {\\n    let low = 0, high = nums.length-1, mid;\\n    \\n    // find the start\\n    while(low <= high) {\\n        mid = Math.floor((low+high)/2);\\n        if(nums[mid] >= target) high = mid-1;\\n        else low = mid+1;\\n    }\\n    \\n    // if target doesn\\'t exist\\n    if(nums[low] !== target) return [-1, -1];\\n    \\n    const start = low;\\n    \\n    // reset low and high\\n    low = 0, high = nums.length-1;\\n    \\n    // find the end\\n    while(low <= high) {\\n        mid = Math.floor((low+high)/2);\\n        if(nums[mid] <= target) low = mid+1;\\n        else high = mid-1;\\n    }\\n    return [start, high];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```javascript\\nvar searchRange = function(nums, target) {\\n    let low = 0, high = nums.length-1, mid;\\n    \\n    // find the start\\n    while(low <= high) {\\n        mid = Math.floor((low+high)/2);\\n        if(nums[mid] >= target) high = mid-1;\\n        else low = mid+1;\\n    }\\n    \\n    // if target doesn\\'t exist\\n    if(nums[low] !== target) return [-1, -1];\\n    \\n    const start = low;\\n    \\n    // reset low and high\\n    low = 0, high = nums.length-1;\\n    \\n    // find the end\\n    while(low <= high) {\\n        mid = Math.floor((low+high)/2);\\n        if(nums[mid] <= target) low = mid+1;\\n        else high = mid-1;\\n    }\\n    return [start, high];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 15012,
                "title": "python-easy-solution",
                "content": "    class Solution:\\n    # @param A, a list of integers\\n    # @param target, an integer to be searched\\n    # @return a list of length 2, [index1, index2]\\n    def searchRange(self, A, target):\\n\\n        lmost = self.leftsearch(A,target)\\n        rmost = self.rightsearch(A,target)\\n        return[lmost,rmost]\\n                        \\n    def leftsearch(self,A,tar):\\n        l = 0\\n        r = len(A)-1\\n        tarI = -1#target index\\n        while l <= r:\\n            mid = (l+r)/2\\n            if A[mid] > tar:\\n                r = mid - 1\\n            elif A[mid] < tar:\\n                l = mid + 1\\n            else:\\n                tarI = mid\\n                r = mid - 1\\n        return tarI\\n\\n        \\n    def rightsearch(self,A,tar):\\n        l = 0\\n        r = len(A)-1\\n        tarI = -1\\n        while l <= r:\\n            mid = (l+r)/2\\n            if A[mid] > tar:\\n                r = mid -1\\n            elif A[mid] <tar:\\n                l = mid + 1\\n            else:\\n                tarI = mid\\n                l = mid+1\\n        return tarI",
                "solutionTags": [],
                "code": "    class Solution:\\n    # @param A, a list of integers\\n    # @param target, an integer to be searched\\n    # @return a list of length 2, [index1, index2]\\n    def searchRange(self, A, target):\\n\\n        lmost = self.leftsearch(A,target)\\n        rmost = self.rightsearch(A,target)\\n        return[lmost,rmost]\\n                        \\n    def leftsearch(self,A,tar):\\n        l = 0\\n        r = len(A)-1\\n        tarI = -1#target index\\n        while l <= r:\\n            mid = (l+r)/2\\n            if A[mid] > tar:\\n                r = mid - 1\\n            elif A[mid] < tar:\\n                l = mid + 1\\n            else:\\n                tarI = mid\\n                r = mid - 1\\n        return tarI\\n\\n        \\n    def rightsearch(self,A,tar):\\n        l = 0\\n        r = len(A)-1\\n        tarI = -1\\n        while l <= r:\\n            mid = (l+r)/2\\n            if A[mid] > tar:\\n                r = mid -1\\n            elif A[mid] <tar:\\n                l = mid + 1\\n            else:\\n                tarI = mid\\n                l = mid+1\\n        return tarI",
                "codeTag": "Java"
            },
            {
                "id": 1059224,
                "title": "c-super-cool-easy-undersdanding-solution-o-log-n-faster-than-98-19",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> searchRange(vector<int>& nums, int target) {\\n\\t\\t\\tint left = get_first_element_position(nums, target);\\n\\t\\t\\tint right = get_last_element_position(nums, target);\\n\\t\\t\\treturn left <= right ? vector<int>{left, right} : vector<int>(2, -1);\\n\\t\\t}\\n\\tprivate:\\n\\t\\tint get_first_element_position(vector<int>& nums, int target){\\n\\t\\t\\tint left = 0, right = nums.size() - 1, mid;\\n\\t\\t\\twhile ( left <= right )\\n\\t\\t\\t{\\n\\t\\t\\t\\tmid = (right + left) / 2;\\n\\t\\t\\t\\tif ( nums[mid] < target) left = mid + 1;\\n\\t\\t\\t\\telse right = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\treturn left;\\n\\t\\t}\\n\\t\\tint get_last_element_position(vector<int>& nums, int target){\\n\\t\\t\\tint left = 0, right = nums.size() - 1, mid;\\n\\t\\t\\twhile ( left <= right )\\n\\t\\t\\t{\\n\\t\\t\\t\\tmid = (right + left) / 2;\\n\\t\\t\\t\\tif ( nums[mid] <= target ) left = mid + 1;\\n\\t\\t\\t\\telse right = mid - 1;\\n\\t\\t\\t}    \\n\\t\\t\\treturn right;\\n\\t\\t}        \\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> searchRange(vector<int>& nums, int target) {\\n\\t\\t\\tint left = get_first_element_position(nums, target);\\n\\t\\t\\tint right = get_last_element_position(nums, target);\\n\\t\\t\\treturn left <= right ? vector<int>{left, right}",
                "codeTag": "Java"
            },
            {
                "id": 3029684,
                "title": "100-faster-c-binary-search",
                "content": "# Intuition\\nfirst thought came was the linear traversal .we will traverse the vector to find the first and the last position .But vector is sorted so i should take advantage of sorted vector and tried to use binary search.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nI have used binary search. At first find any index (let say \\'position1\\')of the target value and then solve separately for finding first position and the last position of  taget value.First position will always lie in left of the \\'postion1\\'.so we will again use binary search for range(0 to position -1).And for last index again we will solve for tha range(position1 , n-1),where n is the size of the array.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(vector<int>& nums , int l , int r, int target)\\n{\\n    int ans = -1;\\n    while(r >= l){\\n        int mid = (l+r)/2;\\n        if(nums[mid] == target)\\n        {\\n            return mid;\\n        }else{\\n            if(nums[mid] < target){\\n                l = mid+1;\\n            }else{\\n                r = mid-1;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        // int first , last;\\n        //we can solve it in n-time using linear search \\n        // but we can take advantage of sorted array and we will use \\n        //binary search to solve this problem\\n        int n = nums.size();\\n        //finding any position  of target value \\n        int index = solve(nums , 0 , n-1 , target);\\n        int l =index , r = index;\\n        //now solve separately\\n        while(1){\\n            int left = solve(nums,0,l-1,target);\\n            int right = solve(nums,r+1,n-1,target);\\n            if(left == -1 && right == -1){\\n                break;\\n            }\\n            if(left != -1){\\n                l = left;//updating the index that we get from the left side of the index .\\n            }\\n\\n            if(right  != -1){\\n                r = right;//updating the index that we get from the right side of the index\\n            }\\n        }\\n        return {l , r};  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(vector<int>& nums , int l , int r, int target)\\n{\\n    int ans = -1;\\n    while(r >= l){\\n        int mid = (l+r)/2;\\n        if(nums[mid] == target)\\n        {\\n            return mid;\\n        }else{\\n            if(nums[mid] < target){\\n                l = mid+1;\\n            }else{\\n                r = mid-1;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        // int first , last;\\n        //we can solve it in n-time using linear search \\n        // but we can take advantage of sorted array and we will use \\n        //binary search to solve this problem\\n        int n = nums.size();\\n        //finding any position  of target value \\n        int index = solve(nums , 0 , n-1 , target);\\n        int l =index , r = index;\\n        //now solve separately\\n        while(1){\\n            int left = solve(nums,0,l-1,target);\\n            int right = solve(nums,r+1,n-1,target);\\n            if(left == -1 && right == -1){\\n                break;\\n            }\\n            if(left != -1){\\n                l = left;//updating the index that we get from the left side of the index .\\n            }\\n\\n            if(right  != -1){\\n                r = right;//updating the index that we get from the right side of the index\\n            }\\n        }\\n        return {l , r};  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386457,
                "title": "c-solution-with-proper-comments-95-62-faster",
                "content": "**Time complexity - O(log N)**\\n**Space complexity - O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans{-1, -1};\\n    //we have to do two binray search operations \\n        //one for 1st index.\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while( low <= high){\\n            int mid = (low+ high) /2;\\n            if(nums[mid] == target){\\n                ans[0] = mid;\\n                //continue searching in left side of the nums to find 1st index of the given target\\n                high = mid-1;\\n            }else if (nums[mid] < target){\\n                //search in right side of the  nums\\n                 low = mid+1;\\n            }else{\\n                //search in left side of the  nums\\n                high = mid-1;\\n            }\\n        }\\n        //second binary search \\n        //to find the last index of the given target\\n        low = 0;\\n        high = nums.size()-1;\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n            \\n            if(nums[mid] == target){\\n                ans[1] = mid;\\n                //continue searching in right side as we want the last index\\n                low = mid+1;\\n            }else if(nums[mid] < target){\\n                low =  mid+1;\\n            }else high = mid-1;\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans{-1, -1}",
                "codeTag": "Java"
            },
            {
                "id": 1181835,
                "title": "find-first-and-last-position-js-python-java-c-easy-binary-search-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThis problem is very nearly the definition of a **binary search**. A binary search allows us to find the insertion index for a target number in a sorted array. It\\'s called a \"binary\" search because in each step it halves the input array and determines in which half the number belongs. Since a binary search is able to eliminate half the remaining array in each iteration, it can accomplish its objective with a **time complexity** of **O(log N)**.\\n\\nIn this case, however, we don\\'t just want to find out where the target number (**T**) would be placed in the nums array (**N**), we want to additionally find out if **T** _actually_ exists in **N**, as well as the starting and end indexes.\\n\\nThe standard implementation of a binary search will find the left-most index in which **T** could be placed, though many languages have functions for both sides. Rather than having to define two sets of functions here, however, we can, with a little creativity, use a single function to find our answer.\\n\\nFirst, we can perform the standard left binary search (**find**) on **T**. Next, we can easily check to see if **T** exists in **N** already by checking the value stored at the result of that first search (**N[Tleft]**). If we don\\'t find **T** at that index, then **T** does not exist in **N** and we should **return [-1, -1]**.\\n\\nOtherwise, we still need to find the right end of the range of **T** values in **N**. To do this, we can just use **find** again, this time with the next integer (**T + 1**). Since this will find the index _after_ the end of the range of **T** values, we can just move back one position to find the end of the **T** range.\\n\\nNow that we have our range, we can **return** it.\\n\\n - _**Time Complexity: O(log N)** for the binary search_\\n - _**Space Complexity: O(1)**_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython has built-in binary search functions for both sides: **bisect_left()** and **bisect_right()**.\\n\\nThe built-in function for Java, **Arrays.binarySearch()** does not find the left-most insertion point, so it\\'s easier to define our own binary search function.\\n\\nC++ can use the built-in function **equal_range()**, which returns iterator pointers to the range of T values.\\n\\n---\\n\\n#### ***Javascript Code:***\\n```javascript\\nvar searchRange = function(N, T) {\\n    const find = (target, arr, left=0, right=arr.length) => {\\n        while (left <= right) {\\n            let mid = left + right >> 1\\n            if (arr[mid] < target) left = mid + 1\\n            else right = mid - 1\\n        }\\n        return left\\n    } \\n    let Tleft = find(T, N)\\n    if (N[Tleft] !== T) return [-1,-1]\\n    return [Tleft, find(T+1, N, Tleft) - 1]\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\n\\n##### ***w/ bisect_left() & bisect_right():***\\n```python\\nclass Solution:\\n    def searchRange(self, N: List[int], T: int) -> List[int]:\\n        Tleft = bisect_left(N, T)\\n        if Tleft == len(N) or N[Tleft] != T: return [-1, -1]\\n        return [Tleft, bisect_right(N, T) - 1]\\n```\\n##### ***w/ Custom Binary Search:***\\n```python\\nclass Solution:\\n    def searchRange(self, N: List[int], T: int) -> List[int]:\\n        def find(target, arr, left=0):\\n            right = len(arr) - 1\\n            while left <= right:\\n                mid = left + right >> 1\\n                if arr[mid] < target: left = mid + 1\\n                else: right = mid - 1\\n            return left\\n        Tleft = find(T, N)\\n        if Tleft == len(N) or N[Tleft] != T: return [-1, -1]\\n        return [Tleft, find(T+1, N, Tleft) - 1]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    public int[] searchRange(int[] N, int T) {\\n        int Tleft = find(T, N, 0);\\n        if (Tleft == N.length || N[Tleft] != T) return new int[] {-1, -1};\\n        return new int[] {Tleft, find(T+1, N, Tleft) - 1};\\n    }\\n    public int find(int target, int[] arr, int left) {\\n        int right = arr.length - 1;\\n        while (left <= right) {\\n            int mid = left + right >> 1;\\n            if (arr[mid] < target) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return left;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\n##### ***w/ equal_range():***\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& N, int T) {\\n        pair<vector<int>::iterator,vector<int>::iterator> range;\\n        range = equal_range(N.begin(), N.end(), T);\\n        int Tleft = distance(N.begin(), range.first);\\n        if (Tleft == N.size() || N[Tleft] != T) return {-1, -1};\\n        return {Tleft, (int)distance(N.begin(), range.second) - 1};\\n    }\\n};\\n```\\n##### ***w/ Custom Binary Search:***\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& N, int T) {\\n        int Tleft = find(T, N);\\n        if (Tleft == N.size() || N[Tleft] != T) return {-1, -1};\\n        return {Tleft, find(T+1, N, Tleft) - 1};\\n    }\\n    int find(int target, vector<int> arr, int left=0) {\\n        int right = arr.size() - 1;\\n        while (left <= right) {\\n            int mid = left + right >> 1;\\n            if (arr[mid] < target) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar searchRange = function(N, T) {\\n    const find = (target, arr, left=0, right=arr.length) => {\\n        while (left <= right) {\\n            let mid = left + right >> 1\\n            if (arr[mid] < target) left = mid + 1\\n            else right = mid - 1\\n        }\\n        return left\\n    } \\n    let Tleft = find(T, N)\\n    if (N[Tleft] !== T) return [-1,-1]\\n    return [Tleft, find(T+1, N, Tleft) - 1]\\n};\\n```\n```python\\nclass Solution:\\n    def searchRange(self, N: List[int], T: int) -> List[int]:\\n        Tleft = bisect_left(N, T)\\n        if Tleft == len(N) or N[Tleft] != T: return [-1, -1]\\n        return [Tleft, bisect_right(N, T) - 1]\\n```\n```python\\nclass Solution:\\n    def searchRange(self, N: List[int], T: int) -> List[int]:\\n        def find(target, arr, left=0):\\n            right = len(arr) - 1\\n            while left <= right:\\n                mid = left + right >> 1\\n                if arr[mid] < target: left = mid + 1\\n                else: right = mid - 1\\n            return left\\n        Tleft = find(T, N)\\n        if Tleft == len(N) or N[Tleft] != T: return [-1, -1]\\n        return [Tleft, find(T+1, N, Tleft) - 1]\\n```\n```java\\nclass Solution {\\n    public int[] searchRange(int[] N, int T) {\\n        int Tleft = find(T, N, 0);\\n        if (Tleft == N.length || N[Tleft] != T) return new int[] {-1, -1};\\n        return new int[] {Tleft, find(T+1, N, Tleft) - 1};\\n    }\\n    public int find(int target, int[] arr, int left) {\\n        int right = arr.length - 1;\\n        while (left <= right) {\\n            int mid = left + right >> 1;\\n            if (arr[mid] < target) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return left;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& N, int T) {\\n        pair<vector<int>::iterator,vector<int>::iterator> range;\\n        range = equal_range(N.begin(), N.end(), T);\\n        int Tleft = distance(N.begin(), range.first);\\n        if (Tleft == N.size() || N[Tleft] != T) return {-1, -1};\\n        return {Tleft, (int)distance(N.begin(), range.second) - 1};\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& N, int T) {\\n        int Tleft = find(T, N);\\n        if (Tleft == N.size() || N[Tleft] != T) return {-1, -1};\\n        return {Tleft, find(T+1, N, Tleft) - 1};\\n    }\\n    int find(int target, vector<int> arr, int left=0) {\\n        int right = arr.size() - 1;\\n        while (left <= right) {\\n            int mid = left + right >> 1;\\n            if (arr[mid] < target) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495416,
                "title": "java-100-faster-solution-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(log N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/330c50ec-0973-4531-9790-af5b88e11668_1683436609.7289596.png)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n\\n        int[] result = new int[2];\\n        result[0] = searchFirst(nums, target);\\n        result[1] = searchLast(nums, target);\\n\\n        return result;\\n    }\\n\\n    // binary search to find the first occurrence of the target\\n    private int searchFirst(int[] nums, int target){\\n        int left = 0; // left index\\n        int right = nums.length - 1; // right index\\n        int index = -1; // index of the first occurrence\\n\\n        while(left <= right){\\n\\n            int mid = left + (right - left) / 2; // calculate the mid index\\n\\n            if(nums[mid] == target){\\n                index = mid; // update index of the first occurrence\\n                right = mid - 1; // search in the left half\\n            }\\n\\n            else if(nums[mid] < target){\\n                left = mid + 1; // search in the right half\\n            }\\n            else{\\n                right = mid - 1; // search in the left half\\n            }\\n        }\\n\\n        return index;\\n    }\\n\\n    // binary search to find the last occurrence of the target\\n    private int searchLast(int[] nums, int target){\\n        int left = 0; // left index\\n        int right = nums.length - 1; // right index\\n        int index = -1; // index of the last occurrence\\n\\n        while(left <= right){\\n\\n            int mid = left + (right - left) / 2; // calculate the mid index\\n\\n            if(nums[mid] == target){\\n                index = mid; // update index of the last occurrence\\n                left = mid + 1; // search in the right half\\n            }\\n\\n            else if(nums[mid] < target){\\n                left = mid + 1; // search in the right half\\n            }\\n            else{\\n                right = mid - 1; // search in the left half\\n            }\\n        }\\n\\n        return index;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n\\n        int[] result = new int[2];\\n        result[0] = searchFirst(nums, target);\\n        result[1] = searchLast(nums, target);\\n\\n        return result;\\n    }\\n\\n    // binary search to find the first occurrence of the target\\n    private int searchFirst(int[] nums, int target){\\n        int left = 0; // left index\\n        int right = nums.length - 1; // right index\\n        int index = -1; // index of the first occurrence\\n\\n        while(left <= right){\\n\\n            int mid = left + (right - left) / 2; // calculate the mid index\\n\\n            if(nums[mid] == target){\\n                index = mid; // update index of the first occurrence\\n                right = mid - 1; // search in the left half\\n            }\\n\\n            else if(nums[mid] < target){\\n                left = mid + 1; // search in the right half\\n            }\\n            else{\\n                right = mid - 1; // search in the left half\\n            }\\n        }\\n\\n        return index;\\n    }\\n\\n    // binary search to find the last occurrence of the target\\n    private int searchLast(int[] nums, int target){\\n        int left = 0; // left index\\n        int right = nums.length - 1; // right index\\n        int index = -1; // index of the last occurrence\\n\\n        while(left <= right){\\n\\n            int mid = left + (right - left) / 2; // calculate the mid index\\n\\n            if(nums[mid] == target){\\n                index = mid; // update index of the last occurrence\\n                left = mid + 1; // search in the right half\\n            }\\n\\n            else if(nums[mid] < target){\\n                left = mid + 1; // search in the right half\\n            }\\n            else{\\n                right = mid - 1; // search in the left half\\n            }\\n        }\\n\\n        return index;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330070,
                "title": "c-solution-binary-search-o-log-n-time",
                "content": "if you solve this problem using STL (upper_bound , lower_bound) then traversal may take O(n) time. to make it time efficient we use binary search with writing some extra line of code like when we find the target  , we instantly not return the mid , we search it\\'s left and right occurances to find the first and last occurance of target.\\n```\\nclass Solution {\\n    //find the first position of target.....\\n    int first_pos(int start , int end , vector<int>& nums , int target)\\n    {\\n        int result = -1;    // make a variable to stroe the index of first occurance.\\n        while(start <= end)\\n        {\\n            int mid = start + (end - start)/2;  \\n            if(nums[mid] == target)\\n            { \\n                result = mid;  //if we find the target at mid position then we store the mid in result variable.\\n                end = mid - 1;  //and continue to find the first occurance in the left of mid and if we find we update the result.\\n            }\\n            else if(nums[mid] > target)\\n                end = mid - 1;\\n            else\\n                start = mid + 1;\\n        }\\n        return result;\\n    }\\n    \\n    //find the last position of target.....\\n    int last_pos(int start , int end , vector<int>& nums , int target)\\n    {\\n        int result = -1;    // make a variable to stroe the index of first occurance.\\n        while(start <= end) \\n        {\\n            int mid = start + (end - start)/2;\\n            if(nums[mid] == target)\\n            {\\n                result = mid;   //if we find the target at mid position then we store the mid in result variable.\\n                start = mid + 1;    //and continue to find the last occurance in the right of mid and if we find we update the result.\\n            }\\n            else if(nums[mid] >= target)\\n                end = mid - 1;\\n            else\\n                start = mid + 1;\\n        }\\n        return result;\\n    }\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int start = 0 , end = n - 1;\\n        vector<int>ans(2);\\n        ans[0] = first_pos(start , end , nums , target);\\n        ans[1] = last_pos(start , end , nums , target);\\n        return ans;\\n    }\\n};\\n```\\ni hope you like this solution and upvote it.",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    //find the first position of target.....\\n    int first_pos(int start , int end , vector<int>& nums , int target)\\n    {\\n        int result = -1;    // make a variable to stroe the index of first occurance.\\n        while(start <= end)\\n        {\\n            int mid = start + (end - start)/2;  \\n            if(nums[mid] == target)\\n            { \\n                result = mid;  //if we find the target at mid position then we store the mid in result variable.\\n                end = mid - 1;  //and continue to find the first occurance in the left of mid and if we find we update the result.\\n            }\\n            else if(nums[mid] > target)\\n                end = mid - 1;\\n            else\\n                start = mid + 1;\\n        }\\n        return result;\\n    }\\n    \\n    //find the last position of target.....\\n    int last_pos(int start , int end , vector<int>& nums , int target)\\n    {\\n        int result = -1;    // make a variable to stroe the index of first occurance.\\n        while(start <= end) \\n        {\\n            int mid = start + (end - start)/2;\\n            if(nums[mid] == target)\\n            {\\n                result = mid;   //if we find the target at mid position then we store the mid in result variable.\\n                start = mid + 1;    //and continue to find the last occurance in the right of mid and if we find we update the result.\\n            }\\n            else if(nums[mid] >= target)\\n                end = mid - 1;\\n            else\\n                start = mid + 1;\\n        }\\n        return result;\\n    }\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int start = 0 , end = n - 1;\\n        vector<int>ans(2);\\n        ans[0] = first_pos(start , end , nums , target);\\n        ans[1] = last_pos(start , end , nums , target);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718714,
                "title": "3-lines-c-o-logn-solution",
                "content": "```\\nvector<int> searchRange(vector<int>& nums, int tar) {\\n\\tif(binary_search(nums.begin(),nums.end(),tar)==false)return {-1,-1};\\n    int lb = lower_bound(nums.begin(), nums.end(), tar) - nums.begin(), ub = upper_bound(nums.begin(),nums.end(),tar)-nums.begin()-1;\\n    return {lb, ub};\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nvector<int> searchRange(vector<int>& nums, int tar) {\\n\\tif(binary_search(nums.begin(),nums.end(),tar)==false)return {-1,-1};\\n    int lb = lower_bound(nums.begin(), nums.end(), tar) - nums.begin(), ub = upper_bound(nums.begin(),nums.end(),tar)-nums.begin()-1;\\n    return {lb, ub};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 681690,
                "title": "iterative-java-binary-search-solution-faster-than-100",
                "content": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Find First and Last Position of Element in Sorted Array.\\nMemory Usage: 42.8 MB, less than 49.61% of Java online submissions for Find First and Last Position of Element in Sorted Array.\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] res=new int[2];\\n        res[0]=findSidx(nums,target);\\n        res[1]=findEidx(nums,target);\\n        return res;\\n    }\\n    public int findSidx(int[] nums,int target){\\n        int left=0;\\n        int right=nums.length-1;\\n        int idx=-1;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            if(nums[mid]==target)idx=mid;\\n            if(target>nums[mid]){\\n                left=mid+1;\\n            }\\n            else{\\n                right=mid-1;\\n            }\\n        }\\n        return idx;\\n    }\\n    public int findEidx(int[] nums,int target){\\n        int left=0;\\n        int right=nums.length-1;\\n        int idx=-1;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            if(nums[mid]==target)idx=mid;\\n            if(target>=nums[mid]){\\n                left=mid+1;\\n            }\\n            else{\\n                right=mid-1;\\n            }\\n        }\\n        return idx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] res=new int[2];\\n        res[0]=findSidx(nums,target);\\n        res[1]=findEidx(nums,target);\\n        return res;\\n    }\\n    public int findSidx(int[] nums,int target){\\n        int left=0;\\n        int right=nums.length-1;\\n        int idx=-1;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            if(nums[mid]==target)idx=mid;\\n            if(target>nums[mid]){\\n                left=mid+1;\\n            }\\n            else{\\n                right=mid-1;\\n            }\\n        }\\n        return idx;\\n    }\\n    public int findEidx(int[] nums,int target){\\n        int left=0;\\n        int right=nums.length-1;\\n        int idx=-1;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            if(nums[mid]==target)idx=mid;\\n            if(target>=nums[mid]){\\n                left=mid+1;\\n            }\\n            else{\\n                right=mid-1;\\n            }\\n        }\\n        return idx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14706,
                "title": "beats-100-python-submission",
                "content": "```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        n = len(nums)\\n        left, right = -1, -1\\n        l, r = 0, n-1\\n        while l < r:\\n            m = (l+r)/2\\n            if nums[m] < target: l = m+1\\n            else: r = m\\n        if nums[l] != target: return -1, -1\\n        left = l\\n        l, r = left, n-1\\n        while l < r:\\n            m = (l+r)/2+1\\n            if nums[m] == target: l = m\\n            else: r = m-1\\n        right = l\\n        return left, right\\n```\\n![0_1473134524961_Screen Shot 2016-09-05 at 11.58.29 PM.png](/uploads/files/1473134525895-screen-shot-2016-09-05-at-11.58.29-pm.png)",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        n = len(nums)\\n        left, right = -1, -1\\n        l, r = 0, n-1\\n        while l < r:\\n            m = (l+r)/2\\n            if nums[m] < target: l = m+1\\n            else: r = m\\n        if nums[l] != target: return -1, -1\\n        left = l\\n        l, r = left, n-1\\n        while l < r:\\n            m = (l+r)/2+1\\n            if nums[m] == target: l = m\\n            else: r = m-1\\n        right = l\\n        return left, right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329232,
                "title": "c-0ms-binary-search",
                "content": "**Time Complexity :- O(Log(n))\\nSpace Complexity :- O(1)**\\n\\n1. \\tFor the first occurrence: Binary search till the element is found. When the element is found, Go to its left side.       Because there could be a duplicate element whose first occurrence will be on its left side.\\n2. \\tFor the last occurrence: Binary search till the element is found.When the element is found, Go to its right side.           Because there could be a duplicate element whose last occurrence will be on its right side.\\n\\nclass Solution {\\npublic:\\n\\n    int getIndex(vector<int>& nums, int target, bool getFirst){\\n        int s = 0;\\n        int e = nums.size()-1;\\n        int ans = -1;\\n        while(s<=e) {\\n            int mid = s + (e-s)/2;\\n            if(nums[mid] == target){\\n                ans = mid;           // storing answer then start searching again \\n                if(getFirst)  e = mid - 1;     // we have to go left side for first position\\n                else\\ts = mid + 1;   //   we have to go right side for last positon                   \\n\\t\\t    }\\n\\t\\t\\telse if(nums[mid] > target) e = mid - 1;\\n            else   s= mid + 1;\\n        }\\n        return ans;   \\n    }\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>  v(2 , -1);\\n        \\n        int first = getIndex(nums, target, true);\\n        if(first == -1)  return v;\\n        int last = getIndex(nums, target, false);\\n        v[0] = first;\\n        v[1] = last;\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int getIndex(vector<int>& nums, int target, bool getFirst){\\n        int s = 0;\\n        int e = nums.size()-1;\\n        int ans = -1;\\n        while(s<=e) {\\n            int mid = s + (e-s)/2;\\n            if(nums[mid] == target){\\n                ans = mid;           // storing answer then start searching again \\n                if(getFirst)  e = mid - 1;     // we have to go left side for first position\\n                else\\ts = mid + 1;   //   we have to go right side for last positon                   \\n\\t\\t    }",
                "codeTag": "Java"
            },
            {
                "id": 2329216,
                "title": "daily-leetcoding-challenge-july-day-25",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1667541,
                "title": "java-0ms-100-faster-o-log-n",
                "content": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int l = 0;\\n        int r = nums.length-1;\\n        while(l <= r){\\n            int mid = (l+r)/2;            \\n            if(nums[mid] == target){\\n                if(nums[l] == target && nums[r] == target){\\n                    return new int[]{l,r};\\n                }\\n                if(nums[l] < target){\\n                    l++;\\n                }\\n                if(nums[r] > target){\\n                    r--;\\n                }\\n            } else if(target < nums[mid]){\\n                r = mid-1;\\n            } else {\\n                l = mid+1;\\n            }\\n        }\\n        return new int[]{-1,-1};   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int l = 0;\\n        int r = nums.length-1;\\n        while(l <= r){\\n            int mid = (l+r)/2;            \\n            if(nums[mid] == target){\\n                if(nums[l] == target && nums[r] == target){\\n                    return new int[]{l,r};\\n                }\\n                if(nums[l] < target){\\n                    l++;\\n                }\\n                if(nums[r] > target){\\n                    r--;\\n                }\\n            } else if(target < nums[mid]){\\n                r = mid-1;\\n            } else {\\n                l = mid+1;\\n            }\\n        }\\n        return new int[]{-1,-1};   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855788,
                "title": "most-optimal-solution-using-plain-binary-search-with-few-tweaks-c-and-java-code",
                "content": "\\n\\n# Approach\\nThe first function finds the first occurrence of the target key in the array. It uses a modified binary search, where it updates the ans variable whenever it finds the target and then continues searching in the left half of the array to find the first occurrence.\\n\\nThe last function finds the last occurrence of the target key in the array. Similar to the first function, it uses a modified binary search to update the ans variable whenever it finds the target and then continues searching in the right half of the array to find the last occurrence.\\n\\nFinally, the searchRange function returns a vector containing the results of the first and last functions, representing the range of occurrences of the target key in the sorted array. If the target is not found, the ans variable remains -1, and the function returns {-1, -1} indicating that the target is not present in the array.\\n\\n# Complexity\\n- Time complexity:\\n2*O(log(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int first(vector<int>& nums, int target) {\\n        int ans = -1;\\n        int low = 0, high = nums.size()-1;\\n        while(low<=high) {\\n            int mid = (low+high)/2;\\n            if(nums[mid] == target) {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else if(nums[mid]<target) low = mid+1;\\n            else high = mid-1;\\n        }\\n        return ans;\\n    }\\n    int last(vector<int>& nums, int target) {\\n        int ans = -1;\\n        int low = 0, high = nums.size()-1;\\n        while(low<=high) {\\n            int mid = (low+high)/2;\\n            if(nums[mid] == target) {\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else if(nums[mid]<target) low = mid+1;\\n            else high = mid-1;\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        return {first(nums,target), last(nums,target)};\\n    }\\n};\\n```\\n# JAVA Code\\n```\\nclass Solution {\\n    public int first(int[] nums, int target) {\\n        int ans = -1;\\n        int low = 0, high = nums.length - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                ans = mid;\\n                high = mid - 1;\\n            } else if (nums[mid] < target) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int last(int[] nums, int target) {\\n        int ans = -1;\\n        int low = 0, high = nums.length - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                ans = mid;\\n                low = mid + 1;\\n            } else if (nums[mid] < target) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        return new int[]{first(nums, target), last(nums, target)};\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int first(vector<int>& nums, int target) {\\n        int ans = -1;\\n        int low = 0, high = nums.size()-1;\\n        while(low<=high) {\\n            int mid = (low+high)/2;\\n            if(nums[mid] == target) {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else if(nums[mid]<target) low = mid+1;\\n            else high = mid-1;\\n        }\\n        return ans;\\n    }\\n    int last(vector<int>& nums, int target) {\\n        int ans = -1;\\n        int low = 0, high = nums.size()-1;\\n        while(low<=high) {\\n            int mid = (low+high)/2;\\n            if(nums[mid] == target) {\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else if(nums[mid]<target) low = mid+1;\\n            else high = mid-1;\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        return {first(nums,target), last(nums,target)};\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int first(int[] nums, int target) {\\n        int ans = -1;\\n        int low = 0, high = nums.length - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                ans = mid;\\n                high = mid - 1;\\n            } else if (nums[mid] < target) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int last(int[] nums, int target) {\\n        int ans = -1;\\n        int low = 0, high = nums.length - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                ans = mid;\\n                low = mid + 1;\\n            } else if (nums[mid] < target) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        return new int[]{first(nums, target), last(nums, target)};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311417,
                "title": "100-easiest-and-systematic-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be optimally solved using Binary Search. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is quite easy to understand. The solution that employs Binary Search to solve this particular problem uses the concept of Binary Search ***twice*** - 1st to get the starting index and 2nd to search the ending index.\\n\\n# Complexity\\n- Time complexity: `O(log n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size()-1;\\n        int start = -1, end = -1;\\n\\n        // Searching the start index of target\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(nums[mid] < target){ low = mid+1; }\\n            else if(nums[mid] > target){ high = mid-1; }\\n            else{   // nums[mid] == target\\n                start = mid;\\n                high = mid-1;\\n            }\\n        }\\n        \\n        // Searching the end index of target\\n        if(start!=-1){\\n            low = 0, high = nums.size()-1;\\n            while(low<=high){\\n                int mid = low + (high-low)/2;\\n                if(nums[mid] < target){ low = mid+1; }\\n                else if(nums[mid] > target){ high = mid-1; }\\n                else{   // nums[mid] == target\\n                    end = mid;\\n                    low = mid+1;\\n                }\\n            }\\n        }\\n\\n        return {start, end};\\n    }\\n\\n    // Author - Mufaddal Saifuddin\\n};\\n```\\n# Request\\n\\nPlease upvote my solution if you liked it.\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size()-1;\\n        int start = -1, end = -1;\\n\\n        // Searching the start index of target\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(nums[mid] < target){ low = mid+1; }\\n            else if(nums[mid] > target){ high = mid-1; }\\n            else{   // nums[mid] == target\\n                start = mid;\\n                high = mid-1;\\n            }\\n        }\\n        \\n        // Searching the end index of target\\n        if(start!=-1){\\n            low = 0, high = nums.size()-1;\\n            while(low<=high){\\n                int mid = low + (high-low)/2;\\n                if(nums[mid] < target){ low = mid+1; }\\n                else if(nums[mid] > target){ high = mid-1; }\\n                else{   // nums[mid] == target\\n                    end = mid;\\n                    low = mid+1;\\n                }\\n            }\\n        }\\n\\n        return {start, end};\\n    }\\n\\n    // Author - Mufaddal Saifuddin\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163324,
                "title": "best-and-simplest-c-solution-using-only-while-loop-super-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n=nums.size(),l=0,r=n-1; \\n        vector<int>v(2,-1);\\n        //for initial index\\n        while(l<=r){\\n            int m=(r+l)/2;\\n            if (nums[m]<target) l=m+1;\\n            else if(nums[m]>target) r=m-1;\\n            else {\\n            if(m==0 || nums[m]!=nums[m-1]) {v[0]=m; break;}\\n            else r=m-1;\\n            }\\n        }\\n        // for ending index\\n        l=0;r=n-1;\\n        while(l<=r){\\n            int m=(r+l)/2;\\n            if (nums[m]<target) l=m+1;\\n            else if(nums[m]>target) r=m-1;\\n            else {\\n            if(m==n-1 || nums[m]!=nums[m+1]) {v[1]=m; break;}\\n            else l=m+1;\\n            }\\n        }\\n        return v;\\n\\n        \\n    }\\n};\\nDo upvote if you like\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n=nums.size(),l=0,r=n-1; \\n        vector<int>v(2,-1);\\n        //for initial index\\n        while(l<=r){\\n            int m=(r+l)/2;\\n            if (nums[m]<target) l=m+1;\\n            else if(nums[m]>target) r=m-1;\\n            else {\\n            if(m==0 || nums[m]!=nums[m-1]) {v[0]=m; break;}\\n            else r=m-1;\\n            }\\n        }\\n        // for ending index\\n        l=0;r=n-1;\\n        while(l<=r){\\n            int m=(r+l)/2;\\n            if (nums[m]<target) l=m+1;\\n            else if(nums[m]>target) r=m-1;\\n            else {\\n            if(m==n-1 || nums[m]!=nums[m+1]) {v[1]=m; break;}\\n            else l=m+1;\\n            }\\n        }\\n        return v;\\n\\n        \\n    }\\n};\\nDo upvote if you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004815,
                "title": "super-easily-understandable-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Binary Search\\n\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n     int[] arr=new int[2];\\n        arr[0]=findFirst(nums,target);\\n        arr[1]=findLast(nums,target);\\n        return arr;\\n    }\\n    public int findFirst(int[] arr,int target){\\n        int index=-1;\\n        int low=0;\\n        int high=arr.length-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(arr[mid]==target){\\n                index=mid;\\n                high=mid-1;\\n            }   \\n            else if(arr[mid]>target)\\n                high=mid-1;\\n             else\\n                low=mid+1;\\n        }\\n        return index;\\n    }\\n      public int findLast(int[] arr,int target){\\n        int index=-1;\\n        int low=0;\\n        int high=arr.length-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(arr[mid]==target){\\n                index=mid;\\n                low=mid+1;\\n            }   \\n            else if(arr[mid]>target)\\n                high=mid-1;\\n             else\\n                low=mid+1;\\n        }\\n        return index; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n     int[] arr=new int[2];\\n        arr[0]=findFirst(nums,target);\\n        arr[1]=findLast(nums,target);\\n        return arr;\\n    }\\n    public int findFirst(int[] arr,int target){\\n        int index=-1;\\n        int low=0;\\n        int high=arr.length-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(arr[mid]==target){\\n                index=mid;\\n                high=mid-1;\\n            }   \\n            else if(arr[mid]>target)\\n                high=mid-1;\\n             else\\n                low=mid+1;\\n        }\\n        return index;\\n    }\\n      public int findLast(int[] arr,int target){\\n        int index=-1;\\n        int low=0;\\n        int high=arr.length-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(arr[mid]==target){\\n                index=mid;\\n                low=mid+1;\\n            }   \\n            else if(arr[mid]>target)\\n                high=mid-1;\\n             else\\n                low=mid+1;\\n        }\\n        return index; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15046,
                "title": "readable-c-11-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> searchRange(int A[], int n, int target) {\\n            vector<int> ans(2);\\n            ans[0] = lowerBound(A, A + n, target) - A;\\n            ans[1] = upperBound(A, A + n, target) - A - 1;\\n            if (ans[0] > ans[1]) {\\n                ans[0] = ans[1] = -1;\\n            }\\n            return ans;\\n        }\\n        \\n        int *lowerBound(int *a, int *b, int target)\\n        {\\n            return binarySearch(a, b, target, [](int a, int b) { return a < b; });\\n        }\\n        \\n        int *upperBound(int *a, int *b, int target)\\n        {\\n            return binarySearch(a, b, target, [](int a, int b) { return a <= b; });\\n        }\\n        \\n        int *binarySearch(int *a ,int *b, int target, function<bool(int, int) > cmp)\\n        {\\n            int l = 0, r = b - a;\\n            while (l < r) { \\n                int mid = l + ((r - l) >> 1);\\n                if (cmp(a[mid], target)) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid;\\n                }\\n            }\\n            return a + l;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> searchRange(int A[], int n, int target) {\\n            vector<int> ans(2);\\n            ans[0] = lowerBound(A, A + n, target) - A;\\n            ans[1] = upperBound(A, A + n, target) - A - 1;\\n            if (ans[0] > ans[1]) {\\n                ans[0] = ans[1] = -1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4015304,
                "title": "fast-c-solution",
                "content": "# **PLEASE UPVOTE MY SOLUTION IG YOU LIKE IT**\\n# **CONNECT WITH ME**\\n# **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n# **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\nInitialize two variables, first and last, to store the indices of the first and last occurrences of the target element. Initially, set them to -1, indicating that no occurrences have been found yet.\\n\\nUse binary search to find the first occurrence of the target element:\\n\\nInitialize left to 0 and right to nums.size() - 1.\\nWhile left is less than or equal to right, do the following:\\nCalculate the middle index mid as (left + right) / 2.\\nIf nums[mid] is equal to the target element, update first to mid and search in the left half by setting right = mid - 1.\\nIf nums[mid] is less than the target element, set left = mid + 1.\\nIf nums[mid] is greater than the target element, set right = mid - 1.\\nUse binary search to find the last occurrence of the target element:\\n\\nReset left to 0 and right to nums.size() - 1.\\nWhile left is less than or equal to right, do the following:\\nCalculate the middle index mid as (left + right) / 2.\\nIf nums[mid] is equal to the target element, update last to mid and search in the right half by setting left = mid + 1.\\nIf nums[mid] is less than the target element, set left = mid + 1.\\nIf nums[mid] is greater than the target element, set right = mid - 1.\\nAfter both binary searches are complete, first and last will hold the indices of the first and last occurrences of the target element, respectively.\\n\\nReturn the pair [first, last] as the result.\\n\\nThis approach ensures that you efficiently find the first and last occurrences of the target element in the sorted array using binary search.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(log n) EVEN IN WORST TIME \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> result = {-1, -1};\\n\\n        // Find the first occurrence of target\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) {\\n                result[0] = mid;\\n                right = mid - 1;  // Continue searching on the left side\\n            } else if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        // Find the last occurrence of target\\n        left = 0;\\n        right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) {\\n                result[1] = mid;\\n                left = mid + 1;   // Continue searching on the right side\\n            } else if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> result = {-1, -1};\\n\\n        // Find the first occurrence of target\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) {\\n                result[0] = mid;\\n                right = mid - 1;  // Continue searching on the left side\\n            } else if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        // Find the last occurrence of target\\n        left = 0;\\n        right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) {\\n                result[1] = mid;\\n                left = mid + 1;   // Continue searching on the right side\\n            } else if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329548,
                "title": "java-easy-solution-100-faster-code",
                "content": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int start=0,end=nums.length-1,fi=-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                fi=mid;\\n                end=mid-1;\\n            }\\n            else if(nums[mid]>target){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        start=0;end=nums.length-1;\\n        int ei=-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n           if(nums[mid]==target){\\n                ei=mid;\\n                start=mid+1;\\n            }\\n            else if(nums[mid]>target){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return new int[]{fi,ei};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int start=0,end=nums.length-1,fi=-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                fi=mid;\\n                end=mid-1;\\n            }\\n            else if(nums[mid]>target){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        start=0;end=nums.length-1;\\n        int ei=-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n           if(nums[mid]==target){\\n                ei=mid;\\n                start=mid+1;\\n            }\\n            else if(nums[mid]>target){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return new int[]{fi,ei};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020403,
                "title": "binary-search-lower-bound-upper-bound-c-stl",
                "content": "**Lower_bound returns an iterator pointing to the 1st element which is greater than equal to the given number (say x)\\nUpper_bound returns an iterator pointing to the 1st element which is just greater than the given number (say x)**\\n\\n**to convert the iterator to index we subtract 1st iterator from them\\n(for vector we do minus vector_name.begin() and for array we do minus array_name)**\\n\\n**example ->\\nvector v1{5, 7, 7, 8, 8, 10};\\ngiven number x=7**\\n\\n**lowerbound - v1.begin() will return 1 (1st elemnt which is not less then 7 which is 7 it self) --> v1[1] = 7\\nupperbound - v1.begin() while return 3 (1st element which is just greater then 7 which is 8) --> v1[3] = 8\\nthats why we did upperbound - v1.begin() - 1 (to get last index of given number) --> v1[2] = 7\\nanswer for the example will be {1,2}**\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        auto low = lower_bound(nums.begin(),nums.end(),target);\\n        auto up = upper_bound(nums.begin(),nums.end(),target);\\n        \\n        if(!binary_search(nums.begin(),nums.end(),target))    return {-1,-1};       // If target is not present in the array\\n        \\n        int rock = low - nums.begin();\\n        int lee = up - nums.begin()-1;\\n        \\n        return {rock,lee};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        auto low = lower_bound(nums.begin(),nums.end(),target);\\n        auto up = upper_bound(nums.begin(),nums.end(),target);\\n        \\n        if(!binary_search(nums.begin(),nums.end(),target))    return {-1,-1};       // If target is not present in the array\\n        \\n        int rock = low - nums.begin();\\n        int lee = up - nums.begin()-1;\\n        \\n        return {rock,lee};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905772,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func searchRange(_ nums: [Int], _ target: Int) -> [Int] {\\n        var index = -1\\n        var lower = 0\\n        var upper = nums.count - 1\\n        var mid = (lower + upper) / 2\\n\\n        while upper >= lower {\\n            if nums[mid] == target { index = mid; break }\\n            if mid == lower {\\n                if nums[upper] == target { index = upper }\\n                break\\n            }\\n            if nums[mid] > target {\\n                upper = mid\\n            } else {\\n                lower = mid\\n            }\\n            mid = (lower + upper) / 2\\n        }\\n        \\n        if index == -1 {\\n            return [-1, -1]\\n        } else {\\n            var i = index\\n            var j = index\\n            while i > 0 {\\n                if nums[i] == nums[i-1] { i -= 1 } else { break }\\n            }\\n            while j < nums.count - 1 {\\n                if nums[j] == nums[j+1] { j += 1 } else { break }\\n            }\\n            return [i, j]\\n        }\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func searchRange(_ nums: [Int], _ target: Int) -> [Int] {\\n        var index = -1\\n        var lower = 0\\n        var upper = nums.count - 1\\n        var mid = (lower + upper) / 2\\n\\n        while upper >= lower {\\n            if nums[mid] == target { index = mid; break }\\n            if mid == lower {\\n                if nums[upper] == target { index = upper }\\n                break\\n            }\\n            if nums[mid] > target {\\n                upper = mid\\n            } else {\\n                lower = mid\\n            }\\n            mid = (lower + upper) / 2\\n        }\\n        \\n        if index == -1 {\\n            return [-1, -1]\\n        } else {\\n            var i = index\\n            var j = index\\n            while i > 0 {\\n                if nums[i] == nums[i-1] { i -= 1 } else { break }\\n            }\\n            while j < nums.count - 1 {\\n                if nums[j] == nums[j+1] { j += 1 } else { break }\\n            }\\n            return [i, j]\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687573,
                "title": "c-using-lower-bound-and-upper-bound",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {      \\n        auto lb = lower_bound(nums.begin(), nums.end(), target);\\n        // checks if the lower bound of target in vector is the target itself otherwise target does not exist in vector\\n        if(lb-nums.begin() == nums.size() || *lb != target)    return {-1, -1};\\n        \\n        auto ub = upper_bound(nums.begin(), nums.end(), target);\\n        int l = lb-nums.begin(), r = (ub-1)-nums.begin();\\n        return {l, r};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {      \\n        auto lb = lower_bound(nums.begin(), nums.end(), target);\\n        // checks if the lower bound of target in vector is the target itself otherwise target does not exist in vector\\n        if(lb-nums.begin() == nums.size() || *lb != target)    return {-1, -1};\\n        \\n        auto ub = upper_bound(nums.begin(), nums.end(), target);\\n        int l = lb-nums.begin(), r = (ub-1)-nums.begin();\\n        return {l, r};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345172,
                "title": "c-binary-search-o-log-n",
                "content": "Binary search is evaluated agains a predicate for which the given array has this results\\n```\\n  5     7     7    8     8    10\\nfalse false false true true true\\n```\\nand we are looking for the first true in order to find first occurrence.\\n\\nFor finding the last occurrence then the evaluated predicate will give this \\n```\\n 5    7     7    8    8    10\\ntrue true true true true false\\n```\\nAnd we are looking for the last true element.\\n\\n\\n```\\nclass Solution {\\npublic:\\n  \\n    int first_occurrence(vector<int>& nums, int target) {\\n        int l = 0;\\n        int r = nums.size() - 1;\\n        while(l < r) {\\n            int mid = l + (r - l) / 2;\\n            if(nums[mid] >= target)\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        if(nums[l] != target)\\n            return -1;\\n        return l;\\n    }\\n    \\n    int last_occurrence(vector<int>& nums, int target) {\\n        int l = 0;\\n        int r = nums.size() - 1;\\n        while(l < r) {\\n            int mid = l + (r - l + 1) / 2;\\n            if(nums[mid] <= target)\\n                l = mid;\\n            else\\n                r = mid - 1;\\n        }\\n        if(nums[l] != target)\\n            return -1;\\n        return l;\\n    }\\n  \\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res = {-1, -1};\\n        if(nums.empty())\\n            return res;\\n        res[0] = first_occurrence(nums, target);\\n        res[1] = last_occurrence(nums, target);            \\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n  5     7     7    8     8    10\\nfalse false false true true true\\n```\n```\\n 5    7     7    8    8    10\\ntrue true true true true false\\n```\n```\\nclass Solution {\\npublic:\\n  \\n    int first_occurrence(vector<int>& nums, int target) {\\n        int l = 0;\\n        int r = nums.size() - 1;\\n        while(l < r) {\\n            int mid = l + (r - l) / 2;\\n            if(nums[mid] >= target)\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        if(nums[l] != target)\\n            return -1;\\n        return l;\\n    }\\n    \\n    int last_occurrence(vector<int>& nums, int target) {\\n        int l = 0;\\n        int r = nums.size() - 1;\\n        while(l < r) {\\n            int mid = l + (r - l + 1) / 2;\\n            if(nums[mid] <= target)\\n                l = mid;\\n            else\\n                r = mid - 1;\\n        }\\n        if(nums[l] != target)\\n            return -1;\\n        return l;\\n    }\\n  \\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res = {-1, -1};\\n        if(nums.empty())\\n            return res;\\n        res[0] = first_occurrence(nums, target);\\n        res[1] = last_occurrence(nums, target);            \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 130083,
                "title": "python-solutions-from-11-lines-o-n-to-8-lines-o-logn-to-2-lines-o-logn",
                "content": "* 11 lines O(N) \\n```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        l, r, n = 0, len(nums) - 1, len(nums)\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if nums[mid] > target: r = mid - 1\\n            elif nums[mid] < target: l = mid + 1\\n            else:\\n                l = r = mid\\n                while l > 0 and nums[l - 1] == nums[l]: l -= 1\\n                while r + 1 < n and nums[r + 1] == nums[r]: r += 1\\n                return [l, r]\\n        return [-1, -1]\\n```\\n* 8 lines O(logN)\\n```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        l, r = 0, len(nums) - 1\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if nums[mid] > target: r = mid - 1\\n            elif nums[mid] < target: l = mid + 1\\n            else:\\n                return [l + bisect.bisect_left(nums[l:mid + 1], target), mid + bisect.bisect_right(nums[mid:r + 1], target) - 1]\\n        return [-1, -1]\\n```\\n* 2 lines O(logN)\\n```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        l, r = bisect.bisect_left(nums, target), bisect.bisect_right(nums, target) - 1\\n        return [l, r] if 0 <= l <= r else [-1, -1]\\n```\\n* Bonus for those not to mess with bisect module\\n```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        def searchleft(l, r):\\n            while l < r:\\n                mid = (l + r) // 2\\n                if nums[mid] == target: r = mid\\n                else: l = mid + 1\\n            return l\\n        def searchright(l, r):\\n            while l <= r:\\n                mid = (l + r) // 2\\n                if nums[mid] == target: l = mid + 1\\n                else: r = mid - 1\\n            return r\\n        l, r, n = 0, len(nums) - 1, len(nums)\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if nums[mid] > target: r = mid - 1\\n            elif nums[mid] < target: l = mid + 1\\n            else:\\n                return [searchleft(l, mid), searchright(mid, r)]\\n        return [-1, -1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        l, r, n = 0, len(nums) - 1, len(nums)\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if nums[mid] > target: r = mid - 1\\n            elif nums[mid] < target: l = mid + 1\\n            else:\\n                l = r = mid\\n                while l > 0 and nums[l - 1] == nums[l]: l -= 1\\n                while r + 1 < n and nums[r + 1] == nums[r]: r += 1\\n                return [l, r]\\n        return [-1, -1]\\n```\n```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        l, r = 0, len(nums) - 1\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if nums[mid] > target: r = mid - 1\\n            elif nums[mid] < target: l = mid + 1\\n            else:\\n                return [l + bisect.bisect_left(nums[l:mid + 1], target), mid + bisect.bisect_right(nums[mid:r + 1], target) - 1]\\n        return [-1, -1]\\n```\n```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        l, r = bisect.bisect_left(nums, target), bisect.bisect_right(nums, target) - 1\\n        return [l, r] if 0 <= l <= r else [-1, -1]\\n```\n```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        def searchleft(l, r):\\n            while l < r:\\n                mid = (l + r) // 2\\n                if nums[mid] == target: r = mid\\n                else: l = mid + 1\\n            return l\\n        def searchright(l, r):\\n            while l <= r:\\n                mid = (l + r) // 2\\n                if nums[mid] == target: l = mid + 1\\n                else: r = mid - 1\\n            return r\\n        l, r, n = 0, len(nums) - 1, len(nums)\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if nums[mid] > target: r = mid - 1\\n            elif nums[mid] < target: l = mid + 1\\n            else:\\n                return [searchleft(l, mid), searchright(mid, r)]\\n        return [-1, -1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777981,
                "title": "easy-cpp-soln-using-upper-and-lower-bound",
                "content": "# please upvote if u like the solution \\n<!-- -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int index=(upper_bound(nums.begin(),nums.end(),target)-nums.begin());\\n        int index1=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        vector<int> ans;\\n        ans.push_back(index1);\\n       \\n       if(index1!=index){\\n           ans.push_back(index-1);\\n           return ans;\\n\\n       }\\n       else return {-1,-1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int index=(upper_bound(nums.begin(),nums.end(),target)-nums.begin());\\n        int index1=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        vector<int> ans;\\n        ans.push_back(index1);\\n       \\n       if(index1!=index){\\n           ans.push_back(index-1);\\n           return ans;\\n\\n       }\\n       else return {-1,-1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773851,
                "title": "binary-search-template-solution-intuition-explained-in-detail-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nhey every one i have made video playlist for binary search where i discuss a template solution and intuition behind it, this template solution will be very useful as this will help you solve many other questions in binary search this question is the part of that playlist:\\nVideo link for question:\\nhttps://youtu.be/4nVAqaM-j1Q\\nPlaylist ink: https://youtube.com/playlist?list=PLICVjZ3X1AcYYdde4GTp79zfdp_VACSkX\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if(nums.size()==0){\\n            return {-1,-1};\\n        }\\n        int l1=0;\\n        int r1= nums.size()-1;\\n        while(l1<r1){\\n            int m1= l1+ (r1-l1)/2;\\n            if(nums[m1]>=target){\\n                r1=m1;\\n            }\\n            else{\\n                l1=m1+1;\\n            }\\n        }\\n\\n        int l2=0;\\n        int r2= nums.size();\\n        while(l2<r2){\\n            int m2= l2+ (r2-l2)/2;\\n            if(nums[m2]>target){\\n                r2=m2;\\n            }\\n            else{\\n                l2=m2+1;\\n            }\\n        }\\n\\n        if(nums[l1]!=target){\\n            return {-1,-1};\\n        }\\n        if(l1==l2){\\n            return{l1,l2};\\n        }\\n        return {l1, l2-1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if(nums.size()==0){\\n            return {-1,-1};\\n        }\\n        int l1=0;\\n        int r1= nums.size()-1;\\n        while(l1<r1){\\n            int m1= l1+ (r1-l1)/2;\\n            if(nums[m1]>=target){\\n                r1=m1;\\n            }\\n            else{\\n                l1=m1+1;\\n            }\\n        }\\n\\n        int l2=0;\\n        int r2= nums.size();\\n        while(l2<r2){\\n            int m2= l2+ (r2-l2)/2;\\n            if(nums[m2]>target){\\n                r2=m2;\\n            }\\n            else{\\n                l2=m2+1;\\n            }\\n        }\\n\\n        if(nums[l1]!=target){\\n            return {-1,-1};\\n        }\\n        if(l1==l2){\\n            return{l1,l2};\\n        }\\n        return {l1, l2-1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261378,
                "title": "java-0ms-faster-than-100-beginner-friendly-binary-search",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n      int[] ans = {-1,-1};\\n      int s = search(nums,target,true);\\n      int e = search(nums,target,false);\\n      ans[0] = s;\\n      ans[1] = e;\\n      return ans;\\n        \\n    }\\n    public int search(int[] nums , int target , boolean FindFirst){\\n        int s = 0;\\n        int e = nums.length-1;\\n        int ans = -1;\\n        while(s<=e){\\n        int mid = s+(e-s)/2;\\n        if(nums[mid] < target) s = mid +1;\\n        else if(nums[mid] > target) e = mid - 1;\\n        else {\\n            ans = mid;\\n            if(FindFirst==true) e = mid -1;\\n            else s = mid+1;  \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n      int[] ans = {-1,-1};\\n      int s = search(nums,target,true);\\n      int e = search(nums,target,false);\\n      ans[0] = s;\\n      ans[1] = e;\\n      return ans;\\n        \\n    }\\n    public int search(int[] nums , int target , boolean FindFirst){\\n        int s = 0;\\n        int e = nums.length-1;\\n        int ans = -1;\\n        while(s<=e){\\n        int mid = s+(e-s)/2;\\n        if(nums[mid] < target) s = mid +1;\\n        else if(nums[mid] > target) e = mid - 1;\\n        else {\\n            ans = mid;\\n            if(FindFirst==true) e = mid -1;\\n            else s = mid+1;  \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098259,
                "title": "c-easy-solution-binary-search",
                "content": "# Approach\\nBinary Search\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bs(vector<int>& arr, int n, int k) {\\n        int l=0,h=n-1;\\n        int res=-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(arr[mid]==k){\\n                res=mid;\\n                h=mid-1;\\n            } \\n            else if(arr[mid]<k){\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n    int fs(vector<int>& arr, int n, int k) {\\n        int l=0,h=n-1;\\n        int res=-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(arr[mid]==k){\\n                res=mid;\\n                l=mid+1;\\n            } \\n            else if(arr[mid]<k){\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int k=bs(nums,nums.size(),target);\\n        int n=fs(nums,nums.size(),target);\\n        return {k,n};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bs(vector<int>& arr, int n, int k) {\\n        int l=0,h=n-1;\\n        int res=-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(arr[mid]==k){\\n                res=mid;\\n                h=mid-1;\\n            } \\n            else if(arr[mid]<k){\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n    int fs(vector<int>& arr, int n, int k) {\\n        int l=0,h=n-1;\\n        int res=-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(arr[mid]==k){\\n                res=mid;\\n                l=mid+1;\\n            } \\n            else if(arr[mid]<k){\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int k=bs(nums,nums.size(),target);\\n        int n=fs(nums,nums.size(),target);\\n        return {k,n};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063513,
                "title": "best-java-solution-binary-search-approach-0-ms",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sorted Array So Apply Binary Search\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] arr=new int[2];\\n        arr[0]=findFirst(nums,target);\\n        arr[1]=findLast(nums,target);\\n        return arr;\\n    }\\n\\n    public int findFirst(int[] arr,int target){\\n        int Start=0;\\n        int End=arr.length-1;\\n\\n        int index=-1;\\n\\n        while(Start<=End) {\\n\\n            int mid=Start+(End-Start)/2;\\n            \\n            if(arr[mid]<target) {\\n                Start=mid+1;\\n            }   \\n            else if(arr[mid]>target) {\\n                End=mid-1;\\n            }\\n            else {\\n                index=mid;\\n                End=mid-1;\\n            }\\n        }\\n        return index;\\n    }\\n\\n    public int findLast(int[] arr,int target){\\n        int Start=0;\\n        int End=arr.length-1;\\n\\n        int index=-1;\\n\\n        while(Start<=End) {\\n\\n        int mid=Start+(End-Start)/2;\\n\\n        if(arr[mid]<target) {\\n            Start=mid+1;\\n        }   \\n        else if(arr[mid]>target) {\\n            End=mid-1;\\n        } \\n        else {\\n            index=mid;\\n            Start=mid+1;\\n        }\\n    }\\n    return index; \\n  }\\n}\\n```\\n\\n# Complexity\\n- Time complexity : O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] arr=new int[2];\\n        arr[0]=findFirst(nums,target);\\n        arr[1]=findLast(nums,target);\\n        return arr;\\n    }\\n\\n    public int findFirst(int[] arr,int target){\\n        int Start=0;\\n        int End=arr.length-1;\\n\\n        int index=-1;\\n\\n        while(Start<=End) {\\n\\n            int mid=Start+(End-Start)/2;\\n            \\n            if(arr[mid]<target) {\\n                Start=mid+1;\\n            }   \\n            else if(arr[mid]>target) {\\n                End=mid-1;\\n            }\\n            else {\\n                index=mid;\\n                End=mid-1;\\n            }\\n        }\\n        return index;\\n    }\\n\\n    public int findLast(int[] arr,int target){\\n        int Start=0;\\n        int End=arr.length-1;\\n\\n        int index=-1;\\n\\n        while(Start<=End) {\\n\\n        int mid=Start+(End-Start)/2;\\n\\n        if(arr[mid]<target) {\\n            Start=mid+1;\\n        }   \\n        else if(arr[mid]>target) {\\n            End=mid-1;\\n        } \\n        else {\\n            index=mid;\\n            Start=mid+1;\\n        }\\n    }\\n    return index; \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821321,
                "title": "python-easy-solution",
                "content": "# Code\\u2705\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]: # nums = [5,7,7,8,8,8,8,10], target = 8\\n        unique = sorted(tuple(set(nums))) # [5, 7, 8, 10]\\n        if target not in unique:\\n            return [-1,-1]\\n        first = nums.index(target) # 3\\n        target_index = unique.index(target) # 2 \\n        if target_index == len(unique)-1:\\n            return [first,len(nums)-1]\\n        last = nums.index(unique[target_index+1]) # 7\\n        return [first,last-1] # [3,6]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]: # nums = [5,7,7,8,8,8,8,10], target = 8\\n        unique = sorted(tuple(set(nums))) # [5, 7, 8, 10]\\n        if target not in unique:\\n            return [-1,-1]\\n        first = nums.index(target) # 3\\n        target_index = unique.index(target) # 2 \\n        if target_index == len(unique)-1:\\n            return [first,len(nums)-1]\\n        last = nums.index(unique[target_index+1]) # 7\\n        return [first,last-1] # [3,6]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790269,
                "title": "simple-java-solution-easy-to-understand",
                "content": "Upvote if you liked the solution\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n\\n        int start=bs(nums,target,true);\\n        int end=bs(nums,target,false);\\n        int ans[]={start,end};\\n        \\n        return ans;\\n    }\\n    \\n    private int bs(int[] nums,int target,boolean firstIndex)\\n    {\\n        int ans=-1;\\n        int lo=0,hi=nums.length-1;\\n        \\n        while(lo<=hi)\\n        {\\n            int mid=lo+(hi-lo)/2;\\n            \\n            if(nums[mid]>target)\\n            {\\n                hi=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                lo=mid+1;\\n            }\\n            else\\n            {\\n                ans=mid;\\n                if(firstIndex)\\n                    hi=mid-1;\\n                else\\n                    lo=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n\\n        int start=bs(nums,target,true);\\n        int end=bs(nums,target,false);\\n        int ans[]={start,end}",
                "codeTag": "Java"
            },
            {
                "id": 2767072,
                "title": "simplest-java-code",
                "content": "# Intuition\\n## <!-- Describe your first thoughts on how to solve this problem. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> Using binary search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->  Better than **100%**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> Better than 27.59%\\n\\n# Code\\n```\\nclass Solution{\\npublic int[] searchRange(int[] nums, int target) {\\n    int l = binarySearch(nums, target);\\n    // target does not exist. No need to look for the last position.\\n    if (l == nums.length || nums[l] != target) return new int[] { -1, -1 };\\n    // look for the index of target + 1\\n    int r = binarySearch(nums, target + 1);\\n    // last position is r - 1.\\n    return new int[] { l, r - 1 };\\n}\\nprivate int binarySearch(int[] nums, int target) {\\n    int l = 0, r = nums.length;\\n    while (l < r) {\\n        int m = (l + r) / 2;\\n        if (nums[m] < target) l = m + 1;\\n        else r = m ;\\n    }\\n    return l;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\npublic int[] searchRange(int[] nums, int target) {\\n    int l = binarySearch(nums, target);\\n    // target does not exist. No need to look for the last position.\\n    if (l == nums.length || nums[l] != target) return new int[] { -1, -1 };\\n    // look for the index of target + 1\\n    int r = binarySearch(nums, target + 1);\\n    // last position is r - 1.\\n    return new int[] { l, r - 1 };\\n}\\nprivate int binarySearch(int[] nums, int target) {\\n    int l = 0, r = nums.length;\\n    while (l < r) {\\n        int m = (l + r) / 2;\\n        if (nums[m] < target) l = m + 1;\\n        else r = m ;\\n    }\\n    return l;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681299,
                "title": "c-two-times-binary-search-for-start-and-end",
                "content": "```\\nclass Solution {\\n public:\\n  vector<int> searchRange(vector<int>& nums, int target) {\\n    int start = bs(nums, target, true);\\n    int end = bs(nums, target, false);\\n\\n    return vector<int>({start, end});\\n  }\\n\\n  int bs(vector<int>& nums, int target, bool firstindex) {\\n    int ans = -1;\\n    int l = 0, r = nums.size() - 1;\\n\\n    while (l <= r) {\\n      int m = l + (r - l) / 2;\\n\\n      if (target > nums[m])\\n        l = m + 1;\\n      else if (target < nums[m])\\n        r = m - 1;\\n      else {\\n        ans = m;\\n        if (firstindex)\\n          r = m - 1;\\n        else\\n          l = m + 1;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  vector<int> searchRange(vector<int>& nums, int target) {\\n    int start = bs(nums, target, true);\\n    int end = bs(nums, target, false);\\n\\n    return vector<int>({start, end});\\n  }\\n\\n  int bs(vector<int>& nums, int target, bool firstindex) {\\n    int ans = -1;\\n    int l = 0, r = nums.size() - 1;\\n\\n    while (l <= r) {\\n      int m = l + (r - l) / 2;\\n\\n      if (target > nums[m])\\n        l = m + 1;\\n      else if (target < nums[m])\\n        r = m - 1;\\n      else {\\n        ans = m;\\n        if (firstindex)\\n          r = m - 1;\\n        else\\n          l = m + 1;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180677,
                "title": "call-binary-search-twice-python3-solution",
                "content": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        \\n        def search(x):\\n            lo, hi = 0, len(nums)           \\n            while lo < hi:\\n                mid = (lo + hi) // 2\\n                if nums[mid] < x:\\n                    lo = mid+1\\n                else:\\n                    hi = mid                    \\n            return lo\\n        \\n        lo = search(target)\\n        hi = search(target+1)-1\\n        \\n        if lo <= hi:\\n            return [lo, hi]\\n                \\n        return [-1, -1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        \\n        def search(x):\\n            lo, hi = 0, len(nums)           \\n            while lo < hi:\\n                mid = (lo + hi) // 2\\n                if nums[mid] < x:\\n                    lo = mid+1\\n                else:\\n                    hi = mid                    \\n            return lo\\n        \\n        lo = search(target)\\n        hi = search(target+1)-1\\n        \\n        if lo <= hi:\\n            return [lo, hi]\\n                \\n        return [-1, -1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439181,
                "title": "c-only-one-simple-binary-search-function-explanation",
                "content": "Let\\'s the example array be [1,2,3,3,3,5] and target is 3\\nSo lets p1 = first occurence of number greater than (target -1=3-1=2)in this case as 3 > 2 and 3 comes at index 2 for the first time\\nand lets p2 = first occurence of number greater than (target=3)which is  5 in this case as 5>3 and 5 comes at index 5 for the first time\\nif p1 == p2 that means our target number is not in the array\\nfor ex array is [1,2,4,4,5] and target = 3\\np1 = 3 as number greater than (3-1=2)  is 4 and first occurence of 4 is at 3rd index\\np2 = 3 as number greater than (3) is 4 and first occurence of 4 is at 3rd index\\nso p1 == p2 that means number is not present\\nif p1 == p2 return [-1,-1]\\nelse return [p1,p2-1] \\nWhy p2-1 because p2 is the index of the first occurence of the number greater than our target so p2-1 will be the last occurence of our target\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int bSearch(vector<int> &nums, int target)\\n    {\\n        int low = 0, high = nums.size();\\n        while (low < high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] > target)\\n                high = mid;\\n            else\\n                low = mid + 1;\\n        }\\n        return low;\\n    }\\n    vector<int> searchRange(vector<int> &nums, int target)\\n    {\\n        int p2 = bSearch(nums, target);\\n        int p1 = bSearch(nums, target - 1);\\n        if (p1 == p2 )// That means element is not present hence return [-1,-1]\\n            return {-1, -1};\\n        return {p1, p2-1}; //element is present \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int bSearch(vector<int> &nums, int target)\\n    {\\n        int low = 0, high = nums.size();\\n        while (low < high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] > target)\\n                high = mid;\\n            else\\n                low = mid + 1;\\n        }\\n        return low;\\n    }\\n    vector<int> searchRange(vector<int> &nums, int target)\\n    {\\n        int p2 = bSearch(nums, target);\\n        int p1 = bSearch(nums, target - 1);\\n        if (p1 == p2 )// That means element is not present hence return [-1,-1]\\n            return {-1, -1};\\n        return {p1, p2-1}; //element is present \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184156,
                "title": "java-3-approaches-explained-o-n-to-o-log-n-all-accepted",
                "content": "*------Please **upvote!** if you like the solution and explanation.  Please put your doubts/queries in the comments section below.  I will try my best to answer them.------*\\n\\n**APPROACH 1 -** 2 Pointers - Time Complexity = **O(N)**:\\n\\n*Take an array of size 2 **`res []`** to store the result and initialize both the cells with **-1**.*\\n\\n1. Take 2 pointers - **ptr1** and **ptr2** starting from **0** and **N-1** respectively.\\n2. Iterate until **`ptr1 <= ptr2`**.\\n3. If **`nums [ptr1] == target`**:  set **`res [0] = ptr1`**, else increment **ptr1**.\\n4. If **`nums [ptr2] == target`**:  set **`res [1] = ptr2`**, else decrement **ptr2**.\\n5. If **`res [0] > -1`** and **`res [1] > -1`**, means we have found the indices, so break and return **res**.\\n\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int res [] = new int [2];\\n        res [0] = -1;\\n        res [1] = -1;\\n        if (nums.length == 0)\\n            return res;\\n        int ptr1 = 0, ptr2 = nums.length - 1;\\n        while (ptr1 <= ptr2) {\\n            if (nums [ptr1] == target)\\n                res [0] = ptr1;\\n            else\\n                ptr1++;\\n            if (nums [ptr2] == target)\\n                res [1] = ptr2;\\n            else\\n                ptr2--;\\n            if (res [0] > -1 && res [1] > -1)\\n                break;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n**APPROACH 2 -** Binary Search + Iteration - Time Complexity = **O(N)**:\\n\\n*Take an array of size 2 **`res []`** to store the result and initialize both the cells with **-1**.*\\n\\n1. Apply binary search and find a **possible** index of **target**.\\n2. Start from this index towards the left of the array and find the final index containing **target**. Set **res [0]** to this index.\\n3. Start from this index towards the right of the array and find the final index containing **target**. Set **res [1]** to this index.\\n4. If the target was not found in the initial Binary Search, return **res** as it is.\\n5. Return **res**.\\n\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int res [] = new int [2];\\n        res [0] = -1;\\n        res [1] = -1;\\n        if (nums.length == 0)\\n            return res;\\n        return BinarySearch (nums, target);\\n    }\\n    \\n    public int [] BinarySearch (int arr [], int target) {\\n        int l = 0, r = arr.length - 1, mid = -1;\\n        boolean flag = false;\\n        while (l <= r) {\\n            mid = l + (r - l) / 2;\\n            if (arr [mid] == target) {\\n                flag = true;\\n                break;\\n            }\\n            if (arr [mid] < target)\\n                l = mid + 1;\\n            else\\n                r = mid - 1;\\n        }\\n        int res [] = new int [2];\\n        if (flag == false) {\\n            res [0] = -1;\\n            res [1] = -1;\\n        }\\n        else {\\n            int i = mid;\\n            while (i > 0 && arr [i-1] == arr [i])\\n                i--;\\n            res [0] = i;\\n            i = mid;\\n            while (i < arr.length - 1 && arr [i] == arr [i+1])\\n                i++;\\n            res [1] = i;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n**APPROACH 3 -** Binary Search - Time Complexity = **O(log N)**:\\n\\n`Credit: Mazhar_MIK\\'s solution - https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/discuss/1181941/C%2B%2B-(Two-approaches-O(logn)-with-comments)`\\n\\nBasically, we will do the iteration part of Approach 2 in the Binary Search function itself.\\n\\n1. Find first position of **target** using Binary Search. After finding target, **keep going towards left** until you find the final index. See the comments in the code.\\n2. Find last position of **target** using Binary Search. After finding target, **keep going towards right** until you find the final index. See the comments in the code.\\n3. Return **res** with these indices.\\n\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        if (nums == null || nums.length == 0)\\n            return new int [] {-1, -1};\\n        int first = findFirst (nums, target);\\n        int last = findLast (nums, target);\\n        return new int [] {first, last};\\n    }\\n    \\n    public int findFirst (int arr [], int target) {\\n        int left = 0, right = arr.length - 1, mid = 0, res = -1;\\n        while (left <= right) {\\n            mid = left + (right - left) / 2;\\n            if (arr [mid] == target) {\\n                res = mid;                 // Possibly our solution\\n                right = mid - 1;           // But, still keep looking towards the left\\n            }\\n            else if (target > arr [mid])\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return res;\\n    }\\n    \\n    public int findLast (int arr [], int target) {\\n        int left = 0, right = arr.length - 1, mid = 0, res = -1;\\n        while (left <= right) {\\n            mid = left + (right - left) / 2;\\n            if (arr [mid] == target) {\\n               res = mid;                 // Possibly our solution\\n               left = mid + 1;            // But, still keep looking towards the right\\n            }\\n            else if (target > arr [mid])\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nAgain, if you like the solutions, please **upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int res [] = new int [2];\\n        res [0] = -1;\\n        res [1] = -1;\\n        if (nums.length == 0)\\n            return res;\\n        int ptr1 = 0, ptr2 = nums.length - 1;\\n        while (ptr1 <= ptr2) {\\n            if (nums [ptr1] == target)\\n                res [0] = ptr1;\\n            else\\n                ptr1++;\\n            if (nums [ptr2] == target)\\n                res [1] = ptr2;\\n            else\\n                ptr2--;\\n            if (res [0] > -1 && res [1] > -1)\\n                break;\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int res [] = new int [2];\\n        res [0] = -1;\\n        res [1] = -1;\\n        if (nums.length == 0)\\n            return res;\\n        return BinarySearch (nums, target);\\n    }\\n    \\n    public int [] BinarySearch (int arr [], int target) {\\n        int l = 0, r = arr.length - 1, mid = -1;\\n        boolean flag = false;\\n        while (l <= r) {\\n            mid = l + (r - l) / 2;\\n            if (arr [mid] == target) {\\n                flag = true;\\n                break;\\n            }\\n            if (arr [mid] < target)\\n                l = mid + 1;\\n            else\\n                r = mid - 1;\\n        }\\n        int res [] = new int [2];\\n        if (flag == false) {\\n            res [0] = -1;\\n            res [1] = -1;\\n        }\\n        else {\\n            int i = mid;\\n            while (i > 0 && arr [i-1] == arr [i])\\n                i--;\\n            res [0] = i;\\n            i = mid;\\n            while (i < arr.length - 1 && arr [i] == arr [i+1])\\n                i++;\\n            res [1] = i;\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        if (nums == null || nums.length == 0)\\n            return new int [] {-1, -1};\\n        int first = findFirst (nums, target);\\n        int last = findLast (nums, target);\\n        return new int [] {first, last};\\n    }\\n    \\n    public int findFirst (int arr [], int target) {\\n        int left = 0, right = arr.length - 1, mid = 0, res = -1;\\n        while (left <= right) {\\n            mid = left + (right - left) / 2;\\n            if (arr [mid] == target) {\\n                res = mid;                 // Possibly our solution\\n                right = mid - 1;           // But, still keep looking towards the left\\n            }\\n            else if (target > arr [mid])\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return res;\\n    }\\n    \\n    public int findLast (int arr [], int target) {\\n        int left = 0, right = arr.length - 1, mid = 0, res = -1;\\n        while (left <= right) {\\n            mid = left + (right - left) / 2;\\n            if (arr [mid] == target) {\\n               res = mid;                 // Possibly our solution\\n               left = mid + 1;            // But, still keep looking towards the right\\n            }\\n            else if (target > arr [mid])\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181943,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int bs(vector<int> & nums,int l,int h,int tar,bool uff)\\n    {\\n        int res=-1;\\n        while(l<=h)\\n        {\\n            int mid=(l+h)/2;\\n            \\n            if(nums[mid]==tar)\\n            {\\n                res=mid;\\n                if(uff)\\n                    l=mid+1;\\n                else\\n                    h=mid-1;\\n            }\\n            else if(nums[mid]>tar)\\n                h=mid-1;\\n            else\\n                l=mid+1;\\n        }\\n        return res;\\n    }\\n    \\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        vector<int> res(2);\\n        int n=nums.size();\\n        res[0]=bs(nums,0,n-1,target,false);\\n        res[1]=bs(nums,0,n-1,target,true);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int bs(vector<int> & nums,int l,int h,int tar,bool uff)\\n    {\\n        int res=-1;\\n        while(l<=h)\\n        {\\n            int mid=(l+h)/2;\\n            \\n            if(nums[mid]==tar)\\n            {\\n                res=mid;\\n                if(uff)\\n                    l=mid+1;\\n                else\\n                    h=mid-1;\\n            }\\n            else if(nums[mid]>tar)\\n                h=mid-1;\\n            else\\n                l=mid+1;\\n        }\\n        return res;\\n    }\\n    \\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        vector<int> res(2);\\n        int n=nums.size();\\n        res[0]=bs(nums,0,n-1,target,false);\\n        res[1]=bs(nums,0,n-1,target,true);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575702,
                "title": "solution-using-template-3-of-bs-by-leetcode",
                "content": "I am doing topic wise problems and this problem was under BS for the card under explore section. It fell into Template 3 where you need to keep check of the left and the right elements during search. Hence I designed a solution likewise. \\nLong solution but simple to understand.\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int ans[] = {-1,-1};\\n        if(nums == null || nums.length == 0)\\n            return ans;\\n        ans[0] = findLeft(nums, target);\\n        ans[1] = findRight(nums, target);\\n        return ans;\\n    }\\n    \\n    public int findLeft(int[] nums, int target){\\n        int low = 0;\\n        int high = nums.length -1;\\n        while(low+1<high){\\n            int mid = (high-low)/2 + low;\\n            if(nums[mid]<target){\\n                low = mid+1;\\n            } else \\n                high = mid;\\n            }\\n        if(nums[low] == target) return low;\\n        if(nums[high] == target) return high;\\n        return -1;\\n        }\\n\\n    public int findRight(int[] nums, int target){\\n            int low = 0;\\n            int high = nums.length -1;\\n            while(low+1<high){\\n                int mid = (high-low)/2 + low;\\n                if(nums[mid]<=target){\\n                    low = mid;\\n                } else \\n                    high = mid-1;\\n                }\\n            if(nums[high] == target) return high;\\n             if(nums[low] == target) return low;\\n            return -1;\\n            }\\n        \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int ans[] = {-1,-1};\\n        if(nums == null || nums.length == 0)\\n            return ans;\\n        ans[0] = findLeft(nums, target);\\n        ans[1] = findRight(nums, target);\\n        return ans;\\n    }\\n    \\n    public int findLeft(int[] nums, int target){\\n        int low = 0;\\n        int high = nums.length -1;\\n        while(low+1<high){\\n            int mid = (high-low)/2 + low;\\n            if(nums[mid]<target){\\n                low = mid+1;\\n            } else \\n                high = mid;\\n            }\\n        if(nums[low] == target) return low;\\n        if(nums[high] == target) return high;\\n        return -1;\\n        }\\n\\n    public int findRight(int[] nums, int target){\\n            int low = 0;\\n            int high = nums.length -1;\\n            while(low+1<high){\\n                int mid = (high-low)/2 + low;\\n                if(nums[mid]<=target){\\n                    low = mid;\\n                } else \\n                    high = mid-1;\\n                }\\n            if(nums[high] == target) return high;\\n             if(nums[low] == target) return low;\\n            return -1;\\n            }\\n        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423966,
                "title": "java-binary-search-solution-with-easy-explanation-and-common-mistake",
                "content": "Three line explanation for iterviews\\n\\n1. We can do separate binary search for first and last elements. Why?\\n2. Because for finding first occurence we keep doing binary search in left half when we encounter mid that is same as mid-1 element.\\n3. We should not iterate linearly towards left and right after finding mid that is equal to target. If we do a linear search then asymptotic time complexity will again become O(n). Although O(n) solution will work on leetcode but won\\'t be good solution for interviews.\\n\\nTime Complexity: log(n) Space: O(1)\\nYou can follow me on https://twitter.com/Jaspind07199761 for DS and Algo tips\\nor connect on https://www.linkedin.com/in/jaspindersingh1/\\n```\\nclass Solution {\\n    public int first(int[] nums, int low, int high, int target)\\n    {\\n        while (low <= high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid] == target){\\n                if( mid == low ||  nums[mid - 1] < nums[mid]) return mid;\\n                // still go left\\n                else high = mid - 1;\\n            } else if(nums[mid] > target){\\n                high = mid - 1;\\n            } else low = mid + 1; \\n        }\\n        return -1; \\n    }\\n    \\n    public int second(int[] nums, int low, int high, int target)\\n    {\\n        while (low <= high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid] == target){\\n                if(mid == high || nums[mid + 1] > target) return mid;\\n                // still go right\\n                else low = mid + 1;\\n            } else if(nums[mid] > target){\\n                high = mid - 1;\\n            } else low = mid + 1; \\n        }\\n        return -1; \\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int left = first(nums, 0, nums.length - 1, target);\\n        int right = second(nums, 0, nums.length - 1, target);\\n        return new int[] {left,right};\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int first(int[] nums, int low, int high, int target)\\n    {\\n        while (low <= high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid] == target){\\n                if( mid == low ||  nums[mid - 1] < nums[mid]) return mid;\\n                // still go left\\n                else high = mid - 1;\\n            } else if(nums[mid] > target){\\n                high = mid - 1;\\n            } else low = mid + 1; \\n        }\\n        return -1; \\n    }\\n    \\n    public int second(int[] nums, int low, int high, int target)\\n    {\\n        while (low <= high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid] == target){\\n                if(mid == high || nums[mid + 1] > target) return mid;\\n                // still go right\\n                else low = mid + 1;\\n            } else if(nums[mid] > target){\\n                high = mid - 1;\\n            } else low = mid + 1; \\n        }\\n        return -1; \\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int left = first(nums, 0, nums.length - 1, target);\\n        int right = second(nums, 0, nums.length - 1, target);\\n        return new int[] {left,right};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14869,
                "title": "python-easy-solution-with-explanation",
                "content": "The first while give bias towards the left and the second while gives bias towards the right.\\nExample:\\n    \\n                          First While[start,end]     Second While[start,end]\\n    nums = [2,2] target=0     [0,-1]                     [0,-1]\\n    nums = [2,2] target=3     [2,1]                      [2,1]\\n    nums = [2,2] target=2     [0,-1]                     [2,1]\\n\\nThe code is as below:\\n\\n  \\n\\n    def searchRange(self, nums, target):\\n        start = 0\\n        end = len(nums)-1\\n        result = []\\n        \\n        while start <= end:\\n            mid = start + (end-start)/2\\n            if nums[mid] < target:\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        result.append(start)\\n        \\n        \\n        start = 0\\n        end = len(nums)-1\\n        \\n        while start <= end:\\n            mid = start + (end-start)/2\\n            if nums[mid]  > target:\\n                end = mid -1\\n            else:\\n                start = mid + 1\\n        result.append(end)\\n        \\n        if result[0] > result[1]:\\n            return [-1, -1]\\n        else:\\n            return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "The first while give bias towards the left and the second while gives bias towards the right.\\nExample:\\n    \\n                          First While[start,end]     Second While[start,end]\\n    nums = [2,2] target=0     [0,-1]                     [0,-1]\\n    nums = [2,2] target=3     [2,1]                      [2,1]\\n    nums = [2,2] target=2     [0,-1]                     [2,1]\\n\\nThe code is as below:\\n\\n  \\n\\n    def searchRange(self, nums, target):\\n        start = 0\\n        end = len(nums)-1\\n        result = []\\n        \\n        while start <= end:\\n            mid = start + (end-start)/2\\n            if nums[mid] < target:\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        result.append(start)\\n        \\n        \\n        start = 0\\n        end = len(nums)-1\\n        \\n        while start <= end:\\n            mid = start + (end-start)/2\\n            if nums[mid]  > target:\\n                end = mid -1\\n            else:\\n                start = mid + 1\\n        result.append(end)\\n        \\n        if result[0] > result[1]:\\n            return [-1, -1]\\n        else:\\n            return result",
                "codeTag": "Python3"
            },
            {
                "id": 3140796,
                "title": "easy-c-solution-for-beginners-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        int first =-1, last=-1;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                first=i;\\n                \\n                break;\\n            }\\n        }\\n        for(int i=nums.size()-1; i>=0; i--)\\n        {\\n            if(nums[i]==target)\\n            {\\n                last=i;\\n                \\n                break;\\n            }\\n        }\\n        v.push_back(first);\\n        v.push_back(last);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        int first =-1, last=-1;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                first=i;\\n                \\n                break;\\n            }\\n        }\\n        for(int i=nums.size()-1; i>=0; i--)\\n        {\\n            if(nums[i]==target)\\n            {\\n                last=i;\\n                \\n                break;\\n            }\\n        }\\n        v.push_back(first);\\n        v.push_back(last);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713029,
                "title": "java-fast-solution",
                "content": "//search element according to binary search\\nclass Solution {\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        int si=0;\\n        int ei=nums.length-1;\\n        int[] ans=new int[]{-1,-1};\\n    while(si<=ei){\\n        int mid=si+(ei-si)/2;\\n        if(nums[mid]==target){\\n            si=mid-1;ei=mid+1;\\n\\t\\t\\t// search for first index with while loop in -ve  direction\\n            while(si>=0&&nums[si]==target){si--;}\\n            ans[0]=si+1;\\n\\t\\t\\t// search for ending index in +ve direction\\n            while(ei<nums.length&&nums[ei]==target){ei++;}\\n            ans[1]=ei-1;\\n            return ans;\\n        }\\n        else if(target>nums[mid]){\\n            si=mid+1;\\n        }\\n       \\n        else ei=mid-1;\\n    }\\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        int si=0;\\n        int ei=nums.length-1;\\n        int[] ans=new int[]{-1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 2256973,
                "title": "c-simple-fast-solution-first-and-last-position-of-element-in-sorted-array",
                "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int start = -1;\\n        int end = -1;\\n        vector<int> ans;\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                start = i;\\n                break;\\n            }\\n        }\\n        for(int i = nums.size()-1;i>=0;i--){\\n            if(nums[i]==target){\\n                end = i;\\n                break;\\n            }\\n        }\\n        \\n        ans.push_back(start);\\n        ans.push_back(end);\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int start = -1;\\n        int end = -1;\\n        vector<int> ans;\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                start = i;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2177406,
                "title": "python-2-liner-no-loop-no-library-simple-and-easy",
                "content": "**Give it a upvote if you like the solution :)**\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        \\n        if target not in nums: return [-1,-1]\\n        else : return [nums.index(target),nums.index(target) + nums.count(target) - 1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        \\n        if target not in nums: return [-1,-1]\\n        else : return [nums.index(target),nums.index(target) + nums.count(target) - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154474,
                "title": "python-binary-search-easily-explained",
                "content": "# Python Binary Search.\\n```\\nclass Solution:\\n# for this solution we need to modify our binary search since we can\\'t return\\n# mid here.\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        # searching from left and then from right\\n        left = self.binSearch(nums, target, True)\\n        right = self.binSearch(nums, target, False)\\n        return [left, right]\\n\\n    # if leftBias=True, we search for left side\\n\\t# if False, we seach for right side\\n    def binSearch(self, nums, target, leftBias):\\n        l, r = 0, len(nums) - 1\\n        i = -1\\n        while l <= r:\\n            m = (l+r) // 2\\n            if nums[m] < target:\\n                l = m + 1\\n            elif nums[m] > target:\\n                r = m - 1\\n            else: # if nums[m] == target\\n                i = m\\n                if leftBias: # if I\\'m searching from left-side\\n                    r = m - 1 \\n                else: # if I\\'m searching from right-side\\n                    l = m + 1\\n        return i\\n```\\n## Give it a **Upvote** If You Like My Explanation.\\n### Have a Great Day/Night.",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n# for this solution we need to modify our binary search since we can\\'t return\\n# mid here.\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        # searching from left and then from right\\n        left = self.binSearch(nums, target, True)\\n        right = self.binSearch(nums, target, False)\\n        return [left, right]\\n\\n    # if leftBias=True, we search for left side\\n\\t# if False, we seach for right side\\n    def binSearch(self, nums, target, leftBias):\\n        l, r = 0, len(nums) - 1\\n        i = -1\\n        while l <= r:\\n            m = (l+r) // 2\\n            if nums[m] < target:\\n                l = m + 1\\n            elif nums[m] > target:\\n                r = m - 1\\n            else: # if nums[m] == target\\n                i = m\\n                if leftBias: # if I\\'m searching from left-side\\n                    r = m - 1 \\n                else: # if I\\'m searching from right-side\\n                    l = m + 1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007640,
                "title": "using-binary-search-o-logn-lower-bound-upper-bound-concept",
                "content": "By Using **Binary Search**  we can able to achieve this solution in logn time ( it is given that array already sorted) \\n\\nSo by the technique of calculation of **lower bound and upper bound** we calculate the index of target in lower bound area and similarly in upper bound area.\\n\\n* runs two separate loop for both.\\n* store the index of target whenever it got.  \\n![image](https://assets.leetcode.com/users/images/663e1b29-ae8d-4e38-9953-c0ec3aef464f_1651669334.2044718.png)\\n \\n**Time complexity - O(nlogn)\\nSpace complexity - O(1)**\\n\\n\\n****\\n**JAVA Code** \\n\\n```\\n\\nclass Solution {\\n\\tpublic int[] searchRange(int[] nums, int target) {\\n\\n\\t\\tint[] ans = { -1, -1 };\\n\\n\\t\\tint i = 0;\\n\\t\\tint j = nums.length - 1;\\n\\n\\t\\twhile (i <= j) {\\n\\t\\t\\tint mid = (i + j) / 2;\\n\\n\\t\\t\\tif (nums[mid] == target) {\\n\\t\\t\\t\\tans[0] = mid;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[mid] >= target) {\\n\\t\\t\\t\\tj = mid - 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\ti = mid + 1;\\n\\t\\t}\\n\\t\\ti = 0;\\n\\t\\tj = nums.length - 1;\\n\\n\\t\\twhile (i <= j) {\\n\\t\\t\\tint mid = (i + j) / 2;\\n\\n\\t\\t\\tif (nums[mid] == target) {\\n\\t\\t\\t\\tans[1] = mid;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[mid] > target) {\\n\\t\\t\\t\\tj = mid - 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\ti = mid + 1;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\n\\tpublic int[] searchRange(int[] nums, int target) {\\n\\n\\t\\tint[] ans = { -1, -1 };\\n\\n\\t\\tint i = 0;\\n\\t\\tint j = nums.length - 1;\\n\\n\\t\\twhile (i <= j) {\\n\\t\\t\\tint mid = (i + j) / 2;\\n\\n\\t\\t\\tif (nums[mid] == target) {\\n\\t\\t\\t\\tans[0] = mid;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[mid] >= target) {\\n\\t\\t\\t\\tj = mid - 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\ti = mid + 1;\\n\\t\\t}\\n\\t\\ti = 0;\\n\\t\\tj = nums.length - 1;\\n\\n\\t\\twhile (i <= j) {\\n\\t\\t\\tint mid = (i + j) / 2;\\n\\n\\t\\t\\tif (nums[mid] == target) {\\n\\t\\t\\t\\tans[1] = mid;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[mid] > target) {\\n\\t\\t\\t\\tj = mid - 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\ti = mid + 1;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599591,
                "title": "lower-bound-upper-bound-binary-search",
                "content": "lower bound + upper bound binary search with closed intervals, i.e [l,r]\\n\\nfor intervals with the open end, i.e [l,r)\\nyou can refer to \\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/discuss/1543638/lower-bound-%2B-upper-bound-binary-search-O(logn)\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        //lower bound binary search\\n        int l = 0, r = nums.length-1;\\n        while(l<=r) {\\n            int m = l + (r-l)/2;\\n            if(nums[m] < target) \\n                l = m + 1;\\n            else if (nums[m] > target) \\n                r = m - 1;\\n            else if (nums[m] == target) \\n                r = m - 1;\\n        }\\n                \\n        if(l== nums.length || nums[l] !=target) return new int[] {-1,-1};\\n        int lowerBound = l; \\n        \\n        //upper bound binary search\\n        l = 0; r = nums.length-1;\\n        while(l<=r) {\\n            int m = l + (r-l)/2;\\n            if(nums[m] < target) \\n                l = m + 1;\\n            else if (nums[m] > target) \\n                r = m - 1;\\n            else if (nums[m] == target) \\n                l = m + 1;\\n        }\\n        return new int[] {lowerBound, r};\\n            \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        //lower bound binary search\\n        int l = 0, r = nums.length-1;\\n        while(l<=r) {\\n            int m = l + (r-l)/2;\\n            if(nums[m] < target) \\n                l = m + 1;\\n            else if (nums[m] > target) \\n                r = m - 1;\\n            else if (nums[m] == target) \\n                r = m - 1;\\n        }\\n                \\n        if(l== nums.length || nums[l] !=target) return new int[] {-1,-1};\\n        int lowerBound = l; \\n        \\n        //upper bound binary search\\n        l = 0; r = nums.length-1;\\n        while(l<=r) {\\n            int m = l + (r-l)/2;\\n            if(nums[m] < target) \\n                l = m + 1;\\n            else if (nums[m] > target) \\n                r = m - 1;\\n            else if (nums[m] == target) \\n                l = m + 1;\\n        }\\n        return new int[] {lowerBound, r};\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409980,
                "title": "clean-commented-code-0ms-run-time-100-faster-log-n-complexity-take-a-look",
                "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n       \\n\\t   int lo =0; int hi=nums.length-1; int r=-1;\\n        \\n       //Simple Binary Search Algo to find first Occurence;\\n        while(lo<=hi){\\n            int mid =lo+(hi-lo)/2;\\n            if(nums[mid]==target){\\n                r=mid;hi=mid-1;\\n            }else if(nums[mid]>target){\\n                hi=mid-1;\\n            }else{\\n                lo=mid+1;\\n            }\\n        }\\n        \\n        //If element doesn\\'t found return -1 for both ;\\n        if(r==-1) return new int[] {-1,-1};\\n        \\n        int[] arr = new int[2];//Create a array of size 2;\\n        arr[0]=r;//put value of 1st Occurence\\n        \\n       //Simple Binary Search Algo to find last Occurence;\\n        lo=r;hi=nums.length-1;\\n        while(lo<=hi){\\n            int mid =lo+(hi-lo)/2;\\n            if(nums[mid]==target){\\n                lo=mid+1;r=mid;\\n            }else if(nums[mid]>target){\\n                hi=mid-1;\\n            }else{\\n                lo=mid+1;\\n            }\\n        }\\n        \\n        arr[1]=r;//put value of last Occurence\\n        return arr;\\n        \\n      //Time Complexity O(log n)+O(log n) i.e. O(log n)\\n      // Space Complexity O(1);\\n    }\\n}\\n\\n//Do upvote if you like\\n//Comment if you want to suggest some changes",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n       \\n\\t   int lo =0; int hi=nums.length-1; int r=-1;\\n        \\n       //Simple Binary Search Algo to find first Occurence;\\n        while(lo<=hi){\\n            int mid =lo+(hi-lo)/2;\\n            if(nums[mid]==target){\\n                r=mid;hi=mid-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 634098,
                "title": "python-bisect",
                "content": "I know in a real world interview you would probably not use this, as it doesn\\'t demonstrate any knowledge of binary search in itself. Still, funny how easy python makes this.\\n\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        if not nums:\\n            return [-1, -1]\\n        \\n        left,right = bisect.bisect_left(nums, target), bisect.bisect_right(nums, target)\\n                \\n        return [left, right - 1] if left < right else [-1, -1]\\n    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        if not nums:\\n            return [-1, -1]\\n        \\n        left,right = bisect.bisect_left(nums, target), bisect.bisect_right(nums, target)\\n                \\n        return [left, right - 1] if left < right else [-1, -1]\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584784,
                "title": "python-solution-faster-than-99-10-explained-with-comments",
                "content": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        if not nums: return (-1, -1)\\n        \\n        # finding left most index (1st occurence) of target\\n        # when this function is called, r is already at the target (may not be the left most)\\n        # l is at the 1st index (0) and in this range all values are <= target\\n        def find_left(nums, l, r, target):\\n            while l < r:\\n                mid = l + (r - l) // 2\\n                if nums[mid] < target: l = mid + 1\\n                # As all values are <= target and previous if is is not entered,\\n                # That means nums[mid] == target now.\\n                # So, now if we find that nums[mid] is preceded by a smaller\\n                # Number, then that is the left most ocuurence of target\\n                elif nums[mid-1] < target: return mid\\n                # We are in the midst of target values\\n                # Reduce r to mid\\n                else: r = mid - 1\\n            return l\\n        \\n        # Finding right most index (last occurence) of target\\n        # When this function is called, l is already at the target (may not be the right most)\\n        # r is at the last index (len(nums)-1) and in this range all values are >= target\\n        def find_right(nums, l, r, target):\\n            while l < r:\\n                mid = l + (r - l) // 2\\n                if nums[mid] > target: r = mid - 1\\n                # As all values are >= target and previous if is is not entered,\\n                # That means nums[mid] == target now.\\n                # So, now if we find that nums[mid] is followe by a greater\\n                # number, then that is the right most ocuurence of target\\n                elif nums[mid+1] > target: return mid\\n                # We are in the midst of target values\\n                # Increase l to mid\\n                else: l = mid + 1\\n            return r\\n        \\n\\t\\t# Binary search on whole array to find a random index of target\\n        l, r = 0, len(nums) - 1\\n        while l <= r:\\n            mid = l + (r - l) // 2\\n            if nums[mid] < target: l = mid + 1\\n            elif nums[mid] > target: r = mid - 1\\n            else: \\n\\t\\t\\t\\t# A random index of target is found\\n                return [find_left(nums, 0, mid, target), find_right(nums, mid, len(nums)-1, target)]\\n        return (-1, -1)\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        if not nums: return (-1, -1)\\n        \\n        # finding left most index (1st occurence) of target\\n        # when this function is called, r is already at the target (may not be the left most)\\n        # l is at the 1st index (0) and in this range all values are <= target\\n        def find_left(nums, l, r, target):\\n            while l < r:\\n                mid = l + (r - l) // 2\\n                if nums[mid] < target: l = mid + 1\\n                # As all values are <= target and previous if is is not entered,\\n                # That means nums[mid] == target now.\\n                # So, now if we find that nums[mid] is preceded by a smaller\\n                # Number, then that is the left most ocuurence of target\\n                elif nums[mid-1] < target: return mid\\n                # We are in the midst of target values\\n                # Reduce r to mid\\n                else: r = mid - 1\\n            return l\\n        \\n        # Finding right most index (last occurence) of target\\n        # When this function is called, l is already at the target (may not be the right most)\\n        # r is at the last index (len(nums)-1) and in this range all values are >= target\\n        def find_right(nums, l, r, target):\\n            while l < r:\\n                mid = l + (r - l) // 2\\n                if nums[mid] > target: r = mid - 1\\n                # As all values are >= target and previous if is is not entered,\\n                # That means nums[mid] == target now.\\n                # So, now if we find that nums[mid] is followe by a greater\\n                # number, then that is the right most ocuurence of target\\n                elif nums[mid+1] > target: return mid\\n                # We are in the midst of target values\\n                # Increase l to mid\\n                else: l = mid + 1\\n            return r\\n        \\n\\t\\t# Binary search on whole array to find a random index of target\\n        l, r = 0, len(nums) - 1\\n        while l <= r:\\n            mid = l + (r - l) // 2\\n            if nums[mid] < target: l = mid + 1\\n            elif nums[mid] > target: r = mid - 1\\n            else: \\n\\t\\t\\t\\t# A random index of target is found\\n                return [find_left(nums, 0, mid, target), find_right(nums, mid, len(nums)-1, target)]\\n        return (-1, -1)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 418998,
                "title": "javascript-binary-search-98",
                "content": "First stab at it. It\\'s pretty ugly but also just a typical binary search implementation. The approach comes in two major steps.\\n \\n**First, find the value**\\n1. Create range of indicies.\\n2. Find the middle of that range.\\n3. Compare middle with target.\\n\\t- If the middle value is greater than target, assign (center index - 1) to the end index and go back to step 2.\\n\\t- If the middle value is less than the target, assign (center index + 1) to the start index and got back to step 2.\\n\\t- If the middle value is target, break and go to the next step.\\n\\n**Second, find the edges**\\n1. Reassign the center index to the start and end indicies.\\n2. Increment the end index value until the next value does not equal the target.\\n3. Decrement the start index value until the next value does not equal the target.\\n\\n```js\\n\\nvar searchRange = function(nums, target) {\\n    const length = nums.length - 1;\\n    let start = 0;\\n    let end = length;\\n    let center;\\n    \\n    // get the center\\n    while (start <= end) {\\n        center = Math.floor((start + end) / 2);\\n        if (nums[center] === target) {\\n            start = center;\\n            end = center;\\n            break;\\n        }\\n        else if (nums[center] < target) start = center + 1;\\n        else end = center - 1;\\n    }\\n\\n    if (start > end) return [-1, -1];\\n    \\n    // find the edges\\n    while (nums[start - 1] === target) start--;\\n    while (nums[end + 1] === target) end++;\\n    return [start, end];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```js\\n\\nvar searchRange = function(nums, target) {\\n    const length = nums.length - 1;\\n    let start = 0;\\n    let end = length;\\n    let center;\\n    \\n    // get the center\\n    while (start <= end) {\\n        center = Math.floor((start + end) / 2);\\n        if (nums[center] === target) {\\n            start = center;\\n            end = center;\\n            break;\\n        }\\n        else if (nums[center] < target) start = center + 1;\\n        else end = center - 1;\\n    }\\n\\n    if (start > end) return [-1, -1];\\n    \\n    // find the edges\\n    while (nums[start - 1] === target) start--;\\n    while (nums[end + 1] === target) end++;\\n    return [start, end];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 14910,
                "title": "the-insert-position-trick",
                "content": "Just imagine where we should insert target+0.5 and target-0.5 into this array.\\n\\n    class Solution {\\n    public:\\n        vector<int> searchRange(vector<int>& nums, int target) {\\n            int t = insertPosition(nums, target - 0.5);\\n            if (target != nums[t]) {\\n                return {-1, -1};\\n            }\\n            return {t, insertPosition(nums, target + 0.5) - 1};\\n        }\\n    private:\\n        int insertPosition(vector<int>& nums, double target) {\\n            int l = 0;\\n            int r = nums.size() - 1;\\n            while (l <= r) {\\n                int mid = l + ((r - l) >> 1);\\n                if (target < nums[mid]) {\\n                    r = mid - 1;\\n                } else {\\n                    l = mid + 1;\\n                }\\n            }\\n            return l;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> searchRange(vector<int>& nums, int target) {\\n            int t = insertPosition(nums, target - 0.5);\\n            if (target != nums[t]) {\\n                return {-1, -1}",
                "codeTag": "Java"
            },
            {
                "id": 3649422,
                "title": "cpp-binary-search-upper-bound-lower-bound",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) \\n    {\\n        int low = lower_bound(nums.begin() , nums.end() , target) - nums.begin();    \\n        int high = upper_bound(nums.begin() , nums.end() , target) - nums.begin();\\n        if(low<nums.size() && nums[low]==target)\\n        {\\n            return {low,high-1};\\n        }\\n        return {-1,-1};\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) \\n    {\\n        int low = lower_bound(nums.begin() , nums.end() , target) - nums.begin();    \\n        int high = upper_bound(nums.begin() , nums.end() , target) - nums.begin();\\n        if(low<nums.size() && nums[low]==target)\\n        {\\n            return {low,high-1};\\n        }\\n        return {-1,-1};\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542485,
                "title": "simple-easy-to-understand-solution-using-upper-lower-bounds",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->We can find upper bound & lower bound to find last & first index of target respectively.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing the inbuilt upper & lower bound functions.\\nAs lower bound will return the index of target appearing first time(because this is used for finding a number which is just less than the target) and upper bound will return the index of target appearing for last time(because this is used for finding a number which is just greater than the target) in the array. \\n\\n# Complexity\\n- Time complexity:O(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) \\n    {\\n        int x,y;\\n        if(binary_search (nums.begin(), nums.end(), target))\\n        {\\n            x = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n            y = upper_bound(nums.begin(), nums.end(), target) - nums.begin()-1;\\n        }\\n        else \\n        {\\n            return{-1,-1};\\n        }\\n        return {x,y};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) \\n    {\\n        int x,y;\\n        if(binary_search (nums.begin(), nums.end(), target))\\n        {\\n            x = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n            y = upper_bound(nums.begin(), nums.end(), target) - nums.begin()-1;\\n        }\\n        else \\n        {\\n            return{-1,-1};\\n        }\\n        return {x,y};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176028,
                "title": "shocking-logic-python3",
                "content": "\\n# First find target index and Traverse reverse Again\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        list2=[-1,-1]\\n        list1=[]\\n        if nums.count(target)>0:\\n            list1.append(nums.index(target))\\n            for i in range(len(nums)-1,-1,-1):\\n                if nums[i]== target:\\n                    list1.append(i)\\n                    break\\n        else:\\n            return list2\\n        return list1\\n//please upvote me it would encourage me alot\\n\\n```\\n# Binary Search Logic---->O(LogN)\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        list1=[]\\n        def search(target):\\n            left,right=0,len(nums)-1\\n            while left<=right:\\n                mid=(left+right)//2\\n                if nums[mid]<target:\\n                    left=mid+1\\n                else:\\n                    right=mid-1\\n            return left\\n        l=search(target)\\n        r=search(target+1)-1\\n        if l<=r:\\n            return [l,r]\\n        return [-1,-1]\\n\\n\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        list2=[-1,-1]\\n        list1=[]\\n        if nums.count(target)>0:\\n            list1.append(nums.index(target))\\n            for i in range(len(nums)-1,-1,-1):\\n                if nums[i]== target:\\n                    list1.append(i)\\n                    break\\n        else:\\n            return list2\\n        return list1\\n//please upvote me it would encourage me alot\\n\\n```\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        list1=[]\\n        def search(target):\\n            left,right=0,len(nums)-1\\n            while left<=right:\\n                mid=(left+right)//2\\n                if nums[mid]<target:\\n                    left=mid+1\\n                else:\\n                    right=mid-1\\n            return left\\n        l=search(target)\\n        r=search(target+1)-1\\n        if l<=r:\\n            return [l,r]\\n        return [-1,-1]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117795,
                "title": "easily-understandable-solution-beats-99-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        v.push_back(-1);\\n        v.push_back(-1);\\n        int st=0;int end=nums.size()-1;\\n        while(st<=end){\\n           int mid=(st+end)/2;\\n           if(nums[mid]==target){\\n               v[0]=mid;\\n               end=mid-1;\\n           }else if(nums[mid]<target){\\n               st=mid+1;\\n           }else{\\n               end=mid-1;\\n           }\\n          \\n        }\\n         st=0;end=nums.size()-1;\\n         while(st<=end){\\n           int mid=(st+end)/2;\\n           if(nums[mid]==target){\\n               v[1]=mid;\\n               st=mid+1;\\n           }else if(nums[mid]<target){\\n               st=mid+1;\\n           }else{\\n               end=mid-1;\\n           }\\n        }\\n        return v;\\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        v.push_back(-1);\\n        v.push_back(-1);\\n        int st=0;int end=nums.size()-1;\\n        while(st<=end){\\n           int mid=(st+end)/2;\\n           if(nums[mid]==target){\\n               v[0]=mid;\\n               end=mid-1;\\n           }else if(nums[mid]<target){\\n               st=mid+1;\\n           }else{\\n               end=mid-1;\\n           }\\n          \\n        }\\n         st=0;end=nums.size()-1;\\n         while(st<=end){\\n           int mid=(st+end)/2;\\n           if(nums[mid]==target){\\n               v[1]=mid;\\n               st=mid+1;\\n           }else if(nums[mid]<target){\\n               st=mid+1;\\n           }else{\\n               end=mid-1;\\n           }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098375,
                "title": "best-o-logn-solution",
                "content": "# Approach 1\\nLinear Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector <int> ans(2, -1);\\n\\n        // Finding index of first occurrence\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == target) {\\n                ans[0] = i;\\n                break;\\n            }\\n        }\\n\\n        // Finding index of last occurrence\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            if (nums[i] == target) {\\n                ans[1] = i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Approach 2\\nBinary Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector <int> ans(2, -1);\\n        int n = nums.size();\\n\\n        // Finding index of first occurrence\\n        int low = 0, high = n - 1;\\n        int mid;\\n        while (low <= high) {\\n            mid = (low + high) / 2;\\n            if (nums[mid] > target)\\n                high = mid - 1;\\n            else if (nums[mid] < target)\\n                low = mid + 1;  \\n            else {\\n                if (mid == 0 || nums[mid] != nums[mid - 1]) {\\n                    ans[0] = mid;\\n                    break;\\n                } else {\\n                    high = mid - 1;\\n                }    \\n            }          \\n        }\\n\\n        // Finding index of last occurrence\\n        low = 0, high = n - 1;\\n        while (low <= high) {\\n            mid = (low + high) / 2;\\n            if (nums[mid] > target)\\n                high = mid - 1;\\n            else if (nums[mid] < target)\\n                low = mid + 1;  \\n            else {\\n                if (mid == n - 1 || nums[mid] != nums[mid + 1]) {\\n                    ans[1] = mid;\\n                    break;\\n                } else {\\n                    low = mid + 1;\\n                }    \\n            }          \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector <int> ans(2, -1);\\n\\n        // Finding index of first occurrence\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == target) {\\n                ans[0] = i;\\n                break;\\n            }\\n        }\\n\\n        // Finding index of last occurrence\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            if (nums[i] == target) {\\n                ans[1] = i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector <int> ans(2, -1);\\n        int n = nums.size();\\n\\n        // Finding index of first occurrence\\n        int low = 0, high = n - 1;\\n        int mid;\\n        while (low <= high) {\\n            mid = (low + high) / 2;\\n            if (nums[mid] > target)\\n                high = mid - 1;\\n            else if (nums[mid] < target)\\n                low = mid + 1;  \\n            else {\\n                if (mid == 0 || nums[mid] != nums[mid - 1]) {\\n                    ans[0] = mid;\\n                    break;\\n                } else {\\n                    high = mid - 1;\\n                }    \\n            }          \\n        }\\n\\n        // Finding index of last occurrence\\n        low = 0, high = n - 1;\\n        while (low <= high) {\\n            mid = (low + high) / 2;\\n            if (nums[mid] > target)\\n                high = mid - 1;\\n            else if (nums[mid] < target)\\n                low = mid + 1;  \\n            else {\\n                if (mid == n - 1 || nums[mid] != nums[mid + 1]) {\\n                    ans[1] = mid;\\n                    break;\\n                } else {\\n                    low = mid + 1;\\n                }    \\n            }          \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949964,
                "title": "100-faster-java-c-easy-solution-with-explanation",
                "content": "-> first by binary search we see element is present in array or not.\\n\\n-> if element not present so first and last index is -1,-1.\\n\\n-> if element present in array than search using while loop go till first index and last index.\\n\\n\\n# Approach\\nBinary Search and Linear Search both\\n\\n# Complexity\\n- Time complexity:\\n- best case O(log n)\\n    - when element not present in array than binary search gives return -1 so answer becomes {-1,-1}\\n-Avearge && Worst case\\n    -Time compexity of binary search + Time complexity of linear search=O(log n)+O(n)=O(n)\\n\\n\\n# JAVA Code\\n```\\nclass Solution {\\n    \\n    public int[] searchRange(int[] nums, int target) \\n    {\\n        int[] ans={-1,-1};\\n        int n=nums.length;\\n\\n        int index=find(nums,0,n-1,target); \\n        //Checking element is present or not in array.\\n\\n\\n        if(index!=-1)\\n        {\\n            ans[0]=index;\\n            ans[1]=index;\\n\\n            while(index-1>=0 && nums[index-1]==target)//move back till first index\\n                ans[0]=--index;\\n\\n            while(index+1<n && nums[index+1]==target)//move forward till last index\\n                ans[1]=++index;\\n            \\n        }\\n\\n        return ans;\\n    }\\n\\n    public int find(int[] nums,int s,int e,int target) //binary search function\\n    {\\n        if(s<=e)\\n        {\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(target>nums[mid])\\n                return find(nums,mid+1,e,target);\\n            else\\n                return find(nums,s,mid-1,target);            \\n        }\\n        return -1;\\n    }\\n}\\n```\\n# C++ Code\\nclass Solution {\\npublic:\\n   \\n    vector<int> searchRange(vector<int>& nums, int target) \\n    {\\n        vector<int> ans={-1,-1};\\n        int n=nums.size();\\n    \\n        int index=find(nums,0,n-1,target);\\n        //Checking element is present or not in array.\\n\\n\\n\\n        if(index!=-1)\\n        {\\n            ans[0]=index;\\n            ans[1]=index;\\n\\n            while(index-1>=0 && nums[index-1]==target)//move back till first index\\n            {\\n                ans[0]=--index;\\n            }\\n            while(index+1<n && nums[index+1]==target)//move forward till last index\\n            {\\n                ans[1]=++index;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n    int find(vector<int>& nums,int s,int e,int target)//binary search function\\n    {\\n        if(s<=e)\\n        {\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(target>nums[mid])\\n                return find(nums,mid+1,e,target);\\n            else\\n                return find(nums,s,mid-1,target);            \\n        }\\n        return -1;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int[] searchRange(int[] nums, int target) \\n    {\\n        int[] ans={-1,-1};\\n        int n=nums.length;\\n\\n        int index=find(nums,0,n-1,target); \\n        //Checking element is present or not in array.\\n\\n\\n        if(index!=-1)\\n        {\\n            ans[0]=index;\\n            ans[1]=index;\\n\\n            while(index-1>=0 && nums[index-1]==target)//move back till first index\\n                ans[0]=--index;\\n\\n            while(index+1<n && nums[index+1]==target)//move forward till last index\\n                ans[1]=++index;\\n            \\n        }\\n\\n        return ans;\\n    }\\n\\n    public int find(int[] nums,int s,int e,int target) //binary search function\\n    {\\n        if(s<=e)\\n        {\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(target>nums[mid])\\n                return find(nums,mid+1,e,target);\\n            else\\n                return find(nums,s,mid-1,target);            \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666452,
                "title": "o-n-single-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& arr, int t) {\\n        int n = arr.size();\\n        vector<int> ans;\\n        int st = -1,en = -1;\\n        for(int i = 0;i<n;i++){\\n            if(arr[i] == t && st == -1){\\n                // cout<<\"1st if : \"<<i<<endl;\\n                st = i;\\n                en = i;\\n            }\\n            else if(arr[i] == t){\\n                // cout<<\"2nd if : \"<<i<<endl;\\n                en = i;\\n            }\\n        }\\n        ans.emplace_back(st);\\n        ans.emplace_back(en);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& arr, int t) {\\n        int n = arr.size();\\n        vector<int> ans;\\n        int st = -1,en = -1;\\n        for(int i = 0;i<n;i++){\\n            if(arr[i] == t && st == -1){\\n                // cout<<\"1st if : \"<<i<<endl;\\n                st = i;\\n                en = i;\\n            }\\n            else if(arr[i] == t){\\n                // cout<<\"2nd if : \"<<i<<endl;\\n                en = i;\\n            }\\n        }\\n        ans.emplace_back(st);\\n        ans.emplace_back(en);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2641673,
                "title": "accepted-c-solution-o-log-n",
                "content": "C++ Solution : \\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target)\\n    {\\n        vector<int> res(2,-1);\\n        int start=0,mid=0,end=nums.size()-1;\\n        \\n        while(start<=end)\\n        {\\n            mid=start+(end-start)/2;\\n            if(nums[mid]<target)\\n                start=mid+1;\\n            else\\n            {\\n                if(nums[mid]==target)\\n                    res[0]=mid;\\n                end=mid-1;\\n            }\\n        }\\n        start=0,end=nums.size()-1;\\n        while(start<=end)\\n        {\\n            mid=start+(end-start)/2;\\n            if(nums[mid]>target)\\n                end=mid-1;\\n            else\\n            {\\n                if(nums[mid]==target)\\n                    res[1]=mid;\\n                start=mid+1;\\n            }\\n        }\\n     return res;   \\n    }\\n};\\n```\\nTime complexity : O(log n)\\nSpace compexity : O(1)\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target)\\n    {\\n        vector<int> res(2,-1);\\n        int start=0,mid=0,end=nums.size()-1;\\n        \\n        while(start<=end)\\n        {\\n            mid=start+(end-start)/2;\\n            if(nums[mid]<target)\\n                start=mid+1;\\n            else\\n            {\\n                if(nums[mid]==target)\\n                    res[0]=mid;\\n                end=mid-1;\\n            }\\n        }\\n        start=0,end=nums.size()-1;\\n        while(start<=end)\\n        {\\n            mid=start+(end-start)/2;\\n            if(nums[mid]>target)\\n                end=mid-1;\\n            else\\n            {\\n                if(nums[mid]==target)\\n                    res[1]=mid;\\n                start=mid+1;\\n            }\\n        }\\n     return res;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329946,
                "title": "clean-c-solution-with-two-binary-searches-beats-100",
                "content": "The solution clearly implements Binary Search approach by modifying the search space and storing the current position of the target element (if found). \\n\\nIt uses two seperate private functions for getting the First and Last positions which are then called by the searchRange() function.\\n\\nprivate:\\n\\n    int firstPos(vector<int> arr, int target)  //function for first position of the target\\n    {\\n        int l=0;\\n        int r=arr.size()-1;\\n        int mid = l + (r-l)/2;\\n        int pos=-1;\\n        \\n        while(l<=r)\\n        {\\n            if(arr[mid]==target)\\n            {\\n                pos=mid;\\n                r=mid-1;\\n            }\\n            else if(target>arr[mid])\\n            {\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n            mid = l + (r-l)/2;\\n        }\\n        return pos;\\n    }\\n    \\n    int lastPos(vector<int> arr, int target)  //function for last position of the target\\n    {\\n        int l=0;\\n        int r=arr.size()-1;\\n        int mid = l + (r-l)/2;\\n        int pos=-1;\\n        \\n        while(l<=r)\\n        {\\n            if(arr[mid]==target)\\n            {\\n                pos=mid;\\n                l=mid+1;        \\n            }\\n            else if(target>arr[mid])\\n            {\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n            mid = l + (r-l)/2;\\n        }\\n        return pos;\\n    } \\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        ans.push_back(firstPos(nums,target));\\n        ans.push_back(lastPos(nums,target));\\n        return ans;\\n    }\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "The solution clearly implements Binary Search approach by modifying the search space and storing the current position of the target element (if found). \\n\\nIt uses two seperate private functions for getting the First and Last positions which are then called by the searchRange() function.\\n\\nprivate:\\n\\n    int firstPos(vector<int> arr, int target)  //function for first position of the target\\n    {\\n        int l=0;\\n        int r=arr.size()-1;\\n        int mid = l + (r-l)/2;\\n        int pos=-1;\\n        \\n        while(l<=r)\\n        {\\n            if(arr[mid]==target)\\n            {\\n                pos=mid;\\n                r=mid-1;\\n            }\\n            else if(target>arr[mid])\\n            {\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n            mid = l + (r-l)/2;\\n        }\\n        return pos;\\n    }\\n    \\n    int lastPos(vector<int> arr, int target)  //function for last position of the target\\n    {\\n        int l=0;\\n        int r=arr.size()-1;\\n        int mid = l + (r-l)/2;\\n        int pos=-1;\\n        \\n        while(l<=r)\\n        {\\n            if(arr[mid]==target)\\n            {\\n                pos=mid;\\n                l=mid+1;        \\n            }\\n            else if(target>arr[mid])\\n            {\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n            mid = l + (r-l)/2;\\n        }\\n        return pos;\\n    } \\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        ans.push_back(firstPos(nums,target));\\n        ans.push_back(lastPos(nums,target));\\n        return ans;\\n    }\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2329756,
                "title": "by-using-stl-easy-understanding-5-line-code",
                "content": "```\\n//please upvote if u like\\nvector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v{-1,-1};\\n        int low = lower_bound(nums.begin(),nums.end(),target) - nums.begin();\\n        int high = upper_bound(nums.begin(),nums.end(),target) - nums.begin();\\n        if(!binary_search(nums.begin(),nums.end(),target)) return v;\\n        v[0] = low, v[1] = high-1;\\n        return v;\\n    }\\n// please upvote if u like :)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n//please upvote if u like\\nvector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v{-1,-1};\\n        int low = lower_bound(nums.begin(),nums.end(),target) - nums.begin();\\n        int high = upper_bound(nums.begin(),nums.end(),target) - nums.begin();\\n        if(!binary_search(nums.begin(),nums.end(),target)) return v;\\n        v[0] = low, v[1] = high-1;\\n        return v;\\n    }\\n// please upvote if u like :)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2329477,
                "title": "c-binary-search-o-logn-concise-clear-code-easy-to-understand-solution",
                "content": "### UPVOTE IF YOU LIKE\\n\\n### ***C++ Code :***\\n```\\nclass Solution {\\npublic:\\n    int bsf(vector<int>& nums, int target){\\n        int l=0, r=nums.size()-1, mid;\\n        while(l<=r){\\n            mid = (r-l)/2+l;\\n            if(nums[mid]<target)l=mid+1;\\n            else r=mid-1;\\n        }\\n        if(l==nums.size() || nums[l]!=target)return -1;\\n        return l;\\n    }\\n    int bsl(vector<int>& nums, int target){\\n        int l=0, r=nums.size()-1, mid;\\n        while(l<=r){\\n            mid = (r-l)/2+l;\\n            if(nums[mid]>target)r=mid-1;\\n            else l=mid+1;\\n        }\\n        if(r<0 || nums[r]!=target)return -1;\\n        return r;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans(2);\\n        ans[0] = bsf(nums, target);\\n        ans[1] = bsl(nums, target);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int bsf(vector<int>& nums, int target){\\n        int l=0, r=nums.size()-1, mid;\\n        while(l<=r){\\n            mid = (r-l)/2+l;\\n            if(nums[mid]<target)l=mid+1;\\n            else r=mid-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1684808,
                "title": "beats-97-modified-binary-search-in-python",
                "content": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        #Time: O(log n)\\n        #Space: O(1)\\n        \\n\\t\\t#Essentially a modified binary search\\n\\t\\t#To find the first occurence of a number, scan the remaining left part\\n\\t\\t#To find the last occurence of a number, scan the remaining right part\\n\\t\\t\\n        def binarySearch(find):\\n            left, right = 0, len(nums) - 1\\n            output = -1\\n            \\n            while left <= right:\\n                mid = (left + right) // 2\\n                \\n                if nums[mid] > target:\\n                    right = mid - 1\\n                elif nums[mid] < target:\\n                    left = mid + 1\\n                else:\\n                    output = mid\\n                    \\n\\t\\t\\t\\t\\t#This is the only modification to a standard binary search\\n                    if find == \\'first\\': #To find the first occurence, look to the left\\n                        right = mid - 1\\n                    elif find == \\'last\\': #To find the last occurence, look to the right\\n                        left = mid + 1\\n            \\n            return output\\n            \\n        return [binarySearch(\\'first\\'), binarySearch(\\'last\\')]\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        #Time: O(log n)\\n        #Space: O(1)\\n        \\n\\t\\t#Essentially a modified binary search\\n\\t\\t#To find the first occurence of a number, scan the remaining left part\\n\\t\\t#To find the last occurence of a number, scan the remaining right part\\n\\t\\t\\n        def binarySearch(find):\\n            left, right = 0, len(nums) - 1\\n            output = -1\\n            \\n            while left <= right:\\n                mid = (left + right) // 2\\n                \\n                if nums[mid] > target:\\n                    right = mid - 1\\n                elif nums[mid] < target:\\n                    left = mid + 1\\n                else:\\n                    output = mid\\n                    \\n\\t\\t\\t\\t\\t#This is the only modification to a standard binary search\\n                    if find == \\'first\\': #To find the first occurence, look to the left\\n                        right = mid - 1\\n                    elif find == \\'last\\': #To find the last occurence, look to the right\\n                        left = mid + 1\\n            \\n            return output\\n            \\n        return [binarySearch(\\'first\\'), binarySearch(\\'last\\')]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592917,
                "title": "go-binary",
                "content": "```\\nfunc searchRange(nums []int, target int) []int {\\n    if len(nums) == 0 {\\n        return []int{-1, -1}\\n    }\\n    return []int{binaryLeft(nums, target), binaryRight(nums, target)}\\n}\\n\\n\\nfunc binaryLeft(nums []int, target int) int {\\n    left, right := 0, len(nums)-1\\n    \\n    for left < right {\\n        mid := (right + left)/2\\n        if nums[mid] < target {\\n            left = mid + 1\\n        } else {\\n            right = mid\\n        }\\n    }\\n    if nums[left] == target {\\n        return left\\n    } \\n    return -1\\n}\\n\\n\\nfunc binaryRight(nums []int, target int) int {\\n    left, right := 0, len(nums)-1\\n    \\n    for left < right {\\n        mid := (right + left)/2 + 1\\n        if nums[mid] > target {\\n            right = mid - 1\\n        } else if nums[mid] <= target {\\n            left = mid\\n        }\\n    }\\n    if nums[left] == target {\\n        return left\\n    } \\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc searchRange(nums []int, target int) []int {\\n    if len(nums) == 0 {\\n        return []int{-1, -1}\\n    }\\n    return []int{binaryLeft(nums, target), binaryRight(nums, target)}\\n}\\n\\n\\nfunc binaryLeft(nums []int, target int) int {\\n    left, right := 0, len(nums)-1\\n    \\n    for left < right {\\n        mid := (right + left)/2\\n        if nums[mid] < target {\\n            left = mid + 1\\n        } else {\\n            right = mid\\n        }\\n    }\\n    if nums[left] == target {\\n        return left\\n    } \\n    return -1\\n}\\n\\n\\nfunc binaryRight(nums []int, target int) int {\\n    left, right := 0, len(nums)-1\\n    \\n    for left < right {\\n        mid := (right + left)/2 + 1\\n        if nums[mid] > target {\\n            right = mid - 1\\n        } else if nums[mid] <= target {\\n            left = mid\\n        }\\n    }\\n    if nums[left] == target {\\n        return left\\n    } \\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1527418,
                "title": "simple-bs-approach-java-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int[] ans = {-1,-1};\\n        \\n        ans[0] = search(nums,target,true);\\n        ans[1] = search(nums,target,false);\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int search(int[] nums,int target, boolean isFirstOccurence){\\n        int index = -1;\\n        int start = 0;\\n        int end = nums.length - 1;\\n        \\n        while(start <= end){\\n            int mid =start + (end - start)/2;\\n            \\n            if(target>nums[mid]){\\n                start = mid+1;\\n            }else if(target < nums[mid]){\\n                end = mid -1;\\n            }else{\\n                index=mid;\\n                if(isFirstOccurence){\\n                    end=mid-1;\\n                }else{\\n                    start=mid+1;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int[] ans = {-1,-1};\\n        \\n        ans[0] = search(nums,target,true);\\n        ans[1] = search(nums,target,false);\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int search(int[] nums,int target, boolean isFirstOccurence){\\n        int index = -1;\\n        int start = 0;\\n        int end = nums.length - 1;\\n        \\n        while(start <= end){\\n            int mid =start + (end - start)/2;\\n            \\n            if(target>nums[mid]){\\n                start = mid+1;\\n            }else if(target < nums[mid]){\\n                end = mid -1;\\n            }else{\\n                index=mid;\\n                if(isFirstOccurence){\\n                    end=mid-1;\\n                }else{\\n                    start=mid+1;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203511,
                "title": "step-by-step-commentary-two-binary-search-logn-complexity-js-es6",
                "content": "`Algorithm:`\\n> - Start with a classic Binary search solution\\n> - Do not stop at the target rather continue traversing to the left side of the list. \\n> - Pay close attention to code difference between two binary search: \\n\\t\\t\\t> First-Position Vs Last-Position \\n\\t\\t\\t> Notice the difference in equality \"=\" sign\\n> - At the end of first binary search, if the number wasn\\'t found, terminate early and return [-1,-1]\\n> - Perform second binary search for Last-Position\\n\\t> Return results\\n```\\nconst searchRange = function(nums, target) {\\n    let firstPosition = -1, lastPosition = -1;\\n    let lo = 0, hi=nums.length-1; \\n    \\n    // Search firstPosition\\n    while(lo<=hi){\\n        let mid = Math.floor((lo+hi)/2);\\n        if(nums[mid] >= target) hi = mid-1;\\n        else lo=mid+1;\\n    }\\n    \\n    // Check if number exists\\n    if(nums[lo] !== target) return [-1, -1];\\n    firstPosition = lo;\\n    \\n    // Reset pointers\\n    let lo =0, hi=nums.length-1; \\n    \\n    // Search lastPosition\\n    while(lo<=hi){\\n        let mid =  Math.floor((lo+hi)/2);\\n        if(nums[mid] > target) hi = mid-1;\\n        else lo=mid+1;\\n    }\\n    lastPosition=hi;\\n    \\n    return [firstPosition, lastPosition]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nconst searchRange = function(nums, target) {\\n    let firstPosition = -1, lastPosition = -1;\\n    let lo = 0, hi=nums.length-1; \\n    \\n    // Search firstPosition\\n    while(lo<=hi){\\n        let mid = Math.floor((lo+hi)/2);\\n        if(nums[mid] >= target) hi = mid-1;\\n        else lo=mid+1;\\n    }\\n    \\n    // Check if number exists\\n    if(nums[lo] !== target) return [-1, -1];\\n    firstPosition = lo;\\n    \\n    // Reset pointers\\n    let lo =0, hi=nums.length-1; \\n    \\n    // Search lastPosition\\n    while(lo<=hi){\\n        let mid =  Math.floor((lo+hi)/2);\\n        if(nums[mid] > target) hi = mid-1;\\n        else lo=mid+1;\\n    }\\n    lastPosition=hi;\\n    \\n    return [firstPosition, lastPosition]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1181940,
                "title": "c-short-std-equal-range-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        auto [l, r] = equal_range(begin(nums), end(nums), target);\\n        if (l == end(nums) || *l != target)\\n            return {-1, -1};\\n\\n        int i = l - begin(nums), j = r - 1 - begin(nums);\\n        return {i, j};\\n    }\\n};\\n```\\n\\n[See `std::equal_range()`](https://en.cppreference.com/w/cpp/algorithm/equal_range) (it performs both a `std::lower_bound()` and `std::upper_bound()` in one call).",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        auto [l, r] = equal_range(begin(nums), end(nums), target);\\n        if (l == end(nums) || *l != target)\\n            return {-1, -1};\\n\\n        int i = l - begin(nums), j = r - 1 - begin(nums);\\n        return {i, j};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181869,
                "title": "find-first-and-last-position-of-element-in-sorted-array-simple-solution-explained",
                "content": "**DO UPVOTE if you find it helpful!!**\\n\\n**Approach-1 : Brute force**: We have to just iterate the nums array and find the first and last position of target. This solution got accepted since the constraints are small (10^5). I wonder why the constraints for this question are such small, because this is not the efficient way for this problem!! \\n```\\nvector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>res = {-1,-1};\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == target){\\n                if(res[0] == -1)\\n                    res[0] = i,res[1]=i;\\n                else\\n                    res[1] =i;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**Time Complexity**:O(n)\\n**Space Complexity**:O(1)\\n\\n**Approach-2: Binary Search**: Here we use two binary searches to find first and last occurance of target.\\n```\\nvector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>res = {-1,-1};\\n        if(nums.size()==0) return res;\\n        int i=0, j= nums.size()-1;\\n        // finding the first occurance of target in nums array\\n        while(i<j){\\n            int mid = (i+j)/2;\\n            if(nums[mid] < target)\\n                i=mid+1;\\n            else \\n                j = mid;\\n        }\\n        if(nums[j] == target) res[0] =j;    \\n        else return res;                // If there is no first occurance, then we directly return res\\n        j=nums.size()-1;                //again we dont have to initialize i from beginning\\n        // Finding last occurance of target in nums array\\n        while(i<j){\\n            int mid = (i+j)/2+1;        // To make sure that mid is biased towards right, \\n            if(nums[mid]<=target)       // so that, it wont stuck at a particular case.\\n                i = mid;\\n            else \\n                j = mid-1;\\n        }\\n        res[1] =j;\\n        return res;\\n    }\\n```\\n**Time Complexity**:O(log(n))\\n**Space Complexity**:O(1)\\n\\n**Note:** There is other approach using STL, making use of inbuilt functions like `lower_bound` and `upper_bound`. But, this is not an ideal way to solve for this problem, many interviewers expect to solve this problem using binary search approach.",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nvector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>res = {-1,-1};\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == target){\\n                if(res[0] == -1)\\n                    res[0] = i,res[1]=i;\\n                else\\n                    res[1] =i;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\nvector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>res = {-1,-1};\\n        if(nums.size()==0) return res;\\n        int i=0, j= nums.size()-1;\\n        // finding the first occurance of target in nums array\\n        while(i<j){\\n            int mid = (i+j)/2;\\n            if(nums[mid] < target)\\n                i=mid+1;\\n            else \\n                j = mid;\\n        }\\n        if(nums[j] == target) res[0] =j;    \\n        else return res;                // If there is no first occurance, then we directly return res\\n        j=nums.size()-1;                //again we dont have to initialize i from beginning\\n        // Finding last occurance of target in nums array\\n        while(i<j){\\n            int mid = (i+j)/2+1;        // To make sure that mid is biased towards right, \\n            if(nums[mid]<=target)       // so that, it wont stuck at a particular case.\\n                i = mid;\\n            else \\n                j = mid-1;\\n        }\\n        res[1] =j;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935218,
                "title": "c-two-solutions",
                "content": "# Solution 1\\n\\n```\\nclass Solution {\\nprivate:\\n    int m_findLow(vector<int> &nums, int target, int low, int high)\\n    {\\n        int mid;\\n        while (low <= high) {\\n            mid = low + (high-low)/2;\\n\\t\\t\\t//Advance low only if it is not pointing to target\\n            if( nums[mid] == target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n\\n    int m_findHigh(vector<int> &nums, int target, int low, int high)\\n    {\\n        int mid;\\n        while (low <= high) {\\n            mid = low + (high-low)/2;\\n\\t\\t\\t//Advance high only if it is not pointing to target\\n            if( nums[mid] == target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return high;\\n    }\\n\\t\\npublic:\\n\\n    vector<int> searchRange(vector<int> &nums, int target)\\n    {\\n        int size = nums.size(), low = 0, high = size - 1, mid;\\n        vector<int> pos(2, -1);\\n\\n        while (low <= high) {\\n            mid = low + (high - low) / 2;\\n\\t\\t\\t\\n\\t\\t\\t//First check if the target is present in the list at all\\n            if (nums[mid] == target) {\\n                if (nums[low] != target) {\\n\\t\\t\\t\\t\\t//Low should be in the lower half\\n                    low = m_findLow(nums, target, low, mid);\\n                }\\n                if (nums[high] != target) {\\n\\t\\t\\t\\t\\t//High should be in the upper half\\n                    high = m_findHigh(nums, target, mid, high);\\n                }\\n                pos[0] = low;\\n                pos[1] = high;\\n                break;\\n            }\\n            else if (nums[mid] > target && nums[high] != target) {\\n                high = mid - 1;\\n            }\\n            else if (nums[mid] < target && nums[low] != target) {\\n                low = mid + 1;\\n            }\\n        }\\n        return pos;\\n    }\\n};\\n```\\n\\n# Solution 2\\nRuntime: 4 ms, faster than 95.75% of C++ online submissions for Find First and Last Position of Element in Sorted Array.\\nMemory Usage: 13.7 MB, less than 12.23% of C++ online submissions for Find First and Last Position of Element in Sorted Array.\\n\\n```\\nclass Solution {\\n\\tint findLow(const vector<int>& nums, int target) {\\n\\t\\tint low = 0, high = nums.size() - 1, mid = 0, lowPos = -1;\\n\\n\\t\\twhile (low <= high) {\\n\\t\\t\\tmid = low + (high - low) / 2;\\n\\n\\t\\t\\tif (target < nums[mid]) {\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (target > nums[mid]) {\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tlowPos = mid;\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn lowPos;\\n\\t}\\n\\n\\tint findHigh(const vector<int>& nums, int target, int l) {\\n\\t\\tint low = l, high = nums.size() - 1, mid = 0, highPos = -1;\\n\\n\\t\\twhile (low <= high) {\\n\\t\\t\\tmid = low + (high - low) / 2;\\n\\t\\t\\tif (target < nums[mid]) {\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (target > nums[mid]) {\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\thighPos = mid;\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn highPos;\\n\\t}\\npublic:\\n\\tvector<int> searchRange(vector<int>& nums, int target)\\n\\t{\\n\\t\\tint low = findLow(nums, target);\\n\\t\\tint high = -1;\\n\\t\\tif (low >= 0)\\n\\t\\t\\thigh = findHigh(nums, target, low);\\n\\t\\treturn vector<int>({ low, high });\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int m_findLow(vector<int> &nums, int target, int low, int high)\\n    {\\n        int mid;\\n        while (low <= high) {\\n            mid = low + (high-low)/2;\\n\\t\\t\\t//Advance low only if it is not pointing to target\\n            if( nums[mid] == target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n\\n    int m_findHigh(vector<int> &nums, int target, int low, int high)\\n    {\\n        int mid;\\n        while (low <= high) {\\n            mid = low + (high-low)/2;\\n\\t\\t\\t//Advance high only if it is not pointing to target\\n            if( nums[mid] == target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return high;\\n    }\\n\\t\\npublic:\\n\\n    vector<int> searchRange(vector<int> &nums, int target)\\n    {\\n        int size = nums.size(), low = 0, high = size - 1, mid;\\n        vector<int> pos(2, -1);\\n\\n        while (low <= high) {\\n            mid = low + (high - low) / 2;\\n\\t\\t\\t\\n\\t\\t\\t//First check if the target is present in the list at all\\n            if (nums[mid] == target) {\\n                if (nums[low] != target) {\\n\\t\\t\\t\\t\\t//Low should be in the lower half\\n                    low = m_findLow(nums, target, low, mid);\\n                }\\n                if (nums[high] != target) {\\n\\t\\t\\t\\t\\t//High should be in the upper half\\n                    high = m_findHigh(nums, target, mid, high);\\n                }\\n                pos[0] = low;\\n                pos[1] = high;\\n                break;\\n            }\\n            else if (nums[mid] > target && nums[high] != target) {\\n                high = mid - 1;\\n            }\\n            else if (nums[mid] < target && nums[low] != target) {\\n                low = mid + 1;\\n            }\\n        }\\n        return pos;\\n    }\\n};\\n```\n```\\nclass Solution {\\n\\tint findLow(const vector<int>& nums, int target) {\\n\\t\\tint low = 0, high = nums.size() - 1, mid = 0, lowPos = -1;\\n\\n\\t\\twhile (low <= high) {\\n\\t\\t\\tmid = low + (high - low) / 2;\\n\\n\\t\\t\\tif (target < nums[mid]) {\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (target > nums[mid]) {\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tlowPos = mid;\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn lowPos;\\n\\t}\\n\\n\\tint findHigh(const vector<int>& nums, int target, int l) {\\n\\t\\tint low = l, high = nums.size() - 1, mid = 0, highPos = -1;\\n\\n\\t\\twhile (low <= high) {\\n\\t\\t\\tmid = low + (high - low) / 2;\\n\\t\\t\\tif (target < nums[mid]) {\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (target > nums[mid]) {\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\thighPos = mid;\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn highPos;\\n\\t}\\npublic:\\n\\tvector<int> searchRange(vector<int>& nums, int target)\\n\\t{\\n\\t\\tint low = findLow(nums, target);\\n\\t\\tint high = -1;\\n\\t\\tif (low >= 0)\\n\\t\\t\\thigh = findHigh(nums, target, low);\\n\\t\\treturn vector<int>({ low, high });\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769254,
                "title": "c-solution-o-log-n",
                "content": "```\\nint* searchRange(int* nums, int numsSize, int target, int* returnSize){\\n    int l=0, r=numsSize-1, mid = r/2;\\n    *returnSize = 2;\\n    int* res = malloc(sizeof(int)*2);\\n    res[0] = -1; res[1] = -1;\\n    \\n    while (l <= r)\\n    {\\n        mid = l+(r-l)/2;\\n        if (target == nums[mid]) // might be in both sides\\n        {\\n            int mid2 = mid;\\n            while (l < mid)\\n            {\\n                int l_mid = (mid+l)/2;\\n                if (nums[l_mid] < target)\\n                    l = l_mid+1;\\n                \\n                else\\n                    mid = l_mid;\\n            }\\n            while (mid2 < r)\\n            {\\n                int r_mid = (mid2+r+1)/2;\\n                if (nums[r_mid] >  target)\\n                    r = r_mid-1;\\n\\n                else\\n                    mid2 = r_mid;\\n            \\n            }\\n            res[0] = l; res[1] = r;\\n            return res;\\n        }\\n        else if (target < nums[mid]) // not in right side\\n            r = mid-1;\\n\\n        else if (target > nums[mid]) // not in left side\\n            l = mid+1;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* searchRange(int* nums, int numsSize, int target, int* returnSize){\\n    int l=0, r=numsSize-1, mid = r/2;\\n    *returnSize = 2;\\n    int* res = malloc(sizeof(int)*2);\\n    res[0] = -1; res[1] = -1;\\n    \\n    while (l <= r)\\n    {\\n        mid = l+(r-l)/2;\\n        if (target == nums[mid]) // might be in both sides\\n        {\\n            int mid2 = mid;\\n            while (l < mid)\\n            {\\n                int l_mid = (mid+l)/2;\\n                if (nums[l_mid] < target)\\n                    l = l_mid+1;\\n                \\n                else\\n                    mid = l_mid;\\n            }\\n            while (mid2 < r)\\n            {\\n                int r_mid = (mid2+r+1)/2;\\n                if (nums[r_mid] >  target)\\n                    r = r_mid-1;\\n\\n                else\\n                    mid2 = r_mid;\\n            \\n            }\\n            res[0] = l; res[1] = r;\\n            return res;\\n        }\\n        else if (target < nums[mid]) // not in right side\\n            r = mid-1;\\n\\n        else if (target > nums[mid]) // not in left side\\n            l = mid+1;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 561766,
                "title": "java-template-iii-solution",
                "content": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int x) {\\n        if (nums.length == 0) return new int[]{-1,-1};\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while (start + 1 < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] < x) start = mid;\\n            else end = mid;\\n        }\\n        int left = nums[start] == x ? start : end;\\n        if (nums[left] != x) return new int[]{-1,-1};\\n        start = left;\\n        end = nums.length - 1;\\n        while(start + 1 < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] <= x) start = mid;\\n            else end = mid;\\n        }\\n        int right = nums[end] == x ? end : start;\\n        return new int[]{left,right};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int x) {\\n        if (nums.length == 0) return new int[]{-1,-1};\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while (start + 1 < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] < x) start = mid;\\n            else end = mid;\\n        }\\n        int left = nums[start] == x ? start : end;\\n        if (nums[left] != x) return new int[]{-1,-1};\\n        start = left;\\n        end = nums.length - 1;\\n        while(start + 1 < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] <= x) start = mid;\\n            else end = mid;\\n        }\\n        int right = nums[end] == x ? end : start;\\n        return new int[]{left,right};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 392634,
                "title": "inspired-by-the-solution-in-book-elements-of-programming-interview",
                "content": "This is inspired by the solution of `Elements of Programming Interview`. Off all the solutions, this was the most intutive approach to me.\\n\\nWe do the binary search twice. Once to find the first occurance and another to find the last occurance.\\n\\n##### Find the first occurance\\n\\nWe do the normal binary search. Once we find the target, we know that *nothing to it\\'s right* can be the first occurance.\\nMaybe the mid is the first occurance, maybe not. So we keep doing the search , but narrow the search range from [0...mid-1].\\n\\n##### Find the last occurance\\n\\nWe do the normal binary search. Once we find the target, we know that *nothing to it\\'s left* can be the last occurance.\\nMaybe the mid is the last occurance, maybe not. So we keep doing the search , but narrow the search range from [mid +1...high].\\n\\n\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int[] result = new int[2];\\n        result[0] = findFirst(nums,target);\\n        result[1] = findLast(nums,target);\\n        return result;\\n        \\n    }\\n    \\n    public int findFirst(int[] nums, int target){\\n        \\n        int result = -1;\\n        int low = 0;\\n        int high = nums.length - 1;\\n\\n        while(low <= high){\\n            int mid = low + ((high-low)/2);\\n\\n            if (nums[mid] < target){\\n                low = mid +1;\\n            } else if (nums[mid] > target){\\n                high = mid - 1;\\n            } else { // nums[mid] == target\\n                result = mid;\\n\\n                // because nothing after mid\\n                // can be the first occurance of target.\\n                //maybe mid is the first occurance , maybe not\\n                //so let\\'s narrow the target for [0...mid-1] and find out\\n                high = mid - 1; \\n   \\n            }\\n        }\\n\\n        return result;\\n  \\n    }\\n    \\n        public int findLast(int[] nums, int target){\\n        \\n        int result = -1;\\n        int low = 0;\\n        int high = nums.length - 1;\\n        \\n        while(low <= high){\\n            \\n            int mid = low + (high-low)/2;\\n            \\n            if (nums[mid] < target){\\n                low = mid +1;\\n            } else if (nums[mid] > target){\\n                high = mid - 1;\\n            } else { // nums[mid] == target\\n                result = mid;\\n                // because nothing before mid\\n                // can be the last occurance of target.\\n                //maybe mid is the last occurance , maybe not\\n                //so let\\'s narrow the target for [mid+1...high] and find                   // out\\n                low = mid + 1;\\n   \\n            }\\n        }\\n\\n        return result;\\n    }\\n \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int[] result = new int[2];\\n        result[0] = findFirst(nums,target);\\n        result[1] = findLast(nums,target);\\n        return result;\\n        \\n    }\\n    \\n    public int findFirst(int[] nums, int target){\\n        \\n        int result = -1;\\n        int low = 0;\\n        int high = nums.length - 1;\\n\\n        while(low <= high){\\n            int mid = low + ((high-low)/2);\\n\\n            if (nums[mid] < target){\\n                low = mid +1;\\n            } else if (nums[mid] > target){\\n                high = mid - 1;\\n            } else { // nums[mid] == target\\n                result = mid;\\n\\n                // because nothing after mid\\n                // can be the first occurance of target.\\n                //maybe mid is the first occurance , maybe not\\n                //so let\\'s narrow the target for [0...mid-1] and find out\\n                high = mid - 1; \\n   \\n            }\\n        }\\n\\n        return result;\\n  \\n    }\\n    \\n        public int findLast(int[] nums, int target){\\n        \\n        int result = -1;\\n        int low = 0;\\n        int high = nums.length - 1;\\n        \\n        while(low <= high){\\n            \\n            int mid = low + (high-low)/2;\\n            \\n            if (nums[mid] < target){\\n                low = mid +1;\\n            } else if (nums[mid] > target){\\n                high = mid - 1;\\n            } else { // nums[mid] == target\\n                result = mid;\\n                // because nothing before mid\\n                // can be the last occurance of target.\\n                //maybe mid is the last occurance , maybe not\\n                //so let\\'s narrow the target for [mid+1...high] and find                   // out\\n                low = mid + 1;\\n   \\n            }\\n        }\\n\\n        return result;\\n    }\\n \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14781,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Search for a Range** https://leetcode.com/problems/search-for-a-range/\\n\\n**Algorithm**\\n* Use binary search to find the lower and upper bound\\n\\n```\\nclass Solution(object):\\n    def get_lower_bound(self, nums, target):\\n        low, high = 0, len(nums)-1\\n        ans = -1\\n        while low <= high:\\n            mid = low + (high-low)//2\\n            if nums[mid] == target:\\n                ans = mid\\n                high = mid-1\\n            elif nums[mid] < target:\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return ans\\n    \\n    def get_upper_bound(self, nums, target):\\n        low, high = 0, len(nums)-1\\n        ans = -1\\n        while low <= high:\\n            mid = low + (high-low)//2\\n            if nums[mid] == target:\\n                ans = mid\\n                low = mid+1\\n            elif nums[mid] < target:\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return ans\\n        \\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        lower_bound = self.get_lower_bound(nums, target)\\n        upper_bound = self.get_upper_bound(nums, target)\\n        return [lower_bound, upper_bound]        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def get_lower_bound(self, nums, target):\\n        low, high = 0, len(nums)-1\\n        ans = -1\\n        while low <= high:\\n            mid = low + (high-low)//2\\n            if nums[mid] == target:\\n                ans = mid\\n                high = mid-1\\n            elif nums[mid] < target:\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return ans\\n    \\n    def get_upper_bound(self, nums, target):\\n        low, high = 0, len(nums)-1\\n        ans = -1\\n        while low <= high:\\n            mid = low + (high-low)//2\\n            if nums[mid] == target:\\n                ans = mid\\n                low = mid+1\\n            elif nums[mid] < target:\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return ans\\n        \\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        lower_bound = self.get_lower_bound(nums, target)\\n        upper_bound = self.get_upper_bound(nums, target)\\n        return [lower_bound, upper_bound]        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 14945,
                "title": "java-1ms-solution-recursive-binary-search-structure-clear-and-simple-code-style-better",
                "content": "    public int[] searchRange(int[] nums, int target) {\\n        if(nums==null || nums.length==0){\\n            return new int[]{-1,-1};\\n        }\\n        else{\\n            return new int[]{\\n                getLeftBoundary(nums,0, nums.length-1,target),\\n                getRightBoundary(nums,0, nums.length-1,target)\\n            };\\n        }\\n    }\\n    private int getLeftBoundary(int[] nums, int start, int end, int target){\\n        if(start==end){\\n            if(nums[start]==target){\\n                return start;\\n            }\\n            return -1;\\n        }\\n        int mid = (start+end)/2;\\n        if(nums[mid]<target){\\n            return getLeftBoundary(nums, mid+1, end, target);\\n        }\\n        else{\\n            return getLeftBoundary(nums, start, mid, target);\\n        }\\n    }\\n    private int getRightBoundary(int[] nums, int start, int end, int target){\\n        if(start==end){\\n            if(nums[start]==target){\\n                return start;\\n            }\\n            return -1;\\n        }\\n\\n        int mid = end-(end-start)/2;\\n        if(nums[mid]>target){\\n            return getRightBoundary(nums, start, mid-1, target);\\n        }\\n        else{\\n            return getRightBoundary(nums, mid, end, target);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "    public int[] searchRange(int[] nums, int target) {\\n        if(nums==null || nums.length==0){\\n            return new int[]{-1,-1};\\n        }\\n        else{\\n            return new int[]{\\n                getLeftBoundary(nums,0, nums.length-1,target),\\n                getRightBoundary(nums,0, nums.length-1,target)\\n            };\\n        }\\n    }\\n    private int getLeftBoundary(int[] nums, int start, int end, int target){\\n        if(start==end){\\n            if(nums[start]==target){\\n                return start;\\n            }\\n            return -1;\\n        }\\n        int mid = (start+end)/2;\\n        if(nums[mid]<target){\\n            return getLeftBoundary(nums, mid+1, end, target);\\n        }\\n        else{\\n            return getLeftBoundary(nums, start, mid, target);\\n        }\\n    }\\n    private int getRightBoundary(int[] nums, int start, int end, int target){\\n        if(start==end){\\n            if(nums[start]==target){\\n                return start;\\n            }\\n            return -1;\\n        }\\n\\n        int mid = end-(end-start)/2;\\n        if(nums[mid]>target){\\n            return getRightBoundary(nums, start, mid-1, target);\\n        }\\n        else{\\n            return getRightBoundary(nums, mid, end, target);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3827753,
                "title": "java-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this question we need to find the starting and ending index of the given target and return an array of {startidx,endidx} and if target is not present return {-1,-1} array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nExplained in the code.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] arr = new int[2];\\n        Arrays.fill(arr,-1);\\n        //elements set to -1 by default\\n        if(nums.length==1 && nums[0]==target){\\n            /*if length of given array is 1 and the target is present at\\n            the 0th index then return {0,0} array.*/\\n            Arrays.fill(arr,0);\\n            return arr;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            //finding the starting index of the target\\n            if(nums[i]==target){\\n                arr[0] = i;\\n                break;\\n            }\\n        }\\n        for(int i=nums.length-1;i>=0;i--){\\n            //finding the last index of the target\\n            if(nums[i]==target){\\n                arr[1] = i;\\n                break;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```\\n![oie_CksRiTNvbciG.jpg](https://assets.leetcode.com/users/images/49c89904-af56-4280-862f-9a43e750a6c0_1690533080.951863.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] arr = new int[2];\\n        Arrays.fill(arr,-1);\\n        //elements set to -1 by default\\n        if(nums.length==1 && nums[0]==target){\\n            /*if length of given array is 1 and the target is present at\\n            the 0th index then return {0,0} array.*/\\n            Arrays.fill(arr,0);\\n            return arr;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            //finding the starting index of the target\\n            if(nums[i]==target){\\n                arr[0] = i;\\n                break;\\n            }\\n        }\\n        for(int i=nums.length-1;i>=0;i--){\\n            //finding the last index of the target\\n            if(nums[i]==target){\\n                arr[1] = i;\\n                break;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808512,
                "title": "python-solution-using-bisect-module",
                "content": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        import bisect\\n        start=bisect.bisect_left(nums,target)      \\n        end=bisect.bisect_right(nums,target)\\n        if start>end-1:\\n            return [-1,-1]\\n        return [start,end-1]\\n```\\n**Steps:**\\n1. Import the \\'bisect\\' module for efficient binary search operations.\\n2. Find the leftmost index where \\'target\\' could be inserted in \\'nums\\' while maintaining sorted order.\\n3. Find the rightmost index where \\'target\\' could be inserted in \\'nums\\' while maintaining sorted order.\\n4. If \\'start\\' is greater than \\'end-1\\', it means \\'target\\' is not found in \\'nums\\'.\\n\\tReturn [-1, -1] to indicate that the target is not present.\\n5. Return the leftmost and rightmost indices of \\'target\\' in \\'nums\\'.\\n\\n**Time Complexity:** O(log n)\\n**Space Complexity:** O(1) \\n\\nReference: https://docs.python.org/3/library/bisect.html \\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        import bisect\\n        start=bisect.bisect_left(nums,target)      \\n        end=bisect.bisect_right(nums,target)\\n        if start>end-1:\\n            return [-1,-1]\\n        return [start,end-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774390,
                "title": "binary-search-java-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int low=0;\\n        int high=nums.length-1;\\n        int ans[]=new int[2];\\n        ans[0]=searchFirst(nums,target);\\n        ans[1]=searchLast(nums,target);\\n        return ans;\\n    }\\n\\n    public int searchFirst(int[] nums, int target){\\n        int low=0;\\n        int high=nums.length-1;\\n        int res=-1;\\n        while(low<=high){\\n            int mid=(low+(high-low)/2);\\n            \\n            if(nums[mid]==target){\\n                res=mid;\\n                high=mid-1;\\n            }\\n            \\n            else if(target>nums[mid]){             \\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int searchLast(int[] nums, int target){\\n        int low=0;\\n        int high=nums.length-1;\\n        int res=-1;\\n        while(low<=high){\\n            int mid=(low+(high-low)/2);\\n            \\n            if(nums[mid]==target){\\n                res=mid;\\n                low=mid+1;\\n            }\\n            \\n            else if(target>nums[mid]){             \\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int low=0;\\n        int high=nums.length-1;\\n        int ans[]=new int[2];\\n        ans[0]=searchFirst(nums,target);\\n        ans[1]=searchLast(nums,target);\\n        return ans;\\n    }\\n\\n    public int searchFirst(int[] nums, int target){\\n        int low=0;\\n        int high=nums.length-1;\\n        int res=-1;\\n        while(low<=high){\\n            int mid=(low+(high-low)/2);\\n            \\n            if(nums[mid]==target){\\n                res=mid;\\n                high=mid-1;\\n            }\\n            \\n            else if(target>nums[mid]){             \\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int searchLast(int[] nums, int target){\\n        int low=0;\\n        int high=nums.length-1;\\n        int res=-1;\\n        while(low<=high){\\n            int mid=(low+(high-low)/2);\\n            \\n            if(nums[mid]==target){\\n                res=mid;\\n                low=mid+1;\\n            }\\n            \\n            else if(target>nums[mid]){             \\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432042,
                "title": "runtime-0s-beats-100-and-in-memory-beats-90-upvote-if-you-like",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] ans={-1,-1};\\n        int start=search(nums,target,true);\\n        int end=search(nums,target,false);\\n        ans[0]=start;\\n        ans[1]=end;\\n        return ans;\\n    }\\n    public int search(int[] arr,int target,boolean findStartIndex)\\n    {\\n        int ans=-1;\\n        int start=0;\\n        int end=arr.length-1;\\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            if(target<arr[mid])\\n            {\\n                end=mid-1;\\n            }\\n            else if(target>arr[mid])\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                ans=mid;\\n                if(findStartIndex)\\n                {\\n                    end=mid-1;\\n                }\\n                else start=mid+1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] ans={-1,-1};\\n        int start=search(nums,target,true);\\n        int end=search(nums,target,false);\\n        ans[0]=start;\\n        ans[1]=end;\\n        return ans;\\n    }\\n    public int search(int[] arr,int target,boolean findStartIndex)\\n    {\\n        int ans=-1;\\n        int start=0;\\n        int end=arr.length-1;\\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            if(target<arr[mid])\\n            {\\n                end=mid-1;\\n            }\\n            else if(target>arr[mid])\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                ans=mid;\\n                if(findStartIndex)\\n                {\\n                    end=mid-1;\\n                }\\n                else start=mid+1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244584,
                "title": "solution-using-binary-search-in-just-o-logn-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int firstOccur(int []nums,int target)\\n    {\\n       int start=0;\\n       int end=nums.length-1;\\n       int index=-1;\\n       while(start<=end)\\n       {\\n           int mid=start+(end-start)/2;\\n           if(nums[mid]==target)\\n           {\\n               index=mid;\\n               end=mid-1;\\n           }\\n           else if(nums[mid]>target)\\n           {\\n               end=mid-1;\\n           }\\n           else\\n           {\\n               start=mid+1;\\n           }\\n       }\\n    \\n       return index; \\n    }\\n     public static int lastOccur(int []nums,int target)\\n    {\\n        int start=0;\\n       int end=nums.length-1;\\n       int index=-1;\\n       while(start<=end)\\n       {\\n           int mid=start+(end-start)/2;\\n           if(nums[mid]==target)\\n           {\\n               index=mid;\\n               start=mid+1;\\n           }\\n           else if(nums[mid]>target)\\n           {\\n               end=mid-1;\\n           }\\n           else\\n           {\\n               start=mid+1;\\n           }\\n       }\\n       \\n       return index;  \\n    }\\n    public int[] searchRange(int[] nums, int target) \\n            {\\n                int []ans=new int [2];\\n          ans[0]=  firstOccur(nums,target);\\n            ans[1]=lastOccur(nums,target);\\n            return ans;\\n        }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int firstOccur(int []nums,int target)\\n    {\\n       int start=0;\\n       int end=nums.length-1;\\n       int index=-1;\\n       while(start<=end)\\n       {\\n           int mid=start+(end-start)/2;\\n           if(nums[mid]==target)\\n           {\\n               index=mid;\\n               end=mid-1;\\n           }\\n           else if(nums[mid]>target)\\n           {\\n               end=mid-1;\\n           }\\n           else\\n           {\\n               start=mid+1;\\n           }\\n       }\\n    \\n       return index; \\n    }\\n     public static int lastOccur(int []nums,int target)\\n    {\\n        int start=0;\\n       int end=nums.length-1;\\n       int index=-1;\\n       while(start<=end)\\n       {\\n           int mid=start+(end-start)/2;\\n           if(nums[mid]==target)\\n           {\\n               index=mid;\\n               start=mid+1;\\n           }\\n           else if(nums[mid]>target)\\n           {\\n               end=mid-1;\\n           }\\n           else\\n           {\\n               start=mid+1;\\n           }\\n       }\\n       \\n       return index;  \\n    }\\n    public int[] searchRange(int[] nums, int target) \\n            {\\n                int []ans=new int [2];\\n          ans[0]=  firstOccur(nums,target);\\n            ans[1]=lastOccur(nums,target);\\n            return ans;\\n        }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240027,
                "title": "python3-beats-88-99-easy-solution",
                "content": "# **I request you guys to please upvote if you find the solution helpful.**\\n![image.png](https://assets.leetcode.com/users/images/5e5843ec-e655-4431-88b3-0bcea1515997_1677590304.8684895.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        pos = []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                pos.append(i)\\n        if len(pos) == 0:\\n            pos.append(-1)\\n            pos.append(-1)\\n            return pos\\n        else:\\n            pos1 = []\\n            pos1.append(min(pos))\\n            pos1.append(max(pos))\\n            return pos1\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        pos = []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                pos.append(i)\\n        if len(pos) == 0:\\n            pos.append(-1)\\n            pos.append(-1)\\n            return pos\\n        else:\\n            pos1 = []\\n            pos1.append(min(pos))\\n            pos1.append(max(pos))\\n            return pos1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080147,
                "title": "c-java-clear-simple-basic-binary-search-tc-log-n-sc-o-1",
                "content": "\\n# Complexity\\n- Time complexity:O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    void lowerBound(vector<int>&nums,int target,vector<int>&ans){\\n        int low=0,high=nums.size()-1;\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            if(nums[mid]==target){\\n                ans[0]=mid;\\n                // search left side to find the first occurrence\\n                high=mid-1;\\n            }\\n            else if(nums[mid]<target)   low=mid+1;\\n            else high=mid-1;\\n        }\\n    }\\n    void higherBound(vector<int>&nums,int target,vector<int>&ans){\\n        int low=0,high=nums.size()-1;\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            if(nums[mid]==target){\\n                ans[1]=mid;\\n                //search right side to find the last occurrence\\n                low=mid+1;\\n            }\\n            else if(nums[mid]<target)   low=mid+1;\\n            else high=mid-1;\\n        }\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans(2,-1);\\n        lowerBound(nums,target,ans);\\n        higherBound(nums,target,ans);\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public static void lowerBound(int []nums,int target,int []ans){\\n        int low=0,high=nums.length-1;\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            if(nums[mid]==target){\\n                ans[0]=mid;\\n                // search left side to find the first occurrence\\n                high=mid-1;\\n            }\\n            else if(nums[mid]<target)   low=mid+1;\\n            else high=mid-1;\\n        }\\n    }\\n    public static void higherBound(int []nums,int target,int []ans){\\n        int low=0,high=nums.length-1;\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            if(nums[mid]==target){\\n                ans[1]=mid;\\n                //search right side to find the last occurrence\\n                low=mid+1;\\n            }\\n            else if(nums[mid]<target)   low=mid+1;\\n            else high=mid-1;\\n        }\\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int []ans=new int[2];\\n        Arrays.fill(ans,-1);\\n        lowerBound(nums,target,ans);\\n        higherBound(nums,target,ans);\\n        return ans;\\n    }\\n}\\n```\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void lowerBound(vector<int>&nums,int target,vector<int>&ans){\\n        int low=0,high=nums.size()-1;\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            if(nums[mid]==target){\\n                ans[0]=mid;\\n                // search left side to find the first occurrence\\n                high=mid-1;\\n            }\\n            else if(nums[mid]<target)   low=mid+1;\\n            else high=mid-1;\\n        }\\n    }\\n    void higherBound(vector<int>&nums,int target,vector<int>&ans){\\n        int low=0,high=nums.size()-1;\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            if(nums[mid]==target){\\n                ans[1]=mid;\\n                //search right side to find the last occurrence\\n                low=mid+1;\\n            }\\n            else if(nums[mid]<target)   low=mid+1;\\n            else high=mid-1;\\n        }\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans(2,-1);\\n        lowerBound(nums,target,ans);\\n        higherBound(nums,target,ans);\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public static void lowerBound(int []nums,int target,int []ans){\\n        int low=0,high=nums.length-1;\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            if(nums[mid]==target){\\n                ans[0]=mid;\\n                // search left side to find the first occurrence\\n                high=mid-1;\\n            }\\n            else if(nums[mid]<target)   low=mid+1;\\n            else high=mid-1;\\n        }\\n    }\\n    public static void higherBound(int []nums,int target,int []ans){\\n        int low=0,high=nums.length-1;\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            if(nums[mid]==target){\\n                ans[1]=mid;\\n                //search right side to find the last occurrence\\n                low=mid+1;\\n            }\\n            else if(nums[mid]<target)   low=mid+1;\\n            else high=mid-1;\\n        }\\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int []ans=new int[2];\\n        Arrays.fill(ans,-1);\\n        lowerBound(nums,target,ans);\\n        higherBound(nums,target,ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028659,
                "title": "fast-two-binary-search-approach",
                "content": "# Intuition\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(log n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        if not nums:\\n            return [-1,-1]\\n        l = 0\\n        r = len(nums) - 1\\n        while l<r:\\n            mid = (l+r) // 2\\n            if nums[mid] < target:\\n                l = mid +1\\n            elif nums[mid] == target:\\n                r = mid \\n            else:\\n                r = mid - 1\\n        \\n        if nums[l] != target:\\n            return [-1,-1]\\n        else:\\n            \\n            end = start = l\\n            r = len(nums) - 1\\n            while l<=r:\\n                \\n                mid = (l+r) // 2\\n                if nums[mid] == target:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n            end = r        \\n            return [start,end]\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        if not nums:\\n            return [-1,-1]\\n        l = 0\\n        r = len(nums) - 1\\n        while l<r:\\n            mid = (l+r) // 2\\n            if nums[mid] < target:\\n                l = mid +1\\n            elif nums[mid] == target:\\n                r = mid \\n            else:\\n                r = mid - 1\\n        \\n        if nums[l] != target:\\n            return [-1,-1]\\n        else:\\n            \\n            end = start = l\\n            r = len(nums) - 1\\n            while l<=r:\\n                \\n                mid = (l+r) // 2\\n                if nums[mid] == target:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n            end = r        \\n            return [start,end]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904660,
                "title": "java-solution-using-binary-search",
                "content": "\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int[] res = new int[2];\\n\\n        int x = -1;\\n        int y = -1;\\n\\n        int start = 0;\\n        int end = nums.length-1;\\n\\n\\n        while( start <= end ){\\n\\n            int mid = (start+end)/2;\\n            \\n            if( nums[mid] == target ){\\n                \\n                x = mid;\\n                end = mid-1;\\n\\n            }else if (nums[mid] < target){\\n                start = mid+1;\\n            }else{\\n                end = mid-1;\\n            }\\n\\n        }\\n\\n         start = 0;\\n         end = nums.length-1;\\n       \\n         while( start <= end ){\\n\\n            int mid = (start+end)/2;\\n            \\n            if( nums[mid] == target ){\\n                \\n                y = mid;\\n                start = mid+1;\\n                \\n            }else if (nums[mid] < target){\\n                start = mid+1;\\n            }else{\\n                end = mid-1;\\n            }\\n\\n        }\\n   \\n\\n            res[0] = x;\\n            res[1] = y;\\n   \\n\\n            return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int[] res = new int[2];\\n\\n        int x = -1;\\n        int y = -1;\\n\\n        int start = 0;\\n        int end = nums.length-1;\\n\\n\\n        while( start <= end ){\\n\\n            int mid = (start+end)/2;\\n            \\n            if( nums[mid] == target ){\\n                \\n                x = mid;\\n                end = mid-1;\\n\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2810980,
                "title": "c-binary-search-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> searchRange(vector<int>& nums, int target) {\\n\\t\\t\\tvector<int>v;\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tint start=0, end=n-1, start1=0, end1=n-1, first=-1, last=-1;\\n\\t\\t\\twhile(start<=end){\\n\\t\\t\\t\\tint mid=start+(end-start)/2;\\n\\t\\t\\t\\tif(target==nums[mid]){\\n\\t\\t\\t\\t\\tfirst=mid;\\n\\t\\t\\t\\t\\tend=mid-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(target>nums[mid]){\\n\\t\\t\\t\\t\\tstart=mid+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(target<nums[mid]){\\n\\t\\t\\t\\t\\tend=mid-1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\tif(first==-1){\\n\\t\\t\\t\\tv.push_back(-1);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tv.push_back(first);\\n\\t\\t\\t}\\n\\t\\t\\twhile(start1<=end1){\\n\\t\\t\\t\\tint mid=start1+(end1-start1)/2;\\n\\t\\t\\t\\tif(target==nums[mid]){\\n\\t\\t\\t\\t\\tlast=mid;\\n\\t\\t\\t\\t\\tstart1=mid+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(target>nums[mid]){\\n\\t\\t\\t\\t\\tstart1=mid+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(target<nums[mid]){\\n\\t\\t\\t\\t\\tend1=mid-1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\tif(last==-1){\\n\\t\\t\\t\\tv.push_back(-1);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tv.push_back(last);\\n\\t\\t\\t}\\n\\t\\t\\treturn v;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> searchRange(vector<int>& nums, int target) {\\n\\t\\t\\tvector<int>v;\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tint start=0, end=n-1, start1=0, end1=n-1, first=-1, last=-1;\\n\\t\\t\\twhile(start<=end){\\n\\t\\t\\t\\tint mid=start+(end-start)/2;\\n\\t\\t\\t\\tif(target==nums[mid]){\\n\\t\\t\\t\\t\\tfirst=mid;\\n\\t\\t\\t\\t\\tend=mid-1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2751170,
                "title": "c-easiest-and-clean-code-with-binary-search-explanation-fast-runtime",
                "content": "Here, basically we are trying to reduce our search space in our interested side, we will reduce search space left side if we want first index (as array is already sorted) .Similarily , we can say for last index will lie on right side of array\\n\\nCondition:- \\n-->end = mid-1; \\nhelping us to reduce search space in left side of array , as our interested side if first index\\n\\n-->start = mid+1\\nhelping us to reduce search space in right side of array , as our interested side if last index\\n\\n**Make Sure To Dry Run This Code, For Better Understanding**\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tDo Upvote If You Like This\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n\\t\\n\\t//Finding First Occurrence Of Target\\n        int start = 0,end = nums.size()-1;\\n        int mid,str = -1,last = -1;\\n        \\n        while(start <= end){\\n            mid = start + (end-start)/2;          \\n            \\n            if(nums[mid] == target){\\n                str = mid;                       //storing index if our target element is found\\n                end = mid-1;                     //condition for first occurence\\n            }\\n            \\n            else if(nums[mid] < target){\\n                start = mid+1;\\n            }\\n            else end = mid-1;\\n        }\\n\\t\\t\\n        //Finding Last Occurence Of Target\\n        start = 0,end = nums.size()-1;\\n        last = -1;\\n        \\n        while(start <= end){\\n            mid = start + (end-start)/2;\\n            \\n            if(nums[mid] == target){\\n                last = mid;                    //storing index if our target element is found\\n                start = mid+1;                 //condition for last occurence\\n            }\\n            \\n            else if(nums[mid] < target){\\n                start = mid+1;\\n            }\\n            else end = mid-1;\\n        }\\n        \\n        return {str,last};                return first and last index of element\\n        \\n    }\\n};\\n```\\n**Time Complexity :- O(logN)\\nSpace Complexity :- O(1)**\\n",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n\\t\\n\\t//Finding First Occurrence Of Target\\n        int start = 0,end = nums.size()-1;\\n        int mid,str = -1,last = -1;\\n        \\n        while(start <= end){\\n            mid = start + (end-start)/2;          \\n            \\n            if(nums[mid] == target){\\n                str = mid;                       //storing index if our target element is found\\n                end = mid-1;                     //condition for first occurence\\n            }\\n            \\n            else if(nums[mid] < target){\\n                start = mid+1;\\n            }\\n            else end = mid-1;\\n        }\\n\\t\\t\\n        //Finding Last Occurence Of Target\\n        start = 0,end = nums.size()-1;\\n        last = -1;\\n        \\n        while(start <= end){\\n            mid = start + (end-start)/2;\\n            \\n            if(nums[mid] == target){\\n                last = mid;                    //storing index if our target element is found\\n                start = mid+1;                 //condition for last occurence\\n            }\\n            \\n            else if(nums[mid] < target){\\n                start = mid+1;\\n            }\\n            else end = mid-1;\\n        }\\n        \\n        return {str,last};                return first and last index of element\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686811,
                "title": "java-solution-using-binary-search",
                "content": "```\\nclass Solution \\n{\\n    public int[] searchRange(int[] nums, int target) \\n    {\\n        int low,high,mid,ans1=-1;\\n        low = 0;\\n        high = nums.length-1;\\n        \\n        while(low<=high)\\n        {\\n            mid = (low+high)/2;\\n            if(nums[mid] == target)\\n            {\\n                ans1 = mid;\\n                high = mid-1; // To get the first occurence of the element \\n            }\\n            else if(nums[mid]<target)\\n                low = mid+1;\\n            else\\n                high = mid-1;\\n        }\\n        \\n        low = 0;\\n        high = nums.length-1;\\n        int ans2=-1;\\n        \\n        while(low<=high)\\n        {\\n            mid = (low+high)/2;\\n            if(nums[mid] == target)\\n            {\\n                ans2 = mid;\\n                low = mid+1; // To get the last occurence of the element\\n            }\\n            else if(nums[mid]<target)\\n                low = mid+1;\\n            else\\n                high = mid-1;\\n        }\\n        \\n        return new int[]{ans1,ans2};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int[] searchRange(int[] nums, int target) \\n    {\\n        int low,high,mid,ans1=-1;\\n        low = 0;\\n        high = nums.length-1;\\n        \\n        while(low<=high)\\n        {\\n            mid = (low+high)/2;\\n            if(nums[mid] == target)\\n            {\\n                ans1 = mid;\\n                high = mid-1; // To get the first occurence of the element \\n            }\\n            else if(nums[mid]<target)\\n                low = mid+1;\\n            else\\n                high = mid-1;\\n        }\\n        \\n        low = 0;\\n        high = nums.length-1;\\n        int ans2=-1;\\n        \\n        while(low<=high)\\n        {\\n            mid = (low+high)/2;\\n            if(nums[mid] == target)\\n            {\\n                ans2 = mid;\\n                low = mid+1; // To get the last occurence of the element\\n            }\\n            else if(nums[mid]<target)\\n                low = mid+1;\\n            else\\n                high = mid-1;\\n        }\\n        \\n        return new int[]{ans1,ans2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435482,
                "title": "c-solution-binary-search-better-than-99-26-3ms-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int t) {\\n        int n = nums.size();\\n        vector<int> ans(2, -1);\\n\\t\\t\\n\\t\\t// if there are no elements in nums\\n        if(n==0)    return ans;\\n        \\n\\t\\t// initialized low(l), and high(r)\\n        int l=0, r = n-1, m;\\n        while(l<=r){\\n            m = l + (r-l)/2;\\n            if(nums[m]>=t)   r = m-1;\\n            else    l = m+1;\\n        }\\n\\t\\t\\n\\t\\t// here are three cases:\\n\\t\\t// if 1st element is smaller than target, then l =0, r=-1, so we exit.\\n\\t\\t// if last element is smaller than target, then l=n, and r=n-1, so we exit.\\n\\t\\t// if first element is greater than target, then r=-1, and l =0, but first element is not target, so we exit.\\n        if((l!=0 && r==-1) || (l>=n && r==n-1) || nums[r+1]!=t)   return ans;\\n\\t\\t\\n\\t\\t// else the next index after r, is the first element for first occurence.\\n        ans[0] = r+1;\\n        \\n        l = 0, r = n-1;\\n        while(l<=r){\\n            m = l+(r-l)/2;\\n            if(nums[m]<=t)   l = m+1;\\n            else    r = m-1;            \\n        }\\n\\t\\t\\n\\t\\t// the last occurence may be the same as the first occurence or the last occurence.\\n        ans[1] = l-1;\\n        return ans;\\n\\t}\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/2042d3c9-56a7-45ec-a44e-1d47a951b012_1660672717.4123282.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int t) {\\n        int n = nums.size();\\n        vector<int> ans(2, -1);\\n\\t\\t\\n\\t\\t// if there are no elements in nums\\n        if(n==0)    return ans;\\n        \\n\\t\\t// initialized low(l), and high(r)\\n        int l=0, r = n-1, m;\\n        while(l<=r){\\n            m = l + (r-l)/2;\\n            if(nums[m]>=t)   r = m-1;\\n            else    l = m+1;\\n        }\\n\\t\\t\\n\\t\\t// here are three cases:\\n\\t\\t// if 1st element is smaller than target, then l =0, r=-1, so we exit.\\n\\t\\t// if last element is smaller than target, then l=n, and r=n-1, so we exit.\\n\\t\\t// if first element is greater than target, then r=-1, and l =0, but first element is not target, so we exit.\\n        if((l!=0 && r==-1) || (l>=n && r==n-1) || nums[r+1]!=t)   return ans;\\n\\t\\t\\n\\t\\t// else the next index after r, is the first element for first occurence.\\n        ans[0] = r+1;\\n        \\n        l = 0, r = n-1;\\n        while(l<=r){\\n            m = l+(r-l)/2;\\n            if(nums[m]<=t)   l = m+1;\\n            else    r = m-1;            \\n        }\\n\\t\\t\\n\\t\\t// the last occurence may be the same as the first occurence or the last occurence.\\n        ans[1] = l-1;\\n        return ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333076,
                "title": "c-solution-easy-approach-comments-fast-than-92",
                "content": "```\\nvector<int> searchRange(vector<int>& nums, int t) {\\n\\tint n = nums.size();\\n\\tvector<int> ans(2, -1);\\n\\t// To check if the array is empty\\n\\tif(n==0)    return ans;\\n\\t// To check if array has only one element\\n\\telse if(nums.size()==1){\\n\\t\\tif(nums[0]==t)\\t\\t\\treturn {0, 0};\\n\\t\\treturn ans;\\n\\t}\\n\\t// If first element of array is our target\\n\\tif(t==nums[0])  ans[0] = 0;\\n\\t// Else we do binary search for the first element in array\\n\\telse{\\n\\t\\tint low =0, high = n-1;\\n\\t\\twhile(low<high){\\n\\t\\t\\tint mid = (low+high)/2;\\n\\t\\t\\tif(nums[mid]==t && nums[mid-1]<nums[mid]){\\n\\t\\t\\t\\tans[0] = mid; break;\\n\\t\\t\\t}\\n\\t\\t\\telse if(nums[mid]>=t)   high = mid;\\n\\t\\t\\telse                    low = mid+1;\\n\\t\\t}\\n\\t}\\n\\t// If last element if our target\\n\\tif(t==nums[n-1])  ans[1] = n-1;\\n\\t// Else we do binary search for the last element in array\\n\\telse{\\n\\t\\tint low =0, high = n;\\n\\t\\twhile(low<high){\\n\\t\\t\\tint mid = (low+high)/2;\\n\\t\\t\\tif(nums[mid]==t && nums[mid]<nums[mid+1] && ans[0]!=mid){\\n\\t\\t\\t\\tans[1] = mid; break;\\n\\t\\t\\t}\\n\\t\\t\\telse if(nums[mid]<=t)   low = mid+1;\\n\\t\\t\\telse                    high = mid;\\n\\t\\t}\\n\\t}\\n\\t// Checking the boundary cases\\n\\tif(ans[0]!=-1 && ans[1]==-1) \\t\\tans[1]=ans[0];\\n\\telse if(ans[1]!=-1 && ans[0]==-1)\\t\\tans[0]=ans[1];\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> searchRange(vector<int>& nums, int t) {\\n\\tint n = nums.size();\\n\\tvector<int> ans(2, -1);\\n\\t// To check if the array is empty\\n\\tif(n==0)    return ans;\\n\\t// To check if array has only one element\\n\\telse if(nums.size()==1){\\n\\t\\tif(nums[0]==t)\\t\\t\\treturn {0, 0};\\n\\t\\treturn ans;\\n\\t}\\n\\t// If first element of array is our target\\n\\tif(t==nums[0])  ans[0] = 0;\\n\\t// Else we do binary search for the first element in array\\n\\telse{\\n\\t\\tint low =0, high = n-1;\\n\\t\\twhile(low<high){\\n\\t\\t\\tint mid = (low+high)/2;\\n\\t\\t\\tif(nums[mid]==t && nums[mid-1]<nums[mid]){\\n\\t\\t\\t\\tans[0] = mid; break;\\n\\t\\t\\t}\\n\\t\\t\\telse if(nums[mid]>=t)   high = mid;\\n\\t\\t\\telse                    low = mid+1;\\n\\t\\t}\\n\\t}\\n\\t// If last element if our target\\n\\tif(t==nums[n-1])  ans[1] = n-1;\\n\\t// Else we do binary search for the last element in array\\n\\telse{\\n\\t\\tint low =0, high = n;\\n\\t\\twhile(low<high){\\n\\t\\t\\tint mid = (low+high)/2;\\n\\t\\t\\tif(nums[mid]==t && nums[mid]<nums[mid+1] && ans[0]!=mid){\\n\\t\\t\\t\\tans[1] = mid; break;\\n\\t\\t\\t}\\n\\t\\t\\telse if(nums[mid]<=t)   low = mid+1;\\n\\t\\t\\telse                    high = mid;\\n\\t\\t}\\n\\t}\\n\\t// Checking the boundary cases\\n\\tif(ans[0]!=-1 && ans[1]==-1) \\t\\tans[1]=ans[0];\\n\\telse if(ans[1]!=-1 && ans[0]==-1)\\t\\tans[0]=ans[1];\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2330367,
                "title": "easy-to-understand-binary-search-solution-with-explanation",
                "content": "Easy solution using binary search since list is already sorted. In this solution even if number is not in the list will take atleast O(log n) time.\\n\\nSteps:\\n\\n1.  If length of nums is zero or length of nums is 1 and that element too is not equal to target then in both these cases we return [-1,-1].\\n2.  If  in case when whole list consist only target element Ex. [3,3,3,3,3,3,3,3,3,3], then in this case we return [0, len(nums)-1].\\n3.  Now if both the cases above don\\'t work then we start the binary search. we calculate mid of the list nums then:\\n a)\\tIf  nums[mid] is equal to target:\\n \\n\\t we check on left and right side of the mid to determine begining and ending index, since list is            sorted all same elements will be side by side.\\n\\t\\n\\ta1) we check left side of the mid for beginning index:\\n\\t   To reduce the runtime for list like [3,3,3,4,5] I check if zero element of the list is equal to target if it is equal then we already found our left most index that is zero and no need to go in the while loop.\\n\\t   If target element is not at zero then we go in while loop and find the left most index.\\n\\t\\n\\ta2) we check right side of mid for ending index:\\n\\tsimilarly here for list like [1,2,3,3,3] I check the last elemnt for the right most index and we dont need go in the while loop.\\n\\tIf target element is not at last then we go in while loop and find the right most index.\\n\\t\\n\\t\\n\\tAfter that we return the lst containg both the values.\\nb) if nums[mid] is less than target then set low  to mid+1 and continue loop\\nc) if num[mid] is greater than target then set high to mid-1 and continue loop\\n\\n4. Now if elemnt is not found we end up here and return lst containg the default value we assigned to it in the start that is [-1,-1].\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        lst = [-1,-1]\\n        length = len(nums)\\n        low = 0\\n        high = length-1\\n        \\n        if (length == 0) or (length == 1 and nums[0] != target):\\n            return lst\\n        \\n        if nums[0] == target and nums[-1] == target:\\n            return [0,high]\\n        \\n        \\n        while low<=high:\\n            mid = low + (high-low)//2\\n            \\n            if nums[mid] == target:\\n                # checking on left side of the mid\\n                temp = mid\\n                if nums[0] == target:\\n                    lst[0] = 0 \\n                else:\\n                    lst[0] = mid\\n\\n                    while mid>-1:\\n                        if nums[mid-1] != target:\\n                            lst[0] = mid\\n                            break\\n                        mid -= 1\\n                # checking on the right side of the mid\\n                mid = temp\\n                if nums[-1] == target:\\n                    lst[1] = length-1\\n                    return lst\\n                else:\\n                    lst[1] = mid\\n                    while mid<length:\\n                        if nums[mid] != target:\\n                            lst[1] = mid-1\\n                            break\\n                        mid += 1\\n                    \\n                return lst\\n            \\n            elif nums[mid] < target:\\n                low = mid+1\\n                \\n            elif nums[mid] > target:\\n                high = mid-1\\n                    \\n        return lst\\n```\\n\\n***If you liked the solution please do upvote. Thanks!***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        lst = [-1,-1]\\n        length = len(nums)\\n        low = 0\\n        high = length-1\\n        \\n        if (length == 0) or (length == 1 and nums[0] != target):\\n            return lst\\n        \\n        if nums[0] == target and nums[-1] == target:\\n            return [0,high]\\n        \\n        \\n        while low<=high:\\n            mid = low + (high-low)//2\\n            \\n            if nums[mid] == target:\\n                # checking on left side of the mid\\n                temp = mid\\n                if nums[0] == target:\\n                    lst[0] = 0 \\n                else:\\n                    lst[0] = mid\\n\\n                    while mid>-1:\\n                        if nums[mid-1] != target:\\n                            lst[0] = mid\\n                            break\\n                        mid -= 1\\n                # checking on the right side of the mid\\n                mid = temp\\n                if nums[-1] == target:\\n                    lst[1] = length-1\\n                    return lst\\n                else:\\n                    lst[1] = mid\\n                    while mid<length:\\n                        if nums[mid] != target:\\n                            lst[1] = mid-1\\n                            break\\n                        mid += 1\\n                    \\n                return lst\\n            \\n            elif nums[mid] < target:\\n                low = mid+1\\n                \\n            elif nums[mid] > target:\\n                high = mid-1\\n                    \\n        return lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329914,
                "title": "rust-using-binary-search-and-partition-point",
                "content": "Rust already has plenty of decent ways to do a binary search on a slice without having to reinvent the wheel, so why not take advantage of that? \\n\\nNote that you can use partition_point alone to handle the case where the target is not in nums, but I prefer the error handling via the Result returned from binary_search, so I went with that since it doesn\\'t influence the big-O runtime. \\n\\n```\\nimpl Solution {\\n    pub fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {\\n        // Find if target in nums\\n        if let Ok(index) = nums.binary_search(&target) {\\n            // Target present\\n            vec![nums.partition_point(|&i| i < target) as i32, nums.partition_point(|&i| i <= target) as i32 - 1]\\n        } else {\\n            // Error, not found\\n            vec![-1, -1]\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {\\n        // Find if target in nums\\n        if let Ok(index) = nums.binary_search(&target) {\\n            // Target present\\n            vec![nums.partition_point(|&i| i < target) as i32, nums.partition_point(|&i| i <= target) as i32 - 1]\\n        } else {\\n            // Error, not found\\n            vec![-1, -1]\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2329454,
                "title": "python-simplest-solution-beats-87-67-submissions",
                "content": "![image](https://assets.leetcode.com/users/images/71f23449-43ee-4e3d-8299-da34b2f61610_1658714981.117612.png)\\n\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        res=[]\\n        if(nums.count(target)==0):\\n            return [-1,-1]\\n        res.append(nums.index(target))\\n        for x in range(len(nums)-1,-1,-1):\\n            if(nums[x]== target ):\\n                res.append(x)\\n                break\\n        \\n        return res\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/71f23449-43ee-4e3d-8299-da34b2f61610_1658714981.117612.png)\\n\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        res=[]\\n        if(nums.count(target)==0):\\n            return [-1,-1]\\n        res.append(nums.index(target))\\n        for x in range(len(nums)-1,-1,-1):\\n            if(nums[x]== target ):\\n                res.append(x)\\n                break\\n        \\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 2329430,
                "title": "python3-easy-simple-and-easy-to-understand-code-binarysearch",
                "content": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        ans=[-1, -1]\\n        ans[0] = self.find_index(nums, target, \\'l\\')\\n        ans[1] = self.find_index(nums, target, \\'r\\')\\n        return ans\\n        \\n    def find_index(self, nums, target, method):    # method: leftmost or rightmost\\n        index, low, high = -1, 0, len(nums)-1\\n        while low <= high:\\n            mid = low + (high - low)//2\\n            if nums[mid] == target:\\n                index = mid\\n                if method == \\'r\\':           # if the selected method is rightmost\\n                    low = mid + 1\\n                elif method == \\'l\\':         # if the selected method is leftmost\\n                    high = mid - 1\\n            elif nums[mid] > target: \\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n        return index\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        ans=[-1, -1]\\n        ans[0] = self.find_index(nums, target, \\'l\\')\\n        ans[1] = self.find_index(nums, target, \\'r\\')\\n        return ans\\n        \\n    def find_index(self, nums, target, method):    # method: leftmost or rightmost\\n        index, low, high = -1, 0, len(nums)-1\\n        while low <= high:\\n            mid = low + (high - low)//2\\n            if nums[mid] == target:\\n                index = mid\\n                if method == \\'r\\':           # if the selected method is rightmost\\n                    low = mid + 1\\n                elif method == \\'l\\':         # if the selected method is leftmost\\n                    high = mid - 1\\n            elif nums[mid] > target: \\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n        return index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188885,
                "title": "c-o-log-n-binary-search",
                "content": "**Logic is pretty simple:** Just perform Binary Search from left to right to find **FIRST** index and right to left to find **LAST** index\\n\\nTime: O(log n)\\n\\n**Upvote** my solution if you liked my approach :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        int first_index = bs(nums, target);    // O(log n)\\n        int last_index = mod_bs(nums, target); // O(log n)\\n        \\n        return vector<int>{first_index, last_index};\\n    }\\n    \\n    // Modified Binary Search that searches in reverse direction\\n    int mod_bs(vector<int>& nums, int target)\\n    {\\n        int low, high, ind;\\n        low = nums.size()-1;\\n        high = 0;\\n        ind = -1;\\n        while (high <= low) \\n        {\\n            int mid = high + (low - high)/2;\\n            \\n            int current = nums[mid];\\n            \\n            if (current == target) \\n                ind = mid;\\n            \\n            if (current <= target) \\n                high = mid + 1;\\n            else\\n                low = mid - 1;\\n        }\\n        \\n        return ind;\\n    }\\n    \\n    // Normal Binary Search\\n    int bs(vector<int>& nums, int target)\\n    {\\n        int low, high, ind;\\n        low = 0;\\n        high = nums.size()-1;\\n        ind = -1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low)/2;\\n            \\n            int current = nums[mid];\\n            \\n            if (current == target)\\n                ind = mid;\\n            \\n            if (current < target)\\n                low = mid+1;\\n            else\\n                high = mid-1;\\n        }\\n        \\n        return ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        int first_index = bs(nums, target);    // O(log n)\\n        int last_index = mod_bs(nums, target); // O(log n)\\n        \\n        return vector<int>{first_index, last_index};\\n    }\\n    \\n    // Modified Binary Search that searches in reverse direction\\n    int mod_bs(vector<int>& nums, int target)\\n    {\\n        int low, high, ind;\\n        low = nums.size()-1;\\n        high = 0;\\n        ind = -1;\\n        while (high <= low) \\n        {\\n            int mid = high + (low - high)/2;\\n            \\n            int current = nums[mid];\\n            \\n            if (current == target) \\n                ind = mid;\\n            \\n            if (current <= target) \\n                high = mid + 1;\\n            else\\n                low = mid - 1;\\n        }\\n        \\n        return ind;\\n    }\\n    \\n    // Normal Binary Search\\n    int bs(vector<int>& nums, int target)\\n    {\\n        int low, high, ind;\\n        low = 0;\\n        high = nums.size()-1;\\n        ind = -1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low)/2;\\n            \\n            int current = nums[mid];\\n            \\n            if (current == target)\\n                ind = mid;\\n            \\n            if (current < target)\\n                low = mid+1;\\n            else\\n                high = mid-1;\\n        }\\n        \\n        return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913135,
                "title": "simple-o-logn-java-solution-1ms-solution",
                "content": "```\\nclass Solution {\\n    public int firstOccurance(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        while(high >= low) {\\n            int mid = (low + high) / 2;\\n            if(nums[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else if(nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                if(mid == 0 || nums[mid] != nums[mid-1]) {\\n                    return mid;\\n                }\\n                else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public int lastOccurance(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        while(high >= low) {\\n            int mid = (low + high) / 2;\\n            if(nums[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else if(nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                if(mid ==  nums.length-1 || nums[mid] != nums[mid+1]) {\\n                    return mid;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public int[] searchRange(int[] nums, int target) {\\n        int[] arr = new int[2];\\n        \\n        int first = firstOccurance(nums,target);\\n        if(first == -1) {\\n            arr[0] = -1;\\n            arr[1] = -1;\\n        }\\n        else {\\n            int second = lastOccurance(nums,target);\\n            arr[0] = first;\\n            arr[1] = second;\\n        }\\n        \\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int firstOccurance(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        while(high >= low) {\\n            int mid = (low + high) / 2;\\n            if(nums[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else if(nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                if(mid == 0 || nums[mid] != nums[mid-1]) {\\n                    return mid;\\n                }\\n                else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public int lastOccurance(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        while(high >= low) {\\n            int mid = (low + high) / 2;\\n            if(nums[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else if(nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                if(mid ==  nums.length-1 || nums[mid] != nums[mid+1]) {\\n                    return mid;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public int[] searchRange(int[] nums, int target) {\\n        int[] arr = new int[2];\\n        \\n        int first = firstOccurance(nums,target);\\n        if(first == -1) {\\n            arr[0] = -1;\\n            arr[1] = -1;\\n        }\\n        else {\\n            int second = lastOccurance(nums,target);\\n            arr[0] = first;\\n            arr[1] = second;\\n        }\\n        \\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897855,
                "title": "easy-understandable-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target){\\n        int[] ans = {1, -1};\\n        ans[0] = search(nums, target, true);\\n        if(ans[0]!=-1)\\n            ans[1] = search(nums, target, false);\\n        return ans;\\n      }\\n    \\n    int search(int[] nums, int target, boolean findStartIndex){\\n        int start = 0;\\n        int end = nums.length-1;\\n        int ans = -1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if(target<nums[mid])\\n                end = mid - 1;\\n            else if(target>nums[mid])\\n                start = mid + 1;\\n            else{\\n                ans = mid;\\n                if(findStartIndex)\\n                    end = mid - 1;\\n                else\\n                    start = mid + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target){\\n        int[] ans = {1, -1};\\n        ans[0] = search(nums, target, true);\\n        if(ans[0]!=-1)\\n            ans[1] = search(nums, target, false);\\n        return ans;\\n      }\\n    \\n    int search(int[] nums, int target, boolean findStartIndex){\\n        int start = 0;\\n        int end = nums.length-1;\\n        int ans = -1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if(target<nums[mid])\\n                end = mid - 1;\\n            else if(target>nums[mid])\\n                start = mid + 1;\\n            else{\\n                ans = mid;\\n                if(findStartIndex)\\n                    end = mid - 1;\\n                else\\n                    start = mid + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705289,
                "title": "rust-binary-search-by-or-partition-point",
                "content": "I reckon this problem isn\\'t really about how to implement binary search, but rather how to wield it. This problem is a good opportunity to use [binary_search_by](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.binary_search_by).\\n\\n```\\nuse std::cmp::Ordering;\\n\\nimpl Solution {\\n    pub fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {\\n        let i = nums.binary_search_by(|n| if n < &target { Ordering::Less } else { Ordering::Greater }).unwrap_err();\\n        \\n        if i == nums.len() || nums[i] != target {\\n            return vec![-1, -1];   \\n        }\\n        \\n        let j = nums.binary_search_by(|n| if n <= &target { Ordering::Less } else { Ordering::Greater }).unwrap_err();\\n        \\n        vec![i as i32, (j - 1) as i32]\\n    }\\n}\\n```\\n\\nWith [partition_point](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.partition_point) instead:\\n```\\nimpl Solution {\\n    pub fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {\\n        let i = nums.partition_point(|n| n < &target);\\n        \\n        if i == nums.len() || nums[i] != target {\\n            return vec![-1, -1];   \\n        }\\n        \\n        let j = nums.partition_point(|n| n <= &target);\\n        \\n        vec![i as i32, (j - 1) as i32]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::Ordering;\\n\\nimpl Solution {\\n    pub fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {\\n        let i = nums.binary_search_by(|n| if n < &target { Ordering::Less } else { Ordering::Greater }).unwrap_err();\\n        \\n        if i == nums.len() || nums[i] != target {\\n            return vec![-1, -1];   \\n        }\\n        \\n        let j = nums.binary_search_by(|n| if n <= &target { Ordering::Less } else { Ordering::Greater }).unwrap_err();\\n        \\n        vec![i as i32, (j - 1) as i32]\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {\\n        let i = nums.partition_point(|n| n < &target);\\n        \\n        if i == nums.len() || nums[i] != target {\\n            return vec![-1, -1];   \\n        }\\n        \\n        let j = nums.partition_point(|n| n <= &target);\\n        \\n        vec![i as i32, (j - 1) as i32]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1638626,
                "title": "simple-binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res(2, -1);\\n        res[0] = _searchRange(nums, target, true);\\n        res[1] = _searchRange(nums, target, false);\\n        return res;\\n    }\\n    \\n    int _searchRange(vector<int>& nums, int target, bool first) {\\n        int ans = -1, l = 0, r = nums.size() - 1;\\n        while(l <= r) {\\n            int mid = (l + r) >> 1;\\n            \\n            if(nums[mid] > target) {\\n                r = mid - 1;\\n            } else if(nums[mid] < target) {\\n                l = mid + 1;\\n            } else {\\n                ans = mid;\\n                // find first index => search left\\n                if(first) {\\n                    r = mid - 1;\\n                } else {\\n                    l = mid + 1; // find last index => search right\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res(2, -1);\\n        res[0] = _searchRange(nums, target, true);\\n        res[1] = _searchRange(nums, target, false);\\n        return res;\\n    }\\n    \\n    int _searchRange(vector<int>& nums, int target, bool first) {\\n        int ans = -1, l = 0, r = nums.size() - 1;\\n        while(l <= r) {\\n            int mid = (l + r) >> 1;\\n            \\n            if(nums[mid] > target) {\\n                r = mid - 1;\\n            } else if(nums[mid] < target) {\\n                l = mid + 1;\\n            } else {\\n                ans = mid;\\n                // find first index => search left\\n                if(first) {\\n                    r = mid - 1;\\n                } else {\\n                    l = mid + 1; // find last index => search right\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604013,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        l=[]\\n        r=nums[::-1]\\n        if target in nums:\\n            l.append(nums.index(target))\\n            a=r.index(target)+1\\n            l.append(len(nums)-a)\\n                \\n        else:\\n            l.append(-1)\\n            l.append(-1)\\n        return l\\n```\\n\\nPlease UPVOTE if you like the Solution",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        l=[]\\n        r=nums[::-1]\\n        if target in nums:\\n            l.append(nums.index(target))\\n            a=r.index(target)+1\\n            l.append(len(nums)-a)\\n                \\n        else:\\n            l.append(-1)\\n            l.append(-1)\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520358,
                "title": "c-o-log-n-runtime-4-ms-faster-than-95-68",
                "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& arr, int x )\\n    {\\n        int n = arr.size();\\n        int start = 0;\\n        int first = -1;\\n        int last = -1;\\n        int end = n-1;\\n        int mid;\\n        vector<int> ans;\\n        while(start<=end)\\n        {\\n            mid = start + (end-start)/2;\\n            if(arr[mid]==x)\\n            {\\n                first = mid;\\n                end = mid-1;\\n            }\\n            else if(arr[mid]>x)\\n            {\\n                end = mid-1;\\n            }\\n            else\\n            {\\n                start = mid+1;\\n            }\\n        }\\n        start = 0;\\n        last = -1;\\n        end = n-1;\\n        while(start<=end)\\n        {\\n            mid = start + (end-start)/2;\\n            if(arr[mid] == x)\\n            {\\n                start = mid +1;\\n                last = mid ;\\n            }\\n            else if(arr[mid]<x)\\n            {\\n                start = mid+1;\\n            }\\n            else\\n            {\\n                end = mid-1;\\n            }\\n        }\\n        if(first!=-1 && last!=-1)\\n        {\\n            ans.push_back(first);\\n            ans.push_back(last);\\n        }\\n        else\\n        {\\n            ans.push_back(first);\\n            ans.push_back(last);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& arr, int x )\\n    {\\n        int n = arr.size();\\n        int start = 0;\\n        int first = -1;\\n        int last = -1;\\n        int end = n-1;\\n        int mid;\\n        vector<int> ans;\\n        while(start<=end)\\n        {\\n            mid = start + (end-start)/2;\\n            if(arr[mid]==x)\\n            {\\n                first = mid;\\n                end = mid-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1379125,
                "title": "c-8-ms-faster-than-86-45",
                "content": "```\\nint findFirstIndex(int *nums, int target, int numsSize){\\n    int start = -1;\\n    \\n    int l=0, h = numsSize-1, mid = 0;\\n    \\n    while(l<=h){\\n        mid = l+(h-l)/2;\\n        if(nums[mid] < target)\\n            l = mid+1;\\n        else\\n            h = mid-1;\\n        if(nums[mid]==target)\\n            start = mid;\\n    }\\n    \\n    return start;\\n}//findFirstIndex\\n\\nint findLastIndex(int *nums, int target, int numsSize){\\n    int end = -1;\\n    \\n    int l=0, h = numsSize-1, mid = 0;\\n    \\n    while(l<=h){\\n        mid = l+(h-l)/2;\\n        if(nums[mid] <= target)\\n            l = mid+1;\\n        else\\n            h = mid-1; \\n        \\n        if(nums[mid] == target)\\n            end = mid;\\n    }\\n    \\n    return end;\\n}\\n\\n\\nint* searchRange(int* nums, int numsSize, int target, int* returnSize){\\n    int *res = (int *)malloc(sizeof(int) * 2);\\n    *returnSize = 2;\\n    \\n    res[0] = findFirstIndex(nums, target, numsSize);\\n    res[1] = findLastIndex(nums, target, numsSize);\\n    return res;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findFirstIndex(int *nums, int target, int numsSize){\\n    int start = -1;\\n    \\n    int l=0, h = numsSize-1, mid = 0;\\n    \\n    while(l<=h){\\n        mid = l+(h-l)/2;\\n        if(nums[mid] < target)\\n            l = mid+1;\\n        else\\n            h = mid-1;\\n        if(nums[mid]==target)\\n            start = mid;\\n    }\\n    \\n    return start;\\n}//findFirstIndex\\n\\nint findLastIndex(int *nums, int target, int numsSize){\\n    int end = -1;\\n    \\n    int l=0, h = numsSize-1, mid = 0;\\n    \\n    while(l<=h){\\n        mid = l+(h-l)/2;\\n        if(nums[mid] <= target)\\n            l = mid+1;\\n        else\\n            h = mid-1; \\n        \\n        if(nums[mid] == target)\\n            end = mid;\\n    }\\n    \\n    return end;\\n}\\n\\n\\nint* searchRange(int* nums, int numsSize, int target, int* returnSize){\\n    int *res = (int *)malloc(sizeof(int) * 2);\\n    *returnSize = 2;\\n    \\n    res[0] = findFirstIndex(nums, target, numsSize);\\n    res[1] = findLastIndex(nums, target, numsSize);\\n    return res;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1181941,
                "title": "c-two-approaches-o-logn-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int find_first_position(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size()-1;\\n        int result = -1;\\n        while(l <= r) {\\n            int mid = l + (r-l)/2;\\n            if(nums[mid] == target) {\\n                result = mid; //possibly my answer\\n                r = mid-1;     //but lets look at left more\\n            } else if(nums[mid] > target) {\\n                r = mid-1;\\n            } else {\\n                l = mid+1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    int find_last_position(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size()-1;\\n        int result = -1;\\n        while(l <= r) {\\n            int mid = l + (r-l)/2;\\n            if(nums[mid] == target) {\\n                result = mid; //possibly my answer\\n                l = mid+1;   //but lets look at right more\\n            } else if(nums[mid] > target) {\\n                r = mid-1;\\n            } else {\\n                l = mid+1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    //Approach-1\\n    vector<int> search(vector<int>& nums, int target) {\\n        int l = find_first_position(nums, target);\\n        int r = find_last_position(nums, target);\\n        \\n        return {l, r};\\n    }\\n    \\n    //Approach-2\\n    vector<int> search_stl(vector<int>& nums, int target) {\\n        //first element equal to or greater than target\\n        int l = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n        \\n        //first element greater than target\\n        int r = upper_bound(nums.begin(), nums.end(), target) - nums.begin();\\n        \\n        //Why do we need this (nums[l] != target) ? \\n        //Because lower_bound returns first element which is equal or GREATER THAN target.\\n        //So, in case the target is not in the list, it will return first greater element than target which will be wrong\\n        if(l == nums.size() || nums[l] != target)\\n            return {-1, -1};\\n        \\n        return {l, r-1};\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        return search(nums, target);     //Approach - 1\\n        \\n        return search_stl(nums, target); //Approach - 2\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int find_first_position(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size()-1;\\n        int result = -1;\\n        while(l <= r) {\\n            int mid = l + (r-l)/2;\\n            if(nums[mid] == target) {\\n                result = mid; //possibly my answer\\n                r = mid-1;     //but lets look at left more\\n            } else if(nums[mid] > target) {\\n                r = mid-1;\\n            } else {\\n                l = mid+1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    int find_last_position(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size()-1;\\n        int result = -1;\\n        while(l <= r) {\\n            int mid = l + (r-l)/2;\\n            if(nums[mid] == target) {\\n                result = mid; //possibly my answer\\n                l = mid+1;   //but lets look at right more\\n            } else if(nums[mid] > target) {\\n                r = mid-1;\\n            } else {\\n                l = mid+1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    //Approach-1\\n    vector<int> search(vector<int>& nums, int target) {\\n        int l = find_first_position(nums, target);\\n        int r = find_last_position(nums, target);\\n        \\n        return {l, r};\\n    }\\n    \\n    //Approach-2\\n    vector<int> search_stl(vector<int>& nums, int target) {\\n        //first element equal to or greater than target\\n        int l = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n        \\n        //first element greater than target\\n        int r = upper_bound(nums.begin(), nums.end(), target) - nums.begin();\\n        \\n        //Why do we need this (nums[l] != target) ? \\n        //Because lower_bound returns first element which is equal or GREATER THAN target.\\n        //So, in case the target is not in the list, it will return first greater element than target which will be wrong\\n        if(l == nums.size() || nums[l] != target)\\n            return {-1, -1};\\n        \\n        return {l, r-1};\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        return search(nums, target);     //Approach - 1\\n        \\n        return search_stl(nums, target); //Approach - 2\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 630187,
                "title": "c-solution-with-different-solutions",
                "content": "**Solution 1:- O(n)**\\n```\\nvector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        if(nums.size()==0)return {-1,-1};\\n        int l=0,r=nums.size()-1;\\n        while(l<=r)\\n        {\\n            if(nums[l]==target && nums[r]==target)\\n            {\\n                ans.push_back(l);\\n                ans.push_back(r);\\n                return ans;\\n            }\\n            else if(nums[l]!=target && nums[r]!=target)\\n                l++,r--;\\n            else if(nums[l]==target && nums[r]!=target)\\n                r--;\\n            else\\n                l++;\\n        }\\n        ans.push_back(-1);\\n        ans.push_back(-1);\\n        return ans;\\n    }\\n```\\n**Solution 2:-O(logn)**\\n```\\n vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l=0,r=nums.size()-1,result=INT_MAX;\\n        while(l<=r)\\n        {\\n            int m=l+(r-l)/2;\\n            if(nums[m]==target)\\n            {\\n                result=m;\\n                r=m-1;\\n            }\\n            else if(nums[m]<target) l=m+1;\\n            else r=m-1;\\n        }\\n        ans.push_back(result!=INT_MAX?result:-1);\\n        l=0,r=nums.size()-1;\\n        result=INT_MAX;\\n        while(l<=r)\\n        {\\n            int m=l+(r-l)/2;\\n            if(nums[m]==target)\\n            {\\n                result=m;\\n                l=m+1;\\n            }\\n            else if(nums[m]<target) l=m+1;\\n            else r=m-1;\\n        }\\n        ans.push_back(result!=INT_MAX?result:-1);\\n        return ans;\\n    }\\n```\\n If you want to learn stl there are a good number of stl functions that this problem can be solved with.\\n **Solution 3:-**\\n ```\\n         vector<int> searchRange(vector<int>& nums, int target) {\\n        if(nums.size()==0||binary_search(nums.begin(),nums.end(),target)==0)return {-1,-1};\\n        int left=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int right=upper_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        return {left,right-1};\\n    }\\n ```\\n **Solution 4:-**\\n ```\\n         vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        if(find(nums.begin(),nums.end(),target)-nums.begin()>=nums.size())ans.push_back(-1);\\n        else\\n            ans.push_back(find(nums.begin(),nums.end(),target)-nums.begin());\\n        reverse(nums.begin(),nums.end());\\n        if(find(nums.begin(),nums.end(),target)-nums.begin()>=nums.size())ans.push_back(-1);\\n        else\\n            ans.push_back(nums.size()-1-(find(nums.begin(),nums.end(),target)-nums.begin()));\\n        return ans;\\n    }\\n ```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        if(nums.size()==0)return {-1,-1};\\n        int l=0,r=nums.size()-1;\\n        while(l<=r)\\n        {\\n            if(nums[l]==target && nums[r]==target)\\n            {\\n                ans.push_back(l);\\n                ans.push_back(r);\\n                return ans;\\n            }\\n            else if(nums[l]!=target && nums[r]!=target)\\n                l++,r--;\\n            else if(nums[l]==target && nums[r]!=target)\\n                r--;\\n            else\\n                l++;\\n        }\\n        ans.push_back(-1);\\n        ans.push_back(-1);\\n        return ans;\\n    }\\n```\n```\\n vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l=0,r=nums.size()-1,result=INT_MAX;\\n        while(l<=r)\\n        {\\n            int m=l+(r-l)/2;\\n            if(nums[m]==target)\\n            {\\n                result=m;\\n                r=m-1;\\n            }\\n            else if(nums[m]<target) l=m+1;\\n            else r=m-1;\\n        }\\n        ans.push_back(result!=INT_MAX?result:-1);\\n        l=0,r=nums.size()-1;\\n        result=INT_MAX;\\n        while(l<=r)\\n        {\\n            int m=l+(r-l)/2;\\n            if(nums[m]==target)\\n            {\\n                result=m;\\n                l=m+1;\\n            }\\n            else if(nums[m]<target) l=m+1;\\n            else r=m-1;\\n        }\\n        ans.push_back(result!=INT_MAX?result:-1);\\n        return ans;\\n    }\\n```\n```\\n         vector<int> searchRange(vector<int>& nums, int target) {\\n        if(nums.size()==0||binary_search(nums.begin(),nums.end(),target)==0)return {-1,-1};\\n        int left=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int right=upper_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        return {left,right-1};\\n    }\\n ```\n```\\n         vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        if(find(nums.begin(),nums.end(),target)-nums.begin()>=nums.size())ans.push_back(-1);\\n        else\\n            ans.push_back(find(nums.begin(),nums.end(),target)-nums.begin());\\n        reverse(nums.begin(),nums.end());\\n        if(find(nums.begin(),nums.end(),target)-nums.begin()>=nums.size())ans.push_back(-1);\\n        else\\n            ans.push_back(nums.size()-1-(find(nums.begin(),nums.end(),target)-nums.begin()));\\n        return ans;\\n    }\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 421199,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int[] SearchRange(int[] nums, int target) \\n    {\\n        return new int[] {FindFirstIndex(nums, target), FindLastIndex(nums, target)};\\n    }\\n    \\n    private int FindFirstIndex(int[] nums, int target)\\n    {\\n        if(nums.Length == 0) return -1;\\n        int start = 0, end = nums.Length - 1;\\n        while(start < end)\\n        {\\n            var mid = start + (end  - start) / 2;\\n            if(nums[mid] < target)\\n                start = mid + 1;\\n            else\\n                end = mid;\\n        }\\n        return nums[start] == target ? start : -1;\\n    }\\n    \\n    private int FindLastIndex(int[] nums, int target)\\n    {\\n        if(nums.Length == 0) return -1;\\n        int start = 0, end = nums.Length - 1;\\n        while(start < end)\\n        {\\n            var mid = start + (end  - start + 1) / 2;\\n            if(nums[mid] > target)\\n                end = mid - 1;\\n            else\\n                start = mid;\\n        }\\n        \\n        return nums[start] == target ? start : -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int[] SearchRange(int[] nums, int target) \\n    {\\n        return new int[] {FindFirstIndex(nums, target), FindLastIndex(nums, target)};\\n    }\\n    \\n    private int FindFirstIndex(int[] nums, int target)\\n    {\\n        if(nums.Length == 0) return -1;\\n        int start = 0, end = nums.Length - 1;\\n        while(start < end)\\n        {\\n            var mid = start + (end  - start) / 2;\\n            if(nums[mid] < target)\\n                start = mid + 1;\\n            else\\n                end = mid;\\n        }\\n        return nums[start] == target ? start : -1;\\n    }\\n    \\n    private int FindLastIndex(int[] nums, int target)\\n    {\\n        if(nums.Length == 0) return -1;\\n        int start = 0, end = nums.Length - 1;\\n        while(start < end)\\n        {\\n            var mid = start + (end  - start + 1) / 2;\\n            if(nums[mid] > target)\\n                end = mid - 1;\\n            else\\n                start = mid;\\n        }\\n        \\n        return nums[start] == target ? start : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 334345,
                "title": "c-concise-binary-search",
                "content": "##### Using lower_bound and upper_bound:\\n```cpp\\nvector<int> searchRange(vector<int>& nums, int target) {\\n\\tauto first = lower_bound(begin(nums), end(nums), target);\\n\\tif(first == end(nums) || *first != target) return {-1, -1};\\n\\tauto last = --(upper_bound(begin(nums), end(nums), target));\\n\\treturn {first - begin(nums), last - begin(nums)};\\n}\\n```\\n\\n---\\n##### Using equal_range:\\n\\n```cpp\\nvector<int> searchRange(vector<int>& nums, int target) {\\n\\tauto range = equal_range(begin(nums), end(nums), target);\\n\\tif(range.first == range.second) return {-1, -1};\\n\\treturn {range.first - begin(nums), range.second - begin(nums) - 1};\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```cpp\\nvector<int> searchRange(vector<int>& nums, int target) {\\n\\tauto first = lower_bound(begin(nums), end(nums), target);\\n\\tif(first == end(nums) || *first != target) return {-1, -1};\\n\\tauto last = --(upper_bound(begin(nums), end(nums), target));\\n\\treturn {first - begin(nums), last - begin(nums)};\\n}\\n```\n```cpp\\nvector<int> searchRange(vector<int>& nums, int target) {\\n\\tauto range = equal_range(begin(nums), end(nums), target);\\n\\tif(range.first == range.second) return {-1, -1};\\n\\treturn {range.first - begin(nums), range.second - begin(nums) - 1};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 139587,
                "title": "clean-javascript-binary-search-solution",
                "content": "```js\\nfunction searchRange(nums, target) {\\n  let res = [-1, -1];\\n\\n  // find the left\\n  let l = 0;\\n  let r = nums.length - 1;\\n\\n  while (l < r) {\\n    const mid = Math.floor((l + r) / 2);  // note using Math.floor\\n    \\n    if (nums[mid] < target) l = mid + 1;\\n    else r = mid;\\n  }\\n\\n  if (nums[l] !== target) return res;\\n  else res[0] = l;\\n\\n  // find the right\\n  r = nums.length - 1;  // no need to set l to 0\\n\\n  while (l < r) {\\n    const mid = Math.ceil((l + r) / 2);   // note using Math.ceil\\n    \\n    if (nums[mid] > target) r = mid - 1;\\n    else l = mid;\\n  }\\n\\n  res[1] = r;\\n\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction searchRange(nums, target) {\\n  let res = [-1, -1];\\n\\n  // find the left\\n  let l = 0;\\n  let r = nums.length - 1;\\n\\n  while (l < r) {\\n    const mid = Math.floor((l + r) / 2);  // note using Math.floor\\n    \\n    if (nums[mid] < target) l = mid + 1;\\n    else r = mid;\\n  }\\n\\n  if (nums[l] !== target) return res;\\n  else res[0] = l;\\n\\n  // find the right\\n  r = nums.length - 1;  // no need to set l to 0\\n\\n  while (l < r) {\\n    const mid = Math.ceil((l + r) / 2);   // note using Math.ceil\\n    \\n    if (nums[mid] > target) r = mid - 1;\\n    else l = mid;\\n  }\\n\\n  res[1] = r;\\n\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 110692,
                "title": "python-99-99-easy-solution-two-scans-with-min-max-and-global-variables-logn-bhasha",
                "content": "\\nI see that we can avoid calling subroutines by using int.min and int.max values.The idea is to find the first occurring index in one pass and then do the same for the second pass.\\n\\n```\\n\\t\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        first = float(\"inf\")\\n        second = float(\"-inf\")\\n        \\n        low = 0\\n        high = len(nums)-1\\n        \\n        while(low<=high):\\n            mid = (low+high)/2\\n            if nums[mid] == target:\\n                first = min(first,mid)\\n                high = mid-1 # Search left to get min index\\n            elif nums[mid]>target:\\n                high = mid-1\\n            else:\\n                low = mid+1\\n                  \\n        low = 0\\n        high = len(nums)-1\\n\\n        # Reset the variables low and high\\n        while(low<=high):\\n            mid = (low+high)/2\\n            if nums[mid] == target:\\n                second = max(second,mid)\\n                low = mid+1 #Search right to get the max index.\\n            elif nums[mid]>target:\\n                high = mid-1\\n            else:\\n                low = mid+1\\n        first = first if first!=float(\"inf\") else -1\\n        second = second if second!=float(\"-inf\") else -1\\n            \\n        return [first,second]\\n\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\t\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        first = float(\"inf\")\\n        second = float(\"-inf\")\\n        \\n        low = 0\\n        high = len(nums)-1\\n        \\n        while(low<=high):\\n            mid = (low+high)/2\\n            if nums[mid] == target:\\n                first = min(first,mid)\\n                high = mid-1 # Search left to get min index\\n            elif nums[mid]>target:\\n                high = mid-1\\n            else:\\n                low = mid+1\\n                  \\n        low = 0\\n        high = len(nums)-1\\n\\n        # Reset the variables low and high\\n        while(low<=high):\\n            mid = (low+high)/2\\n            if nums[mid] == target:\\n                second = max(second,mid)\\n                low = mid+1 #Search right to get the max index.\\n            elif nums[mid]>target:\\n                high = mid-1\\n            else:\\n                low = mid+1\\n        first = first if first!=float(\"inf\") else -1\\n        second = second if second!=float(\"-inf\") else -1\\n            \\n        return [first,second]\\n\\t\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 14761,
                "title": "simple-o-log-n-java-solution",
                "content": "````\\npublic class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(nums[mid] == target){\\n                if(nums[left] == target && nums[right] == target)\\n                    return new int[]{left, right};\\n                else if(nums[left] != target)\\n                    left++;\\n                else\\n                    right--;\\n            }else if(nums[mid] < target)\\n                left = mid + 1;\\n            else \\n                right = mid - 1;\\n        }\\n        \\n        return new int[]{-1, -1};\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(nums[mid] == target){\\n                if(nums[left] == target && nums[right] == target)\\n                    return new int[]{left, right}",
                "codeTag": "Java"
            },
            {
                "id": 3950949,
                "title": "simple-java-solution-beats-100-with-java-beginner-friendly-beats-99-67-in-memory",
                "content": "# Intuition\\nwe have to find the target element and then keep on updating the left and right pointers till we reach the border of the repeating sequence.\\n\\n# Approach\\nMake a seperate function which performs normal binary search. but we will call it two times. one for left boundary and one for right boundary. It will accept a boolean variable which will tell the function to search for left boundary or right boundary. \\n\\n1. FOR LEFT Boundary -\\n    - set boolean to true.\\n    - initialise left and right pointers on boundaries of array.\\n    - initialise mid pointer inside while loop.\\n    - initialise a pointer i which will give you the boundary value.\\n    - perform a simple binary search but when you find the element set i=mid and then keep on updating the right pointer as right=mid-1.\\n    - then return i.\\n\\n\\n2. FOR RIGHT boundary - \\n    - set boolean to false.\\n    - initialise left and right pointers on boundaries of array.\\n    - initialise mid pointer inside while loop.\\n    - initialise a pointer i which will give you the boundary value.\\n    - perform a simple binary search but when you find the element set i=mid and then keep on updating the left pointer as left=mid+1.\\n    - then return i. \\n\\n# Complexity\\n- Time complexity:\\nlog(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] arr={-1,-1};\\n\\n        arr[0]=findInd(nums,target,true);\\n        arr[1]=findInd(nums,target,false);\\n\\n        return arr;\\n    }\\n\\n    public int findInd(int[] nums,int target,boolean flag)\\n    {\\n        int left=0;\\n        int right=nums.length-1;\\n        int i=-1;\\n\\n        while(left<=right)\\n        {\\n            int mid=(left+right)/2;\\n\\n            if(nums[mid]>target)\\n            {\\n                right=mid-1;\\n            }else if(nums[mid]<target)\\n            {\\n                left=mid+1;\\n            }else if(nums[mid]==target)\\n            {\\n                i=mid;\\n                if(flag){\\n                  right=mid-1;;\\n                }else{\\n                   left=mid+1;\\n                }\\n            }\\n        }\\n\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] arr={-1,-1};\\n\\n        arr[0]=findInd(nums,target,true);\\n        arr[1]=findInd(nums,target,false);\\n\\n        return arr;\\n    }\\n\\n    public int findInd(int[] nums,int target,boolean flag)\\n    {\\n        int left=0;\\n        int right=nums.length-1;\\n        int i=-1;\\n\\n        while(left<=right)\\n        {\\n            int mid=(left+right)/2;\\n\\n            if(nums[mid]>target)\\n            {\\n                right=mid-1;\\n            }else if(nums[mid]<target)\\n            {\\n                left=mid+1;\\n            }else if(nums[mid]==target)\\n            {\\n                i=mid;\\n                if(flag){\\n                  right=mid-1;;\\n                }else{\\n                   left=mid+1;\\n                }\\n            }\\n        }\\n\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614466,
                "title": "easy-approach-by-using-pure-binary-search-algorithm",
                "content": "# Intuition\\nTo return a vector containing first occurance of K and last occurance of K\\n\\n# Approach\\nApproach to solve this problem is just by using simple binary search.\\n- Putting a start variable at start of the given vector and end variable at the last element of vector and a variable ans initialized with -1(to return if element is not present).\\n\\n ********* First occurance of target*******************\\n- Ccreate a while loop running till s<=e.\\n- Create a mid variable by using the formula s+(e-s)/2 which eventually statisfies the constraint of integer.\\n- 3 conditions in while loop \\n            1 if(nums[mid]==target){\\n                int ans=mid;\\n                    e=mid-1;// to get the first element as the first occurance of rarget will be in left side of the mid.\\n            }\\n            2 else if (nums[mid] > target) {\\n                e = mid - 1;\\n            }\\n            3  else {\\n                s = mid + 1;\\n            }\\n            return ans; //if not found, will return -1\\n    \\n   ** Last occurance of target**\\n     same as first occurance of target \\n     just change the 1st condition with s=mid+1; //as last occurance will be at right side of  mid.\\n\\n Now just return the vector by saving firstOccurance and lastOccurance. \\n\\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n\\n- Space complexity:\\nSpace Complexity is O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int s = 0,ansA = -1;\\n    int firstOcr(vector<int>& nums, int target) {\\n        int e = nums.size() - 1 ;\\n\\n        while (s <= e) {\\n            int mid = s + (e - s) / 2;\\n\\n            if (nums[mid] == target) {\\n                ansA = mid;\\n                e = mid - 1;\\n            } else if (nums[mid] > target) {\\n                e = mid - 1;\\n            } else {\\n                s = mid + 1;\\n            }\\n        }\\n\\n        return ansA;\\n    }\\n\\n    int LastOcr(vector<int>& nums, int target) {\\n        int e = nums.size() - 1 ;\\n\\n        while (s <= e) {\\n            int mid = s + (e - s) / 2;\\n\\n            if (nums[mid] == target) {\\n                ansA = mid;\\n                s = mid + 1;\\n            } else if (nums[mid] > target) {\\n                e = mid - 1;\\n            } else {\\n                s = mid + 1;\\n            }\\n        }\\n        return ansA;\\n    }\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v(2);\\n        v[0] = firstOcr(nums, target);\\n        v[1] = LastOcr(nums, target);\\n\\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int s = 0,ansA = -1;\\n    int firstOcr(vector<int>& nums, int target) {\\n        int e = nums.size() - 1 ;\\n\\n        while (s <= e) {\\n            int mid = s + (e - s) / 2;\\n\\n            if (nums[mid] == target) {\\n                ansA = mid;\\n                e = mid - 1;\\n            } else if (nums[mid] > target) {\\n                e = mid - 1;\\n            } else {\\n                s = mid + 1;\\n            }\\n        }\\n\\n        return ansA;\\n    }\\n\\n    int LastOcr(vector<int>& nums, int target) {\\n        int e = nums.size() - 1 ;\\n\\n        while (s <= e) {\\n            int mid = s + (e - s) / 2;\\n\\n            if (nums[mid] == target) {\\n                ansA = mid;\\n                s = mid + 1;\\n            } else if (nums[mid] > target) {\\n                e = mid - 1;\\n            } else {\\n                s = mid + 1;\\n            }\\n        }\\n        return ansA;\\n    }\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v(2);\\n        v[0] = firstOcr(nums, target);\\n        v[1] = LastOcr(nums, target);\\n\\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424638,
                "title": "binary-search-pure-c-beats-97",
                "content": "# Intuition\\nWhen searching for something in a sorted array a binary search is often the best tool to use. The requirement of O(logn) time complexity is also a big hint to this end.\\n\\n# Approach\\nThe solution will amount to a modified binary search to find the first occurrence of the target value, then a second binary search to find the last occurrence.\\n\\nInstead of stopping immediately when a target value is found, we have to determine whether that value is the starting occurrence or if its in the middle of a range of those values and adjust the range accordingly.\\n\\nOnce the first occurrence is found, we use that as the start of the range for the 2nd binary search where we look for the last occurrence.\\n\\n# Complexity\\n- Time complexity: $$O(logn)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* searchRange(int* nums, int numsSize, int target, int* returnSize){\\n    int start = 0;\\n    int mid;\\n    int end = numsSize;\\n\\n    /* initialize the return data structure */\\n    int *result = (int *)malloc(2*sizeof(int));\\n    result[0] = -1;\\n    result[1] = -1;\\n    *returnSize = 2;\\n\\n    /* don\\'t bother doing anything if numsSize is 0 */\\n    if (numsSize == 0) {\\n        return result;\\n    }\\n\\n    /* find the start index */\\n    while(start < end) {\\n        mid = (start + end) / 2;\\n        if (nums[mid] == target) {\\n            if (mid == 0 || nums[mid-1] != target) {\\n                result[0] = mid;\\n                break;\\n            }\\n            else {\\n                end = mid;\\n            }\\n        }\\n        else if (nums[mid] < target) {\\n            start = mid + 1;\\n        }\\n        else {\\n            end = mid;\\n        }\\n    }\\n\\n    /* if no start index found, return */\\n    if (result[0] == -1) {\\n        return result;\\n    }\\n\\n    /* find the end index */\\n    start = result[0];\\n    end = numsSize; \\n    while(start < end) {\\n        mid = (start + end) / 2;\\n        if (nums[mid] == target) {\\n            if (mid == (numsSize - 1) || nums[mid + 1] != target) {\\n                result[1] = mid;\\n                break;\\n            }\\n            else {\\n                start = mid + 1;\\n            }\\n        }\\n        else {\\n            end = mid;\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* searchRange(int* nums, int numsSize, int target, int* returnSize){\\n    int start = 0;\\n    int mid;\\n    int end = numsSize;\\n\\n    /* initialize the return data structure */\\n    int *result = (int *)malloc(2*sizeof(int));\\n    result[0] = -1;\\n    result[1] = -1;\\n    *returnSize = 2;\\n\\n    /* don\\'t bother doing anything if numsSize is 0 */\\n    if (numsSize == 0) {\\n        return result;\\n    }\\n\\n    /* find the start index */\\n    while(start < end) {\\n        mid = (start + end) / 2;\\n        if (nums[mid] == target) {\\n            if (mid == 0 || nums[mid-1] != target) {\\n                result[0] = mid;\\n                break;\\n            }\\n            else {\\n                end = mid;\\n            }\\n        }\\n        else if (nums[mid] < target) {\\n            start = mid + 1;\\n        }\\n        else {\\n            end = mid;\\n        }\\n    }\\n\\n    /* if no start index found, return */\\n    if (result[0] == -1) {\\n        return result;\\n    }\\n\\n    /* find the end index */\\n    start = result[0];\\n    end = numsSize; \\n    while(start < end) {\\n        mid = (start + end) / 2;\\n        if (nums[mid] == target) {\\n            if (mid == (numsSize - 1) || nums[mid + 1] != target) {\\n                result[1] = mid;\\n                break;\\n            }\\n            else {\\n                start = mid + 1;\\n            }\\n        }\\n        else {\\n            end = mid;\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3346340,
                "title": "java-easy-and-understandable-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int c=-1,d=-1;;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                c=i;\\n                break;\\n            }\\n        }\\n         for(int i=nums.length-1;i>=0;i--){\\n            if(nums[i]==target){\\n                d=i;\\n                break;\\n            }\\n        }\\n        int a[]=new int[2];\\n        for(int i=0;i<2-1;i++){\\n            a[i]=c;\\n            a[i+1]=d;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int c=-1,d=-1;;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                c=i;\\n                break;\\n            }\\n        }\\n         for(int i=nums.length-1;i>=0;i--){\\n            if(nums[i]==target){\\n                d=i;\\n                break;\\n            }\\n        }\\n        int a[]=new int[2];\\n        for(int i=0;i<2-1;i++){\\n            a[i]=c;\\n            a[i+1]=d;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318820,
                "title": "java-easy-binary-search-beats-100-binary-search-using-recursion",
                "content": "# Intuition\\nfor Binary Search through Recursion understanding purpose \\nBinary Search through recursion\\n\\n# Approach\\nBasically we have applied binary search \\n\\nfor 1st element we have to move from low towards high (left to right)\\nfor last element we have to move from high to log (right to left)\\n\\n* in first function our recursion calls will stat the lower bound \\n ie. start to mid because we want first element and it will be always found in lower bound \\nex -\\narr = 1 1 1 1 1\\nind = 0 1 2 3 4\\n\\nsearching dry run for start index -:\\n\\nmid = 0+4/2 = 2;\\n \\narr = 1 1 1\\nind = 0 1 2\\n_____________\\n\\nmid = 0+2/2 =1;\\n \\narr = 1 1\\nind = 0 1\\n_____________\\n\\nmid = 0+1/2 = 0;\\n\\narr = 1\\nind = 0\\n\\nreturn 0 that is first occurance\\n\\n* same goes for last index but change is we will call upper bound index first\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(log N)\\n\\n- Space complexity:\\nO(log N) == heap {else O(1)}\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int n = nums.length;\\n        start(nums,target,0,n-1);\\n        end(nums,target,0,n-1);\\n        int arr[] = new int[2];\\n        arr[0] =str;\\n        arr[1] =en;\\n        return arr;\\n    }\\n    int str =-1;\\n    public void start(int[] a , int t , int s , int e){\\n    if(s>e){\\n    return;\\n    }\\n\\n    int mid = (s+e)/2;\\n\\n    if(a[mid]==t)\\n    str =mid;\\n\\n    if(a[mid]>=t){\\n    start(a,t,s,mid-1);\\n    }\\n    else{\\n    start(a,t,mid+1,e);\\n        }\\n    }\\n    int en =-1;\\n    public void end(int[] a , int t , int s , int e){\\n        if(s>e){\\n        return;\\n        }\\n\\n        int mid = (s+e)/2;\\n\\n        if(a[mid]==t)\\n    en = mid;\\n\\n        if(a[mid]<=t){\\n            end(a,t,mid+1,e);\\n        }else{\\n            end(a,t,s,mid-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int n = nums.length;\\n        start(nums,target,0,n-1);\\n        end(nums,target,0,n-1);\\n        int arr[] = new int[2];\\n        arr[0] =str;\\n        arr[1] =en;\\n        return arr;\\n    }\\n    int str =-1;\\n    public void start(int[] a , int t , int s , int e){\\n    if(s>e){\\n    return;\\n    }\\n\\n    int mid = (s+e)/2;\\n\\n    if(a[mid]==t)\\n    str =mid;\\n\\n    if(a[mid]>=t){\\n    start(a,t,s,mid-1);\\n    }\\n    else{\\n    start(a,t,mid+1,e);\\n        }\\n    }\\n    int en =-1;\\n    public void end(int[] a , int t , int s , int e){\\n        if(s>e){\\n        return;\\n        }\\n\\n        int mid = (s+e)/2;\\n\\n        if(a[mid]==t)\\n    en = mid;\\n\\n        if(a[mid]<=t){\\n            end(a,t,mid+1,e);\\n        }else{\\n            end(a,t,s,mid-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240778,
                "title": "c-brute-force-o-n-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int start = -1 ; \\n        int end = -1 ; \\n        int n = nums.size() ; \\n        for (int i = 0 ; i < n ; i ++)\\n        {\\n            if (nums[i] == target)\\n            {\\n                start = i ; \\n                break ; \\n            }\\n        }\\n\\n        for (int i = n - 1 ; i >= 0 ; i --)\\n        {\\n            if (nums[i] == target)\\n            {\\n                end = i ; \\n                break ;\\n            }\\n        }\\n        vector<int> ans ; \\n        ans = {start , end} ; \\n        return ans ; \\n    } \\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/fabf8b98-b984-4510-b551-a6b972c155b5_1677603180.1534393.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int start = -1 ; \\n        int end = -1 ; \\n        int n = nums.size() ; \\n        for (int i = 0 ; i < n ; i ++)\\n        {\\n            if (nums[i] == target)\\n            {\\n                start = i ; \\n                break ; \\n            }\\n        }\\n\\n        for (int i = n - 1 ; i >= 0 ; i --)\\n        {\\n            if (nums[i] == target)\\n            {\\n                end = i ; \\n                break ;\\n            }\\n        }\\n        vector<int> ans ; \\n        ans = {start , end} ; \\n        return ans ; \\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222767,
                "title": "simple-solution-in-three-lines",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        if target in nums:\\n            return[nums.index(target),len(nums)-nums[::-1].index(target)-1]\\n        else: return [-1,-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        if target in nums:\\n            return[nums.index(target),len(nums)-nums[::-1].index(target)-1]\\n        else: return [-1,-1]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565827,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1763959,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1576241,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1708352,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1969648,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1569572,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1859759,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1692595,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1866946,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1576517,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1565827,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1763959,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1576241,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1708352,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1969648,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1569572,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1859759,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1692595,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1866946,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1576517,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1724737,
                "content": [
                    {
                        "username": "kbn456",
                        "content": "Description says we should write solution in O(log n) but how come tests are passed with O(n/2) or little greater then O(log n) complexity solutions ?"
                    },
                    {
                        "username": "dattran1232003",
                        "content": "Can\\'t. O(log n) & O(n/2) have much difference when the length of array is 1.000.000.000 elements"
                    },
                    {
                        "username": "AGPCR7",
                        "content": "var searchRange = function(nums, target) {\\n return [nums.indexOf(target),nums.lastIndexOf(target)]\\n};"
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Sir it should be binary search algorithm "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Approach:\\nFor this particular solution we solve the problem with Binary search. The first step will be to find the target number (be it in any index) and store its location in a variable called temp. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector ans and the final positions are returned.\\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned.\\n\\nFor Code, Refer to my blog link:\\nhttps://dsafordummies.digitalpress.blog/binary-search-leetcode-series-2/\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "Saswat_Sharma",
                        "content": "Just try to use simple binary search to find out the ceiling value and floor value of the target."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "siddharth133",
                        "content": "Can anyone check what is wrong with my code it is giving me TLE even in the test cases ????\\nI ma using simple binary search approach\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> result(2,-1);\\n        int left = 0;\\n        int right = nums.size()-1;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                if(result[0] != -1){\\n                    result[1] = mid;\\n                }\\n                else{\\n                result[0] = mid;\\n                }\\n\\n            }\\n            else if(nums[mid] > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        if(result[1] == -1 && result[0] != -1){\\n            result[1] = result[0];\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "abhiHegde28",
                        "content": "class Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        s = 0\\n        e = len(nums) - 1\\n\\n        while(s <= e):\\n            mid = (s+e) // 2 \\n            if(target < nums[mid]):\\n                e = mid - 1 \\n            elif(target > nums[mid]):\\n                s = mid+1\\n            elif(target == nums[mid]):\\n                if(nums[mid] == nums[mid - 1]):\\n                    return [mid-1 , mid]\\n                elif(nums[mid] == nums[mid + 1]):\\n                    return [mid , mid+1]\\n                else:\\n                    return [mid , mid]\\n        return [-1,-1]\\n\\n        this was my solution but i am getting an error can somebody pls help why i am getting error?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "try using two binary searches with two while loops, but before second while loop write s = 0, e = len(nums) - 1"
                    },
                    {
                        "username": "paink1ller",
                        "content": "I think this is too easy to be medium problem imho"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "For GigaChads like us every problem is easy "
                    },
                    {
                        "username": "dasrakesh",
                        "content": "This is a facebook interview question"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Not getting how to do  O(logn) will leetcode accept me :-("
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i want to try something different :-)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, bro if you know what is binary search you can use it, this algorithm runs at O(logn), hope this answers your guestion"
                    },
                    {
                        "username": "bakdominik",
                        "content": "why Im getting \"Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\" error whenever trying to get nums[i] value? \\n\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "These might be problems:\\n\\nUninitialized Vector: If you\\'re using a std::vector and haven\\'t properly initialized it before accessing its elements, it could lead to a null pointer reference.\\n\\nOut of Bounds Access: If the value of i is outside the valid range of indices for the vector nums, you might end up trying to access an element that doesn\\'t exist, causing undefined behavior.\\n\\nPointer Instead of Vector: If nums is declared as a pointer to a vector (std::vector<int>* nums) and not properly assigned to an actual vector object, then accessing nums[i] could result in a null pointer reference."
                    }
                ]
            },
            {
                "id": 1575113,
                "content": [
                    {
                        "username": "kbn456",
                        "content": "Description says we should write solution in O(log n) but how come tests are passed with O(n/2) or little greater then O(log n) complexity solutions ?"
                    },
                    {
                        "username": "dattran1232003",
                        "content": "Can\\'t. O(log n) & O(n/2) have much difference when the length of array is 1.000.000.000 elements"
                    },
                    {
                        "username": "AGPCR7",
                        "content": "var searchRange = function(nums, target) {\\n return [nums.indexOf(target),nums.lastIndexOf(target)]\\n};"
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Sir it should be binary search algorithm "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Approach:\\nFor this particular solution we solve the problem with Binary search. The first step will be to find the target number (be it in any index) and store its location in a variable called temp. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector ans and the final positions are returned.\\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned.\\n\\nFor Code, Refer to my blog link:\\nhttps://dsafordummies.digitalpress.blog/binary-search-leetcode-series-2/\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "Saswat_Sharma",
                        "content": "Just try to use simple binary search to find out the ceiling value and floor value of the target."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "siddharth133",
                        "content": "Can anyone check what is wrong with my code it is giving me TLE even in the test cases ????\\nI ma using simple binary search approach\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> result(2,-1);\\n        int left = 0;\\n        int right = nums.size()-1;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                if(result[0] != -1){\\n                    result[1] = mid;\\n                }\\n                else{\\n                result[0] = mid;\\n                }\\n\\n            }\\n            else if(nums[mid] > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        if(result[1] == -1 && result[0] != -1){\\n            result[1] = result[0];\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "abhiHegde28",
                        "content": "class Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        s = 0\\n        e = len(nums) - 1\\n\\n        while(s <= e):\\n            mid = (s+e) // 2 \\n            if(target < nums[mid]):\\n                e = mid - 1 \\n            elif(target > nums[mid]):\\n                s = mid+1\\n            elif(target == nums[mid]):\\n                if(nums[mid] == nums[mid - 1]):\\n                    return [mid-1 , mid]\\n                elif(nums[mid] == nums[mid + 1]):\\n                    return [mid , mid+1]\\n                else:\\n                    return [mid , mid]\\n        return [-1,-1]\\n\\n        this was my solution but i am getting an error can somebody pls help why i am getting error?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "try using two binary searches with two while loops, but before second while loop write s = 0, e = len(nums) - 1"
                    },
                    {
                        "username": "paink1ller",
                        "content": "I think this is too easy to be medium problem imho"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "For GigaChads like us every problem is easy "
                    },
                    {
                        "username": "dasrakesh",
                        "content": "This is a facebook interview question"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Not getting how to do  O(logn) will leetcode accept me :-("
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i want to try something different :-)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, bro if you know what is binary search you can use it, this algorithm runs at O(logn), hope this answers your guestion"
                    },
                    {
                        "username": "bakdominik",
                        "content": "why Im getting \"Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\" error whenever trying to get nums[i] value? \\n\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "These might be problems:\\n\\nUninitialized Vector: If you\\'re using a std::vector and haven\\'t properly initialized it before accessing its elements, it could lead to a null pointer reference.\\n\\nOut of Bounds Access: If the value of i is outside the valid range of indices for the vector nums, you might end up trying to access an element that doesn\\'t exist, causing undefined behavior.\\n\\nPointer Instead of Vector: If nums is declared as a pointer to a vector (std::vector<int>* nums) and not properly assigned to an actual vector object, then accessing nums[i] could result in a null pointer reference."
                    }
                ]
            },
            {
                "id": 2066577,
                "content": [
                    {
                        "username": "kbn456",
                        "content": "Description says we should write solution in O(log n) but how come tests are passed with O(n/2) or little greater then O(log n) complexity solutions ?"
                    },
                    {
                        "username": "dattran1232003",
                        "content": "Can\\'t. O(log n) & O(n/2) have much difference when the length of array is 1.000.000.000 elements"
                    },
                    {
                        "username": "AGPCR7",
                        "content": "var searchRange = function(nums, target) {\\n return [nums.indexOf(target),nums.lastIndexOf(target)]\\n};"
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Sir it should be binary search algorithm "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Approach:\\nFor this particular solution we solve the problem with Binary search. The first step will be to find the target number (be it in any index) and store its location in a variable called temp. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector ans and the final positions are returned.\\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned.\\n\\nFor Code, Refer to my blog link:\\nhttps://dsafordummies.digitalpress.blog/binary-search-leetcode-series-2/\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "Saswat_Sharma",
                        "content": "Just try to use simple binary search to find out the ceiling value and floor value of the target."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "siddharth133",
                        "content": "Can anyone check what is wrong with my code it is giving me TLE even in the test cases ????\\nI ma using simple binary search approach\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> result(2,-1);\\n        int left = 0;\\n        int right = nums.size()-1;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                if(result[0] != -1){\\n                    result[1] = mid;\\n                }\\n                else{\\n                result[0] = mid;\\n                }\\n\\n            }\\n            else if(nums[mid] > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        if(result[1] == -1 && result[0] != -1){\\n            result[1] = result[0];\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "abhiHegde28",
                        "content": "class Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        s = 0\\n        e = len(nums) - 1\\n\\n        while(s <= e):\\n            mid = (s+e) // 2 \\n            if(target < nums[mid]):\\n                e = mid - 1 \\n            elif(target > nums[mid]):\\n                s = mid+1\\n            elif(target == nums[mid]):\\n                if(nums[mid] == nums[mid - 1]):\\n                    return [mid-1 , mid]\\n                elif(nums[mid] == nums[mid + 1]):\\n                    return [mid , mid+1]\\n                else:\\n                    return [mid , mid]\\n        return [-1,-1]\\n\\n        this was my solution but i am getting an error can somebody pls help why i am getting error?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "try using two binary searches with two while loops, but before second while loop write s = 0, e = len(nums) - 1"
                    },
                    {
                        "username": "paink1ller",
                        "content": "I think this is too easy to be medium problem imho"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "For GigaChads like us every problem is easy "
                    },
                    {
                        "username": "dasrakesh",
                        "content": "This is a facebook interview question"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Not getting how to do  O(logn) will leetcode accept me :-("
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i want to try something different :-)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, bro if you know what is binary search you can use it, this algorithm runs at O(logn), hope this answers your guestion"
                    },
                    {
                        "username": "bakdominik",
                        "content": "why Im getting \"Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\" error whenever trying to get nums[i] value? \\n\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "These might be problems:\\n\\nUninitialized Vector: If you\\'re using a std::vector and haven\\'t properly initialized it before accessing its elements, it could lead to a null pointer reference.\\n\\nOut of Bounds Access: If the value of i is outside the valid range of indices for the vector nums, you might end up trying to access an element that doesn\\'t exist, causing undefined behavior.\\n\\nPointer Instead of Vector: If nums is declared as a pointer to a vector (std::vector<int>* nums) and not properly assigned to an actual vector object, then accessing nums[i] could result in a null pointer reference."
                    }
                ]
            },
            {
                "id": 2066081,
                "content": [
                    {
                        "username": "kbn456",
                        "content": "Description says we should write solution in O(log n) but how come tests are passed with O(n/2) or little greater then O(log n) complexity solutions ?"
                    },
                    {
                        "username": "dattran1232003",
                        "content": "Can\\'t. O(log n) & O(n/2) have much difference when the length of array is 1.000.000.000 elements"
                    },
                    {
                        "username": "AGPCR7",
                        "content": "var searchRange = function(nums, target) {\\n return [nums.indexOf(target),nums.lastIndexOf(target)]\\n};"
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Sir it should be binary search algorithm "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Approach:\\nFor this particular solution we solve the problem with Binary search. The first step will be to find the target number (be it in any index) and store its location in a variable called temp. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector ans and the final positions are returned.\\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned.\\n\\nFor Code, Refer to my blog link:\\nhttps://dsafordummies.digitalpress.blog/binary-search-leetcode-series-2/\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "Saswat_Sharma",
                        "content": "Just try to use simple binary search to find out the ceiling value and floor value of the target."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "siddharth133",
                        "content": "Can anyone check what is wrong with my code it is giving me TLE even in the test cases ????\\nI ma using simple binary search approach\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> result(2,-1);\\n        int left = 0;\\n        int right = nums.size()-1;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                if(result[0] != -1){\\n                    result[1] = mid;\\n                }\\n                else{\\n                result[0] = mid;\\n                }\\n\\n            }\\n            else if(nums[mid] > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        if(result[1] == -1 && result[0] != -1){\\n            result[1] = result[0];\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "abhiHegde28",
                        "content": "class Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        s = 0\\n        e = len(nums) - 1\\n\\n        while(s <= e):\\n            mid = (s+e) // 2 \\n            if(target < nums[mid]):\\n                e = mid - 1 \\n            elif(target > nums[mid]):\\n                s = mid+1\\n            elif(target == nums[mid]):\\n                if(nums[mid] == nums[mid - 1]):\\n                    return [mid-1 , mid]\\n                elif(nums[mid] == nums[mid + 1]):\\n                    return [mid , mid+1]\\n                else:\\n                    return [mid , mid]\\n        return [-1,-1]\\n\\n        this was my solution but i am getting an error can somebody pls help why i am getting error?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "try using two binary searches with two while loops, but before second while loop write s = 0, e = len(nums) - 1"
                    },
                    {
                        "username": "paink1ller",
                        "content": "I think this is too easy to be medium problem imho"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "For GigaChads like us every problem is easy "
                    },
                    {
                        "username": "dasrakesh",
                        "content": "This is a facebook interview question"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Not getting how to do  O(logn) will leetcode accept me :-("
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i want to try something different :-)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, bro if you know what is binary search you can use it, this algorithm runs at O(logn), hope this answers your guestion"
                    },
                    {
                        "username": "bakdominik",
                        "content": "why Im getting \"Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\" error whenever trying to get nums[i] value? \\n\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "These might be problems:\\n\\nUninitialized Vector: If you\\'re using a std::vector and haven\\'t properly initialized it before accessing its elements, it could lead to a null pointer reference.\\n\\nOut of Bounds Access: If the value of i is outside the valid range of indices for the vector nums, you might end up trying to access an element that doesn\\'t exist, causing undefined behavior.\\n\\nPointer Instead of Vector: If nums is declared as a pointer to a vector (std::vector<int>* nums) and not properly assigned to an actual vector object, then accessing nums[i] could result in a null pointer reference."
                    }
                ]
            },
            {
                "id": 2065499,
                "content": [
                    {
                        "username": "kbn456",
                        "content": "Description says we should write solution in O(log n) but how come tests are passed with O(n/2) or little greater then O(log n) complexity solutions ?"
                    },
                    {
                        "username": "dattran1232003",
                        "content": "Can\\'t. O(log n) & O(n/2) have much difference when the length of array is 1.000.000.000 elements"
                    },
                    {
                        "username": "AGPCR7",
                        "content": "var searchRange = function(nums, target) {\\n return [nums.indexOf(target),nums.lastIndexOf(target)]\\n};"
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Sir it should be binary search algorithm "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Approach:\\nFor this particular solution we solve the problem with Binary search. The first step will be to find the target number (be it in any index) and store its location in a variable called temp. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector ans and the final positions are returned.\\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned.\\n\\nFor Code, Refer to my blog link:\\nhttps://dsafordummies.digitalpress.blog/binary-search-leetcode-series-2/\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "Saswat_Sharma",
                        "content": "Just try to use simple binary search to find out the ceiling value and floor value of the target."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "siddharth133",
                        "content": "Can anyone check what is wrong with my code it is giving me TLE even in the test cases ????\\nI ma using simple binary search approach\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> result(2,-1);\\n        int left = 0;\\n        int right = nums.size()-1;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                if(result[0] != -1){\\n                    result[1] = mid;\\n                }\\n                else{\\n                result[0] = mid;\\n                }\\n\\n            }\\n            else if(nums[mid] > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        if(result[1] == -1 && result[0] != -1){\\n            result[1] = result[0];\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "abhiHegde28",
                        "content": "class Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        s = 0\\n        e = len(nums) - 1\\n\\n        while(s <= e):\\n            mid = (s+e) // 2 \\n            if(target < nums[mid]):\\n                e = mid - 1 \\n            elif(target > nums[mid]):\\n                s = mid+1\\n            elif(target == nums[mid]):\\n                if(nums[mid] == nums[mid - 1]):\\n                    return [mid-1 , mid]\\n                elif(nums[mid] == nums[mid + 1]):\\n                    return [mid , mid+1]\\n                else:\\n                    return [mid , mid]\\n        return [-1,-1]\\n\\n        this was my solution but i am getting an error can somebody pls help why i am getting error?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "try using two binary searches with two while loops, but before second while loop write s = 0, e = len(nums) - 1"
                    },
                    {
                        "username": "paink1ller",
                        "content": "I think this is too easy to be medium problem imho"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "For GigaChads like us every problem is easy "
                    },
                    {
                        "username": "dasrakesh",
                        "content": "This is a facebook interview question"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Not getting how to do  O(logn) will leetcode accept me :-("
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i want to try something different :-)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, bro if you know what is binary search you can use it, this algorithm runs at O(logn), hope this answers your guestion"
                    },
                    {
                        "username": "bakdominik",
                        "content": "why Im getting \"Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\" error whenever trying to get nums[i] value? \\n\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "These might be problems:\\n\\nUninitialized Vector: If you\\'re using a std::vector and haven\\'t properly initialized it before accessing its elements, it could lead to a null pointer reference.\\n\\nOut of Bounds Access: If the value of i is outside the valid range of indices for the vector nums, you might end up trying to access an element that doesn\\'t exist, causing undefined behavior.\\n\\nPointer Instead of Vector: If nums is declared as a pointer to a vector (std::vector<int>* nums) and not properly assigned to an actual vector object, then accessing nums[i] could result in a null pointer reference."
                    }
                ]
            },
            {
                "id": 2051913,
                "content": [
                    {
                        "username": "kbn456",
                        "content": "Description says we should write solution in O(log n) but how come tests are passed with O(n/2) or little greater then O(log n) complexity solutions ?"
                    },
                    {
                        "username": "dattran1232003",
                        "content": "Can\\'t. O(log n) & O(n/2) have much difference when the length of array is 1.000.000.000 elements"
                    },
                    {
                        "username": "AGPCR7",
                        "content": "var searchRange = function(nums, target) {\\n return [nums.indexOf(target),nums.lastIndexOf(target)]\\n};"
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Sir it should be binary search algorithm "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Approach:\\nFor this particular solution we solve the problem with Binary search. The first step will be to find the target number (be it in any index) and store its location in a variable called temp. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector ans and the final positions are returned.\\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned.\\n\\nFor Code, Refer to my blog link:\\nhttps://dsafordummies.digitalpress.blog/binary-search-leetcode-series-2/\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "Saswat_Sharma",
                        "content": "Just try to use simple binary search to find out the ceiling value and floor value of the target."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "siddharth133",
                        "content": "Can anyone check what is wrong with my code it is giving me TLE even in the test cases ????\\nI ma using simple binary search approach\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> result(2,-1);\\n        int left = 0;\\n        int right = nums.size()-1;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                if(result[0] != -1){\\n                    result[1] = mid;\\n                }\\n                else{\\n                result[0] = mid;\\n                }\\n\\n            }\\n            else if(nums[mid] > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        if(result[1] == -1 && result[0] != -1){\\n            result[1] = result[0];\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "abhiHegde28",
                        "content": "class Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        s = 0\\n        e = len(nums) - 1\\n\\n        while(s <= e):\\n            mid = (s+e) // 2 \\n            if(target < nums[mid]):\\n                e = mid - 1 \\n            elif(target > nums[mid]):\\n                s = mid+1\\n            elif(target == nums[mid]):\\n                if(nums[mid] == nums[mid - 1]):\\n                    return [mid-1 , mid]\\n                elif(nums[mid] == nums[mid + 1]):\\n                    return [mid , mid+1]\\n                else:\\n                    return [mid , mid]\\n        return [-1,-1]\\n\\n        this was my solution but i am getting an error can somebody pls help why i am getting error?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "try using two binary searches with two while loops, but before second while loop write s = 0, e = len(nums) - 1"
                    },
                    {
                        "username": "paink1ller",
                        "content": "I think this is too easy to be medium problem imho"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "For GigaChads like us every problem is easy "
                    },
                    {
                        "username": "dasrakesh",
                        "content": "This is a facebook interview question"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Not getting how to do  O(logn) will leetcode accept me :-("
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i want to try something different :-)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, bro if you know what is binary search you can use it, this algorithm runs at O(logn), hope this answers your guestion"
                    },
                    {
                        "username": "bakdominik",
                        "content": "why Im getting \"Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\" error whenever trying to get nums[i] value? \\n\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "These might be problems:\\n\\nUninitialized Vector: If you\\'re using a std::vector and haven\\'t properly initialized it before accessing its elements, it could lead to a null pointer reference.\\n\\nOut of Bounds Access: If the value of i is outside the valid range of indices for the vector nums, you might end up trying to access an element that doesn\\'t exist, causing undefined behavior.\\n\\nPointer Instead of Vector: If nums is declared as a pointer to a vector (std::vector<int>* nums) and not properly assigned to an actual vector object, then accessing nums[i] could result in a null pointer reference."
                    }
                ]
            },
            {
                "id": 2049667,
                "content": [
                    {
                        "username": "kbn456",
                        "content": "Description says we should write solution in O(log n) but how come tests are passed with O(n/2) or little greater then O(log n) complexity solutions ?"
                    },
                    {
                        "username": "dattran1232003",
                        "content": "Can\\'t. O(log n) & O(n/2) have much difference when the length of array is 1.000.000.000 elements"
                    },
                    {
                        "username": "AGPCR7",
                        "content": "var searchRange = function(nums, target) {\\n return [nums.indexOf(target),nums.lastIndexOf(target)]\\n};"
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Sir it should be binary search algorithm "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Approach:\\nFor this particular solution we solve the problem with Binary search. The first step will be to find the target number (be it in any index) and store its location in a variable called temp. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector ans and the final positions are returned.\\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned.\\n\\nFor Code, Refer to my blog link:\\nhttps://dsafordummies.digitalpress.blog/binary-search-leetcode-series-2/\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "Saswat_Sharma",
                        "content": "Just try to use simple binary search to find out the ceiling value and floor value of the target."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "siddharth133",
                        "content": "Can anyone check what is wrong with my code it is giving me TLE even in the test cases ????\\nI ma using simple binary search approach\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> result(2,-1);\\n        int left = 0;\\n        int right = nums.size()-1;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                if(result[0] != -1){\\n                    result[1] = mid;\\n                }\\n                else{\\n                result[0] = mid;\\n                }\\n\\n            }\\n            else if(nums[mid] > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        if(result[1] == -1 && result[0] != -1){\\n            result[1] = result[0];\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "abhiHegde28",
                        "content": "class Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        s = 0\\n        e = len(nums) - 1\\n\\n        while(s <= e):\\n            mid = (s+e) // 2 \\n            if(target < nums[mid]):\\n                e = mid - 1 \\n            elif(target > nums[mid]):\\n                s = mid+1\\n            elif(target == nums[mid]):\\n                if(nums[mid] == nums[mid - 1]):\\n                    return [mid-1 , mid]\\n                elif(nums[mid] == nums[mid + 1]):\\n                    return [mid , mid+1]\\n                else:\\n                    return [mid , mid]\\n        return [-1,-1]\\n\\n        this was my solution but i am getting an error can somebody pls help why i am getting error?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "try using two binary searches with two while loops, but before second while loop write s = 0, e = len(nums) - 1"
                    },
                    {
                        "username": "paink1ller",
                        "content": "I think this is too easy to be medium problem imho"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "For GigaChads like us every problem is easy "
                    },
                    {
                        "username": "dasrakesh",
                        "content": "This is a facebook interview question"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Not getting how to do  O(logn) will leetcode accept me :-("
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i want to try something different :-)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, bro if you know what is binary search you can use it, this algorithm runs at O(logn), hope this answers your guestion"
                    },
                    {
                        "username": "bakdominik",
                        "content": "why Im getting \"Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\" error whenever trying to get nums[i] value? \\n\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "These might be problems:\\n\\nUninitialized Vector: If you\\'re using a std::vector and haven\\'t properly initialized it before accessing its elements, it could lead to a null pointer reference.\\n\\nOut of Bounds Access: If the value of i is outside the valid range of indices for the vector nums, you might end up trying to access an element that doesn\\'t exist, causing undefined behavior.\\n\\nPointer Instead of Vector: If nums is declared as a pointer to a vector (std::vector<int>* nums) and not properly assigned to an actual vector object, then accessing nums[i] could result in a null pointer reference."
                    }
                ]
            },
            {
                "id": 2048936,
                "content": [
                    {
                        "username": "kbn456",
                        "content": "Description says we should write solution in O(log n) but how come tests are passed with O(n/2) or little greater then O(log n) complexity solutions ?"
                    },
                    {
                        "username": "dattran1232003",
                        "content": "Can\\'t. O(log n) & O(n/2) have much difference when the length of array is 1.000.000.000 elements"
                    },
                    {
                        "username": "AGPCR7",
                        "content": "var searchRange = function(nums, target) {\\n return [nums.indexOf(target),nums.lastIndexOf(target)]\\n};"
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Sir it should be binary search algorithm "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Approach:\\nFor this particular solution we solve the problem with Binary search. The first step will be to find the target number (be it in any index) and store its location in a variable called temp. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector ans and the final positions are returned.\\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned.\\n\\nFor Code, Refer to my blog link:\\nhttps://dsafordummies.digitalpress.blog/binary-search-leetcode-series-2/\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "Saswat_Sharma",
                        "content": "Just try to use simple binary search to find out the ceiling value and floor value of the target."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "siddharth133",
                        "content": "Can anyone check what is wrong with my code it is giving me TLE even in the test cases ????\\nI ma using simple binary search approach\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> result(2,-1);\\n        int left = 0;\\n        int right = nums.size()-1;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                if(result[0] != -1){\\n                    result[1] = mid;\\n                }\\n                else{\\n                result[0] = mid;\\n                }\\n\\n            }\\n            else if(nums[mid] > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        if(result[1] == -1 && result[0] != -1){\\n            result[1] = result[0];\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "abhiHegde28",
                        "content": "class Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        s = 0\\n        e = len(nums) - 1\\n\\n        while(s <= e):\\n            mid = (s+e) // 2 \\n            if(target < nums[mid]):\\n                e = mid - 1 \\n            elif(target > nums[mid]):\\n                s = mid+1\\n            elif(target == nums[mid]):\\n                if(nums[mid] == nums[mid - 1]):\\n                    return [mid-1 , mid]\\n                elif(nums[mid] == nums[mid + 1]):\\n                    return [mid , mid+1]\\n                else:\\n                    return [mid , mid]\\n        return [-1,-1]\\n\\n        this was my solution but i am getting an error can somebody pls help why i am getting error?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "try using two binary searches with two while loops, but before second while loop write s = 0, e = len(nums) - 1"
                    },
                    {
                        "username": "paink1ller",
                        "content": "I think this is too easy to be medium problem imho"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "For GigaChads like us every problem is easy "
                    },
                    {
                        "username": "dasrakesh",
                        "content": "This is a facebook interview question"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Not getting how to do  O(logn) will leetcode accept me :-("
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i want to try something different :-)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, bro if you know what is binary search you can use it, this algorithm runs at O(logn), hope this answers your guestion"
                    },
                    {
                        "username": "bakdominik",
                        "content": "why Im getting \"Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\" error whenever trying to get nums[i] value? \\n\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "These might be problems:\\n\\nUninitialized Vector: If you\\'re using a std::vector and haven\\'t properly initialized it before accessing its elements, it could lead to a null pointer reference.\\n\\nOut of Bounds Access: If the value of i is outside the valid range of indices for the vector nums, you might end up trying to access an element that doesn\\'t exist, causing undefined behavior.\\n\\nPointer Instead of Vector: If nums is declared as a pointer to a vector (std::vector<int>* nums) and not properly assigned to an actual vector object, then accessing nums[i] could result in a null pointer reference."
                    }
                ]
            },
            {
                "id": 2039494,
                "content": [
                    {
                        "username": "kbn456",
                        "content": "Description says we should write solution in O(log n) but how come tests are passed with O(n/2) or little greater then O(log n) complexity solutions ?"
                    },
                    {
                        "username": "dattran1232003",
                        "content": "Can\\'t. O(log n) & O(n/2) have much difference when the length of array is 1.000.000.000 elements"
                    },
                    {
                        "username": "AGPCR7",
                        "content": "var searchRange = function(nums, target) {\\n return [nums.indexOf(target),nums.lastIndexOf(target)]\\n};"
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Sir it should be binary search algorithm "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Approach:\\nFor this particular solution we solve the problem with Binary search. The first step will be to find the target number (be it in any index) and store its location in a variable called temp. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector ans and the final positions are returned.\\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned.\\n\\nFor Code, Refer to my blog link:\\nhttps://dsafordummies.digitalpress.blog/binary-search-leetcode-series-2/\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "Saswat_Sharma",
                        "content": "Just try to use simple binary search to find out the ceiling value and floor value of the target."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "siddharth133",
                        "content": "Can anyone check what is wrong with my code it is giving me TLE even in the test cases ????\\nI ma using simple binary search approach\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> result(2,-1);\\n        int left = 0;\\n        int right = nums.size()-1;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                if(result[0] != -1){\\n                    result[1] = mid;\\n                }\\n                else{\\n                result[0] = mid;\\n                }\\n\\n            }\\n            else if(nums[mid] > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        if(result[1] == -1 && result[0] != -1){\\n            result[1] = result[0];\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "abhiHegde28",
                        "content": "class Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        s = 0\\n        e = len(nums) - 1\\n\\n        while(s <= e):\\n            mid = (s+e) // 2 \\n            if(target < nums[mid]):\\n                e = mid - 1 \\n            elif(target > nums[mid]):\\n                s = mid+1\\n            elif(target == nums[mid]):\\n                if(nums[mid] == nums[mid - 1]):\\n                    return [mid-1 , mid]\\n                elif(nums[mid] == nums[mid + 1]):\\n                    return [mid , mid+1]\\n                else:\\n                    return [mid , mid]\\n        return [-1,-1]\\n\\n        this was my solution but i am getting an error can somebody pls help why i am getting error?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "try using two binary searches with two while loops, but before second while loop write s = 0, e = len(nums) - 1"
                    },
                    {
                        "username": "paink1ller",
                        "content": "I think this is too easy to be medium problem imho"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "For GigaChads like us every problem is easy "
                    },
                    {
                        "username": "dasrakesh",
                        "content": "This is a facebook interview question"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Not getting how to do  O(logn) will leetcode accept me :-("
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i want to try something different :-)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, bro if you know what is binary search you can use it, this algorithm runs at O(logn), hope this answers your guestion"
                    },
                    {
                        "username": "bakdominik",
                        "content": "why Im getting \"Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\" error whenever trying to get nums[i] value? \\n\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "These might be problems:\\n\\nUninitialized Vector: If you\\'re using a std::vector and haven\\'t properly initialized it before accessing its elements, it could lead to a null pointer reference.\\n\\nOut of Bounds Access: If the value of i is outside the valid range of indices for the vector nums, you might end up trying to access an element that doesn\\'t exist, causing undefined behavior.\\n\\nPointer Instead of Vector: If nums is declared as a pointer to a vector (std::vector<int>* nums) and not properly assigned to an actual vector object, then accessing nums[i] could result in a null pointer reference."
                    }
                ]
            },
            {
                "id": 2036050,
                "content": [
                    {
                        "username": "kbn456",
                        "content": "Description says we should write solution in O(log n) but how come tests are passed with O(n/2) or little greater then O(log n) complexity solutions ?"
                    },
                    {
                        "username": "dattran1232003",
                        "content": "Can\\'t. O(log n) & O(n/2) have much difference when the length of array is 1.000.000.000 elements"
                    },
                    {
                        "username": "AGPCR7",
                        "content": "var searchRange = function(nums, target) {\\n return [nums.indexOf(target),nums.lastIndexOf(target)]\\n};"
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Sir it should be binary search algorithm "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Approach:\\nFor this particular solution we solve the problem with Binary search. The first step will be to find the target number (be it in any index) and store its location in a variable called temp. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector ans and the final positions are returned.\\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned.\\n\\nFor Code, Refer to my blog link:\\nhttps://dsafordummies.digitalpress.blog/binary-search-leetcode-series-2/\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "Saswat_Sharma",
                        "content": "Just try to use simple binary search to find out the ceiling value and floor value of the target."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "siddharth133",
                        "content": "Can anyone check what is wrong with my code it is giving me TLE even in the test cases ????\\nI ma using simple binary search approach\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> result(2,-1);\\n        int left = 0;\\n        int right = nums.size()-1;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                if(result[0] != -1){\\n                    result[1] = mid;\\n                }\\n                else{\\n                result[0] = mid;\\n                }\\n\\n            }\\n            else if(nums[mid] > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        if(result[1] == -1 && result[0] != -1){\\n            result[1] = result[0];\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "abhiHegde28",
                        "content": "class Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        s = 0\\n        e = len(nums) - 1\\n\\n        while(s <= e):\\n            mid = (s+e) // 2 \\n            if(target < nums[mid]):\\n                e = mid - 1 \\n            elif(target > nums[mid]):\\n                s = mid+1\\n            elif(target == nums[mid]):\\n                if(nums[mid] == nums[mid - 1]):\\n                    return [mid-1 , mid]\\n                elif(nums[mid] == nums[mid + 1]):\\n                    return [mid , mid+1]\\n                else:\\n                    return [mid , mid]\\n        return [-1,-1]\\n\\n        this was my solution but i am getting an error can somebody pls help why i am getting error?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "try using two binary searches with two while loops, but before second while loop write s = 0, e = len(nums) - 1"
                    },
                    {
                        "username": "paink1ller",
                        "content": "I think this is too easy to be medium problem imho"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "For GigaChads like us every problem is easy "
                    },
                    {
                        "username": "dasrakesh",
                        "content": "This is a facebook interview question"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Not getting how to do  O(logn) will leetcode accept me :-("
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i want to try something different :-)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, bro if you know what is binary search you can use it, this algorithm runs at O(logn), hope this answers your guestion"
                    },
                    {
                        "username": "bakdominik",
                        "content": "why Im getting \"Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\" error whenever trying to get nums[i] value? \\n\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "These might be problems:\\n\\nUninitialized Vector: If you\\'re using a std::vector and haven\\'t properly initialized it before accessing its elements, it could lead to a null pointer reference.\\n\\nOut of Bounds Access: If the value of i is outside the valid range of indices for the vector nums, you might end up trying to access an element that doesn\\'t exist, causing undefined behavior.\\n\\nPointer Instead of Vector: If nums is declared as a pointer to a vector (std::vector<int>* nums) and not properly assigned to an actual vector object, then accessing nums[i] could result in a null pointer reference."
                    }
                ]
            },
            {
                "id": 2016101,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "break into two pieces(lower bound and upper bound)  :P"
                    },
                    {
                        "username": "eduard92",
                        "content": "Going for 3 days binary search haul, I think I am gonna dream mid formula and while loop"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I love this question"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "So I used one binary search to find the target, and after finding that target then I use another two binary search within it to find the start and end of the target.\n\nSo does the time complexity of that still be O(log n) or something else? Even though it took 0ms but I'm still confused.\n\nThanks :D"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "[@shubhi4](/shubhi4)  as she said  same for the last target also"
                    },
                    {
                        "username": "shubhi4",
                        "content": "yes it will be O(logn) . But you dont need to find the target. you can just search for the minimum index of target first, if not found that means the target is not present in the array."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "I have a gut feel that Template III doesn\\'t really fit the range search. Yes, to find a range in a collection you need to check next and previous elements for finish and start. But in order to find both start and finish you will have to use binary search template III twice - for a start and then for a finish, which makes it no better than using any other templates.\\n\\nIf anyone knows a way to search for both start and finish while using template III, please share."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Getting TLE . Used Binary Search. What\\'s the problem??\\n\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.length-1;\\n        int[] ans = {-1, -1};\\n        int mid = low + high/2 - low/2;\\n\\n        while(low <= high){\\n\\n            mid = low + high/2 - low/2;\\n            if(nums[mid] < target) mid = low+1;\\n            else if(nums[mid] > target) mid = high-1;\\n            else break;\\n        }\\n        if(low > high) return ans;\\n\\n        int lowerbound = mid-1;\\n        int upperbound = mid+1;\\n        \\n        \\n        while(low <= lowerbound){\\n            int middle = low/2 + lowerbound/2 ;\\n            if(nums[middle] == target){\\n                lowerbound = middle -1;\\n                \\n            } \\n            else low = middle+1;\\n        }\\n\\n        while(upperbound <= high){\\n            int middle = upperbound/2 + high/2;\\n            if(nums[middle] == target) upperbound = middle+1;\\n            else high = middle-1;\\n        }\\n\\n        ans[0] = lowerbound+1;\\n        ans[1] = upperbound-1;\\n\\n        return ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "I wonder if anyone solved this question with \"Template III\" mentioned on Learning Card"
                    },
                    {
                        "username": "hp68",
                        "content": "Can someone tell me why my code is not accepting [1] test case.  \\nERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x0000003558cb bp 0x7ffc0282cc70 sp 0x7ffc0282cc68\\n\\n `class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        int l=0, r=nums.size()-1,mid;\\n\\n        while(l<=r){\\n            mid=(l+r)/2;\\n\\n            if(nums[mid]==target){\\n                l=0;\\n                while(l<=mid){\\n                    if(nums[l]==nums[mid]) break;\\n                    else l++;\\n                }\\n                ans.push_back(l);\\n                mid=l;\\n                int initial_mid=mid;\\n                while(nums[mid]==target){\\n                    mid++;\\n                }\\n                if(initial_mid!=mid) ans.push_back(mid-1);\\n                break;\\n            }\\n            else if(nums[mid]<target){\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n\\n        if(ans.size()<2){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n\\n        return ans;\\n    }\\n};\\'"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange index out of range error:\n\n```\nIndexError: list index out of range\n    if (nums[mid] == target):\nLine 22 in getRange (Solution.py)\n    return getRange(0, length, nums)\nLine 38 in searchRange (Solution.py)\n    ret = Solution().searchRange(param_1, param_2)\nLine 66 in _driver (Solution.py)\n    _driver()\nLine 76 in <module> (Solution.py)\n```\n\n\nIt highlights line 22 as the problem. That is this line:\n\n`if (nums[mid] == target):`\n\nI don't understand why nums[mid] is out of range. The calculation for mid is a simple (left + right)/2, so for a list in non-decreasing order it should be imppossible for mid to go out of range. I have traced the iterations carefully with leetcode's input values and the program behaves exactly as I expect it to on paper.\n\nAt first I used the global variable for nums, and I thought that maybe the compiler was creating a new subsection of the nums array for every recursive call of the binary search algorithm, so I passed the original nums array into each recursive call. Unfortunately that did nothing to fix the problem. "
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "try instead \\n\"mid=(left + right) // 2\"\\nor\\n\"mid=left + (right - left) / 2\""
                    }
                ]
            },
            {
                "id": 1990139,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "break into two pieces(lower bound and upper bound)  :P"
                    },
                    {
                        "username": "eduard92",
                        "content": "Going for 3 days binary search haul, I think I am gonna dream mid formula and while loop"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I love this question"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "So I used one binary search to find the target, and after finding that target then I use another two binary search within it to find the start and end of the target.\n\nSo does the time complexity of that still be O(log n) or something else? Even though it took 0ms but I'm still confused.\n\nThanks :D"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "[@shubhi4](/shubhi4)  as she said  same for the last target also"
                    },
                    {
                        "username": "shubhi4",
                        "content": "yes it will be O(logn) . But you dont need to find the target. you can just search for the minimum index of target first, if not found that means the target is not present in the array."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "I have a gut feel that Template III doesn\\'t really fit the range search. Yes, to find a range in a collection you need to check next and previous elements for finish and start. But in order to find both start and finish you will have to use binary search template III twice - for a start and then for a finish, which makes it no better than using any other templates.\\n\\nIf anyone knows a way to search for both start and finish while using template III, please share."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Getting TLE . Used Binary Search. What\\'s the problem??\\n\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.length-1;\\n        int[] ans = {-1, -1};\\n        int mid = low + high/2 - low/2;\\n\\n        while(low <= high){\\n\\n            mid = low + high/2 - low/2;\\n            if(nums[mid] < target) mid = low+1;\\n            else if(nums[mid] > target) mid = high-1;\\n            else break;\\n        }\\n        if(low > high) return ans;\\n\\n        int lowerbound = mid-1;\\n        int upperbound = mid+1;\\n        \\n        \\n        while(low <= lowerbound){\\n            int middle = low/2 + lowerbound/2 ;\\n            if(nums[middle] == target){\\n                lowerbound = middle -1;\\n                \\n            } \\n            else low = middle+1;\\n        }\\n\\n        while(upperbound <= high){\\n            int middle = upperbound/2 + high/2;\\n            if(nums[middle] == target) upperbound = middle+1;\\n            else high = middle-1;\\n        }\\n\\n        ans[0] = lowerbound+1;\\n        ans[1] = upperbound-1;\\n\\n        return ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "I wonder if anyone solved this question with \"Template III\" mentioned on Learning Card"
                    },
                    {
                        "username": "hp68",
                        "content": "Can someone tell me why my code is not accepting [1] test case.  \\nERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x0000003558cb bp 0x7ffc0282cc70 sp 0x7ffc0282cc68\\n\\n `class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        int l=0, r=nums.size()-1,mid;\\n\\n        while(l<=r){\\n            mid=(l+r)/2;\\n\\n            if(nums[mid]==target){\\n                l=0;\\n                while(l<=mid){\\n                    if(nums[l]==nums[mid]) break;\\n                    else l++;\\n                }\\n                ans.push_back(l);\\n                mid=l;\\n                int initial_mid=mid;\\n                while(nums[mid]==target){\\n                    mid++;\\n                }\\n                if(initial_mid!=mid) ans.push_back(mid-1);\\n                break;\\n            }\\n            else if(nums[mid]<target){\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n\\n        if(ans.size()<2){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n\\n        return ans;\\n    }\\n};\\'"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange index out of range error:\n\n```\nIndexError: list index out of range\n    if (nums[mid] == target):\nLine 22 in getRange (Solution.py)\n    return getRange(0, length, nums)\nLine 38 in searchRange (Solution.py)\n    ret = Solution().searchRange(param_1, param_2)\nLine 66 in _driver (Solution.py)\n    _driver()\nLine 76 in <module> (Solution.py)\n```\n\n\nIt highlights line 22 as the problem. That is this line:\n\n`if (nums[mid] == target):`\n\nI don't understand why nums[mid] is out of range. The calculation for mid is a simple (left + right)/2, so for a list in non-decreasing order it should be imppossible for mid to go out of range. I have traced the iterations carefully with leetcode's input values and the program behaves exactly as I expect it to on paper.\n\nAt first I used the global variable for nums, and I thought that maybe the compiler was creating a new subsection of the nums array for every recursive call of the binary search algorithm, so I passed the original nums array into each recursive call. Unfortunately that did nothing to fix the problem. "
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "try instead \\n\"mid=(left + right) // 2\"\\nor\\n\"mid=left + (right - left) / 2\""
                    }
                ]
            },
            {
                "id": 1922787,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "break into two pieces(lower bound and upper bound)  :P"
                    },
                    {
                        "username": "eduard92",
                        "content": "Going for 3 days binary search haul, I think I am gonna dream mid formula and while loop"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I love this question"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "So I used one binary search to find the target, and after finding that target then I use another two binary search within it to find the start and end of the target.\n\nSo does the time complexity of that still be O(log n) or something else? Even though it took 0ms but I'm still confused.\n\nThanks :D"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "[@shubhi4](/shubhi4)  as she said  same for the last target also"
                    },
                    {
                        "username": "shubhi4",
                        "content": "yes it will be O(logn) . But you dont need to find the target. you can just search for the minimum index of target first, if not found that means the target is not present in the array."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "I have a gut feel that Template III doesn\\'t really fit the range search. Yes, to find a range in a collection you need to check next and previous elements for finish and start. But in order to find both start and finish you will have to use binary search template III twice - for a start and then for a finish, which makes it no better than using any other templates.\\n\\nIf anyone knows a way to search for both start and finish while using template III, please share."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Getting TLE . Used Binary Search. What\\'s the problem??\\n\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.length-1;\\n        int[] ans = {-1, -1};\\n        int mid = low + high/2 - low/2;\\n\\n        while(low <= high){\\n\\n            mid = low + high/2 - low/2;\\n            if(nums[mid] < target) mid = low+1;\\n            else if(nums[mid] > target) mid = high-1;\\n            else break;\\n        }\\n        if(low > high) return ans;\\n\\n        int lowerbound = mid-1;\\n        int upperbound = mid+1;\\n        \\n        \\n        while(low <= lowerbound){\\n            int middle = low/2 + lowerbound/2 ;\\n            if(nums[middle] == target){\\n                lowerbound = middle -1;\\n                \\n            } \\n            else low = middle+1;\\n        }\\n\\n        while(upperbound <= high){\\n            int middle = upperbound/2 + high/2;\\n            if(nums[middle] == target) upperbound = middle+1;\\n            else high = middle-1;\\n        }\\n\\n        ans[0] = lowerbound+1;\\n        ans[1] = upperbound-1;\\n\\n        return ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "I wonder if anyone solved this question with \"Template III\" mentioned on Learning Card"
                    },
                    {
                        "username": "hp68",
                        "content": "Can someone tell me why my code is not accepting [1] test case.  \\nERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x0000003558cb bp 0x7ffc0282cc70 sp 0x7ffc0282cc68\\n\\n `class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        int l=0, r=nums.size()-1,mid;\\n\\n        while(l<=r){\\n            mid=(l+r)/2;\\n\\n            if(nums[mid]==target){\\n                l=0;\\n                while(l<=mid){\\n                    if(nums[l]==nums[mid]) break;\\n                    else l++;\\n                }\\n                ans.push_back(l);\\n                mid=l;\\n                int initial_mid=mid;\\n                while(nums[mid]==target){\\n                    mid++;\\n                }\\n                if(initial_mid!=mid) ans.push_back(mid-1);\\n                break;\\n            }\\n            else if(nums[mid]<target){\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n\\n        if(ans.size()<2){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n\\n        return ans;\\n    }\\n};\\'"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange index out of range error:\n\n```\nIndexError: list index out of range\n    if (nums[mid] == target):\nLine 22 in getRange (Solution.py)\n    return getRange(0, length, nums)\nLine 38 in searchRange (Solution.py)\n    ret = Solution().searchRange(param_1, param_2)\nLine 66 in _driver (Solution.py)\n    _driver()\nLine 76 in <module> (Solution.py)\n```\n\n\nIt highlights line 22 as the problem. That is this line:\n\n`if (nums[mid] == target):`\n\nI don't understand why nums[mid] is out of range. The calculation for mid is a simple (left + right)/2, so for a list in non-decreasing order it should be imppossible for mid to go out of range. I have traced the iterations carefully with leetcode's input values and the program behaves exactly as I expect it to on paper.\n\nAt first I used the global variable for nums, and I thought that maybe the compiler was creating a new subsection of the nums array for every recursive call of the binary search algorithm, so I passed the original nums array into each recursive call. Unfortunately that did nothing to fix the problem. "
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "try instead \\n\"mid=(left + right) // 2\"\\nor\\n\"mid=left + (right - left) / 2\""
                    }
                ]
            },
            {
                "id": 1809463,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "break into two pieces(lower bound and upper bound)  :P"
                    },
                    {
                        "username": "eduard92",
                        "content": "Going for 3 days binary search haul, I think I am gonna dream mid formula and while loop"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I love this question"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "So I used one binary search to find the target, and after finding that target then I use another two binary search within it to find the start and end of the target.\n\nSo does the time complexity of that still be O(log n) or something else? Even though it took 0ms but I'm still confused.\n\nThanks :D"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "[@shubhi4](/shubhi4)  as she said  same for the last target also"
                    },
                    {
                        "username": "shubhi4",
                        "content": "yes it will be O(logn) . But you dont need to find the target. you can just search for the minimum index of target first, if not found that means the target is not present in the array."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "I have a gut feel that Template III doesn\\'t really fit the range search. Yes, to find a range in a collection you need to check next and previous elements for finish and start. But in order to find both start and finish you will have to use binary search template III twice - for a start and then for a finish, which makes it no better than using any other templates.\\n\\nIf anyone knows a way to search for both start and finish while using template III, please share."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Getting TLE . Used Binary Search. What\\'s the problem??\\n\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.length-1;\\n        int[] ans = {-1, -1};\\n        int mid = low + high/2 - low/2;\\n\\n        while(low <= high){\\n\\n            mid = low + high/2 - low/2;\\n            if(nums[mid] < target) mid = low+1;\\n            else if(nums[mid] > target) mid = high-1;\\n            else break;\\n        }\\n        if(low > high) return ans;\\n\\n        int lowerbound = mid-1;\\n        int upperbound = mid+1;\\n        \\n        \\n        while(low <= lowerbound){\\n            int middle = low/2 + lowerbound/2 ;\\n            if(nums[middle] == target){\\n                lowerbound = middle -1;\\n                \\n            } \\n            else low = middle+1;\\n        }\\n\\n        while(upperbound <= high){\\n            int middle = upperbound/2 + high/2;\\n            if(nums[middle] == target) upperbound = middle+1;\\n            else high = middle-1;\\n        }\\n\\n        ans[0] = lowerbound+1;\\n        ans[1] = upperbound-1;\\n\\n        return ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "I wonder if anyone solved this question with \"Template III\" mentioned on Learning Card"
                    },
                    {
                        "username": "hp68",
                        "content": "Can someone tell me why my code is not accepting [1] test case.  \\nERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x0000003558cb bp 0x7ffc0282cc70 sp 0x7ffc0282cc68\\n\\n `class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        int l=0, r=nums.size()-1,mid;\\n\\n        while(l<=r){\\n            mid=(l+r)/2;\\n\\n            if(nums[mid]==target){\\n                l=0;\\n                while(l<=mid){\\n                    if(nums[l]==nums[mid]) break;\\n                    else l++;\\n                }\\n                ans.push_back(l);\\n                mid=l;\\n                int initial_mid=mid;\\n                while(nums[mid]==target){\\n                    mid++;\\n                }\\n                if(initial_mid!=mid) ans.push_back(mid-1);\\n                break;\\n            }\\n            else if(nums[mid]<target){\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n\\n        if(ans.size()<2){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n\\n        return ans;\\n    }\\n};\\'"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange index out of range error:\n\n```\nIndexError: list index out of range\n    if (nums[mid] == target):\nLine 22 in getRange (Solution.py)\n    return getRange(0, length, nums)\nLine 38 in searchRange (Solution.py)\n    ret = Solution().searchRange(param_1, param_2)\nLine 66 in _driver (Solution.py)\n    _driver()\nLine 76 in <module> (Solution.py)\n```\n\n\nIt highlights line 22 as the problem. That is this line:\n\n`if (nums[mid] == target):`\n\nI don't understand why nums[mid] is out of range. The calculation for mid is a simple (left + right)/2, so for a list in non-decreasing order it should be imppossible for mid to go out of range. I have traced the iterations carefully with leetcode's input values and the program behaves exactly as I expect it to on paper.\n\nAt first I used the global variable for nums, and I thought that maybe the compiler was creating a new subsection of the nums array for every recursive call of the binary search algorithm, so I passed the original nums array into each recursive call. Unfortunately that did nothing to fix the problem. "
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "try instead \\n\"mid=(left + right) // 2\"\\nor\\n\"mid=left + (right - left) / 2\""
                    }
                ]
            },
            {
                "id": 1571991,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "break into two pieces(lower bound and upper bound)  :P"
                    },
                    {
                        "username": "eduard92",
                        "content": "Going for 3 days binary search haul, I think I am gonna dream mid formula and while loop"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I love this question"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "So I used one binary search to find the target, and after finding that target then I use another two binary search within it to find the start and end of the target.\n\nSo does the time complexity of that still be O(log n) or something else? Even though it took 0ms but I'm still confused.\n\nThanks :D"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "[@shubhi4](/shubhi4)  as she said  same for the last target also"
                    },
                    {
                        "username": "shubhi4",
                        "content": "yes it will be O(logn) . But you dont need to find the target. you can just search for the minimum index of target first, if not found that means the target is not present in the array."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "I have a gut feel that Template III doesn\\'t really fit the range search. Yes, to find a range in a collection you need to check next and previous elements for finish and start. But in order to find both start and finish you will have to use binary search template III twice - for a start and then for a finish, which makes it no better than using any other templates.\\n\\nIf anyone knows a way to search for both start and finish while using template III, please share."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Getting TLE . Used Binary Search. What\\'s the problem??\\n\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.length-1;\\n        int[] ans = {-1, -1};\\n        int mid = low + high/2 - low/2;\\n\\n        while(low <= high){\\n\\n            mid = low + high/2 - low/2;\\n            if(nums[mid] < target) mid = low+1;\\n            else if(nums[mid] > target) mid = high-1;\\n            else break;\\n        }\\n        if(low > high) return ans;\\n\\n        int lowerbound = mid-1;\\n        int upperbound = mid+1;\\n        \\n        \\n        while(low <= lowerbound){\\n            int middle = low/2 + lowerbound/2 ;\\n            if(nums[middle] == target){\\n                lowerbound = middle -1;\\n                \\n            } \\n            else low = middle+1;\\n        }\\n\\n        while(upperbound <= high){\\n            int middle = upperbound/2 + high/2;\\n            if(nums[middle] == target) upperbound = middle+1;\\n            else high = middle-1;\\n        }\\n\\n        ans[0] = lowerbound+1;\\n        ans[1] = upperbound-1;\\n\\n        return ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "I wonder if anyone solved this question with \"Template III\" mentioned on Learning Card"
                    },
                    {
                        "username": "hp68",
                        "content": "Can someone tell me why my code is not accepting [1] test case.  \\nERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x0000003558cb bp 0x7ffc0282cc70 sp 0x7ffc0282cc68\\n\\n `class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        int l=0, r=nums.size()-1,mid;\\n\\n        while(l<=r){\\n            mid=(l+r)/2;\\n\\n            if(nums[mid]==target){\\n                l=0;\\n                while(l<=mid){\\n                    if(nums[l]==nums[mid]) break;\\n                    else l++;\\n                }\\n                ans.push_back(l);\\n                mid=l;\\n                int initial_mid=mid;\\n                while(nums[mid]==target){\\n                    mid++;\\n                }\\n                if(initial_mid!=mid) ans.push_back(mid-1);\\n                break;\\n            }\\n            else if(nums[mid]<target){\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n\\n        if(ans.size()<2){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n\\n        return ans;\\n    }\\n};\\'"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange index out of range error:\n\n```\nIndexError: list index out of range\n    if (nums[mid] == target):\nLine 22 in getRange (Solution.py)\n    return getRange(0, length, nums)\nLine 38 in searchRange (Solution.py)\n    ret = Solution().searchRange(param_1, param_2)\nLine 66 in _driver (Solution.py)\n    _driver()\nLine 76 in <module> (Solution.py)\n```\n\n\nIt highlights line 22 as the problem. That is this line:\n\n`if (nums[mid] == target):`\n\nI don't understand why nums[mid] is out of range. The calculation for mid is a simple (left + right)/2, so for a list in non-decreasing order it should be imppossible for mid to go out of range. I have traced the iterations carefully with leetcode's input values and the program behaves exactly as I expect it to on paper.\n\nAt first I used the global variable for nums, and I thought that maybe the compiler was creating a new subsection of the nums array for every recursive call of the binary search algorithm, so I passed the original nums array into each recursive call. Unfortunately that did nothing to fix the problem. "
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "try instead \\n\"mid=(left + right) // 2\"\\nor\\n\"mid=left + (right - left) / 2\""
                    }
                ]
            },
            {
                "id": 2042422,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "break into two pieces(lower bound and upper bound)  :P"
                    },
                    {
                        "username": "eduard92",
                        "content": "Going for 3 days binary search haul, I think I am gonna dream mid formula and while loop"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I love this question"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "So I used one binary search to find the target, and after finding that target then I use another two binary search within it to find the start and end of the target.\n\nSo does the time complexity of that still be O(log n) or something else? Even though it took 0ms but I'm still confused.\n\nThanks :D"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "[@shubhi4](/shubhi4)  as she said  same for the last target also"
                    },
                    {
                        "username": "shubhi4",
                        "content": "yes it will be O(logn) . But you dont need to find the target. you can just search for the minimum index of target first, if not found that means the target is not present in the array."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "I have a gut feel that Template III doesn\\'t really fit the range search. Yes, to find a range in a collection you need to check next and previous elements for finish and start. But in order to find both start and finish you will have to use binary search template III twice - for a start and then for a finish, which makes it no better than using any other templates.\\n\\nIf anyone knows a way to search for both start and finish while using template III, please share."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Getting TLE . Used Binary Search. What\\'s the problem??\\n\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.length-1;\\n        int[] ans = {-1, -1};\\n        int mid = low + high/2 - low/2;\\n\\n        while(low <= high){\\n\\n            mid = low + high/2 - low/2;\\n            if(nums[mid] < target) mid = low+1;\\n            else if(nums[mid] > target) mid = high-1;\\n            else break;\\n        }\\n        if(low > high) return ans;\\n\\n        int lowerbound = mid-1;\\n        int upperbound = mid+1;\\n        \\n        \\n        while(low <= lowerbound){\\n            int middle = low/2 + lowerbound/2 ;\\n            if(nums[middle] == target){\\n                lowerbound = middle -1;\\n                \\n            } \\n            else low = middle+1;\\n        }\\n\\n        while(upperbound <= high){\\n            int middle = upperbound/2 + high/2;\\n            if(nums[middle] == target) upperbound = middle+1;\\n            else high = middle-1;\\n        }\\n\\n        ans[0] = lowerbound+1;\\n        ans[1] = upperbound-1;\\n\\n        return ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "I wonder if anyone solved this question with \"Template III\" mentioned on Learning Card"
                    },
                    {
                        "username": "hp68",
                        "content": "Can someone tell me why my code is not accepting [1] test case.  \\nERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x0000003558cb bp 0x7ffc0282cc70 sp 0x7ffc0282cc68\\n\\n `class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        int l=0, r=nums.size()-1,mid;\\n\\n        while(l<=r){\\n            mid=(l+r)/2;\\n\\n            if(nums[mid]==target){\\n                l=0;\\n                while(l<=mid){\\n                    if(nums[l]==nums[mid]) break;\\n                    else l++;\\n                }\\n                ans.push_back(l);\\n                mid=l;\\n                int initial_mid=mid;\\n                while(nums[mid]==target){\\n                    mid++;\\n                }\\n                if(initial_mid!=mid) ans.push_back(mid-1);\\n                break;\\n            }\\n            else if(nums[mid]<target){\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n\\n        if(ans.size()<2){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n\\n        return ans;\\n    }\\n};\\'"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange index out of range error:\n\n```\nIndexError: list index out of range\n    if (nums[mid] == target):\nLine 22 in getRange (Solution.py)\n    return getRange(0, length, nums)\nLine 38 in searchRange (Solution.py)\n    ret = Solution().searchRange(param_1, param_2)\nLine 66 in _driver (Solution.py)\n    _driver()\nLine 76 in <module> (Solution.py)\n```\n\n\nIt highlights line 22 as the problem. That is this line:\n\n`if (nums[mid] == target):`\n\nI don't understand why nums[mid] is out of range. The calculation for mid is a simple (left + right)/2, so for a list in non-decreasing order it should be imppossible for mid to go out of range. I have traced the iterations carefully with leetcode's input values and the program behaves exactly as I expect it to on paper.\n\nAt first I used the global variable for nums, and I thought that maybe the compiler was creating a new subsection of the nums array for every recursive call of the binary search algorithm, so I passed the original nums array into each recursive call. Unfortunately that did nothing to fix the problem. "
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "try instead \\n\"mid=(left + right) // 2\"\\nor\\n\"mid=left + (right - left) / 2\""
                    }
                ]
            },
            {
                "id": 2033940,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "break into two pieces(lower bound and upper bound)  :P"
                    },
                    {
                        "username": "eduard92",
                        "content": "Going for 3 days binary search haul, I think I am gonna dream mid formula and while loop"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I love this question"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "So I used one binary search to find the target, and after finding that target then I use another two binary search within it to find the start and end of the target.\n\nSo does the time complexity of that still be O(log n) or something else? Even though it took 0ms but I'm still confused.\n\nThanks :D"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "[@shubhi4](/shubhi4)  as she said  same for the last target also"
                    },
                    {
                        "username": "shubhi4",
                        "content": "yes it will be O(logn) . But you dont need to find the target. you can just search for the minimum index of target first, if not found that means the target is not present in the array."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "I have a gut feel that Template III doesn\\'t really fit the range search. Yes, to find a range in a collection you need to check next and previous elements for finish and start. But in order to find both start and finish you will have to use binary search template III twice - for a start and then for a finish, which makes it no better than using any other templates.\\n\\nIf anyone knows a way to search for both start and finish while using template III, please share."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Getting TLE . Used Binary Search. What\\'s the problem??\\n\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.length-1;\\n        int[] ans = {-1, -1};\\n        int mid = low + high/2 - low/2;\\n\\n        while(low <= high){\\n\\n            mid = low + high/2 - low/2;\\n            if(nums[mid] < target) mid = low+1;\\n            else if(nums[mid] > target) mid = high-1;\\n            else break;\\n        }\\n        if(low > high) return ans;\\n\\n        int lowerbound = mid-1;\\n        int upperbound = mid+1;\\n        \\n        \\n        while(low <= lowerbound){\\n            int middle = low/2 + lowerbound/2 ;\\n            if(nums[middle] == target){\\n                lowerbound = middle -1;\\n                \\n            } \\n            else low = middle+1;\\n        }\\n\\n        while(upperbound <= high){\\n            int middle = upperbound/2 + high/2;\\n            if(nums[middle] == target) upperbound = middle+1;\\n            else high = middle-1;\\n        }\\n\\n        ans[0] = lowerbound+1;\\n        ans[1] = upperbound-1;\\n\\n        return ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "I wonder if anyone solved this question with \"Template III\" mentioned on Learning Card"
                    },
                    {
                        "username": "hp68",
                        "content": "Can someone tell me why my code is not accepting [1] test case.  \\nERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x0000003558cb bp 0x7ffc0282cc70 sp 0x7ffc0282cc68\\n\\n `class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        int l=0, r=nums.size()-1,mid;\\n\\n        while(l<=r){\\n            mid=(l+r)/2;\\n\\n            if(nums[mid]==target){\\n                l=0;\\n                while(l<=mid){\\n                    if(nums[l]==nums[mid]) break;\\n                    else l++;\\n                }\\n                ans.push_back(l);\\n                mid=l;\\n                int initial_mid=mid;\\n                while(nums[mid]==target){\\n                    mid++;\\n                }\\n                if(initial_mid!=mid) ans.push_back(mid-1);\\n                break;\\n            }\\n            else if(nums[mid]<target){\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n\\n        if(ans.size()<2){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n\\n        return ans;\\n    }\\n};\\'"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange index out of range error:\n\n```\nIndexError: list index out of range\n    if (nums[mid] == target):\nLine 22 in getRange (Solution.py)\n    return getRange(0, length, nums)\nLine 38 in searchRange (Solution.py)\n    ret = Solution().searchRange(param_1, param_2)\nLine 66 in _driver (Solution.py)\n    _driver()\nLine 76 in <module> (Solution.py)\n```\n\n\nIt highlights line 22 as the problem. That is this line:\n\n`if (nums[mid] == target):`\n\nI don't understand why nums[mid] is out of range. The calculation for mid is a simple (left + right)/2, so for a list in non-decreasing order it should be imppossible for mid to go out of range. I have traced the iterations carefully with leetcode's input values and the program behaves exactly as I expect it to on paper.\n\nAt first I used the global variable for nums, and I thought that maybe the compiler was creating a new subsection of the nums array for every recursive call of the binary search algorithm, so I passed the original nums array into each recursive call. Unfortunately that did nothing to fix the problem. "
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "try instead \\n\"mid=(left + right) // 2\"\\nor\\n\"mid=left + (right - left) / 2\""
                    }
                ]
            },
            {
                "id": 2024302,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "break into two pieces(lower bound and upper bound)  :P"
                    },
                    {
                        "username": "eduard92",
                        "content": "Going for 3 days binary search haul, I think I am gonna dream mid formula and while loop"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I love this question"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "So I used one binary search to find the target, and after finding that target then I use another two binary search within it to find the start and end of the target.\n\nSo does the time complexity of that still be O(log n) or something else? Even though it took 0ms but I'm still confused.\n\nThanks :D"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "[@shubhi4](/shubhi4)  as she said  same for the last target also"
                    },
                    {
                        "username": "shubhi4",
                        "content": "yes it will be O(logn) . But you dont need to find the target. you can just search for the minimum index of target first, if not found that means the target is not present in the array."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "I have a gut feel that Template III doesn\\'t really fit the range search. Yes, to find a range in a collection you need to check next and previous elements for finish and start. But in order to find both start and finish you will have to use binary search template III twice - for a start and then for a finish, which makes it no better than using any other templates.\\n\\nIf anyone knows a way to search for both start and finish while using template III, please share."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Getting TLE . Used Binary Search. What\\'s the problem??\\n\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.length-1;\\n        int[] ans = {-1, -1};\\n        int mid = low + high/2 - low/2;\\n\\n        while(low <= high){\\n\\n            mid = low + high/2 - low/2;\\n            if(nums[mid] < target) mid = low+1;\\n            else if(nums[mid] > target) mid = high-1;\\n            else break;\\n        }\\n        if(low > high) return ans;\\n\\n        int lowerbound = mid-1;\\n        int upperbound = mid+1;\\n        \\n        \\n        while(low <= lowerbound){\\n            int middle = low/2 + lowerbound/2 ;\\n            if(nums[middle] == target){\\n                lowerbound = middle -1;\\n                \\n            } \\n            else low = middle+1;\\n        }\\n\\n        while(upperbound <= high){\\n            int middle = upperbound/2 + high/2;\\n            if(nums[middle] == target) upperbound = middle+1;\\n            else high = middle-1;\\n        }\\n\\n        ans[0] = lowerbound+1;\\n        ans[1] = upperbound-1;\\n\\n        return ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "I wonder if anyone solved this question with \"Template III\" mentioned on Learning Card"
                    },
                    {
                        "username": "hp68",
                        "content": "Can someone tell me why my code is not accepting [1] test case.  \\nERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x0000003558cb bp 0x7ffc0282cc70 sp 0x7ffc0282cc68\\n\\n `class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        int l=0, r=nums.size()-1,mid;\\n\\n        while(l<=r){\\n            mid=(l+r)/2;\\n\\n            if(nums[mid]==target){\\n                l=0;\\n                while(l<=mid){\\n                    if(nums[l]==nums[mid]) break;\\n                    else l++;\\n                }\\n                ans.push_back(l);\\n                mid=l;\\n                int initial_mid=mid;\\n                while(nums[mid]==target){\\n                    mid++;\\n                }\\n                if(initial_mid!=mid) ans.push_back(mid-1);\\n                break;\\n            }\\n            else if(nums[mid]<target){\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n\\n        if(ans.size()<2){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n\\n        return ans;\\n    }\\n};\\'"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange index out of range error:\n\n```\nIndexError: list index out of range\n    if (nums[mid] == target):\nLine 22 in getRange (Solution.py)\n    return getRange(0, length, nums)\nLine 38 in searchRange (Solution.py)\n    ret = Solution().searchRange(param_1, param_2)\nLine 66 in _driver (Solution.py)\n    _driver()\nLine 76 in <module> (Solution.py)\n```\n\n\nIt highlights line 22 as the problem. That is this line:\n\n`if (nums[mid] == target):`\n\nI don't understand why nums[mid] is out of range. The calculation for mid is a simple (left + right)/2, so for a list in non-decreasing order it should be imppossible for mid to go out of range. I have traced the iterations carefully with leetcode's input values and the program behaves exactly as I expect it to on paper.\n\nAt first I used the global variable for nums, and I thought that maybe the compiler was creating a new subsection of the nums array for every recursive call of the binary search algorithm, so I passed the original nums array into each recursive call. Unfortunately that did nothing to fix the problem. "
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "try instead \\n\"mid=(left + right) // 2\"\\nor\\n\"mid=left + (right - left) / 2\""
                    }
                ]
            },
            {
                "id": 2024052,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "break into two pieces(lower bound and upper bound)  :P"
                    },
                    {
                        "username": "eduard92",
                        "content": "Going for 3 days binary search haul, I think I am gonna dream mid formula and while loop"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I love this question"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "So I used one binary search to find the target, and after finding that target then I use another two binary search within it to find the start and end of the target.\n\nSo does the time complexity of that still be O(log n) or something else? Even though it took 0ms but I'm still confused.\n\nThanks :D"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "[@shubhi4](/shubhi4)  as she said  same for the last target also"
                    },
                    {
                        "username": "shubhi4",
                        "content": "yes it will be O(logn) . But you dont need to find the target. you can just search for the minimum index of target first, if not found that means the target is not present in the array."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "I have a gut feel that Template III doesn\\'t really fit the range search. Yes, to find a range in a collection you need to check next and previous elements for finish and start. But in order to find both start and finish you will have to use binary search template III twice - for a start and then for a finish, which makes it no better than using any other templates.\\n\\nIf anyone knows a way to search for both start and finish while using template III, please share."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Getting TLE . Used Binary Search. What\\'s the problem??\\n\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.length-1;\\n        int[] ans = {-1, -1};\\n        int mid = low + high/2 - low/2;\\n\\n        while(low <= high){\\n\\n            mid = low + high/2 - low/2;\\n            if(nums[mid] < target) mid = low+1;\\n            else if(nums[mid] > target) mid = high-1;\\n            else break;\\n        }\\n        if(low > high) return ans;\\n\\n        int lowerbound = mid-1;\\n        int upperbound = mid+1;\\n        \\n        \\n        while(low <= lowerbound){\\n            int middle = low/2 + lowerbound/2 ;\\n            if(nums[middle] == target){\\n                lowerbound = middle -1;\\n                \\n            } \\n            else low = middle+1;\\n        }\\n\\n        while(upperbound <= high){\\n            int middle = upperbound/2 + high/2;\\n            if(nums[middle] == target) upperbound = middle+1;\\n            else high = middle-1;\\n        }\\n\\n        ans[0] = lowerbound+1;\\n        ans[1] = upperbound-1;\\n\\n        return ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "I wonder if anyone solved this question with \"Template III\" mentioned on Learning Card"
                    },
                    {
                        "username": "hp68",
                        "content": "Can someone tell me why my code is not accepting [1] test case.  \\nERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x0000003558cb bp 0x7ffc0282cc70 sp 0x7ffc0282cc68\\n\\n `class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        int l=0, r=nums.size()-1,mid;\\n\\n        while(l<=r){\\n            mid=(l+r)/2;\\n\\n            if(nums[mid]==target){\\n                l=0;\\n                while(l<=mid){\\n                    if(nums[l]==nums[mid]) break;\\n                    else l++;\\n                }\\n                ans.push_back(l);\\n                mid=l;\\n                int initial_mid=mid;\\n                while(nums[mid]==target){\\n                    mid++;\\n                }\\n                if(initial_mid!=mid) ans.push_back(mid-1);\\n                break;\\n            }\\n            else if(nums[mid]<target){\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n\\n        if(ans.size()<2){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n\\n        return ans;\\n    }\\n};\\'"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange index out of range error:\n\n```\nIndexError: list index out of range\n    if (nums[mid] == target):\nLine 22 in getRange (Solution.py)\n    return getRange(0, length, nums)\nLine 38 in searchRange (Solution.py)\n    ret = Solution().searchRange(param_1, param_2)\nLine 66 in _driver (Solution.py)\n    _driver()\nLine 76 in <module> (Solution.py)\n```\n\n\nIt highlights line 22 as the problem. That is this line:\n\n`if (nums[mid] == target):`\n\nI don't understand why nums[mid] is out of range. The calculation for mid is a simple (left + right)/2, so for a list in non-decreasing order it should be imppossible for mid to go out of range. I have traced the iterations carefully with leetcode's input values and the program behaves exactly as I expect it to on paper.\n\nAt first I used the global variable for nums, and I thought that maybe the compiler was creating a new subsection of the nums array for every recursive call of the binary search algorithm, so I passed the original nums array into each recursive call. Unfortunately that did nothing to fix the problem. "
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "try instead \\n\"mid=(left + right) // 2\"\\nor\\n\"mid=left + (right - left) / 2\""
                    }
                ]
            },
            {
                "id": 2020535,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "break into two pieces(lower bound and upper bound)  :P"
                    },
                    {
                        "username": "eduard92",
                        "content": "Going for 3 days binary search haul, I think I am gonna dream mid formula and while loop"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I love this question"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "So I used one binary search to find the target, and after finding that target then I use another two binary search within it to find the start and end of the target.\n\nSo does the time complexity of that still be O(log n) or something else? Even though it took 0ms but I'm still confused.\n\nThanks :D"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "[@shubhi4](/shubhi4)  as she said  same for the last target also"
                    },
                    {
                        "username": "shubhi4",
                        "content": "yes it will be O(logn) . But you dont need to find the target. you can just search for the minimum index of target first, if not found that means the target is not present in the array."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "I have a gut feel that Template III doesn\\'t really fit the range search. Yes, to find a range in a collection you need to check next and previous elements for finish and start. But in order to find both start and finish you will have to use binary search template III twice - for a start and then for a finish, which makes it no better than using any other templates.\\n\\nIf anyone knows a way to search for both start and finish while using template III, please share."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Getting TLE . Used Binary Search. What\\'s the problem??\\n\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.length-1;\\n        int[] ans = {-1, -1};\\n        int mid = low + high/2 - low/2;\\n\\n        while(low <= high){\\n\\n            mid = low + high/2 - low/2;\\n            if(nums[mid] < target) mid = low+1;\\n            else if(nums[mid] > target) mid = high-1;\\n            else break;\\n        }\\n        if(low > high) return ans;\\n\\n        int lowerbound = mid-1;\\n        int upperbound = mid+1;\\n        \\n        \\n        while(low <= lowerbound){\\n            int middle = low/2 + lowerbound/2 ;\\n            if(nums[middle] == target){\\n                lowerbound = middle -1;\\n                \\n            } \\n            else low = middle+1;\\n        }\\n\\n        while(upperbound <= high){\\n            int middle = upperbound/2 + high/2;\\n            if(nums[middle] == target) upperbound = middle+1;\\n            else high = middle-1;\\n        }\\n\\n        ans[0] = lowerbound+1;\\n        ans[1] = upperbound-1;\\n\\n        return ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "I wonder if anyone solved this question with \"Template III\" mentioned on Learning Card"
                    },
                    {
                        "username": "hp68",
                        "content": "Can someone tell me why my code is not accepting [1] test case.  \\nERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x0000003558cb bp 0x7ffc0282cc70 sp 0x7ffc0282cc68\\n\\n `class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        int l=0, r=nums.size()-1,mid;\\n\\n        while(l<=r){\\n            mid=(l+r)/2;\\n\\n            if(nums[mid]==target){\\n                l=0;\\n                while(l<=mid){\\n                    if(nums[l]==nums[mid]) break;\\n                    else l++;\\n                }\\n                ans.push_back(l);\\n                mid=l;\\n                int initial_mid=mid;\\n                while(nums[mid]==target){\\n                    mid++;\\n                }\\n                if(initial_mid!=mid) ans.push_back(mid-1);\\n                break;\\n            }\\n            else if(nums[mid]<target){\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n\\n        if(ans.size()<2){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n\\n        return ans;\\n    }\\n};\\'"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange index out of range error:\n\n```\nIndexError: list index out of range\n    if (nums[mid] == target):\nLine 22 in getRange (Solution.py)\n    return getRange(0, length, nums)\nLine 38 in searchRange (Solution.py)\n    ret = Solution().searchRange(param_1, param_2)\nLine 66 in _driver (Solution.py)\n    _driver()\nLine 76 in <module> (Solution.py)\n```\n\n\nIt highlights line 22 as the problem. That is this line:\n\n`if (nums[mid] == target):`\n\nI don't understand why nums[mid] is out of range. The calculation for mid is a simple (left + right)/2, so for a list in non-decreasing order it should be imppossible for mid to go out of range. I have traced the iterations carefully with leetcode's input values and the program behaves exactly as I expect it to on paper.\n\nAt first I used the global variable for nums, and I thought that maybe the compiler was creating a new subsection of the nums array for every recursive call of the binary search algorithm, so I passed the original nums array into each recursive call. Unfortunately that did nothing to fix the problem. "
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "try instead \\n\"mid=(left + right) // 2\"\\nor\\n\"mid=left + (right - left) / 2\""
                    }
                ]
            },
            {
                "id": 2017536,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "I\\'ve done in O(n) time but still my solution is accepting."
                    },
                    {
                        "username": "yashgaud15",
                        "content": "i dont know why is this showing up on leetcode, i am not facing any problem in my IDE\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int[] ret = new Solution().searchRange(param_1, param_2);\\n                      ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\ni dont know why is this showing up on leetcode, i am not facing any problem in my IDE"
                    },
                    {
                        "username": "harshjainsk531",
                        "content": "\n        \n\n        int first_occurence = -1;\n        int last_occurence  = - 1;\n        int start = 0;\n        int end = nums.size() -1;\n        int mid = start + (end - start) / 2;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                first_occurence = mid;\n                end = mid - 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        start = 0;\n        end = nums.size() -1;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                last_occurence = mid;\n                start = mid + 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        vector<int> ans {first_occurence, last_occurence};\n\n        return ans;\n\n\nCan anyone help me understand why y code is not working for input array [2, 2] and target = 3?"
                    },
                    {
                        "username": "sarashs",
                        "content": "Two binary searches for the left and the right side"
                    },
                    {
                        "username": "Nayab_Rasool",
                        "content": "I used binary search, its run time is accepted but it shows memory limit exceeded error what should i do?\\n"
                    },
                    {
                        "username": "kamalmodi",
                        "content": "class Solution {\\npublic:\\n    vector<int> firstsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                e=mid-1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n  return ans ;\\n    }\\n}\\n\\n\\nvector<int> lastsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                s=mid+1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n return ans;\\n    }\\n\\n   \\n\\n\\nint main(){\\n    vector<int> nums= {5,7,7,8,8,10};\\n\\n    int firstOccurrence = firstsearchRange(nums, 8, 6);\\n    int lastOccurrence = lastsearchRange(nums, 8, 6);\\n\\n    cout << \" First occurence is\" << firstsearchRange(nums, 8, 6) << endl ;\\n    cout << \" last occurence is\" << lastsearchRange(nums, 8, 6) << endl ;\\n    return 0;\\n}\\n\\nGuys  this is my code   im getting this error.. pls resolve \\nLine 7: Char 24: error: no viable conversion from \\'int\\' to \\'vector<int>\\'\\n          vector <int> ans= -1;"
                    },
                    {
                        "username": "hossain6857",
                        "content": "why the following test case is not valid? please explain.\\n[1 2 10 13 13]"
                    },
                    {
                        "username": "shivam_XDD",
                        "content": "this is my code it is throwing error \\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n please check and tell hwere i am wrong:)\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n   \\n  int firstpos=-1;\\n    while(nums.size()<=end)\\n    { int mid=start - (start+end)/2;\\n        if(nums[mid]==target)\\n        {\\n            firstpos=mid;\\n            end=mid-1;\\n\\n        }\\n\\n        else if(target>nums[mid])\\n        {\\n            start=mid+1;\\n        }\\n        else if (target<nums[mid])\\n        {\\n            end=mid-1;\\n        }\\n\\n      \\n    }\\n\\n      int s=0;\\n    int e=nums.size()-1;\\n   \\n   int secondpos=-1;\\n    while(nums.size()<=e)\\n    {\\n         int m=s - (s+e)/2;\\n        if(nums[m]==target)\\n        {\\n            secondpos=m;\\n            s=m+1;\\n\\n        }\\n\\n        else if(target>nums[m])\\n        {\\n            s=m+1;\\n        }\\n        else if (target<nums[m])\\n        {\\n            e=m-1;\\n        }\\n\\n      \\n    }\\n    return {firstpos , secondpos};\\n\\n    }\\n}; "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n       \\n        int s = 0,e = nums.size()-1 , firstpos = -1,lastpos = -1;\\n        while(s<=e){\\n              int mid = s+(e-s)/2;\\n            if(nums[mid] == target){\\n                firstpos = mid;\\n                e = mid-1;\\n            }\\n              else if(nums[mid] >target)\\n               e = mid-1;\\n            \\n            else\\n                s = mid+1;\\n            \\n            \\n        }\\n         int  start = 0, end =nums.size()-1;\\n          while(start<=end){\\n              int mid = start+(end-start)/2;\\n              if(nums[mid] == target){\\n                  lastpos = mid;\\n                  start = mid+1;\\n              }\\n\\n                  else if(nums[mid]<  target)\\n                      start = mid+1;\\n            \\n                  else\\n                      end = mid-1;\\n                  \\n              }\\n              return{firstpos , lastpos};\\nthis is my code"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "For this particular solution we solve the problem with **Binary search**. The first step will be to find the target number (be it in any index) and store its location in a variable called **temp**. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector<int> ans and the final positions are returned. \\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned. "
                    }
                ]
            },
            {
                "id": 2013516,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "I\\'ve done in O(n) time but still my solution is accepting."
                    },
                    {
                        "username": "yashgaud15",
                        "content": "i dont know why is this showing up on leetcode, i am not facing any problem in my IDE\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int[] ret = new Solution().searchRange(param_1, param_2);\\n                      ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\ni dont know why is this showing up on leetcode, i am not facing any problem in my IDE"
                    },
                    {
                        "username": "harshjainsk531",
                        "content": "\n        \n\n        int first_occurence = -1;\n        int last_occurence  = - 1;\n        int start = 0;\n        int end = nums.size() -1;\n        int mid = start + (end - start) / 2;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                first_occurence = mid;\n                end = mid - 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        start = 0;\n        end = nums.size() -1;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                last_occurence = mid;\n                start = mid + 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        vector<int> ans {first_occurence, last_occurence};\n\n        return ans;\n\n\nCan anyone help me understand why y code is not working for input array [2, 2] and target = 3?"
                    },
                    {
                        "username": "sarashs",
                        "content": "Two binary searches for the left and the right side"
                    },
                    {
                        "username": "Nayab_Rasool",
                        "content": "I used binary search, its run time is accepted but it shows memory limit exceeded error what should i do?\\n"
                    },
                    {
                        "username": "kamalmodi",
                        "content": "class Solution {\\npublic:\\n    vector<int> firstsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                e=mid-1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n  return ans ;\\n    }\\n}\\n\\n\\nvector<int> lastsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                s=mid+1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n return ans;\\n    }\\n\\n   \\n\\n\\nint main(){\\n    vector<int> nums= {5,7,7,8,8,10};\\n\\n    int firstOccurrence = firstsearchRange(nums, 8, 6);\\n    int lastOccurrence = lastsearchRange(nums, 8, 6);\\n\\n    cout << \" First occurence is\" << firstsearchRange(nums, 8, 6) << endl ;\\n    cout << \" last occurence is\" << lastsearchRange(nums, 8, 6) << endl ;\\n    return 0;\\n}\\n\\nGuys  this is my code   im getting this error.. pls resolve \\nLine 7: Char 24: error: no viable conversion from \\'int\\' to \\'vector<int>\\'\\n          vector <int> ans= -1;"
                    },
                    {
                        "username": "hossain6857",
                        "content": "why the following test case is not valid? please explain.\\n[1 2 10 13 13]"
                    },
                    {
                        "username": "shivam_XDD",
                        "content": "this is my code it is throwing error \\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n please check and tell hwere i am wrong:)\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n   \\n  int firstpos=-1;\\n    while(nums.size()<=end)\\n    { int mid=start - (start+end)/2;\\n        if(nums[mid]==target)\\n        {\\n            firstpos=mid;\\n            end=mid-1;\\n\\n        }\\n\\n        else if(target>nums[mid])\\n        {\\n            start=mid+1;\\n        }\\n        else if (target<nums[mid])\\n        {\\n            end=mid-1;\\n        }\\n\\n      \\n    }\\n\\n      int s=0;\\n    int e=nums.size()-1;\\n   \\n   int secondpos=-1;\\n    while(nums.size()<=e)\\n    {\\n         int m=s - (s+e)/2;\\n        if(nums[m]==target)\\n        {\\n            secondpos=m;\\n            s=m+1;\\n\\n        }\\n\\n        else if(target>nums[m])\\n        {\\n            s=m+1;\\n        }\\n        else if (target<nums[m])\\n        {\\n            e=m-1;\\n        }\\n\\n      \\n    }\\n    return {firstpos , secondpos};\\n\\n    }\\n}; "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n       \\n        int s = 0,e = nums.size()-1 , firstpos = -1,lastpos = -1;\\n        while(s<=e){\\n              int mid = s+(e-s)/2;\\n            if(nums[mid] == target){\\n                firstpos = mid;\\n                e = mid-1;\\n            }\\n              else if(nums[mid] >target)\\n               e = mid-1;\\n            \\n            else\\n                s = mid+1;\\n            \\n            \\n        }\\n         int  start = 0, end =nums.size()-1;\\n          while(start<=end){\\n              int mid = start+(end-start)/2;\\n              if(nums[mid] == target){\\n                  lastpos = mid;\\n                  start = mid+1;\\n              }\\n\\n                  else if(nums[mid]<  target)\\n                      start = mid+1;\\n            \\n                  else\\n                      end = mid-1;\\n                  \\n              }\\n              return{firstpos , lastpos};\\nthis is my code"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "For this particular solution we solve the problem with **Binary search**. The first step will be to find the target number (be it in any index) and store its location in a variable called **temp**. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector<int> ans and the final positions are returned. \\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned. "
                    }
                ]
            },
            {
                "id": 2010351,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "I\\'ve done in O(n) time but still my solution is accepting."
                    },
                    {
                        "username": "yashgaud15",
                        "content": "i dont know why is this showing up on leetcode, i am not facing any problem in my IDE\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int[] ret = new Solution().searchRange(param_1, param_2);\\n                      ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\ni dont know why is this showing up on leetcode, i am not facing any problem in my IDE"
                    },
                    {
                        "username": "harshjainsk531",
                        "content": "\n        \n\n        int first_occurence = -1;\n        int last_occurence  = - 1;\n        int start = 0;\n        int end = nums.size() -1;\n        int mid = start + (end - start) / 2;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                first_occurence = mid;\n                end = mid - 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        start = 0;\n        end = nums.size() -1;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                last_occurence = mid;\n                start = mid + 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        vector<int> ans {first_occurence, last_occurence};\n\n        return ans;\n\n\nCan anyone help me understand why y code is not working for input array [2, 2] and target = 3?"
                    },
                    {
                        "username": "sarashs",
                        "content": "Two binary searches for the left and the right side"
                    },
                    {
                        "username": "Nayab_Rasool",
                        "content": "I used binary search, its run time is accepted but it shows memory limit exceeded error what should i do?\\n"
                    },
                    {
                        "username": "kamalmodi",
                        "content": "class Solution {\\npublic:\\n    vector<int> firstsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                e=mid-1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n  return ans ;\\n    }\\n}\\n\\n\\nvector<int> lastsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                s=mid+1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n return ans;\\n    }\\n\\n   \\n\\n\\nint main(){\\n    vector<int> nums= {5,7,7,8,8,10};\\n\\n    int firstOccurrence = firstsearchRange(nums, 8, 6);\\n    int lastOccurrence = lastsearchRange(nums, 8, 6);\\n\\n    cout << \" First occurence is\" << firstsearchRange(nums, 8, 6) << endl ;\\n    cout << \" last occurence is\" << lastsearchRange(nums, 8, 6) << endl ;\\n    return 0;\\n}\\n\\nGuys  this is my code   im getting this error.. pls resolve \\nLine 7: Char 24: error: no viable conversion from \\'int\\' to \\'vector<int>\\'\\n          vector <int> ans= -1;"
                    },
                    {
                        "username": "hossain6857",
                        "content": "why the following test case is not valid? please explain.\\n[1 2 10 13 13]"
                    },
                    {
                        "username": "shivam_XDD",
                        "content": "this is my code it is throwing error \\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n please check and tell hwere i am wrong:)\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n   \\n  int firstpos=-1;\\n    while(nums.size()<=end)\\n    { int mid=start - (start+end)/2;\\n        if(nums[mid]==target)\\n        {\\n            firstpos=mid;\\n            end=mid-1;\\n\\n        }\\n\\n        else if(target>nums[mid])\\n        {\\n            start=mid+1;\\n        }\\n        else if (target<nums[mid])\\n        {\\n            end=mid-1;\\n        }\\n\\n      \\n    }\\n\\n      int s=0;\\n    int e=nums.size()-1;\\n   \\n   int secondpos=-1;\\n    while(nums.size()<=e)\\n    {\\n         int m=s - (s+e)/2;\\n        if(nums[m]==target)\\n        {\\n            secondpos=m;\\n            s=m+1;\\n\\n        }\\n\\n        else if(target>nums[m])\\n        {\\n            s=m+1;\\n        }\\n        else if (target<nums[m])\\n        {\\n            e=m-1;\\n        }\\n\\n      \\n    }\\n    return {firstpos , secondpos};\\n\\n    }\\n}; "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n       \\n        int s = 0,e = nums.size()-1 , firstpos = -1,lastpos = -1;\\n        while(s<=e){\\n              int mid = s+(e-s)/2;\\n            if(nums[mid] == target){\\n                firstpos = mid;\\n                e = mid-1;\\n            }\\n              else if(nums[mid] >target)\\n               e = mid-1;\\n            \\n            else\\n                s = mid+1;\\n            \\n            \\n        }\\n         int  start = 0, end =nums.size()-1;\\n          while(start<=end){\\n              int mid = start+(end-start)/2;\\n              if(nums[mid] == target){\\n                  lastpos = mid;\\n                  start = mid+1;\\n              }\\n\\n                  else if(nums[mid]<  target)\\n                      start = mid+1;\\n            \\n                  else\\n                      end = mid-1;\\n                  \\n              }\\n              return{firstpos , lastpos};\\nthis is my code"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "For this particular solution we solve the problem with **Binary search**. The first step will be to find the target number (be it in any index) and store its location in a variable called **temp**. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector<int> ans and the final positions are returned. \\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned. "
                    }
                ]
            },
            {
                "id": 2009814,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "I\\'ve done in O(n) time but still my solution is accepting."
                    },
                    {
                        "username": "yashgaud15",
                        "content": "i dont know why is this showing up on leetcode, i am not facing any problem in my IDE\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int[] ret = new Solution().searchRange(param_1, param_2);\\n                      ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\ni dont know why is this showing up on leetcode, i am not facing any problem in my IDE"
                    },
                    {
                        "username": "harshjainsk531",
                        "content": "\n        \n\n        int first_occurence = -1;\n        int last_occurence  = - 1;\n        int start = 0;\n        int end = nums.size() -1;\n        int mid = start + (end - start) / 2;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                first_occurence = mid;\n                end = mid - 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        start = 0;\n        end = nums.size() -1;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                last_occurence = mid;\n                start = mid + 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        vector<int> ans {first_occurence, last_occurence};\n\n        return ans;\n\n\nCan anyone help me understand why y code is not working for input array [2, 2] and target = 3?"
                    },
                    {
                        "username": "sarashs",
                        "content": "Two binary searches for the left and the right side"
                    },
                    {
                        "username": "Nayab_Rasool",
                        "content": "I used binary search, its run time is accepted but it shows memory limit exceeded error what should i do?\\n"
                    },
                    {
                        "username": "kamalmodi",
                        "content": "class Solution {\\npublic:\\n    vector<int> firstsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                e=mid-1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n  return ans ;\\n    }\\n}\\n\\n\\nvector<int> lastsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                s=mid+1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n return ans;\\n    }\\n\\n   \\n\\n\\nint main(){\\n    vector<int> nums= {5,7,7,8,8,10};\\n\\n    int firstOccurrence = firstsearchRange(nums, 8, 6);\\n    int lastOccurrence = lastsearchRange(nums, 8, 6);\\n\\n    cout << \" First occurence is\" << firstsearchRange(nums, 8, 6) << endl ;\\n    cout << \" last occurence is\" << lastsearchRange(nums, 8, 6) << endl ;\\n    return 0;\\n}\\n\\nGuys  this is my code   im getting this error.. pls resolve \\nLine 7: Char 24: error: no viable conversion from \\'int\\' to \\'vector<int>\\'\\n          vector <int> ans= -1;"
                    },
                    {
                        "username": "hossain6857",
                        "content": "why the following test case is not valid? please explain.\\n[1 2 10 13 13]"
                    },
                    {
                        "username": "shivam_XDD",
                        "content": "this is my code it is throwing error \\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n please check and tell hwere i am wrong:)\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n   \\n  int firstpos=-1;\\n    while(nums.size()<=end)\\n    { int mid=start - (start+end)/2;\\n        if(nums[mid]==target)\\n        {\\n            firstpos=mid;\\n            end=mid-1;\\n\\n        }\\n\\n        else if(target>nums[mid])\\n        {\\n            start=mid+1;\\n        }\\n        else if (target<nums[mid])\\n        {\\n            end=mid-1;\\n        }\\n\\n      \\n    }\\n\\n      int s=0;\\n    int e=nums.size()-1;\\n   \\n   int secondpos=-1;\\n    while(nums.size()<=e)\\n    {\\n         int m=s - (s+e)/2;\\n        if(nums[m]==target)\\n        {\\n            secondpos=m;\\n            s=m+1;\\n\\n        }\\n\\n        else if(target>nums[m])\\n        {\\n            s=m+1;\\n        }\\n        else if (target<nums[m])\\n        {\\n            e=m-1;\\n        }\\n\\n      \\n    }\\n    return {firstpos , secondpos};\\n\\n    }\\n}; "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n       \\n        int s = 0,e = nums.size()-1 , firstpos = -1,lastpos = -1;\\n        while(s<=e){\\n              int mid = s+(e-s)/2;\\n            if(nums[mid] == target){\\n                firstpos = mid;\\n                e = mid-1;\\n            }\\n              else if(nums[mid] >target)\\n               e = mid-1;\\n            \\n            else\\n                s = mid+1;\\n            \\n            \\n        }\\n         int  start = 0, end =nums.size()-1;\\n          while(start<=end){\\n              int mid = start+(end-start)/2;\\n              if(nums[mid] == target){\\n                  lastpos = mid;\\n                  start = mid+1;\\n              }\\n\\n                  else if(nums[mid]<  target)\\n                      start = mid+1;\\n            \\n                  else\\n                      end = mid-1;\\n                  \\n              }\\n              return{firstpos , lastpos};\\nthis is my code"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "For this particular solution we solve the problem with **Binary search**. The first step will be to find the target number (be it in any index) and store its location in a variable called **temp**. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector<int> ans and the final positions are returned. \\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned. "
                    }
                ]
            },
            {
                "id": 2004590,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "I\\'ve done in O(n) time but still my solution is accepting."
                    },
                    {
                        "username": "yashgaud15",
                        "content": "i dont know why is this showing up on leetcode, i am not facing any problem in my IDE\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int[] ret = new Solution().searchRange(param_1, param_2);\\n                      ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\ni dont know why is this showing up on leetcode, i am not facing any problem in my IDE"
                    },
                    {
                        "username": "harshjainsk531",
                        "content": "\n        \n\n        int first_occurence = -1;\n        int last_occurence  = - 1;\n        int start = 0;\n        int end = nums.size() -1;\n        int mid = start + (end - start) / 2;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                first_occurence = mid;\n                end = mid - 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        start = 0;\n        end = nums.size() -1;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                last_occurence = mid;\n                start = mid + 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        vector<int> ans {first_occurence, last_occurence};\n\n        return ans;\n\n\nCan anyone help me understand why y code is not working for input array [2, 2] and target = 3?"
                    },
                    {
                        "username": "sarashs",
                        "content": "Two binary searches for the left and the right side"
                    },
                    {
                        "username": "Nayab_Rasool",
                        "content": "I used binary search, its run time is accepted but it shows memory limit exceeded error what should i do?\\n"
                    },
                    {
                        "username": "kamalmodi",
                        "content": "class Solution {\\npublic:\\n    vector<int> firstsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                e=mid-1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n  return ans ;\\n    }\\n}\\n\\n\\nvector<int> lastsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                s=mid+1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n return ans;\\n    }\\n\\n   \\n\\n\\nint main(){\\n    vector<int> nums= {5,7,7,8,8,10};\\n\\n    int firstOccurrence = firstsearchRange(nums, 8, 6);\\n    int lastOccurrence = lastsearchRange(nums, 8, 6);\\n\\n    cout << \" First occurence is\" << firstsearchRange(nums, 8, 6) << endl ;\\n    cout << \" last occurence is\" << lastsearchRange(nums, 8, 6) << endl ;\\n    return 0;\\n}\\n\\nGuys  this is my code   im getting this error.. pls resolve \\nLine 7: Char 24: error: no viable conversion from \\'int\\' to \\'vector<int>\\'\\n          vector <int> ans= -1;"
                    },
                    {
                        "username": "hossain6857",
                        "content": "why the following test case is not valid? please explain.\\n[1 2 10 13 13]"
                    },
                    {
                        "username": "shivam_XDD",
                        "content": "this is my code it is throwing error \\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n please check and tell hwere i am wrong:)\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n   \\n  int firstpos=-1;\\n    while(nums.size()<=end)\\n    { int mid=start - (start+end)/2;\\n        if(nums[mid]==target)\\n        {\\n            firstpos=mid;\\n            end=mid-1;\\n\\n        }\\n\\n        else if(target>nums[mid])\\n        {\\n            start=mid+1;\\n        }\\n        else if (target<nums[mid])\\n        {\\n            end=mid-1;\\n        }\\n\\n      \\n    }\\n\\n      int s=0;\\n    int e=nums.size()-1;\\n   \\n   int secondpos=-1;\\n    while(nums.size()<=e)\\n    {\\n         int m=s - (s+e)/2;\\n        if(nums[m]==target)\\n        {\\n            secondpos=m;\\n            s=m+1;\\n\\n        }\\n\\n        else if(target>nums[m])\\n        {\\n            s=m+1;\\n        }\\n        else if (target<nums[m])\\n        {\\n            e=m-1;\\n        }\\n\\n      \\n    }\\n    return {firstpos , secondpos};\\n\\n    }\\n}; "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n       \\n        int s = 0,e = nums.size()-1 , firstpos = -1,lastpos = -1;\\n        while(s<=e){\\n              int mid = s+(e-s)/2;\\n            if(nums[mid] == target){\\n                firstpos = mid;\\n                e = mid-1;\\n            }\\n              else if(nums[mid] >target)\\n               e = mid-1;\\n            \\n            else\\n                s = mid+1;\\n            \\n            \\n        }\\n         int  start = 0, end =nums.size()-1;\\n          while(start<=end){\\n              int mid = start+(end-start)/2;\\n              if(nums[mid] == target){\\n                  lastpos = mid;\\n                  start = mid+1;\\n              }\\n\\n                  else if(nums[mid]<  target)\\n                      start = mid+1;\\n            \\n                  else\\n                      end = mid-1;\\n                  \\n              }\\n              return{firstpos , lastpos};\\nthis is my code"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "For this particular solution we solve the problem with **Binary search**. The first step will be to find the target number (be it in any index) and store its location in a variable called **temp**. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector<int> ans and the final positions are returned. \\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned. "
                    }
                ]
            },
            {
                "id": 2003095,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "I\\'ve done in O(n) time but still my solution is accepting."
                    },
                    {
                        "username": "yashgaud15",
                        "content": "i dont know why is this showing up on leetcode, i am not facing any problem in my IDE\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int[] ret = new Solution().searchRange(param_1, param_2);\\n                      ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\ni dont know why is this showing up on leetcode, i am not facing any problem in my IDE"
                    },
                    {
                        "username": "harshjainsk531",
                        "content": "\n        \n\n        int first_occurence = -1;\n        int last_occurence  = - 1;\n        int start = 0;\n        int end = nums.size() -1;\n        int mid = start + (end - start) / 2;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                first_occurence = mid;\n                end = mid - 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        start = 0;\n        end = nums.size() -1;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                last_occurence = mid;\n                start = mid + 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        vector<int> ans {first_occurence, last_occurence};\n\n        return ans;\n\n\nCan anyone help me understand why y code is not working for input array [2, 2] and target = 3?"
                    },
                    {
                        "username": "sarashs",
                        "content": "Two binary searches for the left and the right side"
                    },
                    {
                        "username": "Nayab_Rasool",
                        "content": "I used binary search, its run time is accepted but it shows memory limit exceeded error what should i do?\\n"
                    },
                    {
                        "username": "kamalmodi",
                        "content": "class Solution {\\npublic:\\n    vector<int> firstsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                e=mid-1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n  return ans ;\\n    }\\n}\\n\\n\\nvector<int> lastsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                s=mid+1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n return ans;\\n    }\\n\\n   \\n\\n\\nint main(){\\n    vector<int> nums= {5,7,7,8,8,10};\\n\\n    int firstOccurrence = firstsearchRange(nums, 8, 6);\\n    int lastOccurrence = lastsearchRange(nums, 8, 6);\\n\\n    cout << \" First occurence is\" << firstsearchRange(nums, 8, 6) << endl ;\\n    cout << \" last occurence is\" << lastsearchRange(nums, 8, 6) << endl ;\\n    return 0;\\n}\\n\\nGuys  this is my code   im getting this error.. pls resolve \\nLine 7: Char 24: error: no viable conversion from \\'int\\' to \\'vector<int>\\'\\n          vector <int> ans= -1;"
                    },
                    {
                        "username": "hossain6857",
                        "content": "why the following test case is not valid? please explain.\\n[1 2 10 13 13]"
                    },
                    {
                        "username": "shivam_XDD",
                        "content": "this is my code it is throwing error \\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n please check and tell hwere i am wrong:)\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n   \\n  int firstpos=-1;\\n    while(nums.size()<=end)\\n    { int mid=start - (start+end)/2;\\n        if(nums[mid]==target)\\n        {\\n            firstpos=mid;\\n            end=mid-1;\\n\\n        }\\n\\n        else if(target>nums[mid])\\n        {\\n            start=mid+1;\\n        }\\n        else if (target<nums[mid])\\n        {\\n            end=mid-1;\\n        }\\n\\n      \\n    }\\n\\n      int s=0;\\n    int e=nums.size()-1;\\n   \\n   int secondpos=-1;\\n    while(nums.size()<=e)\\n    {\\n         int m=s - (s+e)/2;\\n        if(nums[m]==target)\\n        {\\n            secondpos=m;\\n            s=m+1;\\n\\n        }\\n\\n        else if(target>nums[m])\\n        {\\n            s=m+1;\\n        }\\n        else if (target<nums[m])\\n        {\\n            e=m-1;\\n        }\\n\\n      \\n    }\\n    return {firstpos , secondpos};\\n\\n    }\\n}; "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n       \\n        int s = 0,e = nums.size()-1 , firstpos = -1,lastpos = -1;\\n        while(s<=e){\\n              int mid = s+(e-s)/2;\\n            if(nums[mid] == target){\\n                firstpos = mid;\\n                e = mid-1;\\n            }\\n              else if(nums[mid] >target)\\n               e = mid-1;\\n            \\n            else\\n                s = mid+1;\\n            \\n            \\n        }\\n         int  start = 0, end =nums.size()-1;\\n          while(start<=end){\\n              int mid = start+(end-start)/2;\\n              if(nums[mid] == target){\\n                  lastpos = mid;\\n                  start = mid+1;\\n              }\\n\\n                  else if(nums[mid]<  target)\\n                      start = mid+1;\\n            \\n                  else\\n                      end = mid-1;\\n                  \\n              }\\n              return{firstpos , lastpos};\\nthis is my code"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "For this particular solution we solve the problem with **Binary search**. The first step will be to find the target number (be it in any index) and store its location in a variable called **temp**. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector<int> ans and the final positions are returned. \\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned. "
                    }
                ]
            },
            {
                "id": 1998096,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "I\\'ve done in O(n) time but still my solution is accepting."
                    },
                    {
                        "username": "yashgaud15",
                        "content": "i dont know why is this showing up on leetcode, i am not facing any problem in my IDE\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int[] ret = new Solution().searchRange(param_1, param_2);\\n                      ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\ni dont know why is this showing up on leetcode, i am not facing any problem in my IDE"
                    },
                    {
                        "username": "harshjainsk531",
                        "content": "\n        \n\n        int first_occurence = -1;\n        int last_occurence  = - 1;\n        int start = 0;\n        int end = nums.size() -1;\n        int mid = start + (end - start) / 2;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                first_occurence = mid;\n                end = mid - 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        start = 0;\n        end = nums.size() -1;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                last_occurence = mid;\n                start = mid + 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        vector<int> ans {first_occurence, last_occurence};\n\n        return ans;\n\n\nCan anyone help me understand why y code is not working for input array [2, 2] and target = 3?"
                    },
                    {
                        "username": "sarashs",
                        "content": "Two binary searches for the left and the right side"
                    },
                    {
                        "username": "Nayab_Rasool",
                        "content": "I used binary search, its run time is accepted but it shows memory limit exceeded error what should i do?\\n"
                    },
                    {
                        "username": "kamalmodi",
                        "content": "class Solution {\\npublic:\\n    vector<int> firstsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                e=mid-1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n  return ans ;\\n    }\\n}\\n\\n\\nvector<int> lastsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                s=mid+1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n return ans;\\n    }\\n\\n   \\n\\n\\nint main(){\\n    vector<int> nums= {5,7,7,8,8,10};\\n\\n    int firstOccurrence = firstsearchRange(nums, 8, 6);\\n    int lastOccurrence = lastsearchRange(nums, 8, 6);\\n\\n    cout << \" First occurence is\" << firstsearchRange(nums, 8, 6) << endl ;\\n    cout << \" last occurence is\" << lastsearchRange(nums, 8, 6) << endl ;\\n    return 0;\\n}\\n\\nGuys  this is my code   im getting this error.. pls resolve \\nLine 7: Char 24: error: no viable conversion from \\'int\\' to \\'vector<int>\\'\\n          vector <int> ans= -1;"
                    },
                    {
                        "username": "hossain6857",
                        "content": "why the following test case is not valid? please explain.\\n[1 2 10 13 13]"
                    },
                    {
                        "username": "shivam_XDD",
                        "content": "this is my code it is throwing error \\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n please check and tell hwere i am wrong:)\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n   \\n  int firstpos=-1;\\n    while(nums.size()<=end)\\n    { int mid=start - (start+end)/2;\\n        if(nums[mid]==target)\\n        {\\n            firstpos=mid;\\n            end=mid-1;\\n\\n        }\\n\\n        else if(target>nums[mid])\\n        {\\n            start=mid+1;\\n        }\\n        else if (target<nums[mid])\\n        {\\n            end=mid-1;\\n        }\\n\\n      \\n    }\\n\\n      int s=0;\\n    int e=nums.size()-1;\\n   \\n   int secondpos=-1;\\n    while(nums.size()<=e)\\n    {\\n         int m=s - (s+e)/2;\\n        if(nums[m]==target)\\n        {\\n            secondpos=m;\\n            s=m+1;\\n\\n        }\\n\\n        else if(target>nums[m])\\n        {\\n            s=m+1;\\n        }\\n        else if (target<nums[m])\\n        {\\n            e=m-1;\\n        }\\n\\n      \\n    }\\n    return {firstpos , secondpos};\\n\\n    }\\n}; "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n       \\n        int s = 0,e = nums.size()-1 , firstpos = -1,lastpos = -1;\\n        while(s<=e){\\n              int mid = s+(e-s)/2;\\n            if(nums[mid] == target){\\n                firstpos = mid;\\n                e = mid-1;\\n            }\\n              else if(nums[mid] >target)\\n               e = mid-1;\\n            \\n            else\\n                s = mid+1;\\n            \\n            \\n        }\\n         int  start = 0, end =nums.size()-1;\\n          while(start<=end){\\n              int mid = start+(end-start)/2;\\n              if(nums[mid] == target){\\n                  lastpos = mid;\\n                  start = mid+1;\\n              }\\n\\n                  else if(nums[mid]<  target)\\n                      start = mid+1;\\n            \\n                  else\\n                      end = mid-1;\\n                  \\n              }\\n              return{firstpos , lastpos};\\nthis is my code"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "For this particular solution we solve the problem with **Binary search**. The first step will be to find the target number (be it in any index) and store its location in a variable called **temp**. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector<int> ans and the final positions are returned. \\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned. "
                    }
                ]
            },
            {
                "id": 1986288,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "I\\'ve done in O(n) time but still my solution is accepting."
                    },
                    {
                        "username": "yashgaud15",
                        "content": "i dont know why is this showing up on leetcode, i am not facing any problem in my IDE\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int[] ret = new Solution().searchRange(param_1, param_2);\\n                      ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\ni dont know why is this showing up on leetcode, i am not facing any problem in my IDE"
                    },
                    {
                        "username": "harshjainsk531",
                        "content": "\n        \n\n        int first_occurence = -1;\n        int last_occurence  = - 1;\n        int start = 0;\n        int end = nums.size() -1;\n        int mid = start + (end - start) / 2;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                first_occurence = mid;\n                end = mid - 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        start = 0;\n        end = nums.size() -1;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                last_occurence = mid;\n                start = mid + 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        vector<int> ans {first_occurence, last_occurence};\n\n        return ans;\n\n\nCan anyone help me understand why y code is not working for input array [2, 2] and target = 3?"
                    },
                    {
                        "username": "sarashs",
                        "content": "Two binary searches for the left and the right side"
                    },
                    {
                        "username": "Nayab_Rasool",
                        "content": "I used binary search, its run time is accepted but it shows memory limit exceeded error what should i do?\\n"
                    },
                    {
                        "username": "kamalmodi",
                        "content": "class Solution {\\npublic:\\n    vector<int> firstsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                e=mid-1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n  return ans ;\\n    }\\n}\\n\\n\\nvector<int> lastsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                s=mid+1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n return ans;\\n    }\\n\\n   \\n\\n\\nint main(){\\n    vector<int> nums= {5,7,7,8,8,10};\\n\\n    int firstOccurrence = firstsearchRange(nums, 8, 6);\\n    int lastOccurrence = lastsearchRange(nums, 8, 6);\\n\\n    cout << \" First occurence is\" << firstsearchRange(nums, 8, 6) << endl ;\\n    cout << \" last occurence is\" << lastsearchRange(nums, 8, 6) << endl ;\\n    return 0;\\n}\\n\\nGuys  this is my code   im getting this error.. pls resolve \\nLine 7: Char 24: error: no viable conversion from \\'int\\' to \\'vector<int>\\'\\n          vector <int> ans= -1;"
                    },
                    {
                        "username": "hossain6857",
                        "content": "why the following test case is not valid? please explain.\\n[1 2 10 13 13]"
                    },
                    {
                        "username": "shivam_XDD",
                        "content": "this is my code it is throwing error \\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n please check and tell hwere i am wrong:)\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n   \\n  int firstpos=-1;\\n    while(nums.size()<=end)\\n    { int mid=start - (start+end)/2;\\n        if(nums[mid]==target)\\n        {\\n            firstpos=mid;\\n            end=mid-1;\\n\\n        }\\n\\n        else if(target>nums[mid])\\n        {\\n            start=mid+1;\\n        }\\n        else if (target<nums[mid])\\n        {\\n            end=mid-1;\\n        }\\n\\n      \\n    }\\n\\n      int s=0;\\n    int e=nums.size()-1;\\n   \\n   int secondpos=-1;\\n    while(nums.size()<=e)\\n    {\\n         int m=s - (s+e)/2;\\n        if(nums[m]==target)\\n        {\\n            secondpos=m;\\n            s=m+1;\\n\\n        }\\n\\n        else if(target>nums[m])\\n        {\\n            s=m+1;\\n        }\\n        else if (target<nums[m])\\n        {\\n            e=m-1;\\n        }\\n\\n      \\n    }\\n    return {firstpos , secondpos};\\n\\n    }\\n}; "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n       \\n        int s = 0,e = nums.size()-1 , firstpos = -1,lastpos = -1;\\n        while(s<=e){\\n              int mid = s+(e-s)/2;\\n            if(nums[mid] == target){\\n                firstpos = mid;\\n                e = mid-1;\\n            }\\n              else if(nums[mid] >target)\\n               e = mid-1;\\n            \\n            else\\n                s = mid+1;\\n            \\n            \\n        }\\n         int  start = 0, end =nums.size()-1;\\n          while(start<=end){\\n              int mid = start+(end-start)/2;\\n              if(nums[mid] == target){\\n                  lastpos = mid;\\n                  start = mid+1;\\n              }\\n\\n                  else if(nums[mid]<  target)\\n                      start = mid+1;\\n            \\n                  else\\n                      end = mid-1;\\n                  \\n              }\\n              return{firstpos , lastpos};\\nthis is my code"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "For this particular solution we solve the problem with **Binary search**. The first step will be to find the target number (be it in any index) and store its location in a variable called **temp**. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector<int> ans and the final positions are returned. \\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned. "
                    }
                ]
            },
            {
                "id": 1975915,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "I\\'ve done in O(n) time but still my solution is accepting."
                    },
                    {
                        "username": "yashgaud15",
                        "content": "i dont know why is this showing up on leetcode, i am not facing any problem in my IDE\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int[] ret = new Solution().searchRange(param_1, param_2);\\n                      ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\ni dont know why is this showing up on leetcode, i am not facing any problem in my IDE"
                    },
                    {
                        "username": "harshjainsk531",
                        "content": "\n        \n\n        int first_occurence = -1;\n        int last_occurence  = - 1;\n        int start = 0;\n        int end = nums.size() -1;\n        int mid = start + (end - start) / 2;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                first_occurence = mid;\n                end = mid - 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        start = 0;\n        end = nums.size() -1;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                last_occurence = mid;\n                start = mid + 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        vector<int> ans {first_occurence, last_occurence};\n\n        return ans;\n\n\nCan anyone help me understand why y code is not working for input array [2, 2] and target = 3?"
                    },
                    {
                        "username": "sarashs",
                        "content": "Two binary searches for the left and the right side"
                    },
                    {
                        "username": "Nayab_Rasool",
                        "content": "I used binary search, its run time is accepted but it shows memory limit exceeded error what should i do?\\n"
                    },
                    {
                        "username": "kamalmodi",
                        "content": "class Solution {\\npublic:\\n    vector<int> firstsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                e=mid-1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n  return ans ;\\n    }\\n}\\n\\n\\nvector<int> lastsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                s=mid+1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n return ans;\\n    }\\n\\n   \\n\\n\\nint main(){\\n    vector<int> nums= {5,7,7,8,8,10};\\n\\n    int firstOccurrence = firstsearchRange(nums, 8, 6);\\n    int lastOccurrence = lastsearchRange(nums, 8, 6);\\n\\n    cout << \" First occurence is\" << firstsearchRange(nums, 8, 6) << endl ;\\n    cout << \" last occurence is\" << lastsearchRange(nums, 8, 6) << endl ;\\n    return 0;\\n}\\n\\nGuys  this is my code   im getting this error.. pls resolve \\nLine 7: Char 24: error: no viable conversion from \\'int\\' to \\'vector<int>\\'\\n          vector <int> ans= -1;"
                    },
                    {
                        "username": "hossain6857",
                        "content": "why the following test case is not valid? please explain.\\n[1 2 10 13 13]"
                    },
                    {
                        "username": "shivam_XDD",
                        "content": "this is my code it is throwing error \\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n please check and tell hwere i am wrong:)\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n   \\n  int firstpos=-1;\\n    while(nums.size()<=end)\\n    { int mid=start - (start+end)/2;\\n        if(nums[mid]==target)\\n        {\\n            firstpos=mid;\\n            end=mid-1;\\n\\n        }\\n\\n        else if(target>nums[mid])\\n        {\\n            start=mid+1;\\n        }\\n        else if (target<nums[mid])\\n        {\\n            end=mid-1;\\n        }\\n\\n      \\n    }\\n\\n      int s=0;\\n    int e=nums.size()-1;\\n   \\n   int secondpos=-1;\\n    while(nums.size()<=e)\\n    {\\n         int m=s - (s+e)/2;\\n        if(nums[m]==target)\\n        {\\n            secondpos=m;\\n            s=m+1;\\n\\n        }\\n\\n        else if(target>nums[m])\\n        {\\n            s=m+1;\\n        }\\n        else if (target<nums[m])\\n        {\\n            e=m-1;\\n        }\\n\\n      \\n    }\\n    return {firstpos , secondpos};\\n\\n    }\\n}; "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n       \\n        int s = 0,e = nums.size()-1 , firstpos = -1,lastpos = -1;\\n        while(s<=e){\\n              int mid = s+(e-s)/2;\\n            if(nums[mid] == target){\\n                firstpos = mid;\\n                e = mid-1;\\n            }\\n              else if(nums[mid] >target)\\n               e = mid-1;\\n            \\n            else\\n                s = mid+1;\\n            \\n            \\n        }\\n         int  start = 0, end =nums.size()-1;\\n          while(start<=end){\\n              int mid = start+(end-start)/2;\\n              if(nums[mid] == target){\\n                  lastpos = mid;\\n                  start = mid+1;\\n              }\\n\\n                  else if(nums[mid]<  target)\\n                      start = mid+1;\\n            \\n                  else\\n                      end = mid-1;\\n                  \\n              }\\n              return{firstpos , lastpos};\\nthis is my code"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "For this particular solution we solve the problem with **Binary search**. The first step will be to find the target number (be it in any index) and store its location in a variable called **temp**. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector<int> ans and the final positions are returned. \\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned. "
                    }
                ]
            },
            {
                "id": 1975758,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "I\\'ve done in O(n) time but still my solution is accepting."
                    },
                    {
                        "username": "yashgaud15",
                        "content": "i dont know why is this showing up on leetcode, i am not facing any problem in my IDE\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int[] ret = new Solution().searchRange(param_1, param_2);\\n                      ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\ni dont know why is this showing up on leetcode, i am not facing any problem in my IDE"
                    },
                    {
                        "username": "harshjainsk531",
                        "content": "\n        \n\n        int first_occurence = -1;\n        int last_occurence  = - 1;\n        int start = 0;\n        int end = nums.size() -1;\n        int mid = start + (end - start) / 2;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                first_occurence = mid;\n                end = mid - 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        start = 0;\n        end = nums.size() -1;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                last_occurence = mid;\n                start = mid + 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        vector<int> ans {first_occurence, last_occurence};\n\n        return ans;\n\n\nCan anyone help me understand why y code is not working for input array [2, 2] and target = 3?"
                    },
                    {
                        "username": "sarashs",
                        "content": "Two binary searches for the left and the right side"
                    },
                    {
                        "username": "Nayab_Rasool",
                        "content": "I used binary search, its run time is accepted but it shows memory limit exceeded error what should i do?\\n"
                    },
                    {
                        "username": "kamalmodi",
                        "content": "class Solution {\\npublic:\\n    vector<int> firstsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                e=mid-1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n  return ans ;\\n    }\\n}\\n\\n\\nvector<int> lastsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                s=mid+1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n return ans;\\n    }\\n\\n   \\n\\n\\nint main(){\\n    vector<int> nums= {5,7,7,8,8,10};\\n\\n    int firstOccurrence = firstsearchRange(nums, 8, 6);\\n    int lastOccurrence = lastsearchRange(nums, 8, 6);\\n\\n    cout << \" First occurence is\" << firstsearchRange(nums, 8, 6) << endl ;\\n    cout << \" last occurence is\" << lastsearchRange(nums, 8, 6) << endl ;\\n    return 0;\\n}\\n\\nGuys  this is my code   im getting this error.. pls resolve \\nLine 7: Char 24: error: no viable conversion from \\'int\\' to \\'vector<int>\\'\\n          vector <int> ans= -1;"
                    },
                    {
                        "username": "hossain6857",
                        "content": "why the following test case is not valid? please explain.\\n[1 2 10 13 13]"
                    },
                    {
                        "username": "shivam_XDD",
                        "content": "this is my code it is throwing error \\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n please check and tell hwere i am wrong:)\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n   \\n  int firstpos=-1;\\n    while(nums.size()<=end)\\n    { int mid=start - (start+end)/2;\\n        if(nums[mid]==target)\\n        {\\n            firstpos=mid;\\n            end=mid-1;\\n\\n        }\\n\\n        else if(target>nums[mid])\\n        {\\n            start=mid+1;\\n        }\\n        else if (target<nums[mid])\\n        {\\n            end=mid-1;\\n        }\\n\\n      \\n    }\\n\\n      int s=0;\\n    int e=nums.size()-1;\\n   \\n   int secondpos=-1;\\n    while(nums.size()<=e)\\n    {\\n         int m=s - (s+e)/2;\\n        if(nums[m]==target)\\n        {\\n            secondpos=m;\\n            s=m+1;\\n\\n        }\\n\\n        else if(target>nums[m])\\n        {\\n            s=m+1;\\n        }\\n        else if (target<nums[m])\\n        {\\n            e=m-1;\\n        }\\n\\n      \\n    }\\n    return {firstpos , secondpos};\\n\\n    }\\n}; "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n       \\n        int s = 0,e = nums.size()-1 , firstpos = -1,lastpos = -1;\\n        while(s<=e){\\n              int mid = s+(e-s)/2;\\n            if(nums[mid] == target){\\n                firstpos = mid;\\n                e = mid-1;\\n            }\\n              else if(nums[mid] >target)\\n               e = mid-1;\\n            \\n            else\\n                s = mid+1;\\n            \\n            \\n        }\\n         int  start = 0, end =nums.size()-1;\\n          while(start<=end){\\n              int mid = start+(end-start)/2;\\n              if(nums[mid] == target){\\n                  lastpos = mid;\\n                  start = mid+1;\\n              }\\n\\n                  else if(nums[mid]<  target)\\n                      start = mid+1;\\n            \\n                  else\\n                      end = mid-1;\\n                  \\n              }\\n              return{firstpos , lastpos};\\nthis is my code"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "For this particular solution we solve the problem with **Binary search**. The first step will be to find the target number (be it in any index) and store its location in a variable called **temp**. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector<int> ans and the final positions are returned. \\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned. "
                    }
                ]
            },
            {
                "id": 1963886,
                "content": [
                    {
                        "username": "md_irfan_pr",
                        "content": "First we can solve with the help of linear search and time complexity will be O(n)\\nbut when wo apply the concept of binary search and solve with the better time complexity than previous one time complexity will be O(logn)."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "Whats wrong with this code ?? Can anyone suggest me...???\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target)  {\\n      vector<int> ans, no;\\n      no.push_back(-1);\\n      no.push_back(-1);\\n\\n      int start= 0;\\n      int end= nums.size();\\n      int mid= (start + end)/2;\\n      while(start<= end){\\n          if(nums[mid]==target){\\n              if(nums[mid+1]==target){\\n                  ans.push_back(mid);\\n                  ans.push_back(mid+1);\\n                  return ans;\\n              }\\n              else{\\n                  ans.push_back(mid);\\n                  ans.push_back(mid-1);\\n                  return ans;\\n              }\\n          }\\n          if(nums[mid]<target){\\n              start= mid+1;\\n          }\\n          else{\\n              end=mid-1;\\n          }\\n          mid= (start+end)/2;\\n      }\\n      return no;  \\n    }\\n\\n};"
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "[@userkaaname](/userkaaname)  \\nThanks buddy!, for figuring out my mistake . I modified the code and got correct answer.  "
                    },
                    {
                        "username": "userkaaname",
                        "content": "you are assuming that target number is only present in the array two times, however it is not written anywhere.\\nSo, let\\'s assume an array,\\n{1,2,4,4,4,5}\\nAccording to your solution, it will return position {2,3} but actual answer is {2,4}\\nKindly, Modify your code accordingly."
                    },
                    {
                        "username": "luvsharma105",
                        "content": "CAN SOMEBODY TELL ME WHAT IS THIS ERROR ABOUT.\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000003d0 overflowed to 0x6020000003cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "yashseth391",
                        "content": "I think they have given less information in question ."
                    },
                    {
                        "username": "akarshnayak",
                        "content": "Why am i getting a TLE?? my code is in O(logn) \\n `your inline code...your inline code...`\\nclass Solution {\\n    int searchStart(int[] nums,int target){\\n        int s=0;\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                e=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n    int searchEnd(int[] nums,int target,int s){\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                s=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return e;\\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] res=new int[2];\\n        res[0]=searchStart(nums,target);\\n        res[1]=searchEnd(nums,target,res[0]);\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditisharma37",
                        "content": "Can anyone tell me why is it not running ?\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> a;\\n        int start =0;\\n        int end = size(nums) -1;\\n        while(start <= end){\\n            int mid= (start + end)/2 ; \\n            if(nums[mid]== target ){\\n                int s=mid ,e=mid  ;\\n                while( nums[e] == target){\\n                    e++;\\n                }\\n                \\n                while( nums[s] == target){\\n                    s--;\\n                }\\n                a.push_back(s+1);\\n                a.push_back(e-1);\\n                return a;\\n            }\\n            else if( nums[mid] > target){\\n                end = mid -1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        a.push_back(-1);\\n        a.push_back(-1);\\n        return a;\\n    }\\n};\\n\\nIt\\'s giving Runtime Error \\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x00000034caab bp 0x7ffec3562630 sp 0x7ffec3562628\\nREAD of size 4 at 0x602000000434 thread T0\\n    #2 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000434 is located 0 bytes to the right of 4-byte region [0x602000000430,0x602000000434)\\nallocated by thread T0 here:\\n    #6 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8030: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8080: fa fa fd fa fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):"
                    },
                    {
                        "username": "userkaaname",
                        "content": "when target is matched with mid and then you find value of s & e, assume mid =0, then you are doing s-- that will decrease s value to -1 even if you are pushing s+1 in a, it will already generate overflow error because you can't compare nums[-1]==target in next iteration.\nhope you understand ;)"
                    },
                    {
                        "username": "aakashy810",
                        "content": "i write solution in O(n) time complexity and leetcode accepted this "
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Would checking for nums[mid+1] and nums[mid-1] still be logn? Since its sorted we can check the targets neighbor."
                    },
                    {
                        "username": "Anoop0522",
                        "content": "Can someone tell why does my lastIndexOf function giving me a wrong value for the index of \"0\" in the following question.... rest of the cases seems fine to me. Any explanation for my issue would be appreciated.\\n `class Solution {\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        StringBuilder r = new StringBuilder();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            r.append(nums[i]);\\n        }\\n        String w=r.toString();\\n        String y=\"\";\\n        y+=target;\\n        int a[]=new int[2];\\n         a[0]=w.indexOf(y);\\n         a[1]=w.lastIndexOf(y);\\n        return a;\\n    }\\n}`\\noutput console\\nnums[] = [0,0,0,0,1,2,3,3,4,5,6,6,7,8,8,8,9,9,10,10,11,11]\\ntarget = 0\\nexpected output = [0,3]\\nmy output = [0,21]\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Everyone, Need your help and input on the following test case:\\nnums =\\n[3,3,3]\\ntarget =\\n3\\nMy output is [0,1,2] but expected output is [0,2]. Why?\\nThanks in advance\\nKeep Coding :)"
                    },
                    {
                        "username": "xolotl2",
                        "content": "it only needs starting and ending indices of the target. 1 and any other middle value should be ignored "
                    }
                ]
            },
            {
                "id": 1945172,
                "content": [
                    {
                        "username": "md_irfan_pr",
                        "content": "First we can solve with the help of linear search and time complexity will be O(n)\\nbut when wo apply the concept of binary search and solve with the better time complexity than previous one time complexity will be O(logn)."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "Whats wrong with this code ?? Can anyone suggest me...???\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target)  {\\n      vector<int> ans, no;\\n      no.push_back(-1);\\n      no.push_back(-1);\\n\\n      int start= 0;\\n      int end= nums.size();\\n      int mid= (start + end)/2;\\n      while(start<= end){\\n          if(nums[mid]==target){\\n              if(nums[mid+1]==target){\\n                  ans.push_back(mid);\\n                  ans.push_back(mid+1);\\n                  return ans;\\n              }\\n              else{\\n                  ans.push_back(mid);\\n                  ans.push_back(mid-1);\\n                  return ans;\\n              }\\n          }\\n          if(nums[mid]<target){\\n              start= mid+1;\\n          }\\n          else{\\n              end=mid-1;\\n          }\\n          mid= (start+end)/2;\\n      }\\n      return no;  \\n    }\\n\\n};"
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "[@userkaaname](/userkaaname)  \\nThanks buddy!, for figuring out my mistake . I modified the code and got correct answer.  "
                    },
                    {
                        "username": "userkaaname",
                        "content": "you are assuming that target number is only present in the array two times, however it is not written anywhere.\\nSo, let\\'s assume an array,\\n{1,2,4,4,4,5}\\nAccording to your solution, it will return position {2,3} but actual answer is {2,4}\\nKindly, Modify your code accordingly."
                    },
                    {
                        "username": "luvsharma105",
                        "content": "CAN SOMEBODY TELL ME WHAT IS THIS ERROR ABOUT.\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000003d0 overflowed to 0x6020000003cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "yashseth391",
                        "content": "I think they have given less information in question ."
                    },
                    {
                        "username": "akarshnayak",
                        "content": "Why am i getting a TLE?? my code is in O(logn) \\n `your inline code...your inline code...`\\nclass Solution {\\n    int searchStart(int[] nums,int target){\\n        int s=0;\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                e=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n    int searchEnd(int[] nums,int target,int s){\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                s=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return e;\\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] res=new int[2];\\n        res[0]=searchStart(nums,target);\\n        res[1]=searchEnd(nums,target,res[0]);\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditisharma37",
                        "content": "Can anyone tell me why is it not running ?\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> a;\\n        int start =0;\\n        int end = size(nums) -1;\\n        while(start <= end){\\n            int mid= (start + end)/2 ; \\n            if(nums[mid]== target ){\\n                int s=mid ,e=mid  ;\\n                while( nums[e] == target){\\n                    e++;\\n                }\\n                \\n                while( nums[s] == target){\\n                    s--;\\n                }\\n                a.push_back(s+1);\\n                a.push_back(e-1);\\n                return a;\\n            }\\n            else if( nums[mid] > target){\\n                end = mid -1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        a.push_back(-1);\\n        a.push_back(-1);\\n        return a;\\n    }\\n};\\n\\nIt\\'s giving Runtime Error \\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x00000034caab bp 0x7ffec3562630 sp 0x7ffec3562628\\nREAD of size 4 at 0x602000000434 thread T0\\n    #2 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000434 is located 0 bytes to the right of 4-byte region [0x602000000430,0x602000000434)\\nallocated by thread T0 here:\\n    #6 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8030: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8080: fa fa fd fa fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):"
                    },
                    {
                        "username": "userkaaname",
                        "content": "when target is matched with mid and then you find value of s & e, assume mid =0, then you are doing s-- that will decrease s value to -1 even if you are pushing s+1 in a, it will already generate overflow error because you can't compare nums[-1]==target in next iteration.\nhope you understand ;)"
                    },
                    {
                        "username": "aakashy810",
                        "content": "i write solution in O(n) time complexity and leetcode accepted this "
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Would checking for nums[mid+1] and nums[mid-1] still be logn? Since its sorted we can check the targets neighbor."
                    },
                    {
                        "username": "Anoop0522",
                        "content": "Can someone tell why does my lastIndexOf function giving me a wrong value for the index of \"0\" in the following question.... rest of the cases seems fine to me. Any explanation for my issue would be appreciated.\\n `class Solution {\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        StringBuilder r = new StringBuilder();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            r.append(nums[i]);\\n        }\\n        String w=r.toString();\\n        String y=\"\";\\n        y+=target;\\n        int a[]=new int[2];\\n         a[0]=w.indexOf(y);\\n         a[1]=w.lastIndexOf(y);\\n        return a;\\n    }\\n}`\\noutput console\\nnums[] = [0,0,0,0,1,2,3,3,4,5,6,6,7,8,8,8,9,9,10,10,11,11]\\ntarget = 0\\nexpected output = [0,3]\\nmy output = [0,21]\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Everyone, Need your help and input on the following test case:\\nnums =\\n[3,3,3]\\ntarget =\\n3\\nMy output is [0,1,2] but expected output is [0,2]. Why?\\nThanks in advance\\nKeep Coding :)"
                    },
                    {
                        "username": "xolotl2",
                        "content": "it only needs starting and ending indices of the target. 1 and any other middle value should be ignored "
                    }
                ]
            },
            {
                "id": 1943867,
                "content": [
                    {
                        "username": "md_irfan_pr",
                        "content": "First we can solve with the help of linear search and time complexity will be O(n)\\nbut when wo apply the concept of binary search and solve with the better time complexity than previous one time complexity will be O(logn)."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "Whats wrong with this code ?? Can anyone suggest me...???\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target)  {\\n      vector<int> ans, no;\\n      no.push_back(-1);\\n      no.push_back(-1);\\n\\n      int start= 0;\\n      int end= nums.size();\\n      int mid= (start + end)/2;\\n      while(start<= end){\\n          if(nums[mid]==target){\\n              if(nums[mid+1]==target){\\n                  ans.push_back(mid);\\n                  ans.push_back(mid+1);\\n                  return ans;\\n              }\\n              else{\\n                  ans.push_back(mid);\\n                  ans.push_back(mid-1);\\n                  return ans;\\n              }\\n          }\\n          if(nums[mid]<target){\\n              start= mid+1;\\n          }\\n          else{\\n              end=mid-1;\\n          }\\n          mid= (start+end)/2;\\n      }\\n      return no;  \\n    }\\n\\n};"
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "[@userkaaname](/userkaaname)  \\nThanks buddy!, for figuring out my mistake . I modified the code and got correct answer.  "
                    },
                    {
                        "username": "userkaaname",
                        "content": "you are assuming that target number is only present in the array two times, however it is not written anywhere.\\nSo, let\\'s assume an array,\\n{1,2,4,4,4,5}\\nAccording to your solution, it will return position {2,3} but actual answer is {2,4}\\nKindly, Modify your code accordingly."
                    },
                    {
                        "username": "luvsharma105",
                        "content": "CAN SOMEBODY TELL ME WHAT IS THIS ERROR ABOUT.\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000003d0 overflowed to 0x6020000003cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "yashseth391",
                        "content": "I think they have given less information in question ."
                    },
                    {
                        "username": "akarshnayak",
                        "content": "Why am i getting a TLE?? my code is in O(logn) \\n `your inline code...your inline code...`\\nclass Solution {\\n    int searchStart(int[] nums,int target){\\n        int s=0;\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                e=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n    int searchEnd(int[] nums,int target,int s){\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                s=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return e;\\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] res=new int[2];\\n        res[0]=searchStart(nums,target);\\n        res[1]=searchEnd(nums,target,res[0]);\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditisharma37",
                        "content": "Can anyone tell me why is it not running ?\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> a;\\n        int start =0;\\n        int end = size(nums) -1;\\n        while(start <= end){\\n            int mid= (start + end)/2 ; \\n            if(nums[mid]== target ){\\n                int s=mid ,e=mid  ;\\n                while( nums[e] == target){\\n                    e++;\\n                }\\n                \\n                while( nums[s] == target){\\n                    s--;\\n                }\\n                a.push_back(s+1);\\n                a.push_back(e-1);\\n                return a;\\n            }\\n            else if( nums[mid] > target){\\n                end = mid -1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        a.push_back(-1);\\n        a.push_back(-1);\\n        return a;\\n    }\\n};\\n\\nIt\\'s giving Runtime Error \\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x00000034caab bp 0x7ffec3562630 sp 0x7ffec3562628\\nREAD of size 4 at 0x602000000434 thread T0\\n    #2 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000434 is located 0 bytes to the right of 4-byte region [0x602000000430,0x602000000434)\\nallocated by thread T0 here:\\n    #6 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8030: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8080: fa fa fd fa fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):"
                    },
                    {
                        "username": "userkaaname",
                        "content": "when target is matched with mid and then you find value of s & e, assume mid =0, then you are doing s-- that will decrease s value to -1 even if you are pushing s+1 in a, it will already generate overflow error because you can't compare nums[-1]==target in next iteration.\nhope you understand ;)"
                    },
                    {
                        "username": "aakashy810",
                        "content": "i write solution in O(n) time complexity and leetcode accepted this "
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Would checking for nums[mid+1] and nums[mid-1] still be logn? Since its sorted we can check the targets neighbor."
                    },
                    {
                        "username": "Anoop0522",
                        "content": "Can someone tell why does my lastIndexOf function giving me a wrong value for the index of \"0\" in the following question.... rest of the cases seems fine to me. Any explanation for my issue would be appreciated.\\n `class Solution {\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        StringBuilder r = new StringBuilder();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            r.append(nums[i]);\\n        }\\n        String w=r.toString();\\n        String y=\"\";\\n        y+=target;\\n        int a[]=new int[2];\\n         a[0]=w.indexOf(y);\\n         a[1]=w.lastIndexOf(y);\\n        return a;\\n    }\\n}`\\noutput console\\nnums[] = [0,0,0,0,1,2,3,3,4,5,6,6,7,8,8,8,9,9,10,10,11,11]\\ntarget = 0\\nexpected output = [0,3]\\nmy output = [0,21]\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Everyone, Need your help and input on the following test case:\\nnums =\\n[3,3,3]\\ntarget =\\n3\\nMy output is [0,1,2] but expected output is [0,2]. Why?\\nThanks in advance\\nKeep Coding :)"
                    },
                    {
                        "username": "xolotl2",
                        "content": "it only needs starting and ending indices of the target. 1 and any other middle value should be ignored "
                    }
                ]
            },
            {
                "id": 1941237,
                "content": [
                    {
                        "username": "md_irfan_pr",
                        "content": "First we can solve with the help of linear search and time complexity will be O(n)\\nbut when wo apply the concept of binary search and solve with the better time complexity than previous one time complexity will be O(logn)."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "Whats wrong with this code ?? Can anyone suggest me...???\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target)  {\\n      vector<int> ans, no;\\n      no.push_back(-1);\\n      no.push_back(-1);\\n\\n      int start= 0;\\n      int end= nums.size();\\n      int mid= (start + end)/2;\\n      while(start<= end){\\n          if(nums[mid]==target){\\n              if(nums[mid+1]==target){\\n                  ans.push_back(mid);\\n                  ans.push_back(mid+1);\\n                  return ans;\\n              }\\n              else{\\n                  ans.push_back(mid);\\n                  ans.push_back(mid-1);\\n                  return ans;\\n              }\\n          }\\n          if(nums[mid]<target){\\n              start= mid+1;\\n          }\\n          else{\\n              end=mid-1;\\n          }\\n          mid= (start+end)/2;\\n      }\\n      return no;  \\n    }\\n\\n};"
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "[@userkaaname](/userkaaname)  \\nThanks buddy!, for figuring out my mistake . I modified the code and got correct answer.  "
                    },
                    {
                        "username": "userkaaname",
                        "content": "you are assuming that target number is only present in the array two times, however it is not written anywhere.\\nSo, let\\'s assume an array,\\n{1,2,4,4,4,5}\\nAccording to your solution, it will return position {2,3} but actual answer is {2,4}\\nKindly, Modify your code accordingly."
                    },
                    {
                        "username": "luvsharma105",
                        "content": "CAN SOMEBODY TELL ME WHAT IS THIS ERROR ABOUT.\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000003d0 overflowed to 0x6020000003cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "yashseth391",
                        "content": "I think they have given less information in question ."
                    },
                    {
                        "username": "akarshnayak",
                        "content": "Why am i getting a TLE?? my code is in O(logn) \\n `your inline code...your inline code...`\\nclass Solution {\\n    int searchStart(int[] nums,int target){\\n        int s=0;\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                e=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n    int searchEnd(int[] nums,int target,int s){\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                s=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return e;\\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] res=new int[2];\\n        res[0]=searchStart(nums,target);\\n        res[1]=searchEnd(nums,target,res[0]);\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditisharma37",
                        "content": "Can anyone tell me why is it not running ?\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> a;\\n        int start =0;\\n        int end = size(nums) -1;\\n        while(start <= end){\\n            int mid= (start + end)/2 ; \\n            if(nums[mid]== target ){\\n                int s=mid ,e=mid  ;\\n                while( nums[e] == target){\\n                    e++;\\n                }\\n                \\n                while( nums[s] == target){\\n                    s--;\\n                }\\n                a.push_back(s+1);\\n                a.push_back(e-1);\\n                return a;\\n            }\\n            else if( nums[mid] > target){\\n                end = mid -1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        a.push_back(-1);\\n        a.push_back(-1);\\n        return a;\\n    }\\n};\\n\\nIt\\'s giving Runtime Error \\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x00000034caab bp 0x7ffec3562630 sp 0x7ffec3562628\\nREAD of size 4 at 0x602000000434 thread T0\\n    #2 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000434 is located 0 bytes to the right of 4-byte region [0x602000000430,0x602000000434)\\nallocated by thread T0 here:\\n    #6 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8030: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8080: fa fa fd fa fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):"
                    },
                    {
                        "username": "userkaaname",
                        "content": "when target is matched with mid and then you find value of s & e, assume mid =0, then you are doing s-- that will decrease s value to -1 even if you are pushing s+1 in a, it will already generate overflow error because you can't compare nums[-1]==target in next iteration.\nhope you understand ;)"
                    },
                    {
                        "username": "aakashy810",
                        "content": "i write solution in O(n) time complexity and leetcode accepted this "
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Would checking for nums[mid+1] and nums[mid-1] still be logn? Since its sorted we can check the targets neighbor."
                    },
                    {
                        "username": "Anoop0522",
                        "content": "Can someone tell why does my lastIndexOf function giving me a wrong value for the index of \"0\" in the following question.... rest of the cases seems fine to me. Any explanation for my issue would be appreciated.\\n `class Solution {\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        StringBuilder r = new StringBuilder();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            r.append(nums[i]);\\n        }\\n        String w=r.toString();\\n        String y=\"\";\\n        y+=target;\\n        int a[]=new int[2];\\n         a[0]=w.indexOf(y);\\n         a[1]=w.lastIndexOf(y);\\n        return a;\\n    }\\n}`\\noutput console\\nnums[] = [0,0,0,0,1,2,3,3,4,5,6,6,7,8,8,8,9,9,10,10,11,11]\\ntarget = 0\\nexpected output = [0,3]\\nmy output = [0,21]\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Everyone, Need your help and input on the following test case:\\nnums =\\n[3,3,3]\\ntarget =\\n3\\nMy output is [0,1,2] but expected output is [0,2]. Why?\\nThanks in advance\\nKeep Coding :)"
                    },
                    {
                        "username": "xolotl2",
                        "content": "it only needs starting and ending indices of the target. 1 and any other middle value should be ignored "
                    }
                ]
            },
            {
                "id": 1933372,
                "content": [
                    {
                        "username": "md_irfan_pr",
                        "content": "First we can solve with the help of linear search and time complexity will be O(n)\\nbut when wo apply the concept of binary search and solve with the better time complexity than previous one time complexity will be O(logn)."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "Whats wrong with this code ?? Can anyone suggest me...???\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target)  {\\n      vector<int> ans, no;\\n      no.push_back(-1);\\n      no.push_back(-1);\\n\\n      int start= 0;\\n      int end= nums.size();\\n      int mid= (start + end)/2;\\n      while(start<= end){\\n          if(nums[mid]==target){\\n              if(nums[mid+1]==target){\\n                  ans.push_back(mid);\\n                  ans.push_back(mid+1);\\n                  return ans;\\n              }\\n              else{\\n                  ans.push_back(mid);\\n                  ans.push_back(mid-1);\\n                  return ans;\\n              }\\n          }\\n          if(nums[mid]<target){\\n              start= mid+1;\\n          }\\n          else{\\n              end=mid-1;\\n          }\\n          mid= (start+end)/2;\\n      }\\n      return no;  \\n    }\\n\\n};"
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "[@userkaaname](/userkaaname)  \\nThanks buddy!, for figuring out my mistake . I modified the code and got correct answer.  "
                    },
                    {
                        "username": "userkaaname",
                        "content": "you are assuming that target number is only present in the array two times, however it is not written anywhere.\\nSo, let\\'s assume an array,\\n{1,2,4,4,4,5}\\nAccording to your solution, it will return position {2,3} but actual answer is {2,4}\\nKindly, Modify your code accordingly."
                    },
                    {
                        "username": "luvsharma105",
                        "content": "CAN SOMEBODY TELL ME WHAT IS THIS ERROR ABOUT.\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000003d0 overflowed to 0x6020000003cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "yashseth391",
                        "content": "I think they have given less information in question ."
                    },
                    {
                        "username": "akarshnayak",
                        "content": "Why am i getting a TLE?? my code is in O(logn) \\n `your inline code...your inline code...`\\nclass Solution {\\n    int searchStart(int[] nums,int target){\\n        int s=0;\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                e=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n    int searchEnd(int[] nums,int target,int s){\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                s=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return e;\\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] res=new int[2];\\n        res[0]=searchStart(nums,target);\\n        res[1]=searchEnd(nums,target,res[0]);\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditisharma37",
                        "content": "Can anyone tell me why is it not running ?\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> a;\\n        int start =0;\\n        int end = size(nums) -1;\\n        while(start <= end){\\n            int mid= (start + end)/2 ; \\n            if(nums[mid]== target ){\\n                int s=mid ,e=mid  ;\\n                while( nums[e] == target){\\n                    e++;\\n                }\\n                \\n                while( nums[s] == target){\\n                    s--;\\n                }\\n                a.push_back(s+1);\\n                a.push_back(e-1);\\n                return a;\\n            }\\n            else if( nums[mid] > target){\\n                end = mid -1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        a.push_back(-1);\\n        a.push_back(-1);\\n        return a;\\n    }\\n};\\n\\nIt\\'s giving Runtime Error \\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x00000034caab bp 0x7ffec3562630 sp 0x7ffec3562628\\nREAD of size 4 at 0x602000000434 thread T0\\n    #2 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000434 is located 0 bytes to the right of 4-byte region [0x602000000430,0x602000000434)\\nallocated by thread T0 here:\\n    #6 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8030: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8080: fa fa fd fa fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):"
                    },
                    {
                        "username": "userkaaname",
                        "content": "when target is matched with mid and then you find value of s & e, assume mid =0, then you are doing s-- that will decrease s value to -1 even if you are pushing s+1 in a, it will already generate overflow error because you can't compare nums[-1]==target in next iteration.\nhope you understand ;)"
                    },
                    {
                        "username": "aakashy810",
                        "content": "i write solution in O(n) time complexity and leetcode accepted this "
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Would checking for nums[mid+1] and nums[mid-1] still be logn? Since its sorted we can check the targets neighbor."
                    },
                    {
                        "username": "Anoop0522",
                        "content": "Can someone tell why does my lastIndexOf function giving me a wrong value for the index of \"0\" in the following question.... rest of the cases seems fine to me. Any explanation for my issue would be appreciated.\\n `class Solution {\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        StringBuilder r = new StringBuilder();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            r.append(nums[i]);\\n        }\\n        String w=r.toString();\\n        String y=\"\";\\n        y+=target;\\n        int a[]=new int[2];\\n         a[0]=w.indexOf(y);\\n         a[1]=w.lastIndexOf(y);\\n        return a;\\n    }\\n}`\\noutput console\\nnums[] = [0,0,0,0,1,2,3,3,4,5,6,6,7,8,8,8,9,9,10,10,11,11]\\ntarget = 0\\nexpected output = [0,3]\\nmy output = [0,21]\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Everyone, Need your help and input on the following test case:\\nnums =\\n[3,3,3]\\ntarget =\\n3\\nMy output is [0,1,2] but expected output is [0,2]. Why?\\nThanks in advance\\nKeep Coding :)"
                    },
                    {
                        "username": "xolotl2",
                        "content": "it only needs starting and ending indices of the target. 1 and any other middle value should be ignored "
                    }
                ]
            },
            {
                "id": 1920938,
                "content": [
                    {
                        "username": "md_irfan_pr",
                        "content": "First we can solve with the help of linear search and time complexity will be O(n)\\nbut when wo apply the concept of binary search and solve with the better time complexity than previous one time complexity will be O(logn)."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "Whats wrong with this code ?? Can anyone suggest me...???\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target)  {\\n      vector<int> ans, no;\\n      no.push_back(-1);\\n      no.push_back(-1);\\n\\n      int start= 0;\\n      int end= nums.size();\\n      int mid= (start + end)/2;\\n      while(start<= end){\\n          if(nums[mid]==target){\\n              if(nums[mid+1]==target){\\n                  ans.push_back(mid);\\n                  ans.push_back(mid+1);\\n                  return ans;\\n              }\\n              else{\\n                  ans.push_back(mid);\\n                  ans.push_back(mid-1);\\n                  return ans;\\n              }\\n          }\\n          if(nums[mid]<target){\\n              start= mid+1;\\n          }\\n          else{\\n              end=mid-1;\\n          }\\n          mid= (start+end)/2;\\n      }\\n      return no;  \\n    }\\n\\n};"
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "[@userkaaname](/userkaaname)  \\nThanks buddy!, for figuring out my mistake . I modified the code and got correct answer.  "
                    },
                    {
                        "username": "userkaaname",
                        "content": "you are assuming that target number is only present in the array two times, however it is not written anywhere.\\nSo, let\\'s assume an array,\\n{1,2,4,4,4,5}\\nAccording to your solution, it will return position {2,3} but actual answer is {2,4}\\nKindly, Modify your code accordingly."
                    },
                    {
                        "username": "luvsharma105",
                        "content": "CAN SOMEBODY TELL ME WHAT IS THIS ERROR ABOUT.\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000003d0 overflowed to 0x6020000003cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "yashseth391",
                        "content": "I think they have given less information in question ."
                    },
                    {
                        "username": "akarshnayak",
                        "content": "Why am i getting a TLE?? my code is in O(logn) \\n `your inline code...your inline code...`\\nclass Solution {\\n    int searchStart(int[] nums,int target){\\n        int s=0;\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                e=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n    int searchEnd(int[] nums,int target,int s){\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                s=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return e;\\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] res=new int[2];\\n        res[0]=searchStart(nums,target);\\n        res[1]=searchEnd(nums,target,res[0]);\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditisharma37",
                        "content": "Can anyone tell me why is it not running ?\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> a;\\n        int start =0;\\n        int end = size(nums) -1;\\n        while(start <= end){\\n            int mid= (start + end)/2 ; \\n            if(nums[mid]== target ){\\n                int s=mid ,e=mid  ;\\n                while( nums[e] == target){\\n                    e++;\\n                }\\n                \\n                while( nums[s] == target){\\n                    s--;\\n                }\\n                a.push_back(s+1);\\n                a.push_back(e-1);\\n                return a;\\n            }\\n            else if( nums[mid] > target){\\n                end = mid -1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        a.push_back(-1);\\n        a.push_back(-1);\\n        return a;\\n    }\\n};\\n\\nIt\\'s giving Runtime Error \\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x00000034caab bp 0x7ffec3562630 sp 0x7ffec3562628\\nREAD of size 4 at 0x602000000434 thread T0\\n    #2 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000434 is located 0 bytes to the right of 4-byte region [0x602000000430,0x602000000434)\\nallocated by thread T0 here:\\n    #6 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8030: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8080: fa fa fd fa fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):"
                    },
                    {
                        "username": "userkaaname",
                        "content": "when target is matched with mid and then you find value of s & e, assume mid =0, then you are doing s-- that will decrease s value to -1 even if you are pushing s+1 in a, it will already generate overflow error because you can't compare nums[-1]==target in next iteration.\nhope you understand ;)"
                    },
                    {
                        "username": "aakashy810",
                        "content": "i write solution in O(n) time complexity and leetcode accepted this "
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Would checking for nums[mid+1] and nums[mid-1] still be logn? Since its sorted we can check the targets neighbor."
                    },
                    {
                        "username": "Anoop0522",
                        "content": "Can someone tell why does my lastIndexOf function giving me a wrong value for the index of \"0\" in the following question.... rest of the cases seems fine to me. Any explanation for my issue would be appreciated.\\n `class Solution {\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        StringBuilder r = new StringBuilder();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            r.append(nums[i]);\\n        }\\n        String w=r.toString();\\n        String y=\"\";\\n        y+=target;\\n        int a[]=new int[2];\\n         a[0]=w.indexOf(y);\\n         a[1]=w.lastIndexOf(y);\\n        return a;\\n    }\\n}`\\noutput console\\nnums[] = [0,0,0,0,1,2,3,3,4,5,6,6,7,8,8,8,9,9,10,10,11,11]\\ntarget = 0\\nexpected output = [0,3]\\nmy output = [0,21]\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Everyone, Need your help and input on the following test case:\\nnums =\\n[3,3,3]\\ntarget =\\n3\\nMy output is [0,1,2] but expected output is [0,2]. Why?\\nThanks in advance\\nKeep Coding :)"
                    },
                    {
                        "username": "xolotl2",
                        "content": "it only needs starting and ending indices of the target. 1 and any other middle value should be ignored "
                    }
                ]
            },
            {
                "id": 1878564,
                "content": [
                    {
                        "username": "md_irfan_pr",
                        "content": "First we can solve with the help of linear search and time complexity will be O(n)\\nbut when wo apply the concept of binary search and solve with the better time complexity than previous one time complexity will be O(logn)."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "Whats wrong with this code ?? Can anyone suggest me...???\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target)  {\\n      vector<int> ans, no;\\n      no.push_back(-1);\\n      no.push_back(-1);\\n\\n      int start= 0;\\n      int end= nums.size();\\n      int mid= (start + end)/2;\\n      while(start<= end){\\n          if(nums[mid]==target){\\n              if(nums[mid+1]==target){\\n                  ans.push_back(mid);\\n                  ans.push_back(mid+1);\\n                  return ans;\\n              }\\n              else{\\n                  ans.push_back(mid);\\n                  ans.push_back(mid-1);\\n                  return ans;\\n              }\\n          }\\n          if(nums[mid]<target){\\n              start= mid+1;\\n          }\\n          else{\\n              end=mid-1;\\n          }\\n          mid= (start+end)/2;\\n      }\\n      return no;  \\n    }\\n\\n};"
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "[@userkaaname](/userkaaname)  \\nThanks buddy!, for figuring out my mistake . I modified the code and got correct answer.  "
                    },
                    {
                        "username": "userkaaname",
                        "content": "you are assuming that target number is only present in the array two times, however it is not written anywhere.\\nSo, let\\'s assume an array,\\n{1,2,4,4,4,5}\\nAccording to your solution, it will return position {2,3} but actual answer is {2,4}\\nKindly, Modify your code accordingly."
                    },
                    {
                        "username": "luvsharma105",
                        "content": "CAN SOMEBODY TELL ME WHAT IS THIS ERROR ABOUT.\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000003d0 overflowed to 0x6020000003cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "yashseth391",
                        "content": "I think they have given less information in question ."
                    },
                    {
                        "username": "akarshnayak",
                        "content": "Why am i getting a TLE?? my code is in O(logn) \\n `your inline code...your inline code...`\\nclass Solution {\\n    int searchStart(int[] nums,int target){\\n        int s=0;\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                e=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n    int searchEnd(int[] nums,int target,int s){\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                s=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return e;\\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] res=new int[2];\\n        res[0]=searchStart(nums,target);\\n        res[1]=searchEnd(nums,target,res[0]);\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditisharma37",
                        "content": "Can anyone tell me why is it not running ?\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> a;\\n        int start =0;\\n        int end = size(nums) -1;\\n        while(start <= end){\\n            int mid= (start + end)/2 ; \\n            if(nums[mid]== target ){\\n                int s=mid ,e=mid  ;\\n                while( nums[e] == target){\\n                    e++;\\n                }\\n                \\n                while( nums[s] == target){\\n                    s--;\\n                }\\n                a.push_back(s+1);\\n                a.push_back(e-1);\\n                return a;\\n            }\\n            else if( nums[mid] > target){\\n                end = mid -1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        a.push_back(-1);\\n        a.push_back(-1);\\n        return a;\\n    }\\n};\\n\\nIt\\'s giving Runtime Error \\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x00000034caab bp 0x7ffec3562630 sp 0x7ffec3562628\\nREAD of size 4 at 0x602000000434 thread T0\\n    #2 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000434 is located 0 bytes to the right of 4-byte region [0x602000000430,0x602000000434)\\nallocated by thread T0 here:\\n    #6 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8030: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8080: fa fa fd fa fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):"
                    },
                    {
                        "username": "userkaaname",
                        "content": "when target is matched with mid and then you find value of s & e, assume mid =0, then you are doing s-- that will decrease s value to -1 even if you are pushing s+1 in a, it will already generate overflow error because you can't compare nums[-1]==target in next iteration.\nhope you understand ;)"
                    },
                    {
                        "username": "aakashy810",
                        "content": "i write solution in O(n) time complexity and leetcode accepted this "
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Would checking for nums[mid+1] and nums[mid-1] still be logn? Since its sorted we can check the targets neighbor."
                    },
                    {
                        "username": "Anoop0522",
                        "content": "Can someone tell why does my lastIndexOf function giving me a wrong value for the index of \"0\" in the following question.... rest of the cases seems fine to me. Any explanation for my issue would be appreciated.\\n `class Solution {\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        StringBuilder r = new StringBuilder();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            r.append(nums[i]);\\n        }\\n        String w=r.toString();\\n        String y=\"\";\\n        y+=target;\\n        int a[]=new int[2];\\n         a[0]=w.indexOf(y);\\n         a[1]=w.lastIndexOf(y);\\n        return a;\\n    }\\n}`\\noutput console\\nnums[] = [0,0,0,0,1,2,3,3,4,5,6,6,7,8,8,8,9,9,10,10,11,11]\\ntarget = 0\\nexpected output = [0,3]\\nmy output = [0,21]\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Everyone, Need your help and input on the following test case:\\nnums =\\n[3,3,3]\\ntarget =\\n3\\nMy output is [0,1,2] but expected output is [0,2]. Why?\\nThanks in advance\\nKeep Coding :)"
                    },
                    {
                        "username": "xolotl2",
                        "content": "it only needs starting and ending indices of the target. 1 and any other middle value should be ignored "
                    }
                ]
            },
            {
                "id": 1869035,
                "content": [
                    {
                        "username": "md_irfan_pr",
                        "content": "First we can solve with the help of linear search and time complexity will be O(n)\\nbut when wo apply the concept of binary search and solve with the better time complexity than previous one time complexity will be O(logn)."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "Whats wrong with this code ?? Can anyone suggest me...???\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target)  {\\n      vector<int> ans, no;\\n      no.push_back(-1);\\n      no.push_back(-1);\\n\\n      int start= 0;\\n      int end= nums.size();\\n      int mid= (start + end)/2;\\n      while(start<= end){\\n          if(nums[mid]==target){\\n              if(nums[mid+1]==target){\\n                  ans.push_back(mid);\\n                  ans.push_back(mid+1);\\n                  return ans;\\n              }\\n              else{\\n                  ans.push_back(mid);\\n                  ans.push_back(mid-1);\\n                  return ans;\\n              }\\n          }\\n          if(nums[mid]<target){\\n              start= mid+1;\\n          }\\n          else{\\n              end=mid-1;\\n          }\\n          mid= (start+end)/2;\\n      }\\n      return no;  \\n    }\\n\\n};"
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "[@userkaaname](/userkaaname)  \\nThanks buddy!, for figuring out my mistake . I modified the code and got correct answer.  "
                    },
                    {
                        "username": "userkaaname",
                        "content": "you are assuming that target number is only present in the array two times, however it is not written anywhere.\\nSo, let\\'s assume an array,\\n{1,2,4,4,4,5}\\nAccording to your solution, it will return position {2,3} but actual answer is {2,4}\\nKindly, Modify your code accordingly."
                    },
                    {
                        "username": "luvsharma105",
                        "content": "CAN SOMEBODY TELL ME WHAT IS THIS ERROR ABOUT.\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000003d0 overflowed to 0x6020000003cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "yashseth391",
                        "content": "I think they have given less information in question ."
                    },
                    {
                        "username": "akarshnayak",
                        "content": "Why am i getting a TLE?? my code is in O(logn) \\n `your inline code...your inline code...`\\nclass Solution {\\n    int searchStart(int[] nums,int target){\\n        int s=0;\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                e=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n    int searchEnd(int[] nums,int target,int s){\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                s=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return e;\\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] res=new int[2];\\n        res[0]=searchStart(nums,target);\\n        res[1]=searchEnd(nums,target,res[0]);\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditisharma37",
                        "content": "Can anyone tell me why is it not running ?\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> a;\\n        int start =0;\\n        int end = size(nums) -1;\\n        while(start <= end){\\n            int mid= (start + end)/2 ; \\n            if(nums[mid]== target ){\\n                int s=mid ,e=mid  ;\\n                while( nums[e] == target){\\n                    e++;\\n                }\\n                \\n                while( nums[s] == target){\\n                    s--;\\n                }\\n                a.push_back(s+1);\\n                a.push_back(e-1);\\n                return a;\\n            }\\n            else if( nums[mid] > target){\\n                end = mid -1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        a.push_back(-1);\\n        a.push_back(-1);\\n        return a;\\n    }\\n};\\n\\nIt\\'s giving Runtime Error \\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x00000034caab bp 0x7ffec3562630 sp 0x7ffec3562628\\nREAD of size 4 at 0x602000000434 thread T0\\n    #2 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000434 is located 0 bytes to the right of 4-byte region [0x602000000430,0x602000000434)\\nallocated by thread T0 here:\\n    #6 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8030: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8080: fa fa fd fa fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):"
                    },
                    {
                        "username": "userkaaname",
                        "content": "when target is matched with mid and then you find value of s & e, assume mid =0, then you are doing s-- that will decrease s value to -1 even if you are pushing s+1 in a, it will already generate overflow error because you can't compare nums[-1]==target in next iteration.\nhope you understand ;)"
                    },
                    {
                        "username": "aakashy810",
                        "content": "i write solution in O(n) time complexity and leetcode accepted this "
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Would checking for nums[mid+1] and nums[mid-1] still be logn? Since its sorted we can check the targets neighbor."
                    },
                    {
                        "username": "Anoop0522",
                        "content": "Can someone tell why does my lastIndexOf function giving me a wrong value for the index of \"0\" in the following question.... rest of the cases seems fine to me. Any explanation for my issue would be appreciated.\\n `class Solution {\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        StringBuilder r = new StringBuilder();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            r.append(nums[i]);\\n        }\\n        String w=r.toString();\\n        String y=\"\";\\n        y+=target;\\n        int a[]=new int[2];\\n         a[0]=w.indexOf(y);\\n         a[1]=w.lastIndexOf(y);\\n        return a;\\n    }\\n}`\\noutput console\\nnums[] = [0,0,0,0,1,2,3,3,4,5,6,6,7,8,8,8,9,9,10,10,11,11]\\ntarget = 0\\nexpected output = [0,3]\\nmy output = [0,21]\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Everyone, Need your help and input on the following test case:\\nnums =\\n[3,3,3]\\ntarget =\\n3\\nMy output is [0,1,2] but expected output is [0,2]. Why?\\nThanks in advance\\nKeep Coding :)"
                    },
                    {
                        "username": "xolotl2",
                        "content": "it only needs starting and ending indices of the target. 1 and any other middle value should be ignored "
                    }
                ]
            },
            {
                "id": 1866146,
                "content": [
                    {
                        "username": "md_irfan_pr",
                        "content": "First we can solve with the help of linear search and time complexity will be O(n)\\nbut when wo apply the concept of binary search and solve with the better time complexity than previous one time complexity will be O(logn)."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "Whats wrong with this code ?? Can anyone suggest me...???\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target)  {\\n      vector<int> ans, no;\\n      no.push_back(-1);\\n      no.push_back(-1);\\n\\n      int start= 0;\\n      int end= nums.size();\\n      int mid= (start + end)/2;\\n      while(start<= end){\\n          if(nums[mid]==target){\\n              if(nums[mid+1]==target){\\n                  ans.push_back(mid);\\n                  ans.push_back(mid+1);\\n                  return ans;\\n              }\\n              else{\\n                  ans.push_back(mid);\\n                  ans.push_back(mid-1);\\n                  return ans;\\n              }\\n          }\\n          if(nums[mid]<target){\\n              start= mid+1;\\n          }\\n          else{\\n              end=mid-1;\\n          }\\n          mid= (start+end)/2;\\n      }\\n      return no;  \\n    }\\n\\n};"
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "[@userkaaname](/userkaaname)  \\nThanks buddy!, for figuring out my mistake . I modified the code and got correct answer.  "
                    },
                    {
                        "username": "userkaaname",
                        "content": "you are assuming that target number is only present in the array two times, however it is not written anywhere.\\nSo, let\\'s assume an array,\\n{1,2,4,4,4,5}\\nAccording to your solution, it will return position {2,3} but actual answer is {2,4}\\nKindly, Modify your code accordingly."
                    },
                    {
                        "username": "luvsharma105",
                        "content": "CAN SOMEBODY TELL ME WHAT IS THIS ERROR ABOUT.\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000003d0 overflowed to 0x6020000003cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "yashseth391",
                        "content": "I think they have given less information in question ."
                    },
                    {
                        "username": "akarshnayak",
                        "content": "Why am i getting a TLE?? my code is in O(logn) \\n `your inline code...your inline code...`\\nclass Solution {\\n    int searchStart(int[] nums,int target){\\n        int s=0;\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                e=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n    int searchEnd(int[] nums,int target,int s){\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                s=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return e;\\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] res=new int[2];\\n        res[0]=searchStart(nums,target);\\n        res[1]=searchEnd(nums,target,res[0]);\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditisharma37",
                        "content": "Can anyone tell me why is it not running ?\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> a;\\n        int start =0;\\n        int end = size(nums) -1;\\n        while(start <= end){\\n            int mid= (start + end)/2 ; \\n            if(nums[mid]== target ){\\n                int s=mid ,e=mid  ;\\n                while( nums[e] == target){\\n                    e++;\\n                }\\n                \\n                while( nums[s] == target){\\n                    s--;\\n                }\\n                a.push_back(s+1);\\n                a.push_back(e-1);\\n                return a;\\n            }\\n            else if( nums[mid] > target){\\n                end = mid -1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        a.push_back(-1);\\n        a.push_back(-1);\\n        return a;\\n    }\\n};\\n\\nIt\\'s giving Runtime Error \\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x00000034caab bp 0x7ffec3562630 sp 0x7ffec3562628\\nREAD of size 4 at 0x602000000434 thread T0\\n    #2 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000434 is located 0 bytes to the right of 4-byte region [0x602000000430,0x602000000434)\\nallocated by thread T0 here:\\n    #6 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8030: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8080: fa fa fd fa fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):"
                    },
                    {
                        "username": "userkaaname",
                        "content": "when target is matched with mid and then you find value of s & e, assume mid =0, then you are doing s-- that will decrease s value to -1 even if you are pushing s+1 in a, it will already generate overflow error because you can't compare nums[-1]==target in next iteration.\nhope you understand ;)"
                    },
                    {
                        "username": "aakashy810",
                        "content": "i write solution in O(n) time complexity and leetcode accepted this "
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Would checking for nums[mid+1] and nums[mid-1] still be logn? Since its sorted we can check the targets neighbor."
                    },
                    {
                        "username": "Anoop0522",
                        "content": "Can someone tell why does my lastIndexOf function giving me a wrong value for the index of \"0\" in the following question.... rest of the cases seems fine to me. Any explanation for my issue would be appreciated.\\n `class Solution {\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        StringBuilder r = new StringBuilder();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            r.append(nums[i]);\\n        }\\n        String w=r.toString();\\n        String y=\"\";\\n        y+=target;\\n        int a[]=new int[2];\\n         a[0]=w.indexOf(y);\\n         a[1]=w.lastIndexOf(y);\\n        return a;\\n    }\\n}`\\noutput console\\nnums[] = [0,0,0,0,1,2,3,3,4,5,6,6,7,8,8,8,9,9,10,10,11,11]\\ntarget = 0\\nexpected output = [0,3]\\nmy output = [0,21]\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Everyone, Need your help and input on the following test case:\\nnums =\\n[3,3,3]\\ntarget =\\n3\\nMy output is [0,1,2] but expected output is [0,2]. Why?\\nThanks in advance\\nKeep Coding :)"
                    },
                    {
                        "username": "xolotl2",
                        "content": "it only needs starting and ending indices of the target. 1 and any other middle value should be ignored "
                    }
                ]
            },
            {
                "id": 1843263,
                "content": [
                    {
                        "username": "md_irfan_pr",
                        "content": "First we can solve with the help of linear search and time complexity will be O(n)\\nbut when wo apply the concept of binary search and solve with the better time complexity than previous one time complexity will be O(logn)."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "Whats wrong with this code ?? Can anyone suggest me...???\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target)  {\\n      vector<int> ans, no;\\n      no.push_back(-1);\\n      no.push_back(-1);\\n\\n      int start= 0;\\n      int end= nums.size();\\n      int mid= (start + end)/2;\\n      while(start<= end){\\n          if(nums[mid]==target){\\n              if(nums[mid+1]==target){\\n                  ans.push_back(mid);\\n                  ans.push_back(mid+1);\\n                  return ans;\\n              }\\n              else{\\n                  ans.push_back(mid);\\n                  ans.push_back(mid-1);\\n                  return ans;\\n              }\\n          }\\n          if(nums[mid]<target){\\n              start= mid+1;\\n          }\\n          else{\\n              end=mid-1;\\n          }\\n          mid= (start+end)/2;\\n      }\\n      return no;  \\n    }\\n\\n};"
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "[@userkaaname](/userkaaname)  \\nThanks buddy!, for figuring out my mistake . I modified the code and got correct answer.  "
                    },
                    {
                        "username": "userkaaname",
                        "content": "you are assuming that target number is only present in the array two times, however it is not written anywhere.\\nSo, let\\'s assume an array,\\n{1,2,4,4,4,5}\\nAccording to your solution, it will return position {2,3} but actual answer is {2,4}\\nKindly, Modify your code accordingly."
                    },
                    {
                        "username": "luvsharma105",
                        "content": "CAN SOMEBODY TELL ME WHAT IS THIS ERROR ABOUT.\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000003d0 overflowed to 0x6020000003cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "yashseth391",
                        "content": "I think they have given less information in question ."
                    },
                    {
                        "username": "akarshnayak",
                        "content": "Why am i getting a TLE?? my code is in O(logn) \\n `your inline code...your inline code...`\\nclass Solution {\\n    int searchStart(int[] nums,int target){\\n        int s=0;\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                e=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n    int searchEnd(int[] nums,int target,int s){\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                s=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return e;\\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] res=new int[2];\\n        res[0]=searchStart(nums,target);\\n        res[1]=searchEnd(nums,target,res[0]);\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditisharma37",
                        "content": "Can anyone tell me why is it not running ?\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> a;\\n        int start =0;\\n        int end = size(nums) -1;\\n        while(start <= end){\\n            int mid= (start + end)/2 ; \\n            if(nums[mid]== target ){\\n                int s=mid ,e=mid  ;\\n                while( nums[e] == target){\\n                    e++;\\n                }\\n                \\n                while( nums[s] == target){\\n                    s--;\\n                }\\n                a.push_back(s+1);\\n                a.push_back(e-1);\\n                return a;\\n            }\\n            else if( nums[mid] > target){\\n                end = mid -1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        a.push_back(-1);\\n        a.push_back(-1);\\n        return a;\\n    }\\n};\\n\\nIt\\'s giving Runtime Error \\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x00000034caab bp 0x7ffec3562630 sp 0x7ffec3562628\\nREAD of size 4 at 0x602000000434 thread T0\\n    #2 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000434 is located 0 bytes to the right of 4-byte region [0x602000000430,0x602000000434)\\nallocated by thread T0 here:\\n    #6 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8030: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8080: fa fa fd fa fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):"
                    },
                    {
                        "username": "userkaaname",
                        "content": "when target is matched with mid and then you find value of s & e, assume mid =0, then you are doing s-- that will decrease s value to -1 even if you are pushing s+1 in a, it will already generate overflow error because you can't compare nums[-1]==target in next iteration.\nhope you understand ;)"
                    },
                    {
                        "username": "aakashy810",
                        "content": "i write solution in O(n) time complexity and leetcode accepted this "
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Would checking for nums[mid+1] and nums[mid-1] still be logn? Since its sorted we can check the targets neighbor."
                    },
                    {
                        "username": "Anoop0522",
                        "content": "Can someone tell why does my lastIndexOf function giving me a wrong value for the index of \"0\" in the following question.... rest of the cases seems fine to me. Any explanation for my issue would be appreciated.\\n `class Solution {\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        StringBuilder r = new StringBuilder();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            r.append(nums[i]);\\n        }\\n        String w=r.toString();\\n        String y=\"\";\\n        y+=target;\\n        int a[]=new int[2];\\n         a[0]=w.indexOf(y);\\n         a[1]=w.lastIndexOf(y);\\n        return a;\\n    }\\n}`\\noutput console\\nnums[] = [0,0,0,0,1,2,3,3,4,5,6,6,7,8,8,8,9,9,10,10,11,11]\\ntarget = 0\\nexpected output = [0,3]\\nmy output = [0,21]\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Everyone, Need your help and input on the following test case:\\nnums =\\n[3,3,3]\\ntarget =\\n3\\nMy output is [0,1,2] but expected output is [0,2]. Why?\\nThanks in advance\\nKeep Coding :)"
                    },
                    {
                        "username": "xolotl2",
                        "content": "it only needs starting and ending indices of the target. 1 and any other middle value should be ignored "
                    }
                ]
            },
            {
                "id": 1839995,
                "content": [
                    {
                        "username": "TatianaTt",
                        "content": "Why this code does not work in LeetCode, but it works on my IDE:\\n\\n# LeetCode 34. Find First and Last Position of Element in Sorted Array\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Main Function\\n        left = self.first_tar(nums, target)\\n        right = self.last_tar(nums, target)\\n        return [left, right]\\n\\n    def last_tar(self, nums,target):\\n        last_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l+1 < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the last position of the target value           \\n                l = mid\\n        if nums[r] == target:\\n            last_target = r\\n        if nums[l] == target:\\n            last_target = l\\n        return last_target \\n    \\n    def first_tar(self, nums, target):\\n        first_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the first position of the target value           \\n                r = mid  \\n        if nums[l] == target:\\n            first_target = l\\n        if nums[r] == target:\\n            first_target = r\\n        return first_target\\n        \\n\\n\\n"
                    },
                    {
                        "username": "deepak_kaushik",
                        "content": "try doing l =  mid+1 and r=mid-1"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int left = 0,right = nums.size()-1;\\n        int n = nums.size();\\n        vector<int>ans;\\n        int point;\\n        bool flage = false;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                point = mid;\\n                // ans.push_back(mid);\\n                flage = true;\\n                break;\\n\\n            }else if(nums[mid]>target){\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        if(flage){\\n            // cout<<point;\\n            while(point != 0 && nums[point]==target){\\n                ans[0] = point;\\n                point--;\\n            }\\n            while(point != n-1 && nums[point]==target){\\n                ans[1] = point;\\n                point++;\\n            }\\n        }else{\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\nPlease find error"
                    },
                    {
                        "username": "jaindarshan295",
                        "content": "in case the whole list is of target it would take order of n time so rather than traversing every value besides \"point\" you can again apply binary search on both sides"
                    },
                    {
                        "username": "DP0307",
                        "content": "class Solution {\\npublic:\\n  int first(vector<int>& nums, int target){\\n    int ans =-1;\\n        for(int i =0;i<nums.size();i++){\\n              if(nums[i] == target ){\\n                ans = i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\nint second(vector<int>& nums, int target){\\n  int ans =-1;\\n        for(int i =nums.size()-1;i>=0;i--){\\n              if(nums[i] == target ){\\n                ans =i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n      \\n       int a = first(nums,target);\\n       int b = second(nums,target);\\n        \\n      \\n      return {a,b};\\n    }\\n};"
                    },
                    {
                        "username": "Swakshan",
                        "content": "HOW MY CODE IS ACCEPTED Even after using O(n) time complexity\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Anyone solved this question using binary search template 3? Please let me know about it.\\nThanks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is a pretty good problem."
                    },
                    {
                        "username": "adrianP",
                        "content": "How to be extra: \"non-decreasing order\" (\\u25D1\\u203F\\u25D0)"
                    },
                    {
                        "username": "papaidebnath5690",
                        "content": "if the target will be there 2 times in the nums array or not??"
                    },
                    {
                        "username": "shubhi4",
                        "content": "target element can be 0 times, 1 times or more times\\nif its 0 times then answer ->[-1,-1]\\nif its 1 times then index of target elemnt is i \\n     then answer ->[ i, i ]\\nif its >=2 times then i is index of first index of target and j is last index of target \\n     then answer ->[ i, j ]"
                    },
                    {
                        "username": "krapirastogi2329",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res;\\n        int foc=-1,loc=-1;    \\n        int l=0,h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n                foc=mid;\\n                h=mid-1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n         l=0;h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n               loc=mid;\\n                h=mid+1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        res.push_back(foc);\\n        res.push_back(loc);\\n        return res;\\n    }\\n};\\n\\n\\nwhy does this show tle?\\n"
                    },
                    {
                        "username": "Sohoom_418",
                        "content": "same"
                    },
                    {
                        "username": "guptapiyush264",
                        "content": "i tried some new and efficient approach|| binary_search ||c++ ||must see||\\noptimized approch\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        \\n        int starting=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int ending= lower_bound(nums.begin(),nums.end(),target+1)-nums.begin()-1;\\n        if(binary_search(nums.begin(),nums.end(),target))\\n          {\\n            return {starting,ending};\\n          }\\n          else\\n          return {-1,-1};\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1838240,
                "content": [
                    {
                        "username": "TatianaTt",
                        "content": "Why this code does not work in LeetCode, but it works on my IDE:\\n\\n# LeetCode 34. Find First and Last Position of Element in Sorted Array\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Main Function\\n        left = self.first_tar(nums, target)\\n        right = self.last_tar(nums, target)\\n        return [left, right]\\n\\n    def last_tar(self, nums,target):\\n        last_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l+1 < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the last position of the target value           \\n                l = mid\\n        if nums[r] == target:\\n            last_target = r\\n        if nums[l] == target:\\n            last_target = l\\n        return last_target \\n    \\n    def first_tar(self, nums, target):\\n        first_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the first position of the target value           \\n                r = mid  \\n        if nums[l] == target:\\n            first_target = l\\n        if nums[r] == target:\\n            first_target = r\\n        return first_target\\n        \\n\\n\\n"
                    },
                    {
                        "username": "deepak_kaushik",
                        "content": "try doing l =  mid+1 and r=mid-1"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int left = 0,right = nums.size()-1;\\n        int n = nums.size();\\n        vector<int>ans;\\n        int point;\\n        bool flage = false;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                point = mid;\\n                // ans.push_back(mid);\\n                flage = true;\\n                break;\\n\\n            }else if(nums[mid]>target){\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        if(flage){\\n            // cout<<point;\\n            while(point != 0 && nums[point]==target){\\n                ans[0] = point;\\n                point--;\\n            }\\n            while(point != n-1 && nums[point]==target){\\n                ans[1] = point;\\n                point++;\\n            }\\n        }else{\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\nPlease find error"
                    },
                    {
                        "username": "jaindarshan295",
                        "content": "in case the whole list is of target it would take order of n time so rather than traversing every value besides \"point\" you can again apply binary search on both sides"
                    },
                    {
                        "username": "DP0307",
                        "content": "class Solution {\\npublic:\\n  int first(vector<int>& nums, int target){\\n    int ans =-1;\\n        for(int i =0;i<nums.size();i++){\\n              if(nums[i] == target ){\\n                ans = i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\nint second(vector<int>& nums, int target){\\n  int ans =-1;\\n        for(int i =nums.size()-1;i>=0;i--){\\n              if(nums[i] == target ){\\n                ans =i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n      \\n       int a = first(nums,target);\\n       int b = second(nums,target);\\n        \\n      \\n      return {a,b};\\n    }\\n};"
                    },
                    {
                        "username": "Swakshan",
                        "content": "HOW MY CODE IS ACCEPTED Even after using O(n) time complexity\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Anyone solved this question using binary search template 3? Please let me know about it.\\nThanks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is a pretty good problem."
                    },
                    {
                        "username": "adrianP",
                        "content": "How to be extra: \"non-decreasing order\" (\\u25D1\\u203F\\u25D0)"
                    },
                    {
                        "username": "papaidebnath5690",
                        "content": "if the target will be there 2 times in the nums array or not??"
                    },
                    {
                        "username": "shubhi4",
                        "content": "target element can be 0 times, 1 times or more times\\nif its 0 times then answer ->[-1,-1]\\nif its 1 times then index of target elemnt is i \\n     then answer ->[ i, i ]\\nif its >=2 times then i is index of first index of target and j is last index of target \\n     then answer ->[ i, j ]"
                    },
                    {
                        "username": "krapirastogi2329",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res;\\n        int foc=-1,loc=-1;    \\n        int l=0,h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n                foc=mid;\\n                h=mid-1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n         l=0;h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n               loc=mid;\\n                h=mid+1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        res.push_back(foc);\\n        res.push_back(loc);\\n        return res;\\n    }\\n};\\n\\n\\nwhy does this show tle?\\n"
                    },
                    {
                        "username": "Sohoom_418",
                        "content": "same"
                    },
                    {
                        "username": "guptapiyush264",
                        "content": "i tried some new and efficient approach|| binary_search ||c++ ||must see||\\noptimized approch\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        \\n        int starting=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int ending= lower_bound(nums.begin(),nums.end(),target+1)-nums.begin()-1;\\n        if(binary_search(nums.begin(),nums.end(),target))\\n          {\\n            return {starting,ending};\\n          }\\n          else\\n          return {-1,-1};\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1837229,
                "content": [
                    {
                        "username": "TatianaTt",
                        "content": "Why this code does not work in LeetCode, but it works on my IDE:\\n\\n# LeetCode 34. Find First and Last Position of Element in Sorted Array\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Main Function\\n        left = self.first_tar(nums, target)\\n        right = self.last_tar(nums, target)\\n        return [left, right]\\n\\n    def last_tar(self, nums,target):\\n        last_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l+1 < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the last position of the target value           \\n                l = mid\\n        if nums[r] == target:\\n            last_target = r\\n        if nums[l] == target:\\n            last_target = l\\n        return last_target \\n    \\n    def first_tar(self, nums, target):\\n        first_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the first position of the target value           \\n                r = mid  \\n        if nums[l] == target:\\n            first_target = l\\n        if nums[r] == target:\\n            first_target = r\\n        return first_target\\n        \\n\\n\\n"
                    },
                    {
                        "username": "deepak_kaushik",
                        "content": "try doing l =  mid+1 and r=mid-1"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int left = 0,right = nums.size()-1;\\n        int n = nums.size();\\n        vector<int>ans;\\n        int point;\\n        bool flage = false;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                point = mid;\\n                // ans.push_back(mid);\\n                flage = true;\\n                break;\\n\\n            }else if(nums[mid]>target){\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        if(flage){\\n            // cout<<point;\\n            while(point != 0 && nums[point]==target){\\n                ans[0] = point;\\n                point--;\\n            }\\n            while(point != n-1 && nums[point]==target){\\n                ans[1] = point;\\n                point++;\\n            }\\n        }else{\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\nPlease find error"
                    },
                    {
                        "username": "jaindarshan295",
                        "content": "in case the whole list is of target it would take order of n time so rather than traversing every value besides \"point\" you can again apply binary search on both sides"
                    },
                    {
                        "username": "DP0307",
                        "content": "class Solution {\\npublic:\\n  int first(vector<int>& nums, int target){\\n    int ans =-1;\\n        for(int i =0;i<nums.size();i++){\\n              if(nums[i] == target ){\\n                ans = i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\nint second(vector<int>& nums, int target){\\n  int ans =-1;\\n        for(int i =nums.size()-1;i>=0;i--){\\n              if(nums[i] == target ){\\n                ans =i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n      \\n       int a = first(nums,target);\\n       int b = second(nums,target);\\n        \\n      \\n      return {a,b};\\n    }\\n};"
                    },
                    {
                        "username": "Swakshan",
                        "content": "HOW MY CODE IS ACCEPTED Even after using O(n) time complexity\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Anyone solved this question using binary search template 3? Please let me know about it.\\nThanks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is a pretty good problem."
                    },
                    {
                        "username": "adrianP",
                        "content": "How to be extra: \"non-decreasing order\" (\\u25D1\\u203F\\u25D0)"
                    },
                    {
                        "username": "papaidebnath5690",
                        "content": "if the target will be there 2 times in the nums array or not??"
                    },
                    {
                        "username": "shubhi4",
                        "content": "target element can be 0 times, 1 times or more times\\nif its 0 times then answer ->[-1,-1]\\nif its 1 times then index of target elemnt is i \\n     then answer ->[ i, i ]\\nif its >=2 times then i is index of first index of target and j is last index of target \\n     then answer ->[ i, j ]"
                    },
                    {
                        "username": "krapirastogi2329",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res;\\n        int foc=-1,loc=-1;    \\n        int l=0,h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n                foc=mid;\\n                h=mid-1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n         l=0;h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n               loc=mid;\\n                h=mid+1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        res.push_back(foc);\\n        res.push_back(loc);\\n        return res;\\n    }\\n};\\n\\n\\nwhy does this show tle?\\n"
                    },
                    {
                        "username": "Sohoom_418",
                        "content": "same"
                    },
                    {
                        "username": "guptapiyush264",
                        "content": "i tried some new and efficient approach|| binary_search ||c++ ||must see||\\noptimized approch\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        \\n        int starting=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int ending= lower_bound(nums.begin(),nums.end(),target+1)-nums.begin()-1;\\n        if(binary_search(nums.begin(),nums.end(),target))\\n          {\\n            return {starting,ending};\\n          }\\n          else\\n          return {-1,-1};\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1828142,
                "content": [
                    {
                        "username": "TatianaTt",
                        "content": "Why this code does not work in LeetCode, but it works on my IDE:\\n\\n# LeetCode 34. Find First and Last Position of Element in Sorted Array\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Main Function\\n        left = self.first_tar(nums, target)\\n        right = self.last_tar(nums, target)\\n        return [left, right]\\n\\n    def last_tar(self, nums,target):\\n        last_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l+1 < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the last position of the target value           \\n                l = mid\\n        if nums[r] == target:\\n            last_target = r\\n        if nums[l] == target:\\n            last_target = l\\n        return last_target \\n    \\n    def first_tar(self, nums, target):\\n        first_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the first position of the target value           \\n                r = mid  \\n        if nums[l] == target:\\n            first_target = l\\n        if nums[r] == target:\\n            first_target = r\\n        return first_target\\n        \\n\\n\\n"
                    },
                    {
                        "username": "deepak_kaushik",
                        "content": "try doing l =  mid+1 and r=mid-1"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int left = 0,right = nums.size()-1;\\n        int n = nums.size();\\n        vector<int>ans;\\n        int point;\\n        bool flage = false;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                point = mid;\\n                // ans.push_back(mid);\\n                flage = true;\\n                break;\\n\\n            }else if(nums[mid]>target){\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        if(flage){\\n            // cout<<point;\\n            while(point != 0 && nums[point]==target){\\n                ans[0] = point;\\n                point--;\\n            }\\n            while(point != n-1 && nums[point]==target){\\n                ans[1] = point;\\n                point++;\\n            }\\n        }else{\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\nPlease find error"
                    },
                    {
                        "username": "jaindarshan295",
                        "content": "in case the whole list is of target it would take order of n time so rather than traversing every value besides \"point\" you can again apply binary search on both sides"
                    },
                    {
                        "username": "DP0307",
                        "content": "class Solution {\\npublic:\\n  int first(vector<int>& nums, int target){\\n    int ans =-1;\\n        for(int i =0;i<nums.size();i++){\\n              if(nums[i] == target ){\\n                ans = i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\nint second(vector<int>& nums, int target){\\n  int ans =-1;\\n        for(int i =nums.size()-1;i>=0;i--){\\n              if(nums[i] == target ){\\n                ans =i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n      \\n       int a = first(nums,target);\\n       int b = second(nums,target);\\n        \\n      \\n      return {a,b};\\n    }\\n};"
                    },
                    {
                        "username": "Swakshan",
                        "content": "HOW MY CODE IS ACCEPTED Even after using O(n) time complexity\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Anyone solved this question using binary search template 3? Please let me know about it.\\nThanks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is a pretty good problem."
                    },
                    {
                        "username": "adrianP",
                        "content": "How to be extra: \"non-decreasing order\" (\\u25D1\\u203F\\u25D0)"
                    },
                    {
                        "username": "papaidebnath5690",
                        "content": "if the target will be there 2 times in the nums array or not??"
                    },
                    {
                        "username": "shubhi4",
                        "content": "target element can be 0 times, 1 times or more times\\nif its 0 times then answer ->[-1,-1]\\nif its 1 times then index of target elemnt is i \\n     then answer ->[ i, i ]\\nif its >=2 times then i is index of first index of target and j is last index of target \\n     then answer ->[ i, j ]"
                    },
                    {
                        "username": "krapirastogi2329",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res;\\n        int foc=-1,loc=-1;    \\n        int l=0,h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n                foc=mid;\\n                h=mid-1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n         l=0;h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n               loc=mid;\\n                h=mid+1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        res.push_back(foc);\\n        res.push_back(loc);\\n        return res;\\n    }\\n};\\n\\n\\nwhy does this show tle?\\n"
                    },
                    {
                        "username": "Sohoom_418",
                        "content": "same"
                    },
                    {
                        "username": "guptapiyush264",
                        "content": "i tried some new and efficient approach|| binary_search ||c++ ||must see||\\noptimized approch\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        \\n        int starting=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int ending= lower_bound(nums.begin(),nums.end(),target+1)-nums.begin()-1;\\n        if(binary_search(nums.begin(),nums.end(),target))\\n          {\\n            return {starting,ending};\\n          }\\n          else\\n          return {-1,-1};\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1827454,
                "content": [
                    {
                        "username": "TatianaTt",
                        "content": "Why this code does not work in LeetCode, but it works on my IDE:\\n\\n# LeetCode 34. Find First and Last Position of Element in Sorted Array\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Main Function\\n        left = self.first_tar(nums, target)\\n        right = self.last_tar(nums, target)\\n        return [left, right]\\n\\n    def last_tar(self, nums,target):\\n        last_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l+1 < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the last position of the target value           \\n                l = mid\\n        if nums[r] == target:\\n            last_target = r\\n        if nums[l] == target:\\n            last_target = l\\n        return last_target \\n    \\n    def first_tar(self, nums, target):\\n        first_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the first position of the target value           \\n                r = mid  \\n        if nums[l] == target:\\n            first_target = l\\n        if nums[r] == target:\\n            first_target = r\\n        return first_target\\n        \\n\\n\\n"
                    },
                    {
                        "username": "deepak_kaushik",
                        "content": "try doing l =  mid+1 and r=mid-1"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int left = 0,right = nums.size()-1;\\n        int n = nums.size();\\n        vector<int>ans;\\n        int point;\\n        bool flage = false;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                point = mid;\\n                // ans.push_back(mid);\\n                flage = true;\\n                break;\\n\\n            }else if(nums[mid]>target){\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        if(flage){\\n            // cout<<point;\\n            while(point != 0 && nums[point]==target){\\n                ans[0] = point;\\n                point--;\\n            }\\n            while(point != n-1 && nums[point]==target){\\n                ans[1] = point;\\n                point++;\\n            }\\n        }else{\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\nPlease find error"
                    },
                    {
                        "username": "jaindarshan295",
                        "content": "in case the whole list is of target it would take order of n time so rather than traversing every value besides \"point\" you can again apply binary search on both sides"
                    },
                    {
                        "username": "DP0307",
                        "content": "class Solution {\\npublic:\\n  int first(vector<int>& nums, int target){\\n    int ans =-1;\\n        for(int i =0;i<nums.size();i++){\\n              if(nums[i] == target ){\\n                ans = i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\nint second(vector<int>& nums, int target){\\n  int ans =-1;\\n        for(int i =nums.size()-1;i>=0;i--){\\n              if(nums[i] == target ){\\n                ans =i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n      \\n       int a = first(nums,target);\\n       int b = second(nums,target);\\n        \\n      \\n      return {a,b};\\n    }\\n};"
                    },
                    {
                        "username": "Swakshan",
                        "content": "HOW MY CODE IS ACCEPTED Even after using O(n) time complexity\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Anyone solved this question using binary search template 3? Please let me know about it.\\nThanks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is a pretty good problem."
                    },
                    {
                        "username": "adrianP",
                        "content": "How to be extra: \"non-decreasing order\" (\\u25D1\\u203F\\u25D0)"
                    },
                    {
                        "username": "papaidebnath5690",
                        "content": "if the target will be there 2 times in the nums array or not??"
                    },
                    {
                        "username": "shubhi4",
                        "content": "target element can be 0 times, 1 times or more times\\nif its 0 times then answer ->[-1,-1]\\nif its 1 times then index of target elemnt is i \\n     then answer ->[ i, i ]\\nif its >=2 times then i is index of first index of target and j is last index of target \\n     then answer ->[ i, j ]"
                    },
                    {
                        "username": "krapirastogi2329",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res;\\n        int foc=-1,loc=-1;    \\n        int l=0,h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n                foc=mid;\\n                h=mid-1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n         l=0;h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n               loc=mid;\\n                h=mid+1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        res.push_back(foc);\\n        res.push_back(loc);\\n        return res;\\n    }\\n};\\n\\n\\nwhy does this show tle?\\n"
                    },
                    {
                        "username": "Sohoom_418",
                        "content": "same"
                    },
                    {
                        "username": "guptapiyush264",
                        "content": "i tried some new and efficient approach|| binary_search ||c++ ||must see||\\noptimized approch\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        \\n        int starting=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int ending= lower_bound(nums.begin(),nums.end(),target+1)-nums.begin()-1;\\n        if(binary_search(nums.begin(),nums.end(),target))\\n          {\\n            return {starting,ending};\\n          }\\n          else\\n          return {-1,-1};\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1827274,
                "content": [
                    {
                        "username": "TatianaTt",
                        "content": "Why this code does not work in LeetCode, but it works on my IDE:\\n\\n# LeetCode 34. Find First and Last Position of Element in Sorted Array\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Main Function\\n        left = self.first_tar(nums, target)\\n        right = self.last_tar(nums, target)\\n        return [left, right]\\n\\n    def last_tar(self, nums,target):\\n        last_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l+1 < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the last position of the target value           \\n                l = mid\\n        if nums[r] == target:\\n            last_target = r\\n        if nums[l] == target:\\n            last_target = l\\n        return last_target \\n    \\n    def first_tar(self, nums, target):\\n        first_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the first position of the target value           \\n                r = mid  \\n        if nums[l] == target:\\n            first_target = l\\n        if nums[r] == target:\\n            first_target = r\\n        return first_target\\n        \\n\\n\\n"
                    },
                    {
                        "username": "deepak_kaushik",
                        "content": "try doing l =  mid+1 and r=mid-1"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int left = 0,right = nums.size()-1;\\n        int n = nums.size();\\n        vector<int>ans;\\n        int point;\\n        bool flage = false;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                point = mid;\\n                // ans.push_back(mid);\\n                flage = true;\\n                break;\\n\\n            }else if(nums[mid]>target){\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        if(flage){\\n            // cout<<point;\\n            while(point != 0 && nums[point]==target){\\n                ans[0] = point;\\n                point--;\\n            }\\n            while(point != n-1 && nums[point]==target){\\n                ans[1] = point;\\n                point++;\\n            }\\n        }else{\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\nPlease find error"
                    },
                    {
                        "username": "jaindarshan295",
                        "content": "in case the whole list is of target it would take order of n time so rather than traversing every value besides \"point\" you can again apply binary search on both sides"
                    },
                    {
                        "username": "DP0307",
                        "content": "class Solution {\\npublic:\\n  int first(vector<int>& nums, int target){\\n    int ans =-1;\\n        for(int i =0;i<nums.size();i++){\\n              if(nums[i] == target ){\\n                ans = i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\nint second(vector<int>& nums, int target){\\n  int ans =-1;\\n        for(int i =nums.size()-1;i>=0;i--){\\n              if(nums[i] == target ){\\n                ans =i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n      \\n       int a = first(nums,target);\\n       int b = second(nums,target);\\n        \\n      \\n      return {a,b};\\n    }\\n};"
                    },
                    {
                        "username": "Swakshan",
                        "content": "HOW MY CODE IS ACCEPTED Even after using O(n) time complexity\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Anyone solved this question using binary search template 3? Please let me know about it.\\nThanks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is a pretty good problem."
                    },
                    {
                        "username": "adrianP",
                        "content": "How to be extra: \"non-decreasing order\" (\\u25D1\\u203F\\u25D0)"
                    },
                    {
                        "username": "papaidebnath5690",
                        "content": "if the target will be there 2 times in the nums array or not??"
                    },
                    {
                        "username": "shubhi4",
                        "content": "target element can be 0 times, 1 times or more times\\nif its 0 times then answer ->[-1,-1]\\nif its 1 times then index of target elemnt is i \\n     then answer ->[ i, i ]\\nif its >=2 times then i is index of first index of target and j is last index of target \\n     then answer ->[ i, j ]"
                    },
                    {
                        "username": "krapirastogi2329",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res;\\n        int foc=-1,loc=-1;    \\n        int l=0,h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n                foc=mid;\\n                h=mid-1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n         l=0;h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n               loc=mid;\\n                h=mid+1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        res.push_back(foc);\\n        res.push_back(loc);\\n        return res;\\n    }\\n};\\n\\n\\nwhy does this show tle?\\n"
                    },
                    {
                        "username": "Sohoom_418",
                        "content": "same"
                    },
                    {
                        "username": "guptapiyush264",
                        "content": "i tried some new and efficient approach|| binary_search ||c++ ||must see||\\noptimized approch\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        \\n        int starting=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int ending= lower_bound(nums.begin(),nums.end(),target+1)-nums.begin()-1;\\n        if(binary_search(nums.begin(),nums.end(),target))\\n          {\\n            return {starting,ending};\\n          }\\n          else\\n          return {-1,-1};\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1820459,
                "content": [
                    {
                        "username": "TatianaTt",
                        "content": "Why this code does not work in LeetCode, but it works on my IDE:\\n\\n# LeetCode 34. Find First and Last Position of Element in Sorted Array\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Main Function\\n        left = self.first_tar(nums, target)\\n        right = self.last_tar(nums, target)\\n        return [left, right]\\n\\n    def last_tar(self, nums,target):\\n        last_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l+1 < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the last position of the target value           \\n                l = mid\\n        if nums[r] == target:\\n            last_target = r\\n        if nums[l] == target:\\n            last_target = l\\n        return last_target \\n    \\n    def first_tar(self, nums, target):\\n        first_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the first position of the target value           \\n                r = mid  \\n        if nums[l] == target:\\n            first_target = l\\n        if nums[r] == target:\\n            first_target = r\\n        return first_target\\n        \\n\\n\\n"
                    },
                    {
                        "username": "deepak_kaushik",
                        "content": "try doing l =  mid+1 and r=mid-1"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int left = 0,right = nums.size()-1;\\n        int n = nums.size();\\n        vector<int>ans;\\n        int point;\\n        bool flage = false;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                point = mid;\\n                // ans.push_back(mid);\\n                flage = true;\\n                break;\\n\\n            }else if(nums[mid]>target){\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        if(flage){\\n            // cout<<point;\\n            while(point != 0 && nums[point]==target){\\n                ans[0] = point;\\n                point--;\\n            }\\n            while(point != n-1 && nums[point]==target){\\n                ans[1] = point;\\n                point++;\\n            }\\n        }else{\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\nPlease find error"
                    },
                    {
                        "username": "jaindarshan295",
                        "content": "in case the whole list is of target it would take order of n time so rather than traversing every value besides \"point\" you can again apply binary search on both sides"
                    },
                    {
                        "username": "DP0307",
                        "content": "class Solution {\\npublic:\\n  int first(vector<int>& nums, int target){\\n    int ans =-1;\\n        for(int i =0;i<nums.size();i++){\\n              if(nums[i] == target ){\\n                ans = i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\nint second(vector<int>& nums, int target){\\n  int ans =-1;\\n        for(int i =nums.size()-1;i>=0;i--){\\n              if(nums[i] == target ){\\n                ans =i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n      \\n       int a = first(nums,target);\\n       int b = second(nums,target);\\n        \\n      \\n      return {a,b};\\n    }\\n};"
                    },
                    {
                        "username": "Swakshan",
                        "content": "HOW MY CODE IS ACCEPTED Even after using O(n) time complexity\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Anyone solved this question using binary search template 3? Please let me know about it.\\nThanks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is a pretty good problem."
                    },
                    {
                        "username": "adrianP",
                        "content": "How to be extra: \"non-decreasing order\" (\\u25D1\\u203F\\u25D0)"
                    },
                    {
                        "username": "papaidebnath5690",
                        "content": "if the target will be there 2 times in the nums array or not??"
                    },
                    {
                        "username": "shubhi4",
                        "content": "target element can be 0 times, 1 times or more times\\nif its 0 times then answer ->[-1,-1]\\nif its 1 times then index of target elemnt is i \\n     then answer ->[ i, i ]\\nif its >=2 times then i is index of first index of target and j is last index of target \\n     then answer ->[ i, j ]"
                    },
                    {
                        "username": "krapirastogi2329",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res;\\n        int foc=-1,loc=-1;    \\n        int l=0,h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n                foc=mid;\\n                h=mid-1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n         l=0;h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n               loc=mid;\\n                h=mid+1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        res.push_back(foc);\\n        res.push_back(loc);\\n        return res;\\n    }\\n};\\n\\n\\nwhy does this show tle?\\n"
                    },
                    {
                        "username": "Sohoom_418",
                        "content": "same"
                    },
                    {
                        "username": "guptapiyush264",
                        "content": "i tried some new and efficient approach|| binary_search ||c++ ||must see||\\noptimized approch\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        \\n        int starting=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int ending= lower_bound(nums.begin(),nums.end(),target+1)-nums.begin()-1;\\n        if(binary_search(nums.begin(),nums.end(),target))\\n          {\\n            return {starting,ending};\\n          }\\n          else\\n          return {-1,-1};\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1813057,
                "content": [
                    {
                        "username": "TatianaTt",
                        "content": "Why this code does not work in LeetCode, but it works on my IDE:\\n\\n# LeetCode 34. Find First and Last Position of Element in Sorted Array\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Main Function\\n        left = self.first_tar(nums, target)\\n        right = self.last_tar(nums, target)\\n        return [left, right]\\n\\n    def last_tar(self, nums,target):\\n        last_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l+1 < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the last position of the target value           \\n                l = mid\\n        if nums[r] == target:\\n            last_target = r\\n        if nums[l] == target:\\n            last_target = l\\n        return last_target \\n    \\n    def first_tar(self, nums, target):\\n        first_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the first position of the target value           \\n                r = mid  \\n        if nums[l] == target:\\n            first_target = l\\n        if nums[r] == target:\\n            first_target = r\\n        return first_target\\n        \\n\\n\\n"
                    },
                    {
                        "username": "deepak_kaushik",
                        "content": "try doing l =  mid+1 and r=mid-1"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int left = 0,right = nums.size()-1;\\n        int n = nums.size();\\n        vector<int>ans;\\n        int point;\\n        bool flage = false;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                point = mid;\\n                // ans.push_back(mid);\\n                flage = true;\\n                break;\\n\\n            }else if(nums[mid]>target){\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        if(flage){\\n            // cout<<point;\\n            while(point != 0 && nums[point]==target){\\n                ans[0] = point;\\n                point--;\\n            }\\n            while(point != n-1 && nums[point]==target){\\n                ans[1] = point;\\n                point++;\\n            }\\n        }else{\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\nPlease find error"
                    },
                    {
                        "username": "jaindarshan295",
                        "content": "in case the whole list is of target it would take order of n time so rather than traversing every value besides \"point\" you can again apply binary search on both sides"
                    },
                    {
                        "username": "DP0307",
                        "content": "class Solution {\\npublic:\\n  int first(vector<int>& nums, int target){\\n    int ans =-1;\\n        for(int i =0;i<nums.size();i++){\\n              if(nums[i] == target ){\\n                ans = i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\nint second(vector<int>& nums, int target){\\n  int ans =-1;\\n        for(int i =nums.size()-1;i>=0;i--){\\n              if(nums[i] == target ){\\n                ans =i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n      \\n       int a = first(nums,target);\\n       int b = second(nums,target);\\n        \\n      \\n      return {a,b};\\n    }\\n};"
                    },
                    {
                        "username": "Swakshan",
                        "content": "HOW MY CODE IS ACCEPTED Even after using O(n) time complexity\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Anyone solved this question using binary search template 3? Please let me know about it.\\nThanks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is a pretty good problem."
                    },
                    {
                        "username": "adrianP",
                        "content": "How to be extra: \"non-decreasing order\" (\\u25D1\\u203F\\u25D0)"
                    },
                    {
                        "username": "papaidebnath5690",
                        "content": "if the target will be there 2 times in the nums array or not??"
                    },
                    {
                        "username": "shubhi4",
                        "content": "target element can be 0 times, 1 times or more times\\nif its 0 times then answer ->[-1,-1]\\nif its 1 times then index of target elemnt is i \\n     then answer ->[ i, i ]\\nif its >=2 times then i is index of first index of target and j is last index of target \\n     then answer ->[ i, j ]"
                    },
                    {
                        "username": "krapirastogi2329",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res;\\n        int foc=-1,loc=-1;    \\n        int l=0,h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n                foc=mid;\\n                h=mid-1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n         l=0;h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n               loc=mid;\\n                h=mid+1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        res.push_back(foc);\\n        res.push_back(loc);\\n        return res;\\n    }\\n};\\n\\n\\nwhy does this show tle?\\n"
                    },
                    {
                        "username": "Sohoom_418",
                        "content": "same"
                    },
                    {
                        "username": "guptapiyush264",
                        "content": "i tried some new and efficient approach|| binary_search ||c++ ||must see||\\noptimized approch\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        \\n        int starting=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int ending= lower_bound(nums.begin(),nums.end(),target+1)-nums.begin()-1;\\n        if(binary_search(nums.begin(),nums.end(),target))\\n          {\\n            return {starting,ending};\\n          }\\n          else\\n          return {-1,-1};\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1810734,
                "content": [
                    {
                        "username": "TatianaTt",
                        "content": "Why this code does not work in LeetCode, but it works on my IDE:\\n\\n# LeetCode 34. Find First and Last Position of Element in Sorted Array\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Main Function\\n        left = self.first_tar(nums, target)\\n        right = self.last_tar(nums, target)\\n        return [left, right]\\n\\n    def last_tar(self, nums,target):\\n        last_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l+1 < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the last position of the target value           \\n                l = mid\\n        if nums[r] == target:\\n            last_target = r\\n        if nums[l] == target:\\n            last_target = l\\n        return last_target \\n    \\n    def first_tar(self, nums, target):\\n        first_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the first position of the target value           \\n                r = mid  \\n        if nums[l] == target:\\n            first_target = l\\n        if nums[r] == target:\\n            first_target = r\\n        return first_target\\n        \\n\\n\\n"
                    },
                    {
                        "username": "deepak_kaushik",
                        "content": "try doing l =  mid+1 and r=mid-1"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int left = 0,right = nums.size()-1;\\n        int n = nums.size();\\n        vector<int>ans;\\n        int point;\\n        bool flage = false;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                point = mid;\\n                // ans.push_back(mid);\\n                flage = true;\\n                break;\\n\\n            }else if(nums[mid]>target){\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        if(flage){\\n            // cout<<point;\\n            while(point != 0 && nums[point]==target){\\n                ans[0] = point;\\n                point--;\\n            }\\n            while(point != n-1 && nums[point]==target){\\n                ans[1] = point;\\n                point++;\\n            }\\n        }else{\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\nPlease find error"
                    },
                    {
                        "username": "jaindarshan295",
                        "content": "in case the whole list is of target it would take order of n time so rather than traversing every value besides \"point\" you can again apply binary search on both sides"
                    },
                    {
                        "username": "DP0307",
                        "content": "class Solution {\\npublic:\\n  int first(vector<int>& nums, int target){\\n    int ans =-1;\\n        for(int i =0;i<nums.size();i++){\\n              if(nums[i] == target ){\\n                ans = i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\nint second(vector<int>& nums, int target){\\n  int ans =-1;\\n        for(int i =nums.size()-1;i>=0;i--){\\n              if(nums[i] == target ){\\n                ans =i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n      \\n       int a = first(nums,target);\\n       int b = second(nums,target);\\n        \\n      \\n      return {a,b};\\n    }\\n};"
                    },
                    {
                        "username": "Swakshan",
                        "content": "HOW MY CODE IS ACCEPTED Even after using O(n) time complexity\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Anyone solved this question using binary search template 3? Please let me know about it.\\nThanks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is a pretty good problem."
                    },
                    {
                        "username": "adrianP",
                        "content": "How to be extra: \"non-decreasing order\" (\\u25D1\\u203F\\u25D0)"
                    },
                    {
                        "username": "papaidebnath5690",
                        "content": "if the target will be there 2 times in the nums array or not??"
                    },
                    {
                        "username": "shubhi4",
                        "content": "target element can be 0 times, 1 times or more times\\nif its 0 times then answer ->[-1,-1]\\nif its 1 times then index of target elemnt is i \\n     then answer ->[ i, i ]\\nif its >=2 times then i is index of first index of target and j is last index of target \\n     then answer ->[ i, j ]"
                    },
                    {
                        "username": "krapirastogi2329",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res;\\n        int foc=-1,loc=-1;    \\n        int l=0,h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n                foc=mid;\\n                h=mid-1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n         l=0;h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n               loc=mid;\\n                h=mid+1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        res.push_back(foc);\\n        res.push_back(loc);\\n        return res;\\n    }\\n};\\n\\n\\nwhy does this show tle?\\n"
                    },
                    {
                        "username": "Sohoom_418",
                        "content": "same"
                    },
                    {
                        "username": "guptapiyush264",
                        "content": "i tried some new and efficient approach|| binary_search ||c++ ||must see||\\noptimized approch\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        \\n        int starting=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int ending= lower_bound(nums.begin(),nums.end(),target+1)-nums.begin()-1;\\n        if(binary_search(nums.begin(),nums.end(),target))\\n          {\\n            return {starting,ending};\\n          }\\n          else\\n          return {-1,-1};\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1809925,
                "content": [
                    {
                        "username": "TatianaTt",
                        "content": "Why this code does not work in LeetCode, but it works on my IDE:\\n\\n# LeetCode 34. Find First and Last Position of Element in Sorted Array\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Main Function\\n        left = self.first_tar(nums, target)\\n        right = self.last_tar(nums, target)\\n        return [left, right]\\n\\n    def last_tar(self, nums,target):\\n        last_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l+1 < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the last position of the target value           \\n                l = mid\\n        if nums[r] == target:\\n            last_target = r\\n        if nums[l] == target:\\n            last_target = l\\n        return last_target \\n    \\n    def first_tar(self, nums, target):\\n        first_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the first position of the target value           \\n                r = mid  \\n        if nums[l] == target:\\n            first_target = l\\n        if nums[r] == target:\\n            first_target = r\\n        return first_target\\n        \\n\\n\\n"
                    },
                    {
                        "username": "deepak_kaushik",
                        "content": "try doing l =  mid+1 and r=mid-1"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int left = 0,right = nums.size()-1;\\n        int n = nums.size();\\n        vector<int>ans;\\n        int point;\\n        bool flage = false;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                point = mid;\\n                // ans.push_back(mid);\\n                flage = true;\\n                break;\\n\\n            }else if(nums[mid]>target){\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        if(flage){\\n            // cout<<point;\\n            while(point != 0 && nums[point]==target){\\n                ans[0] = point;\\n                point--;\\n            }\\n            while(point != n-1 && nums[point]==target){\\n                ans[1] = point;\\n                point++;\\n            }\\n        }else{\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\nPlease find error"
                    },
                    {
                        "username": "jaindarshan295",
                        "content": "in case the whole list is of target it would take order of n time so rather than traversing every value besides \"point\" you can again apply binary search on both sides"
                    },
                    {
                        "username": "DP0307",
                        "content": "class Solution {\\npublic:\\n  int first(vector<int>& nums, int target){\\n    int ans =-1;\\n        for(int i =0;i<nums.size();i++){\\n              if(nums[i] == target ){\\n                ans = i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\nint second(vector<int>& nums, int target){\\n  int ans =-1;\\n        for(int i =nums.size()-1;i>=0;i--){\\n              if(nums[i] == target ){\\n                ans =i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n      \\n       int a = first(nums,target);\\n       int b = second(nums,target);\\n        \\n      \\n      return {a,b};\\n    }\\n};"
                    },
                    {
                        "username": "Swakshan",
                        "content": "HOW MY CODE IS ACCEPTED Even after using O(n) time complexity\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Anyone solved this question using binary search template 3? Please let me know about it.\\nThanks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is a pretty good problem."
                    },
                    {
                        "username": "adrianP",
                        "content": "How to be extra: \"non-decreasing order\" (\\u25D1\\u203F\\u25D0)"
                    },
                    {
                        "username": "papaidebnath5690",
                        "content": "if the target will be there 2 times in the nums array or not??"
                    },
                    {
                        "username": "shubhi4",
                        "content": "target element can be 0 times, 1 times or more times\\nif its 0 times then answer ->[-1,-1]\\nif its 1 times then index of target elemnt is i \\n     then answer ->[ i, i ]\\nif its >=2 times then i is index of first index of target and j is last index of target \\n     then answer ->[ i, j ]"
                    },
                    {
                        "username": "krapirastogi2329",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res;\\n        int foc=-1,loc=-1;    \\n        int l=0,h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n                foc=mid;\\n                h=mid-1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n         l=0;h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n               loc=mid;\\n                h=mid+1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        res.push_back(foc);\\n        res.push_back(loc);\\n        return res;\\n    }\\n};\\n\\n\\nwhy does this show tle?\\n"
                    },
                    {
                        "username": "Sohoom_418",
                        "content": "same"
                    },
                    {
                        "username": "guptapiyush264",
                        "content": "i tried some new and efficient approach|| binary_search ||c++ ||must see||\\noptimized approch\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        \\n        int starting=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int ending= lower_bound(nums.begin(),nums.end(),target+1)-nums.begin()-1;\\n        if(binary_search(nums.begin(),nums.end(),target))\\n          {\\n            return {starting,ending};\\n          }\\n          else\\n          return {-1,-1};\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1799871,
                "content": [
                    {
                        "username": "HUGE_0000",
                        "content": "If I used v.push_back(mid) here instead of v[0] =mid or v[1]=mid (as i comment out)  ,It didn\\'t pass case 2 and case3.  Plz help me how can I fix it.\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n = nums.size() , l = 0, h = n-1;\\n        vector<int>v;\\n        //  vector<int>v(2,-1);\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==0 || nums[mid]!= nums[mid-1])\\n                {\\n                    // v[0]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    h = mid-1;\\n                }\\n            }\\n\\n        }\\n        l = 0; h = n-1;\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==n-1 || nums[mid]!= nums[mid+1])\\n                {\\n                    // v[1]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    l = mid+1;\\n                }\\n            }\\n\\n        }\\n        return v;\\n        \\n\\n        \\n    }\\n    \\n};\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "O(n logn) for this is easy, not medium."
                    },
                    {
                        "username": "RitikRaj18",
                        "content": "I am getting runtime error with my code. `your inline code...your inline code...`\\nVisible Test Cases are correct but on submitting getting error with this input:-\\nnums = [2,2]\\ntarget = 2\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l = 0, r = nums.size() - 1, mid;\\n        int flag = 0;\\n        while( l <= r ){\\n            mid = l + (r - l) / 2;\\n            if( nums[mid] == target ){\\n                flag = 1;\\n                break;\\n            }    \\n            if( nums[mid] < target ){\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n        if( flag == 0){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else{\\n            int i=mid;\\n            while( nums[i] == nums[i-1] && i !=0 ) i--;\\n            ans.push_back(i);\\n\\n            i = mid;\\n            while( nums[i] == nums[i+1] && i != nums.size()-1) i++;\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\nError:-\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000070 overflowed to 0x60200000006c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "monikachand714",
                        "content": "\\n\\n`class Solution {\\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n\\n\\n        vector<int>result;\\n        int start=firstPos(nums,target);\\n        int last=lastPos(nums,target);\\n        result.push_back(start);\\n        result.push_back(last);\\n\\n        return result;\\n        \\n    }\\n    int firstPos(vector<int>& nums, int target) {\\n     int ans=-1;  \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target <nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            high=mid-1;\\n        }\\n     }\\n     return ans;\\n    }\\n\\n\\n    int lastPos(vector<int>& nums, int target){\\n     int ans=-1; \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target < nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            low=mid+1;\\n        }\\n     }\\n     return ans;\\n\\n    }\\n\\n};`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Find the mid-pointer of array. If the value at mid-pointer is greater than target, then it means that range of target lies on left of mid, if value at mid-pointer is lesser than target, then target lies on the right side, otherwise target lies on both the sides. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "What is wrong with this code I can't understand...\n\nclass Solution {\npublic:\n    int firstIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            e = mid - 1;\n            s = 0;\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\nint lastIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            s = mid + 1;\n            e = nums.size();\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\n\nvector<int> searchRange(vector<int> &nums, int target)\n{\n    vector<int> ans;\n    ans.push_back(firstIndex(nums, target));\n    ans.push_back(lastIndex(nums, target));\n    return ans;\n}\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n    int first_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int f= INT_MAX;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            f = min(f,mid);\\n            e= mid -1;\\n        }\\n        else if(v[mid] > key)\\n        { \\n            e  = mid-1;\\n\\n        }else\\n        {\\n                 s = mid+1;\\n        }\\n    }\\n    if( f == INT_MAX)\\n         f = -1; \\n    return f;\\n\\n}\\nint last_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int l= INT_MIN;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            l = max(l,mid);\\n            s= mid +1;\\n        }\\n        else if(v[mid] > key)\\n        { e  = mid-1;\\n        }\\n        else\\n        {\\n             s = mid+1;\\n        }\\n    }\\n    if( l == INT_MIN)\\n    { \\n        l = -1; \\n    }\\n    return l;\\n\\n}\\npublic:\\nvector<int> searchRange(vector<int>&arr,int key)\\n{\\n    int n = arr.size();\\n    \\n    int ans1 = first_index(arr,key);\\n    int ans2 = last_index(arr,key);\\n\\n    vector<int>v;\\n    v.push_back(ans1);\\n    v.push_back(ans2);\\n    return v;\\n\\n}\\n};"
                    },
                    {
                        "username": "spriyanka2244",
                        "content": "            [0,1,2,3,4,5,6]\\nnums =[5,7,7,8,8,8,10]   target =8  Output =[3,5]\\n\\nif  nums[mid] < x:   ((( if target (x) exit and mid value (4)  is less than target value (x) (8)  ))) \\n                    lo = mid+1 ((than it return left most lower value ))\\n                else:\\n                    hi = mid    (((   if target (x) exit and mid value (4)  is greater than target value (x) (2)  )))             \\n            return lo             (( than it return index value which is equal to target value of index  ))\\n\\nlo = search(target)  it return the  index value eg 3\\n\\nhi = search(target+1)-1   the arr start with 0,1,2,3,4 when we say search(target+1) it will return which         _                                      is high index value 6 that  will count from 1,2,3 so only we -1  to get 5 index\\n"
                    },
                    {
                        "username": "ritikumra",
                        "content": "Heyy! I have used this approach of binary search and then finding the element and returning it\\'s start and ending index. Only 4 test cases have been passed can anyone help me optimize it and find the error. \\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int s=0;\\n        int n= nums.size();\\n        int e=n-1;\\n        int arr[2]={-1,-1};\\n\\n        while(s<=e){\\n\\n            int mid= s+(e-s)/2;\\n            if(nums[mid]==target){\\n                if(nums[mid]==nums[mid-1]){\\n                    arr[0]=mid-1;\\n                    arr[1]=mid;\\n                }\\n                if(nums[mid]==nums[mid+1]){\\n                    arr[0]=mid;\\n                    arr[1]=mid+1;\\n                }\\n            }\\n\\n            if(nums[mid]>target){\\n                e=mid+1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            if(nums[mid]<target){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return {arr[0],arr[1]};\\n        \\n    }\\n};"
                    },
                    {
                        "username": "prabaltripathi",
                        "content": "i am solving it through java and with O(log n ) complexity probably 2log n .....yet it is showing Time Limit ecxeeded"
                    }
                ]
            },
            {
                "id": 1799192,
                "content": [
                    {
                        "username": "HUGE_0000",
                        "content": "If I used v.push_back(mid) here instead of v[0] =mid or v[1]=mid (as i comment out)  ,It didn\\'t pass case 2 and case3.  Plz help me how can I fix it.\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n = nums.size() , l = 0, h = n-1;\\n        vector<int>v;\\n        //  vector<int>v(2,-1);\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==0 || nums[mid]!= nums[mid-1])\\n                {\\n                    // v[0]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    h = mid-1;\\n                }\\n            }\\n\\n        }\\n        l = 0; h = n-1;\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==n-1 || nums[mid]!= nums[mid+1])\\n                {\\n                    // v[1]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    l = mid+1;\\n                }\\n            }\\n\\n        }\\n        return v;\\n        \\n\\n        \\n    }\\n    \\n};\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "O(n logn) for this is easy, not medium."
                    },
                    {
                        "username": "RitikRaj18",
                        "content": "I am getting runtime error with my code. `your inline code...your inline code...`\\nVisible Test Cases are correct but on submitting getting error with this input:-\\nnums = [2,2]\\ntarget = 2\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l = 0, r = nums.size() - 1, mid;\\n        int flag = 0;\\n        while( l <= r ){\\n            mid = l + (r - l) / 2;\\n            if( nums[mid] == target ){\\n                flag = 1;\\n                break;\\n            }    \\n            if( nums[mid] < target ){\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n        if( flag == 0){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else{\\n            int i=mid;\\n            while( nums[i] == nums[i-1] && i !=0 ) i--;\\n            ans.push_back(i);\\n\\n            i = mid;\\n            while( nums[i] == nums[i+1] && i != nums.size()-1) i++;\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\nError:-\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000070 overflowed to 0x60200000006c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "monikachand714",
                        "content": "\\n\\n`class Solution {\\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n\\n\\n        vector<int>result;\\n        int start=firstPos(nums,target);\\n        int last=lastPos(nums,target);\\n        result.push_back(start);\\n        result.push_back(last);\\n\\n        return result;\\n        \\n    }\\n    int firstPos(vector<int>& nums, int target) {\\n     int ans=-1;  \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target <nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            high=mid-1;\\n        }\\n     }\\n     return ans;\\n    }\\n\\n\\n    int lastPos(vector<int>& nums, int target){\\n     int ans=-1; \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target < nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            low=mid+1;\\n        }\\n     }\\n     return ans;\\n\\n    }\\n\\n};`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Find the mid-pointer of array. If the value at mid-pointer is greater than target, then it means that range of target lies on left of mid, if value at mid-pointer is lesser than target, then target lies on the right side, otherwise target lies on both the sides. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "What is wrong with this code I can't understand...\n\nclass Solution {\npublic:\n    int firstIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            e = mid - 1;\n            s = 0;\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\nint lastIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            s = mid + 1;\n            e = nums.size();\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\n\nvector<int> searchRange(vector<int> &nums, int target)\n{\n    vector<int> ans;\n    ans.push_back(firstIndex(nums, target));\n    ans.push_back(lastIndex(nums, target));\n    return ans;\n}\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n    int first_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int f= INT_MAX;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            f = min(f,mid);\\n            e= mid -1;\\n        }\\n        else if(v[mid] > key)\\n        { \\n            e  = mid-1;\\n\\n        }else\\n        {\\n                 s = mid+1;\\n        }\\n    }\\n    if( f == INT_MAX)\\n         f = -1; \\n    return f;\\n\\n}\\nint last_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int l= INT_MIN;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            l = max(l,mid);\\n            s= mid +1;\\n        }\\n        else if(v[mid] > key)\\n        { e  = mid-1;\\n        }\\n        else\\n        {\\n             s = mid+1;\\n        }\\n    }\\n    if( l == INT_MIN)\\n    { \\n        l = -1; \\n    }\\n    return l;\\n\\n}\\npublic:\\nvector<int> searchRange(vector<int>&arr,int key)\\n{\\n    int n = arr.size();\\n    \\n    int ans1 = first_index(arr,key);\\n    int ans2 = last_index(arr,key);\\n\\n    vector<int>v;\\n    v.push_back(ans1);\\n    v.push_back(ans2);\\n    return v;\\n\\n}\\n};"
                    },
                    {
                        "username": "spriyanka2244",
                        "content": "            [0,1,2,3,4,5,6]\\nnums =[5,7,7,8,8,8,10]   target =8  Output =[3,5]\\n\\nif  nums[mid] < x:   ((( if target (x) exit and mid value (4)  is less than target value (x) (8)  ))) \\n                    lo = mid+1 ((than it return left most lower value ))\\n                else:\\n                    hi = mid    (((   if target (x) exit and mid value (4)  is greater than target value (x) (2)  )))             \\n            return lo             (( than it return index value which is equal to target value of index  ))\\n\\nlo = search(target)  it return the  index value eg 3\\n\\nhi = search(target+1)-1   the arr start with 0,1,2,3,4 when we say search(target+1) it will return which         _                                      is high index value 6 that  will count from 1,2,3 so only we -1  to get 5 index\\n"
                    },
                    {
                        "username": "ritikumra",
                        "content": "Heyy! I have used this approach of binary search and then finding the element and returning it\\'s start and ending index. Only 4 test cases have been passed can anyone help me optimize it and find the error. \\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int s=0;\\n        int n= nums.size();\\n        int e=n-1;\\n        int arr[2]={-1,-1};\\n\\n        while(s<=e){\\n\\n            int mid= s+(e-s)/2;\\n            if(nums[mid]==target){\\n                if(nums[mid]==nums[mid-1]){\\n                    arr[0]=mid-1;\\n                    arr[1]=mid;\\n                }\\n                if(nums[mid]==nums[mid+1]){\\n                    arr[0]=mid;\\n                    arr[1]=mid+1;\\n                }\\n            }\\n\\n            if(nums[mid]>target){\\n                e=mid+1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            if(nums[mid]<target){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return {arr[0],arr[1]};\\n        \\n    }\\n};"
                    },
                    {
                        "username": "prabaltripathi",
                        "content": "i am solving it through java and with O(log n ) complexity probably 2log n .....yet it is showing Time Limit ecxeeded"
                    }
                ]
            },
            {
                "id": 1798389,
                "content": [
                    {
                        "username": "HUGE_0000",
                        "content": "If I used v.push_back(mid) here instead of v[0] =mid or v[1]=mid (as i comment out)  ,It didn\\'t pass case 2 and case3.  Plz help me how can I fix it.\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n = nums.size() , l = 0, h = n-1;\\n        vector<int>v;\\n        //  vector<int>v(2,-1);\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==0 || nums[mid]!= nums[mid-1])\\n                {\\n                    // v[0]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    h = mid-1;\\n                }\\n            }\\n\\n        }\\n        l = 0; h = n-1;\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==n-1 || nums[mid]!= nums[mid+1])\\n                {\\n                    // v[1]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    l = mid+1;\\n                }\\n            }\\n\\n        }\\n        return v;\\n        \\n\\n        \\n    }\\n    \\n};\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "O(n logn) for this is easy, not medium."
                    },
                    {
                        "username": "RitikRaj18",
                        "content": "I am getting runtime error with my code. `your inline code...your inline code...`\\nVisible Test Cases are correct but on submitting getting error with this input:-\\nnums = [2,2]\\ntarget = 2\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l = 0, r = nums.size() - 1, mid;\\n        int flag = 0;\\n        while( l <= r ){\\n            mid = l + (r - l) / 2;\\n            if( nums[mid] == target ){\\n                flag = 1;\\n                break;\\n            }    \\n            if( nums[mid] < target ){\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n        if( flag == 0){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else{\\n            int i=mid;\\n            while( nums[i] == nums[i-1] && i !=0 ) i--;\\n            ans.push_back(i);\\n\\n            i = mid;\\n            while( nums[i] == nums[i+1] && i != nums.size()-1) i++;\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\nError:-\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000070 overflowed to 0x60200000006c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "monikachand714",
                        "content": "\\n\\n`class Solution {\\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n\\n\\n        vector<int>result;\\n        int start=firstPos(nums,target);\\n        int last=lastPos(nums,target);\\n        result.push_back(start);\\n        result.push_back(last);\\n\\n        return result;\\n        \\n    }\\n    int firstPos(vector<int>& nums, int target) {\\n     int ans=-1;  \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target <nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            high=mid-1;\\n        }\\n     }\\n     return ans;\\n    }\\n\\n\\n    int lastPos(vector<int>& nums, int target){\\n     int ans=-1; \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target < nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            low=mid+1;\\n        }\\n     }\\n     return ans;\\n\\n    }\\n\\n};`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Find the mid-pointer of array. If the value at mid-pointer is greater than target, then it means that range of target lies on left of mid, if value at mid-pointer is lesser than target, then target lies on the right side, otherwise target lies on both the sides. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "What is wrong with this code I can't understand...\n\nclass Solution {\npublic:\n    int firstIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            e = mid - 1;\n            s = 0;\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\nint lastIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            s = mid + 1;\n            e = nums.size();\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\n\nvector<int> searchRange(vector<int> &nums, int target)\n{\n    vector<int> ans;\n    ans.push_back(firstIndex(nums, target));\n    ans.push_back(lastIndex(nums, target));\n    return ans;\n}\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n    int first_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int f= INT_MAX;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            f = min(f,mid);\\n            e= mid -1;\\n        }\\n        else if(v[mid] > key)\\n        { \\n            e  = mid-1;\\n\\n        }else\\n        {\\n                 s = mid+1;\\n        }\\n    }\\n    if( f == INT_MAX)\\n         f = -1; \\n    return f;\\n\\n}\\nint last_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int l= INT_MIN;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            l = max(l,mid);\\n            s= mid +1;\\n        }\\n        else if(v[mid] > key)\\n        { e  = mid-1;\\n        }\\n        else\\n        {\\n             s = mid+1;\\n        }\\n    }\\n    if( l == INT_MIN)\\n    { \\n        l = -1; \\n    }\\n    return l;\\n\\n}\\npublic:\\nvector<int> searchRange(vector<int>&arr,int key)\\n{\\n    int n = arr.size();\\n    \\n    int ans1 = first_index(arr,key);\\n    int ans2 = last_index(arr,key);\\n\\n    vector<int>v;\\n    v.push_back(ans1);\\n    v.push_back(ans2);\\n    return v;\\n\\n}\\n};"
                    },
                    {
                        "username": "spriyanka2244",
                        "content": "            [0,1,2,3,4,5,6]\\nnums =[5,7,7,8,8,8,10]   target =8  Output =[3,5]\\n\\nif  nums[mid] < x:   ((( if target (x) exit and mid value (4)  is less than target value (x) (8)  ))) \\n                    lo = mid+1 ((than it return left most lower value ))\\n                else:\\n                    hi = mid    (((   if target (x) exit and mid value (4)  is greater than target value (x) (2)  )))             \\n            return lo             (( than it return index value which is equal to target value of index  ))\\n\\nlo = search(target)  it return the  index value eg 3\\n\\nhi = search(target+1)-1   the arr start with 0,1,2,3,4 when we say search(target+1) it will return which         _                                      is high index value 6 that  will count from 1,2,3 so only we -1  to get 5 index\\n"
                    },
                    {
                        "username": "ritikumra",
                        "content": "Heyy! I have used this approach of binary search and then finding the element and returning it\\'s start and ending index. Only 4 test cases have been passed can anyone help me optimize it and find the error. \\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int s=0;\\n        int n= nums.size();\\n        int e=n-1;\\n        int arr[2]={-1,-1};\\n\\n        while(s<=e){\\n\\n            int mid= s+(e-s)/2;\\n            if(nums[mid]==target){\\n                if(nums[mid]==nums[mid-1]){\\n                    arr[0]=mid-1;\\n                    arr[1]=mid;\\n                }\\n                if(nums[mid]==nums[mid+1]){\\n                    arr[0]=mid;\\n                    arr[1]=mid+1;\\n                }\\n            }\\n\\n            if(nums[mid]>target){\\n                e=mid+1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            if(nums[mid]<target){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return {arr[0],arr[1]};\\n        \\n    }\\n};"
                    },
                    {
                        "username": "prabaltripathi",
                        "content": "i am solving it through java and with O(log n ) complexity probably 2log n .....yet it is showing Time Limit ecxeeded"
                    }
                ]
            },
            {
                "id": 1797716,
                "content": [
                    {
                        "username": "HUGE_0000",
                        "content": "If I used v.push_back(mid) here instead of v[0] =mid or v[1]=mid (as i comment out)  ,It didn\\'t pass case 2 and case3.  Plz help me how can I fix it.\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n = nums.size() , l = 0, h = n-1;\\n        vector<int>v;\\n        //  vector<int>v(2,-1);\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==0 || nums[mid]!= nums[mid-1])\\n                {\\n                    // v[0]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    h = mid-1;\\n                }\\n            }\\n\\n        }\\n        l = 0; h = n-1;\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==n-1 || nums[mid]!= nums[mid+1])\\n                {\\n                    // v[1]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    l = mid+1;\\n                }\\n            }\\n\\n        }\\n        return v;\\n        \\n\\n        \\n    }\\n    \\n};\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "O(n logn) for this is easy, not medium."
                    },
                    {
                        "username": "RitikRaj18",
                        "content": "I am getting runtime error with my code. `your inline code...your inline code...`\\nVisible Test Cases are correct but on submitting getting error with this input:-\\nnums = [2,2]\\ntarget = 2\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l = 0, r = nums.size() - 1, mid;\\n        int flag = 0;\\n        while( l <= r ){\\n            mid = l + (r - l) / 2;\\n            if( nums[mid] == target ){\\n                flag = 1;\\n                break;\\n            }    \\n            if( nums[mid] < target ){\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n        if( flag == 0){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else{\\n            int i=mid;\\n            while( nums[i] == nums[i-1] && i !=0 ) i--;\\n            ans.push_back(i);\\n\\n            i = mid;\\n            while( nums[i] == nums[i+1] && i != nums.size()-1) i++;\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\nError:-\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000070 overflowed to 0x60200000006c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "monikachand714",
                        "content": "\\n\\n`class Solution {\\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n\\n\\n        vector<int>result;\\n        int start=firstPos(nums,target);\\n        int last=lastPos(nums,target);\\n        result.push_back(start);\\n        result.push_back(last);\\n\\n        return result;\\n        \\n    }\\n    int firstPos(vector<int>& nums, int target) {\\n     int ans=-1;  \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target <nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            high=mid-1;\\n        }\\n     }\\n     return ans;\\n    }\\n\\n\\n    int lastPos(vector<int>& nums, int target){\\n     int ans=-1; \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target < nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            low=mid+1;\\n        }\\n     }\\n     return ans;\\n\\n    }\\n\\n};`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Find the mid-pointer of array. If the value at mid-pointer is greater than target, then it means that range of target lies on left of mid, if value at mid-pointer is lesser than target, then target lies on the right side, otherwise target lies on both the sides. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "What is wrong with this code I can't understand...\n\nclass Solution {\npublic:\n    int firstIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            e = mid - 1;\n            s = 0;\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\nint lastIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            s = mid + 1;\n            e = nums.size();\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\n\nvector<int> searchRange(vector<int> &nums, int target)\n{\n    vector<int> ans;\n    ans.push_back(firstIndex(nums, target));\n    ans.push_back(lastIndex(nums, target));\n    return ans;\n}\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n    int first_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int f= INT_MAX;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            f = min(f,mid);\\n            e= mid -1;\\n        }\\n        else if(v[mid] > key)\\n        { \\n            e  = mid-1;\\n\\n        }else\\n        {\\n                 s = mid+1;\\n        }\\n    }\\n    if( f == INT_MAX)\\n         f = -1; \\n    return f;\\n\\n}\\nint last_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int l= INT_MIN;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            l = max(l,mid);\\n            s= mid +1;\\n        }\\n        else if(v[mid] > key)\\n        { e  = mid-1;\\n        }\\n        else\\n        {\\n             s = mid+1;\\n        }\\n    }\\n    if( l == INT_MIN)\\n    { \\n        l = -1; \\n    }\\n    return l;\\n\\n}\\npublic:\\nvector<int> searchRange(vector<int>&arr,int key)\\n{\\n    int n = arr.size();\\n    \\n    int ans1 = first_index(arr,key);\\n    int ans2 = last_index(arr,key);\\n\\n    vector<int>v;\\n    v.push_back(ans1);\\n    v.push_back(ans2);\\n    return v;\\n\\n}\\n};"
                    },
                    {
                        "username": "spriyanka2244",
                        "content": "            [0,1,2,3,4,5,6]\\nnums =[5,7,7,8,8,8,10]   target =8  Output =[3,5]\\n\\nif  nums[mid] < x:   ((( if target (x) exit and mid value (4)  is less than target value (x) (8)  ))) \\n                    lo = mid+1 ((than it return left most lower value ))\\n                else:\\n                    hi = mid    (((   if target (x) exit and mid value (4)  is greater than target value (x) (2)  )))             \\n            return lo             (( than it return index value which is equal to target value of index  ))\\n\\nlo = search(target)  it return the  index value eg 3\\n\\nhi = search(target+1)-1   the arr start with 0,1,2,3,4 when we say search(target+1) it will return which         _                                      is high index value 6 that  will count from 1,2,3 so only we -1  to get 5 index\\n"
                    },
                    {
                        "username": "ritikumra",
                        "content": "Heyy! I have used this approach of binary search and then finding the element and returning it\\'s start and ending index. Only 4 test cases have been passed can anyone help me optimize it and find the error. \\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int s=0;\\n        int n= nums.size();\\n        int e=n-1;\\n        int arr[2]={-1,-1};\\n\\n        while(s<=e){\\n\\n            int mid= s+(e-s)/2;\\n            if(nums[mid]==target){\\n                if(nums[mid]==nums[mid-1]){\\n                    arr[0]=mid-1;\\n                    arr[1]=mid;\\n                }\\n                if(nums[mid]==nums[mid+1]){\\n                    arr[0]=mid;\\n                    arr[1]=mid+1;\\n                }\\n            }\\n\\n            if(nums[mid]>target){\\n                e=mid+1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            if(nums[mid]<target){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return {arr[0],arr[1]};\\n        \\n    }\\n};"
                    },
                    {
                        "username": "prabaltripathi",
                        "content": "i am solving it through java and with O(log n ) complexity probably 2log n .....yet it is showing Time Limit ecxeeded"
                    }
                ]
            },
            {
                "id": 1797006,
                "content": [
                    {
                        "username": "HUGE_0000",
                        "content": "If I used v.push_back(mid) here instead of v[0] =mid or v[1]=mid (as i comment out)  ,It didn\\'t pass case 2 and case3.  Plz help me how can I fix it.\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n = nums.size() , l = 0, h = n-1;\\n        vector<int>v;\\n        //  vector<int>v(2,-1);\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==0 || nums[mid]!= nums[mid-1])\\n                {\\n                    // v[0]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    h = mid-1;\\n                }\\n            }\\n\\n        }\\n        l = 0; h = n-1;\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==n-1 || nums[mid]!= nums[mid+1])\\n                {\\n                    // v[1]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    l = mid+1;\\n                }\\n            }\\n\\n        }\\n        return v;\\n        \\n\\n        \\n    }\\n    \\n};\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "O(n logn) for this is easy, not medium."
                    },
                    {
                        "username": "RitikRaj18",
                        "content": "I am getting runtime error with my code. `your inline code...your inline code...`\\nVisible Test Cases are correct but on submitting getting error with this input:-\\nnums = [2,2]\\ntarget = 2\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l = 0, r = nums.size() - 1, mid;\\n        int flag = 0;\\n        while( l <= r ){\\n            mid = l + (r - l) / 2;\\n            if( nums[mid] == target ){\\n                flag = 1;\\n                break;\\n            }    \\n            if( nums[mid] < target ){\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n        if( flag == 0){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else{\\n            int i=mid;\\n            while( nums[i] == nums[i-1] && i !=0 ) i--;\\n            ans.push_back(i);\\n\\n            i = mid;\\n            while( nums[i] == nums[i+1] && i != nums.size()-1) i++;\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\nError:-\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000070 overflowed to 0x60200000006c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "monikachand714",
                        "content": "\\n\\n`class Solution {\\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n\\n\\n        vector<int>result;\\n        int start=firstPos(nums,target);\\n        int last=lastPos(nums,target);\\n        result.push_back(start);\\n        result.push_back(last);\\n\\n        return result;\\n        \\n    }\\n    int firstPos(vector<int>& nums, int target) {\\n     int ans=-1;  \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target <nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            high=mid-1;\\n        }\\n     }\\n     return ans;\\n    }\\n\\n\\n    int lastPos(vector<int>& nums, int target){\\n     int ans=-1; \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target < nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            low=mid+1;\\n        }\\n     }\\n     return ans;\\n\\n    }\\n\\n};`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Find the mid-pointer of array. If the value at mid-pointer is greater than target, then it means that range of target lies on left of mid, if value at mid-pointer is lesser than target, then target lies on the right side, otherwise target lies on both the sides. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "What is wrong with this code I can't understand...\n\nclass Solution {\npublic:\n    int firstIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            e = mid - 1;\n            s = 0;\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\nint lastIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            s = mid + 1;\n            e = nums.size();\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\n\nvector<int> searchRange(vector<int> &nums, int target)\n{\n    vector<int> ans;\n    ans.push_back(firstIndex(nums, target));\n    ans.push_back(lastIndex(nums, target));\n    return ans;\n}\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n    int first_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int f= INT_MAX;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            f = min(f,mid);\\n            e= mid -1;\\n        }\\n        else if(v[mid] > key)\\n        { \\n            e  = mid-1;\\n\\n        }else\\n        {\\n                 s = mid+1;\\n        }\\n    }\\n    if( f == INT_MAX)\\n         f = -1; \\n    return f;\\n\\n}\\nint last_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int l= INT_MIN;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            l = max(l,mid);\\n            s= mid +1;\\n        }\\n        else if(v[mid] > key)\\n        { e  = mid-1;\\n        }\\n        else\\n        {\\n             s = mid+1;\\n        }\\n    }\\n    if( l == INT_MIN)\\n    { \\n        l = -1; \\n    }\\n    return l;\\n\\n}\\npublic:\\nvector<int> searchRange(vector<int>&arr,int key)\\n{\\n    int n = arr.size();\\n    \\n    int ans1 = first_index(arr,key);\\n    int ans2 = last_index(arr,key);\\n\\n    vector<int>v;\\n    v.push_back(ans1);\\n    v.push_back(ans2);\\n    return v;\\n\\n}\\n};"
                    },
                    {
                        "username": "spriyanka2244",
                        "content": "            [0,1,2,3,4,5,6]\\nnums =[5,7,7,8,8,8,10]   target =8  Output =[3,5]\\n\\nif  nums[mid] < x:   ((( if target (x) exit and mid value (4)  is less than target value (x) (8)  ))) \\n                    lo = mid+1 ((than it return left most lower value ))\\n                else:\\n                    hi = mid    (((   if target (x) exit and mid value (4)  is greater than target value (x) (2)  )))             \\n            return lo             (( than it return index value which is equal to target value of index  ))\\n\\nlo = search(target)  it return the  index value eg 3\\n\\nhi = search(target+1)-1   the arr start with 0,1,2,3,4 when we say search(target+1) it will return which         _                                      is high index value 6 that  will count from 1,2,3 so only we -1  to get 5 index\\n"
                    },
                    {
                        "username": "ritikumra",
                        "content": "Heyy! I have used this approach of binary search and then finding the element and returning it\\'s start and ending index. Only 4 test cases have been passed can anyone help me optimize it and find the error. \\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int s=0;\\n        int n= nums.size();\\n        int e=n-1;\\n        int arr[2]={-1,-1};\\n\\n        while(s<=e){\\n\\n            int mid= s+(e-s)/2;\\n            if(nums[mid]==target){\\n                if(nums[mid]==nums[mid-1]){\\n                    arr[0]=mid-1;\\n                    arr[1]=mid;\\n                }\\n                if(nums[mid]==nums[mid+1]){\\n                    arr[0]=mid;\\n                    arr[1]=mid+1;\\n                }\\n            }\\n\\n            if(nums[mid]>target){\\n                e=mid+1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            if(nums[mid]<target){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return {arr[0],arr[1]};\\n        \\n    }\\n};"
                    },
                    {
                        "username": "prabaltripathi",
                        "content": "i am solving it through java and with O(log n ) complexity probably 2log n .....yet it is showing Time Limit ecxeeded"
                    }
                ]
            },
            {
                "id": 1796821,
                "content": [
                    {
                        "username": "HUGE_0000",
                        "content": "If I used v.push_back(mid) here instead of v[0] =mid or v[1]=mid (as i comment out)  ,It didn\\'t pass case 2 and case3.  Plz help me how can I fix it.\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n = nums.size() , l = 0, h = n-1;\\n        vector<int>v;\\n        //  vector<int>v(2,-1);\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==0 || nums[mid]!= nums[mid-1])\\n                {\\n                    // v[0]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    h = mid-1;\\n                }\\n            }\\n\\n        }\\n        l = 0; h = n-1;\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==n-1 || nums[mid]!= nums[mid+1])\\n                {\\n                    // v[1]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    l = mid+1;\\n                }\\n            }\\n\\n        }\\n        return v;\\n        \\n\\n        \\n    }\\n    \\n};\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "O(n logn) for this is easy, not medium."
                    },
                    {
                        "username": "RitikRaj18",
                        "content": "I am getting runtime error with my code. `your inline code...your inline code...`\\nVisible Test Cases are correct but on submitting getting error with this input:-\\nnums = [2,2]\\ntarget = 2\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l = 0, r = nums.size() - 1, mid;\\n        int flag = 0;\\n        while( l <= r ){\\n            mid = l + (r - l) / 2;\\n            if( nums[mid] == target ){\\n                flag = 1;\\n                break;\\n            }    \\n            if( nums[mid] < target ){\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n        if( flag == 0){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else{\\n            int i=mid;\\n            while( nums[i] == nums[i-1] && i !=0 ) i--;\\n            ans.push_back(i);\\n\\n            i = mid;\\n            while( nums[i] == nums[i+1] && i != nums.size()-1) i++;\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\nError:-\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000070 overflowed to 0x60200000006c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "monikachand714",
                        "content": "\\n\\n`class Solution {\\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n\\n\\n        vector<int>result;\\n        int start=firstPos(nums,target);\\n        int last=lastPos(nums,target);\\n        result.push_back(start);\\n        result.push_back(last);\\n\\n        return result;\\n        \\n    }\\n    int firstPos(vector<int>& nums, int target) {\\n     int ans=-1;  \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target <nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            high=mid-1;\\n        }\\n     }\\n     return ans;\\n    }\\n\\n\\n    int lastPos(vector<int>& nums, int target){\\n     int ans=-1; \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target < nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            low=mid+1;\\n        }\\n     }\\n     return ans;\\n\\n    }\\n\\n};`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Find the mid-pointer of array. If the value at mid-pointer is greater than target, then it means that range of target lies on left of mid, if value at mid-pointer is lesser than target, then target lies on the right side, otherwise target lies on both the sides. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "What is wrong with this code I can't understand...\n\nclass Solution {\npublic:\n    int firstIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            e = mid - 1;\n            s = 0;\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\nint lastIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            s = mid + 1;\n            e = nums.size();\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\n\nvector<int> searchRange(vector<int> &nums, int target)\n{\n    vector<int> ans;\n    ans.push_back(firstIndex(nums, target));\n    ans.push_back(lastIndex(nums, target));\n    return ans;\n}\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n    int first_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int f= INT_MAX;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            f = min(f,mid);\\n            e= mid -1;\\n        }\\n        else if(v[mid] > key)\\n        { \\n            e  = mid-1;\\n\\n        }else\\n        {\\n                 s = mid+1;\\n        }\\n    }\\n    if( f == INT_MAX)\\n         f = -1; \\n    return f;\\n\\n}\\nint last_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int l= INT_MIN;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            l = max(l,mid);\\n            s= mid +1;\\n        }\\n        else if(v[mid] > key)\\n        { e  = mid-1;\\n        }\\n        else\\n        {\\n             s = mid+1;\\n        }\\n    }\\n    if( l == INT_MIN)\\n    { \\n        l = -1; \\n    }\\n    return l;\\n\\n}\\npublic:\\nvector<int> searchRange(vector<int>&arr,int key)\\n{\\n    int n = arr.size();\\n    \\n    int ans1 = first_index(arr,key);\\n    int ans2 = last_index(arr,key);\\n\\n    vector<int>v;\\n    v.push_back(ans1);\\n    v.push_back(ans2);\\n    return v;\\n\\n}\\n};"
                    },
                    {
                        "username": "spriyanka2244",
                        "content": "            [0,1,2,3,4,5,6]\\nnums =[5,7,7,8,8,8,10]   target =8  Output =[3,5]\\n\\nif  nums[mid] < x:   ((( if target (x) exit and mid value (4)  is less than target value (x) (8)  ))) \\n                    lo = mid+1 ((than it return left most lower value ))\\n                else:\\n                    hi = mid    (((   if target (x) exit and mid value (4)  is greater than target value (x) (2)  )))             \\n            return lo             (( than it return index value which is equal to target value of index  ))\\n\\nlo = search(target)  it return the  index value eg 3\\n\\nhi = search(target+1)-1   the arr start with 0,1,2,3,4 when we say search(target+1) it will return which         _                                      is high index value 6 that  will count from 1,2,3 so only we -1  to get 5 index\\n"
                    },
                    {
                        "username": "ritikumra",
                        "content": "Heyy! I have used this approach of binary search and then finding the element and returning it\\'s start and ending index. Only 4 test cases have been passed can anyone help me optimize it and find the error. \\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int s=0;\\n        int n= nums.size();\\n        int e=n-1;\\n        int arr[2]={-1,-1};\\n\\n        while(s<=e){\\n\\n            int mid= s+(e-s)/2;\\n            if(nums[mid]==target){\\n                if(nums[mid]==nums[mid-1]){\\n                    arr[0]=mid-1;\\n                    arr[1]=mid;\\n                }\\n                if(nums[mid]==nums[mid+1]){\\n                    arr[0]=mid;\\n                    arr[1]=mid+1;\\n                }\\n            }\\n\\n            if(nums[mid]>target){\\n                e=mid+1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            if(nums[mid]<target){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return {arr[0],arr[1]};\\n        \\n    }\\n};"
                    },
                    {
                        "username": "prabaltripathi",
                        "content": "i am solving it through java and with O(log n ) complexity probably 2log n .....yet it is showing Time Limit ecxeeded"
                    }
                ]
            },
            {
                "id": 1795347,
                "content": [
                    {
                        "username": "HUGE_0000",
                        "content": "If I used v.push_back(mid) here instead of v[0] =mid or v[1]=mid (as i comment out)  ,It didn\\'t pass case 2 and case3.  Plz help me how can I fix it.\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n = nums.size() , l = 0, h = n-1;\\n        vector<int>v;\\n        //  vector<int>v(2,-1);\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==0 || nums[mid]!= nums[mid-1])\\n                {\\n                    // v[0]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    h = mid-1;\\n                }\\n            }\\n\\n        }\\n        l = 0; h = n-1;\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==n-1 || nums[mid]!= nums[mid+1])\\n                {\\n                    // v[1]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    l = mid+1;\\n                }\\n            }\\n\\n        }\\n        return v;\\n        \\n\\n        \\n    }\\n    \\n};\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "O(n logn) for this is easy, not medium."
                    },
                    {
                        "username": "RitikRaj18",
                        "content": "I am getting runtime error with my code. `your inline code...your inline code...`\\nVisible Test Cases are correct but on submitting getting error with this input:-\\nnums = [2,2]\\ntarget = 2\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l = 0, r = nums.size() - 1, mid;\\n        int flag = 0;\\n        while( l <= r ){\\n            mid = l + (r - l) / 2;\\n            if( nums[mid] == target ){\\n                flag = 1;\\n                break;\\n            }    \\n            if( nums[mid] < target ){\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n        if( flag == 0){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else{\\n            int i=mid;\\n            while( nums[i] == nums[i-1] && i !=0 ) i--;\\n            ans.push_back(i);\\n\\n            i = mid;\\n            while( nums[i] == nums[i+1] && i != nums.size()-1) i++;\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\nError:-\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000070 overflowed to 0x60200000006c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "monikachand714",
                        "content": "\\n\\n`class Solution {\\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n\\n\\n        vector<int>result;\\n        int start=firstPos(nums,target);\\n        int last=lastPos(nums,target);\\n        result.push_back(start);\\n        result.push_back(last);\\n\\n        return result;\\n        \\n    }\\n    int firstPos(vector<int>& nums, int target) {\\n     int ans=-1;  \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target <nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            high=mid-1;\\n        }\\n     }\\n     return ans;\\n    }\\n\\n\\n    int lastPos(vector<int>& nums, int target){\\n     int ans=-1; \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target < nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            low=mid+1;\\n        }\\n     }\\n     return ans;\\n\\n    }\\n\\n};`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Find the mid-pointer of array. If the value at mid-pointer is greater than target, then it means that range of target lies on left of mid, if value at mid-pointer is lesser than target, then target lies on the right side, otherwise target lies on both the sides. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "What is wrong with this code I can't understand...\n\nclass Solution {\npublic:\n    int firstIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            e = mid - 1;\n            s = 0;\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\nint lastIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            s = mid + 1;\n            e = nums.size();\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\n\nvector<int> searchRange(vector<int> &nums, int target)\n{\n    vector<int> ans;\n    ans.push_back(firstIndex(nums, target));\n    ans.push_back(lastIndex(nums, target));\n    return ans;\n}\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n    int first_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int f= INT_MAX;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            f = min(f,mid);\\n            e= mid -1;\\n        }\\n        else if(v[mid] > key)\\n        { \\n            e  = mid-1;\\n\\n        }else\\n        {\\n                 s = mid+1;\\n        }\\n    }\\n    if( f == INT_MAX)\\n         f = -1; \\n    return f;\\n\\n}\\nint last_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int l= INT_MIN;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            l = max(l,mid);\\n            s= mid +1;\\n        }\\n        else if(v[mid] > key)\\n        { e  = mid-1;\\n        }\\n        else\\n        {\\n             s = mid+1;\\n        }\\n    }\\n    if( l == INT_MIN)\\n    { \\n        l = -1; \\n    }\\n    return l;\\n\\n}\\npublic:\\nvector<int> searchRange(vector<int>&arr,int key)\\n{\\n    int n = arr.size();\\n    \\n    int ans1 = first_index(arr,key);\\n    int ans2 = last_index(arr,key);\\n\\n    vector<int>v;\\n    v.push_back(ans1);\\n    v.push_back(ans2);\\n    return v;\\n\\n}\\n};"
                    },
                    {
                        "username": "spriyanka2244",
                        "content": "            [0,1,2,3,4,5,6]\\nnums =[5,7,7,8,8,8,10]   target =8  Output =[3,5]\\n\\nif  nums[mid] < x:   ((( if target (x) exit and mid value (4)  is less than target value (x) (8)  ))) \\n                    lo = mid+1 ((than it return left most lower value ))\\n                else:\\n                    hi = mid    (((   if target (x) exit and mid value (4)  is greater than target value (x) (2)  )))             \\n            return lo             (( than it return index value which is equal to target value of index  ))\\n\\nlo = search(target)  it return the  index value eg 3\\n\\nhi = search(target+1)-1   the arr start with 0,1,2,3,4 when we say search(target+1) it will return which         _                                      is high index value 6 that  will count from 1,2,3 so only we -1  to get 5 index\\n"
                    },
                    {
                        "username": "ritikumra",
                        "content": "Heyy! I have used this approach of binary search and then finding the element and returning it\\'s start and ending index. Only 4 test cases have been passed can anyone help me optimize it and find the error. \\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int s=0;\\n        int n= nums.size();\\n        int e=n-1;\\n        int arr[2]={-1,-1};\\n\\n        while(s<=e){\\n\\n            int mid= s+(e-s)/2;\\n            if(nums[mid]==target){\\n                if(nums[mid]==nums[mid-1]){\\n                    arr[0]=mid-1;\\n                    arr[1]=mid;\\n                }\\n                if(nums[mid]==nums[mid+1]){\\n                    arr[0]=mid;\\n                    arr[1]=mid+1;\\n                }\\n            }\\n\\n            if(nums[mid]>target){\\n                e=mid+1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            if(nums[mid]<target){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return {arr[0],arr[1]};\\n        \\n    }\\n};"
                    },
                    {
                        "username": "prabaltripathi",
                        "content": "i am solving it through java and with O(log n ) complexity probably 2log n .....yet it is showing Time Limit ecxeeded"
                    }
                ]
            },
            {
                "id": 1794574,
                "content": [
                    {
                        "username": "HUGE_0000",
                        "content": "If I used v.push_back(mid) here instead of v[0] =mid or v[1]=mid (as i comment out)  ,It didn\\'t pass case 2 and case3.  Plz help me how can I fix it.\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n = nums.size() , l = 0, h = n-1;\\n        vector<int>v;\\n        //  vector<int>v(2,-1);\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==0 || nums[mid]!= nums[mid-1])\\n                {\\n                    // v[0]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    h = mid-1;\\n                }\\n            }\\n\\n        }\\n        l = 0; h = n-1;\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==n-1 || nums[mid]!= nums[mid+1])\\n                {\\n                    // v[1]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    l = mid+1;\\n                }\\n            }\\n\\n        }\\n        return v;\\n        \\n\\n        \\n    }\\n    \\n};\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "O(n logn) for this is easy, not medium."
                    },
                    {
                        "username": "RitikRaj18",
                        "content": "I am getting runtime error with my code. `your inline code...your inline code...`\\nVisible Test Cases are correct but on submitting getting error with this input:-\\nnums = [2,2]\\ntarget = 2\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l = 0, r = nums.size() - 1, mid;\\n        int flag = 0;\\n        while( l <= r ){\\n            mid = l + (r - l) / 2;\\n            if( nums[mid] == target ){\\n                flag = 1;\\n                break;\\n            }    \\n            if( nums[mid] < target ){\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n        if( flag == 0){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else{\\n            int i=mid;\\n            while( nums[i] == nums[i-1] && i !=0 ) i--;\\n            ans.push_back(i);\\n\\n            i = mid;\\n            while( nums[i] == nums[i+1] && i != nums.size()-1) i++;\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\nError:-\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000070 overflowed to 0x60200000006c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "monikachand714",
                        "content": "\\n\\n`class Solution {\\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n\\n\\n        vector<int>result;\\n        int start=firstPos(nums,target);\\n        int last=lastPos(nums,target);\\n        result.push_back(start);\\n        result.push_back(last);\\n\\n        return result;\\n        \\n    }\\n    int firstPos(vector<int>& nums, int target) {\\n     int ans=-1;  \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target <nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            high=mid-1;\\n        }\\n     }\\n     return ans;\\n    }\\n\\n\\n    int lastPos(vector<int>& nums, int target){\\n     int ans=-1; \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target < nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            low=mid+1;\\n        }\\n     }\\n     return ans;\\n\\n    }\\n\\n};`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Find the mid-pointer of array. If the value at mid-pointer is greater than target, then it means that range of target lies on left of mid, if value at mid-pointer is lesser than target, then target lies on the right side, otherwise target lies on both the sides. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "What is wrong with this code I can't understand...\n\nclass Solution {\npublic:\n    int firstIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            e = mid - 1;\n            s = 0;\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\nint lastIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            s = mid + 1;\n            e = nums.size();\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\n\nvector<int> searchRange(vector<int> &nums, int target)\n{\n    vector<int> ans;\n    ans.push_back(firstIndex(nums, target));\n    ans.push_back(lastIndex(nums, target));\n    return ans;\n}\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n    int first_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int f= INT_MAX;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            f = min(f,mid);\\n            e= mid -1;\\n        }\\n        else if(v[mid] > key)\\n        { \\n            e  = mid-1;\\n\\n        }else\\n        {\\n                 s = mid+1;\\n        }\\n    }\\n    if( f == INT_MAX)\\n         f = -1; \\n    return f;\\n\\n}\\nint last_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int l= INT_MIN;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            l = max(l,mid);\\n            s= mid +1;\\n        }\\n        else if(v[mid] > key)\\n        { e  = mid-1;\\n        }\\n        else\\n        {\\n             s = mid+1;\\n        }\\n    }\\n    if( l == INT_MIN)\\n    { \\n        l = -1; \\n    }\\n    return l;\\n\\n}\\npublic:\\nvector<int> searchRange(vector<int>&arr,int key)\\n{\\n    int n = arr.size();\\n    \\n    int ans1 = first_index(arr,key);\\n    int ans2 = last_index(arr,key);\\n\\n    vector<int>v;\\n    v.push_back(ans1);\\n    v.push_back(ans2);\\n    return v;\\n\\n}\\n};"
                    },
                    {
                        "username": "spriyanka2244",
                        "content": "            [0,1,2,3,4,5,6]\\nnums =[5,7,7,8,8,8,10]   target =8  Output =[3,5]\\n\\nif  nums[mid] < x:   ((( if target (x) exit and mid value (4)  is less than target value (x) (8)  ))) \\n                    lo = mid+1 ((than it return left most lower value ))\\n                else:\\n                    hi = mid    (((   if target (x) exit and mid value (4)  is greater than target value (x) (2)  )))             \\n            return lo             (( than it return index value which is equal to target value of index  ))\\n\\nlo = search(target)  it return the  index value eg 3\\n\\nhi = search(target+1)-1   the arr start with 0,1,2,3,4 when we say search(target+1) it will return which         _                                      is high index value 6 that  will count from 1,2,3 so only we -1  to get 5 index\\n"
                    },
                    {
                        "username": "ritikumra",
                        "content": "Heyy! I have used this approach of binary search and then finding the element and returning it\\'s start and ending index. Only 4 test cases have been passed can anyone help me optimize it and find the error. \\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int s=0;\\n        int n= nums.size();\\n        int e=n-1;\\n        int arr[2]={-1,-1};\\n\\n        while(s<=e){\\n\\n            int mid= s+(e-s)/2;\\n            if(nums[mid]==target){\\n                if(nums[mid]==nums[mid-1]){\\n                    arr[0]=mid-1;\\n                    arr[1]=mid;\\n                }\\n                if(nums[mid]==nums[mid+1]){\\n                    arr[0]=mid;\\n                    arr[1]=mid+1;\\n                }\\n            }\\n\\n            if(nums[mid]>target){\\n                e=mid+1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            if(nums[mid]<target){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return {arr[0],arr[1]};\\n        \\n    }\\n};"
                    },
                    {
                        "username": "prabaltripathi",
                        "content": "i am solving it through java and with O(log n ) complexity probably 2log n .....yet it is showing Time Limit ecxeeded"
                    }
                ]
            },
            {
                "id": 1792832,
                "content": [
                    {
                        "username": "HUGE_0000",
                        "content": "If I used v.push_back(mid) here instead of v[0] =mid or v[1]=mid (as i comment out)  ,It didn\\'t pass case 2 and case3.  Plz help me how can I fix it.\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n = nums.size() , l = 0, h = n-1;\\n        vector<int>v;\\n        //  vector<int>v(2,-1);\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==0 || nums[mid]!= nums[mid-1])\\n                {\\n                    // v[0]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    h = mid-1;\\n                }\\n            }\\n\\n        }\\n        l = 0; h = n-1;\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==n-1 || nums[mid]!= nums[mid+1])\\n                {\\n                    // v[1]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    l = mid+1;\\n                }\\n            }\\n\\n        }\\n        return v;\\n        \\n\\n        \\n    }\\n    \\n};\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "O(n logn) for this is easy, not medium."
                    },
                    {
                        "username": "RitikRaj18",
                        "content": "I am getting runtime error with my code. `your inline code...your inline code...`\\nVisible Test Cases are correct but on submitting getting error with this input:-\\nnums = [2,2]\\ntarget = 2\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l = 0, r = nums.size() - 1, mid;\\n        int flag = 0;\\n        while( l <= r ){\\n            mid = l + (r - l) / 2;\\n            if( nums[mid] == target ){\\n                flag = 1;\\n                break;\\n            }    \\n            if( nums[mid] < target ){\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n        if( flag == 0){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else{\\n            int i=mid;\\n            while( nums[i] == nums[i-1] && i !=0 ) i--;\\n            ans.push_back(i);\\n\\n            i = mid;\\n            while( nums[i] == nums[i+1] && i != nums.size()-1) i++;\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\nError:-\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000070 overflowed to 0x60200000006c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "monikachand714",
                        "content": "\\n\\n`class Solution {\\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n\\n\\n        vector<int>result;\\n        int start=firstPos(nums,target);\\n        int last=lastPos(nums,target);\\n        result.push_back(start);\\n        result.push_back(last);\\n\\n        return result;\\n        \\n    }\\n    int firstPos(vector<int>& nums, int target) {\\n     int ans=-1;  \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target <nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            high=mid-1;\\n        }\\n     }\\n     return ans;\\n    }\\n\\n\\n    int lastPos(vector<int>& nums, int target){\\n     int ans=-1; \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target < nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            low=mid+1;\\n        }\\n     }\\n     return ans;\\n\\n    }\\n\\n};`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Find the mid-pointer of array. If the value at mid-pointer is greater than target, then it means that range of target lies on left of mid, if value at mid-pointer is lesser than target, then target lies on the right side, otherwise target lies on both the sides. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "What is wrong with this code I can't understand...\n\nclass Solution {\npublic:\n    int firstIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            e = mid - 1;\n            s = 0;\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\nint lastIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            s = mid + 1;\n            e = nums.size();\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\n\nvector<int> searchRange(vector<int> &nums, int target)\n{\n    vector<int> ans;\n    ans.push_back(firstIndex(nums, target));\n    ans.push_back(lastIndex(nums, target));\n    return ans;\n}\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n    int first_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int f= INT_MAX;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            f = min(f,mid);\\n            e= mid -1;\\n        }\\n        else if(v[mid] > key)\\n        { \\n            e  = mid-1;\\n\\n        }else\\n        {\\n                 s = mid+1;\\n        }\\n    }\\n    if( f == INT_MAX)\\n         f = -1; \\n    return f;\\n\\n}\\nint last_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int l= INT_MIN;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            l = max(l,mid);\\n            s= mid +1;\\n        }\\n        else if(v[mid] > key)\\n        { e  = mid-1;\\n        }\\n        else\\n        {\\n             s = mid+1;\\n        }\\n    }\\n    if( l == INT_MIN)\\n    { \\n        l = -1; \\n    }\\n    return l;\\n\\n}\\npublic:\\nvector<int> searchRange(vector<int>&arr,int key)\\n{\\n    int n = arr.size();\\n    \\n    int ans1 = first_index(arr,key);\\n    int ans2 = last_index(arr,key);\\n\\n    vector<int>v;\\n    v.push_back(ans1);\\n    v.push_back(ans2);\\n    return v;\\n\\n}\\n};"
                    },
                    {
                        "username": "spriyanka2244",
                        "content": "            [0,1,2,3,4,5,6]\\nnums =[5,7,7,8,8,8,10]   target =8  Output =[3,5]\\n\\nif  nums[mid] < x:   ((( if target (x) exit and mid value (4)  is less than target value (x) (8)  ))) \\n                    lo = mid+1 ((than it return left most lower value ))\\n                else:\\n                    hi = mid    (((   if target (x) exit and mid value (4)  is greater than target value (x) (2)  )))             \\n            return lo             (( than it return index value which is equal to target value of index  ))\\n\\nlo = search(target)  it return the  index value eg 3\\n\\nhi = search(target+1)-1   the arr start with 0,1,2,3,4 when we say search(target+1) it will return which         _                                      is high index value 6 that  will count from 1,2,3 so only we -1  to get 5 index\\n"
                    },
                    {
                        "username": "ritikumra",
                        "content": "Heyy! I have used this approach of binary search and then finding the element and returning it\\'s start and ending index. Only 4 test cases have been passed can anyone help me optimize it and find the error. \\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int s=0;\\n        int n= nums.size();\\n        int e=n-1;\\n        int arr[2]={-1,-1};\\n\\n        while(s<=e){\\n\\n            int mid= s+(e-s)/2;\\n            if(nums[mid]==target){\\n                if(nums[mid]==nums[mid-1]){\\n                    arr[0]=mid-1;\\n                    arr[1]=mid;\\n                }\\n                if(nums[mid]==nums[mid+1]){\\n                    arr[0]=mid;\\n                    arr[1]=mid+1;\\n                }\\n            }\\n\\n            if(nums[mid]>target){\\n                e=mid+1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            if(nums[mid]<target){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return {arr[0],arr[1]};\\n        \\n    }\\n};"
                    },
                    {
                        "username": "prabaltripathi",
                        "content": "i am solving it through java and with O(log n ) complexity probably 2log n .....yet it is showing Time Limit ecxeeded"
                    }
                ]
            },
            {
                "id": 1787070,
                "content": [
                    {
                        "username": "HUGE_0000",
                        "content": "If I used v.push_back(mid) here instead of v[0] =mid or v[1]=mid (as i comment out)  ,It didn\\'t pass case 2 and case3.  Plz help me how can I fix it.\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n = nums.size() , l = 0, h = n-1;\\n        vector<int>v;\\n        //  vector<int>v(2,-1);\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==0 || nums[mid]!= nums[mid-1])\\n                {\\n                    // v[0]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    h = mid-1;\\n                }\\n            }\\n\\n        }\\n        l = 0; h = n-1;\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==n-1 || nums[mid]!= nums[mid+1])\\n                {\\n                    // v[1]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    l = mid+1;\\n                }\\n            }\\n\\n        }\\n        return v;\\n        \\n\\n        \\n    }\\n    \\n};\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "O(n logn) for this is easy, not medium."
                    },
                    {
                        "username": "RitikRaj18",
                        "content": "I am getting runtime error with my code. `your inline code...your inline code...`\\nVisible Test Cases are correct but on submitting getting error with this input:-\\nnums = [2,2]\\ntarget = 2\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l = 0, r = nums.size() - 1, mid;\\n        int flag = 0;\\n        while( l <= r ){\\n            mid = l + (r - l) / 2;\\n            if( nums[mid] == target ){\\n                flag = 1;\\n                break;\\n            }    \\n            if( nums[mid] < target ){\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n        if( flag == 0){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else{\\n            int i=mid;\\n            while( nums[i] == nums[i-1] && i !=0 ) i--;\\n            ans.push_back(i);\\n\\n            i = mid;\\n            while( nums[i] == nums[i+1] && i != nums.size()-1) i++;\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\nError:-\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000070 overflowed to 0x60200000006c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "monikachand714",
                        "content": "\\n\\n`class Solution {\\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n\\n\\n        vector<int>result;\\n        int start=firstPos(nums,target);\\n        int last=lastPos(nums,target);\\n        result.push_back(start);\\n        result.push_back(last);\\n\\n        return result;\\n        \\n    }\\n    int firstPos(vector<int>& nums, int target) {\\n     int ans=-1;  \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target <nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            high=mid-1;\\n        }\\n     }\\n     return ans;\\n    }\\n\\n\\n    int lastPos(vector<int>& nums, int target){\\n     int ans=-1; \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target < nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            low=mid+1;\\n        }\\n     }\\n     return ans;\\n\\n    }\\n\\n};`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Find the mid-pointer of array. If the value at mid-pointer is greater than target, then it means that range of target lies on left of mid, if value at mid-pointer is lesser than target, then target lies on the right side, otherwise target lies on both the sides. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "What is wrong with this code I can't understand...\n\nclass Solution {\npublic:\n    int firstIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            e = mid - 1;\n            s = 0;\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\nint lastIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            s = mid + 1;\n            e = nums.size();\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\n\nvector<int> searchRange(vector<int> &nums, int target)\n{\n    vector<int> ans;\n    ans.push_back(firstIndex(nums, target));\n    ans.push_back(lastIndex(nums, target));\n    return ans;\n}\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n    int first_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int f= INT_MAX;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            f = min(f,mid);\\n            e= mid -1;\\n        }\\n        else if(v[mid] > key)\\n        { \\n            e  = mid-1;\\n\\n        }else\\n        {\\n                 s = mid+1;\\n        }\\n    }\\n    if( f == INT_MAX)\\n         f = -1; \\n    return f;\\n\\n}\\nint last_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int l= INT_MIN;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            l = max(l,mid);\\n            s= mid +1;\\n        }\\n        else if(v[mid] > key)\\n        { e  = mid-1;\\n        }\\n        else\\n        {\\n             s = mid+1;\\n        }\\n    }\\n    if( l == INT_MIN)\\n    { \\n        l = -1; \\n    }\\n    return l;\\n\\n}\\npublic:\\nvector<int> searchRange(vector<int>&arr,int key)\\n{\\n    int n = arr.size();\\n    \\n    int ans1 = first_index(arr,key);\\n    int ans2 = last_index(arr,key);\\n\\n    vector<int>v;\\n    v.push_back(ans1);\\n    v.push_back(ans2);\\n    return v;\\n\\n}\\n};"
                    },
                    {
                        "username": "spriyanka2244",
                        "content": "            [0,1,2,3,4,5,6]\\nnums =[5,7,7,8,8,8,10]   target =8  Output =[3,5]\\n\\nif  nums[mid] < x:   ((( if target (x) exit and mid value (4)  is less than target value (x) (8)  ))) \\n                    lo = mid+1 ((than it return left most lower value ))\\n                else:\\n                    hi = mid    (((   if target (x) exit and mid value (4)  is greater than target value (x) (2)  )))             \\n            return lo             (( than it return index value which is equal to target value of index  ))\\n\\nlo = search(target)  it return the  index value eg 3\\n\\nhi = search(target+1)-1   the arr start with 0,1,2,3,4 when we say search(target+1) it will return which         _                                      is high index value 6 that  will count from 1,2,3 so only we -1  to get 5 index\\n"
                    },
                    {
                        "username": "ritikumra",
                        "content": "Heyy! I have used this approach of binary search and then finding the element and returning it\\'s start and ending index. Only 4 test cases have been passed can anyone help me optimize it and find the error. \\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int s=0;\\n        int n= nums.size();\\n        int e=n-1;\\n        int arr[2]={-1,-1};\\n\\n        while(s<=e){\\n\\n            int mid= s+(e-s)/2;\\n            if(nums[mid]==target){\\n                if(nums[mid]==nums[mid-1]){\\n                    arr[0]=mid-1;\\n                    arr[1]=mid;\\n                }\\n                if(nums[mid]==nums[mid+1]){\\n                    arr[0]=mid;\\n                    arr[1]=mid+1;\\n                }\\n            }\\n\\n            if(nums[mid]>target){\\n                e=mid+1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            if(nums[mid]<target){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return {arr[0],arr[1]};\\n        \\n    }\\n};"
                    },
                    {
                        "username": "prabaltripathi",
                        "content": "i am solving it through java and with O(log n ) complexity probably 2log n .....yet it is showing Time Limit ecxeeded"
                    }
                ]
            },
            {
                "id": 1783464,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n   int Fstarting_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n   int Fending_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                low=mid+1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        int lmi=Fstarting_index_target_element(nums,target,n);\\n        int rmi=Fending_index_target_element(nums,target,n);\\n            temp.push_back(lmi);\\n            temp.push_back(rmi);\\n            return temp;\\n    }\\n};"
                    },
                    {
                        "username": "mminyngy",
                        "content": " `class Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        start = 0\\n        end = len(nums) - 1\\n        index = end\\n        result = []\\n\\n        if target in nums:\\n            start = nums.index(target)\\n            for num in reversed(nums):\\n                if num == target:\\n                    end = index\\n                    break\\n                index -= 1\\n        else:\\n            start = -1\\n            end = -1\\n            \\n        result[:] = [start, end]\\n        return result`\\n\\nwill it be accepted? I tryna make it look easy tho"
                    },
                    {
                        "username": "rahulraj17",
                        "content": "These codes give TLE, what should i do ?\\n\\nclass Solution {\\npublic:\\n    int firstOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    \\n    int lastOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                int start = mid + 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        // return{firstOccurance(nums,nums.size(),target), lastOccurance(nums,nums.size(),target)};\\n    }\\n};"
                    },
                    {
                        "username": "Ultron03",
                        "content": "check for which testcase it is giving tle and then solve the testcase in the paper according to your code .. hop it works."
                    },
                    {
                        "username": "user4474EC",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if( nums.size()==0)return{-1,-1};\\n        if(nums.size()==1 && nums[0]==target)return {0,0};\\n        int s=0,e=nums.size()-1;\\n        vector<int>ans;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target){\\n                int l=mid,r=mid;\\n                if( nums[mid]!=nums[mid-1]&&nums[mid]!=nums[mid+1] ){\\n                    ans.push_back(mid);\\n                    ans.push_back(mid);break;\\n                }\\n                else\\n                {\\n                    while( nums[l]==nums[mid])l--;\\n                    ans.push_back(l+1); \\n                    while( nums[r]==nums[mid])r++;\\n                    ans.push_back(r-1);\\n                }\\n\\n                break;\\n                \\n            }\\n            else if(nums[mid]>target ){\\n                e=mid-1;\\n\\n            }\\n            else {\\n                s=mid+1;\\n            }\\n        }\\n        if( ans.size()==0){\\n            if( nums.size()==1&& target==nums[0])return {0,0};\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else if ( ans.size()==1){\\n            if( nums.size()==1 && nums[0]==ans[0])ans.push_back(0);\\n            ans.push_back( ans[0]);\\n        }\\n            \\n\\n        return ans;\\n    }\\n}; \\n\\nthis is my code i am not getting why this is getting run time error for values.\\n"
                    },
                    {
                        "username": "adityapaluskar",
                        "content": "how do i return arrays in output as shown in example... need help"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just make a vector of size two and initialize them with -1 and change if  the target indices found..\\n "
                    },
                    {
                        "username": "kimkass",
                        "content": "What does the description has to be so ambiguous instead  of saying sorted in non decreasing order it can say sorted in increasing order."
                    },
                    {
                        "username": "MissRobot",
                        "content": "Non-decreasing and increasing orders are not the same thing, since the same element can be repeated as in 8 8 8 ... it is non-decreasing order, can\\'t be increasing order."
                    },
                    {
                        "username": "mahak_22",
                        "content": "class Solution {\\npublic:\\nint firstoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            r=mid-1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n    }\\n    return result;\\n}\\nint lastoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            l=mid+1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n        \\n    }\\n    return result;\\n    \\n}\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n    vector<int>v;\\n    \\n    int f=firstoccurence(nums,nums.size(),target);\\n    int last=lastoccurence(nums,nums.size(),target);\\n    return v={f,last};\\n    }\\n\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mukulbhardwaj947",
                        "content": "I have debugged my code  but it still shows TLE.What should i do? "
                    },
                    {
                        "username": "ram_singhal17",
                        "content": "PLEASE HELP ME OUT!! \\n\\nclass Solution {\\npublic:\\n    void search(vector<int>&nums,vector<int>&v,int low,int high,int target,bool flag){\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target && nums[mid-1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,mid,high,target,flag);\\n            }\\n            else if(nums[mid]==target && nums[mid+1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,low,mid,target,flag);\\n            }\\n            else if(nums[mid]<target){\\n                  search(nums,v,mid+1,high,target,flag);\\n            }\\n            else{\\n                search(nums,v,low,mid-1,target,flag);\\n            }\\n        }\\n        \\n        \\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>v;bool flag=false;\\n        int low=0;int high=nums.size()-1;\\n        search(nums,v,low,high,target,flag);\\n        if(flag==false){\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1781286,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n   int Fstarting_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n   int Fending_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                low=mid+1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        int lmi=Fstarting_index_target_element(nums,target,n);\\n        int rmi=Fending_index_target_element(nums,target,n);\\n            temp.push_back(lmi);\\n            temp.push_back(rmi);\\n            return temp;\\n    }\\n};"
                    },
                    {
                        "username": "mminyngy",
                        "content": " `class Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        start = 0\\n        end = len(nums) - 1\\n        index = end\\n        result = []\\n\\n        if target in nums:\\n            start = nums.index(target)\\n            for num in reversed(nums):\\n                if num == target:\\n                    end = index\\n                    break\\n                index -= 1\\n        else:\\n            start = -1\\n            end = -1\\n            \\n        result[:] = [start, end]\\n        return result`\\n\\nwill it be accepted? I tryna make it look easy tho"
                    },
                    {
                        "username": "rahulraj17",
                        "content": "These codes give TLE, what should i do ?\\n\\nclass Solution {\\npublic:\\n    int firstOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    \\n    int lastOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                int start = mid + 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        // return{firstOccurance(nums,nums.size(),target), lastOccurance(nums,nums.size(),target)};\\n    }\\n};"
                    },
                    {
                        "username": "Ultron03",
                        "content": "check for which testcase it is giving tle and then solve the testcase in the paper according to your code .. hop it works."
                    },
                    {
                        "username": "user4474EC",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if( nums.size()==0)return{-1,-1};\\n        if(nums.size()==1 && nums[0]==target)return {0,0};\\n        int s=0,e=nums.size()-1;\\n        vector<int>ans;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target){\\n                int l=mid,r=mid;\\n                if( nums[mid]!=nums[mid-1]&&nums[mid]!=nums[mid+1] ){\\n                    ans.push_back(mid);\\n                    ans.push_back(mid);break;\\n                }\\n                else\\n                {\\n                    while( nums[l]==nums[mid])l--;\\n                    ans.push_back(l+1); \\n                    while( nums[r]==nums[mid])r++;\\n                    ans.push_back(r-1);\\n                }\\n\\n                break;\\n                \\n            }\\n            else if(nums[mid]>target ){\\n                e=mid-1;\\n\\n            }\\n            else {\\n                s=mid+1;\\n            }\\n        }\\n        if( ans.size()==0){\\n            if( nums.size()==1&& target==nums[0])return {0,0};\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else if ( ans.size()==1){\\n            if( nums.size()==1 && nums[0]==ans[0])ans.push_back(0);\\n            ans.push_back( ans[0]);\\n        }\\n            \\n\\n        return ans;\\n    }\\n}; \\n\\nthis is my code i am not getting why this is getting run time error for values.\\n"
                    },
                    {
                        "username": "adityapaluskar",
                        "content": "how do i return arrays in output as shown in example... need help"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just make a vector of size two and initialize them with -1 and change if  the target indices found..\\n "
                    },
                    {
                        "username": "kimkass",
                        "content": "What does the description has to be so ambiguous instead  of saying sorted in non decreasing order it can say sorted in increasing order."
                    },
                    {
                        "username": "MissRobot",
                        "content": "Non-decreasing and increasing orders are not the same thing, since the same element can be repeated as in 8 8 8 ... it is non-decreasing order, can\\'t be increasing order."
                    },
                    {
                        "username": "mahak_22",
                        "content": "class Solution {\\npublic:\\nint firstoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            r=mid-1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n    }\\n    return result;\\n}\\nint lastoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            l=mid+1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n        \\n    }\\n    return result;\\n    \\n}\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n    vector<int>v;\\n    \\n    int f=firstoccurence(nums,nums.size(),target);\\n    int last=lastoccurence(nums,nums.size(),target);\\n    return v={f,last};\\n    }\\n\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mukulbhardwaj947",
                        "content": "I have debugged my code  but it still shows TLE.What should i do? "
                    },
                    {
                        "username": "ram_singhal17",
                        "content": "PLEASE HELP ME OUT!! \\n\\nclass Solution {\\npublic:\\n    void search(vector<int>&nums,vector<int>&v,int low,int high,int target,bool flag){\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target && nums[mid-1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,mid,high,target,flag);\\n            }\\n            else if(nums[mid]==target && nums[mid+1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,low,mid,target,flag);\\n            }\\n            else if(nums[mid]<target){\\n                  search(nums,v,mid+1,high,target,flag);\\n            }\\n            else{\\n                search(nums,v,low,mid-1,target,flag);\\n            }\\n        }\\n        \\n        \\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>v;bool flag=false;\\n        int low=0;int high=nums.size()-1;\\n        search(nums,v,low,high,target,flag);\\n        if(flag==false){\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1777542,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n   int Fstarting_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n   int Fending_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                low=mid+1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        int lmi=Fstarting_index_target_element(nums,target,n);\\n        int rmi=Fending_index_target_element(nums,target,n);\\n            temp.push_back(lmi);\\n            temp.push_back(rmi);\\n            return temp;\\n    }\\n};"
                    },
                    {
                        "username": "mminyngy",
                        "content": " `class Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        start = 0\\n        end = len(nums) - 1\\n        index = end\\n        result = []\\n\\n        if target in nums:\\n            start = nums.index(target)\\n            for num in reversed(nums):\\n                if num == target:\\n                    end = index\\n                    break\\n                index -= 1\\n        else:\\n            start = -1\\n            end = -1\\n            \\n        result[:] = [start, end]\\n        return result`\\n\\nwill it be accepted? I tryna make it look easy tho"
                    },
                    {
                        "username": "rahulraj17",
                        "content": "These codes give TLE, what should i do ?\\n\\nclass Solution {\\npublic:\\n    int firstOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    \\n    int lastOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                int start = mid + 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        // return{firstOccurance(nums,nums.size(),target), lastOccurance(nums,nums.size(),target)};\\n    }\\n};"
                    },
                    {
                        "username": "Ultron03",
                        "content": "check for which testcase it is giving tle and then solve the testcase in the paper according to your code .. hop it works."
                    },
                    {
                        "username": "user4474EC",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if( nums.size()==0)return{-1,-1};\\n        if(nums.size()==1 && nums[0]==target)return {0,0};\\n        int s=0,e=nums.size()-1;\\n        vector<int>ans;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target){\\n                int l=mid,r=mid;\\n                if( nums[mid]!=nums[mid-1]&&nums[mid]!=nums[mid+1] ){\\n                    ans.push_back(mid);\\n                    ans.push_back(mid);break;\\n                }\\n                else\\n                {\\n                    while( nums[l]==nums[mid])l--;\\n                    ans.push_back(l+1); \\n                    while( nums[r]==nums[mid])r++;\\n                    ans.push_back(r-1);\\n                }\\n\\n                break;\\n                \\n            }\\n            else if(nums[mid]>target ){\\n                e=mid-1;\\n\\n            }\\n            else {\\n                s=mid+1;\\n            }\\n        }\\n        if( ans.size()==0){\\n            if( nums.size()==1&& target==nums[0])return {0,0};\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else if ( ans.size()==1){\\n            if( nums.size()==1 && nums[0]==ans[0])ans.push_back(0);\\n            ans.push_back( ans[0]);\\n        }\\n            \\n\\n        return ans;\\n    }\\n}; \\n\\nthis is my code i am not getting why this is getting run time error for values.\\n"
                    },
                    {
                        "username": "adityapaluskar",
                        "content": "how do i return arrays in output as shown in example... need help"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just make a vector of size two and initialize them with -1 and change if  the target indices found..\\n "
                    },
                    {
                        "username": "kimkass",
                        "content": "What does the description has to be so ambiguous instead  of saying sorted in non decreasing order it can say sorted in increasing order."
                    },
                    {
                        "username": "MissRobot",
                        "content": "Non-decreasing and increasing orders are not the same thing, since the same element can be repeated as in 8 8 8 ... it is non-decreasing order, can\\'t be increasing order."
                    },
                    {
                        "username": "mahak_22",
                        "content": "class Solution {\\npublic:\\nint firstoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            r=mid-1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n    }\\n    return result;\\n}\\nint lastoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            l=mid+1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n        \\n    }\\n    return result;\\n    \\n}\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n    vector<int>v;\\n    \\n    int f=firstoccurence(nums,nums.size(),target);\\n    int last=lastoccurence(nums,nums.size(),target);\\n    return v={f,last};\\n    }\\n\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mukulbhardwaj947",
                        "content": "I have debugged my code  but it still shows TLE.What should i do? "
                    },
                    {
                        "username": "ram_singhal17",
                        "content": "PLEASE HELP ME OUT!! \\n\\nclass Solution {\\npublic:\\n    void search(vector<int>&nums,vector<int>&v,int low,int high,int target,bool flag){\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target && nums[mid-1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,mid,high,target,flag);\\n            }\\n            else if(nums[mid]==target && nums[mid+1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,low,mid,target,flag);\\n            }\\n            else if(nums[mid]<target){\\n                  search(nums,v,mid+1,high,target,flag);\\n            }\\n            else{\\n                search(nums,v,low,mid-1,target,flag);\\n            }\\n        }\\n        \\n        \\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>v;bool flag=false;\\n        int low=0;int high=nums.size()-1;\\n        search(nums,v,low,high,target,flag);\\n        if(flag==false){\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1771722,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n   int Fstarting_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n   int Fending_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                low=mid+1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        int lmi=Fstarting_index_target_element(nums,target,n);\\n        int rmi=Fending_index_target_element(nums,target,n);\\n            temp.push_back(lmi);\\n            temp.push_back(rmi);\\n            return temp;\\n    }\\n};"
                    },
                    {
                        "username": "mminyngy",
                        "content": " `class Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        start = 0\\n        end = len(nums) - 1\\n        index = end\\n        result = []\\n\\n        if target in nums:\\n            start = nums.index(target)\\n            for num in reversed(nums):\\n                if num == target:\\n                    end = index\\n                    break\\n                index -= 1\\n        else:\\n            start = -1\\n            end = -1\\n            \\n        result[:] = [start, end]\\n        return result`\\n\\nwill it be accepted? I tryna make it look easy tho"
                    },
                    {
                        "username": "rahulraj17",
                        "content": "These codes give TLE, what should i do ?\\n\\nclass Solution {\\npublic:\\n    int firstOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    \\n    int lastOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                int start = mid + 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        // return{firstOccurance(nums,nums.size(),target), lastOccurance(nums,nums.size(),target)};\\n    }\\n};"
                    },
                    {
                        "username": "Ultron03",
                        "content": "check for which testcase it is giving tle and then solve the testcase in the paper according to your code .. hop it works."
                    },
                    {
                        "username": "user4474EC",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if( nums.size()==0)return{-1,-1};\\n        if(nums.size()==1 && nums[0]==target)return {0,0};\\n        int s=0,e=nums.size()-1;\\n        vector<int>ans;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target){\\n                int l=mid,r=mid;\\n                if( nums[mid]!=nums[mid-1]&&nums[mid]!=nums[mid+1] ){\\n                    ans.push_back(mid);\\n                    ans.push_back(mid);break;\\n                }\\n                else\\n                {\\n                    while( nums[l]==nums[mid])l--;\\n                    ans.push_back(l+1); \\n                    while( nums[r]==nums[mid])r++;\\n                    ans.push_back(r-1);\\n                }\\n\\n                break;\\n                \\n            }\\n            else if(nums[mid]>target ){\\n                e=mid-1;\\n\\n            }\\n            else {\\n                s=mid+1;\\n            }\\n        }\\n        if( ans.size()==0){\\n            if( nums.size()==1&& target==nums[0])return {0,0};\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else if ( ans.size()==1){\\n            if( nums.size()==1 && nums[0]==ans[0])ans.push_back(0);\\n            ans.push_back( ans[0]);\\n        }\\n            \\n\\n        return ans;\\n    }\\n}; \\n\\nthis is my code i am not getting why this is getting run time error for values.\\n"
                    },
                    {
                        "username": "adityapaluskar",
                        "content": "how do i return arrays in output as shown in example... need help"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just make a vector of size two and initialize them with -1 and change if  the target indices found..\\n "
                    },
                    {
                        "username": "kimkass",
                        "content": "What does the description has to be so ambiguous instead  of saying sorted in non decreasing order it can say sorted in increasing order."
                    },
                    {
                        "username": "MissRobot",
                        "content": "Non-decreasing and increasing orders are not the same thing, since the same element can be repeated as in 8 8 8 ... it is non-decreasing order, can\\'t be increasing order."
                    },
                    {
                        "username": "mahak_22",
                        "content": "class Solution {\\npublic:\\nint firstoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            r=mid-1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n    }\\n    return result;\\n}\\nint lastoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            l=mid+1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n        \\n    }\\n    return result;\\n    \\n}\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n    vector<int>v;\\n    \\n    int f=firstoccurence(nums,nums.size(),target);\\n    int last=lastoccurence(nums,nums.size(),target);\\n    return v={f,last};\\n    }\\n\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mukulbhardwaj947",
                        "content": "I have debugged my code  but it still shows TLE.What should i do? "
                    },
                    {
                        "username": "ram_singhal17",
                        "content": "PLEASE HELP ME OUT!! \\n\\nclass Solution {\\npublic:\\n    void search(vector<int>&nums,vector<int>&v,int low,int high,int target,bool flag){\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target && nums[mid-1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,mid,high,target,flag);\\n            }\\n            else if(nums[mid]==target && nums[mid+1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,low,mid,target,flag);\\n            }\\n            else if(nums[mid]<target){\\n                  search(nums,v,mid+1,high,target,flag);\\n            }\\n            else{\\n                search(nums,v,low,mid-1,target,flag);\\n            }\\n        }\\n        \\n        \\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>v;bool flag=false;\\n        int low=0;int high=nums.size()-1;\\n        search(nums,v,low,high,target,flag);\\n        if(flag==false){\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767722,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n   int Fstarting_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n   int Fending_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                low=mid+1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        int lmi=Fstarting_index_target_element(nums,target,n);\\n        int rmi=Fending_index_target_element(nums,target,n);\\n            temp.push_back(lmi);\\n            temp.push_back(rmi);\\n            return temp;\\n    }\\n};"
                    },
                    {
                        "username": "mminyngy",
                        "content": " `class Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        start = 0\\n        end = len(nums) - 1\\n        index = end\\n        result = []\\n\\n        if target in nums:\\n            start = nums.index(target)\\n            for num in reversed(nums):\\n                if num == target:\\n                    end = index\\n                    break\\n                index -= 1\\n        else:\\n            start = -1\\n            end = -1\\n            \\n        result[:] = [start, end]\\n        return result`\\n\\nwill it be accepted? I tryna make it look easy tho"
                    },
                    {
                        "username": "rahulraj17",
                        "content": "These codes give TLE, what should i do ?\\n\\nclass Solution {\\npublic:\\n    int firstOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    \\n    int lastOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                int start = mid + 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        // return{firstOccurance(nums,nums.size(),target), lastOccurance(nums,nums.size(),target)};\\n    }\\n};"
                    },
                    {
                        "username": "Ultron03",
                        "content": "check for which testcase it is giving tle and then solve the testcase in the paper according to your code .. hop it works."
                    },
                    {
                        "username": "user4474EC",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if( nums.size()==0)return{-1,-1};\\n        if(nums.size()==1 && nums[0]==target)return {0,0};\\n        int s=0,e=nums.size()-1;\\n        vector<int>ans;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target){\\n                int l=mid,r=mid;\\n                if( nums[mid]!=nums[mid-1]&&nums[mid]!=nums[mid+1] ){\\n                    ans.push_back(mid);\\n                    ans.push_back(mid);break;\\n                }\\n                else\\n                {\\n                    while( nums[l]==nums[mid])l--;\\n                    ans.push_back(l+1); \\n                    while( nums[r]==nums[mid])r++;\\n                    ans.push_back(r-1);\\n                }\\n\\n                break;\\n                \\n            }\\n            else if(nums[mid]>target ){\\n                e=mid-1;\\n\\n            }\\n            else {\\n                s=mid+1;\\n            }\\n        }\\n        if( ans.size()==0){\\n            if( nums.size()==1&& target==nums[0])return {0,0};\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else if ( ans.size()==1){\\n            if( nums.size()==1 && nums[0]==ans[0])ans.push_back(0);\\n            ans.push_back( ans[0]);\\n        }\\n            \\n\\n        return ans;\\n    }\\n}; \\n\\nthis is my code i am not getting why this is getting run time error for values.\\n"
                    },
                    {
                        "username": "adityapaluskar",
                        "content": "how do i return arrays in output as shown in example... need help"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just make a vector of size two and initialize them with -1 and change if  the target indices found..\\n "
                    },
                    {
                        "username": "kimkass",
                        "content": "What does the description has to be so ambiguous instead  of saying sorted in non decreasing order it can say sorted in increasing order."
                    },
                    {
                        "username": "MissRobot",
                        "content": "Non-decreasing and increasing orders are not the same thing, since the same element can be repeated as in 8 8 8 ... it is non-decreasing order, can\\'t be increasing order."
                    },
                    {
                        "username": "mahak_22",
                        "content": "class Solution {\\npublic:\\nint firstoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            r=mid-1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n    }\\n    return result;\\n}\\nint lastoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            l=mid+1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n        \\n    }\\n    return result;\\n    \\n}\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n    vector<int>v;\\n    \\n    int f=firstoccurence(nums,nums.size(),target);\\n    int last=lastoccurence(nums,nums.size(),target);\\n    return v={f,last};\\n    }\\n\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mukulbhardwaj947",
                        "content": "I have debugged my code  but it still shows TLE.What should i do? "
                    },
                    {
                        "username": "ram_singhal17",
                        "content": "PLEASE HELP ME OUT!! \\n\\nclass Solution {\\npublic:\\n    void search(vector<int>&nums,vector<int>&v,int low,int high,int target,bool flag){\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target && nums[mid-1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,mid,high,target,flag);\\n            }\\n            else if(nums[mid]==target && nums[mid+1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,low,mid,target,flag);\\n            }\\n            else if(nums[mid]<target){\\n                  search(nums,v,mid+1,high,target,flag);\\n            }\\n            else{\\n                search(nums,v,low,mid-1,target,flag);\\n            }\\n        }\\n        \\n        \\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>v;bool flag=false;\\n        int low=0;int high=nums.size()-1;\\n        search(nums,v,low,high,target,flag);\\n        if(flag==false){\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1762515,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n   int Fstarting_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n   int Fending_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                low=mid+1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        int lmi=Fstarting_index_target_element(nums,target,n);\\n        int rmi=Fending_index_target_element(nums,target,n);\\n            temp.push_back(lmi);\\n            temp.push_back(rmi);\\n            return temp;\\n    }\\n};"
                    },
                    {
                        "username": "mminyngy",
                        "content": " `class Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        start = 0\\n        end = len(nums) - 1\\n        index = end\\n        result = []\\n\\n        if target in nums:\\n            start = nums.index(target)\\n            for num in reversed(nums):\\n                if num == target:\\n                    end = index\\n                    break\\n                index -= 1\\n        else:\\n            start = -1\\n            end = -1\\n            \\n        result[:] = [start, end]\\n        return result`\\n\\nwill it be accepted? I tryna make it look easy tho"
                    },
                    {
                        "username": "rahulraj17",
                        "content": "These codes give TLE, what should i do ?\\n\\nclass Solution {\\npublic:\\n    int firstOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    \\n    int lastOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                int start = mid + 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        // return{firstOccurance(nums,nums.size(),target), lastOccurance(nums,nums.size(),target)};\\n    }\\n};"
                    },
                    {
                        "username": "Ultron03",
                        "content": "check for which testcase it is giving tle and then solve the testcase in the paper according to your code .. hop it works."
                    },
                    {
                        "username": "user4474EC",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if( nums.size()==0)return{-1,-1};\\n        if(nums.size()==1 && nums[0]==target)return {0,0};\\n        int s=0,e=nums.size()-1;\\n        vector<int>ans;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target){\\n                int l=mid,r=mid;\\n                if( nums[mid]!=nums[mid-1]&&nums[mid]!=nums[mid+1] ){\\n                    ans.push_back(mid);\\n                    ans.push_back(mid);break;\\n                }\\n                else\\n                {\\n                    while( nums[l]==nums[mid])l--;\\n                    ans.push_back(l+1); \\n                    while( nums[r]==nums[mid])r++;\\n                    ans.push_back(r-1);\\n                }\\n\\n                break;\\n                \\n            }\\n            else if(nums[mid]>target ){\\n                e=mid-1;\\n\\n            }\\n            else {\\n                s=mid+1;\\n            }\\n        }\\n        if( ans.size()==0){\\n            if( nums.size()==1&& target==nums[0])return {0,0};\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else if ( ans.size()==1){\\n            if( nums.size()==1 && nums[0]==ans[0])ans.push_back(0);\\n            ans.push_back( ans[0]);\\n        }\\n            \\n\\n        return ans;\\n    }\\n}; \\n\\nthis is my code i am not getting why this is getting run time error for values.\\n"
                    },
                    {
                        "username": "adityapaluskar",
                        "content": "how do i return arrays in output as shown in example... need help"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just make a vector of size two and initialize them with -1 and change if  the target indices found..\\n "
                    },
                    {
                        "username": "kimkass",
                        "content": "What does the description has to be so ambiguous instead  of saying sorted in non decreasing order it can say sorted in increasing order."
                    },
                    {
                        "username": "MissRobot",
                        "content": "Non-decreasing and increasing orders are not the same thing, since the same element can be repeated as in 8 8 8 ... it is non-decreasing order, can\\'t be increasing order."
                    },
                    {
                        "username": "mahak_22",
                        "content": "class Solution {\\npublic:\\nint firstoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            r=mid-1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n    }\\n    return result;\\n}\\nint lastoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            l=mid+1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n        \\n    }\\n    return result;\\n    \\n}\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n    vector<int>v;\\n    \\n    int f=firstoccurence(nums,nums.size(),target);\\n    int last=lastoccurence(nums,nums.size(),target);\\n    return v={f,last};\\n    }\\n\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mukulbhardwaj947",
                        "content": "I have debugged my code  but it still shows TLE.What should i do? "
                    },
                    {
                        "username": "ram_singhal17",
                        "content": "PLEASE HELP ME OUT!! \\n\\nclass Solution {\\npublic:\\n    void search(vector<int>&nums,vector<int>&v,int low,int high,int target,bool flag){\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target && nums[mid-1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,mid,high,target,flag);\\n            }\\n            else if(nums[mid]==target && nums[mid+1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,low,mid,target,flag);\\n            }\\n            else if(nums[mid]<target){\\n                  search(nums,v,mid+1,high,target,flag);\\n            }\\n            else{\\n                search(nums,v,low,mid-1,target,flag);\\n            }\\n        }\\n        \\n        \\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>v;bool flag=false;\\n        int low=0;int high=nums.size()-1;\\n        search(nums,v,low,high,target,flag);\\n        if(flag==false){\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1755686,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n   int Fstarting_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n   int Fending_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                low=mid+1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        int lmi=Fstarting_index_target_element(nums,target,n);\\n        int rmi=Fending_index_target_element(nums,target,n);\\n            temp.push_back(lmi);\\n            temp.push_back(rmi);\\n            return temp;\\n    }\\n};"
                    },
                    {
                        "username": "mminyngy",
                        "content": " `class Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        start = 0\\n        end = len(nums) - 1\\n        index = end\\n        result = []\\n\\n        if target in nums:\\n            start = nums.index(target)\\n            for num in reversed(nums):\\n                if num == target:\\n                    end = index\\n                    break\\n                index -= 1\\n        else:\\n            start = -1\\n            end = -1\\n            \\n        result[:] = [start, end]\\n        return result`\\n\\nwill it be accepted? I tryna make it look easy tho"
                    },
                    {
                        "username": "rahulraj17",
                        "content": "These codes give TLE, what should i do ?\\n\\nclass Solution {\\npublic:\\n    int firstOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    \\n    int lastOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                int start = mid + 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        // return{firstOccurance(nums,nums.size(),target), lastOccurance(nums,nums.size(),target)};\\n    }\\n};"
                    },
                    {
                        "username": "Ultron03",
                        "content": "check for which testcase it is giving tle and then solve the testcase in the paper according to your code .. hop it works."
                    },
                    {
                        "username": "user4474EC",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if( nums.size()==0)return{-1,-1};\\n        if(nums.size()==1 && nums[0]==target)return {0,0};\\n        int s=0,e=nums.size()-1;\\n        vector<int>ans;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target){\\n                int l=mid,r=mid;\\n                if( nums[mid]!=nums[mid-1]&&nums[mid]!=nums[mid+1] ){\\n                    ans.push_back(mid);\\n                    ans.push_back(mid);break;\\n                }\\n                else\\n                {\\n                    while( nums[l]==nums[mid])l--;\\n                    ans.push_back(l+1); \\n                    while( nums[r]==nums[mid])r++;\\n                    ans.push_back(r-1);\\n                }\\n\\n                break;\\n                \\n            }\\n            else if(nums[mid]>target ){\\n                e=mid-1;\\n\\n            }\\n            else {\\n                s=mid+1;\\n            }\\n        }\\n        if( ans.size()==0){\\n            if( nums.size()==1&& target==nums[0])return {0,0};\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else if ( ans.size()==1){\\n            if( nums.size()==1 && nums[0]==ans[0])ans.push_back(0);\\n            ans.push_back( ans[0]);\\n        }\\n            \\n\\n        return ans;\\n    }\\n}; \\n\\nthis is my code i am not getting why this is getting run time error for values.\\n"
                    },
                    {
                        "username": "adityapaluskar",
                        "content": "how do i return arrays in output as shown in example... need help"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just make a vector of size two and initialize them with -1 and change if  the target indices found..\\n "
                    },
                    {
                        "username": "kimkass",
                        "content": "What does the description has to be so ambiguous instead  of saying sorted in non decreasing order it can say sorted in increasing order."
                    },
                    {
                        "username": "MissRobot",
                        "content": "Non-decreasing and increasing orders are not the same thing, since the same element can be repeated as in 8 8 8 ... it is non-decreasing order, can\\'t be increasing order."
                    },
                    {
                        "username": "mahak_22",
                        "content": "class Solution {\\npublic:\\nint firstoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            r=mid-1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n    }\\n    return result;\\n}\\nint lastoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            l=mid+1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n        \\n    }\\n    return result;\\n    \\n}\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n    vector<int>v;\\n    \\n    int f=firstoccurence(nums,nums.size(),target);\\n    int last=lastoccurence(nums,nums.size(),target);\\n    return v={f,last};\\n    }\\n\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mukulbhardwaj947",
                        "content": "I have debugged my code  but it still shows TLE.What should i do? "
                    },
                    {
                        "username": "ram_singhal17",
                        "content": "PLEASE HELP ME OUT!! \\n\\nclass Solution {\\npublic:\\n    void search(vector<int>&nums,vector<int>&v,int low,int high,int target,bool flag){\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target && nums[mid-1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,mid,high,target,flag);\\n            }\\n            else if(nums[mid]==target && nums[mid+1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,low,mid,target,flag);\\n            }\\n            else if(nums[mid]<target){\\n                  search(nums,v,mid+1,high,target,flag);\\n            }\\n            else{\\n                search(nums,v,low,mid-1,target,flag);\\n            }\\n        }\\n        \\n        \\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>v;bool flag=false;\\n        int low=0;int high=nums.size()-1;\\n        search(nums,v,low,high,target,flag);\\n        if(flag==false){\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1752602,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n   int Fstarting_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n   int Fending_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                low=mid+1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        int lmi=Fstarting_index_target_element(nums,target,n);\\n        int rmi=Fending_index_target_element(nums,target,n);\\n            temp.push_back(lmi);\\n            temp.push_back(rmi);\\n            return temp;\\n    }\\n};"
                    },
                    {
                        "username": "mminyngy",
                        "content": " `class Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        start = 0\\n        end = len(nums) - 1\\n        index = end\\n        result = []\\n\\n        if target in nums:\\n            start = nums.index(target)\\n            for num in reversed(nums):\\n                if num == target:\\n                    end = index\\n                    break\\n                index -= 1\\n        else:\\n            start = -1\\n            end = -1\\n            \\n        result[:] = [start, end]\\n        return result`\\n\\nwill it be accepted? I tryna make it look easy tho"
                    },
                    {
                        "username": "rahulraj17",
                        "content": "These codes give TLE, what should i do ?\\n\\nclass Solution {\\npublic:\\n    int firstOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    \\n    int lastOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                int start = mid + 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        // return{firstOccurance(nums,nums.size(),target), lastOccurance(nums,nums.size(),target)};\\n    }\\n};"
                    },
                    {
                        "username": "Ultron03",
                        "content": "check for which testcase it is giving tle and then solve the testcase in the paper according to your code .. hop it works."
                    },
                    {
                        "username": "user4474EC",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if( nums.size()==0)return{-1,-1};\\n        if(nums.size()==1 && nums[0]==target)return {0,0};\\n        int s=0,e=nums.size()-1;\\n        vector<int>ans;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target){\\n                int l=mid,r=mid;\\n                if( nums[mid]!=nums[mid-1]&&nums[mid]!=nums[mid+1] ){\\n                    ans.push_back(mid);\\n                    ans.push_back(mid);break;\\n                }\\n                else\\n                {\\n                    while( nums[l]==nums[mid])l--;\\n                    ans.push_back(l+1); \\n                    while( nums[r]==nums[mid])r++;\\n                    ans.push_back(r-1);\\n                }\\n\\n                break;\\n                \\n            }\\n            else if(nums[mid]>target ){\\n                e=mid-1;\\n\\n            }\\n            else {\\n                s=mid+1;\\n            }\\n        }\\n        if( ans.size()==0){\\n            if( nums.size()==1&& target==nums[0])return {0,0};\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else if ( ans.size()==1){\\n            if( nums.size()==1 && nums[0]==ans[0])ans.push_back(0);\\n            ans.push_back( ans[0]);\\n        }\\n            \\n\\n        return ans;\\n    }\\n}; \\n\\nthis is my code i am not getting why this is getting run time error for values.\\n"
                    },
                    {
                        "username": "adityapaluskar",
                        "content": "how do i return arrays in output as shown in example... need help"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just make a vector of size two and initialize them with -1 and change if  the target indices found..\\n "
                    },
                    {
                        "username": "kimkass",
                        "content": "What does the description has to be so ambiguous instead  of saying sorted in non decreasing order it can say sorted in increasing order."
                    },
                    {
                        "username": "MissRobot",
                        "content": "Non-decreasing and increasing orders are not the same thing, since the same element can be repeated as in 8 8 8 ... it is non-decreasing order, can\\'t be increasing order."
                    },
                    {
                        "username": "mahak_22",
                        "content": "class Solution {\\npublic:\\nint firstoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            r=mid-1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n    }\\n    return result;\\n}\\nint lastoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            l=mid+1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n        \\n    }\\n    return result;\\n    \\n}\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n    vector<int>v;\\n    \\n    int f=firstoccurence(nums,nums.size(),target);\\n    int last=lastoccurence(nums,nums.size(),target);\\n    return v={f,last};\\n    }\\n\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mukulbhardwaj947",
                        "content": "I have debugged my code  but it still shows TLE.What should i do? "
                    },
                    {
                        "username": "ram_singhal17",
                        "content": "PLEASE HELP ME OUT!! \\n\\nclass Solution {\\npublic:\\n    void search(vector<int>&nums,vector<int>&v,int low,int high,int target,bool flag){\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target && nums[mid-1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,mid,high,target,flag);\\n            }\\n            else if(nums[mid]==target && nums[mid+1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,low,mid,target,flag);\\n            }\\n            else if(nums[mid]<target){\\n                  search(nums,v,mid+1,high,target,flag);\\n            }\\n            else{\\n                search(nums,v,low,mid-1,target,flag);\\n            }\\n        }\\n        \\n        \\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>v;bool flag=false;\\n        int low=0;int high=nums.size()-1;\\n        search(nums,v,low,high,target,flag);\\n        if(flag==false){\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1750006,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n   int Fstarting_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n   int Fending_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                low=mid+1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        int lmi=Fstarting_index_target_element(nums,target,n);\\n        int rmi=Fending_index_target_element(nums,target,n);\\n            temp.push_back(lmi);\\n            temp.push_back(rmi);\\n            return temp;\\n    }\\n};"
                    },
                    {
                        "username": "mminyngy",
                        "content": " `class Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        start = 0\\n        end = len(nums) - 1\\n        index = end\\n        result = []\\n\\n        if target in nums:\\n            start = nums.index(target)\\n            for num in reversed(nums):\\n                if num == target:\\n                    end = index\\n                    break\\n                index -= 1\\n        else:\\n            start = -1\\n            end = -1\\n            \\n        result[:] = [start, end]\\n        return result`\\n\\nwill it be accepted? I tryna make it look easy tho"
                    },
                    {
                        "username": "rahulraj17",
                        "content": "These codes give TLE, what should i do ?\\n\\nclass Solution {\\npublic:\\n    int firstOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    \\n    int lastOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                int start = mid + 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        // return{firstOccurance(nums,nums.size(),target), lastOccurance(nums,nums.size(),target)};\\n    }\\n};"
                    },
                    {
                        "username": "Ultron03",
                        "content": "check for which testcase it is giving tle and then solve the testcase in the paper according to your code .. hop it works."
                    },
                    {
                        "username": "user4474EC",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if( nums.size()==0)return{-1,-1};\\n        if(nums.size()==1 && nums[0]==target)return {0,0};\\n        int s=0,e=nums.size()-1;\\n        vector<int>ans;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target){\\n                int l=mid,r=mid;\\n                if( nums[mid]!=nums[mid-1]&&nums[mid]!=nums[mid+1] ){\\n                    ans.push_back(mid);\\n                    ans.push_back(mid);break;\\n                }\\n                else\\n                {\\n                    while( nums[l]==nums[mid])l--;\\n                    ans.push_back(l+1); \\n                    while( nums[r]==nums[mid])r++;\\n                    ans.push_back(r-1);\\n                }\\n\\n                break;\\n                \\n            }\\n            else if(nums[mid]>target ){\\n                e=mid-1;\\n\\n            }\\n            else {\\n                s=mid+1;\\n            }\\n        }\\n        if( ans.size()==0){\\n            if( nums.size()==1&& target==nums[0])return {0,0};\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else if ( ans.size()==1){\\n            if( nums.size()==1 && nums[0]==ans[0])ans.push_back(0);\\n            ans.push_back( ans[0]);\\n        }\\n            \\n\\n        return ans;\\n    }\\n}; \\n\\nthis is my code i am not getting why this is getting run time error for values.\\n"
                    },
                    {
                        "username": "adityapaluskar",
                        "content": "how do i return arrays in output as shown in example... need help"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just make a vector of size two and initialize them with -1 and change if  the target indices found..\\n "
                    },
                    {
                        "username": "kimkass",
                        "content": "What does the description has to be so ambiguous instead  of saying sorted in non decreasing order it can say sorted in increasing order."
                    },
                    {
                        "username": "MissRobot",
                        "content": "Non-decreasing and increasing orders are not the same thing, since the same element can be repeated as in 8 8 8 ... it is non-decreasing order, can\\'t be increasing order."
                    },
                    {
                        "username": "mahak_22",
                        "content": "class Solution {\\npublic:\\nint firstoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            r=mid-1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n    }\\n    return result;\\n}\\nint lastoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            l=mid+1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n        \\n    }\\n    return result;\\n    \\n}\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n    vector<int>v;\\n    \\n    int f=firstoccurence(nums,nums.size(),target);\\n    int last=lastoccurence(nums,nums.size(),target);\\n    return v={f,last};\\n    }\\n\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mukulbhardwaj947",
                        "content": "I have debugged my code  but it still shows TLE.What should i do? "
                    },
                    {
                        "username": "ram_singhal17",
                        "content": "PLEASE HELP ME OUT!! \\n\\nclass Solution {\\npublic:\\n    void search(vector<int>&nums,vector<int>&v,int low,int high,int target,bool flag){\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target && nums[mid-1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,mid,high,target,flag);\\n            }\\n            else if(nums[mid]==target && nums[mid+1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,low,mid,target,flag);\\n            }\\n            else if(nums[mid]<target){\\n                  search(nums,v,mid+1,high,target,flag);\\n            }\\n            else{\\n                search(nums,v,low,mid-1,target,flag);\\n            }\\n        }\\n        \\n        \\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>v;bool flag=false;\\n        int low=0;int high=nums.size()-1;\\n        search(nums,v,low,high,target,flag);\\n        if(flag==false){\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1744750,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n   int Fstarting_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n   int Fending_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                low=mid+1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        int lmi=Fstarting_index_target_element(nums,target,n);\\n        int rmi=Fending_index_target_element(nums,target,n);\\n            temp.push_back(lmi);\\n            temp.push_back(rmi);\\n            return temp;\\n    }\\n};"
                    },
                    {
                        "username": "mminyngy",
                        "content": " `class Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        start = 0\\n        end = len(nums) - 1\\n        index = end\\n        result = []\\n\\n        if target in nums:\\n            start = nums.index(target)\\n            for num in reversed(nums):\\n                if num == target:\\n                    end = index\\n                    break\\n                index -= 1\\n        else:\\n            start = -1\\n            end = -1\\n            \\n        result[:] = [start, end]\\n        return result`\\n\\nwill it be accepted? I tryna make it look easy tho"
                    },
                    {
                        "username": "rahulraj17",
                        "content": "These codes give TLE, what should i do ?\\n\\nclass Solution {\\npublic:\\n    int firstOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    \\n    int lastOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                int start = mid + 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        // return{firstOccurance(nums,nums.size(),target), lastOccurance(nums,nums.size(),target)};\\n    }\\n};"
                    },
                    {
                        "username": "Ultron03",
                        "content": "check for which testcase it is giving tle and then solve the testcase in the paper according to your code .. hop it works."
                    },
                    {
                        "username": "user4474EC",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if( nums.size()==0)return{-1,-1};\\n        if(nums.size()==1 && nums[0]==target)return {0,0};\\n        int s=0,e=nums.size()-1;\\n        vector<int>ans;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target){\\n                int l=mid,r=mid;\\n                if( nums[mid]!=nums[mid-1]&&nums[mid]!=nums[mid+1] ){\\n                    ans.push_back(mid);\\n                    ans.push_back(mid);break;\\n                }\\n                else\\n                {\\n                    while( nums[l]==nums[mid])l--;\\n                    ans.push_back(l+1); \\n                    while( nums[r]==nums[mid])r++;\\n                    ans.push_back(r-1);\\n                }\\n\\n                break;\\n                \\n            }\\n            else if(nums[mid]>target ){\\n                e=mid-1;\\n\\n            }\\n            else {\\n                s=mid+1;\\n            }\\n        }\\n        if( ans.size()==0){\\n            if( nums.size()==1&& target==nums[0])return {0,0};\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else if ( ans.size()==1){\\n            if( nums.size()==1 && nums[0]==ans[0])ans.push_back(0);\\n            ans.push_back( ans[0]);\\n        }\\n            \\n\\n        return ans;\\n    }\\n}; \\n\\nthis is my code i am not getting why this is getting run time error for values.\\n"
                    },
                    {
                        "username": "adityapaluskar",
                        "content": "how do i return arrays in output as shown in example... need help"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just make a vector of size two and initialize them with -1 and change if  the target indices found..\\n "
                    },
                    {
                        "username": "kimkass",
                        "content": "What does the description has to be so ambiguous instead  of saying sorted in non decreasing order it can say sorted in increasing order."
                    },
                    {
                        "username": "MissRobot",
                        "content": "Non-decreasing and increasing orders are not the same thing, since the same element can be repeated as in 8 8 8 ... it is non-decreasing order, can\\'t be increasing order."
                    },
                    {
                        "username": "mahak_22",
                        "content": "class Solution {\\npublic:\\nint firstoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            r=mid-1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n    }\\n    return result;\\n}\\nint lastoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            l=mid+1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n        \\n    }\\n    return result;\\n    \\n}\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n    vector<int>v;\\n    \\n    int f=firstoccurence(nums,nums.size(),target);\\n    int last=lastoccurence(nums,nums.size(),target);\\n    return v={f,last};\\n    }\\n\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mukulbhardwaj947",
                        "content": "I have debugged my code  but it still shows TLE.What should i do? "
                    },
                    {
                        "username": "ram_singhal17",
                        "content": "PLEASE HELP ME OUT!! \\n\\nclass Solution {\\npublic:\\n    void search(vector<int>&nums,vector<int>&v,int low,int high,int target,bool flag){\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target && nums[mid-1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,mid,high,target,flag);\\n            }\\n            else if(nums[mid]==target && nums[mid+1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,low,mid,target,flag);\\n            }\\n            else if(nums[mid]<target){\\n                  search(nums,v,mid+1,high,target,flag);\\n            }\\n            else{\\n                search(nums,v,low,mid-1,target,flag);\\n            }\\n        }\\n        \\n        \\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>v;bool flag=false;\\n        int low=0;int high=nums.size()-1;\\n        search(nums,v,low,high,target,flag);\\n        if(flag==false){\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1739944,
                "content": [
                    {
                        "username": "anirudh9801",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int low =0;\\n        int ans =-1;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n            if(nums[mid]>target){\\n                high=mid-1;\\n            }else if(nums[mid]<target){\\n                low=mid+1;\\n            }else{\\n                if(mid==0){\\n                    return mid;\\n                }else if(nums[mid-1]!=target){\\n                    return mid;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }\\n\\n        }\\n            return ans;\\n\\n    \\n\\n        // int ans=-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n                   if(nums[mid]>target){\\n            high=mid-1;\\n        }else if(nums[mid]<target){\\n            low=mid+1;\\n        }else{\\n            if(mid==high){\\n                return mid;\\n            }else if(nums[mid+1]!=target){\\n                return mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n    \\n    \\n}\\n        return ans;\\n\\n}\\n}\\n\\ncan anyone help me out? please??"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "nums.size() function does not work, what should i do?"
                    },
                    {
                        "username": "raunak_wick",
                        "content": "use nums.length"
                    },
                    {
                        "username": "chandraparkash421",
                        "content": "java solution\\n `your inline code...your inline code...`\\npublic class Solution {\\n   public int[] searchRange(int[] A, int target) {\\n    int index = binarySearch(A, 0, A.length-1, target);\\n    int[] result = {-1, -1};\\n    if (index != -1) {\\n        int left  = index;\\n        int right = index;\\n        while (left != -1){           \\n            result[0] = left;\\n            left = binarySearch(A, 0, left-1, target);\\n        }\\n        while (right != -1){ \\n            result[1] = right;\\n            right = binarySearch(A, right+1, A.length-1, target);\\n        }\\n    }\\n    return result;\\n}\\n\\nprivate int binarySearch(int[] A, int lo, int hi, int target) {\\n    while (lo <= hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if      (A[mid] < target) lo = mid + 1;\\n        else if (A[mid] > target) hi = mid - 1;\\n        else return mid;            \\n    }\\n    return -1;\\n  }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/34_first_and_last_pos.cpp"
                    },
                    {
                        "username": "anujkumar61",
                        "content": " vector<int>ans= {-1,-1};\\n      int s=0;\\n      int e=nums.size()-1;\\n\\n      while(s<=e){\\n          \\n          int mid =s+(e-s)/2;\\n         \\n         \\n          if(nums[mid] == target && nums[mid] >= 0 ){\\n              ans[0] = mid;\\n              e = mid-1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid -1;\\n          }\\n          \\n      }\\n      \\n    \\n        s = 0;\\n        e = nums.size() - 1;\\n\\n      while(s<=e){\\n          int mid = s+(e-s)/2;\\n\\n          if(nums[mid] == target){\\n              ans[1] = mid;\\n              s = mid+1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid-1;\\n          }\\n      }\\n      return ans;\\n    }\\n\\n\\nI don\\'t know what did i do wrong but only 49/88 testcases are passed \\ncan anyone know?\\n"
                    },
                    {
                        "username": "fardinalam2112",
                        "content": "but we have to do that code in log(n) time if use 2 loop then it will be still in log(n)?\n"
                    },
                    {
                        "username": "Prathvik",
                        "content": "[@anujkumar61](/anujkumar61)  replace \" if(nums[mid]<target) \" with else \" if(nums[mid]<target) \"thats where the error is"
                    },
                    {
                        "username": "anujkumar61",
                        "content": "[@Prathvik](/Prathvik) still getting error after submitting"
                    },
                    {
                        "username": "Prathvik",
                        "content": "remove the && nums[mid]>= 0 condition and it should be fine"
                    },
                    {
                        "username": "sam_chirayu",
                        "content": "Why we need to iterate two times... can\\'t we iterate only one time and if yes then how ???"
                    },
                    {
                        "username": "DURGA_SAI11",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int arr[]=new int[2],j=0;\\n        int flag=0;\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n            for(int i=nums.length-1;i>=0;i--)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n                if(flag==0)\\n                {arr[0]=-1;arr[1]=-1;}\\n            return arr;\\n    }\\n}"
                    },
                    {
                        "username": "user54893210",
                        "content": "Isn\\'t finding length of an array for the right pointer in a binary search o(n) cost?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    }
                ]
            },
            {
                "id": 1733541,
                "content": [
                    {
                        "username": "anirudh9801",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int low =0;\\n        int ans =-1;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n            if(nums[mid]>target){\\n                high=mid-1;\\n            }else if(nums[mid]<target){\\n                low=mid+1;\\n            }else{\\n                if(mid==0){\\n                    return mid;\\n                }else if(nums[mid-1]!=target){\\n                    return mid;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }\\n\\n        }\\n            return ans;\\n\\n    \\n\\n        // int ans=-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n                   if(nums[mid]>target){\\n            high=mid-1;\\n        }else if(nums[mid]<target){\\n            low=mid+1;\\n        }else{\\n            if(mid==high){\\n                return mid;\\n            }else if(nums[mid+1]!=target){\\n                return mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n    \\n    \\n}\\n        return ans;\\n\\n}\\n}\\n\\ncan anyone help me out? please??"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "nums.size() function does not work, what should i do?"
                    },
                    {
                        "username": "raunak_wick",
                        "content": "use nums.length"
                    },
                    {
                        "username": "chandraparkash421",
                        "content": "java solution\\n `your inline code...your inline code...`\\npublic class Solution {\\n   public int[] searchRange(int[] A, int target) {\\n    int index = binarySearch(A, 0, A.length-1, target);\\n    int[] result = {-1, -1};\\n    if (index != -1) {\\n        int left  = index;\\n        int right = index;\\n        while (left != -1){           \\n            result[0] = left;\\n            left = binarySearch(A, 0, left-1, target);\\n        }\\n        while (right != -1){ \\n            result[1] = right;\\n            right = binarySearch(A, right+1, A.length-1, target);\\n        }\\n    }\\n    return result;\\n}\\n\\nprivate int binarySearch(int[] A, int lo, int hi, int target) {\\n    while (lo <= hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if      (A[mid] < target) lo = mid + 1;\\n        else if (A[mid] > target) hi = mid - 1;\\n        else return mid;            \\n    }\\n    return -1;\\n  }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/34_first_and_last_pos.cpp"
                    },
                    {
                        "username": "anujkumar61",
                        "content": " vector<int>ans= {-1,-1};\\n      int s=0;\\n      int e=nums.size()-1;\\n\\n      while(s<=e){\\n          \\n          int mid =s+(e-s)/2;\\n         \\n         \\n          if(nums[mid] == target && nums[mid] >= 0 ){\\n              ans[0] = mid;\\n              e = mid-1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid -1;\\n          }\\n          \\n      }\\n      \\n    \\n        s = 0;\\n        e = nums.size() - 1;\\n\\n      while(s<=e){\\n          int mid = s+(e-s)/2;\\n\\n          if(nums[mid] == target){\\n              ans[1] = mid;\\n              s = mid+1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid-1;\\n          }\\n      }\\n      return ans;\\n    }\\n\\n\\nI don\\'t know what did i do wrong but only 49/88 testcases are passed \\ncan anyone know?\\n"
                    },
                    {
                        "username": "fardinalam2112",
                        "content": "but we have to do that code in log(n) time if use 2 loop then it will be still in log(n)?\n"
                    },
                    {
                        "username": "Prathvik",
                        "content": "[@anujkumar61](/anujkumar61)  replace \" if(nums[mid]<target) \" with else \" if(nums[mid]<target) \"thats where the error is"
                    },
                    {
                        "username": "anujkumar61",
                        "content": "[@Prathvik](/Prathvik) still getting error after submitting"
                    },
                    {
                        "username": "Prathvik",
                        "content": "remove the && nums[mid]>= 0 condition and it should be fine"
                    },
                    {
                        "username": "sam_chirayu",
                        "content": "Why we need to iterate two times... can\\'t we iterate only one time and if yes then how ???"
                    },
                    {
                        "username": "DURGA_SAI11",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int arr[]=new int[2],j=0;\\n        int flag=0;\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n            for(int i=nums.length-1;i>=0;i--)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n                if(flag==0)\\n                {arr[0]=-1;arr[1]=-1;}\\n            return arr;\\n    }\\n}"
                    },
                    {
                        "username": "user54893210",
                        "content": "Isn\\'t finding length of an array for the right pointer in a binary search o(n) cost?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    }
                ]
            },
            {
                "id": 1731070,
                "content": [
                    {
                        "username": "anirudh9801",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int low =0;\\n        int ans =-1;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n            if(nums[mid]>target){\\n                high=mid-1;\\n            }else if(nums[mid]<target){\\n                low=mid+1;\\n            }else{\\n                if(mid==0){\\n                    return mid;\\n                }else if(nums[mid-1]!=target){\\n                    return mid;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }\\n\\n        }\\n            return ans;\\n\\n    \\n\\n        // int ans=-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n                   if(nums[mid]>target){\\n            high=mid-1;\\n        }else if(nums[mid]<target){\\n            low=mid+1;\\n        }else{\\n            if(mid==high){\\n                return mid;\\n            }else if(nums[mid+1]!=target){\\n                return mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n    \\n    \\n}\\n        return ans;\\n\\n}\\n}\\n\\ncan anyone help me out? please??"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "nums.size() function does not work, what should i do?"
                    },
                    {
                        "username": "raunak_wick",
                        "content": "use nums.length"
                    },
                    {
                        "username": "chandraparkash421",
                        "content": "java solution\\n `your inline code...your inline code...`\\npublic class Solution {\\n   public int[] searchRange(int[] A, int target) {\\n    int index = binarySearch(A, 0, A.length-1, target);\\n    int[] result = {-1, -1};\\n    if (index != -1) {\\n        int left  = index;\\n        int right = index;\\n        while (left != -1){           \\n            result[0] = left;\\n            left = binarySearch(A, 0, left-1, target);\\n        }\\n        while (right != -1){ \\n            result[1] = right;\\n            right = binarySearch(A, right+1, A.length-1, target);\\n        }\\n    }\\n    return result;\\n}\\n\\nprivate int binarySearch(int[] A, int lo, int hi, int target) {\\n    while (lo <= hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if      (A[mid] < target) lo = mid + 1;\\n        else if (A[mid] > target) hi = mid - 1;\\n        else return mid;            \\n    }\\n    return -1;\\n  }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/34_first_and_last_pos.cpp"
                    },
                    {
                        "username": "anujkumar61",
                        "content": " vector<int>ans= {-1,-1};\\n      int s=0;\\n      int e=nums.size()-1;\\n\\n      while(s<=e){\\n          \\n          int mid =s+(e-s)/2;\\n         \\n         \\n          if(nums[mid] == target && nums[mid] >= 0 ){\\n              ans[0] = mid;\\n              e = mid-1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid -1;\\n          }\\n          \\n      }\\n      \\n    \\n        s = 0;\\n        e = nums.size() - 1;\\n\\n      while(s<=e){\\n          int mid = s+(e-s)/2;\\n\\n          if(nums[mid] == target){\\n              ans[1] = mid;\\n              s = mid+1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid-1;\\n          }\\n      }\\n      return ans;\\n    }\\n\\n\\nI don\\'t know what did i do wrong but only 49/88 testcases are passed \\ncan anyone know?\\n"
                    },
                    {
                        "username": "fardinalam2112",
                        "content": "but we have to do that code in log(n) time if use 2 loop then it will be still in log(n)?\n"
                    },
                    {
                        "username": "Prathvik",
                        "content": "[@anujkumar61](/anujkumar61)  replace \" if(nums[mid]<target) \" with else \" if(nums[mid]<target) \"thats where the error is"
                    },
                    {
                        "username": "anujkumar61",
                        "content": "[@Prathvik](/Prathvik) still getting error after submitting"
                    },
                    {
                        "username": "Prathvik",
                        "content": "remove the && nums[mid]>= 0 condition and it should be fine"
                    },
                    {
                        "username": "sam_chirayu",
                        "content": "Why we need to iterate two times... can\\'t we iterate only one time and if yes then how ???"
                    },
                    {
                        "username": "DURGA_SAI11",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int arr[]=new int[2],j=0;\\n        int flag=0;\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n            for(int i=nums.length-1;i>=0;i--)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n                if(flag==0)\\n                {arr[0]=-1;arr[1]=-1;}\\n            return arr;\\n    }\\n}"
                    },
                    {
                        "username": "user54893210",
                        "content": "Isn\\'t finding length of an array for the right pointer in a binary search o(n) cost?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    }
                ]
            },
            {
                "id": 1729988,
                "content": [
                    {
                        "username": "anirudh9801",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int low =0;\\n        int ans =-1;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n            if(nums[mid]>target){\\n                high=mid-1;\\n            }else if(nums[mid]<target){\\n                low=mid+1;\\n            }else{\\n                if(mid==0){\\n                    return mid;\\n                }else if(nums[mid-1]!=target){\\n                    return mid;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }\\n\\n        }\\n            return ans;\\n\\n    \\n\\n        // int ans=-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n                   if(nums[mid]>target){\\n            high=mid-1;\\n        }else if(nums[mid]<target){\\n            low=mid+1;\\n        }else{\\n            if(mid==high){\\n                return mid;\\n            }else if(nums[mid+1]!=target){\\n                return mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n    \\n    \\n}\\n        return ans;\\n\\n}\\n}\\n\\ncan anyone help me out? please??"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "nums.size() function does not work, what should i do?"
                    },
                    {
                        "username": "raunak_wick",
                        "content": "use nums.length"
                    },
                    {
                        "username": "chandraparkash421",
                        "content": "java solution\\n `your inline code...your inline code...`\\npublic class Solution {\\n   public int[] searchRange(int[] A, int target) {\\n    int index = binarySearch(A, 0, A.length-1, target);\\n    int[] result = {-1, -1};\\n    if (index != -1) {\\n        int left  = index;\\n        int right = index;\\n        while (left != -1){           \\n            result[0] = left;\\n            left = binarySearch(A, 0, left-1, target);\\n        }\\n        while (right != -1){ \\n            result[1] = right;\\n            right = binarySearch(A, right+1, A.length-1, target);\\n        }\\n    }\\n    return result;\\n}\\n\\nprivate int binarySearch(int[] A, int lo, int hi, int target) {\\n    while (lo <= hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if      (A[mid] < target) lo = mid + 1;\\n        else if (A[mid] > target) hi = mid - 1;\\n        else return mid;            \\n    }\\n    return -1;\\n  }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/34_first_and_last_pos.cpp"
                    },
                    {
                        "username": "anujkumar61",
                        "content": " vector<int>ans= {-1,-1};\\n      int s=0;\\n      int e=nums.size()-1;\\n\\n      while(s<=e){\\n          \\n          int mid =s+(e-s)/2;\\n         \\n         \\n          if(nums[mid] == target && nums[mid] >= 0 ){\\n              ans[0] = mid;\\n              e = mid-1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid -1;\\n          }\\n          \\n      }\\n      \\n    \\n        s = 0;\\n        e = nums.size() - 1;\\n\\n      while(s<=e){\\n          int mid = s+(e-s)/2;\\n\\n          if(nums[mid] == target){\\n              ans[1] = mid;\\n              s = mid+1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid-1;\\n          }\\n      }\\n      return ans;\\n    }\\n\\n\\nI don\\'t know what did i do wrong but only 49/88 testcases are passed \\ncan anyone know?\\n"
                    },
                    {
                        "username": "fardinalam2112",
                        "content": "but we have to do that code in log(n) time if use 2 loop then it will be still in log(n)?\n"
                    },
                    {
                        "username": "Prathvik",
                        "content": "[@anujkumar61](/anujkumar61)  replace \" if(nums[mid]<target) \" with else \" if(nums[mid]<target) \"thats where the error is"
                    },
                    {
                        "username": "anujkumar61",
                        "content": "[@Prathvik](/Prathvik) still getting error after submitting"
                    },
                    {
                        "username": "Prathvik",
                        "content": "remove the && nums[mid]>= 0 condition and it should be fine"
                    },
                    {
                        "username": "sam_chirayu",
                        "content": "Why we need to iterate two times... can\\'t we iterate only one time and if yes then how ???"
                    },
                    {
                        "username": "DURGA_SAI11",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int arr[]=new int[2],j=0;\\n        int flag=0;\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n            for(int i=nums.length-1;i>=0;i--)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n                if(flag==0)\\n                {arr[0]=-1;arr[1]=-1;}\\n            return arr;\\n    }\\n}"
                    },
                    {
                        "username": "user54893210",
                        "content": "Isn\\'t finding length of an array for the right pointer in a binary search o(n) cost?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    }
                ]
            },
            {
                "id": 1721249,
                "content": [
                    {
                        "username": "anirudh9801",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int low =0;\\n        int ans =-1;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n            if(nums[mid]>target){\\n                high=mid-1;\\n            }else if(nums[mid]<target){\\n                low=mid+1;\\n            }else{\\n                if(mid==0){\\n                    return mid;\\n                }else if(nums[mid-1]!=target){\\n                    return mid;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }\\n\\n        }\\n            return ans;\\n\\n    \\n\\n        // int ans=-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n                   if(nums[mid]>target){\\n            high=mid-1;\\n        }else if(nums[mid]<target){\\n            low=mid+1;\\n        }else{\\n            if(mid==high){\\n                return mid;\\n            }else if(nums[mid+1]!=target){\\n                return mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n    \\n    \\n}\\n        return ans;\\n\\n}\\n}\\n\\ncan anyone help me out? please??"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "nums.size() function does not work, what should i do?"
                    },
                    {
                        "username": "raunak_wick",
                        "content": "use nums.length"
                    },
                    {
                        "username": "chandraparkash421",
                        "content": "java solution\\n `your inline code...your inline code...`\\npublic class Solution {\\n   public int[] searchRange(int[] A, int target) {\\n    int index = binarySearch(A, 0, A.length-1, target);\\n    int[] result = {-1, -1};\\n    if (index != -1) {\\n        int left  = index;\\n        int right = index;\\n        while (left != -1){           \\n            result[0] = left;\\n            left = binarySearch(A, 0, left-1, target);\\n        }\\n        while (right != -1){ \\n            result[1] = right;\\n            right = binarySearch(A, right+1, A.length-1, target);\\n        }\\n    }\\n    return result;\\n}\\n\\nprivate int binarySearch(int[] A, int lo, int hi, int target) {\\n    while (lo <= hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if      (A[mid] < target) lo = mid + 1;\\n        else if (A[mid] > target) hi = mid - 1;\\n        else return mid;            \\n    }\\n    return -1;\\n  }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/34_first_and_last_pos.cpp"
                    },
                    {
                        "username": "anujkumar61",
                        "content": " vector<int>ans= {-1,-1};\\n      int s=0;\\n      int e=nums.size()-1;\\n\\n      while(s<=e){\\n          \\n          int mid =s+(e-s)/2;\\n         \\n         \\n          if(nums[mid] == target && nums[mid] >= 0 ){\\n              ans[0] = mid;\\n              e = mid-1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid -1;\\n          }\\n          \\n      }\\n      \\n    \\n        s = 0;\\n        e = nums.size() - 1;\\n\\n      while(s<=e){\\n          int mid = s+(e-s)/2;\\n\\n          if(nums[mid] == target){\\n              ans[1] = mid;\\n              s = mid+1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid-1;\\n          }\\n      }\\n      return ans;\\n    }\\n\\n\\nI don\\'t know what did i do wrong but only 49/88 testcases are passed \\ncan anyone know?\\n"
                    },
                    {
                        "username": "fardinalam2112",
                        "content": "but we have to do that code in log(n) time if use 2 loop then it will be still in log(n)?\n"
                    },
                    {
                        "username": "Prathvik",
                        "content": "[@anujkumar61](/anujkumar61)  replace \" if(nums[mid]<target) \" with else \" if(nums[mid]<target) \"thats where the error is"
                    },
                    {
                        "username": "anujkumar61",
                        "content": "[@Prathvik](/Prathvik) still getting error after submitting"
                    },
                    {
                        "username": "Prathvik",
                        "content": "remove the && nums[mid]>= 0 condition and it should be fine"
                    },
                    {
                        "username": "sam_chirayu",
                        "content": "Why we need to iterate two times... can\\'t we iterate only one time and if yes then how ???"
                    },
                    {
                        "username": "DURGA_SAI11",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int arr[]=new int[2],j=0;\\n        int flag=0;\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n            for(int i=nums.length-1;i>=0;i--)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n                if(flag==0)\\n                {arr[0]=-1;arr[1]=-1;}\\n            return arr;\\n    }\\n}"
                    },
                    {
                        "username": "user54893210",
                        "content": "Isn\\'t finding length of an array for the right pointer in a binary search o(n) cost?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    }
                ]
            },
            {
                "id": 1720491,
                "content": [
                    {
                        "username": "anirudh9801",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int low =0;\\n        int ans =-1;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n            if(nums[mid]>target){\\n                high=mid-1;\\n            }else if(nums[mid]<target){\\n                low=mid+1;\\n            }else{\\n                if(mid==0){\\n                    return mid;\\n                }else if(nums[mid-1]!=target){\\n                    return mid;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }\\n\\n        }\\n            return ans;\\n\\n    \\n\\n        // int ans=-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n                   if(nums[mid]>target){\\n            high=mid-1;\\n        }else if(nums[mid]<target){\\n            low=mid+1;\\n        }else{\\n            if(mid==high){\\n                return mid;\\n            }else if(nums[mid+1]!=target){\\n                return mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n    \\n    \\n}\\n        return ans;\\n\\n}\\n}\\n\\ncan anyone help me out? please??"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "nums.size() function does not work, what should i do?"
                    },
                    {
                        "username": "raunak_wick",
                        "content": "use nums.length"
                    },
                    {
                        "username": "chandraparkash421",
                        "content": "java solution\\n `your inline code...your inline code...`\\npublic class Solution {\\n   public int[] searchRange(int[] A, int target) {\\n    int index = binarySearch(A, 0, A.length-1, target);\\n    int[] result = {-1, -1};\\n    if (index != -1) {\\n        int left  = index;\\n        int right = index;\\n        while (left != -1){           \\n            result[0] = left;\\n            left = binarySearch(A, 0, left-1, target);\\n        }\\n        while (right != -1){ \\n            result[1] = right;\\n            right = binarySearch(A, right+1, A.length-1, target);\\n        }\\n    }\\n    return result;\\n}\\n\\nprivate int binarySearch(int[] A, int lo, int hi, int target) {\\n    while (lo <= hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if      (A[mid] < target) lo = mid + 1;\\n        else if (A[mid] > target) hi = mid - 1;\\n        else return mid;            \\n    }\\n    return -1;\\n  }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/34_first_and_last_pos.cpp"
                    },
                    {
                        "username": "anujkumar61",
                        "content": " vector<int>ans= {-1,-1};\\n      int s=0;\\n      int e=nums.size()-1;\\n\\n      while(s<=e){\\n          \\n          int mid =s+(e-s)/2;\\n         \\n         \\n          if(nums[mid] == target && nums[mid] >= 0 ){\\n              ans[0] = mid;\\n              e = mid-1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid -1;\\n          }\\n          \\n      }\\n      \\n    \\n        s = 0;\\n        e = nums.size() - 1;\\n\\n      while(s<=e){\\n          int mid = s+(e-s)/2;\\n\\n          if(nums[mid] == target){\\n              ans[1] = mid;\\n              s = mid+1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid-1;\\n          }\\n      }\\n      return ans;\\n    }\\n\\n\\nI don\\'t know what did i do wrong but only 49/88 testcases are passed \\ncan anyone know?\\n"
                    },
                    {
                        "username": "fardinalam2112",
                        "content": "but we have to do that code in log(n) time if use 2 loop then it will be still in log(n)?\n"
                    },
                    {
                        "username": "Prathvik",
                        "content": "[@anujkumar61](/anujkumar61)  replace \" if(nums[mid]<target) \" with else \" if(nums[mid]<target) \"thats where the error is"
                    },
                    {
                        "username": "anujkumar61",
                        "content": "[@Prathvik](/Prathvik) still getting error after submitting"
                    },
                    {
                        "username": "Prathvik",
                        "content": "remove the && nums[mid]>= 0 condition and it should be fine"
                    },
                    {
                        "username": "sam_chirayu",
                        "content": "Why we need to iterate two times... can\\'t we iterate only one time and if yes then how ???"
                    },
                    {
                        "username": "DURGA_SAI11",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int arr[]=new int[2],j=0;\\n        int flag=0;\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n            for(int i=nums.length-1;i>=0;i--)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n                if(flag==0)\\n                {arr[0]=-1;arr[1]=-1;}\\n            return arr;\\n    }\\n}"
                    },
                    {
                        "username": "user54893210",
                        "content": "Isn\\'t finding length of an array for the right pointer in a binary search o(n) cost?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    }
                ]
            },
            {
                "id": 1716400,
                "content": [
                    {
                        "username": "anirudh9801",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int low =0;\\n        int ans =-1;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n            if(nums[mid]>target){\\n                high=mid-1;\\n            }else if(nums[mid]<target){\\n                low=mid+1;\\n            }else{\\n                if(mid==0){\\n                    return mid;\\n                }else if(nums[mid-1]!=target){\\n                    return mid;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }\\n\\n        }\\n            return ans;\\n\\n    \\n\\n        // int ans=-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n                   if(nums[mid]>target){\\n            high=mid-1;\\n        }else if(nums[mid]<target){\\n            low=mid+1;\\n        }else{\\n            if(mid==high){\\n                return mid;\\n            }else if(nums[mid+1]!=target){\\n                return mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n    \\n    \\n}\\n        return ans;\\n\\n}\\n}\\n\\ncan anyone help me out? please??"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "nums.size() function does not work, what should i do?"
                    },
                    {
                        "username": "raunak_wick",
                        "content": "use nums.length"
                    },
                    {
                        "username": "chandraparkash421",
                        "content": "java solution\\n `your inline code...your inline code...`\\npublic class Solution {\\n   public int[] searchRange(int[] A, int target) {\\n    int index = binarySearch(A, 0, A.length-1, target);\\n    int[] result = {-1, -1};\\n    if (index != -1) {\\n        int left  = index;\\n        int right = index;\\n        while (left != -1){           \\n            result[0] = left;\\n            left = binarySearch(A, 0, left-1, target);\\n        }\\n        while (right != -1){ \\n            result[1] = right;\\n            right = binarySearch(A, right+1, A.length-1, target);\\n        }\\n    }\\n    return result;\\n}\\n\\nprivate int binarySearch(int[] A, int lo, int hi, int target) {\\n    while (lo <= hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if      (A[mid] < target) lo = mid + 1;\\n        else if (A[mid] > target) hi = mid - 1;\\n        else return mid;            \\n    }\\n    return -1;\\n  }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/34_first_and_last_pos.cpp"
                    },
                    {
                        "username": "anujkumar61",
                        "content": " vector<int>ans= {-1,-1};\\n      int s=0;\\n      int e=nums.size()-1;\\n\\n      while(s<=e){\\n          \\n          int mid =s+(e-s)/2;\\n         \\n         \\n          if(nums[mid] == target && nums[mid] >= 0 ){\\n              ans[0] = mid;\\n              e = mid-1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid -1;\\n          }\\n          \\n      }\\n      \\n    \\n        s = 0;\\n        e = nums.size() - 1;\\n\\n      while(s<=e){\\n          int mid = s+(e-s)/2;\\n\\n          if(nums[mid] == target){\\n              ans[1] = mid;\\n              s = mid+1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid-1;\\n          }\\n      }\\n      return ans;\\n    }\\n\\n\\nI don\\'t know what did i do wrong but only 49/88 testcases are passed \\ncan anyone know?\\n"
                    },
                    {
                        "username": "fardinalam2112",
                        "content": "but we have to do that code in log(n) time if use 2 loop then it will be still in log(n)?\n"
                    },
                    {
                        "username": "Prathvik",
                        "content": "[@anujkumar61](/anujkumar61)  replace \" if(nums[mid]<target) \" with else \" if(nums[mid]<target) \"thats where the error is"
                    },
                    {
                        "username": "anujkumar61",
                        "content": "[@Prathvik](/Prathvik) still getting error after submitting"
                    },
                    {
                        "username": "Prathvik",
                        "content": "remove the && nums[mid]>= 0 condition and it should be fine"
                    },
                    {
                        "username": "sam_chirayu",
                        "content": "Why we need to iterate two times... can\\'t we iterate only one time and if yes then how ???"
                    },
                    {
                        "username": "DURGA_SAI11",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int arr[]=new int[2],j=0;\\n        int flag=0;\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n            for(int i=nums.length-1;i>=0;i--)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n                if(flag==0)\\n                {arr[0]=-1;arr[1]=-1;}\\n            return arr;\\n    }\\n}"
                    },
                    {
                        "username": "user54893210",
                        "content": "Isn\\'t finding length of an array for the right pointer in a binary search o(n) cost?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    }
                ]
            },
            {
                "id": 1716051,
                "content": [
                    {
                        "username": "anirudh9801",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int low =0;\\n        int ans =-1;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n            if(nums[mid]>target){\\n                high=mid-1;\\n            }else if(nums[mid]<target){\\n                low=mid+1;\\n            }else{\\n                if(mid==0){\\n                    return mid;\\n                }else if(nums[mid-1]!=target){\\n                    return mid;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }\\n\\n        }\\n            return ans;\\n\\n    \\n\\n        // int ans=-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n                   if(nums[mid]>target){\\n            high=mid-1;\\n        }else if(nums[mid]<target){\\n            low=mid+1;\\n        }else{\\n            if(mid==high){\\n                return mid;\\n            }else if(nums[mid+1]!=target){\\n                return mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n    \\n    \\n}\\n        return ans;\\n\\n}\\n}\\n\\ncan anyone help me out? please??"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "nums.size() function does not work, what should i do?"
                    },
                    {
                        "username": "raunak_wick",
                        "content": "use nums.length"
                    },
                    {
                        "username": "chandraparkash421",
                        "content": "java solution\\n `your inline code...your inline code...`\\npublic class Solution {\\n   public int[] searchRange(int[] A, int target) {\\n    int index = binarySearch(A, 0, A.length-1, target);\\n    int[] result = {-1, -1};\\n    if (index != -1) {\\n        int left  = index;\\n        int right = index;\\n        while (left != -1){           \\n            result[0] = left;\\n            left = binarySearch(A, 0, left-1, target);\\n        }\\n        while (right != -1){ \\n            result[1] = right;\\n            right = binarySearch(A, right+1, A.length-1, target);\\n        }\\n    }\\n    return result;\\n}\\n\\nprivate int binarySearch(int[] A, int lo, int hi, int target) {\\n    while (lo <= hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if      (A[mid] < target) lo = mid + 1;\\n        else if (A[mid] > target) hi = mid - 1;\\n        else return mid;            \\n    }\\n    return -1;\\n  }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/34_first_and_last_pos.cpp"
                    },
                    {
                        "username": "anujkumar61",
                        "content": " vector<int>ans= {-1,-1};\\n      int s=0;\\n      int e=nums.size()-1;\\n\\n      while(s<=e){\\n          \\n          int mid =s+(e-s)/2;\\n         \\n         \\n          if(nums[mid] == target && nums[mid] >= 0 ){\\n              ans[0] = mid;\\n              e = mid-1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid -1;\\n          }\\n          \\n      }\\n      \\n    \\n        s = 0;\\n        e = nums.size() - 1;\\n\\n      while(s<=e){\\n          int mid = s+(e-s)/2;\\n\\n          if(nums[mid] == target){\\n              ans[1] = mid;\\n              s = mid+1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid-1;\\n          }\\n      }\\n      return ans;\\n    }\\n\\n\\nI don\\'t know what did i do wrong but only 49/88 testcases are passed \\ncan anyone know?\\n"
                    },
                    {
                        "username": "fardinalam2112",
                        "content": "but we have to do that code in log(n) time if use 2 loop then it will be still in log(n)?\n"
                    },
                    {
                        "username": "Prathvik",
                        "content": "[@anujkumar61](/anujkumar61)  replace \" if(nums[mid]<target) \" with else \" if(nums[mid]<target) \"thats where the error is"
                    },
                    {
                        "username": "anujkumar61",
                        "content": "[@Prathvik](/Prathvik) still getting error after submitting"
                    },
                    {
                        "username": "Prathvik",
                        "content": "remove the && nums[mid]>= 0 condition and it should be fine"
                    },
                    {
                        "username": "sam_chirayu",
                        "content": "Why we need to iterate two times... can\\'t we iterate only one time and if yes then how ???"
                    },
                    {
                        "username": "DURGA_SAI11",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int arr[]=new int[2],j=0;\\n        int flag=0;\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n            for(int i=nums.length-1;i>=0;i--)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n                if(flag==0)\\n                {arr[0]=-1;arr[1]=-1;}\\n            return arr;\\n    }\\n}"
                    },
                    {
                        "username": "user54893210",
                        "content": "Isn\\'t finding length of an array for the right pointer in a binary search o(n) cost?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    }
                ]
            },
            {
                "id": 1699048,
                "content": [
                    {
                        "username": "anirudh9801",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int low =0;\\n        int ans =-1;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n            if(nums[mid]>target){\\n                high=mid-1;\\n            }else if(nums[mid]<target){\\n                low=mid+1;\\n            }else{\\n                if(mid==0){\\n                    return mid;\\n                }else if(nums[mid-1]!=target){\\n                    return mid;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }\\n\\n        }\\n            return ans;\\n\\n    \\n\\n        // int ans=-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n                   if(nums[mid]>target){\\n            high=mid-1;\\n        }else if(nums[mid]<target){\\n            low=mid+1;\\n        }else{\\n            if(mid==high){\\n                return mid;\\n            }else if(nums[mid+1]!=target){\\n                return mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n    \\n    \\n}\\n        return ans;\\n\\n}\\n}\\n\\ncan anyone help me out? please??"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "nums.size() function does not work, what should i do?"
                    },
                    {
                        "username": "raunak_wick",
                        "content": "use nums.length"
                    },
                    {
                        "username": "chandraparkash421",
                        "content": "java solution\\n `your inline code...your inline code...`\\npublic class Solution {\\n   public int[] searchRange(int[] A, int target) {\\n    int index = binarySearch(A, 0, A.length-1, target);\\n    int[] result = {-1, -1};\\n    if (index != -1) {\\n        int left  = index;\\n        int right = index;\\n        while (left != -1){           \\n            result[0] = left;\\n            left = binarySearch(A, 0, left-1, target);\\n        }\\n        while (right != -1){ \\n            result[1] = right;\\n            right = binarySearch(A, right+1, A.length-1, target);\\n        }\\n    }\\n    return result;\\n}\\n\\nprivate int binarySearch(int[] A, int lo, int hi, int target) {\\n    while (lo <= hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if      (A[mid] < target) lo = mid + 1;\\n        else if (A[mid] > target) hi = mid - 1;\\n        else return mid;            \\n    }\\n    return -1;\\n  }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/34_first_and_last_pos.cpp"
                    },
                    {
                        "username": "anujkumar61",
                        "content": " vector<int>ans= {-1,-1};\\n      int s=0;\\n      int e=nums.size()-1;\\n\\n      while(s<=e){\\n          \\n          int mid =s+(e-s)/2;\\n         \\n         \\n          if(nums[mid] == target && nums[mid] >= 0 ){\\n              ans[0] = mid;\\n              e = mid-1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid -1;\\n          }\\n          \\n      }\\n      \\n    \\n        s = 0;\\n        e = nums.size() - 1;\\n\\n      while(s<=e){\\n          int mid = s+(e-s)/2;\\n\\n          if(nums[mid] == target){\\n              ans[1] = mid;\\n              s = mid+1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid-1;\\n          }\\n      }\\n      return ans;\\n    }\\n\\n\\nI don\\'t know what did i do wrong but only 49/88 testcases are passed \\ncan anyone know?\\n"
                    },
                    {
                        "username": "fardinalam2112",
                        "content": "but we have to do that code in log(n) time if use 2 loop then it will be still in log(n)?\n"
                    },
                    {
                        "username": "Prathvik",
                        "content": "[@anujkumar61](/anujkumar61)  replace \" if(nums[mid]<target) \" with else \" if(nums[mid]<target) \"thats where the error is"
                    },
                    {
                        "username": "anujkumar61",
                        "content": "[@Prathvik](/Prathvik) still getting error after submitting"
                    },
                    {
                        "username": "Prathvik",
                        "content": "remove the && nums[mid]>= 0 condition and it should be fine"
                    },
                    {
                        "username": "sam_chirayu",
                        "content": "Why we need to iterate two times... can\\'t we iterate only one time and if yes then how ???"
                    },
                    {
                        "username": "DURGA_SAI11",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int arr[]=new int[2],j=0;\\n        int flag=0;\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n            for(int i=nums.length-1;i>=0;i--)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n                if(flag==0)\\n                {arr[0]=-1;arr[1]=-1;}\\n            return arr;\\n    }\\n}"
                    },
                    {
                        "username": "user54893210",
                        "content": "Isn\\'t finding length of an array for the right pointer in a binary search o(n) cost?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    }
                ]
            },
            {
                "id": 1685644,
                "content": [
                    {
                        "username": "anirudh9801",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int low =0;\\n        int ans =-1;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n            if(nums[mid]>target){\\n                high=mid-1;\\n            }else if(nums[mid]<target){\\n                low=mid+1;\\n            }else{\\n                if(mid==0){\\n                    return mid;\\n                }else if(nums[mid-1]!=target){\\n                    return mid;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }\\n\\n        }\\n            return ans;\\n\\n    \\n\\n        // int ans=-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n                   if(nums[mid]>target){\\n            high=mid-1;\\n        }else if(nums[mid]<target){\\n            low=mid+1;\\n        }else{\\n            if(mid==high){\\n                return mid;\\n            }else if(nums[mid+1]!=target){\\n                return mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n    \\n    \\n}\\n        return ans;\\n\\n}\\n}\\n\\ncan anyone help me out? please??"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "nums.size() function does not work, what should i do?"
                    },
                    {
                        "username": "raunak_wick",
                        "content": "use nums.length"
                    },
                    {
                        "username": "chandraparkash421",
                        "content": "java solution\\n `your inline code...your inline code...`\\npublic class Solution {\\n   public int[] searchRange(int[] A, int target) {\\n    int index = binarySearch(A, 0, A.length-1, target);\\n    int[] result = {-1, -1};\\n    if (index != -1) {\\n        int left  = index;\\n        int right = index;\\n        while (left != -1){           \\n            result[0] = left;\\n            left = binarySearch(A, 0, left-1, target);\\n        }\\n        while (right != -1){ \\n            result[1] = right;\\n            right = binarySearch(A, right+1, A.length-1, target);\\n        }\\n    }\\n    return result;\\n}\\n\\nprivate int binarySearch(int[] A, int lo, int hi, int target) {\\n    while (lo <= hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if      (A[mid] < target) lo = mid + 1;\\n        else if (A[mid] > target) hi = mid - 1;\\n        else return mid;            \\n    }\\n    return -1;\\n  }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/34_first_and_last_pos.cpp"
                    },
                    {
                        "username": "anujkumar61",
                        "content": " vector<int>ans= {-1,-1};\\n      int s=0;\\n      int e=nums.size()-1;\\n\\n      while(s<=e){\\n          \\n          int mid =s+(e-s)/2;\\n         \\n         \\n          if(nums[mid] == target && nums[mid] >= 0 ){\\n              ans[0] = mid;\\n              e = mid-1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid -1;\\n          }\\n          \\n      }\\n      \\n    \\n        s = 0;\\n        e = nums.size() - 1;\\n\\n      while(s<=e){\\n          int mid = s+(e-s)/2;\\n\\n          if(nums[mid] == target){\\n              ans[1] = mid;\\n              s = mid+1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid-1;\\n          }\\n      }\\n      return ans;\\n    }\\n\\n\\nI don\\'t know what did i do wrong but only 49/88 testcases are passed \\ncan anyone know?\\n"
                    },
                    {
                        "username": "fardinalam2112",
                        "content": "but we have to do that code in log(n) time if use 2 loop then it will be still in log(n)?\n"
                    },
                    {
                        "username": "Prathvik",
                        "content": "[@anujkumar61](/anujkumar61)  replace \" if(nums[mid]<target) \" with else \" if(nums[mid]<target) \"thats where the error is"
                    },
                    {
                        "username": "anujkumar61",
                        "content": "[@Prathvik](/Prathvik) still getting error after submitting"
                    },
                    {
                        "username": "Prathvik",
                        "content": "remove the && nums[mid]>= 0 condition and it should be fine"
                    },
                    {
                        "username": "sam_chirayu",
                        "content": "Why we need to iterate two times... can\\'t we iterate only one time and if yes then how ???"
                    },
                    {
                        "username": "DURGA_SAI11",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int arr[]=new int[2],j=0;\\n        int flag=0;\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n            for(int i=nums.length-1;i>=0;i--)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n                if(flag==0)\\n                {arr[0]=-1;arr[1]=-1;}\\n            return arr;\\n    }\\n}"
                    },
                    {
                        "username": "user54893210",
                        "content": "Isn\\'t finding length of an array for the right pointer in a binary search o(n) cost?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Gas Station",
        "question_content": "<p>There are <code>n</code> gas stations along a circular route, where the amount of gas at the <code>i<sup>th</sup></code> station is <code>gas[i]</code>.</p>\n\n<p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from the <code>i<sup>th</sup></code> station to its next <code>(i + 1)<sup>th</sup></code> station. You begin the journey with an empty tank at one of the gas stations.</p>\n\n<p>Given two integer arrays <code>gas</code> and <code>cost</code>, return <em>the starting gas station&#39;s index if you can travel around the circuit once in the clockwise direction, otherwise return</em> <code>-1</code>. If there exists a solution, it is <strong>guaranteed</strong> to be <strong>unique</strong></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> gas = [1,2,3,4,5], cost = [3,4,5,1,2]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> gas = [2,3,4], cost = [3,4,3]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong>\nYou can&#39;t start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet&#39;s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can&#39;t travel around the circuit once no matter where you start.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == gas.length == cost.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= gas[i], cost[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1706142,
                "title": "java-c-python-an-explanation-that-ever-exists-till-now",
                "content": "**First Understand the problem :**\\n\\n>We have a car with an unlimited gas tank. We are given an array of gas and an array of costs. Each index in the gas array represents the amount of gas available to fill up your car with. Each index in the cost array represents the amount of gas that will be used when travelling from this gas station to next. \\n>>Our goal is to determine wether it is possible to start at any of the gas stations and complete one trip around.\\n>>>If it is, we need to return the index of that starting gas station, if no such gas station exists then we return -1.\\n\\nLet\\'s understand with an example : We have an **input of gas = [7, 1, 0, 11, 4] & cost = [5, 9, 1, 2, 5]**\\n\\n![image](https://assets.leetcode.com/users/images/494f2123-8fcc-455a-8a67-0968223ba270_1642736908.3527038.png)\\n\\n\\nSo, we have **5 gas station** each with the amount of gas value which the amount of gas they can give to your car. Then we have road connecting them which would have a corresponding amount of gas which would be use when your cars travelling. \\n\\n* So, we start at **1st gas station** with **7 unit of gas**, then make a trip to **2nd gas station** costing **5 unit of gas** which means we have now **2 unit\\'s left** in our tank.\\n* Upon arriving on next gas station we have given **1 unit of gas** so we have now **3 units**.\\n* Now we attempt to make a trip to next gas station. However since this trip requires **9 unit of gas**, but we only have **3 in the tank** we run out of gas. So, this means we can start at **gas station at \"0\"** and make a full trip.\\n\\n![image](https://assets.leetcode.com/users/images/a713145b-d63d-4613-b7ba-a589699daadc_1642737420.2182224.png)\\n\\n* Now lets say we started at **index 3** gas station which gives us **11 units** to start.\\n* Upon travelling to the next gas station we use **2 units of gas**, but we also get **4 units of gas** upon leaving us with **13 unit of gas** in our tank.\\n* Now we loop back around and travel back to **0th index** which uses **5 unit of gas,** but we also get refilled of **7 unit of gas** leaving us tank with total of **15**.\\n* On the next jump, we use **5 unit of gas** and **refuel** for **1** leaving us with **11 unit**.\\n* On the next jump we use **9 unit of gas**, but we **dont get refuell at all**\\n* On last trip we use **1 unit of gas**, which leave our tank left with **1 unit of gas**\\n\\n![image](https://assets.leetcode.com/users/images/052a8134-f32c-457b-997e-0642798ae5e9_1642743874.4318752.png)\\n![image](https://assets.leetcode.com/users/images/b35476a1-f7bf-4804-adc6-c02290888cac_1642743965.466837.png)\\n![image](https://assets.leetcode.com/users/images/755c9e78-44f3-420c-830a-b2925e76aa66_1642744065.3088975.png)\\n\\n\\n\\n>>So, now we know if we start at **index 3** gas station will be able to complete the whole round trip.\\n\\n**Let\\'s see it Brute Force Solution :**\\n```\\n{\\n        int n = gas.length;\\n        for(int i = 0; i < n; i++){\\n            int totalFuel = 0;\\n            int stopCount = 0, j = i;\\n            while(stopCount < n){\\n                totalFuel += gas[j % n] - cost[j % n];\\n                if(totalFuel < 0) break; // whenever we reach -ve\\n                stopCount++;\\n                j++;\\n            }\\n            if(stopCount == n && totalFuel >= 0) return i; // cover all the stops & our fuel left is 0 or more than that\\n        }\\n        return -1;\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N^2)\\n\\n* **Space Complexity :-** BigO(1)\\n\\n<hr>\\n<hr>\\n\\n>Let\\'s **Improve this solution** which runs linear in **O(N) time**.\\n>>As Inorder to improve the solution we have to look into where it\\'s wasting time\\n\\nSo, our **brute-force** ran a simulation, as soon as a gas station became **-ve**. It\\'s stop and move to the next station as a starting point. But this is inefficient and inorder for us to understand why? we have to look at what makes car stop.\\nLet\\'s say for this example the **car start at 0** and it\\'s able to make at **3** gas station. And after trying to make it at **4th station** its run out of gas.\\n![image](https://assets.leetcode.com/users/images/bc1d1e8d-66e1-4232-88a6-50ee630652bd_1642739783.4066157.png)\\n\\nOnce the brute force solution realises it can make this trip, it\\'s start over simulating with this gas station as the starting point.\\nBut this next simulation is **useless and wasting time**\\n\\n**Here\\'s why,** \\n![image](https://assets.leetcode.com/users/images/201c0770-bc89-4e1c-8a76-d0af270d86fa_1642740255.742468.png)\\nWell we already know that these **3 gas stations** and trips **weren\\'t successfull**. Which means comparing our fuel accumulation to our fuel consumption we were at some kind of **surplus** or at the very least we were breaking even with exactly enough fuel to make every trip.\\n\\nThis is because if we were at some kind of deficit then our car would have already run on gas sometime earlier. So, this means on the last trip because we ran out of fuel we were in some kind of deficit.\\nSo, as we can\\'t make the trip **starting at very beginning we can\\'t make over here at index 1 or index 2 or index 3**\\n\\nSo what does this means in terms of our algorithm, it means that we know if we run out of fuel say at some `ith` gas station. All the gas station between `ith and starting point` are bad starting point as well. \\nSo, this means we can start trying at next gas station on the `i + 1` station. So, hopefully now you understand how this **O(N) solution** will takes place.\\n\\n**Let\\'s code it up:**\\n\\n*code line explained :* `similar for C++, Java, Python` **{Only syntax Difference}** approach same\\n```\\n{\\n        int n = gas.length;\\n        int total_surplus = 0; // it will give us a difference b/w gas & cost\\n        int surplus = 0; // our tank\\n        int start = 0; // and the index of gas station\\n        \\n        for(int i = 0; i < n; i++){\\n            total_surplus += gas[i] - cost[i];\\n            surplus += gas[i] - cost[i];\\n            if(surplus < 0){ // if the tank goes -ve\\n                surplus = 0; // reset our tank\\n                start = i + 1; // and update the stating gas station\\n            }\\n        }\\n        return (total_surplus < 0) ? -1 : start;\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int n = gas.length;\\n        int total_surplus = 0;\\n        int surplus = 0;\\n        int start = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            total_surplus += gas[i] - cost[i];\\n            surplus += gas[i] - cost[i];\\n            if(surplus < 0){\\n                surplus = 0;\\n                start = i + 1;\\n            }\\n        }\\n        return (total_surplus < 0) ? -1 : start;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size();\\n        int total_surplus = 0;\\n        int surplus = 0;\\n        int start = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            total_surplus += gas[i] - cost[i];\\n            surplus += gas[i] - cost[i];\\n            if(surplus < 0){\\n                surplus = 0;\\n                start = i + 1;\\n            }\\n        }\\n        return (total_surplus < 0) ? -1 : start;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        n, total_surplus, surplus, start = len(gas), 0, 0, 0\\n        \\n        for i in range(n):\\n            total_surplus += gas[i] - cost[i]\\n            surplus += gas[i] - cost[i]\\n            if surplus < 0:\\n                surplus = 0\\n                start = i + 1\\n        return -1 if (total_surplus < 0) else start\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(1)",
                "solutionTags": [],
                "code": "```\\n{\\n        int n = gas.length;\\n        for(int i = 0; i < n; i++){\\n            int totalFuel = 0;\\n            int stopCount = 0, j = i;\\n            while(stopCount < n){\\n                totalFuel += gas[j % n] - cost[j % n];\\n                if(totalFuel < 0) break; // whenever we reach -ve\\n                stopCount++;\\n                j++;\\n            }\\n            if(stopCount == n && totalFuel >= 0) return i; // cover all the stops & our fuel left is 0 or more than that\\n        }\\n        return -1;\\n```\n```\\n{\\n        int n = gas.length;\\n        int total_surplus = 0; // it will give us a difference b/w gas & cost\\n        int surplus = 0; // our tank\\n        int start = 0; // and the index of gas station\\n        \\n        for(int i = 0; i < n; i++){\\n            total_surplus += gas[i] - cost[i];\\n            surplus += gas[i] - cost[i];\\n            if(surplus < 0){ // if the tank goes -ve\\n                surplus = 0; // reset our tank\\n                start = i + 1; // and update the stating gas station\\n            }\\n        }\\n        return (total_surplus < 0) ? -1 : start;\\n```\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int n = gas.length;\\n        int total_surplus = 0;\\n        int surplus = 0;\\n        int start = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            total_surplus += gas[i] - cost[i];\\n            surplus += gas[i] - cost[i];\\n            if(surplus < 0){\\n                surplus = 0;\\n                start = i + 1;\\n            }\\n        }\\n        return (total_surplus < 0) ? -1 : start;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size();\\n        int total_surplus = 0;\\n        int surplus = 0;\\n        int start = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            total_surplus += gas[i] - cost[i];\\n            surplus += gas[i] - cost[i];\\n            if(surplus < 0){\\n                surplus = 0;\\n                start = i + 1;\\n            }\\n        }\\n        return (total_surplus < 0) ? -1 : start;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        n, total_surplus, surplus, start = len(gas), 0, 0, 0\\n        \\n        for i in range(n):\\n            total_surplus += gas[i] - cost[i]\\n            surplus += gas[i] - cost[i]\\n            if surplus < 0:\\n                surplus = 0\\n                start = i + 1\\n        return -1 if (total_surplus < 0) else start\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42568,
                "title": "share-some-of-my-ideas",
                "content": "I have thought for a long time and got two ideas:\\n\\n - If car starts at A and can not reach B. Any station between A and B \\n    can not reach B.(B is the first station that A can not reach.)\\n - If the total number of gas is bigger than the total number of cost. There must be a solution. \\n - (Should I prove them?)\\n\\nHere is my solution based on those ideas:\\n\\n    class Solution {\\n    public:\\n        int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {\\n            int start(0),total(0),tank(0);\\n            //if car fails at 'start', record the next station\\n            for(int i=0;i<gas.size();i++) if((tank=tank+gas[i]-cost[i])<0) {start=i+1;total+=tank;tank=0;}\\n            return (total+tank<0)? -1:start;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {\\n            int start(0),total(0),tank(0);\\n            //if car fails at 'start', record the next station\\n            for(int i=0;i<gas.size();i++) if((tank=tank+gas[i]-cost[i])<0) {start=i+1;total+=tank;tank=0;}",
                "codeTag": "Java"
            },
            {
                "id": 3011141,
                "title": "c-easy-solution-with-explaination-in-o-n-time-complexity-beats-97",
                "content": "\\uD83C\\uDFA5\\uD83D\\uDD25 Exciting News! Join my Coding Journey! Subscribe Now! \\uD83D\\uDD25\\uD83C\\uDFA5\\n\\n\\uD83D\\uDD17 Link in the leetcode profile \\n\\nNew coding channel alert! \\uD83D\\uDE80\\uD83D\\uDCBB Subscribe to unlock amazing coding content and tutorials. Help me reach 1K subs to start posting more videos! Join now! \\uD83C\\uDF1F\\uD83D\\uDCAA\\n\\nThanks for your support! \\uD83D\\uDE4F\\n# Intuition\\nHere we will apply greedy approach\\n\\n# Approach\\nIn the question given that\\n**If there exists a solution, it is guaranteed to be unique**\\n-This lines clearly tells us that we have unique or no solution exists\\n\\n*Here two cases are possible*\\n1. if our **total_gas is less than our total cost** in that case we can\\'t complete our journey ,so will return -1\\n2. Now we have a unique solution that means single **starting_point** exists\\n3. To find that point we will **keep track of my current_gas+=gas[i]-cost[i]**\\n  - lets suppose at any index our current gas became negative so we can clearly say that till that index all the gas station between ith and starting point are bad,  starting point as well.\\nSo, this means we can start trying at next gas_station on the i+1 station\\n\\n# Complexity\\n- Time complexity:O(N)\\n- Space complexity:O(1)\\n\\n# Code(C++)\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        int total_gas=0,total_cost=0;\\n        int curr_gas=0, starting_point=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            //these two variable are to check if no case is possible\\n            total_gas+=gas[i];\\n            total_cost+=cost[i];\\n            //for checking the total present gas at index i\\n            curr_gas+=gas[i]-cost[i];\\n            if(curr_gas<0)\\n            {\\n               //there is a breakdown....so we will start from next point or index\\n                starting_point=i+1;\\n                //reset our fuel \\n                curr_gas=0;\\n            }\\n        }\\n        return (total_gas<total_cost)?-1:starting_point;     \\n    }\\n};\\n```\\nIf you really found my solution helpful **please upvote it**, as it motivates me to post such kind of codes.\\nLets connect on [Linkdin](https://www.linkedin.com/in/mahesh-vishnoi-a4a47a193/) Or [Telegram](https://t.me/mahesh_vishnoi29)\\n",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        int total_gas=0,total_cost=0;\\n        int curr_gas=0, starting_point=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            //these two variable are to check if no case is possible\\n            total_gas+=gas[i];\\n            total_cost+=cost[i];\\n            //for checking the total present gas at index i\\n            curr_gas+=gas[i]-cost[i];\\n            if(curr_gas<0)\\n            {\\n               //there is a breakdown....so we will start from next point or index\\n                starting_point=i+1;\\n                //reset our fuel \\n                curr_gas=0;\\n            }\\n        }\\n        return (total_gas<total_cost)?-1:starting_point;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42565,
                "title": "my-ac-is-o-1-space-o-n-running-time-solution-does-anybody-have-posted-this-solution",
                "content": "I have got one solution to this problem. I am not sure whether somebody has already posted this solution.\\n\\n    class Solution {\\n    public:\\n        int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {\\n    \\n           int start = gas.size()-1;\\n           int end = 0;\\n           int sum = gas[start] - cost[start];\\n           while (start > end) {\\n              if (sum >= 0) {\\n                 sum += gas[end] - cost[end];\\n                 ++end;\\n              }\\n              else {\\n                 --start;\\n                 sum += gas[start] - cost[start];\\n              }\\n           }\\n           return sum >= 0 ? start : -1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {\\n    \\n           int start = gas.size()-1;\\n           int end = 0;\\n           int sum = gas[start] - cost[start];\\n           while (start > end) {\\n              if (sum >= 0) {\\n                 sum += gas[end] - cost[end];\\n                 ++end;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 42572,
                "title": "proof-of-if-total-gas-is-greater-than-total-cost-there-is-a-solution-c",
                "content": "We prove the following statement. \\nIf sum of all `gas[i]-cost[i]` is greater than or equal to `0`, then there is a start position you can travel the whole circle. \\nLet `i` be the index such that the the partial sum \\n\\n    gas[0]-cost[0]+gas[1]-cost[1]+...+gas[i]-cost[i]\\n\\nis the smallest, then the start position should be `start=i+1` ( `start=0` if `i=n-1`). Consider any other partial sum, for example,\\n\\n    gas[0]-cost[0]+gas[1]-cost[1]+...+gas[i]-cost[i]+gas[i+1]-cost[i+1]\\n\\nSince `gas[0]-cost[0]+gas[1]-cost[1]+...+gas[i]-cost[i]` is the smallest, we must have \\n\\n    gas[i+1]-cost[i+1]>=0\\n\\nin order for `gas[0]-cost[0]+gas[1]-cost[1]+...+gas[i]-cost[i]+gas[i+1]-cost[i+1]` to be greater.\\nThe same reasoning gives that \\n\\n     gas[i+1]-cost[i+1]>=0\\n     gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]>=0\\n     .......\\n     gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]+...+gas[n-1]-cost[n-1]>=0\\nWhat about for the partial sums that wraps around? (\"wraps around\" means from `i+1,i+2,...` to `n-1` then back to `0,1,2,...`).\\n\\n    gas[0]-cost[0]+gas[1]-cost[1]+...+gas[j]-cost[j] + gas[i+1]-cost[i+1]+...+gas[n-1]-cost[n-1]\\n    >=\\n    gas[0]-cost[0]+gas[1]-cost[1]+...+gas[i]-cost[i] + gas[i+1]-cost[i+1]+...+gas[n-1]-cost[n-1]\\n    >=0\\n`j` is some index, `0<=j<=i`.\\nThe first inequality is due to the assumption that ` gas[0]-cost[0]+gas[1]-cost[1]+...+gas[i]-cost[i]` is the smallest.\\nThe last inequality is due to the assumption that the entire sum of `gas[k]-cost[k]` for `k` from `0` to `n-1` is greater than or equal to 0.\\nSo we have that all the partial sums starting from `i+1` is non-negative:\\n\\n    gas[i+1]-cost[i+1]>=0,\\n    gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]>=0,\\n    gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]+...+gas[n-1]-cost[n-1]>=0,\\n    ...\\n    gas[i+1]-cost[i+1]+...+gas[n-1]-cost[n-1] + gas[0]-cost[0]+gas[1]-cost[1]+...+gas[j]-cost[j]>=0,\\n    ...\\nThus `i+1` is the position to start. Coding using this reasoning is as follows:\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size();\\n        int total(0), subsum(INT_MAX), start(0);\\n        for (int i = 0; i < n; ++i) {\\n            total += gas[i] - cost[i];\\n            if (total <= subsum) {\\n                subsum = total;\\n                start = i + 1;\\n            }\\n        }\\n        return (total < 0) ? -1 : (start % n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size();\\n        int total(0), subsum(INT_MAX), start(0);\\n        for (int i = 0; i < n; ++i) {\\n            total += gas[i] - cost[i];\\n            if (total <= subsum) {\\n                subsum = total;\\n                start = i + 1;\\n            }\\n        }\\n        return (total < 0) ? -1 : (start % n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237895,
                "title": "easy-c-solution-in-o-n-time-complexity",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) \\n    {\\n        // first of all we need to check whether we\\'ve sfficient fuel or not. \\n        int total_cost=0,total_fuel=0,n=cost.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            total_cost+=cost[i];\\n            total_fuel+=gas[i];\\n        }\\n        // If the total fuel is lesser than the cost then definitely we can\\'t cover the whole cicular tour.\\n        if(total_fuel<total_cost)\\n        {\\n            return -1;\\n        }\\n        \\n        \\n        // If the total fuel is sufficient enough to cover the circular tour then definitely an answer exists\\n        int curr_fuel=0,start=0;  // start with zero fuel.\\n        for(int i=0;i<n;i++)\\n        {\\n            // If at any point our balance/ current fuel is negative that means we can\\'t come to the i\\'th petrol pump from the previous pump beacuse our fuel won\\'t allow us to cover such distance. \\n            //So we\\'ll make the i\\'th pump as the start point ans proceed. Simultaneously we\\'ll make the current fuel to be 0 as we\\'re starting freshly.\\n            if(curr_fuel<0)\\n            {\\n                start=i;\\n                curr_fuel=0;\\n            }\\n            // at any station we\\'ll fill petrol and pay the cost to go to the next station . so current fuel would be the following.\\n            curr_fuel+=(gas[i]-cost[i]);\\n        }\\n        return start;\\n    }\\n};\\n```\\n**Now you might be wondering even after reaching the end of the array why we are not making any circular tour and after reaching the end we\\'re concluding the result. The main concept is that :-\\nLet\\'s suppose we start at the 0\\'th pump moving on and at the middle we\\'ve negative fuel so we\\'ll restart our journey from the middle position. Now let\\'s suppose after reaching the end  we\\'ve some fuel in our tank. We\\'re saying that the middle position will be the starting position. But why we\\'re not going back to the middle element ( from where we\\'ve started our journey) from the end to just check whether it\\'s possible to make circular tour or not? It\\'s because we\\'ve already checked previously that it\\'s possible to come from the 0\\'th index to the middle. So no need to check for the remainig part of the circular tour since it will always be a valid tour.**\\n\\n***Please  upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) \\n    {\\n        // first of all we need to check whether we\\'ve sfficient fuel or not. \\n        int total_cost=0,total_fuel=0,n=cost.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            total_cost+=cost[i];\\n            total_fuel+=gas[i];\\n        }\\n        // If the total fuel is lesser than the cost then definitely we can\\'t cover the whole cicular tour.\\n        if(total_fuel<total_cost)\\n        {\\n            return -1;\\n        }\\n        \\n        \\n        // If the total fuel is sufficient enough to cover the circular tour then definitely an answer exists\\n        int curr_fuel=0,start=0;  // start with zero fuel.\\n        for(int i=0;i<n;i++)\\n        {\\n            // If at any point our balance/ current fuel is negative that means we can\\'t come to the i\\'th petrol pump from the previous pump beacuse our fuel won\\'t allow us to cover such distance. \\n            //So we\\'ll make the i\\'th pump as the start point ans proceed. Simultaneously we\\'ll make the current fuel to be 0 as we\\'re starting freshly.\\n            if(curr_fuel<0)\\n            {\\n                start=i;\\n                curr_fuel=0;\\n            }\\n            // at any station we\\'ll fill petrol and pay the cost to go to the next station . so current fuel would be the following.\\n            curr_fuel+=(gas[i]-cost[i]);\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012336,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int n = cost.size(), bal = 0, start = 0, deficit = 0;\\n\\n        for(int i = 0; i< n; i++){\\n            bal += gas[i] - cost[i];\\n\\n            if(bal < 0){\\n\\n                deficit += bal;\\n                start = i+1;\\n                bal = 0;\\n            }\\n        }\\n        return bal + deficit >= 0 ? start : -1;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if sum(gas) < sum(cost): return -1\\n        tank = idx = 0\\n        for i in range(len(gas)):\\n            tank+= gas[i]-cost[i] \\n            if tank < 0: tank, idx = 0, i+1\\n        return idx \\n\\n        print(f\"cost: {cost}\")\\n        print(f\"gas: {gas}\")\\n        tank = 0\\n        for i in range(len(cost)):\\n            # find where we can start\\n            if cost[i] > gas[i]+tank:\\n                continue\\n            start = i    \\n            tank += gas[i]\\n            print(\"tank\", tank)\\n            for j in range(start+1, len(cost)):\\n                if cost[i] > gas[i]:\\n                    print(\"inside\", j)\\n        return -1\\n```\\n\\n```Java []\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int sGas = 0, sCost = 0, res = 0, total = 0;\\n        for (int i = 0; i < gas.length; i++) {\\n            sGas += gas[i];\\n            sCost += cost[i];\\n        }\\n        if (sGas < sCost) return -1;\\n        for (int i = 0; i < gas.length; i++) {\\n            total += gas[i] - cost[i];\\n            if (total < 0) {\\n                total = 0;\\n                res = i + 1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int n = cost.size(), bal = 0, start = 0, deficit = 0;\\n\\n        for(int i = 0; i< n; i++){\\n            bal += gas[i] - cost[i];\\n\\n            if(bal < 0){\\n\\n                deficit += bal;\\n                start = i+1;\\n                bal = 0;\\n            }\\n        }\\n        return bal + deficit >= 0 ? start : -1;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if sum(gas) < sum(cost): return -1\\n        tank = idx = 0\\n        for i in range(len(gas)):\\n            tank+= gas[i]-cost[i] \\n            if tank < 0: tank, idx = 0, i+1\\n        return idx \\n\\n        print(f\"cost: {cost}\")\\n        print(f\"gas: {gas}\")\\n        tank = 0\\n        for i in range(len(cost)):\\n            # find where we can start\\n            if cost[i] > gas[i]+tank:\\n                continue\\n            start = i    \\n            tank += gas[i]\\n            print(\"tank\", tank)\\n            for j in range(start+1, len(cost)):\\n                if cost[i] > gas[i]:\\n                    print(\"inside\", j)\\n        return -1\\n```\n```Java []\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int sGas = 0, sCost = 0, res = 0, total = 0;\\n        for (int i = 0; i < gas.length; i++) {\\n            sGas += gas[i];\\n            sCost += cost[i];\\n        }\\n        if (sGas < sCost) return -1;\\n        for (int i = 0; i < gas.length; i++) {\\n            total += gas[i] - cost[i];\\n            if (total < 0) {\\n                total = 0;\\n                res = i + 1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42648,
                "title": "my-one-pass-solution",
                "content": "    class Solution {\\n    public:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int size=gas.size();\\n        int sum=0;\\n        int res=0;\\n        int total=0;\\n        for(int i=0; i<size; ++i){\\n            sum+=gas[i]-cost[i];\\n            if(sum<0){\\n                total+=sum;\\n                sum=0;\\n                res=i+1;\\n            }\\n        }\\n        total+=sum;\\n        return total<0?-1:res;\\n    }};\\n\\nThe idea is simple. \\n\\n 1. Whenever the sum is negative, reset it and let the car start from next point. \\n 2. In the mean time, add up all of the left gas to total. If it's negative finally, return -1 since it's impossible to finish.\\n 3.  If it's non-negative, return the last point saved in res;",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int size=gas.size();\\n        int sum=0;\\n        int res=0;\\n        int total=0;\\n        for(int i=0; i<size; ++i){\\n            sum+=gas[i]-cost[i];\\n            if(sum<0){\\n                total+=sum;\\n                sum=0;\\n                res=i+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3011456,
                "title": "java-solution-with-explanation",
                "content": "\\n\\n# Approach and Explantation\\n1. The function takes in two arrays: gas and cost, where $$gas[i]$$ represents the amount of gas available at the i-th gas station, and $$cost[i]$$ represents the amount of gas needed to travel from the i-th gas station to the next one.\\n\\n2. The function first calculates the total amount of gas available at all the gas stations (totalGas) and the total amount of gas needed to travel around all the gas stations (totalCost). If totalGas is less than totalCost, it means that it is not possible to travel around all the gas stations, so the function returns -1.\\n\\n3. Next, the function starts at the first gas station $$(start = 0)$$ and iterates through the gas stations. At each iteration, it calculates the remaining gas after visiting the current gas station (remainsGas) and adding the gas available at that station $$(gas[i])$$ and subtracting the gas needed to travel to the next gas station $$(cost[i])$$. If remainsGas becomes negative at any point, it means that it is not possible to travel from the current gas station to the next one without running out of gas. In this case, the function sets the starting gas station to the next one $$(start = i+1)$$ and resets the remaining gas to 0 $$(remainsGas = 0)$$.\\n\\n4. Finally, the function returns the starting gas station that allows the travel around all the gas stations.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\n  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        // Initialize totalGas and totalCost to 0\\n        int totalGas = 0, totalCost = 0;\\n        // Iterate through all the gas stations\\n        for(int i = 0 ; i<gas.length; i++){\\n            // Add the gas and cost at each station to the total\\n            totalGas += gas[i];\\n            totalCost += cost[i];\\n        }\\n        // If totalCost is greater than totalGas, it is not possible to complete the circuit\\n        if(totalGas < totalCost) return -1;\\n        \\n        // Initialize remainsGas and start to 0\\n        int remainsGas = 0, start = 0;\\n        // Iterate through all the gas stations\\n        for(int i = 0 ; i < gas.length; i++){\\n            // Add the difference between gas and cost at each station to remainsGas\\n            remainsGas = remainsGas +(gas[i] - cost[i]);\\n            // If remainsGas becomes negative, set start to the next station and reset remainsGas to 0\\n            if(remainsGas < 0 ){\\n                start = i+1;\\n                remainsGas = 0;\\n            }\\n        }\\n        // Return the starting station\\n        return start;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        // Initialize totalGas and totalCost to 0\\n        int totalGas = 0, totalCost = 0;\\n        // Iterate through all the gas stations\\n        for(int i = 0 ; i<gas.length; i++){\\n            // Add the gas and cost at each station to the total\\n            totalGas += gas[i];\\n            totalCost += cost[i];\\n        }\\n        // If totalCost is greater than totalGas, it is not possible to complete the circuit\\n        if(totalGas < totalCost) return -1;\\n        \\n        // Initialize remainsGas and start to 0\\n        int remainsGas = 0, start = 0;\\n        // Iterate through all the gas stations\\n        for(int i = 0 ; i < gas.length; i++){\\n            // Add the difference between gas and cost at each station to remainsGas\\n            remainsGas = remainsGas +(gas[i] - cost[i]);\\n            // If remainsGas becomes negative, set start to the next station and reset remainsGas to 0\\n            if(remainsGas < 0 ){\\n                start = i+1;\\n                remainsGas = 0;\\n            }\\n        }\\n        // Return the starting station\\n        return start;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004074,
                "title": "greedy-method-explanation-visual-python",
                "content": "***TL;DR  (explanation + visual below code snippet)***\\n\\nAt each stage we always select the ***best*** starting point, the ***best*** starting point is the starting point that can ***get the car to the next station***.  if the car can aways get to the next station, then **surely*** the car will complete the circuit if it is possilbe.  \\n\\n***Note:*** We can get to the next station only if we have enough gas to do so (```gas[i] - cost[i]```). \\n\\n```python\\ndef canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n\\ttrip_tank, curr_tank, start, n = 0, 0, 0, len(gas)\\n\\tfor i in range(n):\\n\\t\\ttrip_tank += gas[i] - cost[i]\\n\\t\\tcurr_tank += gas[i] - cost[i]\\n\\t\\tif curr_tank < 0:\\n\\t\\t\\tstart = i + 1\\n\\t\\t\\tcurr_tank = 0 \\n\\treturn start if trip_tank >= 0 else -1\\n```\\n### Overview \\n***Problem:*** a circular road connects all  gas stations. with the freedom to start from any station, find the starting station from which the car can complete the circuit (visit all stations in a clockwise). The gas tank has no limit to the amount it can hold.\\n\\ngiven the gas availible at each station and the costs to get from one station to the next, find the starting point from which the car can complete the circuit. if a solution exists it is guaranteed to be unique.\\n\\n* * * \\n### Why Greedy?\\n* * * \\n\\nin mathematics and computer science an ***optimization problem*** is defined as a problem where the goal is to find the ***best solution*** from a set of ***feasible solutions***. The ***Greedy Method*** is a strategy for solving ***optimization problems***.\\n\\n* * * \\nWhat is considered the ***best solution*** is determined by the problem you are trying to solve. There is only one solution that is considered ***best***. \\n\\nA ***feasible solution*** is a solution (not necessarily the best) that meets ***all constraints*** for the problem. \\n\\n*** \\nThe ***constraints*** for this problem are as follows \\n1. we have a car with an ***unlimited size*** gas tank \\n2.  the car must drive from station to station in a ***clockwise*** manner. \\n3.  the car can ***only*** go on to the next station if it ***has enough gas***.  \\n4.  we can start driving from ***any station***.\\n\\nThus ***any starting point for a trip conducted under these circumstances is a feasible solution***, because ***all constraints*** of the problem have been met. \\n\\nThe ***best solution*** is a ***feasible solution*** that finds the starting point that allows the car to complete the circuit. It may be the case there is ***not*** a ***best solution***  (no starting point allows the car to complete the circuit),. \\n\\n\\nWe are looking for the ***best*** or ***optimal*** solution. \\n* * * \\n### Applying The Greedy Method \\n\\nThe ***Greedy*** method says to solve a problem in a series of stages and always select the ***best option*** at each stage. If we always select the ***best option*** at each stage, then ***surely*** we will arrive at the ***best*** or ***optimal*** solution. \\n\\nin otherwords always select the ***locally optimal solution*** in hopes to reach a ***globally optimal***solution \\n\\n***note:*** we always use the same selection procedure at each stage. \\n\\n* * *\\n\\nWe visit gas stations in series of stages ***one station at a time***. At each stage we select the ***best*** station to start our trip from . The ***best*** station to start our trip from is ***the station that can get us to the next gas station***. if there is no best station at given stage, ***we do not make a selection*** and move on to the next stage. \\n\\n![image](https://assets.leetcode.com/users/images/16ce6314-85d4-4568-8084-3ed2aae5ec64_1609899897.8758104.png)\\n\\n\\n\\nsuppose at ```stage 0``` we have to make the decision of wether or not we select ```station 0``` as the best station thus far. \\n\\nWe defined the best station as the station that can get our car to the next station. ***The car can only get to the next station if the car has enough gas***\\n\\nAt ```station 0``` there is ```1``` unit of gas in our cars tank and the cost to get to ```station 1``` is ```3```, thus we cannot get to the next station because  ```1 - 3 = - 2``` meaning we run out of gas (```gas[0] - cost[0] < 0```  before getting to ```station 1``` , so we do not select  ```station 0``` as the start station. this is depicted in ***Figure 2***. in the ***Figure 3*** we will decide if ```station 1``` is the best starting point \\n\\n***note*** in greedy problems where there are two quanities that influence selection criteria it is common to perform some calculation. in our case we must look at ***gas*** and ***cost***  to decide whether we can get to the next station. it is often helpful to think of how they are related to choose the correct calculation.  we must use ***cost*** units of ***gas*** to get to next station, so subtraction is helpful \\n\\n\\n![image](https://assets.leetcode.com/users/images/fdaa8534-3fc5-4e67-902b-10396723a8cf_1609902679.1085558.png)\\n\\n\\nif we proceed in this manner for stations 1, and 2 ***figures 3 & 4*** respecitvely.\\n\\n![image](https://assets.leetcode.com/users/images/8f7d2a57-287c-455b-b530-bd366a09bf37_1609902771.8733008.png)\\n![image](https://assets.leetcode.com/users/images/3887bb4f-e059-49f7-b75a-83c38601b3f3_1609902931.8222818.png)\\n\\n\\n\\nThe interesting case is when we reach ```station 3```, because we have enough gas to get to ```station 4``` that is (```gas[3] - cost[3] >= 0```).  This means we select ```station 3``` as the ***best*** station. This is depicted in ***Figure 5*** \\n\\n![image](https://assets.leetcode.com/users/images/1458fc62-9cdc-42b1-a762-ef312893389c_1609903005.2327127.png)\\n\\n\\nin ***Figure 6*** we traveled to ```station 4``` and, can still get to the next station when starting our trip from ```station 3```, thus station 3 is selected as the start station again.\\n* * * \\n![image](https://assets.leetcode.com/users/images/67182b8f-5e4d-4321-9d3f-73c41de75ecf_1609903079.0828028.png)\\n* * * \\nin ***figure 6***  we select ```station 3``` by assessing the cost to travel from ```station 3``` to ```station 4```. \\n\\n* * * \\nIn our walkthrough thus far we have only shown that if we start at  station 3 can get to ```station 4``` and ```station 0``` our trip. ***This is not  a complete circuit***. we need to show that from ```station 3``` we can travel to ```stations 4, 0, 1, 2, 3``` respectively. \\n\\nHowever as stated our ***greedy approach**** will only needs to ```N``` stages where ```N``` is the number of stations. How is this possible?\\n* * * \\nin our walkthough thus far we kept track of our ***current tank*** (labeled fuel in the diagrams), after we made a trip from one station to another with some desinated start point. This enabled us to decide wether or not we were able to reach the next station.  Here is a recap. the fuel label has been renamed to current tank for clarity. \\n\\n![image](https://assets.leetcode.com/users/images/9899778f-c646-4f53-86a3-a42752410b3f_1609966555.9263694.png)\\n\\n\\n\\n* * * \\n\\nIf we keep a similar running calculation for our ***entire trip*** we get the amount of gas in the tank ***after visiting all stations***. We will call this ***trip tank***.  This is just like ***current tank*** except  this variable is never reset. \\n\\n![image](https://assets.leetcode.com/users/images/f09b34b7-200d-42ff-953e-ac1bc1106c08_1609966618.534998.png)\\n\\n\\n\\n\\n\\n* * * \\nit turns out that if ```trip_tank >= 0``` after we complete all stages, then it is possible to complete the circuit because we had gas left in the tank. whatever the last selected starting point was, is the starting point that we can complete the circuit from . in the event there is not enough gas to complete the circuit our ```trip_tank < 0``` thus we ```return -1``` looking at the code below this approach becomes clear.\\n\\n\\n```python\\ndef canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n\\ttrip_tank, curr_tank, start, n = 0, 0, 0, len(gas)\\n\\tfor i in range(n):\\n\\t\\ttrip_tank += gas[i] - cost[i]\\n\\t\\tcurr_tank += gas[i] - cost[i]\\n\\t\\tif curr_tank < 0:\\n\\t\\t\\tstart = i + 1\\n\\t\\t\\tcurr_tank = 0 \\n\\treturn start if trip_tank >= 0 else -1\\n\\n\\n```\\n\\ncode courtesy of leetcode official solution",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```gas[i] - cost[i]```\n```python\\ndef canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n\\ttrip_tank, curr_tank, start, n = 0, 0, 0, len(gas)\\n\\tfor i in range(n):\\n\\t\\ttrip_tank += gas[i] - cost[i]\\n\\t\\tcurr_tank += gas[i] - cost[i]\\n\\t\\tif curr_tank < 0:\\n\\t\\t\\tstart = i + 1\\n\\t\\t\\tcurr_tank = 0 \\n\\treturn start if trip_tank >= 0 else -1\\n```\n```stage 0```\n```station 0```\n```station 0```\n```1```\n```station 1```\n```3```\n```1 - 3 = - 2```\n```gas[0] - cost[0] < 0```\n```station 1```\n```station 0```\n```station 1```\n```station 3```\n```station 4```\n```gas[3] - cost[3] >= 0```\n```station 3```\n```station 4```\n```station 3```\n```station 3```\n```station 3```\n```station 4```\n```station 4```\n```station 0```\n```station 3```\n```stations 4, 0, 1, 2, 3```\n```N```\n```N```\n```trip_tank >= 0```\n```trip_tank < 0```\n```return -1```\n```python\\ndef canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n\\ttrip_tank, curr_tank, start, n = 0, 0, 0, len(gas)\\n\\tfor i in range(n):\\n\\t\\ttrip_tank += gas[i] - cost[i]\\n\\t\\tcurr_tank += gas[i] - cost[i]\\n\\t\\tif curr_tank < 0:\\n\\t\\t\\tstart = i + 1\\n\\t\\t\\tcurr_tank = 0 \\n\\treturn start if trip_tank >= 0 else -1\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 42594,
                "title": "fully-commented-o-n-c-solution-enabled-by-a-single-observation-of-mine",
                "content": "    class Solution {\\n    public:\\n        int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {\\n            int i, j, n = gas.size();\\n    \\n            /*\\n             * If start from i, stop before station x -> no station k from i + 1 to x - 1 can reach x.\\n             * Bcoz if so, i can reach k and k can reach x, then i reaches x. Contradiction.\\n             * Thus i can jump directly to x instead of i + 1, bringing complexity from O(n^2) to O(n).\\n             */\\n            // start from station i\\n            for (i = 0; i < n; i += j) {\\n                int gas_left = 0;\\n                // forward j stations\\n                for (j = 1; j <= n; j++) {\\n                    int k = (i + j - 1) % n;\\n                    gas_left += gas[k] - cost[k];\\n                    if (gas_left < 0)\\n                        break;\\n                }\\n                if (j > n)\\n                    return i;\\n            }\\n    \\n            return -1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {\\n            int i, j, n = gas.size();\\n    \\n            /*\\n             * If start from i, stop before station x -> no station k from i + 1 to x - 1 can reach x.\\n             * Bcoz if so, i can reach k and k can reach x, then i reaches x. Contradiction.\\n             * Thus i can jump directly to x instead of i + 1, bringing complexity from O(n^2) to O(n).\\n             */\\n            // start from station i\\n            for (i = 0; i < n; i += j) {\\n                int gas_left = 0;\\n                // forward j stations\\n                for (j = 1; j <= n; j++) {\\n                    int k = (i + j - 1) % n;\\n                    gas_left += gas[k] - cost[k];\\n                    if (gas_left < 0)\\n                        break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1705957,
                "title": "java-a-very-detailed-explanation-intuition-behind-logic-brute-force-to-optimised",
                "content": "****\\nPlease upvote if the explanation helps, as it keeps up the motivation to provide such posts.\\n****\\n\\nExplanation Flow : \\n1. Observations\\n2. Brute Force Solution\\n3. First Optimisation from Brute Force\\n4. Optimisation after `Red Bull` * _ *\\n\\n\\u2318 **Given statement :**\\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.\\n\\n\\u2714\\uFE0F Points of observation : \\n1. At any given point in time , the amount of gas \\npresent should be greater or equal than the \\ncost to travel to the next station.\\n2. We can start at any station.\\n\\nSo, we can say if `total gas offered on route` is `>=` `cost to travel between stations`, then\\nit is possible to make a circular route else not.\\n\\nThus, first check : This will help us determine whether a circular tour is possible or not.\\n```\\n        int sum = 0, n = gas.length;\\n        for(int i=0;i<n;i++) {\\n            sum += gas[i]-cost[i];\\n        }\\n        if(sum < 0) return -1;\\n```\\n\\nOur current scenario : \\nAt this point, we know whether or not a circular route is possible.\\n\\n****\\n![image](https://assets.leetcode.com/users/images/b96670cc-960d-40c9-a80f-27fe76586c6f_1642746991.1380951.png)\\n\\n\\n\\n****\\n\\n\\u2714\\uFE0F Brute Force Solution:\\nAt this point, we know whether or not a circular route is possible.\\nAs we don\\'t know the viable starting position for our circular route, we would try to make a circular route from every gas station after a refill.\\n\\n```\\n          for(int i=0;i<n;i++) {\\n            int tank = 0;\\n            boolean roundTrip = true;\\n            for(int j=i;j<n+i+1;j++) { // for a round trip, we need to reach i again\\n                tank += gas[j%n]-cost[j%n];\\n\\t\\t\\t\\t// if at any point, our gas in tank becomes neg, we can not reach the next station\\n                if(tank < 0) {\\n                    roundTrip = false;\\n                    break;\\n                }\\n            }\\n            if(roundTrip)\\n                return i;\\n        }\\n        return -1;\\n```\\n\\n\\u2714\\uFE0F Complexity Analysis:\\n* TC : `O(n^2)`\\n* SC : `O(1)`\\n\\n\\n[`It is important to understand the logic in brute force to be able to move to optmised approach`]\\n\\n\\u2714\\uFE0F Observations from brute force : \\n\\nWe start from a station `i`, get a refill and check if we are able to reach next stations. \\nIf not, we start again from `i+1` and continue until we find that station from which we should\\nactually start our journey ( as we know it is possible to make a circular route now ).\\n\\nWe could do one optimisation in this: \\n`For eg :`\\n   s1 ,      s2  ,       s3   ,   s4   ,    s5  ,   s6\\n_\\\\|\\\\_  ,  _\\\\|\\\\_ ,  _\\\\|\\\\_  , _\\\\|\\\\_  , _\\\\|\\\\_ ,  _\\\\|\\\\_\\n<- - - - -- -- >\\n\\nIf we are able to reach `s3` from say `s1` but not able to move to `s4` then, we should just check if we are able to make a round trip from `s4` . why ? \\n\\nIt is same logic with which we were initially saying \\n( At any given point in time , the amount of gas \\npresent should be greater or equal than the \\ncost to travel to the next station. )\\n\\n**As, we know a circular route is possible thus, `s4` could be a starting point and if `s4` is the starting point, we will have some surplus gas along the way to make tha path from `s3` to `s4` possible or any such path for that matter.**\\n\\nThus,\\n\\n```\\n        int gasInTank = 0, start = 0;\\n        for(int i=0;i<n;i++) {\\n            gasInTank += gas[i]-cost[i];\\n            // if we are not able to reach next station from i, start route from i+1\\n            if(gasInTank < 0) {\\n                start = i+1;\\n                gasInTank = 0;\\n            }\\n        }\\n        \\n        return gasInTank >= 0 ? start : -1; // as tour is possible thus, we can also return \"start\"\\n```\\n\\n\\n# \\u2318 Complete Code : \\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int sum = 0, n = gas.length;\\n        for(int i=0;i<n;i++) {\\n            sum += gas[i]-cost[i];\\n        }\\n        if(sum < 0) return -1;\\n\\t\\t\\n        int gasInTank = 0, start = 0, n = gas.length;;\\n        for(int i=0;i<n;i++) {\\n            gasInTank += gas[i]-cost[i];\\n            // if we are not able to reach next station from i, \\n            if(gasInTank < 0) {\\n                start = i+1;\\n                gasInTank = 0;\\n            }\\n        }\\n        \\n        return gasInTank >= 0 ? start : -1; // we can as well just return \"start\" as we know circular route is possible\\n    }\\n}\\n\\n```\\n\\n\\u2714\\uFE0F Complexity Analysis : \\n* TC : `O(n)`\\n* SC : `O(1)`\\n* We are iterating over the array `twice`, we can do it in a single pass.\\n\\n# \\u2318 One Pass Algorithm : \\nWe just need to do the same logic/calculations in single pass.\\ni.e.` Calculating \"sum\" and \"gasInTank\" same time.`\\n\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int sum = 0, n = gas.length;\\n        int gasInTank = 0, start = 0;\\n        for(int i=0;i<n;i++) {\\n            gasInTank += gas[i]-cost[i];\\n            sum += gas[i]-cost[i];\\n            // if we are not able to reach next station from i, \\n            if(gasInTank < 0) {\\n                start = i+1;\\n                gasInTank = 0;\\n            }\\n        }\\n        \\n        return sum >= 0 ? start : -1;\\n    }\\n}\\n```\\n\\n\\u2714\\uFE0F Complexity Analysis: \\n* TC : `O(n)`\\n* SC : `O(1)`",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n        int sum = 0, n = gas.length;\\n        for(int i=0;i<n;i++) {\\n            sum += gas[i]-cost[i];\\n        }\\n        if(sum < 0) return -1;\\n```\n```\\n          for(int i=0;i<n;i++) {\\n            int tank = 0;\\n            boolean roundTrip = true;\\n            for(int j=i;j<n+i+1;j++) { // for a round trip, we need to reach i again\\n                tank += gas[j%n]-cost[j%n];\\n\\t\\t\\t\\t// if at any point, our gas in tank becomes neg, we can not reach the next station\\n                if(tank < 0) {\\n                    roundTrip = false;\\n                    break;\\n                }\\n            }\\n            if(roundTrip)\\n                return i;\\n        }\\n        return -1;\\n```\n```\\n        int gasInTank = 0, start = 0;\\n        for(int i=0;i<n;i++) {\\n            gasInTank += gas[i]-cost[i];\\n            // if we are not able to reach next station from i, start route from i+1\\n            if(gasInTank < 0) {\\n                start = i+1;\\n                gasInTank = 0;\\n            }\\n        }\\n        \\n        return gasInTank >= 0 ? start : -1; // as tour is possible thus, we can also return \"start\"\\n```\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int sum = 0, n = gas.length;\\n        for(int i=0;i<n;i++) {\\n            sum += gas[i]-cost[i];\\n        }\\n        if(sum < 0) return -1;\\n\\t\\t\\n        int gasInTank = 0, start = 0, n = gas.length;;\\n        for(int i=0;i<n;i++) {\\n            gasInTank += gas[i]-cost[i];\\n            // if we are not able to reach next station from i, \\n            if(gasInTank < 0) {\\n                start = i+1;\\n                gasInTank = 0;\\n            }\\n        }\\n        \\n        return gasInTank >= 0 ? start : -1; // we can as well just return \"start\" as we know circular route is possible\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int sum = 0, n = gas.length;\\n        int gasInTank = 0, start = 0;\\n        for(int i=0;i<n;i++) {\\n            gasInTank += gas[i]-cost[i];\\n            sum += gas[i]-cost[i];\\n            // if we are not able to reach next station from i, \\n            if(gasInTank < 0) {\\n                start = i+1;\\n                gasInTank = 0;\\n            }\\n        }\\n        \\n        return sum >= 0 ? start : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860347,
                "title": "python-simple-and-very-short-explained-solution-o-n-o-1-faster-than-98",
                "content": "1. If sum of gas is less than sum of cost, then there is no way to get through all stations. So while we loop through the stations we sum up, so that at the end we can check the sum.\\n2. Otherwise, there must be one unique solution, so the first one I find is the right one. If the tank becomes negative, we restart because that can\\'t happen.\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if (sum(gas) - sum(cost) < 0):\\n            return -1\\n        \\n        gas_tank, start_index = 0, 0\\n        \\n        for i in range(len(gas)):\\n            gas_tank += gas[i] - cost[i]\\n            \\n            if gas_tank < 0:\\n                start_index = i+1\\n                gas_tank = 0\\n            \\n        return start_index\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if (sum(gas) - sum(cost) < 0):\\n            return -1\\n        \\n        gas_tank, start_index = 0, 0\\n        \\n        for i in range(len(gas)):\\n            gas_tank += gas[i] - cost[i]\\n            \\n            if gas_tank < 0:\\n                start_index = i+1\\n                gas_tank = 0\\n            \\n        return start_index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42667,
                "title": "straightforward-java-linear-solution-with-o-1-space-explanation-and-math-proof",
                "content": "The algorithm is pretty easy to understand. Imagine we take a tour around this circle, the only condition that we can complete this trip is to have more fuel provided than costed in total. That's what the first loop does.\\n\\nIf we do have more fuel provided than costed, that means we can always find a start point around this circle that we could complete the journey with an empty tank. Hence, we check from the beginning of the array, if we can gain more fuel at the current station, we will maintain the start point, else, which means we will burn out of oil before reaching to the next station, we will start over at the next station.\\n\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int tank = 0;\\n        for(int i = 0; i < gas.length; i++)\\n            tank += gas[i] - cost[i];\\n        if(tank < 0)\\n            return - 1;\\n            \\n        int start = 0;\\n        int accumulate = 0;\\n        for(int i = 0; i < gas.length; i++){\\n            int curGain = gas[i] - cost[i];\\n            if(accumulate + curGain < 0){\\n                start = i + 1;\\n                accumulate = 0;\\n            }\\n            else accumulate += curGain;\\n        }\\n        \\n        return start;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "The algorithm is pretty easy to understand. Imagine we take a tour around this circle, the only condition that we can complete this trip is to have more fuel provided than costed in total. That's what the first loop does.\\n\\nIf we do have more fuel provided than costed, that means we can always find a start point around this circle that we could complete the journey with an empty tank. Hence, we check from the beginning of the array, if we can gain more fuel at the current station, we will maintain the start point, else, which means we will burn out of oil before reaching to the next station, we will start over at the next station.\\n\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int tank = 0;\\n        for(int i = 0; i < gas.length; i++)\\n            tank += gas[i] - cost[i];\\n        if(tank < 0)\\n            return - 1;\\n            \\n        int start = 0;\\n        int accumulate = 0;\\n        for(int i = 0; i < gas.length; i++){\\n            int curGain = gas[i] - cost[i];\\n            if(accumulate + curGain < 0){\\n                start = i + 1;\\n                accumulate = 0;\\n            }\\n            else accumulate += curGain;\\n        }\\n        \\n        return start;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1705919,
                "title": "greedy-o-n-solution-with-easy-explanation",
                "content": "\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB Friend\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that motivates me to create a better post like this \\u270D\\uFE0F\\n____________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________\\n\\n#### \\u2714\\uFE0F **Question Conclusion**\\n* There are N gas stations along a circular route, where the amount of gas at station i is arr[i]. \\n* You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). \\n* At the beginning of the journey, the tank is empty at one of the gas stations.\\n* Return the minimum starting gas station\\u2019s index if you need to travel around the circuit once, otherwise return -1.\\n#### \\u2714\\uFE0F **Solution - I (Best Approach)**\\n**##### Problem Note**\\n* Completing the circuit means starting at i and ending up at i again.\\n* Both input arrays are non-empty and have the same length.\\n* Each element in the input arrays is a non-negative integer.\\n##### **Intuition :-**\\n* As we know there consist a unique solution if exist.\\n* If we look at the problem, our point of concern should be the total amount of gas should be greater than the total cost. The only factor we need to consider is setting the starting point.\\n\\n**##### Pseudo Code**\\n- set current, total, start and diff to 0\\n\\n- loop for i = 0; i < gas.size(); i++\\n  - diff = gas[i] -  cost[i]\\n\\n  - total += diff\\n  - current += diff\\n\\n  // current value refers to the total gas - total cost till ith station.\\n  // if that value is negative, this means gas is exhausted, and we cannot complete the circuit.\\n  // Hence we set the current index as the start.\\n  - if current < 0\\n    - start = i + 1\\n    - current = 0\\n\\n- if total >= 0\\n  - return start\\n\\n- return -1\\n##### **Code :-**\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int current = 0;\\n        int total = 0;\\n        int diff = 0;\\n        int start = 0;\\n\\n        for(int i = 0; i < gas.size(); i++){\\n            diff = gas[i] - cost[i];\\n\\n            total += diff;\\n            current += diff;\\n            if(current < 0){\\n                start = i + 1;\\n                current = 0;\\n            }\\n        }\\n\\n        if(total >= 0){\\n            return start;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```\\n**Time Complexity** : `O(N)`, \\n**Space Complexity** : `O(1)`, \\n_____________________________________________________________________________________________________________\\n_____________________________________________________________________________________________________________\\n\\n\\uD83D\\uDCBBIf there are any suggestions/questions in my post, comment below \\uD83D\\uDC47",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int current = 0;\\n        int total = 0;\\n        int diff = 0;\\n        int start = 0;\\n\\n        for(int i = 0; i < gas.size(); i++){\\n            diff = gas[i] - cost[i];\\n\\n            total += diff;\\n            current += diff;\\n            if(current < 0){\\n                start = i + 1;\\n                current = 0;\\n            }\\n        }\\n\\n        if(total >= 0){\\n            return start;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011189,
                "title": "java-0-ms-o-n",
                "content": "\\n# Brute Force Approach\\n<a href=\"https://github.com/f-mohamed-abdullah\">![Gas station.jpg](https://assets.leetcode.com/users/images/5454cb14-d456-48bf-9cc6-31a0f3be68aa_1673065122.3855727.jpeg)</a>\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int total=0,avail=0,ind=0;\\n        for(int i=0;i<gas.length;i++){\\n            total+=gas[i]-cost[i];\\n            avail+=gas[i]-cost[i];\\n            if(avail<0){\\n                avail=0;\\n                ind=i+1;\\n            }\\n        }\\n        return total<0?-1:ind;\\n    }\\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/b21b9708-a8e6-49c6-9c4d-6bb30666103b_1673055596.1989512.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int total=0,avail=0,ind=0;\\n        for(int i=0;i<gas.length;i++){\\n            total+=gas[i]-cost[i];\\n            avail+=gas[i]-cost[i];\\n            if(avail<0){\\n                avail=0;\\n                ind=i+1;\\n            }\\n        }\\n        return total<0?-1:ind;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011271,
                "title": "python-3-2-6-lines-w-explanation-and-example-t-m-99-98",
                "content": "Here\\'s the plan:\\n\\n- First, it is possible to complete the circuit if and only if the total amount of gas on the circuit is sufficient to drive the circuit. More formally: `sum(gas) >= sum(cost)`.\\n- The starting station can be determined by starting at some station`a`(say, `a = 0`) and noting whether a station `b` on the circuit is unreachable due to lack of gas. If all are reachable, then `a` is our answer. If not, our answer is not `a`, nor is any station between `a` and`b`.\\n- We reset the tank to zero and repeat on the remainder of the string `s`.\\n- The last station that is unreachable in this process, say station`z`, is our answer. \\n\\nWhy does this work? Recall there\\'s enough gas to complete the circuit. If it were possible to \"borrow\" gas to get to the next station, the station requiring the most borrowed gas overall is station`z`. Thus, starting at station`z` is the answer.\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: list[int], cost: list[int]) -> int:\\n        \\n        if sum(gas) < sum(cost): return -1   #   Example: gas = [1,2,3,4,5]  cost = [3,4,5,1,2]\\n                                             #\\n        tank = idx = 0                       #   i  gas  cost   tank        start\\n                                             #  \\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\n        for i in range(len(gas)):            #   start = 0              0     0\\n                                             #   0   1    3    0+1-3 = -2     1    reset tank to 0, start to 0+1 = 1\\n            tank+= gas[i]-cost[i]            #   1   2    4    0+2-4 = -2     2    reset tank to 0, start to 1+1 = 2 \\n            if tank < 0: tank, idx = 0, i+1  #   2   3    5    0+3-5 = -2     3    reset tank to 0, start to 2+1 = 3\\n                                             #   3   4    1    0+4-1 =  3     3    \\n        return idx                           #   4   5    2    3+5-2 =  6     3\\n                                             #\\n                                             #  See explanation in problem description to verify that i = 3 works\\n\\n```\\n[https://leetcode.com/problems/gas-station/submissions/624723831/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).\\n\\nAnd here\\'s the two-liner....\\n\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: list[int], cost: list[int]) -> int:\\n\\n        diff = list(accumulate([g - c for g,c in zip(gas,cost)], initial = 0))\\n\\n        return diff.index(min(diff)) if diff[-1] >= 0 else -1\\n```\\n\\nAdded 1/8/22:\\nA number of comments below requested more explanation that a solution must exist if `sum(gas) >= sum(costs)`. \\n\\nLet\\'s consider the data from Example 1. Suppose the car is allowed to continue without regard to maintaining a nonnegative balance of `gas`. Fig 1 shows the balance of gas when initiating the circuit at `i = 0`. \\n\\nThe function is a bounded (possibly quasi-) periodic function, and, in general, `sum(gas) >= sum(costs)` implies the function value at the end of each period is not less than the function value at the beginning of that period. By the Bounded Function Theorem, there exists a minimum value in each period (this occurrence is not necessarily unique in one period).\\n\\n![11.jpg](https://assets.leetcode.com/users/images/ff7fe4a7-d2d8-4053-b3d1-6dd964c10fdb_1673206259.6080277.jpeg)\\n\\nFig 2 shows the function starting at `i = 3` (the `i` for which that minimum value exists) with the same periodicity that has no negative values. The inference from Fig 2 is that a solution will always exist as long as `sum(gas) >= sum(costs)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: list[int], cost: list[int]) -> int:\\n        \\n        if sum(gas) < sum(cost): return -1   #   Example: gas = [1,2,3,4,5]  cost = [3,4,5,1,2]\\n                                             #\\n        tank = idx = 0                       #   i  gas  cost   tank        start\\n                                             #  \\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\n        for i in range(len(gas)):            #   start = 0              0     0\\n                                             #   0   1    3    0+1-3 = -2     1    reset tank to 0, start to 0+1 = 1\\n            tank+= gas[i]-cost[i]            #   1   2    4    0+2-4 = -2     2    reset tank to 0, start to 1+1 = 2 \\n            if tank < 0: tank, idx = 0, i+1  #   2   3    5    0+3-5 = -2     3    reset tank to 0, start to 2+1 = 3\\n                                             #   3   4    1    0+4-1 =  3     3    \\n        return idx                           #   4   5    2    3+5-2 =  6     3\\n                                             #\\n                                             #  See explanation in problem description to verify that i = 3 works\\n\\n```\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: list[int], cost: list[int]) -> int:\\n\\n        diff = list(accumulate([g - c for g,c in zip(gas,cost)], initial = 0))\\n\\n        return diff.index(min(diff)) if diff[-1] >= 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011074,
                "title": "chatgpt-2-solutions-explained",
                "content": "**Solution 1: Brute force (TLE)**\\n - Iterate through each gas station and calculate the remaining gas after traveling to the next station. If the gas at any station becomes negative, it means you cannot complete the journey starting from that station.\\n - If you can complete the journey starting from any station, return that station\\'s index.\\n - If you cannot complete the journey starting from any station, return -1.\\n\\n**TC:** O(N^2)\\n\\n```python\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        n = len(gas)\\n        for i in range(n):\\n            remaining = 0\\n            for j in range(n):\\n                k = (i + j) % n\\n                remaining += gas[k] - cost[k]\\n                if remaining < 0:\\n                    break\\n            else:\\n                return i\\n        return -1\\n```\\n\\n**Solution 2: Can we do better?**\\nLet\\'s use variables to keep track of the total gas available and the current remaining gas, which allows it to determine whether it is possible to complete the journey and, if so, where to start.\\n - **If the ```total amount of gas - the total amount of cost < 0```, there is no solution. (How can you travel all the way if your total gas is not enough to cover the total cost?)**\\n - **If the remaining gas at any station becomes negative, it means you cannot complete the journey starting from any stations between the previously selected start station and the current station (Starting from any of these stations will lead to negative gas at the current station). So we simply select the next station as the start and hope for the best.**\\n\\n\\n**TC:** O(N)\\n\\n```python\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n\\t    n = len(gas)\\n\\t    total_gas = 0\\n\\t    start = 0\\n\\t    remaining = 0\\n\\t    for i in range(n):\\n\\t        total_gas += gas[i] - cost[i]\\n\\t        remaining += gas[i] - cost[i]\\n\\t        if remaining < 0:\\n\\t            start = i + 1\\n\\t            remaining = 0\\n\\t    return start if total_gas >= 0 else -1\\n```\\n\\n**The solution in this post was generated from chatGPT, including the explanations!!! OMG!!!** (except the bold text)\\nI think Leetcode problems were in the training data of ChatGPT, **but still, OMG !!!** Try it yourself on ChatGPT! It is amazing!\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        n = len(gas)\\n        for i in range(n):\\n            remaining = 0\\n            for j in range(n):\\n                k = (i + j) % n\\n                remaining += gas[k] - cost[k]\\n                if remaining < 0:\\n                    break\\n            else:\\n                return i\\n        return -1\\n```\n```total amount of gas - the total amount of cost < 0```\n```python\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n\\t    n = len(gas)\\n\\t    total_gas = 0\\n\\t    start = 0\\n\\t    remaining = 0\\n\\t    for i in range(n):\\n\\t        total_gas += gas[i] - cost[i]\\n\\t        remaining += gas[i] - cost[i]\\n\\t        if remaining < 0:\\n\\t            start = i + 1\\n\\t            remaining = 0\\n\\t    return start if total_gas >= 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128187,
                "title": "o-n-time-and-o-1-space-python-solution-with-new-idea-and-explanation",
                "content": "This solution base on the idea\\n> If the total number of gas is bigger than the total number of cost. There must be a solution.\\n\\nPick **Example 1** to prove\\n```\\ngas  = [1,2,3,4,5]\\ncost = [3,4,5,1,2]\\n```\\nIt\\'s easy to prove that if we start from station 0, and keep track of the amount of gas, when we go to the end of station, our gas would be g (g >= 0)\\nDraw a picture of the ramain gas and station number\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/haige/image_1525278981.png)\\nWe find that at station 2 the gas is the least\\nThen we pick station 3 as start station, and we can reorganize the image(move down the x axis and splice the left image of station 3 to the right).\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/haige/image_1525280315.png)\\n\\nWe finally proved that **If the total number of gas is bigger than the total number of cost. There must be a solution**, because we just need to find the station that the ramaining gas is least and pick the next station as the start station, and our gas will not less than zero on our journey travelling around the circuit.\\n```python\\nclass Solution:\\n    def canCompleteCircuit(self, gas, cost):\\n        if sum(gas) < sum(cost):\\n            return -1\\n        start, total, Min = 0, 0, sys.maxsize\\n        for i in range(len(gas)):\\n            total += gas[i] - cost[i]\\n            if total < Min:\\n                start = (i + 1)%len(gas)\\n                Min = total\\n        return start",
                "solutionTags": [],
                "code": "```\\ngas  = [1,2,3,4,5]\\ncost = [3,4,5,1,2]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 42661,
                "title": "possibly-the-most-easiest-approach-o-n-one-variable-python",
                "content": "    def canCompleteCircuit(self, gas, cost):\\n        \"\"\"\\n        :type gas: List[int]\\n        :type cost: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(gas) == 0 or len(cost) == 0 or sum(gas) < sum(cost):\\n            return -1\\n        position = 0\\n        balance = 0 # current tank balance\\n        for i in range(len(gas)):\\n            balance += gas[i] - cost[i] # update balance\\n            if balance < 0: # balance drops to negative, reset the start position\\n                balance = 0\\n                position = i+1\\n        return position",
                "solutionTags": [],
                "code": "    def canCompleteCircuit(self, gas, cost):\\n        \"\"\"\\n        :type gas: List[int]\\n        :type cost: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(gas) == 0 or len(cost) == 0 or sum(gas) < sum(cost):\\n            return -1\\n        position = 0\\n        balance = 0 # current tank balance\\n        for i in range(len(gas)):\\n            balance += gas[i] - cost[i] # update balance\\n            if balance < 0: # balance drops to negative, reset the start position\\n                balance = 0\\n                position = i+1\\n        return position",
                "codeTag": "Python3"
            },
            {
                "id": 1705893,
                "title": "python3-debit-and-credit-o-1-space-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nConsider this example: `----+++`, where \\xAB-\\xBB are parts of the way where we don\\'t have enough gas to travel to the next station, and \\xAB+\\xBB  are vice versa. Imagine that we could borrow the gas for those \\xAB-\\xBB parts and return debt later when we reach \\xAB+\\xBB parts where we have plenty of gas. That will allow us to start traveling from the very first gas station and maintain a kind of ledger that will account for our debit and credit. If at the end of the travel our credit is greater than debit, that means we are able to do a circuit. Of course, we also should remember the start of the \\xAB+\\xBB part which is our result.\\n\\nTime: **O(n)** - linear\\nSpace: **O(1)** - nothing stored\\n\\nRuntime: 460 ms, faster than **85.85%** of Python3 online submissions for Gas Station.\\nMemory Usage: 18.9 MB, less than **75.25%** of Python3 online submissions for Gas Station.\\n\\n```\\ndef canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n\\tcandidate, debit, credit = None, 0, 0\\n\\t\\n\\tfor i in range(len(gas)):\\n\\t\\tcredit += gas[i] - cost[i]\\n\\t\\tif credit < 0:\\n\\t\\t\\tcandidate, debit, credit = None, debit - credit, 0\\n\\t\\telif candidate is None: \\n\\t\\t\\tcandidate = i\\n\\n\\treturn candidate if credit >= debit else -1\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\ndef canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n\\tcandidate, debit, credit = None, 0, 0\\n\\t\\n\\tfor i in range(len(gas)):\\n\\t\\tcredit += gas[i] - cost[i]\\n\\t\\tif credit < 0:\\n\\t\\t\\tcandidate, debit, credit = None, debit - credit, 0\\n\\t\\telif candidate is None: \\n\\t\\t\\tcandidate = i\\n\\n\\treturn candidate if credit >= debit else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 274646,
                "title": "python-one-pass-greedy",
                "content": "The heuristic is that if ```sum(gas) >= sum(cost)```, there must exists a starting station that enable the circular travel.\\nSuppose our circular route stations are {0,...,n} and ```sum(gas) >= sum(cost)```. And we define a function ```route(l,r)``` as ```\\u2211(l<=i<r) gas[i]-cost[i]``` The valid starting station ```s``` is the leftmost station that we can travel from it to ```n```. So ```route(s,n) > 0```. And we just need to prove ```route(s,n) + route(0,k) > 0``` for any ```k``` from ```{0,...,s-1}```.\\nSince ```s``` is the leftmost station that we can travel from it to ```n```, so for any ```k``` from ```{0,...,s-1}```, we can not travel from ```k``` to ```n```. Or ```route(k,n) < 0 && route(s,n) > 0 => route(k,s) < 0```.\\nAnd as ```sum(gas) >= sum(cost)```, ```route(0,k) + route(k,s) + route(s,n) > 0```. Considering ```route(k,s) < 0```, we can conclude that ```route(0,k) + route(s,n) > 0```.\\nSo based on this, we just need to find out the leftmost station that we can travel from it to ```n``` if ```sum(gas) >= sum(cost)```.\\n```\\ndef canCompleteCircuit(gas, cost):\\n\\tif sum(gas) < sum(cost): \\n\\t\\treturn -1\\n\\tn, start, agg = len(gas), 0, 0\\n\\tfor i in range(n):\\n\\t\\tagg += gas[i] - cost[i]\\n\\t\\tif agg < 0:\\n\\t\\t\\tstart, agg = i+1, 0\\n\\treturn start\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```sum(gas) >= sum(cost)```\n```sum(gas) >= sum(cost)```\n```route(l,r)```\n```\\u2211(l<=i<r) gas[i]-cost[i]```\n```s```\n```n```\n```route(s,n) > 0```\n```route(s,n) + route(0,k) > 0```\n```k```\n```{0,...,s-1}```\n```s```\n```n```\n```k```\n```{0,...,s-1}```\n```k```\n```n```\n```route(k,n) < 0 && route(s,n) > 0 => route(k,s) < 0```\n```sum(gas) >= sum(cost)```\n```route(0,k) + route(k,s) + route(s,n) > 0```\n```route(k,s) < 0```\n```route(0,k) + route(s,n) > 0```\n```n```\n```sum(gas) >= sum(cost)```\n```\\ndef canCompleteCircuit(gas, cost):\\n\\tif sum(gas) < sum(cost): \\n\\t\\treturn -1\\n\\tn, start, agg = len(gas), 0, 0\\n\\tfor i in range(n):\\n\\t\\tagg += gas[i] - cost[i]\\n\\t\\tif agg < 0:\\n\\t\\t\\tstart, agg = i+1, 0\\n\\treturn start\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 860396,
                "title": "python-o-n-greedy-solution-explained",
                "content": "Let us first evaluate differences between our `gas` and `cost`, because this is what we need in the end. Now, let us start from first place and  check if we can fulfill problem conditions: it means that all **cumulative** sums should be not negative. If we get negative cumulative sum, it means, that we can not succeed using current starting index, so we need to take next starting index. In fact we can do better: imagine, we have `i` as starging index and at some moment we have cumulative sum which is negative:\\n\\n`d_i + ... _ d_j < 0`.\\n\\nNote also, that it is the first time we have this sum negative. But it means, that if we consider any `k`, such that `i+1 <=k < j`, then sum `d_k + ... + d_j` also will be negatie, because sum `d_i + ... d_{k-1}` will be positive. It means, that the next candidate for starting index should be `j+1`. \\n\\nImagine example `-2 -2 -2 3 3`. Note, that our gas stations are on circle, so let us use duplication trick and traverse `-2 -2 -2 3 3 -2 -2 -2 3 3`. If we apply our logic, we will find  `-2 -2 -2` **3 3 -2 -2 -2 3 3**: it means if we have solution, starting index will be before first `n`.\\n\\nIf we have `-2 -2 -2 3 2`, then we have `-2 -2 -2 3 2 -2 -2 -2` **3 2**, so starting index is not before first `n`.\\n\\n**Complexity**: Time complexity is `O(n)`, because we have two passes over our data and space complexity is also `O(n)`, because I evaluate `diffs` (it can be easily reduced to `O(1)`).\\n\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas, cost):\\n        diffs = [a-b for a,b in zip(gas, cost)]\\n        n = len(diffs)\\n        cumsum, out = 0, 0\\n        for i in range(2*n):\\n            cumsum += diffs[i%n]\\n            if cumsum < 0:\\n                cumsum = 0\\n                out = i + 1\\n                \\n        return -1 if out > n else out\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canCompleteCircuit(self, gas, cost):\\n        diffs = [a-b for a,b in zip(gas, cost)]\\n        n = len(diffs)\\n        cumsum, out = 0, 0\\n        for i in range(2*n):\\n            cumsum += diffs[i%n]\\n            if cumsum < 0:\\n                cumsum = 0\\n                out = i + 1\\n                \\n        return -1 if out > n else out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 167542,
                "title": "10-lines-python-that-beats-100-no-proof-in-here",
                "content": "I saw lots of posts are using `if sum(gas) < sum(cost): return -1` to filter out \\'No-Solution\\' test cases, **but in interview, if you can\\'t remember how to proof it, then maybe better not to use it**\\n\\nHere\\'s another solution that **does not use that trick but still beats 100%.**\\n\\nThe idea is based on the observation that:\\n* If proceed from A, and found A cannot reach B, then for any points C between A and B; C cannot reach B too. (because if A reached C, then the fuel left when reached C will always >= 0, which is always equal or better than start from C)\\n\\n* same idea, if A can reach B, then for any points C between A and B;  C can reach B too.\\n\\n**So the algorithm is:**\\n 1. start from index `start`  (initialized as 0) and proceeds, record the fuel left in tank.\\n\\n2. if we are lucky and sucessfully returned to point `start`, than we return index \\'start\\' :)\\n\\n3. however, if at index `i`, we found that we can\\'t proceed to `i + 1`, then we record how many gas are we lacking (stored in `gap`), and re-start from `i + 1`, and we update the start index.\\n\\n\\n4. keep runing untill we returned to the **0** point. now the variable `gap` stores the information that **how many fuel we need in order to start from** `0` **and returned sucessfully reach to index** `start` (which records the last start position), and we also have a `tank` variable that tells us **how many fuel we left when we start from `start` and reach** `0`, if `tank >= gap`, then we **can** return to the `start` point, if not, we **can\\'t.**\\n\\nHere\\'s the code\\n\\n```\\nclass Solution(object):\\n    def canCompleteCircuit(self, gas, cost):\\n        \"\"\"\\n        :type gas: List[int]\\n        :type cost: List[int]\\n        :rtype: int\\n        \"\"\"\\n        tank = gap = start = 0\\n        for i in range(len(gas)):\\n            tank += gas[i]\\n            if tank >= cost[i]:\\n                tank -= cost[i]\\n            else:\\n                gap += cost[i] - tank\\n                start = i + 1\\n                tank = 0\\n        if start == len(gas) or tank < gap: return -1\\n        return start\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canCompleteCircuit(self, gas, cost):\\n        \"\"\"\\n        :type gas: List[int]\\n        :type cost: List[int]\\n        :rtype: int\\n        \"\"\"\\n        tank = gap = start = 0\\n        for i in range(len(gas)):\\n            tank += gas[i]\\n            if tank >= cost[i]:\\n                tank -= cost[i]\\n            else:\\n                gap += cost[i] - tank\\n                start = i + 1\\n                tank = 0\\n        if start == len(gas) or tank < gap: return -1\\n        return start\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011375,
                "title": "c-99-18-faster-o-n-easy-explanation-single-loop-solution",
                "content": "# Explanation\\n\\n- If ```total cost of loop > total gas available``` then for sure we\\'ll not be able to complete the loop so return -1.\\n\\n- Now if the above condition doesn\\'t satisfy means there exist atleast one answer.\\n\\n- We\\'ll start iterating from the first index, if anywhere in the path we\\'ve found ```fuel < 0``` at index \"i\" means we can\\'t proceed further. So, we have to restart our journey from that very same index(i).\\n- Now that we have proven in the previous step that we can reach index \"i\", we have changed our target from the loop to the end index of the array because if we can manage the cost of the last index, we will reach at index \"i\" by using the fuel of 1st to \"i\"th index.\\n\\n#### I\\'m pretty sure you guys will understand these above steps completely after reading code\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int totalCost = 0;\\n        int totalGas = 0;\\n        int n = gas.size();\\n        for(int i=0;i<n;i++){\\n            totalCost += cost[i];\\n            totalGas += gas[i];\\n        }\\n        if(totalCost > totalGas)\\n            return -1;\\n\\n        int startIndex=0, curFuel = 0;\\n\\n        for(int i=0;i<n;i++){\\n            if(curFuel < 0){\\n                curFuel = 0;\\n                startIndex = i;\\n            }\\n\\n            curFuel += (gas[i]-cost[i]);\\n        }\\n        return startIndex;\\n    }\\n};\\n```\\n\\n## Please upvote if you find my solution helpful \\uD83D\\uDE4F\\n#### Thank you in advance :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```total cost of loop > total gas available```\n```fuel < 0```\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int totalCost = 0;\\n        int totalGas = 0;\\n        int n = gas.size();\\n        for(int i=0;i<n;i++){\\n            totalCost += cost[i];\\n            totalGas += gas[i];\\n        }\\n        if(totalCost > totalGas)\\n            return -1;\\n\\n        int startIndex=0, curFuel = 0;\\n\\n        for(int i=0;i<n;i++){\\n            if(curFuel < 0){\\n                curFuel = 0;\\n                startIndex = i;\\n            }\\n\\n            curFuel += (gas[i]-cost[i]);\\n        }\\n        return startIndex;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012162,
                "title": "3-different-java-code",
                "content": "##### If my efforts add little value , please do Upvote because it keeps me motivated to try and post different solutions for one problem \\u270C\\uFE0F\\u270C\\uFE0F\\n# Code 1 (DP)\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        long sum = 0;\\n        int maxLoc = 0, max = 0, minLoc = 0, min = 0;\\n        int startMax = 0, endMin = 0, newStartMax = 0; \\n        for (int i = 0; i < gas.length; ++i) {\\n            int diff = gas[i] - cost[i];\\n            sum += diff;\\n            // Get max subarray sum\\n            if (maxLoc + diff < 0) {\\n                maxLoc = 0;\\n                newStartMax = -1;\\n            } else {\\n                if (newStartMax == -1)\\n                    newStartMax = i;\\n                maxLoc += diff;\\n            }\\n            if (max < maxLoc) {\\n                max = maxLoc;\\n                startMax = newStartMax;\\n            }\\n            \\n            // Get min subarray sum\\n            minLoc = Math.min(0, minLoc + diff);\\n            if (min > minLoc) { min = minLoc; endMin = i; }\\n        }\\n        if (sum < 0)\\n            return -1;\\n        if (sum - min > max)\\n            return endMin + 1;\\n        return startMax;\\n    }\\n}\\n```\\n# Code 2  (Greedy)\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        if(arraySum(gas) < arraySum(cost)) return -1;\\n        int n = gas.length;\\n        int answer = 0;\\n        int sum = 0;\\n        for(int i=0; i<n; i++){\\n            sum += (gas[i] - cost[i]);\\n            if(sum < 0){\\n                sum = 0;\\n                answer = i+1;\\n            }\\n        }\\n        return answer;\\n    }\\n    private int arraySum(int[] arr){\\n        int n = arr.length;\\n        int sum = 0;\\n        for(int i=0; i<n; i++){\\n            sum += arr[i];\\n        }\\n        return sum;\\n    }\\n}\\n```\\n# Code 3 (Stack)\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int n = gas.length;\\n\\n        for(int i=0 ; i<n; i++){\\n          if(gas[i]-cost[i] >= 0){\\n              stack.push(i);\\n          }\\n        }\\n\\n        // Now checking for all points\\n        while(stack.size()>0){\\n            int index = stack.pop();\\n            if(check(gas, cost, index, n)){\\n                return index;\\n            }\\n        }\\n        return -1;        \\n    }\\n    public boolean check (int gas[], int cost[], int index, int n){\\n        boolean flag = true;\\n        int size = 0;\\n        int ptr = index;\\n        int sum =0;\\n        while(size < n){\\n            sum+= gas[ptr%n]-cost[ptr%n];\\n            if(sum<0){\\n                return false;\\n            }\\n            ptr++;\\n            size++;\\n        }\\n\\n        if(size == n && sum>=0)return true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        long sum = 0;\\n        int maxLoc = 0, max = 0, minLoc = 0, min = 0;\\n        int startMax = 0, endMin = 0, newStartMax = 0; \\n        for (int i = 0; i < gas.length; ++i) {\\n            int diff = gas[i] - cost[i];\\n            sum += diff;\\n            // Get max subarray sum\\n            if (maxLoc + diff < 0) {\\n                maxLoc = 0;\\n                newStartMax = -1;\\n            } else {\\n                if (newStartMax == -1)\\n                    newStartMax = i;\\n                maxLoc += diff;\\n            }\\n            if (max < maxLoc) {\\n                max = maxLoc;\\n                startMax = newStartMax;\\n            }\\n            \\n            // Get min subarray sum\\n            minLoc = Math.min(0, minLoc + diff);\\n            if (min > minLoc) { min = minLoc; endMin = i; }\\n        }\\n        if (sum < 0)\\n            return -1;\\n        if (sum - min > max)\\n            return endMin + 1;\\n        return startMax;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        if(arraySum(gas) < arraySum(cost)) return -1;\\n        int n = gas.length;\\n        int answer = 0;\\n        int sum = 0;\\n        for(int i=0; i<n; i++){\\n            sum += (gas[i] - cost[i]);\\n            if(sum < 0){\\n                sum = 0;\\n                answer = i+1;\\n            }\\n        }\\n        return answer;\\n    }\\n    private int arraySum(int[] arr){\\n        int n = arr.length;\\n        int sum = 0;\\n        for(int i=0; i<n; i++){\\n            sum += arr[i];\\n        }\\n        return sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int n = gas.length;\\n\\n        for(int i=0 ; i<n; i++){\\n          if(gas[i]-cost[i] >= 0){\\n              stack.push(i);\\n          }\\n        }\\n\\n        // Now checking for all points\\n        while(stack.size()>0){\\n            int index = stack.pop();\\n            if(check(gas, cost, index, n)){\\n                return index;\\n            }\\n        }\\n        return -1;        \\n    }\\n    public boolean check (int gas[], int cost[], int index, int n){\\n        boolean flag = true;\\n        int size = 0;\\n        int ptr = index;\\n        int sum =0;\\n        while(size < n){\\n            sum+= gas[ptr%n]-cost[ptr%n];\\n            if(sum<0){\\n                return false;\\n            }\\n            ptr++;\\n            size++;\\n        }\\n\\n        if(size == n && sum>=0)return true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42600,
                "title": "my-o-n-time-o-1-extra-space-solution",
                "content": "    public class Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        for(int i = 0; i < gas.length; i++) {\\n            gas[i] -= cost[i];\\n        }\\n        int sum = 0;\\n        int result = 0;\\n        int n = gas.length;\\n        for(int i = 0; i < n * 2 - 1; i++) {\\n            sum += gas[i % n];\\n            if(sum < 0) {\\n                result = i + 1;\\n                if(result >= n) {\\n                    return -1;\\n                }\\n                sum = 0;\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        for(int i = 0; i < gas.length; i++) {\\n            gas[i] -= cost[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 860335,
                "title": "c-simple-and-clear-explained-solution-o-n-time-o-1-space",
                "content": "1. If sum of gas is less than sum of cost, then there is no way to get through all stations. So while we loop through the stations we sum up, so that at the end we can check the sum.\\n2. Otherwise, there must be one unique solution, so the first one I find is the right one. If the tank becomes negative, we restart because that can\\'t happen.\\n\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int gas_tank = 0, start_index = 0, n = gas.size(), sum = 0;\\n        \\n        for (int i=0; i<n; i++) {\\n            \\n            sum += gas[i] - cost[i];\\n            gas_tank += gas[i] - cost[i];\\n            \\n            if (gas_tank < 0) {\\n                start_index = i+1;\\n                gas_tank = 0;\\n            }\\n            \\n        }\\n        return sum < 0 ? -1 : start_index;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int gas_tank = 0, start_index = 0, n = gas.size(), sum = 0;\\n        \\n        for (int i=0; i<n; i++) {\\n            \\n            sum += gas[i] - cost[i];\\n            gas_tank += gas[i] - cost[i];\\n            \\n            if (gas_tank < 0) {\\n                start_index = i+1;\\n                gas_tank = 0;\\n            }\\n            \\n        }\\n        return sum < 0 ? -1 : start_index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42685,
                "title": "concise-8ms-c-solution-with-explanation",
                "content": "The idea is to keep track of how much gas we are carrying as we enter each city. When a complete circuit is made, if the amount we're carrying is less than 0, making a circuit without running out of gas is impossible (the route takes more gas than it provides overall). However, if the carry is nonnegative at the end, the route is possible, so we just need to know where to start: we should start where the carry amount was at a minimum, because it will never be less than that on the rest of the route.\\n\\n    class Solution {\\n    public:\\n        int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {\\n            int carry = 0;\\n            pair<size_t, int> city_carry(0, 0);\\n            for (size_t i = 1; i < gas.size(); ++i) {\\n                carry += gas[i - 1] - cost[i - 1];\\n                if (carry < city_carry.second) {\\n                    city_carry = {i, carry};\\n                }\\n            }\\n            carry += gas[gas.size()-1] - cost[gas.size()-1];\\n            return carry >= 0 ? city_carry.first : -1;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {\\n            int carry = 0;\\n            pair<size_t, int> city_carry(0, 0);\\n            for (size_t i = 1; i < gas.size(); ++i) {\\n                carry += gas[i - 1] - cost[i - 1];\\n                if (carry < city_carry.second) {\\n                    city_carry = {i, carry}",
                "codeTag": "Java"
            },
            {
                "id": 420532,
                "title": "javascript-solution",
                "content": "#### The Idea\\n1. update position if `current tank` < 0\\n2. check if `total tank` is < 0\\n3. When `total tank` is positive, it means we have enough gas to over all the previous path.\\n```\\nvar canCompleteCircuit = function(gas, cost) {\\n    let curTank = 0, totalTank = 0, pos = 0;\\n    for (let i=0;i<gas.length;i++) {\\n        curTank+= gas[i] - cost[i];\\n        totalTank+= gas[i] - cost[i];\\n        if (curTank<0) {\\n            curTank = 0;\\n            pos = i+1;\\n        }\\n    }   \\n    return totalTank<0?-1:pos;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canCompleteCircuit = function(gas, cost) {\\n    let curTank = 0, totalTank = 0, pos = 0;\\n    for (let i=0;i<gas.length;i++) {\\n        curTank+= gas[i] - cost[i];\\n        totalTank+= gas[i] - cost[i];\\n        if (curTank<0) {\\n            curTank = 0;\\n            pos = i+1;\\n        }\\n    }   \\n    return totalTank<0?-1:pos;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3012708,
                "title": "explanation-with-simulation-images-detailed-solution",
                "content": "# Intuition & Approach:\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSuppose, we have this input given to us. The red lines on the image show the cost of the trip.:\\n\\n![image.png](https://assets.leetcode.com/users/images/b736041d-e336-4e28-8a7b-2ba5cc2b453c_1673076644.860966.png)\\n\\n\\nAs usual, we will start from the first gas station (station 0). In the first station we can refill gas tank = 0+7 = 7. After refilling this gas we attempt to move to the next station:\\n- Moving to next gas station requires 5 cost. As we have gas tank = 7. We can use 5 and go to the next gas station (station 1). After moving to station 1 we have tank = (7-5) = 2.\\n- Now, we can refill gas tank = (2+1) = 3 from gas station 1. Now, we want to move to the next station (station 2).\\n- But station 1 to station 2 requires cost = 9. But we have tank = 3. So, our car cannot move to the next station.\\n- This illustration is shown below:\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/a4246be6-4398-4244-b0f3-940623e42c05_1673076966.9593108.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/5e5ddf4b-d895-4d62-9149-dc5760efd478_1673077346.3325996.png)\\n\\n\\nNow what to do?\\n\\nYou can see from the figures that whenever we found a station where our \\n**current fuel tank < cost required** \\nto move to the next station, we can make a decision.\\n\\nIn this case, we can start from the station after that. That means, for the above example, we will do the same thing. But from the station 2. We failed when we were at station 1. So, it is best to start from station after that.\\n\\nNow, let\\'s illustrate what happens if we start from station 2. Station 2 can refill 0 amount of gas. With 0 amount of gas we cannot overcome the cost = 1 to move to the next station. So, in this station, we also get **current fuel tank < cost required**. So, we update our start index to the next station. And that is station 3.\\n\\nNow, let\\'s illustrate the simulation if we start from station 3:\\n\\n1. We have total_tank = 0. Current tank after refilling becomes 0+11 = 11.\\n![image.png](https://assets.leetcode.com/users/images/f63e41fe-a152-4fe6-9ed1-53375730baea_1673078515.7560387.png)\\n\\n2. We can use cost 2 to move to the station 4. Our current tank and total tank is updated. In station 4, we previously had 11. Then it cost 2 to come here. Then from station 4 we can get gas 4. So, our final tank will become 13.\\n\\n![image.png](https://assets.leetcode.com/users/images/7cfe2a2d-9f8e-4324-8c23-76f92e8e06a1_1673078596.626254.png)\\n\\n\\n3. We can use it to move to station 0. As it is a circular queue. Now, we have total_tank = 15. We can use it to move to the next station (station 1).\\n\\n![image.png](https://assets.leetcode.com/users/images/0f62e442-7c9a-4d14-93c2-16ff242f4e89_1673078751.1558113.png)\\n\\n\\n4. \\n![image.png](https://assets.leetcode.com/users/images/989d5869-0b93-49c2-8a07-4a1a78d9f1fe_1673078823.284428.png)\\n\\n5. \\n![image.png](https://assets.leetcode.com/users/images/176c3b99-779a-45c5-b399-3e583f38dc91_1673078854.9241922.png)\\n\\n6. Finally, we reached our starting station. That is station 3. We completed a cycle and we can determine our final answer to be **station 3**.\\n\\n![image.png](https://assets.leetcode.com/users/images/fbe16b13-5d41-4ab5-9d91-8c43eaee3f5c_1673078885.0627084.png)\\n\\n# Important condition:\\nWhen we see **current fuel tank < cost required** we update our start index to **current index + 1**. The reason we do this:\\n\\nSuppose, this is a different example scenario where we cannot get enough fuel to complete the trip from station 2 to station 3:\\n\\n![image.png](https://assets.leetcode.com/users/images/a271f0a9-166e-43b4-8404-e8e4ba683f92_1673080060.526466.png)\\n\\n\\nSuppose, from the above picture we see that, from station 2 we are unable to move to station 3. In this case, our starting position was station 0. After facing this issue, in brute-force case, we will change our starting position to station 1. But this will be useless. Because, we already know that these 2 gas stations and trips weren\\'t successfull. Which means, the previous stations didn\\'t provide us with sufficient amount of fuel to move from station 2 to station 3. So, it is the proof that starting from any of these 2 stations will lead us to failure. And for station 2, we already know that starting form it doesn\\'t help us move to station 3. So, we must update our start index to the next station. Our new start index will be station 3.\\n\\n![image.png](https://assets.leetcode.com/users/images/bb20dfa6-5e0a-49ed-a878-d51cabc7636b_1673080457.0815423.png)\\n\\n\\n# Complexity:\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code:\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int start=0;\\n        int total_tank=0;\\n        int cur_tank=0;\\n        for(int i=0; i<gas.length; i++){\\n            total_tank += gas[i]-cost[i];\\n            cur_tank += gas[i]-cost[i];\\n            if(cur_tank<0){\\n                cur_tank = 0;\\n                start=i+1;\\n            }\\n        }\\n        return (total_tank<0)?-1:start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int start=0;\\n        int total_tank=0;\\n        int cur_tank=0;\\n        for(int i=0; i<gas.length; i++){\\n            total_tank += gas[i]-cost[i];\\n            cur_tank += gas[i]-cost[i];\\n            if(cur_tank<0){\\n                cur_tank = 0;\\n                start=i+1;\\n            }\\n        }\\n        return (total_tank<0)?-1:start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 608151,
                "title": "java-simple-greedy-o-n-o-1",
                "content": "- Keep a starting **candidate** \\n- Keep **total gaining** from the gas stations.\\n- Keep a **current gaining** from starting candidate to the current station\\n- If current gaining < 0 it means that our current candidate is not the one. Make the candidate the next element\\n- Iterate the arrays and if totalGaining >= 0, return the candidate, otherwise return -1\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        \\n        int currentGaining = 0;\\n        int totalGaining = 0;\\n        int candidate = 0;\\n        \\n        for(int i= 0; i < gas.length; i++) {\\n            \\n            currentGaining += gas[i] - cost[i];\\n            totalGaining += gas[i] - cost[i];\\n            \\n            if (currentGaining < 0) {\\n                candidate = i+1;\\n                currentGaining = 0;\\n            }\\n            \\n        }\\n        \\n        return totalGaining >= 0 ? candidate : -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        \\n        int currentGaining = 0;\\n        int totalGaining = 0;\\n        int candidate = 0;\\n        \\n        for(int i= 0; i < gas.length; i++) {\\n            \\n            currentGaining += gas[i] - cost[i];\\n            totalGaining += gas[i] - cost[i];\\n            \\n            if (currentGaining < 0) {\\n                candidate = i+1;\\n                currentGaining = 0;\\n            }\\n            \\n        }\\n        \\n        return totalGaining >= 0 ? candidate : -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 215701,
                "title": "simple-java-solution-beats-100-with-detailed-explain",
                "content": "***Example 1:***\\n* **Input:**\\n\\t* gas:  [1, 2, 3, 4, 5]\\n\\t* cost: [3, 4, 5, 1, 2]\\n* **Output:** 3\\n\\n\\n* **gas - cost:**    [-2, -2, -2, 3, 3],     sum = 0\\n\\n| index |  0 | 1 | 2 | 3| 4 |\\n|----|----|----|----|----|----|\\n| **gas - cost** | -2 | -2| -2 | 3 | 3 |\\n| **gas left to the last(4th) gas station** | 0 |2|4|6|3|\\n\\n***Example 2:***\\n* **Input:**\\n  * gas: [2, 3, 4]\\n  * cost: [3, 4, 3]\\n* **Output:** -1\\n  \\n* **gas - cost:** [-1, -1, 1], sum = -1 < 0\\n\\n***Solution Explain:*** \\n*   We can find that only when the sum of the array of `gas - cost` is greater than or equals to zero,  we can travel around the circuit. \\n*   We can go through the `gas - cost` array from the last index to the beginning, and calculate `gas left` to the last gas station, as we can see in *Example 1*. The index of the maximum gas left to the last station is the starting index we want.\\n \\n\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int n = gas.length;\\n        int maxLeft = 0;\\n        int left= 0;  //gas left to the last gas station\\n        int startIndex = 0;\\n        for(int i = n - 1 ; i>= 0; i--)\\n        {\\n            left += gas[i] - cost[i]; \\n            if(left > maxLeft)\\n            { \\n                maxLeft = left;\\n                startIndex = i;\\n            }\\n        }\\n        return left < 0 ? -1 : startIndex;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int n = gas.length;\\n        int maxLeft = 0;\\n        int left= 0;  //gas left to the last gas station\\n        int startIndex = 0;\\n        for(int i = n - 1 ; i>= 0; i--)\\n        {\\n            left += gas[i] - cost[i]; \\n            if(left > maxLeft)\\n            { \\n                maxLeft = left;\\n                startIndex = i;\\n            }\\n        }\\n        return left < 0 ? -1 : startIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42666,
                "title": "simple-o-n-java-solution-with-comments",
                "content": "\\tint canCompleteCircuit(int[] gas, int[] cost) {\\n\\t\\tint total = 0, tank = 0, index = 0;\\n\\t\\tfor (int i = 0; i < cost.length; i++) {\\n\\t\\t\\tint cur = gas[i] - cost[i];\\t\\t\\t\\n\\n\\t\\t\\ttank += cur;\\n\\t\\t\\tif (tank < 0) {//if sum < 0, index can only start from i + 1\\n\\t\\t\\t\\tindex = i + 1;\\n\\t\\t\\t\\ttank = 0;\\n\\t\\t\\t}\\n\\t\\t\\ttotal += cur;\\t\\t\\t\\n\\t\\t}\\t\\t\\n\\t\\treturn total < 0 ? -1 : index;\\n\\t}",
                "solutionTags": [],
                "code": "\\tint canCompleteCircuit(int[] gas, int[] cost) {\\n\\t\\tint total = 0, tank = 0, index = 0;\\n\\t\\tfor (int i = 0; i < cost.length; i++) {\\n\\t\\t\\tint cur = gas[i] - cost[i];\\t\\t\\t\\n\\n\\t\\t\\ttank += cur;\\n\\t\\t\\tif (tank < 0) {//if sum < 0, index can only start from i + 1\\n\\t\\t\\t\\tindex = i + 1;\\n\\t\\t\\t\\ttank = 0;\\n\\t\\t\\t}\\n\\t\\t\\ttotal += cur;\\t\\t\\t\\n\\t\\t}\\t\\t\\n\\t\\treturn total < 0 ? -1 : index;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3011100,
                "title": "easiest-c-solution-with-detailed-explanation",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Intuition:** we can use greedy approach since we just have to check the best option to start.\\n\\n**Approach:**\\nFrom observation, we can see that there\\'s only 2 possible outcomes.\\n1. Take out total_fuel and total_cost. If total_fuel is less than total_cost, that means this journey is not possible so return -1.\\n2. Now just check => `gas = [1,2,3,4,5]` and `cost = [3,4,5,1,2]`\\n3. At i=0, if we do gas[i] - cost[i] i.e 1-3, we get -2. Since it is negative how can we start the journey here. So we will keep going forward until we find a combination whose difference will give us positive fuel. \\n\\n**Lets do a DRY RUN =>**\\n![image](https://assets.leetcode.com/users/images/af152b07-a9ff-4e98-9985-c630f620374c_1673052445.254524.png)\\nWe see that 3 is the answer for this Input, so lets start at 3. Remember that travel needs gas[i]-cost[i] to be positive.\\nHere diff is the fuel consumed to reach the next position\\n1. At i=3, travel_cost = 0 and diff = (4-1) = 3\\n2. At i=4, travel_cost = 3 + (5-2) = 6\\n3. At i=0, travel_cost = 6 + (1-3) = 4\\n4. At i=1, travel_cost = 4 + (2-4) = 2\\n5. At i=2, travel_cost = 2 + (3-5) = 0\\nHere we observe that our fuel got over at i=2 and we reached destination i.e i=3 position.\\n\\n**Brute Force Solution:**\\nEach time we traverse the whole vector for each position, giving us time complexity of O(N^2).\\n**Optimised Solution:**\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int current = 0;\\n        int total_fuel = 0, total_cost=0;\\n        int diff = 0;\\n        int start = 0;\\n        \\n        for(int i = 0; i < gas.size(); i++) {\\n            total_fuel += gas[i];\\n        }       \\n        for(int i = 0; i < gas.size(); i++) {\\n            total_cost += cost[i];\\n        }\\n        // edge case\\n        if(total_fuel < total_cost) {\\n            return -1;\\n        }\\n        \\n        for(int i = 0; i < gas.size(); i++){\\n            current += (gas[i] - cost[i]);\\n            if(current < 0){\\n                start = i + 1;\\n                current = 0;\\n            }\\n        }\\n\\n        return start;\\n    }\\n};\\n```\\n\\n**Time Complexity** =>`O(N)`\\n**Space Complexity** => `O(1)`\\n\\n![image](https://assets.leetcode.com/users/images/4ae5f7b0-6a27-4c15-8364-b0bfc243765e_1673051796.7255352.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int current = 0;\\n        int total_fuel = 0, total_cost=0;\\n        int diff = 0;\\n        int start = 0;\\n        \\n        for(int i = 0; i < gas.size(); i++) {\\n            total_fuel += gas[i];\\n        }       \\n        for(int i = 0; i < gas.size(); i++) {\\n            total_cost += cost[i];\\n        }\\n        // edge case\\n        if(total_fuel < total_cost) {\\n            return -1;\\n        }\\n        \\n        for(int i = 0; i < gas.size(); i++){\\n            current += (gas[i] - cost[i]);\\n            if(current < 0){\\n                start = i + 1;\\n                current = 0;\\n            }\\n        }\\n\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705867,
                "title": "c-simplest-intuitive-solution-one-pass",
                "content": "**INTUITION :** \\n\\n* You can start from any station for which ```gas[i]``` is greater than or equal to  ```cost[i]``` (Gas we can fill up >= Gas needed to travel to next station).\\n* Starting from any such station, if you can travel back to that station, then return the station\\'s index or return -1.\\n\\n**APPROACH :**\\n* We traverse the array from index ```0``` to the last index, assuming our ```ans=0``` , do ```totalGas += gas[i] - cost[i]``` and ```currGas += gas[i] - coast[i]``` at each index.\\n* If ```currGas < 0``` , make ```currGas = 0``` since it\\'s clear that you can\\'t start from that index - you don\\'t gave enough gas to go till next index & so we increment our ans to next index - ```ans=i+1```.\\n* After traversing the arrays, if the ```totalGas < 0``` that means no matter from which station we start, we can\\'t return back to that station, so we return ```-1```.\\n* Whereas, if the ```totalGas >= 0```, we can start from the station ```ans``` & return back to that index. So we return ```ans```.\\n\\n**Time Complexity :** O(N) - ```N = gas.size() or cost.size()```\\n\\n**Space Complexity :** O(1) - No extra space is used\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int totalGas=0, currGas=0, ans=0; //totalGas -> stores the gas remaining after traverlling around the circuit, \\n\\t\\t//currGas -> stores the gasRem after filling up at a stn & trvaelling to next station, if that\\'s not possible, stores 0\\n\\t\\t//ans -> stores the index from which we can start and finish a round circuit\\n        \\n        for(int i=0; i<gas.size(); i++){\\n            totalGas += gas[i]-cost[i];\\n            currGas += gas[i]-cost[i];\\n            \\n            if(currGas < 0) currGas=0, ans=i+1;\\n        }\\n        return (totalGas < 0)? -1 : ans;\\n    }\\n};\\n```\\n\\n**If you like my solution & explanation, please do upvote :)**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```gas[i]```\n```cost[i]```\n```0```\n```ans=0```\n```totalGas += gas[i] - cost[i]```\n```currGas += gas[i] - coast[i]```\n```currGas < 0```\n```currGas = 0```\n```ans=i+1```\n```totalGas < 0```\n```-1```\n```totalGas >= 0```\n```ans```\n```ans```\n```N = gas.size() or cost.size()```\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int totalGas=0, currGas=0, ans=0; //totalGas -> stores the gas remaining after traverlling around the circuit, \\n\\t\\t//currGas -> stores the gasRem after filling up at a stn & trvaelling to next station, if that\\'s not possible, stores 0\\n\\t\\t//ans -> stores the index from which we can start and finish a round circuit\\n        \\n        for(int i=0; i<gas.size(); i++){\\n            totalGas += gas[i]-cost[i];\\n            currGas += gas[i]-cost[i];\\n            \\n            if(currGas < 0) currGas=0, ans=i+1;\\n        }\\n        return (totalGas < 0)? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011376,
                "title": "java-o-n-easy",
                "content": "# Code\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        // Initialize st to -1, which represents that the starting gas station has not been found yet.\\n        // Initialize sum to 0, which will keep track of the total remaining gas after visiting all stations.\\n        // Initialize asum to 0, which will keep track of the total remaining gas after visiting each station.\\n        int st = -1; int sum = 0;int asum = 0;\\n        \\n        // Iterate through each gas station.\\n        for(int i = 0; i < gas.length; i++) {\\n            // Calculate the remaining gas at the current station after traveling to the next station.\\n            gas[i] -= cost[i];\\n            // Add the remaining gas to the total sum.\\n            sum += gas[i];\\n            // Add the remaining gas to the running sum for the current station.\\n            asum += gas[i];\\n            \\n            // If the running sum is negative, it means that the circuit cannot be completed from the current starting gas station.\\n            // Reset the running sum to 0 and update the starting gas station to the next station.\\n            if(asum < 0) {\\n                asum = 0;\\n                st = i + 1;\\n            }\\n            // If the starting gas station is still unassigned, assign it to the current station.\\n            else if(st == -1) {\\n                st = i;\\n            }\\n        }\\n        \\n        // If the total sum is negative, it means that it is not possible to complete a circuit without running out of gas.\\n        // Return -1 in this case.\\n        if(sum < 0) {\\n            return -1;\\n        }\\n        // Otherwise, return the starting gas station index.\\n        return st;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        // Initialize st to -1, which represents that the starting gas station has not been found yet.\\n        // Initialize sum to 0, which will keep track of the total remaining gas after visiting all stations.\\n        // Initialize asum to 0, which will keep track of the total remaining gas after visiting each station.\\n        int st = -1; int sum = 0;int asum = 0;\\n        \\n        // Iterate through each gas station.\\n        for(int i = 0; i < gas.length; i++) {\\n            // Calculate the remaining gas at the current station after traveling to the next station.\\n            gas[i] -= cost[i];\\n            // Add the remaining gas to the total sum.\\n            sum += gas[i];\\n            // Add the remaining gas to the running sum for the current station.\\n            asum += gas[i];\\n            \\n            // If the running sum is negative, it means that the circuit cannot be completed from the current starting gas station.\\n            // Reset the running sum to 0 and update the starting gas station to the next station.\\n            if(asum < 0) {\\n                asum = 0;\\n                st = i + 1;\\n            }\\n            // If the starting gas station is still unassigned, assign it to the current station.\\n            else if(st == -1) {\\n                st = i;\\n            }\\n        }\\n        \\n        // If the total sum is negative, it means that it is not possible to complete a circuit without running out of gas.\\n        // Return -1 in this case.\\n        if(sum < 0) {\\n            return -1;\\n        }\\n        // Otherwise, return the starting gas station index.\\n        return st;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007861,
                "title": "easy-explanation-in-javascript",
                "content": "There are two key concepts to grasp to understand this problem. \\n\\nLet\\'s use the example:\\ngas : [ 1, 2, 3, 4, 5]\\ncost: [ 3, 4, 5, 1, 2]\\n\\nThe first question is, can we know if a solution exists just by looking at these arrays?\\n\\nWe can. If we take the sum of gas[], and subtrack the sum of cost[], we get a single number. If the number is less than 0, then there is no way to complete a round trip, regardless of where we start. There just isn\\'t enough gas to make up for the cost.\\n\\nLet\\'s start with this part of the solution:\\n\\n```\\nvar canCompleteCircuit = function(gas, cost) {\\n\\tlet totalTank = 0;\\n\\t\\n\\tfor (let i = 0; i < gas.length; i++) {\\n\\t\\tconst netCost = gas[i] - cost[i];\\n\\t\\ttotalTank += netCost;\\n\\t}\\n\\treturn totalTank < 0 ? -1 : //our final answer goes here\\n}\\n```\\n\\nThe second intuition is how to figure out the correct starting station in a single pass. We\\'ll create two variables, `currentTank` and `startingStation`, which both will be initialized to zero.\\n\\nLet\\'s imagine this using the example above:\\n\\ngas : [ 1, 2, 3, 4, 5]\\ncost: [ 3, 4, 5, 1, 2]\\n\\n1) We start at station 0. It has one gas and 3 cost, so `netCost` is -2. Since the `netCost` is negative, that means this station isn\\'t a valid starting point, so we\\'ll move onto the next one.\\n\\n2) Station one has the same problem - gas[1] = 2 and cost[1] = 4, so `netCost` = -2, another invalid station. Move to the next one.\\n\\n3) Station two is also -2. Moving on.\\n\\n4) Station three has a `netCost` = 3. That means that this is a potential starting point, since we can actually get from station three to station four using only the gas given to us at station 3. So, set `startingStation` to 3. Also, let\\'s add the `netCost` to our `currentTank`, which was still at 0 and is now 3. \\n\\n5) Now, we check out station 4. Again, `netCost` is 3, which means `currentTank` becomes 6.\\n\\n6) At this point, we\\'re done with the loop. `totalTank` is >= 0, so we know that a valid solution exists. What\\'s more, we know that we never ran out of gas starting at station 3. Combining those two facts - that there is a solution, and that station 3 is the earliest station in the array where you don\\'t run out of gas before reaching the end of the array, this means that station 3 is the correct starting point!\\n\\nThis isn\\'t necessarily intuitive at first. We didn\\'t exhaustively search the beginning of the array, so you may feel uneasy with this approach. \\n\\nHere\\'s the thing: We **know** that Station 0, Station 1, and Station 2 are not valid starting points. We also have a car that has an **unlimited** tank - that\\'s important. If your tank is unlimited, that means there\\'s no downside to taking gas now as opposed to later. \\n\\nAll of this combined means that the earliest starting point we can find is the right one - assuming the trip is possible at all, which we already checked for using `totalTank`.\\n\\nFinally, let\\'s draw up the complete solution:\\n\\n```\\nvar canCompleteCircuit = function(gas, cost) {\\n    let totalTank = 0;\\n    let currentTank = 0;\\n    let startingStation = 0;\\n    for (let i = 0; i < gas.length; i++) {\\n        const netCost = gas[i] - cost[i];\\n        totalTank += netCost;\\n        currentTank += netCost;\\n        if (currentTank < 0) {\\n            startingStation = i+1;\\n            currentTank = 0;\\n        }\\n    }\\n    return totalTank < 0 ? -1 : start;\\n};\\n```\\n\\nThe only other \"gotcha\" is to make sure you are setting `startingStation` to `i + 1` when we have an invalid startingStation, and not `startingStation + 1`. We want to go to the station after the one we just failed at.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canCompleteCircuit = function(gas, cost) {\\n\\tlet totalTank = 0;\\n\\t\\n\\tfor (let i = 0; i < gas.length; i++) {\\n\\t\\tconst netCost = gas[i] - cost[i];\\n\\t\\ttotalTank += netCost;\\n\\t}\\n\\treturn totalTank < 0 ? -1 : //our final answer goes here\\n}\\n```\n```\\nvar canCompleteCircuit = function(gas, cost) {\\n    let totalTank = 0;\\n    let currentTank = 0;\\n    let startingStation = 0;\\n    for (let i = 0; i < gas.length; i++) {\\n        const netCost = gas[i] - cost[i];\\n        totalTank += netCost;\\n        currentTank += netCost;\\n        if (currentTank < 0) {\\n            startingStation = i+1;\\n            currentTank = 0;\\n        }\\n    }\\n    return totalTank < 0 ? -1 : start;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1705951,
                "title": "python-4-lines-o-n-explained-concise-and-easy-to-understand",
                "content": "\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n```\\nclass Solution(object):\\n    def canCompleteCircuit(self, gas, cost):\\n        if sum(gas) < sum(cost): return -1\\n        tank = [0] * len(gas)  # If starting from station 0, tank after arriving at each station\\n        for i in range(1, len(gas)): tank[i] = tank[i - 1] + gas[i - 1] - cost[i - 1]\\n        return tank.index(min(tank))  # the smallest negative number reflects the largest gap, we start from it greedily\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution(object):\\n    def canCompleteCircuit(self, gas, cost):\\n        if sum(gas) < sum(cost): return -1\\n        tank = [0] * len(gas)  # If starting from station 0, tank after arriving at each station\\n        for i in range(1, len(gas)): tank[i] = tank[i - 1] + gas[i - 1] - cost[i - 1]\\n        return tank.index(min(tank))  # the smallest negative number reflects the largest gap, we start from it greedily\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805989,
                "title": "brute-force-one-pass-step-by-step-explanation-with-proof-graph-and-code-beginners-friendly",
                "content": "(Update) I made a video explaining and proving all 3 properties in simple language. If you prefer watching than reading, check it out!\\nhttps://www.youtube.com/watch?v=rf66wlb9aNQ\\n# Problem\\n![image](https://assets.leetcode.com/users/images/c0e16482-8fd9-4608-a320-f444f95213d0_1598116852.709416.png)\\n\\n## Author\\'s note\\nThis question may use greedy algorithm which involves mathematical proofs.\\n\\n# Idea 1: Brute Force\\nWe will have to start from every station and check if we have enough gas to go to the next station with `remainGas = remainGas + gas[station] - cost[station]`. If not `remainGas < 0`, we break and move the starting point to the next station and keep checking until we find a starting point that sustains us to travel around.\\n\\n## Time cost\\nO(n^2). Because we have two pointers (both traverse O(n) times) and one is nested in the other one. \\n\\n## Code\\n```java\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int n = gas.length;\\n        for (int i = 0; i < n; i++) {\\n            int remainGas = 0;\\n            boolean isSuccess = true;\\n            for (int j = i; j < n + i; j++) {\\n                int station = (j+n) % n;\\n                remainGas += gas[station] - cost[station];\\n                if (remainGas < 0) {\\n                    isSuccess = false;\\n                    break;\\n                }\\n            }\\n            if (isSuccess) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n# Idea 2: One pass\\nAfter coming up with brute force, you always ask yourself, are all procedures or calculations necessary? The answer is NO. The solution depends on 3 properties. Every property saves us a bunch of work compared to brute force.\\n\\n## Code\\nLet\\'s reveal the algorithm first and then analyze properties and how they help with simplifying the procedure.\\n```java\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int remainGas = 0;\\n        int totalGas = 0;\\n        int totalCost = 0;\\n        int start = 0;\\n        // Property 1: We compare total gas and total cost. \\n        for (int i = 0; i < gas.length; i++) {\\n            totalGas += gas[i];\\n            totalCost += cost[i];\\n        }\\n        // If total gas doesn\\'t cover total cost, it doesn\\'t work out and we return -1.\\n        if (totalGas < totalCost) {\\n            return -1;\\n        }\\n        // If total gas can cover the cost, we set up a pointer i starting from #1 and traverse. Property 3: no loop around, i < gas.length.\\n        for (int i = 0; i < gas.length; i++) {\\n            // Arriving at each station, we calculate the remaining gas\\n            remainGas += gas[i] - cost[i];\\n            // If the remainGas < 0, that means it\\'s impossible to arrive at this station - it will be an unsuccessful route.\\n            if (remainGas < 0) {\\n                // Property 2: we set the remaining gas to 0, and move the starting point to the next station and test again until we find a successful route (remainGas >=0 at every station).\\n                start = i+1;\\n                remainGas = 0;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```\\n\\n## Property 1. If total gas < total cost, a successful route doesn\\'t exist.\\nThis is obvious.\\n\\nQuestion: How to prove that if total gas >= total cost, there must be a successful route? I made a video to prove this:\\nhttps://www.youtube.com/watch?v=rf66wlb9aNQ\\n\\n### Simplify the code\\nWith this property, we can check at the very beginning (or at the end). \\n```java\\nfor (int i = 0; i < gas.length; i++) {\\n            totalGas += gas[i];\\n            totalCost += cost[i];\\n        }\\n        // If total gas doesn\\'t cover total cost, it doesn\\'t work out and we return -1.\\n        if (totalGas < totalCost) {\\n            return -1;\\n```\\n\\n## Property 2. If path(#i -> #j) failed, it will also fail if we start with any station between #i and #j.\\n\\nConsider this graph as an example: if we start from #1: \\n* path(#1 -> #3) is successful\\n* path(#3 -> #4) fails\\n\\n![image](https://assets.leetcode.com/users/images/142c8d45-ddca-4e2e-a4da-f21932d2ec47_1598117277.5198011.png)\\n\\nWith the brute force idea, if #1 doesn\\'t work out we have to start with #2 to check. Is it necessary? No. We don\\'t have to check from #2 because we\\'ve known that it won\\'t pass #4.\\n\\n![image](https://assets.leetcode.com/users/images/b5649987-2d60-4ff1-b821-d4aedceb8f14_1598285740.7145834.png)\\n\\nWhy? Starting from #2 can be equal to starting from #1, adding 1 gas at #1 (originally gas = 2 at #1). That equals to, #1 doesn\\'t provide us any benefits. \\n\\nWe knew that path(#1 -> #4) fails. That\\'s being said, even if #1 provides us some extra benefits to let us have gas remaining when arriving at #2, that gas doesn\\'t sustain us to pass #4. \\n\\nTherefore, path(#2 -> #4) wouldn\\'t work. We can prove in contradiction. If it works, path(#1 -> #4) should work as well because #1 may provide extra gas for the trip which contradicts with the assumption \"path(#1 -> #4) fails\".\\n\\nIf you prefer watching than reading, feel free to check out my explanation video:\\nhttps://www.youtube.com/watch?v=rf66wlb9aNQ\\n\\n### Simplify the code\\n\\nWith this property, we further conclude that, once we find a failed path(#i -> #j), we can set up the starting point from the next point #j+1. In the code, `start = i+1`.\\n\\n## Property 3. With enough total gas, if there\\'s a successful path(#X -> #last station), starting point #X must be valid (no need to loop back to check).\\n\\nThat\\'s being said, if we find a starting point X that can reach the last station, we don\\'t have to loop back to check stations before X. The gas will always be enough to cover the rest trip (in this example, #5 is the last station but may not be the last one in the route because the starting point is not always #1).\\n\\nIt sounds unbelievable. Let\\'s prove. In this graph, the whole route is divided by green section path(#X -> #n) and blue section path(#n -> #X-1). We want to prove that if the green section works, the blue section must work.\\n\\n![image](https://assets.leetcode.com/users/images/28915514-8a44-4e88-acbc-3e6ee4d17bdf_1598117334.5332415.png)\\n\\n\\n### Notations\\n\\n* #X = starting point\\n* #n = last station in alphabetics\\n* k = the remaining gas after going path(#X -> #n) (before adding gas from #n)\\n\\n### Proof\\n\\n![image](https://assets.leetcode.com/users/images/6aabe851-6afc-4b62-a4db-15466e88d2b5_1598117351.4455805.png)\\n\\nThis formula shows that the sum of x remaining gas at #n and the gas being added must be able to cover the cost during the blue section. Therefore, as long as the green section works, the blue section must work.\\n\\nIf you prefer watching than reading, feel free to check out my explanation video:\\nhttps://www.youtube.com/watch?v=rf66wlb9aNQ\\n\\n### Simplify the code\\n\\bWith this property, we don\\'t have to circle around and check the stations in front of the starting point. So the loop is `for (int i = 0; i < gas.length; i++)`.\\n",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int n = gas.length;\\n        for (int i = 0; i < n; i++) {\\n            int remainGas = 0;\\n            boolean isSuccess = true;\\n            for (int j = i; j < n + i; j++) {\\n                int station = (j+n) % n;\\n                remainGas += gas[station] - cost[station];\\n                if (remainGas < 0) {\\n                    isSuccess = false;\\n                    break;\\n                }\\n            }\\n            if (isSuccess) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int remainGas = 0;\\n        int totalGas = 0;\\n        int totalCost = 0;\\n        int start = 0;\\n        // Property 1: We compare total gas and total cost. \\n        for (int i = 0; i < gas.length; i++) {\\n            totalGas += gas[i];\\n            totalCost += cost[i];\\n        }\\n        // If total gas doesn\\'t cover total cost, it doesn\\'t work out and we return -1.\\n        if (totalGas < totalCost) {\\n            return -1;\\n        }\\n        // If total gas can cover the cost, we set up a pointer i starting from #1 and traverse. Property 3: no loop around, i < gas.length.\\n        for (int i = 0; i < gas.length; i++) {\\n            // Arriving at each station, we calculate the remaining gas\\n            remainGas += gas[i] - cost[i];\\n            // If the remainGas < 0, that means it\\'s impossible to arrive at this station - it will be an unsuccessful route.\\n            if (remainGas < 0) {\\n                // Property 2: we set the remaining gas to 0, and move the starting point to the next station and test again until we find a successful route (remainGas >=0 at every station).\\n                start = i+1;\\n                remainGas = 0;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```\n```java\\nfor (int i = 0; i < gas.length; i++) {\\n            totalGas += gas[i];\\n            totalCost += cost[i];\\n        }\\n        // If total gas doesn\\'t cover total cost, it doesn\\'t work out and we return -1.\\n        if (totalGas < totalCost) {\\n            return -1;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42702,
                "title": "11ms-c-solution-visiting-each-station-once",
                "content": "        \\n    class Solution\\n    {\\n    public:\\n        int canCompleteCircuit(vector<int> &gas, vector<int> &cost)\\n        {\\n            // Start from an arbitrarily chosen index, let's say 0.\\n            // Accumulate the remaining gas (gas - cost).\\n            //\\n            // If there is enough gas to advance to the next station \\n            // then advance to the next station (i++). Continue to do this\\n            // expanding the range of traveled stations until we have \\n            // circled back to the starting point(found a solution)\\n            // or we have ran out of gas.\\n            // \\n            // If we ran out of gas it means that we should have entered the\\n            // range with more gas, so we expand the current range to the left\\n            // in hope to accumulate enough gas.\\n            // \\n            // And so on, expand to the right if we have gas, expand to the \\n            // left if we don't have gas.\\n            // \\n            // Once we completed a circle we have the left side of the range (j)\\n            // as the starting station index.\\n            //\\n    \\n            if (gas.size() == 0 || cost.size() == 0 || gas.size() != cost.size())\\n            {\\n                return -1;\\n            }\\n    \\n            int i = 0; // Right side of the range. \\n            int j = gas.size(); // Left side of the range\\n            int crt = 0; // Current index to be added to the range.\\n            // It might be confusing that the right side of the range starts\\n            // at 0 and the left side starts at gas.size(). \\n            // The range of stations is given by the indexes:\\n            // j, j+1, j+2, ... , gas.size() - 1, 0, 1, 2, ..., i.\\n    \\n            int gasSum = 0; // Remaining gas in the tank\\n    \\n            while (i != j)\\n            {\\n                gasSum += gas[crt] - cost[crt];\\n    \\n                if (gasSum >= 0)\\n                {\\n                    // Move right\\n                    i = i + 1;\\n                    crt = i;\\n                }\\n                else\\n                {\\n                    // Move left\\n                    j = j - 1;\\n                    crt = j;\\n                }\\n            }\\n    \\n            if (gasSum >= 0)\\n            {\\n                j = j % gas.size();\\n                return j;\\n            }\\n            else\\n            {\\n                return -1;\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "class Solution\\n    {\\n    public:\\n        int canCompleteCircuit(vector<int> &gas, vector<int> &cost)\\n        {\\n            // Start from an arbitrarily chosen index, let's say 0.\\n            // Accumulate the remaining gas (gas - cost).\\n            //\\n            // If there is enough gas to advance to the next station \\n            // then advance to the next station (i++). Continue to do this\\n            // expanding the range of traveled stations until we have \\n            // circled back to the starting point(found a solution)\\n            // or we have ran out of gas.\\n            // \\n            // If we ran out of gas it means that we should have entered the\\n            // range with more gas, so we expand the current range to the left\\n            // in hope to accumulate enough gas.\\n            // \\n            // And so on, expand to the right if we have gas, expand to the \\n            // left if we don't have gas.\\n            // \\n            // Once we completed a circle we have the left side of the range (j)\\n            // as the starting station index.\\n            //\\n    \\n            if (gas.size() == 0 || cost.size() == 0 || gas.size() != cost.size())\\n            {\\n                return -1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 391095,
                "title": "java-b-f-greedy-solutions-with-explanation-comments-and-illustration-easy-understand",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/gas-station/) <span class=\"gray\">EPI 17.6</span>\\nDifficulty: <span class=\"orange\">Medium</span>\\n\\n# Problem\\n\\n> There are `N` gas stations along a circular route, where the amount of gas at station `i` is `gas[i]`.\\n\\n> You have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from station `i` to its next station `(i + 1)`. You begin the journey with an empty tank at one of the gas stations.\\n\\nReturn the starting gas station\\'s index if you can travel around the circuit once in the clockwise direction, otherwise return `-1`.\\n\\n**Note:** \\n\\n- If there exists a solution, it is guaranteed to be unique.\\n- Both input arrays are non-empty and have the same length.\\n- Each element in the input arrays is a non-negative integer.\\n\\n**Example:** \\n\\n```java\\ngas  = [1,2,3,4,5]\\ncost = [3,4,5,1,2]\\nOutput: 3\\n\\ngas  = [3,3,4]\\ncost = [3,4,4]\\nOutput: -1\\n```\\n\\n\\n# Analysis\\n\\n## Brute-Force\\n\\nThe idea of brute-force is to examine each single station (or city in EPI book):\\n\\n- Choose the station as a starting point.\\n- Simulate the road trip to see if the following stations are reachable.\\n\\n**Note:** See comments.\\n\\n```java\\npublic int canCompleteCircuit(int[] gas, int[] cost) {\\n  int n = gas.length; // #station\\n  for (int i = 0; i < n; ++i) { // for each station i (starting point)\\n    int gallon = gas[i]; // refuel at starting point\\n    boolean isAmple = true; // isAmple: is it a valid starting point\\n    for (int j = 0; j < n; ++j) { // we need to check n stations\\n      // note: nextStation is the one we need to check\\n      //       currStation is denoted because the cost information is in it\\n      int currStation = (i + j) % n;\\n      int nextStation = (currStation + 1) % n;\\n      gallon -= cost[currStation];\\n      if (gallon < 0) { // not reachable from currStation to nextStation\\n        isAmple = false;\\n        break;\\n      }\\n      gallon += gas[nextStation]; // refuel in nextStation\\n    }\\n    if (isAmple) return i;\\n  }\\n  return -1;\\n}\\n```\\n\\n**Time:** `O(N^2)`\\n**Space:** `O(1)`\\n\\n\\n\\n## Greedy\\n\\nProof by Contradiction: [LeetCode Solution](https://leetcode.com/problems/gas-station/solution/) (if you have time)\\n\\nThe illustration in the EPI book helps understand the algorithm.\\n\\n**Note:** The problem statement is a bit different, but the idea is the same. (`Distance` equals `Gas Cost`, `City` equals `Station`)\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/gpkek.png \"Starting at A, Reference: EPI\")\\n\\nWe can see that at `D` we have the **lowest gallon** before refueling (negative gallon is allowed in the algorithm). Now take the station `D` as the starting point then we can have the optimal solution (if it exists).\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/ps18l.png \"Starting at D, Reference: EPI\")\\n\\nAt last, check the starting point at last to see if such an `ample` station exists. If the gallon at last is negative which means we don\\'t have enough gallons in total to do the road trip (return `-1`).\\n\\n**Note:** See comments.\\n\\n```java\\npublic int canCompleteCircuit(int[] gas, int[] cost) {\\n  int n = gas.length;\\n  int minCityIdx = -1;\\n  int gallon = 0, minGallon = Integer.MAX_VALUE;\\n  for (int i = 0; i < n; ++i) { // starting from city 0\\n    gallon += gas[i]; // refuel at i\\n    gallon -= cost[i]; // deduct cost from i to i + 1\\n    // update\\n    if (gallon < minGallon) {\\n      minGallon = gallon;\\n      minCityIdx = (i + 1) % n; // consider the calculation for starting point at last\\n    }\\n  }\\n  // when getting back to the starting point, check if the gallon is negative (no ample city)\\n  return (gallon >= 0) ? minCityIdx : -1;\\n}\\n```\\n\\n**Time:** `O(N)`\\n**Space:** `O(1)`\\n\\n",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```java\\ngas  = [1,2,3,4,5]\\ncost = [3,4,5,1,2]\\nOutput: 3\\n\\ngas  = [3,3,4]\\ncost = [3,4,4]\\nOutput: -1\\n```\n```java\\npublic int canCompleteCircuit(int[] gas, int[] cost) {\\n  int n = gas.length; // #station\\n  for (int i = 0; i < n; ++i) { // for each station i (starting point)\\n    int gallon = gas[i]; // refuel at starting point\\n    boolean isAmple = true; // isAmple: is it a valid starting point\\n    for (int j = 0; j < n; ++j) { // we need to check n stations\\n      // note: nextStation is the one we need to check\\n      //       currStation is denoted because the cost information is in it\\n      int currStation = (i + j) % n;\\n      int nextStation = (currStation + 1) % n;\\n      gallon -= cost[currStation];\\n      if (gallon < 0) { // not reachable from currStation to nextStation\\n        isAmple = false;\\n        break;\\n      }\\n      gallon += gas[nextStation]; // refuel in nextStation\\n    }\\n    if (isAmple) return i;\\n  }\\n  return -1;\\n}\\n```\n```java\\npublic int canCompleteCircuit(int[] gas, int[] cost) {\\n  int n = gas.length;\\n  int minCityIdx = -1;\\n  int gallon = 0, minGallon = Integer.MAX_VALUE;\\n  for (int i = 0; i < n; ++i) { // starting from city 0\\n    gallon += gas[i]; // refuel at i\\n    gallon -= cost[i]; // deduct cost from i to i + 1\\n    // update\\n    if (gallon < minGallon) {\\n      minGallon = gallon;\\n      minCityIdx = (i + 1) % n; // consider the calculation for starting point at last\\n    }\\n  }\\n  // when getting back to the starting point, check if the gallon is negative (no ample city)\\n  return (gallon >= 0) ? minCityIdx : -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1276287,
                "title": "simple-one-pass-python-solution",
                "content": "\\t\\n\\tclass Solution:\\n\\t\\tdef canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n\\t\\t\\t\\n\\t\\t\\t# base case\\n\\t\\t\\tif sum(gas) - sum(cost) < 0:\\n\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\tgas_tank = 0  # gas available in car till now\\n\\t\\t\\tstart_index = 0  # Consider first gas station as starting point\\n\\n\\t\\t\\tfor i in range(len(gas)):\\n\\n\\t\\t\\t\\tgas_tank += gas[i] - cost[i]\\n\\n\\t\\t\\t\\tif gas_tank < 0:  # the car has deficit of petrol\\n\\t\\t\\t\\t\\tstart_index = i+1  # change the starting point\\n\\t\\t\\t\\t\\tgas_tank = 0  # make the current gas to 0, as we will be starting again from next station\\n\\n\\t\\t\\treturn start_index\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "\\t\\n\\tclass Solution:\\n\\t\\tdef canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n\\t\\t\\t\\n\\t\\t\\t# base case\\n\\t\\t\\tif sum(gas) - sum(cost) < 0:\\n\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\tgas_tank = 0  # gas available in car till now\\n\\t\\t\\tstart_index = 0  # Consider first gas station as starting point\\n\\n\\t\\t\\tfor i in range(len(gas)):\\n\\n\\t\\t\\t\\tgas_tank += gas[i] - cost[i]\\n\\n\\t\\t\\t\\tif gas_tank < 0:  # the car has deficit of petrol\\n\\t\\t\\t\\t\\tstart_index = i+1  # change the starting point\\n\\t\\t\\t\\t\\tgas_tank = 0  # make the current gas to 0, as we will be starting again from next station\\n\\n\\t\\t\\treturn start_index\\n",
                "codeTag": "Java"
            },
            {
                "id": 637494,
                "title": "c-solution-based-on-kadane-s-algorithm",
                "content": "Idea is if between station A and station B we run out of fuel then we cannot start anywhere between A and B.\\nWhich is similar to what we encouter while calculating maximum subarray sum. So if at station B if sum of gas[i] - cost[i] is less than 0 so we cannot reach station B. We reset sum to 0 and go again from B+1 th station\\n\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size();\\n        int sum=0, store=0, over=0;\\n        for(int i=0;i<n;++i){\\n            over+=gas[i]-cost[i]; //if total gas is less than cost then solution not exist\\n            sum+=gas[i]-cost[i]; //next two lines is basically the idea of kadane algorithm\\n            if(sum<0){store=i+1;sum=0;} //just use extra variable store to keep track of index to start\\n        }\\n        if(over<0) return -1;\\n        return store;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size();\\n        int sum=0, store=0, over=0;\\n        for(int i=0;i<n;++i){\\n            over+=gas[i]-cost[i]; //if total gas is less than cost then solution not exist\\n            sum+=gas[i]-cost[i]; //next two lines is basically the idea of kadane algorithm\\n            if(sum<0){store=i+1;sum=0;} //just use extra variable store to keep track of index to start\\n        }\\n        if(over<0) return -1;\\n        return store;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011223,
                "title": "golang-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nBrute force will require O(N^2) Time.\\n\\nTo achieve O(N) time, we need to be aware of 2 ideas:\\n1. If we start at station `start` and the first station that is not reachable is station `i`, then for all stations in `[start, i)`, starting at those stations will not be able to reach `i`. \\n\\n2. If total `gas` >= total `cost`, then there is a starting station that can reach all stations.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc canCompleteCircuit(gas []int, cost []int) int {\\n    n := len(gas)\\n    fuelLeft, globalFuelLeft, start := 0, 0, 0\\n    for i := 0; i < n; i++ {\\n        globalFuelLeft += gas[i] - cost[i]\\n        fuelLeft += gas[i] - cost[i]\\n        if fuelLeft < 0 {\\n            start = i + 1\\n            fuelLeft = 0\\n        }\\n    }\\n\\n    if globalFuelLeft < 0 {\\n        return -1\\n    }\\n    return start\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc canCompleteCircuit(gas []int, cost []int) int {\\n    n := len(gas)\\n    fuelLeft, globalFuelLeft, start := 0, 0, 0\\n    for i := 0; i < n; i++ {\\n        globalFuelLeft += gas[i] - cost[i]\\n        fuelLeft += gas[i] - cost[i]\\n        if fuelLeft < 0 {\\n            start = i + 1\\n            fuelLeft = 0\\n        }\\n    }\\n\\n    if globalFuelLeft < 0 {\\n        return -1\\n    }\\n    return start\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1316274,
                "title": "java-o-n-time-o-1-space-solution-100-faster",
                "content": "The idea is to calculate the fuel shortage upto the point where balance becomes < 0. Reset the balance to zero in order to calculate the balance in rest of the path. If their sum >= 0, we have found the starting point.\\n\\n```\\n public int canCompleteCircuit(int[] gas, int[] cost) {\\n\\t\\tint tank=0;                    //fuel in tank\\n        int shortage=0;            //fuel shortage\\n        int start=0;                   //starting point\\n\\t\\t\\n        for(int i=0;i<gas.length;i++){\\n          \\n\\t\\t  tank+=gas[i]-cost[i];          //calculate the balance at everypoint\\n\\t\\t  \\n\\t\\t  //update fuelshortage and starting point when it becomes less than 0 \\n            if(tank<0){\\n                shortage+=tank;\\n                tank=0;\\n                start=i+1;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// if the sum of both >= 0 then we have found the solution\\n        return shortage+tank>=0?start:-1;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int canCompleteCircuit(int[] gas, int[] cost) {\\n\\t\\tint tank=0;                    //fuel in tank\\n        int shortage=0;            //fuel shortage\\n        int start=0;                   //starting point\\n\\t\\t\\n        for(int i=0;i<gas.length;i++){\\n          \\n\\t\\t  tank+=gas[i]-cost[i];          //calculate the balance at everypoint\\n\\t\\t  \\n\\t\\t  //update fuelshortage and starting point when it becomes less than 0 \\n            if(tank<0){\\n                shortage+=tank;\\n                tank=0;\\n                start=i+1;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// if the sum of both >= 0 then we have found the solution\\n        return shortage+tank>=0?start:-1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1159963,
                "title": "simple-python-sol-96-faster-with-explanations",
                "content": "\\n\\t  \"\"\"\\n\\t  \\n\\t  \\n\\t  Success\\n      Details \\n      Runtime: 44 ms, faster than 96.59% of Python3 online submissions for Gas Station.\\n     Memory Usage: 14.9 MB, less than 99.69% of Python3 online submissions for Gas Station.\\n\\t\\t\\n\\t\\t\\n\\t\\tSo the basic idea is that we are keeping a extra and lack var\\n        \\n        So when we fuel up and when arrive the next station we add the the difference of \\n        \\n        the prev gas - cost and then add the curr gas \\n        \\n        at the end if  we reach the end of list we will see if sum + diff >= 0:\\n        \\n        then we dont need to check the again from the start coz we know that we can complete the tour\\n        \\n        else we can\\'t.\\n        \"\"\"\\n        \\n        \\n\\n        \\n        extra = start= lack = 0\\n        for i in range(len(gas)):\\n            \\n            extra+= gas[i]- cost[i]\\n            \\n            if extra<0:\\n                start= i+1\\n                lack+=extra\\n                \\n                extra = 0\\n        if extra+lack>=0:\\n            return start\\n        \\n        return -1\\n\\t\\t\\n**IF YOU FIND IT HELPFUL PLEASE UPVOTE**\\n**AND IF YOU HAVE ANY QUERY COMMENT DOWN I WILL TRY REPLY ASAP**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n\\t  \"\"\"\\n\\t  \\n\\t  \\n\\t  Success\\n      Details \\n      Runtime: 44 ms, faster than 96.59% of Python3 online submissions for Gas Station.\\n     Memory Usage: 14.9 MB, less than 99.69% of Python3 online submissions for Gas Station.\\n\\t\\t\\n\\t\\t\\n\\t\\tSo the basic idea is that we are keeping a extra and lack var\\n        \\n        So when we fuel up and when arrive the next station we add the the difference of \\n        \\n        the prev gas - cost and then add the curr gas \\n        \\n        at the end if  we reach the end of list we will see if sum + diff >= 0:\\n        \\n        then we dont need to check the again from the start coz we know that we can complete the tour\\n        \\n        else we can\\'t.\\n        \"\"\"\\n        \\n        \\n\\n        \\n        extra = start= lack = 0\\n        for i in range(len(gas)):\\n            \\n            extra+= gas[i]- cost[i]\\n            \\n            if extra<0:\\n                start= i+1\\n                lack+=extra\\n                \\n                extra = 0\\n        if extra+lack>=0:\\n            return start\\n        \\n        return -1\\n\\t\\t\\n**IF YOU FIND IT HELPFUL PLEASE UPVOTE**\\n**AND IF YOU HAVE ANY QUERY COMMENT DOWN I WILL TRY REPLY ASAP**",
                "codeTag": "Unknown"
            },
            {
                "id": 695537,
                "title": "c-solution-12-lines-code-o-n-8-ms-faster-than-88-00",
                "content": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int extra = 0,index=0,total=0;\\n        for(int i=0; i<gas.size(); i++) {\\n            total += gas[i] - cost[i];\\n            extra += gas[i] - cost[i];\\n            if(extra < 0) {\\n                extra = 0;\\n                index = i+1;\\n            }\\n        }\\n        if(total>=0) return index;\\n        else return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int extra = 0,index=0,total=0;\\n        for(int i=0; i<gas.size(); i++) {\\n            total += gas[i] - cost[i];\\n            extra += gas[i] - cost[i];\\n            if(extra < 0) {\\n                extra = 0;\\n                index = i+1;\\n            }\\n        }\\n        if(total>=0) return index;\\n        else return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287303,
                "title": "proof-if-the-sum-of-gas-sum-of-cost-there-will-always-be-a-solution",
                "content": "### Background\\nhttps://leetcode.com/problems/gas-station/discuss/42568/Share-some-of-my-ideas.\\n@daxianji007 came up with an idea (**If the total number of gas is bigger than the total number of cost. There must be a solution.**) without proving it, and I thought it would be nice if someone can prove and illustrate the idea vividly. \\nSo here I am.\\n\\n### Precondition\\nSum of gas >= sum of cost ( I think the precondition should include situations where sum of gas **equals** sum of cost )\\n let `gasLeft` = `gas - cost`, and I will use `gasLeft` instead of `gas` and `cost` to save the trouble.\\nSo now the precondition is:\\n`Sum(gasLeft) >= 0`\\n\\n### Example\\n`gasLeft: [21,-14,-11,13,7,-13,-4,-10,11]` (any random array with `Sum(array)>=0` is good. Here `Sum(gasLeft)=0`)\\n![image](https://assets.leetcode.com/users/lmiaoj/image_1557109334.png)\\nNow, let start at any position (here I start from index 0), accumulate gasLeft[i] until the sum is negative and then merge the nodes together, and we will get something like below: \\n![image](https://assets.leetcode.com/users/lmiaoj/image_1557109552.png)\\nAnd now we can say that we get a `K` (`K` is the start index of the last merged node), which satisfys the following:\\n```\\ngasLeft[K]>=0;\\ngasLeft[K]+gasLeft[K+1]>=0;\\ngasLeft[K]+gasLeft[K+1]+gasLeft[K+2]>=0;\\n...\\ngasLeft[K]+...+gasLeft[K-1]>=0; //the sum of the entire loop\\n```\\n\\n### Proof\\nI am not very good at proving things using mathematical statements, so I\\'ll just try to picture it here.\\nLook at the 2nd picture and follow my thoughts:\\nImagine from position `K`, a car with `N(N>=0) gasLeft` starts off;\\nthink of all the stations in the same node in the 2nd picture as **one big merged-station**; (we can do this because even a car with 0 gasLeft can safely pass these stations at one time, so they can be merged together)\\nBecause `N+gasLeft(merged-stations) >=0` (remember the precondition `Sum(gasLeft)>=0`), the car can safely return to K after passing all merged stations;\\nSo the car starts from `K` can safely pass all stations without running out of gas;\\nThe proof is done!\\n\\n#### PS:\\n1. there may be more than one K. If you start from another different station you may get another K;\\n2. any feedbacks and suggestions are welcome !",
                "solutionTags": [],
                "code": "```\\ngasLeft[K]>=0;\\ngasLeft[K]+gasLeft[K+1]>=0;\\ngasLeft[K]+gasLeft[K+1]+gasLeft[K+2]>=0;\\n...\\ngasLeft[K]+...+gasLeft[K-1]>=0; //the sum of the entire loop\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 42578,
                "title": "easy-and-simple-proof-with-python-solution",
                "content": "Gas Station (Proof)\\n\\n**I. When total cost <= total gas, there is always a solution.**\\nsum(x, y) = gas[x] - cost[x] + gas[x + 1] - cost[x + 1] + ... + gas[y] - cost[y]\\nProof:\\nWe assume that [i, j] is the greatest range sum. Then, starting from *i*, we could travel the loop. Assume in contradiction that starting from *i*, there is a *m* stop the travel due to out of gas. . Thus, since total sum >= 0, sum[i, j] >= 0. Since total sum >= 0, we know *A + B + C > 0*. Since sum(A, B ) <= 0, then C >= 0. Then, sum(C, A) >= 0. Therefore, sum(C, A) will be the greatest range which is contradicted to the assumption.\\n\\n![0_1468366781051_image.png](/uploads/files/1468366781384-image.png) \\n\\n**II. When *sum(i, j) < 0, start = i + 1***\\nTwo proof:\\n\\n1. Since there is always a solution, once we find a range sum < 0, we can let this range be the last range in the whole trip. Then, start = i + 1.\\n2. Since the gain of previous stations are always >= 0, once we find a range sum[i, j] < 0, there is not a k satisfy that range sum[k, j] >= 0. Then, start = i + 1.\\n\\n```\\nclass Solution(object):\\n    def canCompleteCircuit(self, gas, cost):\\n        \"\"\"\\n        :type gas: List[int]\\n        :type cost: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        totalgas = 0\\n        totalcost = 0\\n        start = 0\\n        balance = 0\\n        for i in xrange(0, len(gas)):\\n            totalgas += gas[i]\\n            totalcost += cost[i]\\n            balance += gas[i] - cost[i]\\n            if balance < 0:\\n                start = i + 1\\n                balance = 0\\n        \\n        if totalcost <= totalgas:\\n            return start\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canCompleteCircuit(self, gas, cost):\\n        \"\"\"\\n        :type gas: List[int]\\n        :type cost: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        totalgas = 0\\n        totalcost = 0\\n        start = 0\\n        balance = 0\\n        for i in xrange(0, len(gas)):\\n            totalgas += gas[i]\\n            totalcost += cost[i]\\n            balance += gas[i] - cost[i]\\n            if balance < 0:\\n                start = i + 1\\n                balance = 0\\n        \\n        if totalcost <= totalgas:\\n            return start\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011799,
                "title": "easy-c-solution-kadane-s-algorithm",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        //base case\\n        int totalGas=accumulate(gas.begin(),gas.end(),0);\\n        int totalCost=accumulate(cost.begin(),cost.end(),0);\\n        if(totalGas<totalCost) return -1;\\n\\n\\n        int n=gas.size();\\n        int currGas=0,startIdx=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            currGas+=gas[i]-cost[i];\\n            if(currGas<0)\\n            {\\n                startIdx=i+1;\\n                currGas=0;\\n            }\\n        }\\n        return startIdx;\\n    }\\n};\\n```\\n\\n![4812322.jpg](https://assets.leetcode.com/users/images/07b939f2-df43-41fe-9efd-8820b475edc3_1673068793.3229742.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        //base case\\n        int totalGas=accumulate(gas.begin(),gas.end(),0);\\n        int totalCost=accumulate(cost.begin(),cost.end(),0);\\n        if(totalGas<totalCost) return -1;\\n\\n\\n        int n=gas.size();\\n        int currGas=0,startIdx=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            currGas+=gas[i]-cost[i];\\n            if(currGas<0)\\n            {\\n                startIdx=i+1;\\n                currGas=0;\\n            }\\n        }\\n        return startIdx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951472,
                "title": "python-o-n-time-and-o-1-space",
                "content": "# Intuition\\nYou are asked if its possible to complete a circuit (get back to the same index without running out of gas) and from which station this is possible.\\n\\nThe question gives users two arrays: one representing the gas available at each station, one representing how far the next station is at the current index. Essentially gas[i]-cost[i] gives you the net change after leaving the ith index. \\n\\nFor example:\\n\\ngas = [1,4,2,3].  cost = [3,2,3,1]\\n\\nAfter you leave the 0th index you will have gas[0] - cost[0] = 1-3 = -2 gas. \\n\\nThis intuition regarding what the gas-cost is at every index will be invaluble in the approach.\\n\\n# Approach\\nThe brute force solution to this problem would require calculating the complete circuit from each index. \\n\\nIf you approach this with a two pointer solution you need to only do a double pass.\\n\\nHave one pointer (start) which will indicate what gas station you are starting on. Have another pointer (end) which will indicate what gas station you have made it to. \\n\\nAs you increment the end pointer, find the gas[i] - cost[i] at each index you visit and it to a total gas tank. If that gas tank ever reaches zero, increment your start pointer and subtract that gas[i] - cost[i] from the total tank, since this indicates that that start index was invalid. Keep doing this until your total tank is 0 or above. If your start pointer reaches the end of the array and you havent found the answer, then return -1 since this means no start indexes were valid.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution(object):\\n    def canCompleteCircuit(self, gas, cost):\\n        \"\"\"\\n        :type gas: List[int]\\n        :type cost: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        # start a pointer at 0 called start\\n        # start a pointer at 0 called end\\n        # start a variable called length\\n        # you start at the beginning of the list and sum. if the sum at any time is less than 0, you subtract from the start. and move the pointer. subtract from length keep summing until you get lengths equal length of list\\n        # \\n        # if start pointer ever gets back to 0 answer is  -1\\n        \\n        start = 0\\n        end = 0 \\n        sum = 0\\n        length = 0\\n        while start<len(gas) and length < len(gas):\\n            sum += gas[end]-cost[end]\\n            length +=1\\n            while start<len(gas) and sum < 0:\\n                sum -= gas[start] - cost[start]\\n                start +=1\\n                length-=1\\n            end+=1\\n            end = end % len(gas)\\n        if length == len(gas):\\n            return start\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def canCompleteCircuit(self, gas, cost):\\n        \"\"\"\\n        :type gas: List[int]\\n        :type cost: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        # start a pointer at 0 called start\\n        # start a pointer at 0 called end\\n        # start a variable called length\\n        # you start at the beginning of the list and sum. if the sum at any time is less than 0, you subtract from the start. and move the pointer. subtract from length keep summing until you get lengths equal length of list\\n        # \\n        # if start pointer ever gets back to 0 answer is  -1\\n        \\n        start = 0\\n        end = 0 \\n        sum = 0\\n        length = 0\\n        while start<len(gas) and length < len(gas):\\n            sum += gas[end]-cost[end]\\n            length +=1\\n            while start<len(gas) and sum < 0:\\n                sum -= gas[start] - cost[start]\\n                start +=1\\n                length-=1\\n            end+=1\\n            end = end % len(gas)\\n        if length == len(gas):\\n            return start\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938470,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of gas stations.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func canCompleteCircuit(_ gas: [Int], _ cost: [Int]) -> Int {\\n        let count = gas.count\\n        var dp: [Int] = Array(repeating: Int.min, count: count)\\n        var i = 0\\n        var loop = 0\\n        var start = -1\\n        \\n        while loop <= 1 {\\n            let index = i > 0 ? i - 1 : count - 1\\n            \\n            if dp[i] >= 0 && start == i { return start }\\n            \\n            if dp[index] >= 0 {\\n                dp[i] = dp[index] + gas[i] - cost[i]\\n            \\n            } else {\\n                dp[i] = gas[i] - cost[i]\\n                start = i\\n            }\\n            \\n            if dp[i] < 0 { start = i }\\n            i += 1\\n            if i == count { loop += 1 }\\n            i %= count\\n        }\\n        \\n        return -1\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of gas stations.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func canCompleteCircuit(_ gas: [Int], _ cost: [Int]) -> Int {\\n        let count = gas.count\\n        var dp: [Int] = Array(repeating: Int.min, count: count)\\n        var i = 0\\n        var loop = 0\\n        var start = -1\\n        \\n        while loop <= 1 {\\n            let index = i > 0 ? i - 1 : count - 1\\n            \\n            if dp[i] >= 0 && start == i { return start }\\n            \\n            if dp[index] >= 0 {\\n                dp[i] = dp[index] + gas[i] - cost[i]\\n            \\n            } else {\\n                dp[i] = gas[i] - cost[i]\\n                start = i\\n            }\\n            \\n            if dp[i] < 0 { start = i }\\n            i += 1\\n            if i == count { loop += 1 }\\n            i %= count\\n        }\\n        \\n        return -1\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430224,
                "title": "c-very-simple-approach",
                "content": "**Please Upvote if you like the Code and Comment down below if you have any query!**\\n\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) \\n    {\\n        int curr_gas=0,start=0,previous_gas=0;\\n        \\n        for(int i=0;i<gas.size();i++)\\n        {\\n            curr_gas=curr_gas+(gas[i]-cost[i]);\\n            if(curr_gas<0)\\n            {\\n                start=i+1;\\n                previous_gas=previous_gas+curr_gas;\\n                curr_gas=0;\\n            }\\n        }\\n        return ((curr_gas+previous_gas)>=0)?(start):-1;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Recursion"
                ],
                "code": "**Please Upvote if you like the Code and Comment down below if you have any query!**\\n\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) \\n    {\\n        int curr_gas=0,start=0,previous_gas=0;\\n        \\n        for(int i=0;i<gas.size();i++)\\n        {\\n            curr_gas=curr_gas+(gas[i]-cost[i]);\\n            if(curr_gas<0)\\n            {\\n                start=i+1;\\n                previous_gas=previous_gas+curr_gas;\\n                curr_gas=0;\\n            }\\n        }\\n        return ((curr_gas+previous_gas)>=0)?(start):-1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 734236,
                "title": "c-o-n-o-1-with-explanation-96-faster",
                "content": "**Idea:**\\nFor `A < B`, if you can\\'t reach `B` from `A`, you can\\'t reach `B` from any point in between `A` and `B` as well (refer to lucifer\\'s comment below). \\nFollowing this idea, we assign a `start` (A) and if at any point `i `(B), if cumulative `gas - cost` becomes negative, it implies we can\\'t reach `i` from `start`. At this point, reset the cumulative `gas - cost` to `0` and make `i + 1`  the `start` (thus skipping all points in between `start` and `i`).\\nAt the end if the journey is at all possible then `start` is the answer.\\ne.g.\\n`gas: [1,2,3,4,5]`\\n`cost: [3,4,5,1,2]`\\n`gas - cost: [-2,-2,-2,3,3]`  -> if the sum of this array is `< 0`, journey is impossible, as the total gas available is less than the total cost.\\n\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size();\\n        int total = 0, tank = 0, start = 0;\\n\\t\\t\\n        for(int i = 0; i < n; i++) {\\n            int diff = gas[i] - cost[i];\\n            total += diff;\\n            tank += diff;\\n            \\n            if(tank < 0) {\\n                start = i + 1;\\n                tank = 0;\\n            }\\n        }\\n        \\n        if(total < 0) return -1;\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size();\\n        int total = 0, tank = 0, start = 0;\\n\\t\\t\\n        for(int i = 0; i < n; i++) {\\n            int diff = gas[i] - cost[i];\\n            total += diff;\\n            tank += diff;\\n            \\n            if(tank < 0) {\\n                start = i + 1;\\n                tank = 0;\\n            }\\n        }\\n        \\n        if(total < 0) return -1;\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011314,
                "title": "easiest-explanation-greedy-approach-short-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int tank=0;\\n        int total=0;\\n        int index=0;\\n\\n        for(int i=0;i<gas.size();i++){\\n            int consume=gas[i]-cost[i];\\n            tank+=consume;\\n            if(tank <0 ){\\n                index=i+1;\\n                tank=0;\\n            }\\n            total+=consume;\\n        }\\n\\n        if(total <0) return -1;\\n        else return index;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int tank=0;\\n        int total=0;\\n        int index=0;\\n\\n        for(int i=0;i<gas.size();i++){\\n            int consume=gas[i]-cost[i];\\n            tank+=consume;\\n            if(tank <0 ){\\n                index=i+1;\\n                tank=0;\\n            }\\n            total+=consume;\\n        }\\n\\n        if(total <0) return -1;\\n        else return index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011230,
                "title": "explained-1ms-solution",
                "content": "This solution first computes the **difference between the amount of gas and the cost** at each station. If the **sum** of this list is **negative**, it means that it is not possible to complete the circuit, so we **return -1**. Otherwise, we iterate through the list and keep track of the current sum **(currentGas)**. If at any point currentGas becomes negative, we know that we cannot complete the circuit starting at the current station, so we **update start to be the next station and reset curr_sum to 0**. When the loop finishes, start will hold the index of the starting gas station that allows us to complete the circuit.\\n\\n##### 1. If the total of gas is less than total of the cost then there doesnt exists a solution.\\n##### 2. If car starts at A and can not reach B. Any station between A and B can not reach B. (B is the first station that A can not reach.) So at this point we change the starting point to B+1.\\n\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) \\n    {\\n        //determine if we have a solution\\n        int total = 0;\\n        for (int i = 0; i < gas.length; i++) \\n        {\\n            total += gas[i] - cost[i];\\n        }\\n        if (total < 0) return -1;\\n   \\n        // find out where to start\\n        int currentGas = 0;\\n        int start = 0;\\n        for (int i = 0; i < gas.length;i++) \\n        {\\n            currentGas += gas[i] - cost[i];\\n            if (currentGas < 0) \\n            {\\n                start = i + 1;\\n                currentGas = 0;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) \\n    {\\n        //determine if we have a solution\\n        int total = 0;\\n        for (int i = 0; i < gas.length; i++) \\n        {\\n            total += gas[i] - cost[i];\\n        }\\n        if (total < 0) return -1;\\n   \\n        // find out where to start\\n        int currentGas = 0;\\n        int start = 0;\\n        for (int i = 0; i < gas.length;i++) \\n        {\\n            currentGas += gas[i] - cost[i];\\n            if (currentGas < 0) \\n            {\\n                start = i + 1;\\n                currentGas = 0;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011052,
                "title": "daily-leetcoding-challenge-january-day-7",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/gas-station/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One pass.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/gas-station/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1707172,
                "title": "detailed-c-intuitive-two-approaches-naive-greedy",
                "content": "**Please Upvote if you Like :)**\\n\\n**Approach 1(TLE) : Naive Approach -> Time Complexity O(N^2)**\\n**TC Passed 34/35**\\n\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int gast=0,cos=0;\\n        int x=gas.size();\\n        for(int i=0;i<gas.size();i++)\\n        {\\n            gast+=gas[i];\\n            cos+=cost[i];\\n        }\\n        if(gast<cos)\\n        {\\n            return -1;\\n        }\\n        for(int i=0;i<gas.size();i++)\\n        {\\n            if(gas[i]>=cost[i])\\n            {\\n                int ans=i;\\n                int stepcount=0,j=i;\\n                int gas_tot=0;\\n                while(stepcount < gas.size())\\n                {\\n                    gas_tot += gas[j % gas.size()] - cost[j % gas.size()];\\n                    stepcount++;\\n                    if(gas_tot < 0)\\n                    {\\n                        break;\\n                    }\\n                    j++;\\n                } \\n                if(gas_tot >= 0 && stepcount == gas.size())\\n                {\\n                    return ans;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n**Approach 2 (AC) : Time Complexity O(N)**\\n\\n```\\n//Credit: Youtube Channel Naresh Gupta\\n\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int ans = 0, total = 0,tank = 0;\\n        for(int i = 0;i < gas.size(); i++)\\n        {\\n            int required = gas[i] - cost[i]; // If +ve then we can reach to the next station\\n            tank += required;\\n            if(tank < 0)\\n            {\\n                ans = i + 1;\\n                tank = 0;\\n            }\\n            total += required; // If at the last this total is -ve then we do not have a solution\\n        }\\n        if(total >= 0)\\n        {\\n            return ans;\\n        }\\n        else\\n        {\\n            return -1;\\n        }\\n    }\\n};\\n\\n\\n/*Some people think that how we are ensuring that we are going circular?\\n\\nThe answer is \\nwhen the total>=0,\\nit means that there exists a solution to the problem (note that there will be a unique solution if solution to the problem exists).\\nThis is because, suppose that at some station in your tour, you have gas[i]-cost[i] is negative, but it will be covered by the gas that remained in tank at some other station where you filled the gas previously (since total>=0 means that availability is greater than demand). So if you can just find the starting point according to what he explained in the video, you can stay assured that circular tour is possible if total>=0 at the end\\n\\nThis is my understanding....\\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int gast=0,cos=0;\\n        int x=gas.size();\\n        for(int i=0;i<gas.size();i++)\\n        {\\n            gast+=gas[i];\\n            cos+=cost[i];\\n        }\\n        if(gast<cos)\\n        {\\n            return -1;\\n        }\\n        for(int i=0;i<gas.size();i++)\\n        {\\n            if(gas[i]>=cost[i])\\n            {\\n                int ans=i;\\n                int stepcount=0,j=i;\\n                int gas_tot=0;\\n                while(stepcount < gas.size())\\n                {\\n                    gas_tot += gas[j % gas.size()] - cost[j % gas.size()];\\n                    stepcount++;\\n                    if(gas_tot < 0)\\n                    {\\n                        break;\\n                    }\\n                    j++;\\n                } \\n                if(gas_tot >= 0 && stepcount == gas.size())\\n                {\\n                    return ans;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\n//Credit: Youtube Channel Naresh Gupta\\n\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int ans = 0, total = 0,tank = 0;\\n        for(int i = 0;i < gas.size(); i++)\\n        {\\n            int required = gas[i] - cost[i]; // If +ve then we can reach to the next station\\n            tank += required;\\n            if(tank < 0)\\n            {\\n                ans = i + 1;\\n                tank = 0;\\n            }\\n            total += required; // If at the last this total is -ve then we do not have a solution\\n        }\\n        if(total >= 0)\\n        {\\n            return ans;\\n        }\\n        else\\n        {\\n            return -1;\\n        }\\n    }\\n};\\n\\n\\n/*Some people think that how we are ensuring that we are going circular?\\n\\nThe answer is \\nwhen the total>=0,\\nit means that there exists a solution to the problem (note that there will be a unique solution if solution to the problem exists).\\nThis is because, suppose that at some station in your tour, you have gas[i]-cost[i] is negative, but it will be covered by the gas that remained in tank at some other station where you filled the gas previously (since total>=0 means that availability is greater than demand). So if you can just find the starting point according to what he explained in the video, you can stay assured that circular tour is possible if total>=0 at the end\\n\\nThis is my understanding....\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019297,
                "title": "javascript-clean-one-pass",
                "content": "```javascript\\nvar canCompleteCircuit = function(gas, cost) {\\n    let start = 0, tank = 0, total = 0;\\n    \\n    for(let i = 0; i < gas.length; i++) {\\n        const consume = gas[i] - cost[i];\\n        tank += consume;\\n\\n        if(tank < 0) {\\n            tank = 0;\\n            start = i + 1;\\n        }\\n        total += consume;\\n    }\\n    return total < 0 ? -1 : start;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar canCompleteCircuit = function(gas, cost) {\\n    let start = 0, tank = 0, total = 0;\\n    \\n    for(let i = 0; i < gas.length; i++) {\\n        const consume = gas[i] - cost[i];\\n        tank += consume;\\n\\n        if(tank < 0) {\\n            tank = 0;\\n            start = i + 1;\\n        }\\n        total += consume;\\n    }\\n    return total < 0 ? -1 : start;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 912256,
                "title": "c-easy-one-pass-solution-with-clear-explanation-memory-o-1",
                "content": "Hi there,\\n\\nAlgorithm explanation:\\n- On each step calculate the diff[i]=gas[i]-cost[i];\\n- If the diff[i] is non-negative, then add it to the sum and set start_index=i, otherwise reset start_index and sum.\\n- Calculate the overall sum that is equal to the sum of the all diff[i].\\n\\nIf the overallsum < 0 then the total amount of gas is not enough to visit all stations: answer is -1.\\nOtherwise start_index is the answer, because we\\'ve visited all of the stations and since overall sum is the positive there must be an answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) \\n    {\\n        assert(gas.size() == cost.size());\\n        \\n        int start_index = -1;\\n        int sum = 0;\\n        int overallsum = 0;\\n        for(int i = 0; i < gas.size(); ++i)\\n        {\\n            gas[i] -= cost[i];\\n            \\n            sum += gas[i];\\n            \\n            if(sum >= 0)\\n            {\\n                if(start_index == -1)\\n                    start_index = i;\\n            }\\n            else\\n            {\\n                sum = 0;\\n                start_index = -1;\\n            }         \\n            \\n            overallsum += gas[i];\\n        }\\n\\n        if(overallsum < 0)\\n            return -1;\\n        \\n        return start_index;\\n    }\\n};\\n```\\n\\nUpvote please, if you find my post useful.\\n\\nCheers",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) \\n    {\\n        assert(gas.size() == cost.size());\\n        \\n        int start_index = -1;\\n        int sum = 0;\\n        int overallsum = 0;\\n        for(int i = 0; i < gas.size(); ++i)\\n        {\\n            gas[i] -= cost[i];\\n            \\n            sum += gas[i];\\n            \\n            if(sum >= 0)\\n            {\\n                if(start_index == -1)\\n                    start_index = i;\\n            }\\n            else\\n            {\\n                sum = 0;\\n                start_index = -1;\\n            }         \\n            \\n            overallsum += gas[i];\\n        }\\n\\n        if(overallsum < 0)\\n            return -1;\\n        \\n        return start_index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860348,
                "title": "java-very-simple-one-o-n-time-with-detailed-explanation",
                "content": "```\\nThe idea is to have enough gas to reach next station, then we will move to next station.\\nOtherwise we will start from next station\\n\\nFirst we take 0th station as our starting station\\nthen, we will fill gas and subtract the cost to reach next station.\\nif filled < 0, this means we are lacking of gas to reach the station.\\nSo, we will start freshly from next station \\nand we will also store the gas required to reach 0th station to ith station \\nbecause we need to circularly reach the starting station. \\nInstead of traversing again from 0th station \\nif we store gas required to reach 0th station to ith station, \\nif we have enough gas, then we will return starting station,\\nOtherwise return -1.\\n```\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int ans = 0, filled = 0, required = 0;\\n        for(int i = 0; i < gas.length; i++){\\n            filled += gas[i] - cost[i];\\n            if(filled < 0){\\n                required += filled;\\n                ans = i + 1;\\n                filled = 0;\\n            }\\n        }\\n        return filled >= Math.abs(required) ? ans : -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nThe idea is to have enough gas to reach next station, then we will move to next station.\\nOtherwise we will start from next station\\n\\nFirst we take 0th station as our starting station\\nthen, we will fill gas and subtract the cost to reach next station.\\nif filled < 0, this means we are lacking of gas to reach the station.\\nSo, we will start freshly from next station \\nand we will also store the gas required to reach 0th station to ith station \\nbecause we need to circularly reach the starting station. \\nInstead of traversing again from 0th station \\nif we store gas required to reach 0th station to ith station, \\nif we have enough gas, then we will return starting station,\\nOtherwise return -1.\\n```\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int ans = 0, filled = 0, required = 0;\\n        for(int i = 0; i < gas.length; i++){\\n            filled += gas[i] - cost[i];\\n            if(filled < 0){\\n                required += filled;\\n                ans = i + 1;\\n                filled = 0;\\n            }\\n        }\\n        return filled >= Math.abs(required) ? ans : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750189,
                "title": "python-greedy-approach-minimum-subarray-sum",
                "content": "I feel like this question is a reversed version of [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/). If we can get the end idx of the minimum subarray, that idx + 1 will be gauranteed to be the correct start point. \\n\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        curr_neg, max_neg, idx = 0, 0, -1\\n        for i in range(len(gas)):\\n            curr_neg += gas[i] - cost[i]\\n            if max_neg > curr_neg:\\n                max_neg = curr_neg\\n                idx = i\\n            \\n        return -1 if curr_neg < 0 else idx + 1\\n```\\n        \\n",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        curr_neg, max_neg, idx = 0, 0, -1\\n        for i in range(len(gas)):\\n            curr_neg += gas[i] - cost[i]\\n            if max_neg > curr_neg:\\n                max_neg = curr_neg\\n                idx = i\\n            \\n        return -1 if curr_neg < 0 else idx + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602419,
                "title": "explained-simple-and-clear-python3-code",
                "content": "# Intuition\\nThe problem requires finding the starting gas station index to complete a circular route while considering the gas and cost at each station. If the total gas available is less than the total cost of traveling, it is impossible to complete the circuit. The solution aims to find a starting station where, if the car starts with an empty tank, it can successfully travel around the circuit in a clockwise direction.\\n\\n\\n# Approach\\nThe solution utilizes a greedy algorithm to solve the problem. It starts by checking if the total gas available is less than the total cost of traveling. If this condition is true, it means there is insufficient gas to complete the circuit, and the solution returns -1 to indicate that it is not possible.\\n\\nAssuming there is enough gas, the solution proceeds by initializing a variable to keep track of the current gas in the tank. It also initializes another variable to store the starting gas station\\'s index if a valid solution is found.\\n\\nNext, the solution iterates over each gas station from 0 to n-1, where n is the length of the gas and cost arrays. In each iteration, it calculates the difference between the gas and cost at the current station. This difference represents the net gas available at that station.\\n\\nTo determine the starting station, the solution accumulates the net gas difference as it moves through the stations. If the accumulated net gas becomes negative at any point, it means the car cannot reach the next station without running out of gas. In such cases, the solution updates the starting station index to the next station (i+1) and resets the accumulated net gas to zero.\\n\\nAfter iterating over all the stations, the solution returns the starting station index stored in the variable res. If a valid solution does not exist, the return value will be -1.\\n\\n# Complexity\\n- Time complexity:\\nThe solution involves a single pass over the gas and cost arrays, resulting in a time complexity of O(n), where n is the length of the arrays.\\n\\n- Space complexity:\\nThe solution uses additional space to store the net gas differences in the diff array. Therefore, the space complexity is O(n) since it requires storing the differences for all n gas stations.\\n# Code\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if sum(gas)<sum(cost):\\n            return -1\\n        n=len(gas)\\n        diff=[gas[i]-cost[i] for i in range(n)]\\n        total=0\\n        res=0\\n        for i in range(n):\\n            total+=diff[i]\\n            if total<0:\\n                res=i+1\\n                total=0\\n        return res\\n                    \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if sum(gas)<sum(cost):\\n            return -1\\n        n=len(gas)\\n        diff=[gas[i]-cost[i] for i in range(n)]\\n        total=0\\n        res=0\\n        for i in range(n):\\n            total+=diff[i]\\n            if total<0:\\n                res=i+1\\n                total=0\\n        return res\\n                    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706945,
                "title": "c-solution-o-n-time-complexity",
                "content": "```\\nint canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int start = 0;\\n        int require = 0,extra = 0;\\n        for(int i=0;i<gas.size();i++){\\n            extra += gas[i] - cost[i];\\n            if(extra < 0){\\n                require += extra;\\n                extra = 0;\\n                start = i + 1;\\n            }\\n        }\\n        if(extra + require >= 0) return start;\\n        return -1;\\n    }\\n\\t//If you like my solution then plz upvote\\n```",
                "solutionTags": [],
                "code": "```\\nint canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int start = 0;\\n        int require = 0,extra = 0;\\n        for(int i=0;i<gas.size();i++){\\n            extra += gas[i] - cost[i];\\n            if(extra < 0){\\n                require += extra;\\n                extra = 0;\\n                start = i + 1;\\n            }\\n        }\\n        if(extra + require >= 0) return start;\\n        return -1;\\n    }\\n\\t//If you like my solution then plz upvote\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 456534,
                "title": "c-two-pointer-approach-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        // Put start pointer at the last station (n-1), and start from there\\n        // Put end pointer at the first station (0).\\n        // Keep track of the total gas left: total_gas = accum(gas[i]-cost[i])\\n        // If total_gas >= 0, this means we have enough gas to move to the next station,\\n        // so we move the end pointer forward: end++\\n        // If total_gas < 0, this means we do not have enough gas, so we need to move\\n        // start pointer backward to obtain gas: start--\\n        // When start and end pointers meet, return -1 if total_gas < 0.\\n        // Otherwise, return start.\\n        int start = gas.size()-1;\\n        int end = 0;\\n        int total_gas = gas[start] - cost[start];\\n        while (end < start) {\\n            if (total_gas >= 0) {\\n                total_gas += gas[end] - cost[end];\\n                end++;\\n            } else {\\n                start--;\\n                total_gas += gas[start] - cost[start];\\n            }\\n        }\\n        return (total_gas < 0) ? -1 : start;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        // Put start pointer at the last station (n-1), and start from there\\n        // Put end pointer at the first station (0).\\n        // Keep track of the total gas left: total_gas = accum(gas[i]-cost[i])\\n        // If total_gas >= 0, this means we have enough gas to move to the next station,\\n        // so we move the end pointer forward: end++\\n        // If total_gas < 0, this means we do not have enough gas, so we need to move\\n        // start pointer backward to obtain gas: start--\\n        // When start and end pointers meet, return -1 if total_gas < 0.\\n        // Otherwise, return start.\\n        int start = gas.size()-1;\\n        int end = 0;\\n        int total_gas = gas[start] - cost[start];\\n        while (end < start) {\\n            if (total_gas >= 0) {\\n                total_gas += gas[end] - cost[end];\\n                end++;\\n            } else {\\n                start--;\\n                total_gas += gas[start] - cost[start];\\n            }\\n        }\\n        return (total_gas < 0) ? -1 : start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203474,
                "title": "c-solution-beats-99-2-4ms-with-explanation",
                "content": "Move forward until reach an appropriate staring point.\\n\\nQ: What is an appropriate staring point? \\nA: where the gas[i]>=cost[i]\\n\\nStart from this point and move forward and check if there is any chance to loop and reach the same index. In case of negative result in the middle, lets update the moving index by the location where the condition is not satisfying (where we have no more gas to move forward).\\nThis is because if on way of moving from source we are locked at location SKIP then there is no way to start from any points between source and location SKIP.\\nFor example in following example, our candidates are the bolded ones. By starting from candidate index 1 (gas[1]=4, cost[1]=2), we stop at location 4 (gas[4]=5 , cost[4]=7 ); so there is no need to check the index 3 (gas[3]=4 , cost[4])\\n\\ngas= [1,**4**,3,**4**,5,**5**]\\ncost = [3,**2**,4,**4**,7,**2**]\\n\\nWith simple optimization, we can skip many previously calculation, in my case my running time reduced from ~160ms to 4 ms\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n      int s= gas.size();     \\n      for (int idx=0; idx< s;++idx) {            \\n          if (gas[idx]<cost[idx]) /* in starting point we should have gas[i]>=cost[i]*/\\n              continue;\\n          \\n          int cnt=0;\\n          int cap =0;\\n          for (cnt=0;cnt<s;++cnt) {\\n              int i = (idx+cnt)%s ;\\n              cap+= gas[i]-cost[i];\\n              if (cap<0) {\\n              /*if the there is no result till index i, lets skip all elements between idx and i. However if (i<idx) means ther ei sno result since we have already checked elements less than idx */    \\n                 if(i<idx)\\n                     return -1;\\n                  else\\n                    idx=i;\\n                  break;\\n              }\\n          }\\n          if(cnt==s)\\n              return idx;\\n  \\n      }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n      int s= gas.size();     \\n      for (int idx=0; idx< s;++idx) {            \\n          if (gas[idx]<cost[idx]) /* in starting point we should have gas[i]>=cost[i]*/\\n              continue;\\n          \\n          int cnt=0;\\n          int cap =0;\\n          for (cnt=0;cnt<s;++cnt) {\\n              int i = (idx+cnt)%s ;\\n              cap+= gas[i]-cost[i];\\n              if (cap<0) {\\n              /*if the there is no result till index i, lets skip all elements between idx and i. However if (i<idx) means ther ei sno result since we have already checked elements less than idx */    \\n                 if(i<idx)\\n                     return -1;\\n                  else\\n                    idx=i;\\n                  break;\\n              }\\n          }\\n          if(cnt==s)\\n              return idx;\\n  \\n      }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141046,
                "title": "python-solution-o-n-time-o-1-extra-space-beat-97",
                "content": "First, you definitely cannot complete the trip if there is more gas required than gas given. That is pretty obvious.\\n\\nThe tricky part is to realize that if you plan carefully, you definitely can complete the trip if there is at least as much gas given as needed.\\n\\nSo how do you pick where to start? First, each station will either give you a gas surplus (if it requires less gas to go to the next station than it has at the station), or a gas deficit (if it\\'s the other way around). So your total gas supply either rises or shrinks as you pass through each station (draw a curve yourself. It will look like a movement of a stock). The most difficult part of the trip is when your gas supply continues to shrink. Now assume your gas can go negative, and you have to start from station 0, the most difficult time is when your gas supply is the lowest (most negative). The trick is to pick the station right after the most difficult time. Then your gas always stays positive!\\n\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas, cost):\\n        \"\"\"\\n        :type gas: List[int]\\n        :type cost: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if sum(gas) < sum(cost):\\n            return -1\\n        tank = 0\\n        min_gas, min_gas_loc = 0, None\\n        for i in range(len(gas)):\\n            tank += gas[i] - cost[i]\\n            if tank < min_gas:\\n                min_gas = tank\\n                min_gas_loc = i\\n        return 0 if min_gas_loc is None else (min_gas_loc + 1) % len(gas)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canCompleteCircuit(self, gas, cost):\\n        \"\"\"\\n        :type gas: List[int]\\n        :type cost: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if sum(gas) < sum(cost):\\n            return -1\\n        tank = 0\\n        min_gas, min_gas_loc = 0, None\\n        for i in range(len(gas)):\\n            tank += gas[i] - cost[i]\\n            if tank < min_gas:\\n                min_gas = tank\\n                min_gas_loc = i\\n        return 0 if min_gas_loc is None else (min_gas_loc + 1) % len(gas)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011628,
                "title": "rust-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe answer is guaranteed to be unique so that we can just find the station where we need gas the most.\\nTo measure the necessary, we can draw a graph with two axis: x-axis is the station index`i` and the y-axis is the prefix-sum of `gas[i] - cost[i]`, which means if we start from the first station, how much gas we have when we got to each station.\\nThen, the lowest point on the graph is the answer we want, because if we start at it, we can have a gas tank with non-negative amount of rest gas when we got to any of other stations.\\nSpecially, if we got a negative amount at the last element of the prefix-sum, it means we can never complete the circle because the total gas is less than the total cost.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. perform `zip` and `map` to get the `gas[i] - cost[i]`, warp with an `enumerate` to get the indices\\n2. `fold` with `(<prefix-sum>, (<lowest point index>, <lowest point value(for comparing)>))`\\n3. check the answer: if the `prefix-sum` is negative, return -1, else return the `lowest point index`\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn can_complete_circuit(gas: Vec<i32>, cost: Vec<i32>) -> i32 {\\n        match gas\\n            .into_iter()\\n            .zip(cost.into_iter())\\n            .map(|(g, c)| g - c)\\n            .enumerate()\\n            .fold((0, (0, 0)), |(s, pass @ (_, vm)), (i, v)| match s + v {\\n                s if s < vm => (s, (i as i32 + 1, s)),\\n                s => (s, pass),\\n            }) {\\n            (s, _) if s < 0 => -1,\\n            (_, (im, _)) => im,\\n        }\\n    }\\n}\\n```\\n- We can use `into_iter` because the vectors are not used any more.\\n- During each iteration in `fold`, first we rebind `s` to the new sum, then compare it to the previous min and determine whether to swap or not. Don\\'t forget to convert i to `i32` because the default index type is `usize`.",
                "solutionTags": [
                    "Rust",
                    "Greedy"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn can_complete_circuit(gas: Vec<i32>, cost: Vec<i32>) -> i32 {\\n        match gas\\n            .into_iter()\\n            .zip(cost.into_iter())\\n            .map(|(g, c)| g - c)\\n            .enumerate()\\n            .fold((0, (0, 0)), |(s, pass @ (_, vm)), (i, v)| match s + v {\\n                s if s < vm => (s, (i as i32 + 1, s)),\\n                s => (s, pass),\\n            }) {\\n            (s, _) if s < 0 => -1,\\n            (_, (im, _)) => im,\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3011143,
                "title": "js-greedy-commented-you-will-get-it",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\nPlease upvote if you found this helpful.\\n\\n# Code\\n```\\nvar canCompleteCircuit = function (gas, cost) { \\n//Return -1 if sum of gas is less than sum of cost.(Need enough gas to cover the cost to home :P)\\n  if (gas.reduce((p, v) => p + v) < cost.reduce((p, v) => p + v)) return -1;\\n\\n  let [tank, start] = [0,0];\\n// Iterate over the gas and cost array. \\n// If a position reached with a tank <0, that means we should\\n// reset the tank and try to start in the next position.\\n  for (let i = 0; i < gas.length; i++) {\\n    tank += gas[i] - cost[i];\\n    if (tank < 0) {\\n      tank = 0;\\n      start = i + 1;\\n    }\\n  }\\n  return start;\\n};\\n```\\n\\n\\n\\n# Refector\\nUsing only one loop, a bit faster.\\n![1.jpg](https://assets.leetcode.com/users/images/1ad6e463-f253-4ef6-8b75-ff93e886e36d_1673054839.1368449.jpeg)\\n# Code\\n```\\nvar canCompleteCircuit = function (gas, cost) {\\n  let [tank, start, sumG, sumC] = [0, 0, 0, 0];\\n  for (let i = 0; i < gas.length; i++) {\\n    sumG += gas[i];\\n    sumC += cost[i];\\n    tank += gas[i] - cost[i];\\n    if (tank < 0) {\\n      tank = 0;\\n      start = i + 1;\\n    }\\n  }\\n  return sumG >= sumC ? start : -1;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canCompleteCircuit = function (gas, cost) { \\n//Return -1 if sum of gas is less than sum of cost.(Need enough gas to cover the cost to home :P)\\n  if (gas.reduce((p, v) => p + v) < cost.reduce((p, v) => p + v)) return -1;\\n\\n  let [tank, start] = [0,0];\\n// Iterate over the gas and cost array. \\n// If a position reached with a tank <0, that means we should\\n// reset the tank and try to start in the next position.\\n  for (let i = 0; i < gas.length; i++) {\\n    tank += gas[i] - cost[i];\\n    if (tank < 0) {\\n      tank = 0;\\n      start = i + 1;\\n    }\\n  }\\n  return start;\\n};\\n```\n```\\nvar canCompleteCircuit = function (gas, cost) {\\n  let [tank, start, sumG, sumC] = [0, 0, 0, 0];\\n  for (let i = 0; i < gas.length; i++) {\\n    sumG += gas[i];\\n    sumC += cost[i];\\n    tank += gas[i] - cost[i];\\n    if (tank < 0) {\\n      tank = 0;\\n      start = i + 1;\\n    }\\n  }\\n  return sumG >= sumC ? start : -1;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3011068,
                "title": "java-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n\\n        int n = gas.length;\\n\\n        //total surplus during the whole journey\\n        int total  = 0;\\n        \\n        // our tank        \\n        int gasAvailable = 0;\\n\\n        int index = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            total  += gas[i] - cost[i];\\n            gasAvailable += gas[i] - cost[i];\\n            \\n            // if the tank goes -ve\\n            if(gasAvailable < 0){\\n                gasAvailable = 0;\\n                index = i + 1;\\n            }\\n        }\\n        \\n        return (total  < 0) ? -1 : index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n\\n        int n = gas.length;\\n\\n        //total surplus during the whole journey\\n        int total  = 0;\\n        \\n        // our tank        \\n        int gasAvailable = 0;\\n\\n        int index = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            total  += gas[i] - cost[i];\\n            gasAvailable += gas[i] - cost[i];\\n            \\n            // if the tank goes -ve\\n            if(gasAvailable < 0){\\n                gasAvailable = 0;\\n                index = i + 1;\\n            }\\n        }\\n        \\n        return (total  < 0) ? -1 : index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395794,
                "title": "python-very-simple-o-n-solution-with-explanation",
                "content": "# Explanation\\n\\nThe initial approach is to try every single curcuit possible, and then stop when the car can\\'t make it. That is quadratic complexity, so let\\'s try and optimize it. In our brute force solution, we are wasting a LOT of time:\\n\\nSay you are at index 0, and you run out of fuel on the way from index 2 to 3\\n```\\n0----1----2----3----4\\n* ---------> x\\n```\\n\\nSince there isn\\'t enough fuel for you to get from `0` to `3`, but it is possible to get from `0` to `2`, that means that there is *always* a surplus of fuel from `0` to `2`. \\n\\nHowever, this means that we **don\\'t have to try starting from `1` or `2`**. We can\\'t make it to `3` **even with a surplus**, so obviously we can\\'t make it to `3` *without a surplus*. So, we can just try starting from index `3` instead.\\n\\nIn the brute force solution, we are still trying the starting points that we don\\'t have to. The new optimized `O(n)` solution fixes that:\\n\\nEverytime the amount of gas in the tank drops below 0, we only have to try the next gas station (station `i+1`, where `i` is the position the car is at).\\n\\n`n is the length of array gas`\\nTime complexity: O(n)\\\\\\nSpace complexity: O(1)\\n```py\\nclass Solution(object):\\n    def canCompleteCircuit(self, gas, cost):\\n        \"\"\"\\n        :type gas: List[int]\\n        :type cost: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if sum(gas) < sum(cost): \\n            return -1\\n        \\n        start = 0\\n        cur_gas = 0\\n        for i in range(len(gas)):\\n            cur_gas += gas[i] - cost[i]\\n            if cur_gas < 0:\\n                start = i+1\\n                cur_gas = 0\\n\\n        return start\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n0----1----2----3----4\\n* ---------> x\\n```\n```py\\nclass Solution(object):\\n    def canCompleteCircuit(self, gas, cost):\\n        \"\"\"\\n        :type gas: List[int]\\n        :type cost: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if sum(gas) < sum(cost): \\n            return -1\\n        \\n        start = 0\\n        cur_gas = 0\\n        for i in range(len(gas)):\\n            cur_gas += gas[i] - cost[i]\\n            if cur_gas < 0:\\n                start = i+1\\n                cur_gas = 0\\n\\n        return start\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706569,
                "title": "simple-o-n-greedy-solution-faster-than-94",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int curTank = 0;\\n        int startingPoint = 0;\\n        for(int i = 0; i < gas.size(); i++) {\\n            curTank += gas[i] - cost[i];\\n            if(curTank < 0) {\\n                startingPoint = i+1;\\n                curTank = 0;\\n            }\\n        }\\n        for(int i = 0; i < startingPoint; i++) {\\n            curTank += gas[i] - cost[i];\\n            if(curTank < 0) return -1;\\n        }\\n        return startingPoint;\\n    }\\n};\\n```\\n\\nPseudo Code\\n\\nTraverse through array\\n\\t-check whether starting point is feasible\\n\\t-if not set the starting point to the next point\\n\\t-check until the end of the array\\n\\t\\ncheck whether you can reach the starting point from zero index with current tank\\n  -if not -> return -1;\\n  -else return starting point",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int curTank = 0;\\n        int startingPoint = 0;\\n        for(int i = 0; i < gas.size(); i++) {\\n            curTank += gas[i] - cost[i];\\n            if(curTank < 0) {\\n                startingPoint = i+1;\\n                curTank = 0;\\n            }\\n        }\\n        for(int i = 0; i < startingPoint; i++) {\\n            curTank += gas[i] - cost[i];\\n            if(curTank < 0) return -1;\\n        }\\n        return startingPoint;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280704,
                "title": "c-o-n-beats-100-with-explanation-and-proof",
                "content": "**Greedy Approach**\\nTwo main intuitions that are to be used in our solution are:-\\n1. If a gas station has less gas than the cost to go to next station, then it cannot be starting point. \\n2. If the total sum of gas[i]-cost[i] for all i is negative, then starting an any station will not  be possible.\\n\\nNow, in the algorithm, we assume the initial solution to be station 0 and keep a count of the gas in its tank. If at any point the gas becomes 0, then we take the next station(from current index) as our new starting station and also keep updating the total cumulative sum in total_tank which at the end tells us whether a solution is even possible or not.\\n\\nWhen we get a positive total tank at the end, we can say that the starting station that we assume is indeed the starting staion. This is because of the following proof:-\\nlet sum(i,j) denote the sum of gas(k)-cost(k) from i to j.\\n\\nLet Ns be starting point, N be last station. Now for our solution to be proved wrong, it is sufficient to find one staion from 0 to Ns-1 that is not reachable from Ns. Let this station be k.\\nThen according to our solution, \\nWe already know the following:-\\n1. sum(0,N)>=0 since a solution exists.\\n2. sum(Ns, N)>=0 as we found a solution\\n3. Now sum(0,N)=sum(0,k) +sum(k+1, Ns-1)+sum(Ns,N).\\n4. Also if we are stating that k is not reachable from Ns, then it means that sum(Ns,N)+sum(0,k)<0.\\n5. Also sum(k+1,Ns)<0. Otherwise, starting point would be before Ns.\\nCombinning these relations leads to k fall into two disjoint subsets which means no possible k exists. Hence Ns is our unique solution.\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int starting_point=0, curr_tank=0, total_tank=0;\\n        for(int i=0;i<cost.size();i++)\\n        {\\n            curr_tank+=gas[i]-cost[i];\\n            total_tank+=gas[i]-cost[i];\\n            if(curr_tank<0)\\n            {\\n                starting_point=i+1;\\n                curr_tank=0;\\n            }\\n        }\\n        return total_tank>=0?starting_point:-1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int starting_point=0, curr_tank=0, total_tank=0;\\n        for(int i=0;i<cost.size();i++)\\n        {\\n            curr_tank+=gas[i]-cost[i];\\n            total_tank+=gas[i]-cost[i];\\n            if(curr_tank<0)\\n            {\\n                starting_point=i+1;\\n                curr_tank=0;\\n            }\\n        }\\n        return total_tank>=0?starting_point:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 943020,
                "title": "java-few-lines-very-easy-to-understand-o-n-and-o-1",
                "content": "```\\nclass Solution {\\n  public int canCompleteCircuit(int[] gas, int[] cost) {\\n    int running = 0;\\n    int max = Integer.MIN_VALUE;\\n    int maxIndex = -1;\\n\\n    for (int i = gas.length - 1; i >= 0; i--) {\\n      running += gas[i] - cost[i];\\n      if (running > max) {\\n        max = running;\\n        maxIndex = i;\\n      }\\n    }\\n    return running < 0 ? -1 : maxIndex;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n  public int canCompleteCircuit(int[] gas, int[] cost) {\\n    int running = 0;\\n    int max = Integer.MIN_VALUE;\\n    int maxIndex = -1;\\n\\n    for (int i = gas.length - 1; i >= 0; i--) {\\n      running += gas[i] - cost[i];\\n      if (running > max) {\\n        max = running;\\n        maxIndex = i;\\n      }\\n    }\\n    return running < 0 ? -1 : maxIndex;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860343,
                "title": "java-simple-clear-explained-solution-o-n-time-o-1-space-0-ms",
                "content": "1. If sum of gas is less than sum of cost, then there is no way to get through all stations. So while we loop through the stations we sum up, so that at the end we can check the sum.\\n2. Otherwise, there must be one unique solution, so the first one I find is the right one. If the tank becomes negative, we restart because that can\\'t happen.\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int gas_tank = 0, start_index = 0, n = gas.length, sum = 0;\\n        \\n        for (int i=0; i<n; i++) {\\n            \\n            sum += gas[i] - cost[i];\\n            gas_tank += gas[i] - cost[i];\\n            \\n            if (gas_tank < 0) {\\n                start_index = i+1;\\n                gas_tank = 0;\\n            }\\n            \\n        }\\n        return sum < 0 ? -1 : start_index;\\n    }\\n}\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int gas_tank = 0, start_index = 0, n = gas.length, sum = 0;\\n        \\n        for (int i=0; i<n; i++) {\\n            \\n            sum += gas[i] - cost[i];\\n            gas_tank += gas[i] - cost[i];\\n            \\n            if (gas_tank < 0) {\\n                start_index = i+1;\\n                gas_tank = 0;\\n            }\\n            \\n        }\\n        return sum < 0 ? -1 : start_index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860310,
                "title": "python-3-clean-greedy-o-n-explanation",
                "content": "### Intuition\\n- Since the answer is unique, there is only one place to start. \\n- Intuitively, we want to have enough gas at start and (maybe) use up the gas when arrive the destination\\n- That is saying we want to keep the max cost at the end, since its a circular route\\n\\t- we can find the max cost (minimum of **cumulated** `gas[i]-cost[i]`)\\n\\t- and start from the next station of that\\n- This process is considered as **Greedy** because we want to travel as far as we can, we take gas as much as the gas station can offer\\n- Time complexity: `O(n)`\\n### Implementation\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        diff = [g-c for g, c in zip(gas, cost)]       # get difference between gas & cost\\n        idx, min_val, cur = 0, sys.maxsize, 0         # get cumulative sum and find the smallest, the place after the smallest idx will be where we start\\n        for i, v in enumerate(diff):\\n            cur += v \\n            if cur <= min_val: min_val, idx = cur, i  # maintain smallest & its index\\n        return (idx+1)%len(diff) if cur >= 0 else -1  # if total sum is less than 0, meaning no possible place to start\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        diff = [g-c for g, c in zip(gas, cost)]       # get difference between gas & cost\\n        idx, min_val, cur = 0, sys.maxsize, 0         # get cumulative sum and find the smallest, the place after the smallest idx will be where we start\\n        for i, v in enumerate(diff):\\n            cur += v \\n            if cur <= min_val: min_val, idx = cur, i  # maintain smallest & its index\\n        return (idx+1)%len(diff) if cur >= 0 else -1  # if total sum is less than 0, meaning no possible place to start\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325315,
                "title": "if-you-are-stuck-like-me-read-this-solution",
                "content": "![image](https://assets.leetcode.com/users/gulshan98125/image_1562063384.png)\\n\\n- We start with position= 0 with tank=0\\n- We go through stations index i from \"0 to len(arr)-1\" and doing tank+= gas[i]-cost[i]\\n- Whenever we find that tank < 0 after doing the above (tank+= gas[i]-cost[i]), it means :\\n\\t- and we cannot go from i to i+1.\\n    - we can reach at max to index i starting from position with empty tank\\n\\t- we require this negative tank amount of fuel to go from i to i+1\\n- We add this negative tank value \"dark shaded portions in image\" to variable requiredFuel because it is the extra fuel we require at index i to just reach to i+1\\n- We repeat with position=i+1 and tank=0 and doing the same thing for the remaining array\\n- Suppose there was a position=k+1 as in image, from where after completing the process for the end index we have tank >0, it means that we can go from k+1 to 0 with some_fuel still left in the tank.\\n\\t- Now we are at index 0\\n\\t- we know that these dark shaded portions are the extra amount of fuel required at index 0 to go from index 0 to index k+1\\n\\t- so we just need to check that if tank+requiredFuel>=0 then we can cover these dark portions in image So we return position. Otherwise there is no path so we return -1\\n\\n\\n**Python code:**\\n```\\ndef canCompleteCircuit(self, gas, cost):\\n\\tposition = 0\\n\\ttank = 0 # current tank balance\\n\\trequiredFuel = 0\\n\\tfor i in range(len(gas)):\\n\\t\\ttank += gas[i] - cost[i] # update tank\\n\\t\\tif tank < 0: # balance drops to negative, reset the start position\\n\\t\\t\\tposition = i+1\\n\\t\\t\\trequiredFuel+=tank\\n\\t\\t\\ttank = 0\\n\\n\\tif (tank+requiredFuel>=0):\\n\\t\\treturn position\\n\\telse:\\n\\t\\treturn -1\\n```",
                "solutionTags": [],
                "code": "```\\ndef canCompleteCircuit(self, gas, cost):\\n\\tposition = 0\\n\\ttank = 0 # current tank balance\\n\\trequiredFuel = 0\\n\\tfor i in range(len(gas)):\\n\\t\\ttank += gas[i] - cost[i] # update tank\\n\\t\\tif tank < 0: # balance drops to negative, reset the start position\\n\\t\\t\\tposition = i+1\\n\\t\\t\\trequiredFuel+=tank\\n\\t\\t\\ttank = 0\\n\\n\\tif (tank+requiredFuel>=0):\\n\\t\\treturn position\\n\\telse:\\n\\t\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 42680,
                "title": "clean-o-n-python-solution",
                "content": "    class Solution(object):\\n        def canCompleteCircuit(self, gas, cost):\\n            \"\"\"\\n            :type gas: List[int]\\n            :type cost: List[int]\\n            :rtype: int\\n            \"\"\"\\n            start = rest = overall = 0\\n            for i in xrange(len(gas)):\\n                rest += gas[i] - cost[i]\\n                overall += gas[i] - cost[i]\\n                if rest < 0:\\n                    rest, start = 0, i + 1\\n            return start if overall >=0 else -1",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def canCompleteCircuit(self, gas, cost):\\n            \"\"\"\\n            :type gas: List[int]\\n            :type cost: List[int]\\n            :rtype: int\\n            \"\"\"\\n            start = rest = overall = 0\\n            for i in xrange(len(gas)):\\n                rest += gas[i] - cost[i]\\n                overall += gas[i] - cost[i]\\n                if rest < 0:\\n                    rest, start = 0, i + 1\\n            return start if overall >=0 else -1",
                "codeTag": "Java"
            },
            {
                "id": 42703,
                "title": "find-the-minimum-then-you-are-done",
                "content": "    class Solution {\\n    public:\\n        int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {\\n            int loc = 0;\\n            int sum=0;\\n            int min=INT_MAX;\\n            //find the minimum \\n            for(int i =0; i<gas.size(); ++i){\\n                sum+=gas[i]-cost[i];\\n                if(sum<min){\\n                    min = sum;\\n                    loc=i;\\n                }\\n            }\\n            \\n            if(sum>=0) return (loc+1)%gas.size();\\n            else return -1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {\\n            int loc = 0;\\n            int sum=0;\\n            int min=INT_MAX;\\n            //find the minimum \\n            for(int i =0; i<gas.size(); ++i){\\n                sum+=gas[i]-cost[i];\\n                if(sum<min){\\n                    min = sum;\\n                    loc=i;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3012255,
                "title": "python-greedy-solution-faster-than-99-with-explanation",
                "content": "# 134. Gas Station\\nThe canCompleteCircuit method takes in two lists of integers. The method returns an integer representing the starting station from which a circular tour can be completed, or -1 if such a tour is not possible.\\n\\nThe method first checks if the total amount of gas is less than the total cost of the trip. If it is, it returns -1.\\n\\nIt then initializes three variables:\\n- current_tank: a variable representing the current amount of gas in the tank\\n- starting_station: a variable representing the starting station\\n- num_stations: a variable representing the number of stations\\n\\nIt then iterates through the gas and cost lists. For each station, it updates current_tank by the difference between the gas and cost at that station. If current_tank becomes negative, it updates starting_station to the next station and resets current_tank to 0.\\n\\nFinally, after all the stations have been processed, it returns starting_station.\\n# Code\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        # return -1 if the total gas is less than the total cost\\n        if sum(gas) < sum(cost):\\n            return -1\\n\\n        current_tank, starting_station, num_stations = 0, 0, len(gas)\\n        for station in range(num_stations):\\n            current_tank += gas[station] - cost[station]\\n            # if current_tank is negative, update starting_station to the next station\\n            # and reset current_tank to 0\\n            if current_tank < 0:\\n                starting_station = station + 1\\n                current_tank = 0 \\n        \\n        # return starting_station\\n        return starting_station\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        # return -1 if the total gas is less than the total cost\\n        if sum(gas) < sum(cost):\\n            return -1\\n\\n        current_tank, starting_station, num_stations = 0, 0, len(gas)\\n        for station in range(num_stations):\\n            current_tank += gas[station] - cost[station]\\n            # if current_tank is negative, update starting_station to the next station\\n            # and reset current_tank to 0\\n            if current_tank < 0:\\n                starting_station = station + 1\\n                current_tank = 0 \\n        \\n        # return starting_station\\n        return starting_station\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011495,
                "title": "simple-brute-force-small-optimization-with-images-easy-to-understand",
                "content": "Just do a brute force cyclic traversal from each index, but with a **small optimization**\\n![image](https://assets.leetcode.com/users/images/ec383eba-cbb5-4df9-be2c-c3c3b8a9b3e7_1673063411.3091168.jpeg)\\n![image](https://assets.leetcode.com/users/images/0b042bb6-6e6e-4f3a-b424-eabf54bec2b0_1673063421.4989889.jpeg)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int getBestReachableIdx(vector<int>&gas, vector<int>&cost, int startIdx)\\n    {\\n        int n = gas.size(), currIdx = (startIdx + 1) % n;\\n        int gasLeft = gas[startIdx] - cost[startIdx];\\n        if (gasLeft < 0) return -1;\\n        \\n        while(currIdx != startIdx)\\n        {\\n            gasLeft += gas[currIdx];\\n\\n            int reqGas = cost[currIdx];\\n            if (gasLeft >= reqGas) gasLeft -= reqGas;\\n            else if (gasLeft < reqGas) break;   \\n            \\n            currIdx = (currIdx + 1) % n;\\n        }\\n        return currIdx;\\n    }\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) \\n    {\\n        int n = gas.size();\\n        int currIdx = 0;\\n        while(currIdx < n)\\n        {\\n            int bestReachableIdx = getBestReachableIdx(gas, cost, currIdx);\\n            if (bestReachableIdx == currIdx) return currIdx;\\n            else if (bestReachableIdx > currIdx) currIdx = bestReachableIdx + 1; //optimization step\\n            else if ((bestReachableIdx == -1) || (bestReachableIdx < currIdx))  currIdx++;\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getBestReachableIdx(vector<int>&gas, vector<int>&cost, int startIdx)\\n    {\\n        int n = gas.size(), currIdx = (startIdx + 1) % n;\\n        int gasLeft = gas[startIdx] - cost[startIdx];\\n        if (gasLeft < 0) return -1;\\n        \\n        while(currIdx != startIdx)\\n        {\\n            gasLeft += gas[currIdx];\\n\\n            int reqGas = cost[currIdx];\\n            if (gasLeft >= reqGas) gasLeft -= reqGas;\\n            else if (gasLeft < reqGas) break;   \\n            \\n            currIdx = (currIdx + 1) % n;\\n        }\\n        return currIdx;\\n    }\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) \\n    {\\n        int n = gas.size();\\n        int currIdx = 0;\\n        while(currIdx < n)\\n        {\\n            int bestReachableIdx = getBestReachableIdx(gas, cost, currIdx);\\n            if (bestReachableIdx == currIdx) return currIdx;\\n            else if (bestReachableIdx > currIdx) currIdx = bestReachableIdx + 1; //optimization step\\n            else if ((bestReachableIdx == -1) || (bestReachableIdx < currIdx))  currIdx++;\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011249,
                "title": "video",
                "content": "# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/YrKBTFym61M\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nvar canCompleteCircuit = function(gas, cost) {\\n    let n = gas.length\\n\\n    let start = n - 1\\n    let end = 0\\n    gasInTank = gas[start] - cost[start]\\n    while (start >= end) {\\n        if (gasInTank >= 0) {\\n            gasInTank += gas[end] - cost[end]\\n            end++\\n        }\\n        else {\\n            start--\\n            gasInTank += gas[start] - cost[start]\\n        }\\n    }\\n    return gasInTank >= 0 ? start : -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canCompleteCircuit = function(gas, cost) {\\n    let n = gas.length\\n\\n    let start = n - 1\\n    let end = 0\\n    gasInTank = gas[start] - cost[start]\\n    while (start >= end) {\\n        if (gasInTank >= 0) {\\n            gasInTank += gas[end] - cost[end]\\n            end++\\n        }\\n        else {\\n            start--\\n            gasInTank += gas[start] - cost[start]\\n        }\\n    }\\n    return gasInTank >= 0 ? start : -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3011142,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        int total_cost=0;\\n        int total_gas=0;\\n        \\n        for(int i=0;i<n;i++){\\n            total_cost+=cost[i];\\n            total_gas+=gas[i];\\n        }\\n        \\n        if(total_gas<total_cost){\\n            return -1;\\n        } \\n        int ans=0;\\n        int currfuel=0;\\n        for(int i=0;i<n;i++){\\n            currfuel+=(gas[i]-cost[i]);\\n            if(currfuel<0){\\n                ans=i+1;\\n                currfuel=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        int total_cost=0;\\n        int total_gas=0;\\n        \\n        for(int i=0;i<n;i++){\\n            total_cost+=cost[i];\\n            total_gas+=gas[i];\\n        }\\n        \\n        if(total_gas<total_cost){\\n            return -1;\\n        } \\n        int ans=0;\\n        int currfuel=0;\\n        for(int i=0;i<n;i++){\\n            currfuel+=(gas[i]-cost[i]);\\n            if(currfuel<0){\\n                ans=i+1;\\n                currfuel=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706410,
                "title": "java-beginner-friendly-solution-2ms-simple-logic",
                "content": "```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int reserve = 0;\\n        int n = gas.length;\\n        int totalGas = 0;\\n        int totalCost = 0;\\n        for (int i = 0; i < n; i++) {\\n            totalCost += cost[i];\\n            totalGas += gas[i];\\n        }\\n        if (totalCost > totalGas) {\\n            return -1;\\n        }\\n        int index = 0;\\n        for (int i = 0; i < n; i++) {\\n            reserve += (gas[i] - cost[i]);\\n            if (reserve < 0) {\\n                reserve = 0;\\n                index = i + 1;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```\\n\\nPlz Comment down if you have any Doubts ..\\nThank you!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int reserve = 0;\\n        int n = gas.length;\\n        int totalGas = 0;\\n        int totalCost = 0;\\n        for (int i = 0; i < n; i++) {\\n            totalCost += cost[i];\\n            totalGas += gas[i];\\n        }\\n        if (totalCost > totalGas) {\\n            return -1;\\n        }\\n        int index = 0;\\n        for (int i = 0; i < n; i++) {\\n            reserve += (gas[i] - cost[i]);\\n            if (reserve < 0) {\\n                reserve = 0;\\n                index = i + 1;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633768,
                "title": "simplest-solution-you-can-find-o-n-o-1-c-explained",
                "content": "res : Result index\\nexgas : Extra Gas we have remaining after reaching each gas station\\nregas : Required gas \\n\\nConsider the following numbers in this format: (Gas at station, Cost to reach next station) for DRY RUN\\n\\n    1.   2.    3.    4.    5.   6\\n(7,6) , (8,7) , (5,8) , (11,9) , (7,7) , (6,5)\\n\\nWe will traverse from point 1 to 2, then 2 to 3 and so on.\\n\\nOn every traversal, we can update the extra gas that we have left from the last station, ie,\\nexgas += gas_at_current_station - distance_to_reach_next_station\\n\\nThe only trick you need to understand here is that :\\nOnce we reach a point where we cannot reach the next station even after using exgas, then the starting position cannot be any previous stations and will be the any of the next stations ONLY. \\nSo update the exgas as 0, because now we will consider the next station as our starting point.\\n\\nThen we will simply update the regas (REQUIRED GAS), so that once we reach the end and start traversing from the start to the result index we can simply check the regas and know how much extra gas we would need inorder to do the traversal (since we failed before).\\n\\nSo now we will simply check if adding the current extra gas to the required gas gives the +ve result, showing whether we\\'ll be able to traverse or not.\\n\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int res = 0;\\n        int exgas = 0;\\n        int regas = 0;\\n        int n = gas.size();\\n        for(int i=0;i<n;i++){\\n            exgas += (gas[i] - cost[i]);\\n            if(exgas < 0){\\n                res = i+1;\\n                regas += exgas;\\n                exgas = 0;\\n            }\\n        }\\n        \\n        if(regas+exgas >= 0) return res;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int res = 0;\\n        int exgas = 0;\\n        int regas = 0;\\n        int n = gas.size();\\n        for(int i=0;i<n;i++){\\n            exgas += (gas[i] - cost[i]);\\n            if(exgas < 0){\\n                res = i+1;\\n                regas += exgas;\\n                exgas = 0;\\n            }\\n        }\\n        \\n        if(regas+exgas >= 0) return res;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531937,
                "title": "c-single-pass-greedy",
                "content": "```\\n int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int totalSurplus=0,curSurplus=0,st=0;\\n        int n=gas.size();\\n        for(int i=0;i<n;i++){\\n            totalSurplus+=gas[i]-cost[i];\\n            curSurplus+=gas[i]-cost[i];\\n            if(curSurplus<0){\\n                curSurplus=0;\\n                st=i+1;\\n            }\\n        }\\n        return (totalSurplus<0)?-1:st;\\n    }",
                "solutionTags": [],
                "code": "```\\n int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int totalSurplus=0,curSurplus=0,st=0;\\n        int n=gas.size();\\n        for(int i=0;i<n;i++){\\n            totalSurplus+=gas[i]-cost[i];\\n            curSurplus+=gas[i]-cost[i];\\n            if(curSurplus<0){\\n                curSurplus=0;\\n                st=i+1;\\n            }\\n        }\\n        return (totalSurplus<0)?-1:st;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 861243,
                "title": "greedy-approach-o-n-time-complexity",
                "content": "**Explaination** :\\n\\n1. Gas[i] will add to our tank, and cost[i] will substract from our tank.\\n2. To be able to complete the circuit, one must have this value (gas[i] -cost[i] , lets call it val[i]) always greater than equal (>=) to 0 at each i. \\n3. And we can travel only towards right (and then back to beginning index).\\n\\n**Approach** :\\n\\nIf we assume some middle element (say index 4) is the answer. Then val[4]+ val[5] +..+val[n] + val[0] + va[1] + ... + val[3] is what car circular routes might look like. And at not point should this cumulative sum becomes negative. (or else, this is not the right route , as your tank is empty in between)\\n\\n\\n( val[4] +.. + val[n] ) = Sum of the first part of our route : must be a positive sum.\\nAnd there should be no negative value in this cumulative sum  ( let call it Sum-First-Part)\\n\\n***Hint 1***: We can try storing backward cumulative sum in an array.\\n\\t\\t\\tWe travel this array from backward and find the least index that has all positives values at and after it.\\n\\t\\t\\teg : backward cum sum array[] : 0 1 -2 2 1 1\\n\\t\\t\\tWe get the index 3 as all values are positive at index 3 and also after it (index 4, 5)\\n\\nAnd this is the result also\\n\\n\\tint mx = 0, pos= 0;\\n\\tfor (int i = len - 1; i >= 0; i--) {\\n        sum += (gas[i] - cost[i]);\\n        if (sum >= mx) mx = sum, pos = i; // finding the greatest val in backward cumulative sum\\n    }\\n\\n    if (sum < 0)\\n        return -1;\\n\\n    return pos;\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\n\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "**Explaination** :\\n\\n1. Gas[i] will add to our tank, and cost[i] will substract from our tank.\\n2. To be able to complete the circuit, one must have this value (gas[i] -cost[i] , lets call it val[i]) always greater than equal (>=) to 0 at each i. \\n3. And we can travel only towards right (and then back to beginning index).\\n\\n**Approach** :\\n\\nIf we assume some middle element (say index 4) is the answer. Then val[4]+ val[5] +..+val[n] + val[0] + va[1] + ... + val[3] is what car circular routes might look like. And at not point should this cumulative sum becomes negative. (or else, this is not the right route , as your tank is empty in between)\\n\\n\\n( val[4] +.. + val[n] ) = Sum of the first part of our route : must be a positive sum.\\nAnd there should be no negative value in this cumulative sum  ( let call it Sum-First-Part)\\n\\n***Hint 1***: We can try storing backward cumulative sum in an array.\\n\\t\\t\\tWe travel this array from backward and find the least index that has all positives values at and after it.\\n\\t\\t\\teg : backward cum sum array[] : 0 1 -2 2 1 1\\n\\t\\t\\tWe get the index 3 as all values are positive at index 3 and also after it (index 4, 5)\\n\\nAnd this is the result also\\n\\n\\tint mx = 0, pos= 0;\\n\\tfor (int i = len - 1; i >= 0; i--) {\\n        sum += (gas[i] - cost[i]);\\n        if (sum >= mx) mx = sum, pos = i; // finding the greatest val in backward cumulative sum\\n    }\\n\\n    if (sum < 0)\\n        return -1;\\n\\n    return pos;\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 860355,
                "title": "c-super-simple-clear-explained-solution-o-n-o-1",
                "content": "1. If sum of gas is less than sum of cost, then there is no way to get through all stations. So while we loop through the stations we sum up, so that at the end we can check the sum.\\n2. Otherwise, there must be one unique solution, so the first one I find is the right one. If the tank becomes negative, we restart because that can\\'t happen.\\n```\\nint canCompleteCircuit(int* gas, int gasSize, int* cost, int costSize){\\n    int gas_tank = 0, start_index = 0, sum = 0;\\n        \\n        for (int i=0; i<costSize; i++) {\\n            \\n            sum += gas[i] - cost[i];\\n            gas_tank += gas[i] - cost[i];\\n            \\n            if (gas_tank < 0) {\\n                start_index = i+1;\\n                gas_tank = 0;\\n            }\\n            \\n        }\\n        return sum < 0 ? -1 : start_index;\\n}\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint canCompleteCircuit(int* gas, int gasSize, int* cost, int costSize){\\n    int gas_tank = 0, start_index = 0, sum = 0;\\n        \\n        for (int i=0; i<costSize; i++) {\\n            \\n            sum += gas[i] - cost[i];\\n            gas_tank += gas[i] - cost[i];\\n            \\n            if (gas_tank < 0) {\\n                start_index = i+1;\\n                gas_tank = 0;\\n            }\\n            \\n        }\\n        return sum < 0 ? -1 : start_index;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 855861,
                "title": "java-greedy-brute-force",
                "content": "Method 1: Brute force O(n^2)\\n\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int n = gas.length;\\n        for(int i=0;i<n;i++){\\n            if(gas[i] < cost[i]) continue;\\n            if(solve(i,n,gas,cost) == i) return i;\\n        }\\n        return -1;\\n    }\\n    \\n    int solve(int start, int n, int[]gas, int[]cost){\\n        int j = (start+1) % n, curr_gas = gas[start]-cost[start];\\n        while(j != start){\\n            curr_gas = curr_gas + gas[j] - cost[j];\\n            if(curr_gas < 0) break;\\n            j = (j+1) % n;\\n        }\\n        return j==start ? start : -1;\\n    }\\n}\\n```\\n\\n\\nMethod 2 : Greedy-> O(n)\\nTwo observations : \\n\\ti) If car starts at A and can not reach B. Any station between A and B can not reach B.\\n\\tii) sum(gas) < sum(cost) then No solution exist\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int n = gas.length,start=0;\\n        int gas_sum=0, cost_sum=0, tank=0;\\n        for(int i=0;i<n;i++){\\n            gas_sum += gas[i];\\n            cost_sum += cost[i];\\n            tank += gas[i] - cost[i];\\n            if(tank < 0){\\n                start = i+1;\\n                tank = 0;\\n            }\\n        }\\n        return gas_sum < cost_sum ? -1 : start;\\n    }   \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int n = gas.length;\\n        for(int i=0;i<n;i++){\\n            if(gas[i] < cost[i]) continue;\\n            if(solve(i,n,gas,cost) == i) return i;\\n        }\\n        return -1;\\n    }\\n    \\n    int solve(int start, int n, int[]gas, int[]cost){\\n        int j = (start+1) % n, curr_gas = gas[start]-cost[start];\\n        while(j != start){\\n            curr_gas = curr_gas + gas[j] - cost[j];\\n            if(curr_gas < 0) break;\\n            j = (j+1) % n;\\n        }\\n        return j==start ? start : -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int n = gas.length,start=0;\\n        int gas_sum=0, cost_sum=0, tank=0;\\n        for(int i=0;i<n;i++){\\n            gas_sum += gas[i];\\n            cost_sum += cost[i];\\n            tank += gas[i] - cost[i];\\n            if(tank < 0){\\n                start = i+1;\\n                tank = 0;\\n            }\\n        }\\n        return gas_sum < cost_sum ? -1 : start;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42688,
                "title": "my-simple-c-o-n-solution",
                "content": "    class Solution {\\n    public:\\n        int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n            vector<int> diff;\\n            int size = gas.size();\\n            for(int i=0; i<size; i++) {\\n                diff.push_back(gas[i]-cost[i]);\\n            }\\n            for(int i=0; i<size; i++) {\\n                if(diff[i]>=0) {\\n                    int sum = 0, count = 0;\\n                    while(sum>=0&&count<size) {\\n                        sum += diff[(i+count)%size];\\n                        count++;\\n                    }\\n                    if(count==size&&sum>=0) return i;\\n                    else i = i+count-1;\\n                }\\n            }\\n            return -1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n            vector<int> diff;\\n            int size = gas.size();\\n            for(int i=0; i<size; i++) {\\n                diff.push_back(gas[i]-cost[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3014023,
                "title": "easy-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        rem=0\\n        st=0\\n        t_gas=0\\n        for p in range(len(gas)):\\n            dif=gas[p]-cost[p]\\n            t_gas+=dif\\n            rem+=dif\\n            if rem<0:\\n                st=p+1\\n                rem=0\\n        else: return st if abs(t_gas)==t_gas else -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        rem=0\\n        st=0\\n        t_gas=0\\n        for p in range(len(gas)):\\n            dif=gas[p]-cost[p]\\n            t_gas+=dif\\n            rem+=dif\\n            if rem<0:\\n                st=p+1\\n                rem=0\\n        else: return st if abs(t_gas)==t_gas else -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013609,
                "title": "c-code-greedy-approach-o-n-time-complexity",
                "content": "\\n\\n# Approach\\n- As soon as a gas station changed to -ve, our brute-force simulation began. The first step is to stop and proceed to the next station. But in order for us to see why, this is ineffective. We must examine the causes of car stops.\\n- Let\\'s assume for the sake of this example that the car starts at 0 and can reach 3 gas stations. And after attempting to reach the fourth station, its gas runs out.\\nOnce the brute force approach realises it can complete the journey, it restarts the simulation from this gas station. However, this upcoming simulation is pointless and a waste of time.\\n\\n- The failure of these three gas stations and journeys is previously known. This indicates that, when comparing our fuel buildup to our gasoline use, we were either in some sort of surplus or, at the absolute least, breaking even, with precisely enough fuel to complete every journey.\\n- This is due to the fact that if we were in some sort of deficit, our car would have already consumed gas earlier. This indicates that we were in some sort of deficit on the previous trip since we ran out of petrol.\\nAs a result, neither Index 1 nor Index 2 nor Index 3 can be reached because we cannot begin the journey at the very beginning.\\n\\n- In terms of our algorithm, this means that we will be aware if we run out of fuel, say at a gas station. Each and every gas station between it and the starting point is a poor starting point.\\n- As a result, we can begin our efforts at the next petrol station on the i + 1 station. So perhaps you now have a better understanding of how this O(N) solution will work.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n\\n        int total=0; //it will give us a difference b/w gas & cos\\n        int start=0; // and the index of gas station\\n        int diff=0; // our tank\\n        for(int i=0;i<gas.size();i++)\\n        {\\n            total+=gas[i]-cost[i];// storing values to check that total cost is less than total refill or not\\n            diff+=gas[i]-cost[i];\\n            if(diff<0)\\n            {\\n                start=i+1;\\n                diff=0;\\n            }\\n        }\\n        return (total<0)?-1:start;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n\\n        int total=0; //it will give us a difference b/w gas & cos\\n        int start=0; // and the index of gas station\\n        int diff=0; // our tank\\n        for(int i=0;i<gas.size();i++)\\n        {\\n            total+=gas[i]-cost[i];// storing values to check that total cost is less than total refill or not\\n            diff+=gas[i]-cost[i];\\n            if(diff<0)\\n            {\\n                start=i+1;\\n                diff=0;\\n            }\\n        }\\n        return (total<0)?-1:start;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012863,
                "title": "simple-greedy-c-o-n-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force is just taking two loops and checking at each index if its possible to make  a trip to n stations that can easily done by checking one bu one each index and if required gas is more than availabe then we can\\'t start at that index if not then we check if all the stations can be traversed . But it will be O(n^2) SO we can think of a Greedy  Approach in which we have to take an observation in considertion that is :\\n- If we take i as starting point and it make trip to some (e.g 3 stations) and after that we ran out of gas and then from that i to i+3 there will not be any good starting point (just dry run it ) So we have to take next starting point after these three stations so if 3 were traversed initially after that we ran out of gas so take 4 th as starting point.\\n- The reason behind this observation is if i was our starting point and it can\\'t make it after some stations that means those stations are deficit of gas so there is no chance they can be a good starting point. So we have to start at next station ( i.e after these stations) \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedy Approach : Jsut loop through the indexes and chekc if total gas - required gas becomes negative or not if yes then take starting point at i+1 if not then keep traversing ....\\nLook at the code for more understanding\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        int sumg=accumulate(gas.begin(),gas.end(),0);\\n        int sumc=accumulate(cost.begin(),cost.end(),0);\\n        if(sumc>sumg)return -1;\\n        int ind=0,diff=0;\\n        for(int i=0;i<n;i++){\\n             diff+=gas[i]-cost[i];\\n          if(diff<0){\\n              ind=i+1;\\n              diff=0;\\n          }\\n        }\\n        return ind;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        int sumg=accumulate(gas.begin(),gas.end(),0);\\n        int sumc=accumulate(cost.begin(),cost.end(),0);\\n        if(sumc>sumg)return -1;\\n        int ind=0,diff=0;\\n        for(int i=0;i<n;i++){\\n             diff+=gas[i]-cost[i];\\n          if(diff<0){\\n              ind=i+1;\\n              diff=0;\\n          }\\n        }\\n        return ind;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012283,
                "title": "java-1ms-better-than-100-explanation",
                "content": "# Code\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int tank = 0, maxFuel = Integer.MIN_VALUE, ans = 0;\\n        for(int i = gas.length-1; i >= 0; i--){\\n            tank += gas[i]-cost[i];\\n\\n            if(maxFuel < tank){\\n                maxFuel = tank;\\n                ans = i;\\n            }\\n        }\\n        return (tank < 0)?-1:ans;\\n    }\\n}\\n```\\n\\n# Explanation\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- First think when will we complete the circular ride -> When we have enough fuel left. But how to find it as we can start from anywhere.\\n- Irrespective of where we start if sum of all `gas` elements is greater than sum of `cost` we complete the tour.\\n- Now that we know when we complete the tour all we need to check is where to start from.\\n- For that let\\'s start counting from the last index of the given arrays. Let `tank` be a variable which simulates our fuel tank . For each i, `tank += gas[i] - cost[i]`. Let\\'s also have a `maxFuel` which store the maximum value that `tank` achieves during the entire iteration. \\n- Now just check if `tank >= 0`. If yes just return index where we obtain `maxFuel`. Else -1.\\n- Now you might ask well why does it work. We are told that we have only one possible path. Reason why starting from last works is that it simulates the clockwise path that we are asked to take. Clockwise path from `i` to the last index of array. ***`maxFuel` just help us find starting at which index do I have maximum Fuel left to travel till the last station i.e till `gas.length-1`. If I\\'m sure that there is only one path then the index where we obtain `maxFuel` is the way to go!!.***\\n\\n\\n\\n\\n**Just take any test case and check incase of conflict in thoughts. Upvote if you like**\\n\\n",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int tank = 0, maxFuel = Integer.MIN_VALUE, ans = 0;\\n        for(int i = gas.length-1; i >= 0; i--){\\n            tank += gas[i]-cost[i];\\n\\n            if(maxFuel < tank){\\n                maxFuel = tank;\\n                ans = i;\\n            }\\n        }\\n        return (tank < 0)?-1:ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011277,
                "title": "c-153-ms",
                "content": "# Intuition\\nStart from the end to the beginning; sum up each (gas - cost), figure out the index of the maximum. If the sum is less than zero, you can\\'t get there from here. Otherwise, the answer is the index with the maximum sum.\\n\\n# Approach\\nSe above.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n    public int CanCompleteCircuit(int[] gas, int[] cost) {\\n\\n        int sum = gas[^1] - cost[^1];\\n        int maxIndex = gas.Length - 1;\\n        int maxSum = sum;\\n\\n        for(int i = gas.Length - 2; i >= 0; i--){\\n            sum += gas[i] - cost[i];\\n            if(sum > maxSum){\\n                maxIndex = i;\\n                maxSum = sum;\\n            }\\n        }\\n\\n        if(sum < 0) return -1;\\n        return maxIndex;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n    public int CanCompleteCircuit(int[] gas, int[] cost) {\\n\\n        int sum = gas[^1] - cost[^1];\\n        int maxIndex = gas.Length - 1;\\n        int maxSum = sum;\\n\\n        for(int i = gas.Length - 2; i >= 0; i--){\\n            sum += gas[i] - cost[i];\\n            if(sum > maxSum){\\n                maxIndex = i;\\n                maxSum = sum;\\n            }\\n        }\\n\\n        if(sum < 0) return -1;\\n        return maxIndex;\\n\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2726266,
                "title": "java-greedy-explained",
                "content": "### **Please Upvote** :D\\n---\\n- Check if `total gas` is lesser than `total cost`, if yes its impossible to travel so return `-1`.\\n- Else, start moving from the beginning, if `remaining ga`s is lesser than `0` means we can\\'t move further.\\n- In such case, we put `start` as `i + 1` as it can be our potential position to return.\\n- Otherwise our gas stays collected in `remainingGas` and we keep moving further.\\n- At the end we return `start` because it will keep getting updated to each potential start point when remaining gas becomes lesser than `0`.\\n``` java []\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int totalGas = 0, totalCost = 0;\\n        for (int i = 0; i < gas.length; i++) {\\n            totalGas += gas[i];\\n            totalCost += cost[i];\\n        }\\n        \\n        if (totalCost > totalGas) {\\n            return -1;\\n        }\\n\\n        int remainingGas = 0, start = 0;\\n        for (int i = 0; i < gas.length; i++) {\\n            remainingGas += (gas[i] - cost[i]);\\n            if (remainingGas < 0) {\\n                remainingGas = 0;\\n                start = i + 1;\\n            }\\n        }\\n\\n        return start;\\n    }\\n}\\n\\n// TC: O(n + n) => O(n)\\n// SC: O(1)\\n```\\n---\\n### *Same solution but reduced iteration:*\\n- Start moving from the beginning, if `remaining gas` is lesser than `0` means we can\\'t move further.\\n- In such case, we put `start` as `i + 1` as it can be our potential position to return.\\n- Otherwise our gas stays collected in `remainingGas` and we keep moving further.\\n- Meanwhile keep calculating `extra gas` for the whole journey, if its lesser than `0` means we cant complete our journey so return `-1`.\\n- Else return `start` (it will keep getting updated to each potential start point when remaining gas becomes lesser than `0`).\\n\\n``` java []\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int remainingGas = 0, extra = 0;\\n        int start = 0;\\n        for (int i = 0; i < gas.length; i++) {\\n            extra += (gas[i] - cost[i]);\\n            remainingGas += (gas[i] - cost[i]);\\n            if (remainingGas < 0) {\\n                remainingGas = 0;\\n                start = i + 1;\\n            }\\n        }\\n\\n        return extra < 0? -1 : start;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int totalGas = 0, totalCost = 0;\\n        for (int i = 0; i < gas.length; i++) {\\n            totalGas += gas[i];\\n            totalCost += cost[i];\\n        }\\n        \\n        if (totalCost > totalGas) {\\n            return -1;\\n        }\\n\\n        int remainingGas = 0, start = 0;\\n        for (int i = 0; i < gas.length; i++) {\\n            remainingGas += (gas[i] - cost[i]);\\n            if (remainingGas < 0) {\\n                remainingGas = 0;\\n                start = i + 1;\\n            }\\n        }\\n\\n        return start;\\n    }\\n}\\n\\n// TC: O(n + n) => O(n)\\n// SC: O(1)\\n```\n``` java []\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int remainingGas = 0, extra = 0;\\n        int start = 0;\\n        for (int i = 0; i < gas.length; i++) {\\n            extra += (gas[i] - cost[i]);\\n            remainingGas += (gas[i] - cost[i]);\\n            if (remainingGas < 0) {\\n                remainingGas = 0;\\n                start = i + 1;\\n            }\\n        }\\n\\n        return extra < 0? -1 : start;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252391,
                "title": "go-kadane-max-subarray-easy-to-understand",
                "content": "If you are not familiar with Kadane\\'s Algorithm for finding maximum subarray please check this [question first](https://leetcode.com/problems/maximum-subarray/). \\nThe idea is calculate **diff** array where:\\ndiff[i] = gas[i] - cost[i]\\n\\nThen find a maximum subarray with mentioned algorithm keeping track on the max subarray start position.\\nIf rest of the array is less then maxSubarray value then return index, otherwise -1.\\n\\n```\\nfunc canCompleteCircuit(gas []int, cost []int) int {\\n    diff := make([]int, len(gas))\\n    sum := 0\\n    for i:=0;i<len(diff);i++{\\n        diff[i]=gas[i]-cost[i]\\n        sum += diff[i]\\n    }\\n    \\n    //kadane\\n    current := 0\\n    maxSub := math.MinInt\\n    index := 0\\n    for i, v := range diff {\\n        buff := current + v\\n        if v > buff {\\n            index = i\\n            current = v\\n        }else{\\n            current = buff\\n        }\\n        \\n        maxSub = max(maxSub, current)\\n    }\\n    \\n    if maxSub < abs(sum - maxSub) {\\n        return -1\\n    }\\n    return index\\n}\\n\\nfunc abs(a int) int {\\n    if a < 0 {\\n        return a * -1\\n    }\\n    return a\\n}\\n\\nfunc max(a,b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc canCompleteCircuit(gas []int, cost []int) int {\\n    diff := make([]int, len(gas))\\n    sum := 0\\n    for i:=0;i<len(diff);i++{\\n        diff[i]=gas[i]-cost[i]\\n        sum += diff[i]\\n    }\\n    \\n    //kadane\\n    current := 0\\n    maxSub := math.MinInt\\n    index := 0\\n    for i, v := range diff {\\n        buff := current + v\\n        if v > buff {\\n            index = i\\n            current = v\\n        }else{\\n            current = buff\\n        }\\n        \\n        maxSub = max(maxSub, current)\\n    }\\n    \\n    if maxSub < abs(sum - maxSub) {\\n        return -1\\n    }\\n    return index\\n}\\n\\nfunc abs(a int) int {\\n    if a < 0 {\\n        return a * -1\\n    }\\n    return a\\n}\\n\\nfunc max(a,b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1706122,
                "title": "solution-swift-gas-station-test-cases",
                "content": "```swift\\nclass Solution {\\n    func canCompleteCircuit(_ gas: [Int], _ cost: [Int]) -> Int {\\n        \\n        let allgas = gas.reduce(0) { $0 + $1 }, allcost = cost.reduce(0) { $0 + $1 }\\n        guard allgas >= allcost else { return -1 }\\n        \\n        var value = 0, gasSum = 0, costSum = 0\\n        \\n        for (i, curr) in gas.enumerated() {\\n            gasSum += curr\\n            costSum += cost[i]\\n            if gasSum < costSum {\\n                value = i + 1\\n                gasSum = 0\\n                costSum = 0\\n            }\\n        }\\n        return value\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.008 (0.010) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\\n    // Travel to station 4. Your tank = 4 - 1 + 5 = 8\\n    // Travel to station 0. Your tank = 8 - 2 + 1 = 7\\n    // Travel to station 1. Your tank = 7 - 3 + 2 = 6\\n    // Travel to station 2. Your tank = 6 - 4 + 3 = 5\\n    // Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\\n    // Therefore, return 3 as the starting index.\\n    func test0() {\\n        let value = solution.canCompleteCircuit([1,2,3,4,5], [3,4,5,1,2])\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    // You can\\'t start at station 0 or 1, as there is not enough gas to travel to the next station.\\n    // Let\\'s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\\n    // Travel to station 0. Your tank = 4 - 3 + 2 = 3\\n    // Travel to station 1. Your tank = 3 - 3 + 3 = 3\\n    // You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\\n    // Therefore, you can\\'t travel around the circuit once no matter where you start.\\n    func test1() {\\n        let value = solution.canCompleteCircuit([2,3,4], [3,4,3])\\n        XCTAssertEqual(value, -1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func canCompleteCircuit(_ gas: [Int], _ cost: [Int]) -> Int {\\n        \\n        let allgas = gas.reduce(0) { $0 + $1 }, allcost = cost.reduce(0) { $0 + $1 }\\n        guard allgas >= allcost else { return -1 }\\n        \\n        var value = 0, gasSum = 0, costSum = 0\\n        \\n        for (i, curr) in gas.enumerated() {\\n            gasSum += curr\\n            costSum += cost[i]\\n            if gasSum < costSum {\\n                value = i + 1\\n                gasSum = 0\\n                costSum = 0\\n            }\\n        }\\n        return value\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\\n    // Travel to station 4. Your tank = 4 - 1 + 5 = 8\\n    // Travel to station 0. Your tank = 8 - 2 + 1 = 7\\n    // Travel to station 1. Your tank = 7 - 3 + 2 = 6\\n    // Travel to station 2. Your tank = 6 - 4 + 3 = 5\\n    // Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\\n    // Therefore, return 3 as the starting index.\\n    func test0() {\\n        let value = solution.canCompleteCircuit([1,2,3,4,5], [3,4,5,1,2])\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    // You can\\'t start at station 0 or 1, as there is not enough gas to travel to the next station.\\n    // Let\\'s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\\n    // Travel to station 0. Your tank = 4 - 3 + 2 = 3\\n    // Travel to station 1. Your tank = 3 - 3 + 3 = 3\\n    // You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\\n    // Therefore, you can\\'t travel around the circuit once no matter where you start.\\n    func test1() {\\n        let value = solution.canCompleteCircuit([2,3,4], [3,4,3])\\n        XCTAssertEqual(value, -1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549590,
                "title": "java-o-n-time-o-1-space-code-with-explanation",
                "content": "Basically what we are doing is first checking whether summation of gas - summation of cost is greater than or equal to 0 or not then only we can get answer \\n\\nthen we are doing prefix sum of gas-cost and finding the most negative or the most smallest value in that prefix sum, once we know that then we gonna return the index+1 where index is the index of the most negative or the most smallest element prefix sum.\\n\\nthe reason we did that bcz it is guaranteed that the next idx of gas-cost will be positive\\nprefix[i+1] >=prefix[i] //i is the index of the smallest prefix sum.\\nprefix[i+1] >=prefix[i] + gas[i+1]-cost[i+1]\\n0>=gas[i+1]-cost[i+1]\\n\\nnow also think about that position whose (gas-cost) value can bring back the most negative prefix sum to positive value or 0 , will be such a great position to start about(ik its hard to imagine but that\\'s how I am thinking, if you have a better approach plz do discuss in comment section or way to describe this solution in better words).\\n\\nPLZ UPVOTE IF THIS SOLUTION FOUND HELPFUL.\\n```\\n public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int gasSum = 0 , gasCostSum = 0;\\n        \\n        for(Integer e : gas) gasSum+=e;\\n        for(Integer e : cost) gasCostSum+=e;\\n        \\n        if(gasSum-gasCostSum<0) return -1;\\n        \\n        int prefixSum = 0;\\n        int minIdx=0;\\n        int minValueInPrefix=Integer.MAX_VALUE;\\n        \\n        for(int i=0;i<gas.length;i++){\\n            prefixSum+=gas[i]-cost[i];\\n            if(prefixSum<minValueInPrefix){\\n                minValueInPrefix=prefixSum;\\n                minIdx=i;\\n            }\\n        }\\n        \\n        return minIdx==gas.length-1?0:minIdx+1;\\n    }\\n\\t",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "Basically what we are doing is first checking whether summation of gas - summation of cost is greater than or equal to 0 or not then only we can get answer \\n\\nthen we are doing prefix sum of gas-cost and finding the most negative or the most smallest value in that prefix sum, once we know that then we gonna return the index+1 where index is the index of the most negative or the most smallest element prefix sum.\\n\\nthe reason we did that bcz it is guaranteed that the next idx of gas-cost will be positive\\nprefix[i+1] >=prefix[i] //i is the index of the smallest prefix sum.\\nprefix[i+1] >=prefix[i] + gas[i+1]-cost[i+1]\\n0>=gas[i+1]-cost[i+1]\\n\\nnow also think about that position whose (gas-cost) value can bring back the most negative prefix sum to positive value or 0 , will be such a great position to start about(ik its hard to imagine but that\\'s how I am thinking, if you have a better approach plz do discuss in comment section or way to describe this solution in better words).\\n\\nPLZ UPVOTE IF THIS SOLUTION FOUND HELPFUL.\\n```\\n public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int gasSum = 0 , gasCostSum = 0;\\n        \\n        for(Integer e : gas) gasSum+=e;\\n        for(Integer e : cost) gasCostSum+=e;\\n        \\n        if(gasSum-gasCostSum<0) return -1;\\n        \\n        int prefixSum = 0;\\n        int minIdx=0;\\n        int minValueInPrefix=Integer.MAX_VALUE;\\n        \\n        for(int i=0;i<gas.length;i++){\\n            prefixSum+=gas[i]-cost[i];\\n            if(prefixSum<minValueInPrefix){\\n                minValueInPrefix=prefixSum;\\n                minIdx=i;\\n            }\\n        }\\n        \\n        return minIdx==gas.length-1?0:minIdx+1;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1356765,
                "title": "c-two-pass-and-one-pass-solutions-o-1-space-and-o-n-time",
                "content": "# **Intuition and Thought Process**:\\n\\nSo, here we need to find out if we can traverse all the gas stations and return back to the initial start location. If we can do so wee need to return the index of the gas station. If that is not possible return -1.\\n\\n**Brute Force and Obvious Solution**:\\n\\nSo the obvious and naive solution is to check if we can traverse all the gas stations for every index i. \\nIt takes O(N) to check if we can traverse all the gas stations and hence it takes O(N^2) to check if the traversal is possible for every index i. \\n* *Time Complexity*: O(N^2)\\n* *Space Complexity*: O(1).\\n\\n**Faster Solution - Two Pass Solution**\\n\\nNow the goal is to come up with a better solution than brute force. How do we do that? Well, in the algorithmic world the next faster solution from **O(N^2)** is **O(NLogN)**. Tp do that, we need to use some sort of sorting or heaps or binary search. Unfortunately we can not do any of that as we need to preserve the indices of *gas* and *cost* arrays. Now we need to come up with a **O(N)** solution.\\n\\nWe can only reach a gas station i+1 from i , only if `(gas[i] - cost[i])  >=  0` . For any i from `i = 0 to n-1`, this isn\\'t possible, that index `i` can not be the start position. We start at gas station 0 and keep track of starting index. Fill in the tank and go to the next gas station. If we reach the next gas station then that means that the circular traversal is posible for our current start location. If we can not, then the circular traversal is not possible for this starting location and can chose the next gas station as our start location.\\n\\nMy idea here is to take advantage of the fact that the gas stations are circularly placed and traverse the array twice and the fact that there is only one possible solution.\\nLet us say we have  4 gas stations `g0, g1, g2,g3`.\\n* If we start at g0, we need to ensure that g1, g2, g3 are reachable.\\n* If some gas station can not be reachable, then we start from there and check if all the others are reachable.\\n* Let us say we could only reach until g2 and can not reach to g3 from there, we start at g3 and then go to g0 again.\\n* Instead of stopping at n-1th gas station, we continue to traverse from the beginning in our for loop again. This way , we can identify for every start position i, a circular traversal can be acheived.\\n\\nHere the improvement from brute force is instead of traversing the entire circular loop for every index , we start at every gas station we can not reach and continue with that as a start pointing.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int sum = 0, index = 0, n = gas.size(), count = 0;\\n\\t\\t// traversing the array twice by keeping track of number of elements traversed.\\n        for(int i = 0; count < 2 * n; i = (i+1) % n) {\\n            sum += (gas[i] - cost[i]);\\n\\t\\t\\t/*\\n\\t\\t\\t\\tIt is the equivalent of\\n\\t\\t\\t\\tif( sum < 0) {\\n\\t\\t\\t\\t\\tindex = count + 1;\\n\\t\\t\\t\\t\\tsum = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t*/\\n\\t\\t\\t /*update new start position. I am using index to denote start position and am updating it to the next iteration number. I am not using i here because if we use i, there may be a situation where in first iteration we have already tried with i as a start location and have identified it can not be a start location. Again, if we use that in the second iteration, it would be difficult to determine if that\\'s our designed start position or not */\\n             (sum < 0) ? index = count + 1, sum = 0 : index;\\n             count++;\\n         }\\n\\t\\t /* if index > n-1, then there is no solution, because we have tried out all the start locations and we couldn\\'t complete the circular traversal. If not then that is the desired start position and we have reached all the gas stations */  \\n         return index >= n ? -1 : index;\\n      \\n    }\\n};\\n```\\n\\n* *Time Complexity*: O( 2*N) = O(N)\\n* *Space Complexity*: O(1).\\n\\n**Optimal one pass solution**:\\n\\nNow from the previous two pass solution, we can observe that, the entire circular traversal of gas sattions is possible only if the entire `sum(gas[i] - cost[i])` is positve for all `i = 0 to n-1`. We can avoid the other traversal if we keep track of the entire  `sum(gas[i] - cost[i])` in a new variable. If by end of the traversal for gas array we know for sure that the  `sum(gas[i] - cost[i])` is non negative, the circular traversal is possible and the current start position would be the required answer.\\n\\nLet us say we have  4 gas stations `g0, g1, g2,g3`. If 2 is the required start position, then in two pass solution above we go from g2 -> g3 -> g0 -> g1 -> g2 to verify that this is the right solution. Hence we are traversing the array again. But here, in this solution we are keeping track of cumulative sum of `gas[i] - cost[i]`. If g2 is the  correct start position, then we know that g2 is not reachable if we start at g0 and the cumulative sum until g2 (`g0+g1+g2`) is negative. But if we can know that `g0+ g1 + g2 + g3` is positive by the end of the traversal of gas array, then we can know that g0 and g1 are also reachablefrom g2 as starting point. We are just pre computing the sum until this point to avaoid another traversal.\\n\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int sum = 0, index = 0, n = gas.size(), totalGas = 0;\\n        for(int i = 0; i < n; i++) {\\n            sum += (gas[i] - cost[i]);\\n            totalGas += (gas[i] - cost[i]);\\n            (sum < 0) ? index = i + 1, sum = 0: index;\\n        }\\n        return  totalGas < 0 ? -1 : index;\\n    }\\n};\\n```\\n\\n* *Time Complexity*: O(N)\\n* *Space Complexity*: O(1).",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int sum = 0, index = 0, n = gas.size(), count = 0;\\n\\t\\t// traversing the array twice by keeping track of number of elements traversed.\\n        for(int i = 0; count < 2 * n; i = (i+1) % n) {\\n            sum += (gas[i] - cost[i]);\\n\\t\\t\\t/*\\n\\t\\t\\t\\tIt is the equivalent of\\n\\t\\t\\t\\tif( sum < 0) {\\n\\t\\t\\t\\t\\tindex = count + 1;\\n\\t\\t\\t\\t\\tsum = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t*/\\n\\t\\t\\t /*update new start position. I am using index to denote start position and am updating it to the next iteration number. I am not using i here because if we use i, there may be a situation where in first iteration we have already tried with i as a start location and have identified it can not be a start location. Again, if we use that in the second iteration, it would be difficult to determine if that\\'s our designed start position or not */\\n             (sum < 0) ? index = count + 1, sum = 0 : index;\\n             count++;\\n         }\\n\\t\\t /* if index > n-1, then there is no solution, because we have tried out all the start locations and we couldn\\'t complete the circular traversal. If not then that is the desired start position and we have reached all the gas stations */  \\n         return index >= n ? -1 : index;\\n      \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int sum = 0, index = 0, n = gas.size(), totalGas = 0;\\n        for(int i = 0; i < n; i++) {\\n            sum += (gas[i] - cost[i]);\\n            totalGas += (gas[i] - cost[i]);\\n            (sum < 0) ? index = i + 1, sum = 0: index;\\n        }\\n        return  totalGas < 0 ? -1 : index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234365,
                "title": "o-n-time-o-1-space-complexity-easy-explanation",
                "content": "One basic idea towards the solution is that whenever the total required gas is greater than the total availble gas, the solution will not exist, otherwise the solution always exists. Now, if the solution exists, just traverse the array and start taking sum from *ind* to *i*, if the sum of *cost* is more than *gas* the answer is shifted to the *i + 1* index value.\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int lsum = 0, rsum = 0, gsum = 0, csum = 0, ind = 0;\\n        \\n        for(int i = 0; i < gas.size(); ++i) {\\n            gsum += gas[i];\\n            csum += cost[i];\\n            lsum += gas[i];\\n            rsum += cost[i];\\n            if(lsum < rsum) {\\n                ind = i + 1;\\n                lsum = 0;\\n                rsum = 0;\\n            }\\n        }\\n        \\n        if(gsum < csum || ind >= gas.size()) return -1;\\n        return ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int lsum = 0, rsum = 0, gsum = 0, csum = 0, ind = 0;\\n        \\n        for(int i = 0; i < gas.size(); ++i) {\\n            gsum += gas[i];\\n            csum += cost[i];\\n            lsum += gas[i];\\n            rsum += cost[i];\\n            if(lsum < rsum) {\\n                ind = i + 1;\\n                lsum = 0;\\n                rsum = 0;\\n            }\\n        }\\n        \\n        if(gsum < csum || ind >= gas.size()) return -1;\\n        return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1197683,
                "title": "lessons-learned",
                "content": "**Pattern**: Cumulative sum pattern\\n\\nSimilar to Kadane\\'s algorithm. The below intution of using cumulative sums of continuous positive balance could be easily arrived at by thinking bruteforce first (where for each index cumulative balance is computed) and realizing to reduce this O(n^2) to O(n) can be done by storing the cumulative sum of balance in 1 travesal and using it to find the solution.\\n\\n**Intution**\\n1. The total gas (gas means gas at each station) should atleast match upto toal cost (cost means gas required to reach next station) for any successful travel.\\n2. If current balance (balance means gas at current station - gas required to next station) is negative we can\\'t travel to next station. So current station will never be the starting station.\\n3. So a positive curent balance be a starting station, but is ithat always true? A group of consequtive positive balances can be collectively negated by a bigger negative current balance. \\n4.  **A powerful observation in continuation to above observation is none of the stations at each of the positive balances can be a starting point now**. And since the current balance is negative, even current station can\\'t be starting station. Now the only possibility for a possible starting station is the next station, but we still have to repeat the process of checking if it has negative balance or if any negative balance in future negates all the positive balances starting from it.\\n5.  Observations 2 and 4 can be clubbed together during implementation.\\n6.  Another observation is even if positive balances consequetively occur till last station, we have to make sure they totally exceed all the previous negative and positive balances atleast by 0 for observation 1 to be true. (Ok, I think this is a redundant statement of observation 1.)\\n\\n**Note**:\\n[A post on why this is tagged as a \"Greedy\" problem](https://leetcode.com/problems/gas-station/discuss/1004074/Greedy-Method-or-Explanation-+-Visual-or-Python) \\n\\n**Code**:\\n```\\n// Got accepeted submission without any compile or runtime errors in the first try!\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int n = gas.length;\\n        int balance = 0;\\n        int negativeSum = 0;\\n        int possibleStart = 0;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            balance += gas[i] - cost[i];\\n            if (balance < 0) {\\n                negativeSum += balance;\\n                possibleStart = i + 1;\\n                balance = 0;\\n            }\\n        }\\n        \\n        if (possibleStart == n) {\\n            return -1;\\n        }\\n        if (balance >= Math.abs(negativeSum)) return possibleStart;\\n        return -1;\\n    }\\n}\\n```\\n```\\n/*\\n\\ngas:            1 2 3 0 3\\ncost:           1 1 1 5 1\\nremaining gas:  0 1 3-2 0\\n\\ngas:            1  2  3  4  5\\ncost:           3  4  5  1  2\\nremaining gas: -2 -4 -6  3  6 \\nprevRem gas:   -2 -4 -6 -6 -6\\n\\ngas:            2  3  4\\ncost:           3  4  3\\nremaining gas: -1 -1  1\\nprevRem gas:   -1 -2 -2\\n\\n*/\\n\\n// Just another representation\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int n = gas.length;\\n        int prevRemainingGas = 0;\\n        int remainingGas = 0;\\n        int possibleStart = 0;\\n        for (int i = 0; i < n; ++i) {\\n            int curGas = gas[i];\\n            int curCost = cost[i];\\n            remainingGas += curGas - curCost;\\n            if (remainingGas < 0) {\\n                possibleStart = i + 1;\\n                prevRemainingGas += remainingGas;\\n                remainingGas = 0;\\n            }\\n        }\\n        return possibleStart == n ? -1 : remainingGas + prevRemainingGas >= 0 ? possibleStart : -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Got accepeted submission without any compile or runtime errors in the first try!\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int n = gas.length;\\n        int balance = 0;\\n        int negativeSum = 0;\\n        int possibleStart = 0;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            balance += gas[i] - cost[i];\\n            if (balance < 0) {\\n                negativeSum += balance;\\n                possibleStart = i + 1;\\n                balance = 0;\\n            }\\n        }\\n        \\n        if (possibleStart == n) {\\n            return -1;\\n        }\\n        if (balance >= Math.abs(negativeSum)) return possibleStart;\\n        return -1;\\n    }\\n}\\n```\n```\\n/*\\n\\ngas:            1 2 3 0 3\\ncost:           1 1 1 5 1\\nremaining gas:  0 1 3-2 0\\n\\ngas:            1  2  3  4  5\\ncost:           3  4  5  1  2\\nremaining gas: -2 -4 -6  3  6 \\nprevRem gas:   -2 -4 -6 -6 -6\\n\\ngas:            2  3  4\\ncost:           3  4  3\\nremaining gas: -1 -1  1\\nprevRem gas:   -1 -2 -2\\n\\n*/\\n\\n// Just another representation\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int n = gas.length;\\n        int prevRemainingGas = 0;\\n        int remainingGas = 0;\\n        int possibleStart = 0;\\n        for (int i = 0; i < n; ++i) {\\n            int curGas = gas[i];\\n            int curCost = cost[i];\\n            remainingGas += curGas - curCost;\\n            if (remainingGas < 0) {\\n                possibleStart = i + 1;\\n                prevRemainingGas += remainingGas;\\n                remainingGas = 0;\\n            }\\n        }\\n        return possibleStart == n ? -1 : remainingGas + prevRemainingGas >= 0 ? possibleStart : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1141060,
                "title": "c-explanation-for-everybody-concise-greedy-0ms-solution",
                "content": "**Observation 1**\\nIn order to have a circle, total gas has to be greater than or equal to total cost (This helps us to find out if there is an unique answer or not)\\nBasically;\\n```\\nif (TotalGas >= TotalCost)\\n     we have an answer\\nelse \\n     return -1\\n```\\n\\n**Observation 2**\\nIf we cannot find a circle starting from station A and ending in station B means that any station between them (including A and B itself) cannot give the answer, so we don\\'t need to check the stations between them again.\\n\\n**C++ Implementation**\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int sum = 0, size = gas.size(), answer = INT_MAX, curGas = 0;\\n        for (int i = 0; i < gas.size(); i++) {\\n            curGas += gas[i] - cost[i];\\n            // Possible answer\\n            if (curGas >= 0) {\\n                answer = min(answer, i);\\n            }\\n            // Reset\\n            else {\\n                answer = INT_MAX;\\n                curGas = 0;\\n            }\\n            sum += gas[i] - cost[i];\\n        }\\n        return (sum < 0) ? -1 : answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nif (TotalGas >= TotalCost)\\n     we have an answer\\nelse \\n     return -1\\n```\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int sum = 0, size = gas.size(), answer = INT_MAX, curGas = 0;\\n        for (int i = 0; i < gas.size(); i++) {\\n            curGas += gas[i] - cost[i];\\n            // Possible answer\\n            if (curGas >= 0) {\\n                answer = min(answer, i);\\n            }\\n            // Reset\\n            else {\\n                answer = INT_MAX;\\n                curGas = 0;\\n            }\\n            sum += gas[i] - cost[i];\\n        }\\n        return (sum < 0) ? -1 : answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860576,
                "title": "python-simple-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=lWl-HbIC70g)\\nhttps://www.youtube.com/watch?v=lWl-HbIC70g\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        tank = 0\\n        shortage = 0\\n        start = 0\\n        \\n        for indx in range(len(gas)):\\n            tank += gas[indx]\\n            if tank >= cost[indx]:\\n                tank -= cost[indx]\\n            else:\\n                shortage += cost[indx] - tank\\n                start = indx + 1\\n                tank = 0\\n        \\n        if start == len(gas) or tank < shortage:\\n            return -1\\n        return start\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        tank = 0\\n        shortage = 0\\n        start = 0\\n        \\n        for indx in range(len(gas)):\\n            tank += gas[indx]\\n            if tank >= cost[indx]:\\n                tank -= cost[indx]\\n            else:\\n                shortage += cost[indx] - tank\\n                start = indx + 1\\n                tank = 0\\n        \\n        if start == len(gas) or tank < shortage:\\n            return -1\\n        return start\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860318,
                "title": "c-simple-clean-clear-o-n-solution-100-faster-0ms",
                "content": "```\\n\\nint canCompleteCircuit(int* gas, int gasSize, int* cost, int costSize)\\n{\\n        int tank = 0, start_gas = 0, index = 0;\\n        \\n        for (size_t i = 0; i < costSize; i++) \\n        {\\n           \\n            int start = gas[i] - cost[i];\\n            \\n            if (tank + start < 0) \\n            {\\n                tank = 0;\\n                index = i + 1;\\n            } \\n            else \\n            {\\n                tank += start;\\n            }\\n            start_gas += start;\\n        }\\n        \\n        return start_gas >= 0 ? index : -1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nint canCompleteCircuit(int* gas, int gasSize, int* cost, int costSize)\\n{\\n        int tank = 0, start_gas = 0, index = 0;\\n        \\n        for (size_t i = 0; i < costSize; i++) \\n        {\\n           \\n            int start = gas[i] - cost[i];\\n            \\n            if (tank + start < 0) \\n            {\\n                tank = 0;\\n                index = i + 1;\\n            } \\n            else \\n            {\\n                tank += start;\\n            }\\n            start_gas += start;\\n        }\\n        \\n        return start_gas >= 0 ? index : -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 860316,
                "title": "python-simple-short-clean-o-n-solution",
                "content": "```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        tank = 0\\n        start_gas = 0\\n        index = 0\\n        for i in range(len(gas)):\\n            start = gas[i] - cost[i]\\n            \\n            if tank + start < 0:\\n                tank = 0\\n                index = i + 1\\n            else:\\n                tank += start\\n                \\n            start_gas += start\\n        \\n        return index if start_gas >= 0 else -1\\n  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        tank = 0\\n        start_gas = 0\\n        index = 0\\n        for i in range(len(gas)):\\n            start = gas[i] - cost[i]\\n            \\n            if tank + start < 0:\\n                tank = 0\\n                index = i + 1\\n            else:\\n                tank += start\\n                \\n            start_gas += start\\n        \\n        return index if start_gas >= 0 else -1\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 398968,
                "title": "python-easytounderstand",
                "content": "class Solution(object):\\n    def canCompleteCircuit(self, gas, cost):\\n\\n        tank=0\\n        usage = 0\\n        index = -1\\n        if (sum(cost) - sum(gas))>0:\\n            return -1\\n        for i in range(len(gas)):\\n            \\n            if tank+gas[i]>=cost[i]:\\n                if tank==0:\\n                    index = i\\n                tank +=(gas[i]-cost[i])\\n            else:\\n                tank = 0\\n                index = -1\\n        return index",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "class Solution(object):\\n    def canCompleteCircuit(self, gas, cost):\\n\\n        tank=0\\n        usage = 0\\n        index = -1\\n        if (sum(cost) - sum(gas))>0:\\n            return -1\\n        for i in range(len(gas)):\\n            \\n            if tank+gas[i]>=cost[i]:\\n                if tank==0:\\n                    index = i\\n                tank +=(gas[i]-cost[i])\\n            else:\\n                tank = 0\\n                index = -1\\n        return index",
                "codeTag": "Java"
            },
            {
                "id": 244053,
                "title": "java-solution",
                "content": "**Solution 1:**\\n\\n- If sum of gas is more than sum of cost, then there must be a solution. The question guaranteed that the solution is unique i.e. The first one we found is the right one.\\n- The tank should never be negative, so restart whenever there is a negative number.\\n\\nTime complexity: `O(n)`\\nSpace Complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n\\tpublic int canCompleteCircuit(int[] gas, int[] cost)\\n\\t{\\n\\t\\tint sumGas = 0;\\n\\t\\tint sumCost = 0;\\n\\t\\tint start = 0;\\n\\t\\tint tank = 0;\\n\\n\\t\\tfor(int i = 0; i < gas.length; i++)\\n\\t\\t{\\n\\t\\t\\tsumGas += gas[i];\\n\\t\\t\\tsumCost += cost[i];\\n\\t\\t\\ttank += gas[i] - cost[i];\\n\\t\\t\\t\\n\\t\\t\\tif(tank < 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart = i + 1;\\n\\t\\t\\t\\ttank = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn sumGas < sumCost ? -1 : start;\\n\\t}\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n\\tpublic int canCompleteCircuit(int[] gas, int[] cost)\\n\\t{\\n\\t\\tint sumGas = 0;\\n\\t\\tint sumCost = 0;\\n\\t\\tint start = 0;\\n\\t\\tint tank = 0;\\n\\n\\t\\tfor(int i = 0; i < gas.length; i++)\\n\\t\\t{\\n\\t\\t\\tsumGas += gas[i];\\n\\t\\t\\tsumCost += cost[i];\\n\\t\\t\\ttank += gas[i] - cost[i];\\n\\t\\t\\t\\n\\t\\t\\tif(tank < 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart = i + 1;\\n\\t\\t\\t\\ttank = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn sumGas < sumCost ? -1 : start;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42569,
                "title": "very-simple-python-logic",
                "content": "```\\nclass Solution(object):\\n    def canCompleteCircuit(self, gas, cost):\\n        \"\"\"\\n        :type gas: List[int]\\n        :type cost: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n    \\n        n = len(gas)\\n        if (sum(gas) - sum(cost)) < 0: # if total gas at all stations is less than total cost , then no soln. exists\\n            return -1\\n        \\n        tank = 0\\n        src  = 0 # starting from index 0\\n        cur  = 0\\n        while True:\\n            tank += gas[cur]         # car is at 'cur', fill the tank\\n            if tank - cost[cur] < 0: # car can't move to next stop, let car begin from next stop\\n                tank = 0             # empty the tank\\n                src  = (cur+1)%n     # update src\\n                cur  = src           # move to src\\n                continue             # move back to start of the loop\\n            tank -= cost[cur]        # moving to next emptied the gas by cost[cur]\\n            cur   = (cur +1)%n       # reached next\\n            if src == cur:           # did complete cycle?\\n                return src           # return start",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canCompleteCircuit(self, gas, cost):\\n        \"\"\"\\n        :type gas: List[int]\\n        :type cost: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n    \\n        n = len(gas)\\n        if (sum(gas) - sum(cost)) < 0: # if total gas at all stations is less than total cost , then no soln. exists\\n            return -1\\n        \\n        tank = 0\\n        src  = 0 # starting from index 0\\n        cur  = 0\\n        while True:\\n            tank += gas[cur]         # car is at 'cur', fill the tank\\n            if tank - cost[cur] < 0: # car can't move to next stop, let car begin from next stop\\n                tank = 0             # empty the tank\\n                src  = (cur+1)%n     # update src\\n                cur  = src           # move to src\\n                continue             # move back to start of the loop\\n            tank -= cost[cur]        # moving to next emptied the gas by cost[cur]\\n            cur   = (cur +1)%n       # reached next\\n            if src == cur:           # did complete cycle?\\n                return src           # return start",
                "codeTag": "Java"
            },
            {
                "id": 42719,
                "title": "simple-o-n-o-1-space-solution-js",
                "content": "    var canCompleteCircuit = function(gas, cost) {\\n        carFuel = 0;\\n        streak = 0;\\n        for(i = 0; i <= gas.length*2; i++) {\\n            carFuel += gas[i%gas.length];\\n            carFuel -= cost[i%cost.length];\\n            if(carFuel < 0) {\\n                carFuel = 0;\\n                streak = -1;\\n            }\\n            if(streak === gas.length)\\n                return i-streak;\\n            \\n            streak++;\\n        }\\n        return -1;\\n    };",
                "solutionTags": [],
                "code": "    var canCompleteCircuit = function(gas, cost) {\\n        carFuel = 0;\\n        streak = 0;\\n        for(i = 0; i <= gas.length*2; i++) {\\n            carFuel += gas[i%gas.length];\\n            carFuel -= cost[i%cost.length];\\n            if(carFuel < 0) {\\n                carFuel = 0;\\n                streak = -1;\\n            }\\n            if(streak === gas.length)\\n                return i-streak;\\n            \\n            streak++;\\n        }\\n        return -1;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 42746,
                "title": "my-solution-in-o-n-time",
                "content": "The idea is to keep track of the sum of all (gas[i] - cost[i]) (a random start would work), in the end, if sum >= 0, we can complete the circle. The position to  start is the one next of the minimum of the sum. I actually don't know how to prove this, but it is accepted.\\n\\n    class Solution {\\n    public:\\n        int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {\\n            int len = gas.size();\\n            if(len == 0) return -1;\\n            int min = gas[0] - cost[0];\\n            int sum = min;\\n            int pos = 1%len;\\n            for(int i = 1; i < len; ++i){\\n                sum += gas[i] - cost[i];\\n                if(min > sum){\\n                    min = sum;\\n                    pos = (i+1)%len;\\n                } \\n            }\\n            if(sum < 0) return -1;\\n            return pos;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {\\n            int len = gas.size();\\n            if(len == 0) return -1;\\n            int min = gas[0] - cost[0];\\n            int sum = min;\\n            int pos = 1%len;\\n            for(int i = 1; i < len; ++i){\\n                sum += gas[i] - cost[i];\\n                if(min > sum){\\n                    min = sum;\\n                    pos = (i+1)%len;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 42731,
                "title": "my-solution-is-pretty-straightforward-am-i-missing-anything",
                "content": "My solution is accepted. The idea is if the sum of the gas is greater than the sum of cost, there must be a solution.\\n\\nNext, accumulate the \"surplus\" or \"deficit\" along the circle, at one point, you will have the biggest deficit. Starting from the next station, you will never run into deficit so you can travel around the circle.\\n\\nThe solution is so straightforward, makes me wonder am I missing anything?\\n\\n**Added: Proof of existence of solution when the sum of gas is on less than the sum of cost**\\n\\nWith that assumption, let's check the situation where there is only one station Greatest Net Deficit (GND)\\nNote that the net surplus(NS) is the result of all the previous stations, a negative NS mean the car can not reach the next station.. If we start from the station from the station with the GND, which put the NS for that station at 0, then the NS will be positive for all station except the starting station, which can be positive or zero. Any way, the car can travel the circle.\\n\\nNext assume there are k station with equal GND, if we start from the first of them K1, we'll arrive in the next GND station K2 with 0 gas left, which means we can take K1-K2 path out of the circle without affecting our solution. Keep doing that we'll get back to the previous situation. So we know that there will be a least one solution given the sum of gas is greater than the sum of the cost.\\n    \\n     int canCompleteCircuit(vector<int> &gas, vector<int> &cost) \\n    {\\n    \\n            int totalgas = 0;\\n            int totalcost = 0;\\n            int maxdiff = 0;\\n            int station = 0;\\n            int diff = 0;\\n            for (int i = 0; i < gas.size(); i++) {\\n                totalgas += gas[i];\\n                totalcost += cost[i];\\n                diff = totalgas - totalcost;\\n                if (diff < maxdiff) {\\n                    maxdiff = diff;\\n                    station = i;\\n                }\\n            }\\n            if (totalcost > totalgas)\\n                return -1;\\n            station +=1;\\n            if (station == gas.size())\\n                station = 0;\\n            return station;\\n            \\n        }",
                "solutionTags": [],
                "code": "My solution is accepted. The idea is if the sum of the gas is greater than the sum of cost, there must be a solution.\\n\\nNext, accumulate the \"surplus\" or \"deficit\" along the circle, at one point, you will have the biggest deficit. Starting from the next station, you will never run into deficit so you can travel around the circle.\\n\\nThe solution is so straightforward, makes me wonder am I missing anything?\\n\\n**Added: Proof of existence of solution when the sum of gas is on less than the sum of cost**\\n\\nWith that assumption, let's check the situation where there is only one station Greatest Net Deficit (GND)\\nNote that the net surplus(NS) is the result of all the previous stations, a negative NS mean the car can not reach the next station.. If we start from the station from the station with the GND, which put the NS for that station at 0, then the NS will be positive for all station except the starting station, which can be positive or zero. Any way, the car can travel the circle.\\n\\nNext assume there are k station with equal GND, if we start from the first of them K1, we'll arrive in the next GND station K2 with 0 gas left, which means we can take K1-K2 path out of the circle without affecting our solution. Keep doing that we'll get back to the previous situation. So we know that there will be a least one solution given the sum of gas is greater than the sum of the cost.\\n    \\n     int canCompleteCircuit(vector<int> &gas, vector<int> &cost) \\n    {\\n    \\n            int totalgas = 0;\\n            int totalcost = 0;\\n            int maxdiff = 0;\\n            int station = 0;\\n            int diff = 0;\\n            for (int i = 0; i < gas.size(); i++) {\\n                totalgas += gas[i];\\n                totalcost += cost[i];\\n                diff = totalgas - totalcost;\\n                if (diff < maxdiff) {\\n                    maxdiff = diff;\\n                    station = i;\\n                }\\n            }\\n            if (totalcost > totalgas)\\n                return -1;\\n            station +=1;\\n            if (station == gas.size())\\n                station = 0;\\n            return station;\\n            \\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 42744,
                "title": "this-solution-got-accepted-but-i-think-the-problem-needs-some-clarification",
                "content": "Here's my code:\\n\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        // IMPORTANT: Please reset any member data you declared, as\\n        // the same Solution instance will be reused for each test case.\\n        int tank = 0;\\n        int counter = 0;\\n        int curIndex = 0;\\n        int ret = 0;\\n        boolean reset = true;\\n        while(tank >= 0 && counter < gas.length){\\n            if(reset){\\n                if(gas[curIndex]-cost[curIndex]>=0){\\n                    tank += gas[curIndex]-cost[curIndex];\\n                    counter++;\\n                    ret = curIndex;\\n                    reset = false;\\n                }\\n                else if(curIndex == gas.length-1) return -1;\\n                curIndex++;\\n            }\\n            else{\\n                tank+=gas[curIndex]-cost[curIndex];\\n                if(tank < 0){\\n                    if(ret == gas.length-1) return -1;\\n                    tank = 0;\\n                    counter = 0;\\n                    ret = curIndex;\\n                    reset = true;\\n                }\\n                else{\\n                    counter++;\\n                    curIndex++;\\n                }\\n            }\\n            if(curIndex == gas.length) curIndex = 0;\\n        }\\n        return ret;\\n    }\\n\\nThe idea is if we start at any ith station, where ith station has positive gas-cost,and we fail at kth station(total gas < 0), starting from any station between ith and kth will not be possible. Thus, when we fail at k, next time we try to start at a station after k, where the station has positive gas-cost, and see if we can finish the circuit from there. If at the end of the gas/cost array the gas - cost value is still negative or starting at the end of the array is still not a valid solution, we return -1;\\n\\nIn this way we can reduce the run time to linear time. Is there a better solution?\\n\\nI think the following two things might need some clarification in the problem:\\n\\n1. Since the gas stations are on a circle, can we travel backward? I did not count the case when traveling to the left direction of the array works but traveling to the right does not work. In my understanding, at ith station, the cost to travel to the right will be cost[i] but the cost to travel to the left will be cost[i-1]. \\n\\n2. How do we define \"complete the circuit\"? It seems that the circuit is regarded as completed if we can start at ith station and arrive at ith station eventually, not just i-1th station. Initially I had this line:\\n\\n    if(gas.length == 1) return 0;\\n\\nbut it failed the test case \"[4], [5]\".",
                "solutionTags": [],
                "code": "Here's my code:\\n\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        // IMPORTANT: Please reset any member data you declared, as\\n        // the same Solution instance will be reused for each test case.\\n        int tank = 0;\\n        int counter = 0;\\n        int curIndex = 0;\\n        int ret = 0;\\n        boolean reset = true;\\n        while(tank >= 0 && counter < gas.length){\\n            if(reset){\\n                if(gas[curIndex]-cost[curIndex]>=0){\\n                    tank += gas[curIndex]-cost[curIndex];\\n                    counter++;\\n                    ret = curIndex;\\n                    reset = false;\\n                }\\n                else if(curIndex == gas.length-1) return -1;\\n                curIndex++;\\n            }\\n            else{\\n                tank+=gas[curIndex]-cost[curIndex];\\n                if(tank < 0){\\n                    if(ret == gas.length-1) return -1;\\n                    tank = 0;\\n                    counter = 0;\\n                    ret = curIndex;\\n                    reset = true;\\n                }\\n                else{\\n                    counter++;\\n                    curIndex++;\\n                }\\n            }\\n            if(curIndex == gas.length) curIndex = 0;\\n        }\\n        return ret;\\n    }\\n\\nThe idea is if we start at any ith station, where ith station has positive gas-cost,and we fail at kth station(total gas < 0), starting from any station between ith and kth will not be possible. Thus, when we fail at k, next time we try to start at a station after k, where the station has positive gas-cost, and see if we can finish the circuit from there. If at the end of the gas/cost array the gas - cost value is still negative or starting at the end of the array is still not a valid solution, we return -1;\\n\\nIn this way we can reduce the run time to linear time. Is there a better solution?\\n\\nI think the following two things might need some clarification in the problem:\\n\\n1. Since the gas stations are on a circle, can we travel backward? I did not count the case when traveling to the left direction of the array works but traveling to the right does not work. In my understanding, at ith station, the cost to travel to the right will be cost[i] but the cost to travel to the left will be cost[i-1]. \\n\\n2. How do we define \"complete the circuit\"? It seems that the circuit is regarded as completed if we can start at ith station and arrive at ith station eventually, not just i-1th station. Initially I had this line:\\n\\n    if(gas.length == 1) return 0;\\n\\nbut it failed the test case \"[4], [5]\".",
                "codeTag": "Unknown"
            },
            {
                "id": 3014670,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int totalGas=0;\\n        int totalCost=0;\\n        for(int i=0;i<gas.length;i++){\\n            totalGas+=gas[i];\\n            totalCost+=cost[i];\\n        }\\n            if(totalGas<totalCost){\\n                return -1;\\n            }\\n        int remGas=0;\\n        int start=0;\\n        for(int i=0;i<gas.length;i++){\\n            remGas+=gas[i]-cost[i];\\n            if(remGas<0){\\n                start=i+1;\\n                remGas=0;\\n            }\\n        \\n        }\\n        return start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int totalGas=0;\\n        int totalCost=0;\\n        for(int i=0;i<gas.length;i++){\\n            totalGas+=gas[i];\\n            totalCost+=cost[i];\\n        }\\n            if(totalGas<totalCost){\\n                return -1;\\n            }\\n        int remGas=0;\\n        int start=0;\\n        for(int i=0;i<gas.length;i++){\\n            remGas+=gas[i]-cost[i];\\n            if(remGas<0){\\n                start=i+1;\\n                remGas=0;\\n            }\\n        \\n        }\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014347,
                "title": "java-c-100-solution-using-greedy-gas-station",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int n = gas.length,total = 0,extra=0,start=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            total += gas[i]-cost[i];\\n            extra += gas[i]-cost[i];\\n            if(extra<0)\\n            {\\n                extra = 0;\\n                start = i+1;\\n            }\\n        }\\n        return total >= 0 ? start : -1;        \\n    }\\n}\\n```\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size(),total = 0,extra=0,start=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            total += gas[i]-cost[i];\\n            extra += gas[i]-cost[i];\\n            if(extra<0)\\n            {\\n                extra = 0;\\n                start = i+1;\\n            }\\n        }\\n        return total >= 0 ? start : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int n = gas.length,total = 0,extra=0,start=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            total += gas[i]-cost[i];\\n            extra += gas[i]-cost[i];\\n            if(extra<0)\\n            {\\n                extra = 0;\\n                start = i+1;\\n            }\\n        }\\n        return total >= 0 ? start : -1;        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size(),total = 0,extra=0,start=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            total += gas[i]-cost[i];\\n            extra += gas[i]-cost[i];\\n            if(extra<0)\\n            {\\n                extra = 0;\\n                start = i+1;\\n            }\\n        }\\n        return total >= 0 ? start : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012322,
                "title": "easy-c-solution",
                "content": "**Easy Cpp solution**\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size();\\n        int total_surplus = 0;\\n        int surplus = 0;\\n        int start = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            total_surplus += gas[i] - cost[i];\\n            surplus += gas[i] - cost[i];\\n            if(surplus < 0){\\n                surplus = 0;\\n                start = i + 1;\\n            }\\n        }\\n        return (total_surplus < 0) ? -1 : start;\\n    }\\n};\\n```\\n\\n*If you like it please upvote it*",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size();\\n        int total_surplus = 0;\\n        int surplus = 0;\\n        int start = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            total_surplus += gas[i] - cost[i];\\n            surplus += gas[i] - cost[i];\\n            if(surplus < 0){\\n                surplus = 0;\\n                start = i + 1;\\n            }\\n        }\\n        return (total_surplus < 0) ? -1 : start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011831,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncheck for index where gas[i]>=cost[i] ans simultanously maintain the total available gas after each station\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nafter all iterations if total available gas<0 then the journey is not possible \\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int gas1=0, gas2=0; \\n/*gas1 will maintain total available gas at given station gas2   will maintain currently available gas*/\\n        int res=0;  \\n        for(int i=0; i<gas.size(); i++){\\n            gas1 += gas[i]-cost[i];\\n            gas2 += gas[i]-cost[i];\\n            \\n            if(gas2 < 0) \\n            {\\n                gas2=0;\\n                 res=i+1;\\n            }\\n        }\\n        if(gas1 < 0)\\n        return -1;\\n        else\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int gas1=0, gas2=0; \\n/*gas1 will maintain total available gas at given station gas2   will maintain currently available gas*/\\n        int res=0;  \\n        for(int i=0; i<gas.size(); i++){\\n            gas1 += gas[i]-cost[i];\\n            gas2 += gas[i]-cost[i];\\n            \\n            if(gas2 < 0) \\n            {\\n                gas2=0;\\n                 res=i+1;\\n            }\\n        }\\n        if(gas1 < 0)\\n        return -1;\\n        else\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797805,
                "title": "python-explained-steps-clean-code-best-method",
                "content": "Hello!\\n\\nTo solve this problem we have to find the point in which we would have the **worst case** of gas value (we can think of gas as money and treat -5 gas as 5$ debt). \\n\\nWe know that there is only **one unique answer**, so the starting point has to be at the point where we are at **the lowest level of gas** (because if we cannot go any lower, then it means that we will have positive value of gas at every next step).\\n\\nThe case when we return -1 is when sum of **gas** list is lower than sum of **cost** list. In code you can see that we will add all values from **gas** and **cost** list.\\n\\nIn code we iterate through every gas station from start to the end and in each station update information about **current gas level**.\\n\\n**result** variable stores index of the gas station in which we have to start\\n\\nCode:\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        current_gas = gas[0]\\n        result = 0\\n        worst_case = 0\\n        \\n        for x in range(len(gas)):\\n            current_gas -= cost[x]\\n            \\n            if current_gas < worst_case:\\n                worst_case = current_gas\\n                result = x+1\\n            \\n            if x < len(gas)-1:\\n                current_gas += gas[x+1]\\n        \\n        if current_gas < 0:\\n            return -1\\n        else:\\n            return result\\n```\\nPlease upvote if it was helpful :))",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        current_gas = gas[0]\\n        result = 0\\n        worst_case = 0\\n        \\n        for x in range(len(gas)):\\n            current_gas -= cost[x]\\n            \\n            if current_gas < worst_case:\\n                worst_case = current_gas\\n                result = x+1\\n            \\n            if x < len(gas)-1:\\n                current_gas += gas[x+1]\\n        \\n        if current_gas < 0:\\n            return -1\\n        else:\\n            return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048407,
                "title": "clean-and-clear-o-n-python-solution-easy-to-understand",
                "content": "A question that requires some **math intuition**!\\n\\n**Greedy** idea:\\nGo through the list, **when** we find that we **run out of gas**, we should **re-start** from the next postion.\\n\\n**Time:** O(n)\\n**Space:** O(1)\\n\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        \\n        if sum(gas) < sum(cost): \\n            return -1\\n        \\n        n = len(gas)\\n        start, total = 0, 0\\n        \\n        for i in range(n):\\n            total += gas[i] - cost[i]\\n            if total < 0:\\n                start, total = i + 1, 0\\n        \\n        return start\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        \\n        if sum(gas) < sum(cost): \\n            return -1\\n        \\n        n = len(gas)\\n        start, total = 0, 0\\n        \\n        for i in range(n):\\n            total += gas[i] - cost[i]\\n            if total < 0:\\n                start, total = i + 1, 0\\n        \\n        return start\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884646,
                "title": "c-solution-time-o-n-space-o-1-fully-explained-short-sweet",
                "content": "**Method:**\\n* let\\'s consider an example of 10 stations\\n\\t* let\\'s denote the gas-cost value for each station as a,b,c,d,e,f,g,h,i,j respectively\\n\\t* the curr_gas store these a,b,c,etc.\\n\\t* the start = 0 i.e. we are starting from the index=0 i.e. the 1st station\\n\\t* now let\\'s suppose at the 6th station is the first point where gas-cost becomes negative\\n\\t* i.e. a+b+c+d+e+f = -ve =k(say)\\n\\t* now the logic is that we can surely say that none of the intermediate station from 1 to 6 can be the starting point\\n\\t\\t* proof:\\n\\t\\t\\t* let\\'s prove it by contradiction\\n\\t\\t\\t* let\\'s say 3rd station is the valid starting point\\n\\t\\t\\t* now, if at 6th value became negative that means all the previous one are positive right(i.e. a+b+c+d+e = +ve)\\n\\t\\t\\t* so if we start from c then\\n\\t\\t\\t\\t* c+d+e+f = k-(a+b)\\n\\t\\t\\t\\t* here lhs must be +ve as 3rd station is the valid point\\n\\t\\t\\t\\t* in the rhs k = -ve, a+b = +ve\\n\\t\\t\\t\\t* -ve -(+ve) = -ve hence rhs will be negative always\\n\\t\\t\\t\\t* thus lhs!=rhs  contradiction and hence the next possible station will be after 6 for sure\\n\\t\\t\\t\\t* hence when we encounter curr_gas<0 we shift start to i+1;\\n* now for the prev_gas it stores a+b+c+d+e+f\\n* as we are now gonna start fresh from g\\n* and the loop runs till j\\n* at last if suppose g to j sum is positive then curr_gas = g+h+i+j\\n* and in order to check we must add a to f in it which we had already store in prev_gas\\n* so the total is curr_gas+prev_gas and it must be positive for the travel\\n* **Time Complexity: O(n)**\\n\\t* n = number of gas stations\\n\\t* as the loop runs only n times\\n* **Space Complexity: O(1)**\\n\\t* as we created 3 variable only\\n\\t* hence the space complexity is linear\\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int curr_gas =0;\\n        int prev_gas =0;\\n        int start =0;\\n        for(int i=0;i<gas.size();i++){\\n            curr_gas+= gas[i]-cost[i];\\n            if(curr_gas<0){\\n                start=i+1;\\n                prev_gas+=curr_gas;\\n                curr_gas=0;\\n            }\\n        }\\n        if(curr_gas+prev_gas >=0){\\n            return start;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n*Happy Coding :-)*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int curr_gas =0;\\n        int prev_gas =0;\\n        int start =0;\\n        for(int i=0;i<gas.size();i++){\\n            curr_gas+= gas[i]-cost[i];\\n            if(curr_gas<0){\\n                start=i+1;\\n                prev_gas+=curr_gas;\\n                curr_gas=0;\\n            }\\n        }\\n        if(curr_gas+prev_gas >=0){\\n            return start;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706723,
                "title": "c-c-python-java-simple-and-short-solutions-o-n-tc-o-1-sc-explained",
                "content": "1. If sum of gas is less than sum of cost, then there is no way to get through all stations. So while we loop through the stations we sum up, so that at the end we can check the sum.\\n2. Otherwise, there must be one unique solution, so the first one I find is the right one. If the tank becomes negative, we restart because that can\\'t happen.\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int gas_tank = 0, start_index = 0, n = gas.size(), sum = 0;\\n        \\n        for (int i=0; i<n; i++) {\\n            \\n            sum += gas[i] - cost[i];\\n            gas_tank += gas[i] - cost[i];\\n            \\n            if (gas_tank < 0) {\\n                start_index = i+1;\\n                gas_tank = 0;\\n            }\\n            \\n        }\\n        return sum < 0 ? -1 : start_index;\\n    }\\n};\\n```\\n**C:**\\n```\\nint canCompleteCircuit(int* gas, int gasSize, int* cost, int costSize){\\n    int gas_tank = 0, start_index = 0, sum = 0;\\n        \\n        for (int i=0; i<costSize; i++) {\\n            \\n            sum += gas[i] - cost[i];\\n            gas_tank += gas[i] - cost[i];\\n            \\n            if (gas_tank < 0) {\\n                start_index = i+1;\\n                gas_tank = 0;\\n            }\\n            \\n        }\\n        return sum < 0 ? -1 : start_index;\\n}\\n```\\n**Java:**\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int gas_tank = 0, start_index = 0, n = gas.length, sum = 0;\\n        \\n        for (int i=0; i<n; i++) {\\n            \\n            sum += gas[i] - cost[i];\\n            gas_tank += gas[i] - cost[i];\\n            \\n            if (gas_tank < 0) {\\n                start_index = i+1;\\n                gas_tank = 0;\\n            }\\n            \\n        }\\n        return sum < 0 ? -1 : start_index;\\n    }\\n}\\n```\\n**Python:**\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if (sum(gas) - sum(cost) < 0):\\n            return -1\\n        \\n        gas_tank, start_index = 0, 0\\n        \\n        for i in range(len(gas)):\\n            gas_tank += gas[i] - cost[i]\\n            \\n            if gas_tank < 0:\\n                start_index = i+1\\n                gas_tank = 0\\n            \\n        return start_index\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int gas_tank = 0, start_index = 0, n = gas.size(), sum = 0;\\n        \\n        for (int i=0; i<n; i++) {\\n            \\n            sum += gas[i] - cost[i];\\n            gas_tank += gas[i] - cost[i];\\n            \\n            if (gas_tank < 0) {\\n                start_index = i+1;\\n                gas_tank = 0;\\n            }\\n            \\n        }\\n        return sum < 0 ? -1 : start_index;\\n    }\\n};\\n```\n```\\nint canCompleteCircuit(int* gas, int gasSize, int* cost, int costSize){\\n    int gas_tank = 0, start_index = 0, sum = 0;\\n        \\n        for (int i=0; i<costSize; i++) {\\n            \\n            sum += gas[i] - cost[i];\\n            gas_tank += gas[i] - cost[i];\\n            \\n            if (gas_tank < 0) {\\n                start_index = i+1;\\n                gas_tank = 0;\\n            }\\n            \\n        }\\n        return sum < 0 ? -1 : start_index;\\n}\\n```\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int gas_tank = 0, start_index = 0, n = gas.length, sum = 0;\\n        \\n        for (int i=0; i<n; i++) {\\n            \\n            sum += gas[i] - cost[i];\\n            gas_tank += gas[i] - cost[i];\\n            \\n            if (gas_tank < 0) {\\n                start_index = i+1;\\n                gas_tank = 0;\\n            }\\n            \\n        }\\n        return sum < 0 ? -1 : start_index;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if (sum(gas) - sum(cost) < 0):\\n            return -1\\n        \\n        gas_tank, start_index = 0, 0\\n        \\n        for i in range(len(gas)):\\n            gas_tank += gas[i] - cost[i]\\n            \\n            if gas_tank < 0:\\n                start_index = i+1\\n                gas_tank = 0\\n            \\n        return start_index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706683,
                "title": "python-3-o-n-o-1-greedy-one-pass-approach",
                "content": "```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if sum(gas)<sum(cost):\\n            return -1\\n        s,res=0,0\\n        for i in range(len(gas)):\\n            s += (gas[i]-cost[i])\\n            if s<0:\\n                s=0\\n                res=i+1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if sum(gas)<sum(cost):\\n            return -1\\n        s,res=0,0\\n        for i in range(len(gas)):\\n            s += (gas[i]-cost[i])\\n            if s<0:\\n                s=0\\n                res=i+1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706024,
                "title": "python3-runtime-432-ms-faster-than-99-27-memory-18-6-mb-less-than-94-41",
                "content": "```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if sum(gas) < sum(cost):\\n            return -1\\n        extra,ans = 0,0\\n        for i in range(len(gas)):\\n            extra += gas[i]-cost[i]\\n            if extra<0:\\n                ans = i+1\\n                extra = 0\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if sum(gas) < sum(cost):\\n            return -1\\n        extra,ans = 0,0\\n        for i in range(len(gas)):\\n            extra += gas[i]-cost[i]\\n            if extra<0:\\n                ans = i+1\\n                extra = 0\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632710,
                "title": "o-n-easy-solution-find-global-minima",
                "content": "The question can be resolved to finding the minima in the gas remaining at each station. Start the journey at the gas station right next to the minima. This would ensure that the gas tank will never go below that minima and hence the trip can be completed provided we have gas remaining is at least zero after going through all stations.\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        start = -1\\n        runSum = 0\\n        mini = float(\\'inf\\')\\n        for i in range(len(gas)):\\n            runSum+=gas[i]-cost[i]\\n            if runSum<mini:\\n                mini = runSum\\n                start = i+1\\n\\n        return start%len(gas) if runSum>=0 else -1\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        start = -1\\n        runSum = 0\\n        mini = float(\\'inf\\')\\n        for i in range(len(gas)):\\n            runSum+=gas[i]-cost[i]\\n            if runSum<mini:\\n                mini = runSum\\n                start = i+1\\n\\n        return start%len(gas) if runSum>=0 else -1\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515792,
                "title": "c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int gasTotal = accumulate(gas.begin(), gas.end(),0);\\n        int costTotal = accumulate(cost.begin(), cost.end(),0);\\n        \\n        if(gasTotal < costTotal) return -1;\\n        int stamina = 0;\\n        int res = 0;\\n        for(int i = 0; i < gas.size(); ++i) {\\n            stamina+=gas[i] - cost[i];\\n            if(stamina < 0) {\\n                stamina = 0;\\n                res = i+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int gasTotal = accumulate(gas.begin(), gas.end(),0);\\n        int costTotal = accumulate(cost.begin(), cost.end(),0);\\n        \\n        if(gasTotal < costTotal) return -1;\\n        int stamina = 0;\\n        int res = 0;\\n        for(int i = 0; i < gas.size(); ++i) {\\n            stamina+=gas[i] - cost[i];\\n            if(stamina < 0) {\\n                stamina = 0;\\n                res = i+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446633,
                "title": "c-4ms-runtime-o-n-solution-explained-with-inline-comments-clean-code",
                "content": "```\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size();\\n        \\n        /* \\n            We will use two variables i and j such that,\\n            i will point to starting gas station and\\n            j will act as iterator ahead it in circular manner \\n        */\\n        \\n        int i=0, j=0;\\n        int balance = 0;       \\n        \\n        while(i<n){\\n            \\n            /* add curr fuel to balance */\\n            \\n            balance += gas[j];\\n            \\n            /* If balance is greater then cost, we can travel to next station */\\n            \\n            if(balance >= cost[j]){\\n                balance -= cost[j];\\n                j = (j+1) % n;   \\n                \\n                if(j==i) return j;      // --> If next station is the starting station, we completed tour\\n            }\\n            \\n            \\n            /* Else we will start from the next gas station */\\n            \\n            else{\\n                j += 1;\\n                balance = 0;\\n                \\n                /* \\n                    If next station is ahead of the prev starting station (i) then we can update i to next station \\n                    Else simply return -1, because we get stuck in infinite loop, as next starting station should be\\n                    ahead of prev starting station\\n                */\\n                \\n                if(j>i) i = j;\\n                else return -1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size();\\n        \\n        /* \\n            We will use two variables i and j such that,\\n            i will point to starting gas station and\\n            j will act as iterator ahead it in circular manner \\n        */\\n        \\n        int i=0, j=0;\\n        int balance = 0;       \\n        \\n        while(i<n){\\n            \\n            /* add curr fuel to balance */\\n            \\n            balance += gas[j];\\n            \\n            /* If balance is greater then cost, we can travel to next station */\\n            \\n            if(balance >= cost[j]){\\n                balance -= cost[j];\\n                j = (j+1) % n;   \\n                \\n                if(j==i) return j;      // --> If next station is the starting station, we completed tour\\n            }\\n            \\n            \\n            /* Else we will start from the next gas station */\\n            \\n            else{\\n                j += 1;\\n                balance = 0;\\n                \\n                /* \\n                    If next station is ahead of the prev starting station (i) then we can update i to next station \\n                    Else simply return -1, because we get stuck in infinite loop, as next starting station should be\\n                    ahead of prev starting station\\n                */\\n                \\n                if(j>i) i = j;\\n                else return -1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1331456,
                "title": "sliding-window-c-easy-to-understand-o-n-time-complexity",
                "content": "- Idea maintain a sliding widow from index j to i, which represents the gas stations visited when starting from j.\\n-  We increment i, add the gas-cost offset to current gas. If current goes below 0, we increment j, until current is above 0;\\n-  the start index j can range from 0 to n\\n-  i can go beyond n, so we roll it to 0.\\n````\\n  int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int i=0,j=0,n=gas.size(),curr=0;\\n        while(j<n){\\n            curr+=gas[i]-cost[i];\\n            i=(i+1)%n;\\n            if(curr>=0 && i==j)return j;\\n            while(j<n && curr<0){\\n                curr+=cost[j]-gas[j];\\n                j++;\\n            }\\n        }\\n        return -1;\\n    }\\n\\t\\n",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "- Idea maintain a sliding widow from index j to i, which represents the gas stations visited when starting from j.\\n-  We increment i, add the gas-cost offset to current gas. If current goes below 0, we increment j, until current is above 0;\\n-  the start index j can range from 0 to n\\n-  i can go beyond n, so we roll it to 0.\\n````\\n  int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int i=0,j=0,n=gas.size(),curr=0;\\n        while(j<n){\\n            curr+=gas[i]-cost[i];\\n            i=(i+1)%n;\\n            if(curr>=0 && i==j)return j;\\n            while(j<n && curr<0){\\n                curr+=cost[j]-gas[j];\\n                j++;\\n            }\\n        }\\n        return -1;\\n    }\\n\\t\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1257923,
                "title": "c-one-trick-to-solve-it",
                "content": "**/ we should start from the index just after the index where the carry amount was at a minimum, because it will never be less than that on the rest of the route.**\\n\\nclass Solution {\\npublic:\\n\\n\\tint canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size();\\n        int total=0, subsum=INT_MAX, start=0;\\n        for(int i = 0; i < n; i++){\\n            total += gas[i] - cost[i];\\n            if(total < subsum) {\\n                subsum = total;\\n                start = i + 1; //stores the next index.\\n            }\\n        }\\n        return (total < 0) ?  -1 : (start%n); //if we at last then next index would be first element.\\n    }\\n\\t//Upvote if you find it useful.\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\tint canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size();\\n        int total=0, subsum=INT_MAX, start=0;\\n        for(int i = 0; i < n; i++){\\n            total += gas[i] - cost[i];\\n            if(total < subsum) {\\n                subsum = total;\\n                start = i + 1; //stores the next index.\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1203419,
                "title": "java-solution-with-clear-explanation",
                "content": "Let me know if you guys find it helpful or my explanation can be improved\\n```\\npublic int canCompleteCircuit(int[] gas, int[] cost) {\\n        if (gas.length == 0) return -1;\\n        if (gas.length != cost.length) return -1;\\n        // The above base checks are already given in the question, but might have to do it in a real interview\\n\\n        // Compute total gas\\n        // int totalGas = 0;\\n        // int totalCost = 0;\\n\\n        // We can compute totalGas and totalCost by iterating both the arrays\\n        // But to do it in one pass we will do it in actaul logic below\\n\\n        // Thought: Lets say we are asked to return true or false if we can travel to all the gas stations,\\n        // We dont need to do the below logic, we can just do `return totalGas - totalCost <= 0`\\n        // Instead we will calculate totalTank;\\n\\n        int totalTank = 0;\\n        int currGas = 0;\\n        int startingPosition = 0;\\n\\n        for (int i = 0; i < gas.length; i++) {\\n            // Compute totalgas here now\\n            totalTank += gas[i] - cost[i];\\n\\n            // We will also compute the currGas with previousGas we remember\\n            currGas += gas[i] - cost[i];\\n\\n            // Two points to note here:\\n            // If the currGas < 0, this cannot be the starting point -> straight forward\\n            // To better understand why the below check is necessary to get the starting position,\\n            // Imagine we have an example below:\\n            // gas = [1, 2, 3, 5, 4] cost  = [1, 4, 5, 2, 1]\\n            // StartPos = 0 currTank = 1 - 1 = 0;\\n            // currTank = 0 + 2 - 4 = -2;\\n            // We Got a negative value,\\n            // we change the startPos,\\n            // (Although we started with startPos as 0, this will be reset if at any ith position we find the currTank  < 0);\\n\\n            if (currGas < 0) {\\n                // Try changing the startingPosition (This is not the final)\\n                startingPosition = i + 1;\\n\\n                // Set the currGas to 0, because we want to start from 0\\n                currGas = 0;\\n            }\\n        }\\n\\n        // Finally we check if the totalGas - totalCost >= 0\\n        return totalTank >= 0 ? startingPosition : -1;\\n    }\\n",
                "solutionTags": [],
                "code": "Let me know if you guys find it helpful or my explanation can be improved\\n```\\npublic int canCompleteCircuit(int[] gas, int[] cost) {\\n        if (gas.length == 0) return -1;\\n        if (gas.length != cost.length) return -1;\\n        // The above base checks are already given in the question, but might have to do it in a real interview\\n\\n        // Compute total gas\\n        // int totalGas = 0;\\n        // int totalCost = 0;\\n\\n        // We can compute totalGas and totalCost by iterating both the arrays\\n        // But to do it in one pass we will do it in actaul logic below\\n\\n        // Thought: Lets say we are asked to return true or false if we can travel to all the gas stations,\\n        // We dont need to do the below logic, we can just do `return totalGas - totalCost <= 0`\\n        // Instead we will calculate totalTank;\\n\\n        int totalTank = 0;\\n        int currGas = 0;\\n        int startingPosition = 0;\\n\\n        for (int i = 0; i < gas.length; i++) {\\n            // Compute totalgas here now\\n            totalTank += gas[i] - cost[i];\\n\\n            // We will also compute the currGas with previousGas we remember\\n            currGas += gas[i] - cost[i];\\n\\n            // Two points to note here:\\n            // If the currGas < 0, this cannot be the starting point -> straight forward\\n            // To better understand why the below check is necessary to get the starting position,\\n            // Imagine we have an example below:\\n            // gas = [1, 2, 3, 5, 4] cost  = [1, 4, 5, 2, 1]\\n            // StartPos = 0 currTank = 1 - 1 = 0;\\n            // currTank = 0 + 2 - 4 = -2;\\n            // We Got a negative value,\\n            // we change the startPos,\\n            // (Although we started with startPos as 0, this will be reset if at any ith position we find the currTank  < 0);\\n\\n            if (currGas < 0) {\\n                // Try changing the startingPosition (This is not the final)\\n                startingPosition = i + 1;\\n\\n                // Set the currGas to 0, because we want to start from 0\\n                currGas = 0;\\n            }\\n        }\\n\\n        // Finally we check if the totalGas - totalCost >= 0\\n        return totalTank >= 0 ? startingPosition : -1;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 860480,
                "title": "gas-station-python-o-n-simple-explanation",
                "content": "```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if sum(gas) < sum(cost):\\n            return -1\\n        last = 0\\n        sm = 0\\n        n = len(gas)\\n        for i in range(n):\\n            if gas[i] + sm < cost[i]:\\n                last = i+1\\n                sm = 0\\n            else:\\n                sm += (gas[i]-cost[i])\\n        return last\\n```\\nwe update the last index each time we are at a point where if a jump is made would not be able to go further and the first condition eliminates all the not possible cases",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if sum(gas) < sum(cost):\\n            return -1\\n        last = 0\\n        sm = 0\\n        n = len(gas)\\n        for i in range(n):\\n            if gas[i] + sm < cost[i]:\\n                last = i+1\\n                sm = 0\\n            else:\\n                sm += (gas[i]-cost[i])\\n        return last\\n```",
                "codeTag": "Java"
            },
            {
                "id": 849147,
                "title": "cpp-o-n-fully-explained-commented",
                "content": "\\'\\'\\'\\n\\n        //optimized soln O(n) \\n        //an imp observation:  if the sum of total gas in all the stations is greater than total cost then only there can be a solution\\n        \\n        int n=gas.size();\\n        int surplus=0,deficit=0;    //surplus at an iteration i tells us how much gas will we have left when going to station i+1 from the selected starting point through i.\\n        //deficit tells us how much extra gas do we need to reach the selected starting point from 0th gas station\\n        //and in the end it will give the deficit from 0 to the first correct starting point(even if there are more than 1 starting points)\\n        \\n        //now why deficit is counted till the selected starting point only?\\n        //-> because for a starting point we won\\'t have deficit till the circle is reached or till the car becomes stranded and in the 2nd case we\\'ll have the new starting point and so this deficit will also be counted \\n        \\n        int start=0; //initial starting point\\n        \\n        //why we loop only till n when the circle can even start from 5th ?\\n        //-> because we maintain a deficit of fuel in gas station from 0 till the starting point ..eg if start is 5th then deficit of fuel from 0th to reach 5th is store in deficit and if from 5th till 0(next of n-1th is 0) our surplus is greater than deficit then only we\\'ll be sure that the circle can be formed starting from 5th  \\n        for(int i=0;i<n;i++)\\n        {\\n            surplus+=gas[i]-cost[i];\\n\\n                //next lines mean the car would stop before the next station and we\\'ll be stranded...therefore our considered starting point was not the correct starting point and even the stations between selected starting point and current station are also not correct as think of it this way that if we were able to get to current station from the starting point then that means we might had either 0 or >0 surplus gas while arriving at the station i and even then if we could not go to the next station means that even after starting with some more gas than gas[j] for all stations in between we were stranded so these all are bad/incorrect starting stations     \\n            if(surplus<0)\\n            {\\n                start=(i+1)%n;\\n                deficit+=surplus;   //only adding deficit till before starting point \\n                surplus =0;\\n            }            \\n        }\\n\\n        return surplus+deficit>=0?start:-1; //remember the first observation and also only if deficit of 0th to start is less than surplus from start to 0 then only possible\\n        \\n        //uncommented, clean code for reference xDxDxDxDxDxD :\\n        \\n\\t//         int n=gas.size();\\n\\t//         int surplus=0,deficit=0;   \\n\\t//         int start=0;         \\n\\t//         for(int i=0;i<n;i++)\\n\\t//         {\\n\\t//             surplus+=gas[i]-cost[i];\\n\\n\\t//             if(surplus<0)\\n\\t//             {\\n\\t//                 start=(i+1)%n;\\n\\t//                 deficit+=surplus;\\n\\t//                 surplus =0;\\n\\t//             }            \\n\\t//         }\\n\\t//         return surplus+deficit>=0?start:-1;\\n        \\n        \\n        \\n        \\n        \\n  \\n\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\'\\'\\'\\n\\n        //optimized soln O(n) \\n        //an imp observation:  if the sum of total gas in all the stations is greater than total cost then only there can be a solution\\n        \\n        int n=gas.size();\\n        int surplus=0,deficit=0;    //surplus at an iteration i tells us how much gas will we have left when going to station i+1 from the selected starting point through i.\\n        //deficit tells us how much extra gas do we need to reach the selected starting point from 0th gas station\\n        //and in the end it will give the deficit from 0 to the first correct starting point(even if there are more than 1 starting points)\\n        \\n        //now why deficit is counted till the selected starting point only?\\n        //-> because for a starting point we won\\'t have deficit till the circle is reached or till the car becomes stranded and in the 2nd case we\\'ll have the new starting point and so this deficit will also be counted \\n        \\n        int start=0; //initial starting point\\n        \\n        //why we loop only till n when the circle can even start from 5th ?\\n        //-> because we maintain a deficit of fuel in gas station from 0 till the starting point ..eg if start is 5th then deficit of fuel from 0th to reach 5th is store in deficit and if from 5th till 0(next of n-1th is 0) our surplus is greater than deficit then only we\\'ll be sure that the circle can be formed starting from 5th  \\n        for(int i=0;i<n;i++)\\n        {\\n            surplus+=gas[i]-cost[i];\\n\\n                //next lines mean the car would stop before the next station and we\\'ll be stranded...therefore our considered starting point was not the correct starting point and even the stations between selected starting point and current station are also not correct as think of it this way that if we were able to get to current station from the starting point then that means we might had either 0 or >0 surplus gas while arriving at the station i and even then if we could not go to the next station means that even after starting with some more gas than gas[j] for all stations in between we were stranded so these all are bad/incorrect starting stations     \\n            if(surplus<0)\\n            {\\n                start=(i+1)%n;\\n                deficit+=surplus;   //only adding deficit till before starting point \\n                surplus =0;\\n            }            \\n        }\\n\\n        return surplus+deficit>=0?start:-1; //remember the first observation and also only if deficit of 0th to start is less than surplus from start to 0 then only possible\\n        \\n        //uncommented, clean code for reference xDxDxDxDxDxD :\\n        \\n\\t//         int n=gas.size();\\n\\t//         int surplus=0,deficit=0;   \\n\\t//         int start=0;         \\n\\t//         for(int i=0;i<n;i++)\\n\\t//         {\\n\\t//             surplus+=gas[i]-cost[i];\\n\\n\\t//             if(surplus<0)\\n\\t//             {\\n\\t//                 start=(i+1)%n;\\n\\t//                 deficit+=surplus;\\n\\t//                 surplus =0;\\n\\t//             }            \\n\\t//         }\\n\\t//         return surplus+deficit>=0?start:-1;\\n        \\n        \\n        \\n        \\n        \\n  \\n\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 804651,
                "title": "detailed-proof-by-contradiction-and-2-pointer-2-solutions-python-o-n-time-and-o-1-space",
                "content": "Approach 1 :  2-Pointer Solution (T: O(2n)->O(n), S: O(1) )\\na)  currentidx to endIdx and idx-0 to currentidx (endPtr movement in circular fashion).\\nb)left to right (finding source station) idx=0 to endIdx (startPtr movement)\\n\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        start=end=rgas=0\\n        n=len(gas)\\n        while start<n:\\n            rgas+=(gas[end%n]-cost[end%n])\\n            if (end+1)%n==start and rgas>=0:\\n                return start\\n            while rgas<0 and start<=end and start<len(gas):\\n                rgas-=(gas[start]-cost[start])\\n                start+=1\\n            \\n            end+=1\\n        return -1\\n```\\n\\n\\n\\nApproach 2:\\nusing proof by contradiction. (Single-pass)\\nT: O(n), S: O:(1)\\n    Facts: \\n        a: A cannot reach B\\n        b: A can reach stations between A and B\\n        c: stations between A and B can reach B\\n    stations: A->C1->C2->...CK->B\\n        =>by transitive property:\\n            A->Ci and Ci->B => A->B (which contradicts my fact (a) )\\n            => it means all the stations that station A can reach, cannot reach the station b,paraphrasing that means if the (gas-cost) gain is decreasing starting from station A to station Ci suchcthat we get to a situation where the gas in the tank drops below zero (if we draw a graph , the slope of the (gas-cost) gain curve would decrease from station A to station Ci), in that case station A can reach station Ci but not he stations after station Ci, so it would be more worse to start from any other station after station A until the point of station Ci since the (gas-cost) gain drops as we reach station Ci, so starting after the station Ci would be our next try to see if we can reach station B such that we still have some gas left or no gas at all in the tank but not negative (this tells us that if sum(gas)-sum(cost)>=0 holds, then there is some station i where gas[i]>=cost[i], such that there will some gas left in the tank and we cover all the stations).\\n\\n\\n\\n```\\n\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        sourceStation=totalGain=gasLeftInTheTank=0\\n        numStations=len(gas)\\n        for currentStation in range(numStations):\\n            currentGain=(gas[currentStation]-cost[currentStation])\\n            gasLeftInTheTank+=currentGain\\n            totalGain+=currentGain\\n            if gasLeftInTheTank<0:\\n                sourceStation=i+1\\n                gasLeftInTheTank=0\\n        return -1 if totalGain<0 else sourceStation\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        start=end=rgas=0\\n        n=len(gas)\\n        while start<n:\\n            rgas+=(gas[end%n]-cost[end%n])\\n            if (end+1)%n==start and rgas>=0:\\n                return start\\n            while rgas<0 and start<=end and start<len(gas):\\n                rgas-=(gas[start]-cost[start])\\n                start+=1\\n            \\n            end+=1\\n        return -1\\n```\n```\\n\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        sourceStation=totalGain=gasLeftInTheTank=0\\n        numStations=len(gas)\\n        for currentStation in range(numStations):\\n            currentGain=(gas[currentStation]-cost[currentStation])\\n            gasLeftInTheTank+=currentGain\\n            totalGain+=currentGain\\n            if gasLeftInTheTank<0:\\n                sourceStation=i+1\\n                gasLeftInTheTank=0\\n        return -1 if totalGain<0 else sourceStation\\n```",
                "codeTag": "Java"
            },
            {
                "id": 667539,
                "title": "c-easy-explanation-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        //first find if a solution exists\\n        int gastotal = 0, costtotal = 0;\\n        for(int i = 0; i < gas.size(); ++i)\\n        {\\n            gastotal += gas[i];\\n            costtotal += cost[i];\\n        }\\n        //if no solution is possible, return -1\\n        if(gastotal < costtotal)\\n        {\\n            return -1;\\n        }\\n        //if a solution is possible, do below\\n        int start = 0;\\n        int tank = 0;\\n        \\n        for(int i = 0; i < gas.size(); ++i)\\n        {\\n            tank += gas[i];\\n            //if cost to next station is more than the gas we have right now,\\n            //reset tank back to 0 and try again at the next station\\n            if(cost[i] > tank)\\n            {\\n                tank = 0;\\n                start = i+1;\\n            }\\n            else\\n            {\\n                tank -= cost[i];\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        //first find if a solution exists\\n        int gastotal = 0, costtotal = 0;\\n        for(int i = 0; i < gas.size(); ++i)\\n        {\\n            gastotal += gas[i];\\n            costtotal += cost[i];\\n        }\\n        //if no solution is possible, return -1\\n        if(gastotal < costtotal)\\n        {\\n            return -1;\\n        }\\n        //if a solution is possible, do below\\n        int start = 0;\\n        int tank = 0;\\n        \\n        for(int i = 0; i < gas.size(); ++i)\\n        {\\n            tank += gas[i];\\n            //if cost to next station is more than the gas we have right now,\\n            //reset tank back to 0 and try again at the next station\\n            if(cost[i] > tank)\\n            {\\n                tank = 0;\\n                start = i+1;\\n            }\\n            else\\n            {\\n                tank -= cost[i];\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 497406,
                "title": "simplest-idea",
                "content": "if the total cost will be grater then the total available gas then can\\'t travel the all station and return -1. now starting station will be those station from where we must have a positive value in the tank so that we can travel to the next station. \\n```\\ntank=start=0\\n        if sum(cost)> sum(gas): return -1\\n        for i in range(len(gas)):\\n            tank+=gas[i]-cost[i]\\n            if tank<0:\\n                tank,start=0,i+1\\n        return start\\n```",
                "solutionTags": [],
                "code": "```\\ntank=start=0\\n        if sum(cost)> sum(gas): return -1\\n        for i in range(len(gas)):\\n            tank+=gas[i]-cost[i]\\n            if tank<0:\\n                tank,start=0,i+1\\n        return start\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 453838,
                "title": "beats-100-time-and-space-visual-understanding",
                "content": "Logic: Always start from the bottom-most point if the answer is possible.\\nVisual Understanding:\\n![image](https://assets.leetcode.com/users/bullpup/image_1576564602.png)\\n\\n![image](https://assets.leetcode.com/users/bullpup/image_1576564606.png)\\n\\n![image](https://assets.leetcode.com/users/bullpup/image_1576564603.png)\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int length = gas.length;\\n        int rs = 0;         // running sum \\n        int mrs = rs;    // minimum running sum\\n        int index = 0;       \\n        for(int i = 0; i < length; i++){\\n            rs += gas[i] - cost[i];\\n            if(rs < mrs){\\n                mrs = rs;\\n                index = (i + 1) % length;\\n            }\\n        }\\n        return rs < 0 ? -1 : index;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int length = gas.length;\\n        int rs = 0;         // running sum \\n        int mrs = rs;    // minimum running sum\\n        int index = 0;       \\n        for(int i = 0; i < length; i++){\\n            rs += gas[i] - cost[i];\\n            if(rs < mrs){\\n                mrs = rs;\\n                index = (i + 1) % length;\\n            }\\n        }\\n        return rs < 0 ? -1 : index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333007,
                "title": "java-solution-in-chinese",
                "content": "\\u9898\\u76EE\\u7ED9\\u51FA\\u4E86\\u4E24\\u4E2A\\u6570\\u7EC4\\uFF0C\\u4E8C\\u8005\\u5404\\u4F4D\\u7F6E\\u76F8\\u5BF9\\u5E94\\uFF0Cgas \\u6570\\u7EC4\\u8868\\u793A\\u4ECE\\u5F53\\u524D\\u4F4D\\u7F6E\\u51FA\\u53D1\\u524D\\u80FD\\u589E\\u52A0\\u591A\\u5C11\\u7684\\u6CB9\\u91CF\\uFF0Ccost \\u6570\\u7EC4\\u8868\\u793A\\u4ECE\\u5F53\\u524D\\u4F4D\\u7F6E\\u51FA\\u53D1\\u5230\\u4E0B\\u4E00\\u4F4D\\u7F6E\\u9700\\u8981\\u6D88\\u8017\\u591A\\u5C11\\u7684\\u6709\\u91CF\\uFF0C\\u6570\\u7EC4\\u53EF\\u4EE5\\u770B\\u4F5C\\u662F\\u4E00\\u4E2A\\u5934\\u5C3E\\u76F8\\u8FDE\\u7684\\u73AF\\uFF0C\\u9898\\u76EE\\u7684\\u8981\\u6C42\\u662F\\u627E\\u51FA\\u4E00\\u4E2A\\u53EF\\u4EE5\\u4F5C\\u4E3A\\u8D77\\u59CB\\u70B9\\u7684\\u4F4D\\u7F6E\\uFF0C\\u5E76\\u4E14\\u80FD\\u591F\\u8D70\\u5B8C\\u6574\\u4E2A\\u73AF\\u8DEF\\u56DE\\u5230\\u8D77\\u59CB\\u70B9\\u3002\\n\\n\\u90A3\\u4E48\\u4E00\\u79CD\\u65B9\\u6CD5\\u5C31\\u662F\\uFF0C\\u904D\\u5386\\u6BCF\\u4E00\\u4E2A\\u4F4D\\u7F6E\\uFF0C\\u5224\\u65AD\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u662F\\u5426\\u53EF\\u4EE5\\u4F5C\\u4E3A\\u8D77\\u59CB\\u70B9\\uFF0C\\u5982\\u679C\\u5728\\u73AF\\u8DEF\\u4E2D\\u8D70\\u5230\\u67D0\\u4E2A\\u4F4D\\u7F6E\\u540E\\u6CA1\\u6709\\u8DB3\\u591F\\u7684\\u6CB9\\u91CF\\u51FA\\u53D1\\u5230\\u4E0B\\u4E00\\u4F4D\\u7F6E\\uFF0C\\u5C31\\u8868\\u793A\\u8FD9\\u4E2A\\u8D77\\u59CB\\u70B9\\u4E0D\\u6EE1\\u8DB3\\u8981\\u6C42\\uFF0C\\u518D\\u53BB\\u5224\\u65AD\\u4E0B\\u4E00\\u4E2A\\u70B9\\u5373\\u53EF\\uFF1A\\n\\n```java\\npublic static int canCompleteCircuit(int[] gas, int[] cost) {\\n    int len = gas.length;\\n    int left;\\n    for (int i = 0; i < len; i++) {\\n        left = 0;\\n        for (int j = 0; j < len; j++) {\\n            int pos = (i + j) % len;\\n            left += gas[pos] - cost[pos];\\n            if (left < 0) {\\n                break;\\n            }\\n            if (j == len-1) {\\n                return i;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\n\\n\\u6B64\\u65F6\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u4E3A$O(n^2)$\\uFF0C\\u7A7A\\u95F4\\u590D\\u6742\\u5EA6\\u4E3A$O(1)$\\u3002\\n\\n\\u4F46\\u662F\\u4E0A\\u8FF0\\u89E3\\u7B54\\u51F8\\u663E\\u51FA\\u4E00\\u4E2A\\u95EE\\u9898\\uFF0C\\u6BCF\\u4E00\\u4E2A\\u68C0\\u6D4B\\u8FC7\\u7A0B\\u90FD\\u662F\\u72EC\\u7ACB\\u7684\\uFF0C\\u4E92\\u4E0D\\u5F71\\u54CD\\uFF0C\\u8FD9\\u5C31\\u5BFC\\u81F4\\u6BCF\\u4E00\\u4E2A\\u8D77\\u59CB\\u70B9\\u90FD\\u9700\\u8981\\u8FDB\\u884C\\u4E00\\u4E2A\\u5B8C\\u6574\\u7684\\u5224\\u65AD\\u3002\\u4F46\\u662F\\u5B83\\u4EEC\\u5B9E\\u9645\\u4E0A\\u5904\\u4E8E\\u540C\\u4E00\\u4E2A\\u73AF\\u8DEF\\u5185\\uFF0C\\u4E14\\u90FD\\u662F\\u9010\\u6B65\\u5411\\u4E0B\\u4E00\\u4E2A\\u4F4D\\u7F6E\\u79FB\\u52A8\\uFF0C\\u6240\\u4EE5\\u9488\\u5BF9\\u672C\\u9898\\u7684\\u4F18\\u5316\\uFF0C\\u5C31\\u5728\\u4E8E\\u5C06\\u5404\\u8D77\\u59CB\\u70B9\\u7684\\u5224\\u65AD\\u8054\\u7CFB\\u5230\\u4E00\\u8D77\\uFF0C\\u4F7F\\u4E00\\u4E2A\\u8D77\\u59CB\\u70B9\\u80FD\\u591F\\u5229\\u7528\\u4E0A\\u4E00\\u4E2A\\u8D77\\u59CB\\u70B9\\u6216\\u524D\\u51E0\\u4E2A\\u8D77\\u59CB\\u70B9\\u5224\\u65AD\\u4E4B\\u540E\\u5F97\\u5230\\u7684\\u7ED3\\u679C\\uFF0C\\u8FD9\\u6837\\u4E00\\u6765\\u5C31\\u5FC5\\u7136\\u80FD\\u591F\\u51CF\\u5C11\\u5224\\u65AD\\u4E00\\u4E2A\\u8D77\\u59CB\\u70B9\\u6D88\\u8017\\u7684\\u65F6\\u95F4\\u3002\\n\\n\\u90A3\\u4E48\\u518D\\u770B\\u9898\\u76EE\\uFF0C\\u9898\\u4E2D\\u63D0\\u5230\\u6BCF\\u4E00\\u9898\\u6700\\u591A\\u53EA\\u6709\\u4E00\\u4E2A\\u7ED3\\u679C\\uFF0C\\u5373\\u9664\\u4E86\\u67D0\\u4E00\\u4E2A\\u6EE1\\u8DB3\\u6761\\u4EF6\\u7684\\u8D77\\u59CB\\u70B9\\u4E4B\\u5916\\uFF0C\\u5176\\u4ED6\\u6240\\u6709\\u70B9\\u90FD\\u4E0D\\u6EE1\\u8DB3\\u3002\\u9996\\u5148\\u53EF\\u4EE5\\u786E\\u5B9A\\u7684\\u662F\\uFF0C\\u5982\\u679C\\u4E00\\u4E2A\\u8D77\\u59CB\\u70B9 i \\u6EE1\\u8DB3\\u6761\\u4EF6\\uFF0C\\u90A3\\u4E48\\u5FC5\\u7136\\u6709 gas[i] >= cost[i] \\uFF0C\\u8FD9\\u6837\\u8F66\\u624D\\u80FD\\u5728\\u8FD9\\u4E2A\\u70B9\\u8D77\\u6B65\\uFF0C\\u7136\\u540E\\u8D70\\u5230\\u4E0B\\u4E00\\u4E2A\\u70B9 i+1\\uFF0C\\u5982\\u679C\\u6709 left(i,i) + gas[i+1] >= cost[i+1] \\uFF0C\\uFF08left(i,j) \\u8868\\u793A\\u4ECE \\u4F4D\\u7F6E i \\u4F5C\\u4E3A\\u8D77\\u59CB\\u70B9\\uFF0C\\u4ECE\\u4F4D\\u7F6E j \\u51FA\\u53D1\\u4E4B\\u540E\\u7684\\u5269\\u4F59\\u6CB9\\u91CF\\uFF09\\u90A3\\u4E48\\u8F66\\u4E5F\\u53EF\\u4EE5\\u4ECE\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u51FA\\u53D1\\uFF0C\\u76F4\\u5230\\u8D70\\u5230\\u4E86\\u4F4D\\u7F6E j \\u4E4B\\u540E\\uFF0C\\u51FA\\u73B0\\u4E86 left + gas[j] < cost[j] \\u7684\\u60C5\\u51B5\\uFF0C\\u610F\\u5473\\u7740\\u6B64\\u65F6\\u8F66\\u4E0D\\u80FD\\u518D\\u4ECE\\u4F4D\\u7F6E j \\u51FA\\u53D1\\u4E86\\uFF0C\\u8D77\\u59CB\\u70B9 i \\u4E0D\\u6EE1\\u8DB3\\u6761\\u4EF6\\uFF0C\\u90A3\\u4E48\\u4E0B\\u4E00\\u4E2A\\u5E94\\u8BE5\\u5224\\u65AD\\u7684\\u8D77\\u59CB\\u70B9\\u5E94\\u8BE5\\u662F\\u54EA\\u91CC\\uFF1F\\u5728\\u4E0A\\u4E00\\u79CD\\u89E3\\u7B54\\u4E2D\\uFF0C\\u4E0B\\u4E00\\u4E2A\\u5F85\\u5224\\u65AD\\u7684\\u8D77\\u59CB\\u70B9\\u662F i+1 \\uFF0C\\u4F46\\u662F\\u5728\\u6B64\\u65F6\\uFF0C\\u4E0B\\u4E00\\u4E2A\\u5E94\\u8BE5\\u5224\\u65AD\\u7684\\u8D77\\u59CB\\u70B9\\u5E94\\u8BE5\\u662F j+1 \\uFF0C\\u4E3A\\u4EC0\\u4E48\\uFF1F\\u4E0B\\u9762\\u5C06\\u8BF4\\u660E\\u4E3A\\u4EC0\\u4E48\\u4ECE i+1 \\u5230 j \\u90FD\\u662F\\u4E0D\\u6EE1\\u8DB3\\u6761\\u4EF6\\u7684\\u8D77\\u59CB\\u70B9\\u3002\\n\\n\\u5148\\u770B i+1 \\uFF0C\\u7531\\u4E8E\\u8F66\\u53EF\\u4EE5\\u4ECE\\u4F4D\\u7F6E i \\u5F00\\u5230 \\u4F4D\\u7F6E i+1 \\uFF0C\\u4E5F\\u5C31\\u662F left(i,i) >= 0\\uFF0C\\u90A3\\u4E48\\u5982\\u679C\\u4F4D\\u7F6E i+1 \\u662F\\u6EE1\\u8DB3\\u6761\\u4EF6\\u7684\\u8D77\\u59CB\\u70B9\\uFF0C\\u90A3\\u4E48\\u5FC5\\u7136\\u6709 left(i+1, j) >= 0\\uFF0C\\u90A3\\u4E48\\u6709 left(i,j) = left(i,i+1) + left(i+1, j) >= 0\\uFF0C\\u4F46\\u662F\\u7ECF\\u8FC7\\u5224\\u65AD left(i,j) < 0\\uFF0C\\u6240\\u4EE5\\u540C\\u7406\\u5F97\\u5230 left(i+1, j) < 0\\uFF0C \\u6240\\u4EE5 i+1 \\u4E0D\\u662F\\u6EE1\\u8DB3\\u6761\\u4EF6\\u7684\\u8D77\\u59CB\\u70B9\\uFF0C\\u540C\\u7406\\uFF0C\\u4ECE i+1 \\u5230 j \\u4E2D\\u7684\\u4EFB\\u4F55\\u4E00\\u70B9\\u90FD\\u4E0D\\u6EE1\\u8DB3\\u6761\\u4EF6\\u3002\\n\\n\\u6240\\u4EE5\\uFF0C\\u4E0B\\u4E00\\u4E2A\\u5F85\\u5224\\u65AD\\u7684\\u8D77\\u59CB\\u70B9\\u662F j+1 \\uFF0C\\u6309\\u7167\\u540C\\u6837\\u7684\\u5224\\u65AD\\u65B9\\u6CD5\\uFF0C\\u4E00\\u76F4\\u5224\\u65AD\\u5230\\u6700\\u540E\\u4E00\\u4E2A\\u4F4D\\u7F6E n-1 \\uFF0C\\u5982\\u679C\\u5224\\u65AD\\u5230 n-1 \\u7684\\u65F6\\u5019\\u8FD8\\u6709 left(j+1, n-1) >= 0, \\u90A3\\u4E48\\u5C31\\u610F\\u5473\\u7740\\u8D77\\u59CB\\u70B9 j+1 \\u662F\\u4E00\\u79CD\\u53EF\\u80FD\\u89E3\\uFF0C\\u7136\\u540E\\u63A5\\u4E0B\\u6765\\u8FD8\\u8981\\u5224\\u65AD\\u4ECE\\u8FD9\\u4E2A\\u8D77\\u59CB\\u70B9\\u5F00\\u59CB\\u662F\\u5426\\u80FD\\u8D70\\u4E00\\u4E2A\\u73AF\\u8DEF\\uFF0C\\u5373\\u5224\\u65AD\\u662F\\u5426\\u6EE1\\u8DB3 left(j+1, n-1) + left(0, j) >= 0 \\u662F\\u5426\\u6210\\u7ACB\\u3002\\u5982\\u679C\\u6210\\u7ACB\\uFF0C\\u90A3\\u4E48 j+1 \\u786E\\u5B9A\\u5C31\\u662F\\u4E00\\u4E2A\\u6EE1\\u8DB3\\u6761\\u4EF6\\u7684\\u8D77\\u59CB\\u70B9\\uFF0C\\u800C\\u5982\\u679C\\u4E0D\\u6EE1\\u8DB3\\uFF0C\\u5219\\u5C31\\u8868\\u793A\\u9898\\u76EE\\u7ED9\\u5B9A\\u7684\\u6761\\u4EF6\\u6CA1\\u6709\\u6EE1\\u8DB3\\u6761\\u4EF6\\u7684\\u89E3\\u3002j+2 \\u5230 n-1 \\u4E2D\\u7684\\u6240\\u6709\\u8D77\\u59CB\\u70B9\\u662F\\u5426\\u90FD\\u4E0D\\u6EE1\\u8DB3\\u6761\\u4EF6\\uFF1F\\u540C\\u4E0A\\u9762 i+1 \\u5230 j \\u90FD\\u4E0D\\u6EE1\\u8DB3\\u7684\\u8BF4\\u660E\\uFF0C\\u4E0D\\u518D\\u8D58\\u8FF0\\u3002\\n\\n\\u6240\\u4EE5\\uFF0C\\u4EE3\\u7801\\u4E3A\\uFF1A\\n\\n```java\\nint len = gas.length, left = 0, result = -1;\\nboolean isOk = false;\\nfor (int i = 0; i < len; i++) {\\n    gas[i] -= cost[i];\\n    if (gas[i] >= 0 && left == 0) {\\n        isOk = true;\\n        result = i;\\n    }\\n    left += gas[i];\\n    if (left < 0) {\\n        left = 0;\\n        isOk = false;\\n    }\\n}\\nif (!isOk) {\\n    return -1;\\n} else {\\n    for (int i = 0; i < result; i++) {\\n        left += gas[i];\\n        if (left < 0) {\\n            return -1;\\n        }\\n    }\\n}\\nreturn result;\\n```\\n\\n\\u6B64\\u65F6\\u4EE3\\u7801\\u7684\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u4E3A$O(n)$\\uFF0C\\u7A7A\\u95F4\\u590D\\u6742\\u5EA6\\u4E3A$O(1)$\\u3002",
                "solutionTags": [],
                "code": "```java\\npublic static int canCompleteCircuit(int[] gas, int[] cost) {\\n    int len = gas.length;\\n    int left;\\n    for (int i = 0; i < len; i++) {\\n        left = 0;\\n        for (int j = 0; j < len; j++) {\\n            int pos = (i + j) % len;\\n            left += gas[pos] - cost[pos];\\n            if (left < 0) {\\n                break;\\n            }\\n            if (j == len-1) {\\n                return i;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\n```java\\nint len = gas.length, left = 0, result = -1;\\nboolean isOk = false;\\nfor (int i = 0; i < len; i++) {\\n    gas[i] -= cost[i];\\n    if (gas[i] >= 0 && left == 0) {\\n        isOk = true;\\n        result = i;\\n    }\\n    left += gas[i];\\n    if (left < 0) {\\n        left = 0;\\n        isOk = false;\\n    }\\n}\\nif (!isOk) {\\n    return -1;\\n} else {\\n    for (int i = 0; i < result; i++) {\\n        left += gas[i];\\n        if (left < 0) {\\n            return -1;\\n        }\\n    }\\n}\\nreturn result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 326359,
                "title": "c-85-beat-o-n-time-o-1-extra-space-linear-solution",
                "content": "This is an exhaustive approach. First we loop through the entire circut and get the cumulative sum. If it\\'s less than 0, there will not be any index from which we can start. If it\\'s 0 or greater, then there must be at least one index from which we can start.\\n\\nOn pass 2, we start with the assumption that there must be at least one index from which we can start.\\n\\nStart from index 0, loop forward... If our cumulative sum drops below 0, it means that our start index is incorrect. Furthermore, it means that any index between our start index and the current index are also invalid. (the first index yielded a positive net, but the current index is the \"killer\" index) -- this means that the correct answer starts later in the list. We move the start index past the current index and reset our tank. If we\\'ve exhausted every possibility except for n-1, then the final solution must be n-1.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int aCount = gas.size();\\n        int aTank = 0;\\n        int aIndex = 0;\\n        \\n        for (aIndex=0;aIndex<aCount;aIndex++) {\\n            aTank += gas[aIndex] - cost[aIndex];\\n        }\\n        \\n        //If we cannot complete the circuit with a positive tank,\\n        //then there is no index from which we can start.........\\n        if (aTank < 0) { return -1; }\\n        \\n        aTank = 0;\\n        int aStartIndex = 0;\\n        for (aIndex=0;aIndex<(aCount-1);aIndex++) {\\n            \\n            aTank += gas[aIndex] - cost[aIndex];\\n            \\n            if (aTank < 0) {\\n                //The previous start index we\\'ve attempted from has miffed.\\n                //Since we were positive at said starting index, it also holds\\n                //true that the indices between the start index and the current\\n                //index would also get the tank below 0... E.G. the index we JUST ARRIVED AT\\n                //is the index in which our tank goes negative. So there must be a later index\\n                //where our net is higher...\\n                aStartIndex = aIndex + 1;\\n                aTank = 0;\\n            }\\n        }\\n        \\n        return aStartIndex;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int aCount = gas.size();\\n        int aTank = 0;\\n        int aIndex = 0;\\n        \\n        for (aIndex=0;aIndex<aCount;aIndex++) {\\n            aTank += gas[aIndex] - cost[aIndex];\\n        }\\n        \\n        //If we cannot complete the circuit with a positive tank,\\n        //then there is no index from which we can start.........\\n        if (aTank < 0) { return -1; }\\n        \\n        aTank = 0;\\n        int aStartIndex = 0;\\n        for (aIndex=0;aIndex<(aCount-1);aIndex++) {\\n            \\n            aTank += gas[aIndex] - cost[aIndex];\\n            \\n            if (aTank < 0) {\\n                //The previous start index we\\'ve attempted from has miffed.\\n                //Since we were positive at said starting index, it also holds\\n                //true that the indices between the start index and the current\\n                //index would also get the tank below 0... E.G. the index we JUST ARRIVED AT\\n                //is the index in which our tank goes negative. So there must be a later index\\n                //where our net is higher...\\n                aStartIndex = aIndex + 1;\\n                aTank = 0;\\n            }\\n        }\\n        \\n        return aStartIndex;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 326355,
                "title": "c-o-n-2-straight-forward-solution-85-beat",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n    \\n        for (int aStartIndex=0;aStartIndex<gas.size();aStartIndex++) {\\n            \\n            int aGas = 0;\\n            int aIndex = aStartIndex;\\n            int aLoops = 0;\\n            while (aLoops < gas.size()) {\\n                \\n                aGas += gas[aIndex];\\n                aGas -= cost[aIndex];\\n                \\n                if (aGas < 0) { break; }\\n                \\n                aLoops += 1;\\n                aIndex += 1;\\n                if (aIndex == gas.size()) aIndex = 0;\\n            }\\n            \\n            if (aLoops == cost.size()) { return aStartIndex; }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n\\nHmm, pretty sure this can be done in O(N). Trying to \"see\" it. I can\\'t see. Dang!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n    \\n        for (int aStartIndex=0;aStartIndex<gas.size();aStartIndex++) {\\n            \\n            int aGas = 0;\\n            int aIndex = aStartIndex;\\n            int aLoops = 0;\\n            while (aLoops < gas.size()) {\\n                \\n                aGas += gas[aIndex];\\n                aGas -= cost[aIndex];\\n                \\n                if (aGas < 0) { break; }\\n                \\n                aLoops += 1;\\n                aIndex += 1;\\n                if (aIndex == gas.size()) aIndex = 0;\\n            }\\n            \\n            if (aLoops == cost.size()) { return aStartIndex; }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287948,
                "title": "c-greedy",
                "content": "```\\npublic class Solution {\\n    public int CanCompleteCircuit(int[] gas, int[] cost) {\\n        var n = gas.Length;\\n        var totalSum = 0;\\n        var rangeSum = 0;\\n\\n        var candidate = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            var diff = gas[i] - cost[i];\\n            totalSum += diff;\\n            rangeSum += diff;\\n\\n            if (rangeSum < 0) {\\n                candidate = i + 1;\\n                rangeSum = 0;\\n            }\\n        }\\n\\n        if (totalSum < 0) return -1;\\n\\n        return candidate;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int CanCompleteCircuit(int[] gas, int[] cost) {\\n        var n = gas.Length;\\n        var totalSum = 0;\\n        var rangeSum = 0;\\n\\n        var candidate = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            var diff = gas[i] - cost[i];\\n            totalSum += diff;\\n            rangeSum += diff;\\n\\n            if (rangeSum < 0) {\\n                candidate = i + 1;\\n                rangeSum = 0;\\n            }\\n        }\\n\\n        if (totalSum < 0) return -1;\\n\\n        return candidate;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 246879,
                "title": "simple-graphic-proof-and-easy-python-code",
                "content": "Okay it took me a big time to solve this one and I would like to share my solution (which is pretty much like others, but the proof is a little different I guess). It should be clear that if sum(cost) > sum(gas), then no solution is possible. Therefore, we are going to assume that sum(gas) >= sum(cost).\\n\\nBefore proving the Lemma, lets define gain[i] = gas[i] - cost[i] and \\ncurrGas[i] = gain[i], if i = 0;\\ncurrGas[i] = currGas[i - 1] + gain[i], otherwise.\\nNote currGas[i] corresponds to how much gas we would have at the tank at station i if we started at station 0.\\n\\nThen we have the following Lemma:\\nIf sum(gas) >= sum(cost), then k + 1 is a valid starting station, where k is the index such that currGas[k] is minimum.\\n\\nProof: Let optGas[j] denote how much gas we would have at the tank at station j if we started at station k + 1. Note that for all j between k and n, we have\\noptGas[j] = currGas[j] - currGas[k], \\nsince currGas[k] is minimum, currGas[j] >= currGas[k] and therefore optGas[j] >= 0. \\nThis should be clear in the next figure.\\n![image](https://assets.leetcode.com/users/jun_ota/image_1551493670.png)\\n\\n\\nA little harder is the blue part of the graph (j between 0 and k). For that part we have that \\noptGas[j] = currGas[n] - currGas[k] + currGas[j], \\nsince currGas[j] >= currGas[k] and  \\nsum(gas) >= sum(cost) => sum(gas) - sum(cost) >= 0 => currGas[n] >= 0. \\nWe have then that optGas[j] >= 0.\\n\\nThe following graphs should make it clear that, indeed, we need currGas[n] >= 0 to have a solution.\\n![image](https://assets.leetcode.com/users/jun_ota/image_1551493511.png)\\n\\nPython solution (kinda straightforward once you know the proof):\\n```\\nclass Solution(object):\\n    def canCompleteCircuit(self, gas, cost):\\n        \"\"\"\\n        :type gas: List[int]\\n        :type cost: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(gas)\\n        acc = 0\\n        start = 0\\n        minVal = 0\\n        for i in range(n):\\n            acc += gas[i] - cost[i]\\n            if acc < minVal:\\n                minVal = acc\\n                start = i + 1\\n        \\n        if acc < 0:\\n            return -1\\n        else:\\n            return start\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canCompleteCircuit(self, gas, cost):\\n        \"\"\"\\n        :type gas: List[int]\\n        :type cost: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(gas)\\n        acc = 0\\n        start = 0\\n        minVal = 0\\n        for i in range(n):\\n            acc += gas[i] - cost[i]\\n            if acc < minVal:\\n                minVal = acc\\n                start = i + 1\\n        \\n        if acc < 0:\\n            return -1\\n        else:\\n            return start\\n```",
                "codeTag": "Java"
            },
            {
                "id": 206911,
                "title": "python-beats-100-with-explanation-and-plots",
                "content": "```\\nclass Solution(object):\\n    def canCompleteCircuit(self, gas, cost):        \\n        n = len(gas)\\n        dp = [gas[0] - cost[0]]\\n        for i in range(1,n):\\n            dp.append(dp[-1] + gas[i] - cost[i])\\n        if dp[-1] < 0:\\n            return -1\\n        return (dp.index(min(dp)) + 1 )%n\\n```\\n\\nHere we can define a new function dp[x] = dp[x-1] + gas[x] - cost[x] (suppose dp[-1] = 0), which means that if we start at index 0, how many gas will remain in tank at index x. \\n\\t\\nUse the example in problem, here we can draw the dp[x]. \\ngas  = [1,2,3,4,5]\\ncost = [3,4,5,1,2]\\n![image](https://assets.leetcode.com/users/wxxaili/image_1545202275.png)\\nFrom the plot, we know at the end of trip, the gas in tank will be zero, which means we could finish the trip. If the gas in tank in the last index is smaller than 0, we should return -1 since it cannot finish the trip.\\n\\nMy solution is if we could finish the trip, we should start at the index which is the next index of minimum dp. For example, in the plot we should start at index 3 since dp[x] has the minimum value at index 2. The reason is that if we start index 3, which means we could move the line up such that dp[2] = 0, since dp[2] is the minumum value, if it\\'s equal to 0, then all the other value will be larger than 0. See the following plot.\\n![image](https://assets.leetcode.com/users/wxxaili/image_1545202775.png)\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canCompleteCircuit(self, gas, cost):        \\n        n = len(gas)\\n        dp = [gas[0] - cost[0]]\\n        for i in range(1,n):\\n            dp.append(dp[-1] + gas[i] - cost[i])\\n        if dp[-1] < 0:\\n            return -1\\n        return (dp.index(min(dp)) + 1 )%n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191463,
                "title": "",
                "content": "```\\n//\\u8FD9\\u91CC\\u7ED9\\u51FA\\u4E00\\u4E2A\\u6570\\u5B66\\u5B9A\\u7406\\u7684\\u8BC1\\u660E\\u3002\\u8BE5\\u6570\\u5B66\\u5B9A\\u7406\\u4E3A\\uFF1A\\u5047\\u5982\\u4E00\\u4E2A\\u73AF\\u5F62\\u8DEF\\u5F84\\u4E0A\\u7684\\u6240\\u6709\\u503C\\u7684\\u548C\\u4F4D\\u975E\\u8D1F\\uFF0C\\u90A3\\u4E48\\u5FC5\\u5B9A\\u5B58\\u5728\\u4E00\\u4E2A\\u8D77\\u59CB\\u70B9\\uFF0C\\u4F7F\\u5F97\\u4ECE\\u8BE5\\u8D77\\u59CB\\u70B9\\u51FA\\u53D1\\u5230\\u56DE\\n//\\u5230\\u8BE5\\u8D77\\u59CB\\u70B9\\u7684\\u8FC7\\u7A0B\\u4E2D\\uFF0C\\u8DEF\\u5F84\\u548C\\u7684\\u503C\\u4E00\\u76F4\\u90FD\\u4E3A\\u975E\\u8D1F\\u3002\\n//\\u5728\\u6211\\u4EEC\\u8FD9\\u9053\\u9898\\u76EE\\u91CC\\u9762\\u4E5F\\u5C31\\u662F\\uFF1A\\u5047\\u5982\\u603B\\u5171\\u7684\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u4E3A\\u975E\\u8D1F\\uFF0C\\u90A3\\u4E48\\u5FC5\\u5B9A\\u5B58\\u5728\\u4E00\\u4E2A\\u8D77\\u59CB\\u70B9\\uFF0C\\u5728\\u7ED5\\u5B8C\\u4E00\\u5708\\u7684\\u6574\\u4E2A\\u8FC7\\u7A0B\\u4E2D\\uFF0C\\u603B\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u603B\\u662F\\u4E3A\\u975E\\u8D1F\\u3002\\n\\n// \\u6CE8\\u610F\\uFF1A\\u8FD9\\u91CC\\u6240\\u8BF4\\u7684\\u603B\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u5176\\u5B9E\\u5C31\\u662F\\u8DEF\\u5F84\\u548C\\u3002\\u53EF\\u80FD\\u8868\\u8FF0\\u6709\\u70B9\\u4E71\\uFF0C\\u6240\\u4EE5\\u8FD9\\u91CC\\u9884\\u5148\\u7ED9\\u51FA\\u5B9A\\u4E49\\u3002\\n\\n// \\u5176\\u5B9E\\u5F88\\u597D\\u8BC1\\u660E\\uFF0C\\u53EA\\u9700\\u8981\\u8BC1\\u660E\\u539F\\u547D\\u9898\\u7684\\u9006\\u53CD\\u547D\\u9898\\uFF1A\\u5047\\u5982\\u5BF9\\u4E8E\\u6240\\u6709\\u7684\\u8D77\\u59CB\\u70B9\\uFF0C\\u5728\\u7ED5\\u5B8C\\u4E00\\u5708\\u7684\\u8FC7\\u7A0B\\u4E2D\\u90FD\\u5B58\\u5728\\u4E00\\u4E2A\\u4E2D\\u95F4\\u70B9\\u4F7F\\u5F97\\u4ECE\\u8D77\\u59CB\\u70B9\\u5230\\u8BE5\\u4E2D\\u95F4\\u70B9\\u7684\\u6CB9\\u8017\\n//\\u548C\\u5927\\u4E8E\\u6CB9\\u91CF\\u548C\\uFF0C\\u90A3\\u4E48\\u603B\\u5171\\u7684\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u4E00\\u5B9A\\u5C0F\\u4E8E0\\u3002\\u7136\\u540E\\u5462\\uFF0C\\u6211\\u4EEC\\u5047\\u8BBE\\u4ECEA\\u51FA\\u53D1\\uFF0C\\u90A3\\u4E48\\u4ECEA->A\\u7684\\u8FC7\\u7A0B\\u4E2D\\u5FC5\\u5B9A\\u5B58\\u5728B\\u4F7F\\u5F97sumGas\\u3010AB\\u3011- sumCost\\u3010AB\\u3011< 0\\uFF0C\\n//\\u6211\\u4EEC\\u4EE4\\u8BE5\\u5DEE\\u503C\\u4E3Ax\\u3002\\u7136\\u540E\\u4ECEB+1\\u51FA\\u53D1\\u5230A\\uFF0C\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u8BC1\\u660EB\\u5230A\\u7684\\u603B\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEEy\\u4E00\\u5B9A\\u5C0F\\u4E8E -x\\u5373\\u53EF\\u4F7F\\u5F97\\u539F\\u547D\\u9898\\u5F97\\u8BC1\\u3002 \\u90A3\\u4E48\\u73B0\\u5728\\u6211\\u4EEC\\u5047\\u8BBEy >= -x\\u3002\\u8003\\u8651\\n//\\u7B2C\\u4E00\\u79CD\\u60C5\\u51B5\\uFF1A\\u4ECEB\\u51FA\\u53D1\\u9047\\u5230\\u7684\\u7B2C\\u4E00\\u4E2A\\u603B\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u4E3A\\u8D1F\\u7684\\u70B9C\\u5728A\\u7684\\u540E\\u8FB9\\uFF08\\u4E5F\\u5C31C\\u5728A->B\\u8DEF\\u5F84\\u4E0A\\uFF08\\u4E0D\\u5305\\u62ECB\\uFF0C\\u4E0D\\u5305\\u62ECA\\uFF09 \\uFF09\\uFF0C\\u90A3\\u4E48\\u53EF\\u4EE5\\u77E5\\u9053B ->A\\u7684\\u603B\\n//\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u4E3A\\u6B63\\u3002\\u800C\\u4E14\\u6211\\u4EEC\\u77E5\\u9053\\u7684\\u662F\\uFF0CA\\u540E\\u9762\\u7684\\u7B2C\\u4E00\\u4E2A\\u8D1F\\u70B9\\u662FB\\uFF0C\\u4E5F\\u5C31\\u662F\\u4ECEA\\u51FA\\u53D1\\u7684\\uFF0C\\u4EE5A->B\\u8DEF\\u5F84\\u4E0AB\\u4E4B\\u524D\\u6240\\u6709\\u70B9\\u4E3A\\u7EC8\\u70B9\\u7684\\uFF0C\\u603B\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u5FC5\\u5B9A\\u4E3A\\n//\\u6B63\\uFF0C\\u90A3\\u4E48\\u53EF\\u4EE5\\u63A8\\u51FAA->C\\u7684\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u4E3A\\u6B63\\u3002\\u90A3\\u4E48B->C\\u7684\\u603B\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u5FC5\\u5B9A\\u4E3A\\u6B63\\uFF0C\\u6545\\u800C\\u5BFC\\u81F4\\u77DB\\u76FE\\u3002\\u4E5F\\u5C31\\u662F\\u8BF4\\u8FD9\\u79CD\\u60C5\\u51B5\\u4E0D\\u53EF\\u80FD\\u5B58\\u5728\\u3002\\u90A3\\u4E48\\u8003\\u8651\\u7B2C\\u4E8C\\u79CD\\n//\\u60C5\\u51B5\\uFF1A\\u4ECEB\\u51FA\\u53D1\\u9047\\u5230\\u7684\\u7B2C\\u4E00\\u4E2A\\u603B\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u4E3A\\u8D1F\\u7684\\u70B9C\\u5728A\\u7684\\u540E\\u8FB9\\uFF08\\u4E5F\\u5C31C\\u5728B ->A\\u8DEF\\u5F84\\u4E0A\\uFF08\\u5305\\u62ECA\\uFF0C\\u5305\\u62ECB+1\\uFF09 \\uFF09\\uFF0C\\u90A3\\u4E48\\u6211\\u4EEC\\u53EF\\u4EE5\\u4EE4B->C\\u7684\\u603B\\u6CB9\\u91CF\\u6CB9\\n//\\u8017\\u5DEE\\u4E3Ax1,\\u7136\\u540E\\u4ECEC\\u51FA\\u53D1\\u3002\\u7136\\u540E\\u5462\\uFF0C\\u7531\\u6211\\u4EEC\\u7684\\u5047\\u8BBE\\u53EF\\u4EE5\\u77E5\\u9053\\u4ECEC\\u51FA\\u53D1\\u4E5F\\u4F1A\\u9047\\u5230\\u4E00\\u4E2A\\u603B\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u4E3A\\u8D1F\\u7684\\u70B9D\\uFF0C\\u4E14\\u540C\\u7406D\\u5FC5\\u5B9A\\u5728C -> A\\u7684\\u8DEF\\u5F84\\u4E0A\\uFF08\\u5305\\u62EC\\n//C+1\\u4E0D\\u5305\\u62ECA\\uFF09\\u3002\\u5FAA\\u73AF\\u524D\\u9762\\u7684\\u903B\\u8F91\\uFF0C\\u5FC5\\u5B9A\\u4F1A\\u51FA\\u73B0\\u4E00\\u4E2A\\u8D77\\u70B9\\u4E3AS\\uFF0C\\u7EC8\\u70B9\\u4E3AA\\u7684\\u8DEF\\u5F84\\uFF0C\\u4E14\\u8BE5\\u8DEF\\u5F84\\u7684\\u603B\\u6CB9\\u91CF\\u6CB9\\u8017\\u548C\\u4E3A\\u8D1F\\uFF08\\u56E0\\u4E3A\\u6211\\u4EEC\\u524D\\u9762\\u5047\\u8BBE\\u4E86\\u5BF9\\u4E8E\\u6240\\u6709\\u7684\\u8D77\\n//\\u59CB\\u70B9\\uFF0C\\u5728\\u7ED5\\u5B8C\\u4E00\\u5708\\u7684\\u8FC7\\u7A0B\\u4E2D\\u90FD\\u5B58\\u5728\\u4E00\\u4E2A\\u4E2D\\u95F4\\u70B9\\u4F7F\\u5F97\\u4ECE\\u8D77\\u59CB\\u70B9\\u5230\\u8BE5\\u4E2D\\u95F4\\u70B9\\u7684\\u6CB9\\u8017\\u548C\\u5927\\u4E8E\\u6CB9\\u91CF\\u548C\\uFF09\\u3002\\u8FD9\\u6837\\u5462\\uFF0C\\u6211\\u4EEC\\u5C31\\u53EF\\u4EE5\\u5F97\\u51FA\\u7ED3\\u8BBA\\uFF0CB->A\\u7684\\u603B\\u6CB9\\u91CF\\u6CB9\\n//\\u8017\\u5DEE\\u4E3A\\u8D1F\\u3002\\u4E5F\\u5C31\\u662Fy < 0 < - x\\u3002\\u90A3\\u4E48A->B + B->A = A >A\\u4E3A\\u8D1F\\uFF0C\\u4E5F\\u5C31\\u662F\\u603B\\u8DEF\\u5F84\\u548C\\u4E3A\\u8D1F\\u3002\\u6545\\u800C\\u7B2C\\u4E8C\\u79CD\\u60C5\\u51B5\\u6EE1\\u8DB3\\u547D\\u9898\\u3002\\u5F53\\u7136\\u6211\\u4EEC\\u8FD8\\u6F0F\\u4E86\\u7B2C\\u4E09\\u79CD\\u60C5\\u51B5\\uFF0C\\u5C31\\n//\\u662FB\\u7684\\u4E0B\\u4E00\\u4E2A\\u8D1F\\u70B9\\u8FD8\\u662FB\\uFF0C\\u6216\\u8005C\\u7684\\u4E0B\\u4E00\\u4E2A\\u8D1F\\u70B9\\u662FB\\u6216C\\uFF0C\\u6216\\u8005D\\u7684\\u4E0B\\u4E00\\u4E2A\\u8D1F\\u70B9\\u662FB\\u6216C\\u6216D\\u3002\\u8FD9\\u79CD\\u60C5\\u51B5\\u5462\\u53EA\\u9700\\u8981\\u628A\\u56FE\\u753B\\u4E00\\u753B\\u5C31\\u5F88\\u597D\\u8BC1\\u660E\\u4E86\\u3002\\u8FD9\\u91CC\\u4E3E\\u4E2A\\u4F8B\\n//\\u5B50\\uFF0C\\u5047\\u5982B\\u7684\\u4E0B\\u4E00\\u4E2A\\u8D1F\\u70B9\\u662FB\\uFF0C\\u90A3\\u4E48\\u53EF\\u4EE5\\u77E5\\u9053\\u7ED5\\u5B8C\\u4E00\\u5708\\u7684\\u603B\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u5FC5\\u5B9A\\u4E3A\\u8D1F\\u3002\\u4E5F\\u5C31\\u662F\\u547D\\u9898\\u5F97\\u8BC1\\u3002\\u7EE7\\u7EED\\uFF0C\\u5047\\u5982C\\u7684\\u4E0B\\u4E00\\u4E2A\\u8D1F\\u70B9\\u662FB\\uFF0C\\u90A3\\u4E48C->B\\u4E3A\\n//\\u8D1F\\uFF0CB->C\\u4E3A\\u8D1F\\uFF0C\\u90A3\\u4E48C->C\\u81EA\\u7136\\u4E3A\\u8D1F\\uFF0C\\u5F97\\u8BC1\\u3002\\n//\\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5047\\u5982\\u5BF9\\u4E8E\\u6240\\u6709\\u7684\\u8D77\\u59CB\\u70B9\\uFF0C\\u5728\\u7ED5\\u5B8C\\u4E00\\u5708\\u7684\\u8FC7\\u7A0B\\u4E2D\\u90FD\\u5B58\\u5728\\u4E00\\u4E2A\\u4E2D\\u95F4\\u70B9\\u4F7F\\u5F97\\u4ECE\\u8D77\\u59CB\\u70B9\\u5230\\u8BE5\\u4E2D\\u95F4\\u70B9\\u7684\\u6CB9\\u8017\\u548C\\u5927\\u4E8E\\u6CB9\\u91CF\\u548C\\uFF0C\\u90A3\\u4E48\\u603B\\u5171\\u7684\\u6CB9\\u91CF\\u6CB9\\u8017\\n//\\u5DEE\\u4E00\\u5B9A\\u5C0F\\u4E8E0\\u3002\\u4E5F\\u5C31\\u662F\\u5047\\u5982\\u603B\\u5171\\u7684\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u4E3A\\u975E\\u8D1F\\uFF0C\\u90A3\\u4E48\\u5FC5\\u5B9A\\u5B58\\u5728\\u4E00\\u4E2A\\u8D77\\u59CB\\u70B9\\uFF0C\\u5728\\u7ED5\\u5B8C\\u4E00\\u5708\\u7684\\u6574\\u4E2A\\u8FC7\\u7A0B\\u4E2D\\uFF0C\\u603B\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u603B\\u662F\\u4E3A\\u975E\\u8D1F\\u3002\\n\\n\\n//\\u53E6\\u5916\\u5462\\uFF0C\\u591A\\u4F59\\u7684\\u8BDD\\u6211\\u5C31\\u4E0D\\u8BF4\\u4E86\\u3002\\u8BF4\\u4E0B\\u4E3A\\u4EC0\\u4E48\\u5BF9\\u4E8E\\u4E00\\u4E2Astart\\u53EA\\u9700\\u8981\\u626B\\u63CF\\u5230\\u6570\\u7EC4\\u672B\\u5C3E\\u800C\\u4E0D\\u9700\\u8981\\u7EE7\\u7EED\\u626B\\u63CF0 ~ (start-1)\\u7684\\u503C\\u3002\\u539F\\u56E0\\u5982\\u4E0B\\uFF1A\\u5047\\u5982\\u6574\\u4E2A\\u8DEF\\u5F84\\u7684\\n//gas\\u603B\\u548C\\u5927\\u4E8Ecost\\u603B\\u548C\\uFF0C\\u90A3\\u4E48\\u5FC5\\u5B9A\\u5B58\\u5728\\u4E00\\u4E2Astart\\u53EF\\u4EE5\\u8D70\\u5B8C\\u5168\\u7A0B\\u3002\\u5047\\u5982\\u8BF4\\u904D\\u5386\\u5230\\u67D0\\u4E2Astart\\uFF0C\\u4F7F\\u5F97\\u8F66\\u5B50\\u53EF\\u4EE5\\u901A\\u8FC7\\u4ECEstart\\u5230gas.length - 1\\u7684\\u6574\\u6761\\u8DEF\\u5F84\\uFF0C\\u90A3\\u4E48\\n//\\u8FD9\\u4E2Astart\\u5FC5\\u5B9A\\u5C31\\u662F\\u6211\\u4EEC\\u8981\\u627E\\u7684\\u8D77\\u59CB\\u70B9\\u3002\\u56E0\\u4E3A\\u5047\\u5982\\u4ECE\\u8BE5start\\u8D77\\u6B65\\u4E0D\\u80FD\\u8D70\\u5B8C\\u5168\\u7A0B\\u7684\\u8BDD\\uFF0C\\u90A3\\u4E48\\u4EE5start+1\\u5230gas.length-1\\u6240\\u6709\\u70B9\\u4E3A\\u8D77\\u70B9\\u51FA\\u53D1\\uFF0C\\u90FD\\u4E0D\\u53EF\\u80FD\\u8D70\\u5B8C\\n//\\u5168\\u7A0B\\u3002\\u4E3E\\u4E2A\\u4F8B\\u5B50\\u6211\\u4EEC\\u627E\\u5230\\u4E86\\u7B26\\u5408\\u4E0A\\u8FF0\\u6761\\u4EF6\\u7684start,\\u90A3\\u4E48gas[start] - cost[start]\\u4E00\\u5B9A\\u662F>=0\\u7684\\u3002\\u5047\\u5982\\u8BE5start\\u4E0D\\u80FD\\u8D70\\u5B8C\\u5168\\u7A0B\\uFF0C\\u90A3\\u4E48\\u5FC5\\u5B9A\\u5B58\\u57280 ~ (start-1)\\u7684\\n//\\u67D0\\u4E2A\\u70B9\\uFF0C\\u4F7F\\u5F97\\u8DEF\\u5F84\\u548C\\u4E3A\\u8D1F\\u3002\\u73B0\\u5728\\u6211\\u4EEC\\u4ECEstart+1\\u5F00\\u59CB\\u8D70\\uFF0C\\u8D70\\u5230\\u8BE5\\u70B9\\u4E5F\\u5FC5\\u5B9A\\u4E3A\\u8D1F\\u3002\\u6240\\u4EE5\\u8BF4\\u5F53\\u6211\\u4EEC\\u627E\\u5230\\u53EF\\u4EE5\\u4F7F\\u5F97\\u8F66\\u5B50\\u901A\\u8FC7start\\u5230gas.length - 1\\u8DEF\\u5F84\\u7684start\\n//\\u65F6\\u3002\\u53EA\\u8981\\u6574\\u6761\\u8DEF\\u5F84\\u7684gas\\u548C>=\\u6574\\u6761\\u8DEF\\u5F84\\u7684cost\\u548C\\uFF0C\\u90A3\\u4E48\\u8BE5start\\u5FC5\\u5B9A\\u5C31\\u662F\\u6211\\u4EEC\\u8981\\u627E\\u7684\\u80FD\\u8D70\\u901A\\u5168\\u7A0B\\u7684\\u8D77\\u70B9\\u3002\\n\\n\\nThank for the idea of @dkerkcuygt. Here is a neat way to prove. \\n\\u5047\\u8BBE\\u628A\\u65E0\\u7A77\\u591A\\u4E2A\\u52A0\\u6CB9\\u7AD9\\u6392\\u5728\\u4E00\\u8D77\\u3002 \\u89C4\\u5B9A\\u53EA\\u80FD\\u5F80\\u53F3\\u3002\\u4ECE0\\u5F00\\u59CB\\u8BA1\\u7B97\\u8FD9\\u4E2A\\u65E0\\u7A77\\u7684\\u5E8F\\u5217\\u4E0A\\u6BCF\\u4E2A\\u70B9\\u7684\\u5269\\u4F59\\u6CB9\\u91CF\\uFF0C\\u5269\\u4F59\\u91CF\\u5141\\u8BB8\\u4E3A\\u8D1F\\u6570\\u3002\\n\\u6709\\u89E3\\u7684\\u60C5\\u51B5\\u7B49\\u4EF7\\u4E8E\\uFF0C \\u4ECE\\u67D0\\u4E2A\\u4F4D\\u7F6Ei\\u5F00\\u59CB\\uFF0C \\u8FDE\\u7EEDn\\u4E2A\\u4F4D\\u7F6E\\u7684\\u5269\\u4F59\\u91CF\\u4E0D\\u5C0F\\u4E8E\\u4F4D\\u7F6Ei\\u7684\\u5269\\u4F59\\u91CF\\u3002\\n\\n\\u4F1A\\u6709\\u4E09\\u79CD\\u60C5\\u51B5\\uFF1A\\n\\n\\u8D70\\u5B8C\\u4E00\\u904D\\u4EE5\\u540E\\uFF0C\\u6CB9\\u91CF\\u589E\\u52A0\\n\\u8D70\\u5B8C\\u4E00\\u904D\\u4EE5\\u540E\\u6CB9\\u91CF\\u4E0D\\u53D8\\n\\u8D70\\u5B8C\\u4E00\\u904D\\u4EE5\\u540E\\u6CB9\\u91CF\\u51CF\\u5C11\\n1\\uFF0C \\u4E00\\u5B9A\\u80FD\\u627E\\u5230\\u89E3\\n2\\uFF0C\\u8FD9\\u79CD\\u60C5\\u51B5\\u4E0B\\uFF0C \\u89E3\\u5B58\\u5728\\uFF0C\\u5373 \\u201C\\u5468\\u671F\\u51FD\\u6570\\u4E00\\u5B9A\\u6709\\u6700\\u5927\\u503C\\u548C\\u6700\\u5C0F\\u503C\\u3002 \\u53EA\\u8981\\u4ECE\\u6700\\u5C0F\\u503C\\u51FA\\u53D1\\uFF0C\\u6C38\\u8FDC\\u4E0D\\u4F1A\\u4F4E\\u4E8E\\u521D\\u503C\\u3002\\u201D\\n3\\uFF0C \\u4E00\\u5B9A\\u65E0\\u89E3\\n\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int curSum = 0;\\n        int total = 0;\\n        int start = 0;\\n        for(int i = 0; i < gas.length; i++){\\n            curSum += gas[i] - cost[i];\\n            total += gas[i] - cost[i];\\n            if(curSum < 0){\\n                curSum = 0;\\n                start = i + 1;\\n            }\\n        }\\n        \\n        return total >= 0 ? start : -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//\\u8FD9\\u91CC\\u7ED9\\u51FA\\u4E00\\u4E2A\\u6570\\u5B66\\u5B9A\\u7406\\u7684\\u8BC1\\u660E\\u3002\\u8BE5\\u6570\\u5B66\\u5B9A\\u7406\\u4E3A\\uFF1A\\u5047\\u5982\\u4E00\\u4E2A\\u73AF\\u5F62\\u8DEF\\u5F84\\u4E0A\\u7684\\u6240\\u6709\\u503C\\u7684\\u548C\\u4F4D\\u975E\\u8D1F\\uFF0C\\u90A3\\u4E48\\u5FC5\\u5B9A\\u5B58\\u5728\\u4E00\\u4E2A\\u8D77\\u59CB\\u70B9\\uFF0C\\u4F7F\\u5F97\\u4ECE\\u8BE5\\u8D77\\u59CB\\u70B9\\u51FA\\u53D1\\u5230\\u56DE\\n//\\u5230\\u8BE5\\u8D77\\u59CB\\u70B9\\u7684\\u8FC7\\u7A0B\\u4E2D\\uFF0C\\u8DEF\\u5F84\\u548C\\u7684\\u503C\\u4E00\\u76F4\\u90FD\\u4E3A\\u975E\\u8D1F\\u3002\\n//\\u5728\\u6211\\u4EEC\\u8FD9\\u9053\\u9898\\u76EE\\u91CC\\u9762\\u4E5F\\u5C31\\u662F\\uFF1A\\u5047\\u5982\\u603B\\u5171\\u7684\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u4E3A\\u975E\\u8D1F\\uFF0C\\u90A3\\u4E48\\u5FC5\\u5B9A\\u5B58\\u5728\\u4E00\\u4E2A\\u8D77\\u59CB\\u70B9\\uFF0C\\u5728\\u7ED5\\u5B8C\\u4E00\\u5708\\u7684\\u6574\\u4E2A\\u8FC7\\u7A0B\\u4E2D\\uFF0C\\u603B\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u603B\\u662F\\u4E3A\\u975E\\u8D1F\\u3002\\n\\n// \\u6CE8\\u610F\\uFF1A\\u8FD9\\u91CC\\u6240\\u8BF4\\u7684\\u603B\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u5176\\u5B9E\\u5C31\\u662F\\u8DEF\\u5F84\\u548C\\u3002\\u53EF\\u80FD\\u8868\\u8FF0\\u6709\\u70B9\\u4E71\\uFF0C\\u6240\\u4EE5\\u8FD9\\u91CC\\u9884\\u5148\\u7ED9\\u51FA\\u5B9A\\u4E49\\u3002\\n\\n// \\u5176\\u5B9E\\u5F88\\u597D\\u8BC1\\u660E\\uFF0C\\u53EA\\u9700\\u8981\\u8BC1\\u660E\\u539F\\u547D\\u9898\\u7684\\u9006\\u53CD\\u547D\\u9898\\uFF1A\\u5047\\u5982\\u5BF9\\u4E8E\\u6240\\u6709\\u7684\\u8D77\\u59CB\\u70B9\\uFF0C\\u5728\\u7ED5\\u5B8C\\u4E00\\u5708\\u7684\\u8FC7\\u7A0B\\u4E2D\\u90FD\\u5B58\\u5728\\u4E00\\u4E2A\\u4E2D\\u95F4\\u70B9\\u4F7F\\u5F97\\u4ECE\\u8D77\\u59CB\\u70B9\\u5230\\u8BE5\\u4E2D\\u95F4\\u70B9\\u7684\\u6CB9\\u8017\\n//\\u548C\\u5927\\u4E8E\\u6CB9\\u91CF\\u548C\\uFF0C\\u90A3\\u4E48\\u603B\\u5171\\u7684\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u4E00\\u5B9A\\u5C0F\\u4E8E0\\u3002\\u7136\\u540E\\u5462\\uFF0C\\u6211\\u4EEC\\u5047\\u8BBE\\u4ECEA\\u51FA\\u53D1\\uFF0C\\u90A3\\u4E48\\u4ECEA->A\\u7684\\u8FC7\\u7A0B\\u4E2D\\u5FC5\\u5B9A\\u5B58\\u5728B\\u4F7F\\u5F97sumGas\\u3010AB\\u3011- sumCost\\u3010AB\\u3011< 0\\uFF0C\\n//\\u6211\\u4EEC\\u4EE4\\u8BE5\\u5DEE\\u503C\\u4E3Ax\\u3002\\u7136\\u540E\\u4ECEB+1\\u51FA\\u53D1\\u5230A\\uFF0C\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u8BC1\\u660EB\\u5230A\\u7684\\u603B\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEEy\\u4E00\\u5B9A\\u5C0F\\u4E8E -x\\u5373\\u53EF\\u4F7F\\u5F97\\u539F\\u547D\\u9898\\u5F97\\u8BC1\\u3002 \\u90A3\\u4E48\\u73B0\\u5728\\u6211\\u4EEC\\u5047\\u8BBEy >= -x\\u3002\\u8003\\u8651\\n//\\u7B2C\\u4E00\\u79CD\\u60C5\\u51B5\\uFF1A\\u4ECEB\\u51FA\\u53D1\\u9047\\u5230\\u7684\\u7B2C\\u4E00\\u4E2A\\u603B\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u4E3A\\u8D1F\\u7684\\u70B9C\\u5728A\\u7684\\u540E\\u8FB9\\uFF08\\u4E5F\\u5C31C\\u5728A->B\\u8DEF\\u5F84\\u4E0A\\uFF08\\u4E0D\\u5305\\u62ECB\\uFF0C\\u4E0D\\u5305\\u62ECA\\uFF09 \\uFF09\\uFF0C\\u90A3\\u4E48\\u53EF\\u4EE5\\u77E5\\u9053B ->A\\u7684\\u603B\\n//\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u4E3A\\u6B63\\u3002\\u800C\\u4E14\\u6211\\u4EEC\\u77E5\\u9053\\u7684\\u662F\\uFF0CA\\u540E\\u9762\\u7684\\u7B2C\\u4E00\\u4E2A\\u8D1F\\u70B9\\u662FB\\uFF0C\\u4E5F\\u5C31\\u662F\\u4ECEA\\u51FA\\u53D1\\u7684\\uFF0C\\u4EE5A->B\\u8DEF\\u5F84\\u4E0AB\\u4E4B\\u524D\\u6240\\u6709\\u70B9\\u4E3A\\u7EC8\\u70B9\\u7684\\uFF0C\\u603B\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u5FC5\\u5B9A\\u4E3A\\n//\\u6B63\\uFF0C\\u90A3\\u4E48\\u53EF\\u4EE5\\u63A8\\u51FAA->C\\u7684\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u4E3A\\u6B63\\u3002\\u90A3\\u4E48B->C\\u7684\\u603B\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u5FC5\\u5B9A\\u4E3A\\u6B63\\uFF0C\\u6545\\u800C\\u5BFC\\u81F4\\u77DB\\u76FE\\u3002\\u4E5F\\u5C31\\u662F\\u8BF4\\u8FD9\\u79CD\\u60C5\\u51B5\\u4E0D\\u53EF\\u80FD\\u5B58\\u5728\\u3002\\u90A3\\u4E48\\u8003\\u8651\\u7B2C\\u4E8C\\u79CD\\n//\\u60C5\\u51B5\\uFF1A\\u4ECEB\\u51FA\\u53D1\\u9047\\u5230\\u7684\\u7B2C\\u4E00\\u4E2A\\u603B\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u4E3A\\u8D1F\\u7684\\u70B9C\\u5728A\\u7684\\u540E\\u8FB9\\uFF08\\u4E5F\\u5C31C\\u5728B ->A\\u8DEF\\u5F84\\u4E0A\\uFF08\\u5305\\u62ECA\\uFF0C\\u5305\\u62ECB+1\\uFF09 \\uFF09\\uFF0C\\u90A3\\u4E48\\u6211\\u4EEC\\u53EF\\u4EE5\\u4EE4B->C\\u7684\\u603B\\u6CB9\\u91CF\\u6CB9\\n//\\u8017\\u5DEE\\u4E3Ax1,\\u7136\\u540E\\u4ECEC\\u51FA\\u53D1\\u3002\\u7136\\u540E\\u5462\\uFF0C\\u7531\\u6211\\u4EEC\\u7684\\u5047\\u8BBE\\u53EF\\u4EE5\\u77E5\\u9053\\u4ECEC\\u51FA\\u53D1\\u4E5F\\u4F1A\\u9047\\u5230\\u4E00\\u4E2A\\u603B\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u4E3A\\u8D1F\\u7684\\u70B9D\\uFF0C\\u4E14\\u540C\\u7406D\\u5FC5\\u5B9A\\u5728C -> A\\u7684\\u8DEF\\u5F84\\u4E0A\\uFF08\\u5305\\u62EC\\n//C+1\\u4E0D\\u5305\\u62ECA\\uFF09\\u3002\\u5FAA\\u73AF\\u524D\\u9762\\u7684\\u903B\\u8F91\\uFF0C\\u5FC5\\u5B9A\\u4F1A\\u51FA\\u73B0\\u4E00\\u4E2A\\u8D77\\u70B9\\u4E3AS\\uFF0C\\u7EC8\\u70B9\\u4E3AA\\u7684\\u8DEF\\u5F84\\uFF0C\\u4E14\\u8BE5\\u8DEF\\u5F84\\u7684\\u603B\\u6CB9\\u91CF\\u6CB9\\u8017\\u548C\\u4E3A\\u8D1F\\uFF08\\u56E0\\u4E3A\\u6211\\u4EEC\\u524D\\u9762\\u5047\\u8BBE\\u4E86\\u5BF9\\u4E8E\\u6240\\u6709\\u7684\\u8D77\\n//\\u59CB\\u70B9\\uFF0C\\u5728\\u7ED5\\u5B8C\\u4E00\\u5708\\u7684\\u8FC7\\u7A0B\\u4E2D\\u90FD\\u5B58\\u5728\\u4E00\\u4E2A\\u4E2D\\u95F4\\u70B9\\u4F7F\\u5F97\\u4ECE\\u8D77\\u59CB\\u70B9\\u5230\\u8BE5\\u4E2D\\u95F4\\u70B9\\u7684\\u6CB9\\u8017\\u548C\\u5927\\u4E8E\\u6CB9\\u91CF\\u548C\\uFF09\\u3002\\u8FD9\\u6837\\u5462\\uFF0C\\u6211\\u4EEC\\u5C31\\u53EF\\u4EE5\\u5F97\\u51FA\\u7ED3\\u8BBA\\uFF0CB->A\\u7684\\u603B\\u6CB9\\u91CF\\u6CB9\\n//\\u8017\\u5DEE\\u4E3A\\u8D1F\\u3002\\u4E5F\\u5C31\\u662Fy < 0 < - x\\u3002\\u90A3\\u4E48A->B + B->A = A >A\\u4E3A\\u8D1F\\uFF0C\\u4E5F\\u5C31\\u662F\\u603B\\u8DEF\\u5F84\\u548C\\u4E3A\\u8D1F\\u3002\\u6545\\u800C\\u7B2C\\u4E8C\\u79CD\\u60C5\\u51B5\\u6EE1\\u8DB3\\u547D\\u9898\\u3002\\u5F53\\u7136\\u6211\\u4EEC\\u8FD8\\u6F0F\\u4E86\\u7B2C\\u4E09\\u79CD\\u60C5\\u51B5\\uFF0C\\u5C31\\n//\\u662FB\\u7684\\u4E0B\\u4E00\\u4E2A\\u8D1F\\u70B9\\u8FD8\\u662FB\\uFF0C\\u6216\\u8005C\\u7684\\u4E0B\\u4E00\\u4E2A\\u8D1F\\u70B9\\u662FB\\u6216C\\uFF0C\\u6216\\u8005D\\u7684\\u4E0B\\u4E00\\u4E2A\\u8D1F\\u70B9\\u662FB\\u6216C\\u6216D\\u3002\\u8FD9\\u79CD\\u60C5\\u51B5\\u5462\\u53EA\\u9700\\u8981\\u628A\\u56FE\\u753B\\u4E00\\u753B\\u5C31\\u5F88\\u597D\\u8BC1\\u660E\\u4E86\\u3002\\u8FD9\\u91CC\\u4E3E\\u4E2A\\u4F8B\\n//\\u5B50\\uFF0C\\u5047\\u5982B\\u7684\\u4E0B\\u4E00\\u4E2A\\u8D1F\\u70B9\\u662FB\\uFF0C\\u90A3\\u4E48\\u53EF\\u4EE5\\u77E5\\u9053\\u7ED5\\u5B8C\\u4E00\\u5708\\u7684\\u603B\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u5FC5\\u5B9A\\u4E3A\\u8D1F\\u3002\\u4E5F\\u5C31\\u662F\\u547D\\u9898\\u5F97\\u8BC1\\u3002\\u7EE7\\u7EED\\uFF0C\\u5047\\u5982C\\u7684\\u4E0B\\u4E00\\u4E2A\\u8D1F\\u70B9\\u662FB\\uFF0C\\u90A3\\u4E48C->B\\u4E3A\\n//\\u8D1F\\uFF0CB->C\\u4E3A\\u8D1F\\uFF0C\\u90A3\\u4E48C->C\\u81EA\\u7136\\u4E3A\\u8D1F\\uFF0C\\u5F97\\u8BC1\\u3002\\n//\\u7EFC\\u4E0A\\u6240\\u8FF0\\uFF0C\\u5047\\u5982\\u5BF9\\u4E8E\\u6240\\u6709\\u7684\\u8D77\\u59CB\\u70B9\\uFF0C\\u5728\\u7ED5\\u5B8C\\u4E00\\u5708\\u7684\\u8FC7\\u7A0B\\u4E2D\\u90FD\\u5B58\\u5728\\u4E00\\u4E2A\\u4E2D\\u95F4\\u70B9\\u4F7F\\u5F97\\u4ECE\\u8D77\\u59CB\\u70B9\\u5230\\u8BE5\\u4E2D\\u95F4\\u70B9\\u7684\\u6CB9\\u8017\\u548C\\u5927\\u4E8E\\u6CB9\\u91CF\\u548C\\uFF0C\\u90A3\\u4E48\\u603B\\u5171\\u7684\\u6CB9\\u91CF\\u6CB9\\u8017\\n//\\u5DEE\\u4E00\\u5B9A\\u5C0F\\u4E8E0\\u3002\\u4E5F\\u5C31\\u662F\\u5047\\u5982\\u603B\\u5171\\u7684\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u4E3A\\u975E\\u8D1F\\uFF0C\\u90A3\\u4E48\\u5FC5\\u5B9A\\u5B58\\u5728\\u4E00\\u4E2A\\u8D77\\u59CB\\u70B9\\uFF0C\\u5728\\u7ED5\\u5B8C\\u4E00\\u5708\\u7684\\u6574\\u4E2A\\u8FC7\\u7A0B\\u4E2D\\uFF0C\\u603B\\u6CB9\\u91CF\\u6CB9\\u8017\\u5DEE\\u603B\\u662F\\u4E3A\\u975E\\u8D1F\\u3002\\n\\n\\n//\\u53E6\\u5916\\u5462\\uFF0C\\u591A\\u4F59\\u7684\\u8BDD\\u6211\\u5C31\\u4E0D\\u8BF4\\u4E86\\u3002\\u8BF4\\u4E0B\\u4E3A\\u4EC0\\u4E48\\u5BF9\\u4E8E\\u4E00\\u4E2Astart\\u53EA\\u9700\\u8981\\u626B\\u63CF\\u5230\\u6570\\u7EC4\\u672B\\u5C3E\\u800C\\u4E0D\\u9700\\u8981\\u7EE7\\u7EED\\u626B\\u63CF0 ~ (start-1)\\u7684\\u503C\\u3002\\u539F\\u56E0\\u5982\\u4E0B\\uFF1A\\u5047\\u5982\\u6574\\u4E2A\\u8DEF\\u5F84\\u7684\\n//gas\\u603B\\u548C\\u5927\\u4E8Ecost\\u603B\\u548C\\uFF0C\\u90A3\\u4E48\\u5FC5\\u5B9A\\u5B58\\u5728\\u4E00\\u4E2Astart\\u53EF\\u4EE5\\u8D70\\u5B8C\\u5168\\u7A0B\\u3002\\u5047\\u5982\\u8BF4\\u904D\\u5386\\u5230\\u67D0\\u4E2Astart\\uFF0C\\u4F7F\\u5F97\\u8F66\\u5B50\\u53EF\\u4EE5\\u901A\\u8FC7\\u4ECEstart\\u5230gas.length - 1\\u7684\\u6574\\u6761\\u8DEF\\u5F84\\uFF0C\\u90A3\\u4E48\\n//\\u8FD9\\u4E2Astart\\u5FC5\\u5B9A\\u5C31\\u662F\\u6211\\u4EEC\\u8981\\u627E\\u7684\\u8D77\\u59CB\\u70B9\\u3002\\u56E0\\u4E3A\\u5047\\u5982\\u4ECE\\u8BE5start\\u8D77\\u6B65\\u4E0D\\u80FD\\u8D70\\u5B8C\\u5168\\u7A0B\\u7684\\u8BDD\\uFF0C\\u90A3\\u4E48\\u4EE5start+1\\u5230gas.length-1\\u6240\\u6709\\u70B9\\u4E3A\\u8D77\\u70B9\\u51FA\\u53D1\\uFF0C\\u90FD\\u4E0D\\u53EF\\u80FD\\u8D70\\u5B8C\\n//\\u5168\\u7A0B\\u3002\\u4E3E\\u4E2A\\u4F8B\\u5B50\\u6211\\u4EEC\\u627E\\u5230\\u4E86\\u7B26\\u5408\\u4E0A\\u8FF0\\u6761\\u4EF6\\u7684start,\\u90A3\\u4E48gas[start] - cost[start]\\u4E00\\u5B9A\\u662F>=0\\u7684\\u3002\\u5047\\u5982\\u8BE5start\\u4E0D\\u80FD\\u8D70\\u5B8C\\u5168\\u7A0B\\uFF0C\\u90A3\\u4E48\\u5FC5\\u5B9A\\u5B58\\u57280 ~ (start-1)\\u7684\\n//\\u67D0\\u4E2A\\u70B9\\uFF0C\\u4F7F\\u5F97\\u8DEF\\u5F84\\u548C\\u4E3A\\u8D1F\\u3002\\u73B0\\u5728\\u6211\\u4EEC\\u4ECEstart+1\\u5F00\\u59CB\\u8D70\\uFF0C\\u8D70\\u5230\\u8BE5\\u70B9\\u4E5F\\u5FC5\\u5B9A\\u4E3A\\u8D1F\\u3002\\u6240\\u4EE5\\u8BF4\\u5F53\\u6211\\u4EEC\\u627E\\u5230\\u53EF\\u4EE5\\u4F7F\\u5F97\\u8F66\\u5B50\\u901A\\u8FC7start\\u5230gas.length - 1\\u8DEF\\u5F84\\u7684start\\n//\\u65F6\\u3002\\u53EA\\u8981\\u6574\\u6761\\u8DEF\\u5F84\\u7684gas\\u548C>=\\u6574\\u6761\\u8DEF\\u5F84\\u7684cost\\u548C\\uFF0C\\u90A3\\u4E48\\u8BE5start\\u5FC5\\u5B9A\\u5C31\\u662F\\u6211\\u4EEC\\u8981\\u627E\\u7684\\u80FD\\u8D70\\u901A\\u5168\\u7A0B\\u7684\\u8D77\\u70B9\\u3002\\n\\n\\nThank for the idea of @dkerkcuygt. Here is a neat way to prove. \\n\\u5047\\u8BBE\\u628A\\u65E0\\u7A77\\u591A\\u4E2A\\u52A0\\u6CB9\\u7AD9\\u6392\\u5728\\u4E00\\u8D77\\u3002 \\u89C4\\u5B9A\\u53EA\\u80FD\\u5F80\\u53F3\\u3002\\u4ECE0\\u5F00\\u59CB\\u8BA1\\u7B97\\u8FD9\\u4E2A\\u65E0\\u7A77\\u7684\\u5E8F\\u5217\\u4E0A\\u6BCF\\u4E2A\\u70B9\\u7684\\u5269\\u4F59\\u6CB9\\u91CF\\uFF0C\\u5269\\u4F59\\u91CF\\u5141\\u8BB8\\u4E3A\\u8D1F\\u6570\\u3002\\n\\u6709\\u89E3\\u7684\\u60C5\\u51B5\\u7B49\\u4EF7\\u4E8E\\uFF0C \\u4ECE\\u67D0\\u4E2A\\u4F4D\\u7F6Ei\\u5F00\\u59CB\\uFF0C \\u8FDE\\u7EEDn\\u4E2A\\u4F4D\\u7F6E\\u7684\\u5269\\u4F59\\u91CF\\u4E0D\\u5C0F\\u4E8E\\u4F4D\\u7F6Ei\\u7684\\u5269\\u4F59\\u91CF\\u3002\\n\\n\\u4F1A\\u6709\\u4E09\\u79CD\\u60C5\\u51B5\\uFF1A\\n\\n\\u8D70\\u5B8C\\u4E00\\u904D\\u4EE5\\u540E\\uFF0C\\u6CB9\\u91CF\\u589E\\u52A0\\n\\u8D70\\u5B8C\\u4E00\\u904D\\u4EE5\\u540E\\u6CB9\\u91CF\\u4E0D\\u53D8\\n\\u8D70\\u5B8C\\u4E00\\u904D\\u4EE5\\u540E\\u6CB9\\u91CF\\u51CF\\u5C11\\n1\\uFF0C \\u4E00\\u5B9A\\u80FD\\u627E\\u5230\\u89E3\\n2\\uFF0C\\u8FD9\\u79CD\\u60C5\\u51B5\\u4E0B\\uFF0C \\u89E3\\u5B58\\u5728\\uFF0C\\u5373 \\u201C\\u5468\\u671F\\u51FD\\u6570\\u4E00\\u5B9A\\u6709\\u6700\\u5927\\u503C\\u548C\\u6700\\u5C0F\\u503C\\u3002 \\u53EA\\u8981\\u4ECE\\u6700\\u5C0F\\u503C\\u51FA\\u53D1\\uFF0C\\u6C38\\u8FDC\\u4E0D\\u4F1A\\u4F4E\\u4E8E\\u521D\\u503C\\u3002\\u201D\\n3\\uFF0C \\u4E00\\u5B9A\\u65E0\\u89E3\\n\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int curSum = 0;\\n        int total = 0;\\n        int start = 0;\\n        for(int i = 0; i < gas.length; i++){\\n            curSum += gas[i] - cost[i];\\n            total += gas[i] - cost[i];\\n            if(curSum < 0){\\n                curSum = 0;\\n                start = i + 1;\\n            }\\n        }\\n        \\n        return total >= 0 ? start : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 157204,
                "title": "simple-o-n-java-w-explanation",
                "content": "```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        \\n        int N = gas.length;\\n        int guess = 0;\\n        int cum = 0;\\n        int sum = 0;\\n        \\n        for(int i = 0; i < N; ++i){\\n            cum += (gas[i] - cost[i]);\\n            sum += (gas[i] - cost[i]);\\n            \\n            if(cum < 0){\\n                cum = 0;\\n                guess = (i + 1) % N;\\n            }\\n        }\\n        \\n        return (sum >= 0) ? guess : -1;\\n    }\\n}\\n```\\n\\nFor a lot of these problems such as *Gas Station* or *Find the Celebrity* I am applying the trick I like to call \"**guessing game**\" what I mean by this is, I start with guess and then eliminate possiblities and *finally* do a check making sure this guess is correct.\\n\\nHow did I apply it here?\\n\\n1. Start with `guess = 0`\\n2. Eliminate candidates\\n3. Finally, after `for` loop is done, I have a candidate `guess` and a `sum` value, I know that if `sum >= 0` then that means my `guess` **must** be correct. That is the definition of the problem. So I apply this final check and return `guess` if `sum >= 0` and `-1` otherwise.\\n\\nStep **2** might seem tricky so I\\'ll try to explain here.\\n\\nConsider I start at `guess = 0`. Now I run a for loop and I\\'m on station `i = 0`. I know that to get to `i + 1` I must consume `gas[i] - cost[i]`, lets say `gas[i] - cost[i] >= 0` this means from station `i` I can move to station `i + 1`. Ok cool, now I\\'m on station `i + 1`. To get to `i + 2` I must consume additional `gas[i] - cost[i]` so add this to `cum`. What if `cum < 0`. This means I can\\'t go to `i + 2`. \\nGeneralize this and say I started with `i` and found out that I can\\'t go from `i + 10` to `i + 11`. \\n\\nThis *also* means that I can\\'t from from any of `{i + 1, i + 2, i + 3, ... , i + 9}` to `i  + 11`. If you are wondering why, just think. Going from `i` to `i + 5` means you ended up with *at least* `cum >= 0`, otherwise it wouldn\\'t be possible. If you start `i + 5` you by default start with `cum = 0`, so in the worst case they are both the same, so if you started from `i` and failed to get to `i + 11` you also can\\'t go from `i + 5` to `i + 11`.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        \\n        int N = gas.length;\\n        int guess = 0;\\n        int cum = 0;\\n        int sum = 0;\\n        \\n        for(int i = 0; i < N; ++i){\\n            cum += (gas[i] - cost[i]);\\n            sum += (gas[i] - cost[i]);\\n            \\n            if(cum < 0){\\n                cum = 0;\\n                guess = (i + 1) % N;\\n            }\\n        }\\n        \\n        return (sum >= 0) ? guess : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42605,
                "title": "c-3ms-maximum-subarray-kadane",
                "content": "If there is indeed a solution and it's unique, then the starting offset of the maximum subarray would give us that relevant offset. \\n\\nThe problem here is about ensuring that the net available gas is always >=0. Which means we need to find that subarray sequence which helps us accumulate maximum fuel. Essentially the maximum subarray. \\n\\nPlus, in an interview setting you might just get some bonus points for illustrating Kadane. \\n\\n```\\nint canCompleteCircuit(int* gas, int gasSize, int* cost, int costSize)\\n{\\n    int i, sum = 0, pos = 0, max_sum = 0, total_sum = 0, max_pos = 0;\\n\\n    /* Find the maximum sub-array */\\n    for (i = 0; i < gasSize; ++i) {\\n        total_sum += gas[i] - cost[i]; // keep track of the total sum\\n\\n        /* Kadane's algorithm */\\n        if (gas[i] - cost[i] + sum > gas[i] - cost[i])\\n            sum += gas[i] - cost[i];\\n        else {\\n            sum = gas[i] - cost[i];\\n            pos = i;\\n        }\\n\\n        /* Keep track of maximum sub-array sum and location */\\n        if (sum > max_sum) {\\n            max_sum =  sum;\\n            max_pos = pos;\\n        }\\n    }\\n\\n    /* If the maximum sub-array straddles both the ends, then update\\n    position. Note that \"sum\" is the last accumulated sub-array sum. */\\n    if (max_pos == 0 && max_sum + sum > max_sum)\\n        max_pos = pos;\\n    /* If we have a solution, then return the offset */\\n    return total_sum >= 0 ? max_pos : -1;\\n}\\n``",
                "solutionTags": [
                    "C"
                ],
                "code": "If there is indeed a solution and it's unique, then the starting offset of the maximum subarray would give us that relevant offset. \\n\\nThe problem here is about ensuring that the net available gas is always >=0. Which means we need to find that subarray sequence which helps us accumulate maximum fuel. Essentially the maximum subarray. \\n\\nPlus, in an interview setting you might just get some bonus points for illustrating Kadane. \\n\\n```\\nint canCompleteCircuit(int* gas, int gasSize, int* cost, int costSize)\\n{\\n    int i, sum = 0, pos = 0, max_sum = 0, total_sum = 0, max_pos = 0;\\n\\n    /* Find the maximum sub-array */\\n    for (i = 0; i < gasSize; ++i) {\\n        total_sum += gas[i] - cost[i]; // keep track of the total sum\\n\\n        /* Kadane's algorithm */\\n        if (gas[i] - cost[i] + sum > gas[i] - cost[i])\\n            sum += gas[i] - cost[i];\\n        else {\\n            sum = gas[i] - cost[i];\\n            pos = i;\\n        }\\n\\n        /* Keep track of maximum sub-array sum and location */\\n        if (sum > max_sum) {\\n            max_sum =  sum;\\n            max_pos = pos;\\n        }\\n    }\\n\\n    /* If the maximum sub-array straddles both the ends, then update\\n    position. Note that \"sum\" is the last accumulated sub-array sum. */\\n    if (max_pos == 0 && max_sum + sum > max_sum)\\n        max_pos = pos;\\n    /* If we have a solution, then return the offset */\\n    return total_sum >= 0 ? max_pos : -1;\\n}\\n``",
                "codeTag": "Unknown"
            },
            {
                "id": 42611,
                "title": "8-ms-c-using-accumulation-sum",
                "content": "    class Solution {\\n    public:\\n        int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n            if(gas.empty()) return -1;\\n            int min=gas[0]-cost[0],sum=gas[0]-cost[0],index=0;\\n            /*compute the accumulation sum of gas[i]-cost[i], when it takes minimum, the starting point should be the next station*/\\n            for(int i=1;i<gas.size();i++){\\n                sum += gas[i]-cost[i];\\n                if(sum<min){\\n                    min = sum;\\n                    index = i;\\n                }\\n            }\\n            if(sum<0) return -1;\\n            else return (index+1)%gas.size();\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n            if(gas.empty()) return -1;\\n            int min=gas[0]-cost[0],sum=gas[0]-cost[0],index=0;\\n            /*compute the accumulation sum of gas[i]-cost[i], when it takes minimum, the starting point should be the next station*/\\n            for(int i=1;i<gas.size();i++){\\n                sum += gas[i]-cost[i];\\n                if(sum<min){\\n                    min = sum;\\n                    index = i;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 42642,
                "title": "share-my-mathematical-proof",
                "content": "It seems for me that there lacks the complete mathematical proof of the O(n) solution, so I want to share my thoughts here.\\n\\nLet total = (gas[0] - cost[0]) + (gas[1] - cost[1]) + ... + (gas[N] - cost[N]). If total >= 0, then there must exist at least one j, where 0 <= j <= N, that sum(j, N) = (gas[j] - cost[j]) + ... + (gas[N] - cost[N]) >= 0 without any place being negative. In other words, there mush be a gas station j that if we start from it, we can arrive at the first station. Let j represents the first station satisfies this property. Then there are k blocking points, where 0 <= b1 < b2 < ... < bk <= j - 1, 1 <= k <= j, such that the sum between (0, b1), (b1, b2), ..., (bk-1, bk) are negative. Then we have total = sum(0, b1) + ... + sum(bk-1, bk) + sum(j, N). When total >= 0, we have sum(j, N) >= -sum(0, b1) + ... + -sum(bk-1, bk), based on the definition, we can infer that we can go from j to j.\\n\\nSo after the proof, the algorithm and code just come naturally:\\n\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        if (gas == null || cost == null || gas.length != cost.length) return -1;\\n        if (gas.length == 0) return -1;\\n        int total = 0, sum = 0, diff = 0;\\n        int start = 0;\\n        for (int i = 0; i < gas.length; i++) {\\n            diff = gas[i] - cost[i];\\n            if ((sum += diff) < 0) {\\n                start = i + 1;\\n                sum = 0;\\n            }\\n            total += diff;\\n        }\\n        return total >= 0 ? start : -1;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "It seems for me that there lacks the complete mathematical proof of the O(n) solution, so I want to share my thoughts here.\\n\\nLet total = (gas[0] - cost[0]) + (gas[1] - cost[1]) + ... + (gas[N] - cost[N]). If total >= 0, then there must exist at least one j, where 0 <= j <= N, that sum(j, N) = (gas[j] - cost[j]) + ... + (gas[N] - cost[N]) >= 0 without any place being negative. In other words, there mush be a gas station j that if we start from it, we can arrive at the first station. Let j represents the first station satisfies this property. Then there are k blocking points, where 0 <= b1 < b2 < ... < bk <= j - 1, 1 <= k <= j, such that the sum between (0, b1), (b1, b2), ..., (bk-1, bk) are negative. Then we have total = sum(0, b1) + ... + sum(bk-1, bk) + sum(j, N). When total >= 0, we have sum(j, N) >= -sum(0, b1) + ... + -sum(bk-1, bk), based on the definition, we can infer that we can go from j to j.\\n\\nSo after the proof, the algorithm and code just come naturally:\\n\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        if (gas == null || cost == null || gas.length != cost.length) return -1;\\n        if (gas.length == 0) return -1;\\n        int total = 0, sum = 0, diff = 0;\\n        int start = 0;\\n        for (int i = 0; i < gas.length; i++) {\\n            diff = gas[i] - cost[i];\\n            if ((sum += diff) < 0) {\\n                start = i + 1;\\n                sum = 0;\\n            }\\n            total += diff;\\n        }\\n        return total >= 0 ? start : -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 42656,
                "title": "8ms-simple-o-n-c-solution",
                "content": "    class Solution {\\n    public:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int idx = -1, total = 0, maxn = -1;\\n        for(int i = cost.size()-1; i >= 0; --i)\\n        {\\n            total += gas[i] - cost[i];\\n            if(total > maxn)\\n            {\\n                idx = i;\\n                maxn = total;\\n            }\\n        }\\n        return total>=0?idx:-1;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int idx = -1, total = 0, maxn = -1;\\n        for(int i = cost.size()-1; i >= 0; --i)\\n        {\\n            total += gas[i] - cost[i];\\n            if(total > maxn)\\n            {\\n                idx = i;\\n                maxn = total;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 42662,
                "title": "test-cases-not-good-enough-wrong-solution-accepted",
                "content": "My C++ code which is not correct is getting accepted by OJ. But on test gas[]={5,8,2,8}; and cost[]={6,5,6,6}; it should return 3 but it returns 1 which is wrong. I hope LeetCode will add the testcase.\\n\\n    class Solution {\\n    public:\\n        int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n            int initial_idx=-1,current_idx=-1,max_diff=-1,diff=0,possible=0;\\n            int n=gas.size();\\n            for(int i=0;i<n;i++){\\n                diff+=gas[i]-cost[i];\\n                possible+=gas[i]-cost[i];\\n                if(diff>=0){\\n                    if(current_idx==-1)\\n                            current_idx=i;\\n                    if(diff>max_diff){\\n                        max_diff=diff;\\n                        initial_idx=current_idx;\\n                    }\\n                } else{\\n                    current_idx=-1;\\n                    diff=0;\\n                }\\n            }\\n           \\n            if(diff>0){\\n                int sum=0,pre=0;\\n                for(int i=0;(i<n)&&(sum>=0);i++){\\n                    pre=sum>pre?sum:pre;\\n                    sum+=gas[i]-cost[i];\\n                }\\n                if(pre+diff>max_diff)\\n                    initial_idx=current_idx;\\n            }\\n            if(possible<0)\\n                return -1;\\n            else\\n                return initial_idx;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n            int initial_idx=-1,current_idx=-1,max_diff=-1,diff=0,possible=0;\\n            int n=gas.size();\\n            for(int i=0;i<n;i++){\\n                diff+=gas[i]-cost[i];\\n                possible+=gas[i]-cost[i];\\n                if(diff>=0){\\n                    if(current_idx==-1)\\n                            current_idx=i;\\n                    if(diff>max_diff){\\n                        max_diff=diff;\\n                        initial_idx=current_idx;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 42682,
                "title": "based-on-the-question-description-the-direction-should-be-clockwise",
                "content": " After checking the discussion here I found some guys are wondering whether we can travel from right to left, I checked based on the test cases on LeetCode OJ, we can only travel from left to right, as clockwise direction. The first function below is from right to left and can't pass the OJ like the case: gas = [1, 2, 3, 4, 5], cost = [3, 4, 5, 1, 2]. If we can travel from right to left, then 4 (the last station) should be the starting point, while the OJ said we should return 3, which is corresponding to the second function, from left to right. After checking the question description carefully, we can find that \"it costs cost[i] of gas to travel from station i to its next station (i+1)\", so it means we can only travel from smaller number station to bigger number station, and the last station is a special case, which will return to the first station, station 0. Actually I think for this kind of greedy questions or dynamic questions, if we didn't encounter them before or didn't practice intensively, it will be quite hard to devise a solution in a 45 minutes interview. So practice, practice, practice ...\\n     \\n    # can't pass OJ\\n    def canCompleteCircuit1(self, gas, cost):\\n        ret, s, cur = len(gas)-1, 0, 0\\n        for i in xrange(len(gas)-1, -1, -1):\\n            cur += (gas[i] - cost[i])\\n            s += (gas[i] - cost[i])\\n            if cur < 0:\\n                cur = 0\\n                ret = i - 1\\n        return -1 if s < 0 else ret\\n        \\n    # can pass OJ\\n    def canCompleteCircuit2(self, gas, cost):\\n        ret, s, cur = 0, 0, 0\\n        for i in xrange(len(gas)):\\n            cur += (gas[i] - cost[i])\\n            s += (gas[i] - cost[i])\\n            if cur < 0:\\n                cur = 0\\n                ret = i + 1\\n        return -1 if s < 0 else ret",
                "solutionTags": [
                    "Python"
                ],
                "code": " After checking the discussion here I found some guys are wondering whether we can travel from right to left, I checked based on the test cases on LeetCode OJ, we can only travel from left to right, as clockwise direction. The first function below is from right to left and can't pass the OJ like the case: gas = [1, 2, 3, 4, 5], cost = [3, 4, 5, 1, 2]. If we can travel from right to left, then 4 (the last station) should be the starting point, while the OJ said we should return 3, which is corresponding to the second function, from left to right. After checking the question description carefully, we can find that \"it costs cost[i] of gas to travel from station i to its next station (i+1)\", so it means we can only travel from smaller number station to bigger number station, and the last station is a special case, which will return to the first station, station 0. Actually I think for this kind of greedy questions or dynamic questions, if we didn't encounter them before or didn't practice intensively, it will be quite hard to devise a solution in a 45 minutes interview. So practice, practice, practice ...\\n     \\n    # can't pass OJ\\n    def canCompleteCircuit1(self, gas, cost):\\n        ret, s, cur = len(gas)-1, 0, 0\\n        for i in xrange(len(gas)-1, -1, -1):\\n            cur += (gas[i] - cost[i])\\n            s += (gas[i] - cost[i])\\n            if cur < 0:\\n                cur = 0\\n                ret = i - 1\\n        return -1 if s < 0 else ret\\n        \\n    # can pass OJ\\n    def canCompleteCircuit2(self, gas, cost):\\n        ret, s, cur = 0, 0, 0\\n        for i in xrange(len(gas)):\\n            cur += (gas[i] - cost[i])\\n            s += (gas[i] - cost[i])\\n            if cur < 0:\\n                cur = 0\\n                ret = i + 1\\n        return -1 if s < 0 else ret",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1565115,
                "content": [
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan anyone please explain with giving some examples also to make it clear what is asked? thanks"
                    },
                    {
                        "username": "LOVEGURU",
                        "content": "Gas is gas station, Cost is amount of gas required to travel from i to i+1 station. we need to find index .From that we can complete the journey if we do not find index return -1.\\nour main agenda is find index we can travel from i to n-1 in the circular way"
                    },
                    {
                        "username": "Joseph86",
                        "content": "[@calm27](/calm27) I was in 5th grade in 2015 :0"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "whoa..  ancient comments were full of respect and gratitude!"
                    },
                    {
                        "username": "calm27",
                        "content": "[@heisenberg280](/heisenberg280) no way 2015 was 8 years ago, mate. no way "
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "[@heisenberg280](/heisenberg280)  \\uD83D\\uDE02\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Msey",
                        "content": "[@heisenberg280](/heisenberg280) or not and gave up :)"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@studcoder569](/studcoder569) Jul 29, 2015"
                    },
                    {
                        "username": "studcoder569",
                        "content": "[@heisenberg280](/heisenberg280) Good point lol"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "[@heisenberg280](/heisenberg280) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@studcoder569](/studcoder569) love your dedication but after 8 long years she might have understood the question by now :)"
                    },
                    {
                        "username": "studcoder569",
                        "content": "The question is asking you to find a starting gas station on the circuit that will allow you to complete one round trip without running out of gas. It is possible for there to be no solution. If there is a solution, the test cases are written such that it is unique. The examples shown in the description illustrate how the road trip would work. "
                    },
                    {
                        "username": "dadick",
                        "content": "Hint: if you start from station `a` and stuck at `b`, then you can't get to `b` from any station between `a` and `b`."
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) at position a we are getting some positive value \"y\" and from a to b we are adding some \"x\"  ..so if x+y cant cross b then obviously x alone cant cross b....... in your case we can reach to position 2 but cant cross it"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) reached to position to 2 but we cant reach to next position ..\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "what if ,gas={2,3,1,5} cost={1,2,4,3} i start at station 0 and reach station 2, and get stuck there, but i can start at station 1 and reach station 2, so your hint is proved wrong successfully "
                    },
                    {
                        "username": "khan60939",
                        "content": "[@mimirave](/mimirave) same confusion"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Bye bye TLE \\uD83D\\uDC4B"
                    },
                    {
                        "username": "mimirave",
                        "content": "Am I misunderstanding this hint?: If I start at station 0, successfully get to station 1, successfully get to station 2 but cannot complete the trip to station 3, then I am stuck at station 2 and the hint says that I cannot get to station 2 from station 1.  "
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "thanks! overcame TLE"
                    },
                    {
                        "username": "Jayasurya_K",
                        "content": "Thanks Buddy! TLE cracked..!"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "Thanks! TLE eliminator hint"
                    },
                    {
                        "username": "vanchanr",
                        "content": "good one !"
                    },
                    {
                        "username": "huanpipt",
                        "content": "Overcome TLE with this tip :) "
                    },
                    {
                        "username": "w286432531",
                        "content": "Thanks. I went from TLE to accepted with this hint."
                    },
                    {
                        "username": "CourteousCoder",
                        "content": "In order to prepare for an interview, it is more important that I am able to recognized the pattern in this problem.\\n\\nCan someone please help me identify the pattern of this problem?\\n\\nIs this a variation of a classic problem in Computer Science?\\nIf so, which?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of those problems that don\\'t fall under any category. It simply is just understanding the problem and utilizing problem solving"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "so how was your interview\\n"
                    },
                    {
                        "username": "kardopaska",
                        "content": "This is a classic problem of misdirection.  Description clearly states that valid answers include travel in clockwise direction only!  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "yueyunpeng",
                        "content": "I solved it with a two pass algorithm fairly quickly, the idea is:\\n\\n1. First just assum the gas tank can fall below zero, complete a loop starting at position 0, and record the index with lowest amount of gas (possibly negative) in tank, call it `lowest_idx`.\\n\\n2. Complete a loop starting from `lowest_idx`, break and return `-1` if the tank falls below zero at any point. Return `lowest_idx` if it never fell below zero.\\n\\nSure it\\'s not one pass, but extremely easy to understand, guarantees to be O(N) time and O(1) space, and did pass all tests. Am I missing anything?"
                    },
                    {
                        "username": "ggx94",
                        "content": "[@Kaltu](/Kaltu) I think they have tried to fix it (test case 39/40 for me...) but there is still a bug. The solution is still not unique,"
                    },
                    {
                        "username": "crazytan",
                        "content": "What if there are multiple indices with lowest amount of gas?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "There is a bug in the testcase `gas=[2,1,0,0]`, `cost=[0,1,0,0]`, the problem statement says the solution is unique but start from every index can complete the circuit\\nThe system can detect duplicated solution if we rotate the pairs by 1 to `gas=[0,2,1,0]`, `cost=[0,0,1,0]`, then it says \"Invalid Testcase\" \"The answer should be unique.\"\\n\\nBefore LeetCode remove this bugged testcase, be sure to account this.\\nFor example, when computing lowest_idx, make sure you keep updating it when ever the lowest gas tank are hit, so we can skip the [0, 0] gas/cost pairs"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": " int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "NishantGautam",
                        "content": "[@Yue Yunpeng](/yueyunpeng) how did you arrive at the thinking that I have to start at the station with lowest amount of gas."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Trick to solve circular path problems: Explains in under three minutes:\\nhttps://youtu.be/IEnJSIOOtOg"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "[@er_sushant](/er_sushant)  we can move forward onle if gas>0 so we should always keep this in mind.so,if(gas<=0)break; we can\\'t move further"
                    },
                    {
                        "username": "er_sushant",
                        "content": "[@abhi098](/abhi098) we can guarantee at the last station when `gas >= 0`, this means there is enough gas to make one circular circuit atleast once. if we found `gas < 0`, in any of the station, means we don\\'t have enough gas to move to next station.\\nAlso try various test cases for better understanding."
                    },
                    {
                        "username": "abhi098",
                        "content": "[@jobless_lm10](/jobless_lm10) how can you guarentee that when gas >0 at the last station, you can complete the whole circle from where you start ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "no need to do second pass. If gas remaining at the end of first pass is less than 0 then we can never go round all stations from any station. Otherwise we can go round all from lowest_idx + 1."
                    },
                    {
                        "username": "evidem64",
                        "content": "Problem description states:\\n> If there exists a solution, it is guaranteed to be unique\\n\\nOn submission my solution fails for the following case:\\n> [1,2,3,4,5,6,7,8]\\n> [1,2,3,4,5,6,7,8]\\n\\nClearly, there IS a solution, but it\\'s NOT unique, since\\nyou can start at any of the stations.\\nExpected answer is 0 though, anything else gets rejected.\\n"
                    },
                    {
                        "username": "emil_i_lonneberga",
                        "content": "Another test case that failed to satisfy the uniqueness is gas = [2, 0, 0, 0, ..., 0], cost =[0, 1, 0, 0, ..., 0]. If the test cases cannot be guaranteed to be unique, then additional restrictions like finding the minimum of all viable starting index should be placed. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@nishant7372](/nishant7372) `gas=[2,1,0,0, .... ,0,0]`, `cost=[0,1,0,0, .... ,0,0]` This one is a system testcase, the expected answer is `0` but we can clearly see that every index is actually valid.\nAND, if we rotate it by 1 to `gas=[0,2,1,0,0, .... ,0]`, `cost=[0,0,1,0,0, .... ,0]` as a custom testcase, the system now complains it has non-unique answer.\nThe problem is a circular problem, simply shifting the index in the array representation should not make any difference."
                    },
                    {
                        "username": "labbiahmed",
                        "content": "only one time tank == 0 . in this scenario this test case invalid . every time when you arrived a next station your tank is empty. \\n"
                    },
                    {
                        "username": "mudit_loya",
                        "content": "yes .. the solution is not unique .. even i have testcases where there many solutions"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "Isn\\'t this an invalid test case. It\\'s giving me invalid test case output."
                    },
                    {
                        "username": "jotho_",
                        "content": "There are more than one correct starting stations for that testcase, so it will be rejected."
                    },
                    {
                        "username": "aneesh1029",
                        "content": "You are starting from starting station at 0th index so return the first station possible"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "I think we need to return the smallest possible answer"
                    },
                    {
                        "username": "nishant7372",
                        "content": "I think all the system testcases have a unique answer."
                    },
                    {
                        "username": "banty",
                        "content": "This is not a rant, I genuinly want to know what is it that this problem trying to test so that I can practice it more and be better at it"
                    },
                    {
                        "username": "RB213",
                        "content": "This question is stupid, the language is so convoluted and examples are poor. But this situation does happen in real life when customers/product can\\'t express the problem clearly and engineers build poorly designed system. "
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "It is simply about problem solving skill + greedy technique i think"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "The problem does not state we want the smallest index as a result.\\n\\n[1,6,3,4,5]\\n[3,4,5,1,2]\\n\\nSo, why the answer 3 is not accpeted for the above test case ??\\n"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "The question mentions that the answer is unique. Your test case has two answers. Hence, the wrong one."
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question is very confusing. "
                    },
                    {
                        "username": "pavankumar",
                        "content": "Hi all,\\nI've written the code in suchaway that my solution validates all possible starting positions. I know that this is a very inefficient code to find the solution and finally i got time limit exceeded. can anybody give suggestions on how to solve this in an efficient way. I don't need code  but logic fine.\\n\\nThanks\\npavan kumar"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I know this comment is now almost a decade old at this point but here\\'s what I did. Try keeping track of the difference between the gas and cost as that\\'s what really matters for the problem. You might have to look when to avoid (hint the value will be negative so you can\\'t reach that place anyways). Here\\'s an example:\\n```[1,2,3,4,5] gas\\n[3,4,5,1,2] cost\\n[-2,-2,-2,3,3] -> difference between gas and cost (use variable instead of array for better space)\\n  0  1   2 3 4 -> index\\n```\\nthe net value till index 2 is negative (always -2 so we can ignore till there because it is not possible to move to the next point from these position.\\nfor index 3 this can be a possible answer. But what about having another net negative value in between (say -4)\\n```\\n[-2,-2,-2,3,-4,3]\\n```\\nwe can no longer use the index 3 now. But if you look closely we will find that for the above case it\\'s impossible to have a solution (output is -1). Reason is becase sum(gas)-sum(cost) is negative.\\nBut what for \\n```\\n[-2,-2,-2,3,-4,10]\\n```\\nHere we will keep track of the `minimum valid index`. Since, the answer is unique we can have only 1 valid index. Hence, using a Integer.MAX_VALUE as the initial answer and choosing the min and reassigning it to Integer.MAX_VALUE when the initially possible valid index (the index 3 in this case) is incorrect answer.\\n\\nLink to code: https://leetcode.com/problems/gas-station/solutions/3012347/easy-python-solution/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`The most unbelievable thing about this question isn\\'t that the car has unlimited gas tank, but the fact that I have got money to pay for it`"
                    },
                    {
                        "username": "pushpit_singh",
                        "content": "Us bhai Us"
                    },
                    {
                        "username": "dileep9259",
                        "content": "wah !!! :P\\n"
                    }
                ]
            },
            {
                "id": 1745609,
                "content": [
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan anyone please explain with giving some examples also to make it clear what is asked? thanks"
                    },
                    {
                        "username": "LOVEGURU",
                        "content": "Gas is gas station, Cost is amount of gas required to travel from i to i+1 station. we need to find index .From that we can complete the journey if we do not find index return -1.\\nour main agenda is find index we can travel from i to n-1 in the circular way"
                    },
                    {
                        "username": "Joseph86",
                        "content": "[@calm27](/calm27) I was in 5th grade in 2015 :0"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "whoa..  ancient comments were full of respect and gratitude!"
                    },
                    {
                        "username": "calm27",
                        "content": "[@heisenberg280](/heisenberg280) no way 2015 was 8 years ago, mate. no way "
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "[@heisenberg280](/heisenberg280)  \\uD83D\\uDE02\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Msey",
                        "content": "[@heisenberg280](/heisenberg280) or not and gave up :)"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@studcoder569](/studcoder569) Jul 29, 2015"
                    },
                    {
                        "username": "studcoder569",
                        "content": "[@heisenberg280](/heisenberg280) Good point lol"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "[@heisenberg280](/heisenberg280) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@studcoder569](/studcoder569) love your dedication but after 8 long years she might have understood the question by now :)"
                    },
                    {
                        "username": "studcoder569",
                        "content": "The question is asking you to find a starting gas station on the circuit that will allow you to complete one round trip without running out of gas. It is possible for there to be no solution. If there is a solution, the test cases are written such that it is unique. The examples shown in the description illustrate how the road trip would work. "
                    },
                    {
                        "username": "dadick",
                        "content": "Hint: if you start from station `a` and stuck at `b`, then you can't get to `b` from any station between `a` and `b`."
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) at position a we are getting some positive value \"y\" and from a to b we are adding some \"x\"  ..so if x+y cant cross b then obviously x alone cant cross b....... in your case we can reach to position 2 but cant cross it"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) reached to position to 2 but we cant reach to next position ..\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "what if ,gas={2,3,1,5} cost={1,2,4,3} i start at station 0 and reach station 2, and get stuck there, but i can start at station 1 and reach station 2, so your hint is proved wrong successfully "
                    },
                    {
                        "username": "khan60939",
                        "content": "[@mimirave](/mimirave) same confusion"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Bye bye TLE \\uD83D\\uDC4B"
                    },
                    {
                        "username": "mimirave",
                        "content": "Am I misunderstanding this hint?: If I start at station 0, successfully get to station 1, successfully get to station 2 but cannot complete the trip to station 3, then I am stuck at station 2 and the hint says that I cannot get to station 2 from station 1.  "
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "thanks! overcame TLE"
                    },
                    {
                        "username": "Jayasurya_K",
                        "content": "Thanks Buddy! TLE cracked..!"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "Thanks! TLE eliminator hint"
                    },
                    {
                        "username": "vanchanr",
                        "content": "good one !"
                    },
                    {
                        "username": "huanpipt",
                        "content": "Overcome TLE with this tip :) "
                    },
                    {
                        "username": "w286432531",
                        "content": "Thanks. I went from TLE to accepted with this hint."
                    },
                    {
                        "username": "CourteousCoder",
                        "content": "In order to prepare for an interview, it is more important that I am able to recognized the pattern in this problem.\\n\\nCan someone please help me identify the pattern of this problem?\\n\\nIs this a variation of a classic problem in Computer Science?\\nIf so, which?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of those problems that don\\'t fall under any category. It simply is just understanding the problem and utilizing problem solving"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "so how was your interview\\n"
                    },
                    {
                        "username": "kardopaska",
                        "content": "This is a classic problem of misdirection.  Description clearly states that valid answers include travel in clockwise direction only!  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "yueyunpeng",
                        "content": "I solved it with a two pass algorithm fairly quickly, the idea is:\\n\\n1. First just assum the gas tank can fall below zero, complete a loop starting at position 0, and record the index with lowest amount of gas (possibly negative) in tank, call it `lowest_idx`.\\n\\n2. Complete a loop starting from `lowest_idx`, break and return `-1` if the tank falls below zero at any point. Return `lowest_idx` if it never fell below zero.\\n\\nSure it\\'s not one pass, but extremely easy to understand, guarantees to be O(N) time and O(1) space, and did pass all tests. Am I missing anything?"
                    },
                    {
                        "username": "ggx94",
                        "content": "[@Kaltu](/Kaltu) I think they have tried to fix it (test case 39/40 for me...) but there is still a bug. The solution is still not unique,"
                    },
                    {
                        "username": "crazytan",
                        "content": "What if there are multiple indices with lowest amount of gas?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "There is a bug in the testcase `gas=[2,1,0,0]`, `cost=[0,1,0,0]`, the problem statement says the solution is unique but start from every index can complete the circuit\\nThe system can detect duplicated solution if we rotate the pairs by 1 to `gas=[0,2,1,0]`, `cost=[0,0,1,0]`, then it says \"Invalid Testcase\" \"The answer should be unique.\"\\n\\nBefore LeetCode remove this bugged testcase, be sure to account this.\\nFor example, when computing lowest_idx, make sure you keep updating it when ever the lowest gas tank are hit, so we can skip the [0, 0] gas/cost pairs"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": " int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "NishantGautam",
                        "content": "[@Yue Yunpeng](/yueyunpeng) how did you arrive at the thinking that I have to start at the station with lowest amount of gas."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Trick to solve circular path problems: Explains in under three minutes:\\nhttps://youtu.be/IEnJSIOOtOg"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "[@er_sushant](/er_sushant)  we can move forward onle if gas>0 so we should always keep this in mind.so,if(gas<=0)break; we can\\'t move further"
                    },
                    {
                        "username": "er_sushant",
                        "content": "[@abhi098](/abhi098) we can guarantee at the last station when `gas >= 0`, this means there is enough gas to make one circular circuit atleast once. if we found `gas < 0`, in any of the station, means we don\\'t have enough gas to move to next station.\\nAlso try various test cases for better understanding."
                    },
                    {
                        "username": "abhi098",
                        "content": "[@jobless_lm10](/jobless_lm10) how can you guarentee that when gas >0 at the last station, you can complete the whole circle from where you start ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "no need to do second pass. If gas remaining at the end of first pass is less than 0 then we can never go round all stations from any station. Otherwise we can go round all from lowest_idx + 1."
                    },
                    {
                        "username": "evidem64",
                        "content": "Problem description states:\\n> If there exists a solution, it is guaranteed to be unique\\n\\nOn submission my solution fails for the following case:\\n> [1,2,3,4,5,6,7,8]\\n> [1,2,3,4,5,6,7,8]\\n\\nClearly, there IS a solution, but it\\'s NOT unique, since\\nyou can start at any of the stations.\\nExpected answer is 0 though, anything else gets rejected.\\n"
                    },
                    {
                        "username": "emil_i_lonneberga",
                        "content": "Another test case that failed to satisfy the uniqueness is gas = [2, 0, 0, 0, ..., 0], cost =[0, 1, 0, 0, ..., 0]. If the test cases cannot be guaranteed to be unique, then additional restrictions like finding the minimum of all viable starting index should be placed. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@nishant7372](/nishant7372) `gas=[2,1,0,0, .... ,0,0]`, `cost=[0,1,0,0, .... ,0,0]` This one is a system testcase, the expected answer is `0` but we can clearly see that every index is actually valid.\nAND, if we rotate it by 1 to `gas=[0,2,1,0,0, .... ,0]`, `cost=[0,0,1,0,0, .... ,0]` as a custom testcase, the system now complains it has non-unique answer.\nThe problem is a circular problem, simply shifting the index in the array representation should not make any difference."
                    },
                    {
                        "username": "labbiahmed",
                        "content": "only one time tank == 0 . in this scenario this test case invalid . every time when you arrived a next station your tank is empty. \\n"
                    },
                    {
                        "username": "mudit_loya",
                        "content": "yes .. the solution is not unique .. even i have testcases where there many solutions"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "Isn\\'t this an invalid test case. It\\'s giving me invalid test case output."
                    },
                    {
                        "username": "jotho_",
                        "content": "There are more than one correct starting stations for that testcase, so it will be rejected."
                    },
                    {
                        "username": "aneesh1029",
                        "content": "You are starting from starting station at 0th index so return the first station possible"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "I think we need to return the smallest possible answer"
                    },
                    {
                        "username": "nishant7372",
                        "content": "I think all the system testcases have a unique answer."
                    },
                    {
                        "username": "banty",
                        "content": "This is not a rant, I genuinly want to know what is it that this problem trying to test so that I can practice it more and be better at it"
                    },
                    {
                        "username": "RB213",
                        "content": "This question is stupid, the language is so convoluted and examples are poor. But this situation does happen in real life when customers/product can\\'t express the problem clearly and engineers build poorly designed system. "
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "It is simply about problem solving skill + greedy technique i think"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "The problem does not state we want the smallest index as a result.\\n\\n[1,6,3,4,5]\\n[3,4,5,1,2]\\n\\nSo, why the answer 3 is not accpeted for the above test case ??\\n"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "The question mentions that the answer is unique. Your test case has two answers. Hence, the wrong one."
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question is very confusing. "
                    },
                    {
                        "username": "pavankumar",
                        "content": "Hi all,\\nI've written the code in suchaway that my solution validates all possible starting positions. I know that this is a very inefficient code to find the solution and finally i got time limit exceeded. can anybody give suggestions on how to solve this in an efficient way. I don't need code  but logic fine.\\n\\nThanks\\npavan kumar"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I know this comment is now almost a decade old at this point but here\\'s what I did. Try keeping track of the difference between the gas and cost as that\\'s what really matters for the problem. You might have to look when to avoid (hint the value will be negative so you can\\'t reach that place anyways). Here\\'s an example:\\n```[1,2,3,4,5] gas\\n[3,4,5,1,2] cost\\n[-2,-2,-2,3,3] -> difference between gas and cost (use variable instead of array for better space)\\n  0  1   2 3 4 -> index\\n```\\nthe net value till index 2 is negative (always -2 so we can ignore till there because it is not possible to move to the next point from these position.\\nfor index 3 this can be a possible answer. But what about having another net negative value in between (say -4)\\n```\\n[-2,-2,-2,3,-4,3]\\n```\\nwe can no longer use the index 3 now. But if you look closely we will find that for the above case it\\'s impossible to have a solution (output is -1). Reason is becase sum(gas)-sum(cost) is negative.\\nBut what for \\n```\\n[-2,-2,-2,3,-4,10]\\n```\\nHere we will keep track of the `minimum valid index`. Since, the answer is unique we can have only 1 valid index. Hence, using a Integer.MAX_VALUE as the initial answer and choosing the min and reassigning it to Integer.MAX_VALUE when the initially possible valid index (the index 3 in this case) is incorrect answer.\\n\\nLink to code: https://leetcode.com/problems/gas-station/solutions/3012347/easy-python-solution/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`The most unbelievable thing about this question isn\\'t that the car has unlimited gas tank, but the fact that I have got money to pay for it`"
                    },
                    {
                        "username": "pushpit_singh",
                        "content": "Us bhai Us"
                    },
                    {
                        "username": "dileep9259",
                        "content": "wah !!! :P\\n"
                    }
                ]
            },
            {
                "id": 1572282,
                "content": [
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan anyone please explain with giving some examples also to make it clear what is asked? thanks"
                    },
                    {
                        "username": "LOVEGURU",
                        "content": "Gas is gas station, Cost is amount of gas required to travel from i to i+1 station. we need to find index .From that we can complete the journey if we do not find index return -1.\\nour main agenda is find index we can travel from i to n-1 in the circular way"
                    },
                    {
                        "username": "Joseph86",
                        "content": "[@calm27](/calm27) I was in 5th grade in 2015 :0"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "whoa..  ancient comments were full of respect and gratitude!"
                    },
                    {
                        "username": "calm27",
                        "content": "[@heisenberg280](/heisenberg280) no way 2015 was 8 years ago, mate. no way "
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "[@heisenberg280](/heisenberg280)  \\uD83D\\uDE02\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Msey",
                        "content": "[@heisenberg280](/heisenberg280) or not and gave up :)"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@studcoder569](/studcoder569) Jul 29, 2015"
                    },
                    {
                        "username": "studcoder569",
                        "content": "[@heisenberg280](/heisenberg280) Good point lol"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "[@heisenberg280](/heisenberg280) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@studcoder569](/studcoder569) love your dedication but after 8 long years she might have understood the question by now :)"
                    },
                    {
                        "username": "studcoder569",
                        "content": "The question is asking you to find a starting gas station on the circuit that will allow you to complete one round trip without running out of gas. It is possible for there to be no solution. If there is a solution, the test cases are written such that it is unique. The examples shown in the description illustrate how the road trip would work. "
                    },
                    {
                        "username": "dadick",
                        "content": "Hint: if you start from station `a` and stuck at `b`, then you can't get to `b` from any station between `a` and `b`."
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) at position a we are getting some positive value \"y\" and from a to b we are adding some \"x\"  ..so if x+y cant cross b then obviously x alone cant cross b....... in your case we can reach to position 2 but cant cross it"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) reached to position to 2 but we cant reach to next position ..\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "what if ,gas={2,3,1,5} cost={1,2,4,3} i start at station 0 and reach station 2, and get stuck there, but i can start at station 1 and reach station 2, so your hint is proved wrong successfully "
                    },
                    {
                        "username": "khan60939",
                        "content": "[@mimirave](/mimirave) same confusion"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Bye bye TLE \\uD83D\\uDC4B"
                    },
                    {
                        "username": "mimirave",
                        "content": "Am I misunderstanding this hint?: If I start at station 0, successfully get to station 1, successfully get to station 2 but cannot complete the trip to station 3, then I am stuck at station 2 and the hint says that I cannot get to station 2 from station 1.  "
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "thanks! overcame TLE"
                    },
                    {
                        "username": "Jayasurya_K",
                        "content": "Thanks Buddy! TLE cracked..!"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "Thanks! TLE eliminator hint"
                    },
                    {
                        "username": "vanchanr",
                        "content": "good one !"
                    },
                    {
                        "username": "huanpipt",
                        "content": "Overcome TLE with this tip :) "
                    },
                    {
                        "username": "w286432531",
                        "content": "Thanks. I went from TLE to accepted with this hint."
                    },
                    {
                        "username": "CourteousCoder",
                        "content": "In order to prepare for an interview, it is more important that I am able to recognized the pattern in this problem.\\n\\nCan someone please help me identify the pattern of this problem?\\n\\nIs this a variation of a classic problem in Computer Science?\\nIf so, which?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of those problems that don\\'t fall under any category. It simply is just understanding the problem and utilizing problem solving"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "so how was your interview\\n"
                    },
                    {
                        "username": "kardopaska",
                        "content": "This is a classic problem of misdirection.  Description clearly states that valid answers include travel in clockwise direction only!  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "yueyunpeng",
                        "content": "I solved it with a two pass algorithm fairly quickly, the idea is:\\n\\n1. First just assum the gas tank can fall below zero, complete a loop starting at position 0, and record the index with lowest amount of gas (possibly negative) in tank, call it `lowest_idx`.\\n\\n2. Complete a loop starting from `lowest_idx`, break and return `-1` if the tank falls below zero at any point. Return `lowest_idx` if it never fell below zero.\\n\\nSure it\\'s not one pass, but extremely easy to understand, guarantees to be O(N) time and O(1) space, and did pass all tests. Am I missing anything?"
                    },
                    {
                        "username": "ggx94",
                        "content": "[@Kaltu](/Kaltu) I think they have tried to fix it (test case 39/40 for me...) but there is still a bug. The solution is still not unique,"
                    },
                    {
                        "username": "crazytan",
                        "content": "What if there are multiple indices with lowest amount of gas?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "There is a bug in the testcase `gas=[2,1,0,0]`, `cost=[0,1,0,0]`, the problem statement says the solution is unique but start from every index can complete the circuit\\nThe system can detect duplicated solution if we rotate the pairs by 1 to `gas=[0,2,1,0]`, `cost=[0,0,1,0]`, then it says \"Invalid Testcase\" \"The answer should be unique.\"\\n\\nBefore LeetCode remove this bugged testcase, be sure to account this.\\nFor example, when computing lowest_idx, make sure you keep updating it when ever the lowest gas tank are hit, so we can skip the [0, 0] gas/cost pairs"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": " int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "NishantGautam",
                        "content": "[@Yue Yunpeng](/yueyunpeng) how did you arrive at the thinking that I have to start at the station with lowest amount of gas."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Trick to solve circular path problems: Explains in under three minutes:\\nhttps://youtu.be/IEnJSIOOtOg"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "[@er_sushant](/er_sushant)  we can move forward onle if gas>0 so we should always keep this in mind.so,if(gas<=0)break; we can\\'t move further"
                    },
                    {
                        "username": "er_sushant",
                        "content": "[@abhi098](/abhi098) we can guarantee at the last station when `gas >= 0`, this means there is enough gas to make one circular circuit atleast once. if we found `gas < 0`, in any of the station, means we don\\'t have enough gas to move to next station.\\nAlso try various test cases for better understanding."
                    },
                    {
                        "username": "abhi098",
                        "content": "[@jobless_lm10](/jobless_lm10) how can you guarentee that when gas >0 at the last station, you can complete the whole circle from where you start ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "no need to do second pass. If gas remaining at the end of first pass is less than 0 then we can never go round all stations from any station. Otherwise we can go round all from lowest_idx + 1."
                    },
                    {
                        "username": "evidem64",
                        "content": "Problem description states:\\n> If there exists a solution, it is guaranteed to be unique\\n\\nOn submission my solution fails for the following case:\\n> [1,2,3,4,5,6,7,8]\\n> [1,2,3,4,5,6,7,8]\\n\\nClearly, there IS a solution, but it\\'s NOT unique, since\\nyou can start at any of the stations.\\nExpected answer is 0 though, anything else gets rejected.\\n"
                    },
                    {
                        "username": "emil_i_lonneberga",
                        "content": "Another test case that failed to satisfy the uniqueness is gas = [2, 0, 0, 0, ..., 0], cost =[0, 1, 0, 0, ..., 0]. If the test cases cannot be guaranteed to be unique, then additional restrictions like finding the minimum of all viable starting index should be placed. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@nishant7372](/nishant7372) `gas=[2,1,0,0, .... ,0,0]`, `cost=[0,1,0,0, .... ,0,0]` This one is a system testcase, the expected answer is `0` but we can clearly see that every index is actually valid.\nAND, if we rotate it by 1 to `gas=[0,2,1,0,0, .... ,0]`, `cost=[0,0,1,0,0, .... ,0]` as a custom testcase, the system now complains it has non-unique answer.\nThe problem is a circular problem, simply shifting the index in the array representation should not make any difference."
                    },
                    {
                        "username": "labbiahmed",
                        "content": "only one time tank == 0 . in this scenario this test case invalid . every time when you arrived a next station your tank is empty. \\n"
                    },
                    {
                        "username": "mudit_loya",
                        "content": "yes .. the solution is not unique .. even i have testcases where there many solutions"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "Isn\\'t this an invalid test case. It\\'s giving me invalid test case output."
                    },
                    {
                        "username": "jotho_",
                        "content": "There are more than one correct starting stations for that testcase, so it will be rejected."
                    },
                    {
                        "username": "aneesh1029",
                        "content": "You are starting from starting station at 0th index so return the first station possible"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "I think we need to return the smallest possible answer"
                    },
                    {
                        "username": "nishant7372",
                        "content": "I think all the system testcases have a unique answer."
                    },
                    {
                        "username": "banty",
                        "content": "This is not a rant, I genuinly want to know what is it that this problem trying to test so that I can practice it more and be better at it"
                    },
                    {
                        "username": "RB213",
                        "content": "This question is stupid, the language is so convoluted and examples are poor. But this situation does happen in real life when customers/product can\\'t express the problem clearly and engineers build poorly designed system. "
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "It is simply about problem solving skill + greedy technique i think"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "The problem does not state we want the smallest index as a result.\\n\\n[1,6,3,4,5]\\n[3,4,5,1,2]\\n\\nSo, why the answer 3 is not accpeted for the above test case ??\\n"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "The question mentions that the answer is unique. Your test case has two answers. Hence, the wrong one."
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question is very confusing. "
                    },
                    {
                        "username": "pavankumar",
                        "content": "Hi all,\\nI've written the code in suchaway that my solution validates all possible starting positions. I know that this is a very inefficient code to find the solution and finally i got time limit exceeded. can anybody give suggestions on how to solve this in an efficient way. I don't need code  but logic fine.\\n\\nThanks\\npavan kumar"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I know this comment is now almost a decade old at this point but here\\'s what I did. Try keeping track of the difference between the gas and cost as that\\'s what really matters for the problem. You might have to look when to avoid (hint the value will be negative so you can\\'t reach that place anyways). Here\\'s an example:\\n```[1,2,3,4,5] gas\\n[3,4,5,1,2] cost\\n[-2,-2,-2,3,3] -> difference between gas and cost (use variable instead of array for better space)\\n  0  1   2 3 4 -> index\\n```\\nthe net value till index 2 is negative (always -2 so we can ignore till there because it is not possible to move to the next point from these position.\\nfor index 3 this can be a possible answer. But what about having another net negative value in between (say -4)\\n```\\n[-2,-2,-2,3,-4,3]\\n```\\nwe can no longer use the index 3 now. But if you look closely we will find that for the above case it\\'s impossible to have a solution (output is -1). Reason is becase sum(gas)-sum(cost) is negative.\\nBut what for \\n```\\n[-2,-2,-2,3,-4,10]\\n```\\nHere we will keep track of the `minimum valid index`. Since, the answer is unique we can have only 1 valid index. Hence, using a Integer.MAX_VALUE as the initial answer and choosing the min and reassigning it to Integer.MAX_VALUE when the initially possible valid index (the index 3 in this case) is incorrect answer.\\n\\nLink to code: https://leetcode.com/problems/gas-station/solutions/3012347/easy-python-solution/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`The most unbelievable thing about this question isn\\'t that the car has unlimited gas tank, but the fact that I have got money to pay for it`"
                    },
                    {
                        "username": "pushpit_singh",
                        "content": "Us bhai Us"
                    },
                    {
                        "username": "dileep9259",
                        "content": "wah !!! :P\\n"
                    }
                ]
            },
            {
                "id": 1574644,
                "content": [
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan anyone please explain with giving some examples also to make it clear what is asked? thanks"
                    },
                    {
                        "username": "LOVEGURU",
                        "content": "Gas is gas station, Cost is amount of gas required to travel from i to i+1 station. we need to find index .From that we can complete the journey if we do not find index return -1.\\nour main agenda is find index we can travel from i to n-1 in the circular way"
                    },
                    {
                        "username": "Joseph86",
                        "content": "[@calm27](/calm27) I was in 5th grade in 2015 :0"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "whoa..  ancient comments were full of respect and gratitude!"
                    },
                    {
                        "username": "calm27",
                        "content": "[@heisenberg280](/heisenberg280) no way 2015 was 8 years ago, mate. no way "
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "[@heisenberg280](/heisenberg280)  \\uD83D\\uDE02\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Msey",
                        "content": "[@heisenberg280](/heisenberg280) or not and gave up :)"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@studcoder569](/studcoder569) Jul 29, 2015"
                    },
                    {
                        "username": "studcoder569",
                        "content": "[@heisenberg280](/heisenberg280) Good point lol"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "[@heisenberg280](/heisenberg280) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@studcoder569](/studcoder569) love your dedication but after 8 long years she might have understood the question by now :)"
                    },
                    {
                        "username": "studcoder569",
                        "content": "The question is asking you to find a starting gas station on the circuit that will allow you to complete one round trip without running out of gas. It is possible for there to be no solution. If there is a solution, the test cases are written such that it is unique. The examples shown in the description illustrate how the road trip would work. "
                    },
                    {
                        "username": "dadick",
                        "content": "Hint: if you start from station `a` and stuck at `b`, then you can't get to `b` from any station between `a` and `b`."
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) at position a we are getting some positive value \"y\" and from a to b we are adding some \"x\"  ..so if x+y cant cross b then obviously x alone cant cross b....... in your case we can reach to position 2 but cant cross it"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) reached to position to 2 but we cant reach to next position ..\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "what if ,gas={2,3,1,5} cost={1,2,4,3} i start at station 0 and reach station 2, and get stuck there, but i can start at station 1 and reach station 2, so your hint is proved wrong successfully "
                    },
                    {
                        "username": "khan60939",
                        "content": "[@mimirave](/mimirave) same confusion"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Bye bye TLE \\uD83D\\uDC4B"
                    },
                    {
                        "username": "mimirave",
                        "content": "Am I misunderstanding this hint?: If I start at station 0, successfully get to station 1, successfully get to station 2 but cannot complete the trip to station 3, then I am stuck at station 2 and the hint says that I cannot get to station 2 from station 1.  "
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "thanks! overcame TLE"
                    },
                    {
                        "username": "Jayasurya_K",
                        "content": "Thanks Buddy! TLE cracked..!"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "Thanks! TLE eliminator hint"
                    },
                    {
                        "username": "vanchanr",
                        "content": "good one !"
                    },
                    {
                        "username": "huanpipt",
                        "content": "Overcome TLE with this tip :) "
                    },
                    {
                        "username": "w286432531",
                        "content": "Thanks. I went from TLE to accepted with this hint."
                    },
                    {
                        "username": "CourteousCoder",
                        "content": "In order to prepare for an interview, it is more important that I am able to recognized the pattern in this problem.\\n\\nCan someone please help me identify the pattern of this problem?\\n\\nIs this a variation of a classic problem in Computer Science?\\nIf so, which?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of those problems that don\\'t fall under any category. It simply is just understanding the problem and utilizing problem solving"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "so how was your interview\\n"
                    },
                    {
                        "username": "kardopaska",
                        "content": "This is a classic problem of misdirection.  Description clearly states that valid answers include travel in clockwise direction only!  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "yueyunpeng",
                        "content": "I solved it with a two pass algorithm fairly quickly, the idea is:\\n\\n1. First just assum the gas tank can fall below zero, complete a loop starting at position 0, and record the index with lowest amount of gas (possibly negative) in tank, call it `lowest_idx`.\\n\\n2. Complete a loop starting from `lowest_idx`, break and return `-1` if the tank falls below zero at any point. Return `lowest_idx` if it never fell below zero.\\n\\nSure it\\'s not one pass, but extremely easy to understand, guarantees to be O(N) time and O(1) space, and did pass all tests. Am I missing anything?"
                    },
                    {
                        "username": "ggx94",
                        "content": "[@Kaltu](/Kaltu) I think they have tried to fix it (test case 39/40 for me...) but there is still a bug. The solution is still not unique,"
                    },
                    {
                        "username": "crazytan",
                        "content": "What if there are multiple indices with lowest amount of gas?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "There is a bug in the testcase `gas=[2,1,0,0]`, `cost=[0,1,0,0]`, the problem statement says the solution is unique but start from every index can complete the circuit\\nThe system can detect duplicated solution if we rotate the pairs by 1 to `gas=[0,2,1,0]`, `cost=[0,0,1,0]`, then it says \"Invalid Testcase\" \"The answer should be unique.\"\\n\\nBefore LeetCode remove this bugged testcase, be sure to account this.\\nFor example, when computing lowest_idx, make sure you keep updating it when ever the lowest gas tank are hit, so we can skip the [0, 0] gas/cost pairs"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": " int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "NishantGautam",
                        "content": "[@Yue Yunpeng](/yueyunpeng) how did you arrive at the thinking that I have to start at the station with lowest amount of gas."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Trick to solve circular path problems: Explains in under three minutes:\\nhttps://youtu.be/IEnJSIOOtOg"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "[@er_sushant](/er_sushant)  we can move forward onle if gas>0 so we should always keep this in mind.so,if(gas<=0)break; we can\\'t move further"
                    },
                    {
                        "username": "er_sushant",
                        "content": "[@abhi098](/abhi098) we can guarantee at the last station when `gas >= 0`, this means there is enough gas to make one circular circuit atleast once. if we found `gas < 0`, in any of the station, means we don\\'t have enough gas to move to next station.\\nAlso try various test cases for better understanding."
                    },
                    {
                        "username": "abhi098",
                        "content": "[@jobless_lm10](/jobless_lm10) how can you guarentee that when gas >0 at the last station, you can complete the whole circle from where you start ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "no need to do second pass. If gas remaining at the end of first pass is less than 0 then we can never go round all stations from any station. Otherwise we can go round all from lowest_idx + 1."
                    },
                    {
                        "username": "evidem64",
                        "content": "Problem description states:\\n> If there exists a solution, it is guaranteed to be unique\\n\\nOn submission my solution fails for the following case:\\n> [1,2,3,4,5,6,7,8]\\n> [1,2,3,4,5,6,7,8]\\n\\nClearly, there IS a solution, but it\\'s NOT unique, since\\nyou can start at any of the stations.\\nExpected answer is 0 though, anything else gets rejected.\\n"
                    },
                    {
                        "username": "emil_i_lonneberga",
                        "content": "Another test case that failed to satisfy the uniqueness is gas = [2, 0, 0, 0, ..., 0], cost =[0, 1, 0, 0, ..., 0]. If the test cases cannot be guaranteed to be unique, then additional restrictions like finding the minimum of all viable starting index should be placed. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@nishant7372](/nishant7372) `gas=[2,1,0,0, .... ,0,0]`, `cost=[0,1,0,0, .... ,0,0]` This one is a system testcase, the expected answer is `0` but we can clearly see that every index is actually valid.\nAND, if we rotate it by 1 to `gas=[0,2,1,0,0, .... ,0]`, `cost=[0,0,1,0,0, .... ,0]` as a custom testcase, the system now complains it has non-unique answer.\nThe problem is a circular problem, simply shifting the index in the array representation should not make any difference."
                    },
                    {
                        "username": "labbiahmed",
                        "content": "only one time tank == 0 . in this scenario this test case invalid . every time when you arrived a next station your tank is empty. \\n"
                    },
                    {
                        "username": "mudit_loya",
                        "content": "yes .. the solution is not unique .. even i have testcases where there many solutions"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "Isn\\'t this an invalid test case. It\\'s giving me invalid test case output."
                    },
                    {
                        "username": "jotho_",
                        "content": "There are more than one correct starting stations for that testcase, so it will be rejected."
                    },
                    {
                        "username": "aneesh1029",
                        "content": "You are starting from starting station at 0th index so return the first station possible"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "I think we need to return the smallest possible answer"
                    },
                    {
                        "username": "nishant7372",
                        "content": "I think all the system testcases have a unique answer."
                    },
                    {
                        "username": "banty",
                        "content": "This is not a rant, I genuinly want to know what is it that this problem trying to test so that I can practice it more and be better at it"
                    },
                    {
                        "username": "RB213",
                        "content": "This question is stupid, the language is so convoluted and examples are poor. But this situation does happen in real life when customers/product can\\'t express the problem clearly and engineers build poorly designed system. "
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "It is simply about problem solving skill + greedy technique i think"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "The problem does not state we want the smallest index as a result.\\n\\n[1,6,3,4,5]\\n[3,4,5,1,2]\\n\\nSo, why the answer 3 is not accpeted for the above test case ??\\n"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "The question mentions that the answer is unique. Your test case has two answers. Hence, the wrong one."
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question is very confusing. "
                    },
                    {
                        "username": "pavankumar",
                        "content": "Hi all,\\nI've written the code in suchaway that my solution validates all possible starting positions. I know that this is a very inefficient code to find the solution and finally i got time limit exceeded. can anybody give suggestions on how to solve this in an efficient way. I don't need code  but logic fine.\\n\\nThanks\\npavan kumar"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I know this comment is now almost a decade old at this point but here\\'s what I did. Try keeping track of the difference between the gas and cost as that\\'s what really matters for the problem. You might have to look when to avoid (hint the value will be negative so you can\\'t reach that place anyways). Here\\'s an example:\\n```[1,2,3,4,5] gas\\n[3,4,5,1,2] cost\\n[-2,-2,-2,3,3] -> difference between gas and cost (use variable instead of array for better space)\\n  0  1   2 3 4 -> index\\n```\\nthe net value till index 2 is negative (always -2 so we can ignore till there because it is not possible to move to the next point from these position.\\nfor index 3 this can be a possible answer. But what about having another net negative value in between (say -4)\\n```\\n[-2,-2,-2,3,-4,3]\\n```\\nwe can no longer use the index 3 now. But if you look closely we will find that for the above case it\\'s impossible to have a solution (output is -1). Reason is becase sum(gas)-sum(cost) is negative.\\nBut what for \\n```\\n[-2,-2,-2,3,-4,10]\\n```\\nHere we will keep track of the `minimum valid index`. Since, the answer is unique we can have only 1 valid index. Hence, using a Integer.MAX_VALUE as the initial answer and choosing the min and reassigning it to Integer.MAX_VALUE when the initially possible valid index (the index 3 in this case) is incorrect answer.\\n\\nLink to code: https://leetcode.com/problems/gas-station/solutions/3012347/easy-python-solution/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`The most unbelievable thing about this question isn\\'t that the car has unlimited gas tank, but the fact that I have got money to pay for it`"
                    },
                    {
                        "username": "pushpit_singh",
                        "content": "Us bhai Us"
                    },
                    {
                        "username": "dileep9259",
                        "content": "wah !!! :P\\n"
                    }
                ]
            },
            {
                "id": 1570784,
                "content": [
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan anyone please explain with giving some examples also to make it clear what is asked? thanks"
                    },
                    {
                        "username": "LOVEGURU",
                        "content": "Gas is gas station, Cost is amount of gas required to travel from i to i+1 station. we need to find index .From that we can complete the journey if we do not find index return -1.\\nour main agenda is find index we can travel from i to n-1 in the circular way"
                    },
                    {
                        "username": "Joseph86",
                        "content": "[@calm27](/calm27) I was in 5th grade in 2015 :0"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "whoa..  ancient comments were full of respect and gratitude!"
                    },
                    {
                        "username": "calm27",
                        "content": "[@heisenberg280](/heisenberg280) no way 2015 was 8 years ago, mate. no way "
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "[@heisenberg280](/heisenberg280)  \\uD83D\\uDE02\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Msey",
                        "content": "[@heisenberg280](/heisenberg280) or not and gave up :)"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@studcoder569](/studcoder569) Jul 29, 2015"
                    },
                    {
                        "username": "studcoder569",
                        "content": "[@heisenberg280](/heisenberg280) Good point lol"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "[@heisenberg280](/heisenberg280) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@studcoder569](/studcoder569) love your dedication but after 8 long years she might have understood the question by now :)"
                    },
                    {
                        "username": "studcoder569",
                        "content": "The question is asking you to find a starting gas station on the circuit that will allow you to complete one round trip without running out of gas. It is possible for there to be no solution. If there is a solution, the test cases are written such that it is unique. The examples shown in the description illustrate how the road trip would work. "
                    },
                    {
                        "username": "dadick",
                        "content": "Hint: if you start from station `a` and stuck at `b`, then you can't get to `b` from any station between `a` and `b`."
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) at position a we are getting some positive value \"y\" and from a to b we are adding some \"x\"  ..so if x+y cant cross b then obviously x alone cant cross b....... in your case we can reach to position 2 but cant cross it"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) reached to position to 2 but we cant reach to next position ..\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "what if ,gas={2,3,1,5} cost={1,2,4,3} i start at station 0 and reach station 2, and get stuck there, but i can start at station 1 and reach station 2, so your hint is proved wrong successfully "
                    },
                    {
                        "username": "khan60939",
                        "content": "[@mimirave](/mimirave) same confusion"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Bye bye TLE \\uD83D\\uDC4B"
                    },
                    {
                        "username": "mimirave",
                        "content": "Am I misunderstanding this hint?: If I start at station 0, successfully get to station 1, successfully get to station 2 but cannot complete the trip to station 3, then I am stuck at station 2 and the hint says that I cannot get to station 2 from station 1.  "
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "thanks! overcame TLE"
                    },
                    {
                        "username": "Jayasurya_K",
                        "content": "Thanks Buddy! TLE cracked..!"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "Thanks! TLE eliminator hint"
                    },
                    {
                        "username": "vanchanr",
                        "content": "good one !"
                    },
                    {
                        "username": "huanpipt",
                        "content": "Overcome TLE with this tip :) "
                    },
                    {
                        "username": "w286432531",
                        "content": "Thanks. I went from TLE to accepted with this hint."
                    },
                    {
                        "username": "CourteousCoder",
                        "content": "In order to prepare for an interview, it is more important that I am able to recognized the pattern in this problem.\\n\\nCan someone please help me identify the pattern of this problem?\\n\\nIs this a variation of a classic problem in Computer Science?\\nIf so, which?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of those problems that don\\'t fall under any category. It simply is just understanding the problem and utilizing problem solving"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "so how was your interview\\n"
                    },
                    {
                        "username": "kardopaska",
                        "content": "This is a classic problem of misdirection.  Description clearly states that valid answers include travel in clockwise direction only!  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "yueyunpeng",
                        "content": "I solved it with a two pass algorithm fairly quickly, the idea is:\\n\\n1. First just assum the gas tank can fall below zero, complete a loop starting at position 0, and record the index with lowest amount of gas (possibly negative) in tank, call it `lowest_idx`.\\n\\n2. Complete a loop starting from `lowest_idx`, break and return `-1` if the tank falls below zero at any point. Return `lowest_idx` if it never fell below zero.\\n\\nSure it\\'s not one pass, but extremely easy to understand, guarantees to be O(N) time and O(1) space, and did pass all tests. Am I missing anything?"
                    },
                    {
                        "username": "ggx94",
                        "content": "[@Kaltu](/Kaltu) I think they have tried to fix it (test case 39/40 for me...) but there is still a bug. The solution is still not unique,"
                    },
                    {
                        "username": "crazytan",
                        "content": "What if there are multiple indices with lowest amount of gas?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "There is a bug in the testcase `gas=[2,1,0,0]`, `cost=[0,1,0,0]`, the problem statement says the solution is unique but start from every index can complete the circuit\\nThe system can detect duplicated solution if we rotate the pairs by 1 to `gas=[0,2,1,0]`, `cost=[0,0,1,0]`, then it says \"Invalid Testcase\" \"The answer should be unique.\"\\n\\nBefore LeetCode remove this bugged testcase, be sure to account this.\\nFor example, when computing lowest_idx, make sure you keep updating it when ever the lowest gas tank are hit, so we can skip the [0, 0] gas/cost pairs"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": " int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "NishantGautam",
                        "content": "[@Yue Yunpeng](/yueyunpeng) how did you arrive at the thinking that I have to start at the station with lowest amount of gas."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Trick to solve circular path problems: Explains in under three minutes:\\nhttps://youtu.be/IEnJSIOOtOg"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "[@er_sushant](/er_sushant)  we can move forward onle if gas>0 so we should always keep this in mind.so,if(gas<=0)break; we can\\'t move further"
                    },
                    {
                        "username": "er_sushant",
                        "content": "[@abhi098](/abhi098) we can guarantee at the last station when `gas >= 0`, this means there is enough gas to make one circular circuit atleast once. if we found `gas < 0`, in any of the station, means we don\\'t have enough gas to move to next station.\\nAlso try various test cases for better understanding."
                    },
                    {
                        "username": "abhi098",
                        "content": "[@jobless_lm10](/jobless_lm10) how can you guarentee that when gas >0 at the last station, you can complete the whole circle from where you start ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "no need to do second pass. If gas remaining at the end of first pass is less than 0 then we can never go round all stations from any station. Otherwise we can go round all from lowest_idx + 1."
                    },
                    {
                        "username": "evidem64",
                        "content": "Problem description states:\\n> If there exists a solution, it is guaranteed to be unique\\n\\nOn submission my solution fails for the following case:\\n> [1,2,3,4,5,6,7,8]\\n> [1,2,3,4,5,6,7,8]\\n\\nClearly, there IS a solution, but it\\'s NOT unique, since\\nyou can start at any of the stations.\\nExpected answer is 0 though, anything else gets rejected.\\n"
                    },
                    {
                        "username": "emil_i_lonneberga",
                        "content": "Another test case that failed to satisfy the uniqueness is gas = [2, 0, 0, 0, ..., 0], cost =[0, 1, 0, 0, ..., 0]. If the test cases cannot be guaranteed to be unique, then additional restrictions like finding the minimum of all viable starting index should be placed. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@nishant7372](/nishant7372) `gas=[2,1,0,0, .... ,0,0]`, `cost=[0,1,0,0, .... ,0,0]` This one is a system testcase, the expected answer is `0` but we can clearly see that every index is actually valid.\nAND, if we rotate it by 1 to `gas=[0,2,1,0,0, .... ,0]`, `cost=[0,0,1,0,0, .... ,0]` as a custom testcase, the system now complains it has non-unique answer.\nThe problem is a circular problem, simply shifting the index in the array representation should not make any difference."
                    },
                    {
                        "username": "labbiahmed",
                        "content": "only one time tank == 0 . in this scenario this test case invalid . every time when you arrived a next station your tank is empty. \\n"
                    },
                    {
                        "username": "mudit_loya",
                        "content": "yes .. the solution is not unique .. even i have testcases where there many solutions"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "Isn\\'t this an invalid test case. It\\'s giving me invalid test case output."
                    },
                    {
                        "username": "jotho_",
                        "content": "There are more than one correct starting stations for that testcase, so it will be rejected."
                    },
                    {
                        "username": "aneesh1029",
                        "content": "You are starting from starting station at 0th index so return the first station possible"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "I think we need to return the smallest possible answer"
                    },
                    {
                        "username": "nishant7372",
                        "content": "I think all the system testcases have a unique answer."
                    },
                    {
                        "username": "banty",
                        "content": "This is not a rant, I genuinly want to know what is it that this problem trying to test so that I can practice it more and be better at it"
                    },
                    {
                        "username": "RB213",
                        "content": "This question is stupid, the language is so convoluted and examples are poor. But this situation does happen in real life when customers/product can\\'t express the problem clearly and engineers build poorly designed system. "
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "It is simply about problem solving skill + greedy technique i think"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "The problem does not state we want the smallest index as a result.\\n\\n[1,6,3,4,5]\\n[3,4,5,1,2]\\n\\nSo, why the answer 3 is not accpeted for the above test case ??\\n"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "The question mentions that the answer is unique. Your test case has two answers. Hence, the wrong one."
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question is very confusing. "
                    },
                    {
                        "username": "pavankumar",
                        "content": "Hi all,\\nI've written the code in suchaway that my solution validates all possible starting positions. I know that this is a very inefficient code to find the solution and finally i got time limit exceeded. can anybody give suggestions on how to solve this in an efficient way. I don't need code  but logic fine.\\n\\nThanks\\npavan kumar"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I know this comment is now almost a decade old at this point but here\\'s what I did. Try keeping track of the difference between the gas and cost as that\\'s what really matters for the problem. You might have to look when to avoid (hint the value will be negative so you can\\'t reach that place anyways). Here\\'s an example:\\n```[1,2,3,4,5] gas\\n[3,4,5,1,2] cost\\n[-2,-2,-2,3,3] -> difference between gas and cost (use variable instead of array for better space)\\n  0  1   2 3 4 -> index\\n```\\nthe net value till index 2 is negative (always -2 so we can ignore till there because it is not possible to move to the next point from these position.\\nfor index 3 this can be a possible answer. But what about having another net negative value in between (say -4)\\n```\\n[-2,-2,-2,3,-4,3]\\n```\\nwe can no longer use the index 3 now. But if you look closely we will find that for the above case it\\'s impossible to have a solution (output is -1). Reason is becase sum(gas)-sum(cost) is negative.\\nBut what for \\n```\\n[-2,-2,-2,3,-4,10]\\n```\\nHere we will keep track of the `minimum valid index`. Since, the answer is unique we can have only 1 valid index. Hence, using a Integer.MAX_VALUE as the initial answer and choosing the min and reassigning it to Integer.MAX_VALUE when the initially possible valid index (the index 3 in this case) is incorrect answer.\\n\\nLink to code: https://leetcode.com/problems/gas-station/solutions/3012347/easy-python-solution/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`The most unbelievable thing about this question isn\\'t that the car has unlimited gas tank, but the fact that I have got money to pay for it`"
                    },
                    {
                        "username": "pushpit_singh",
                        "content": "Us bhai Us"
                    },
                    {
                        "username": "dileep9259",
                        "content": "wah !!! :P\\n"
                    }
                ]
            },
            {
                "id": 1576270,
                "content": [
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan anyone please explain with giving some examples also to make it clear what is asked? thanks"
                    },
                    {
                        "username": "LOVEGURU",
                        "content": "Gas is gas station, Cost is amount of gas required to travel from i to i+1 station. we need to find index .From that we can complete the journey if we do not find index return -1.\\nour main agenda is find index we can travel from i to n-1 in the circular way"
                    },
                    {
                        "username": "Joseph86",
                        "content": "[@calm27](/calm27) I was in 5th grade in 2015 :0"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "whoa..  ancient comments were full of respect and gratitude!"
                    },
                    {
                        "username": "calm27",
                        "content": "[@heisenberg280](/heisenberg280) no way 2015 was 8 years ago, mate. no way "
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "[@heisenberg280](/heisenberg280)  \\uD83D\\uDE02\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Msey",
                        "content": "[@heisenberg280](/heisenberg280) or not and gave up :)"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@studcoder569](/studcoder569) Jul 29, 2015"
                    },
                    {
                        "username": "studcoder569",
                        "content": "[@heisenberg280](/heisenberg280) Good point lol"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "[@heisenberg280](/heisenberg280) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@studcoder569](/studcoder569) love your dedication but after 8 long years she might have understood the question by now :)"
                    },
                    {
                        "username": "studcoder569",
                        "content": "The question is asking you to find a starting gas station on the circuit that will allow you to complete one round trip without running out of gas. It is possible for there to be no solution. If there is a solution, the test cases are written such that it is unique. The examples shown in the description illustrate how the road trip would work. "
                    },
                    {
                        "username": "dadick",
                        "content": "Hint: if you start from station `a` and stuck at `b`, then you can't get to `b` from any station between `a` and `b`."
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) at position a we are getting some positive value \"y\" and from a to b we are adding some \"x\"  ..so if x+y cant cross b then obviously x alone cant cross b....... in your case we can reach to position 2 but cant cross it"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) reached to position to 2 but we cant reach to next position ..\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "what if ,gas={2,3,1,5} cost={1,2,4,3} i start at station 0 and reach station 2, and get stuck there, but i can start at station 1 and reach station 2, so your hint is proved wrong successfully "
                    },
                    {
                        "username": "khan60939",
                        "content": "[@mimirave](/mimirave) same confusion"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Bye bye TLE \\uD83D\\uDC4B"
                    },
                    {
                        "username": "mimirave",
                        "content": "Am I misunderstanding this hint?: If I start at station 0, successfully get to station 1, successfully get to station 2 but cannot complete the trip to station 3, then I am stuck at station 2 and the hint says that I cannot get to station 2 from station 1.  "
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "thanks! overcame TLE"
                    },
                    {
                        "username": "Jayasurya_K",
                        "content": "Thanks Buddy! TLE cracked..!"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "Thanks! TLE eliminator hint"
                    },
                    {
                        "username": "vanchanr",
                        "content": "good one !"
                    },
                    {
                        "username": "huanpipt",
                        "content": "Overcome TLE with this tip :) "
                    },
                    {
                        "username": "w286432531",
                        "content": "Thanks. I went from TLE to accepted with this hint."
                    },
                    {
                        "username": "CourteousCoder",
                        "content": "In order to prepare for an interview, it is more important that I am able to recognized the pattern in this problem.\\n\\nCan someone please help me identify the pattern of this problem?\\n\\nIs this a variation of a classic problem in Computer Science?\\nIf so, which?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of those problems that don\\'t fall under any category. It simply is just understanding the problem and utilizing problem solving"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "so how was your interview\\n"
                    },
                    {
                        "username": "kardopaska",
                        "content": "This is a classic problem of misdirection.  Description clearly states that valid answers include travel in clockwise direction only!  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "yueyunpeng",
                        "content": "I solved it with a two pass algorithm fairly quickly, the idea is:\\n\\n1. First just assum the gas tank can fall below zero, complete a loop starting at position 0, and record the index with lowest amount of gas (possibly negative) in tank, call it `lowest_idx`.\\n\\n2. Complete a loop starting from `lowest_idx`, break and return `-1` if the tank falls below zero at any point. Return `lowest_idx` if it never fell below zero.\\n\\nSure it\\'s not one pass, but extremely easy to understand, guarantees to be O(N) time and O(1) space, and did pass all tests. Am I missing anything?"
                    },
                    {
                        "username": "ggx94",
                        "content": "[@Kaltu](/Kaltu) I think they have tried to fix it (test case 39/40 for me...) but there is still a bug. The solution is still not unique,"
                    },
                    {
                        "username": "crazytan",
                        "content": "What if there are multiple indices with lowest amount of gas?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "There is a bug in the testcase `gas=[2,1,0,0]`, `cost=[0,1,0,0]`, the problem statement says the solution is unique but start from every index can complete the circuit\\nThe system can detect duplicated solution if we rotate the pairs by 1 to `gas=[0,2,1,0]`, `cost=[0,0,1,0]`, then it says \"Invalid Testcase\" \"The answer should be unique.\"\\n\\nBefore LeetCode remove this bugged testcase, be sure to account this.\\nFor example, when computing lowest_idx, make sure you keep updating it when ever the lowest gas tank are hit, so we can skip the [0, 0] gas/cost pairs"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": " int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "NishantGautam",
                        "content": "[@Yue Yunpeng](/yueyunpeng) how did you arrive at the thinking that I have to start at the station with lowest amount of gas."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Trick to solve circular path problems: Explains in under three minutes:\\nhttps://youtu.be/IEnJSIOOtOg"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "[@er_sushant](/er_sushant)  we can move forward onle if gas>0 so we should always keep this in mind.so,if(gas<=0)break; we can\\'t move further"
                    },
                    {
                        "username": "er_sushant",
                        "content": "[@abhi098](/abhi098) we can guarantee at the last station when `gas >= 0`, this means there is enough gas to make one circular circuit atleast once. if we found `gas < 0`, in any of the station, means we don\\'t have enough gas to move to next station.\\nAlso try various test cases for better understanding."
                    },
                    {
                        "username": "abhi098",
                        "content": "[@jobless_lm10](/jobless_lm10) how can you guarentee that when gas >0 at the last station, you can complete the whole circle from where you start ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "no need to do second pass. If gas remaining at the end of first pass is less than 0 then we can never go round all stations from any station. Otherwise we can go round all from lowest_idx + 1."
                    },
                    {
                        "username": "evidem64",
                        "content": "Problem description states:\\n> If there exists a solution, it is guaranteed to be unique\\n\\nOn submission my solution fails for the following case:\\n> [1,2,3,4,5,6,7,8]\\n> [1,2,3,4,5,6,7,8]\\n\\nClearly, there IS a solution, but it\\'s NOT unique, since\\nyou can start at any of the stations.\\nExpected answer is 0 though, anything else gets rejected.\\n"
                    },
                    {
                        "username": "emil_i_lonneberga",
                        "content": "Another test case that failed to satisfy the uniqueness is gas = [2, 0, 0, 0, ..., 0], cost =[0, 1, 0, 0, ..., 0]. If the test cases cannot be guaranteed to be unique, then additional restrictions like finding the minimum of all viable starting index should be placed. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@nishant7372](/nishant7372) `gas=[2,1,0,0, .... ,0,0]`, `cost=[0,1,0,0, .... ,0,0]` This one is a system testcase, the expected answer is `0` but we can clearly see that every index is actually valid.\nAND, if we rotate it by 1 to `gas=[0,2,1,0,0, .... ,0]`, `cost=[0,0,1,0,0, .... ,0]` as a custom testcase, the system now complains it has non-unique answer.\nThe problem is a circular problem, simply shifting the index in the array representation should not make any difference."
                    },
                    {
                        "username": "labbiahmed",
                        "content": "only one time tank == 0 . in this scenario this test case invalid . every time when you arrived a next station your tank is empty. \\n"
                    },
                    {
                        "username": "mudit_loya",
                        "content": "yes .. the solution is not unique .. even i have testcases where there many solutions"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "Isn\\'t this an invalid test case. It\\'s giving me invalid test case output."
                    },
                    {
                        "username": "jotho_",
                        "content": "There are more than one correct starting stations for that testcase, so it will be rejected."
                    },
                    {
                        "username": "aneesh1029",
                        "content": "You are starting from starting station at 0th index so return the first station possible"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "I think we need to return the smallest possible answer"
                    },
                    {
                        "username": "nishant7372",
                        "content": "I think all the system testcases have a unique answer."
                    },
                    {
                        "username": "banty",
                        "content": "This is not a rant, I genuinly want to know what is it that this problem trying to test so that I can practice it more and be better at it"
                    },
                    {
                        "username": "RB213",
                        "content": "This question is stupid, the language is so convoluted and examples are poor. But this situation does happen in real life when customers/product can\\'t express the problem clearly and engineers build poorly designed system. "
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "It is simply about problem solving skill + greedy technique i think"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "The problem does not state we want the smallest index as a result.\\n\\n[1,6,3,4,5]\\n[3,4,5,1,2]\\n\\nSo, why the answer 3 is not accpeted for the above test case ??\\n"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "The question mentions that the answer is unique. Your test case has two answers. Hence, the wrong one."
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question is very confusing. "
                    },
                    {
                        "username": "pavankumar",
                        "content": "Hi all,\\nI've written the code in suchaway that my solution validates all possible starting positions. I know that this is a very inefficient code to find the solution and finally i got time limit exceeded. can anybody give suggestions on how to solve this in an efficient way. I don't need code  but logic fine.\\n\\nThanks\\npavan kumar"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I know this comment is now almost a decade old at this point but here\\'s what I did. Try keeping track of the difference between the gas and cost as that\\'s what really matters for the problem. You might have to look when to avoid (hint the value will be negative so you can\\'t reach that place anyways). Here\\'s an example:\\n```[1,2,3,4,5] gas\\n[3,4,5,1,2] cost\\n[-2,-2,-2,3,3] -> difference between gas and cost (use variable instead of array for better space)\\n  0  1   2 3 4 -> index\\n```\\nthe net value till index 2 is negative (always -2 so we can ignore till there because it is not possible to move to the next point from these position.\\nfor index 3 this can be a possible answer. But what about having another net negative value in between (say -4)\\n```\\n[-2,-2,-2,3,-4,3]\\n```\\nwe can no longer use the index 3 now. But if you look closely we will find that for the above case it\\'s impossible to have a solution (output is -1). Reason is becase sum(gas)-sum(cost) is negative.\\nBut what for \\n```\\n[-2,-2,-2,3,-4,10]\\n```\\nHere we will keep track of the `minimum valid index`. Since, the answer is unique we can have only 1 valid index. Hence, using a Integer.MAX_VALUE as the initial answer and choosing the min and reassigning it to Integer.MAX_VALUE when the initially possible valid index (the index 3 in this case) is incorrect answer.\\n\\nLink to code: https://leetcode.com/problems/gas-station/solutions/3012347/easy-python-solution/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`The most unbelievable thing about this question isn\\'t that the car has unlimited gas tank, but the fact that I have got money to pay for it`"
                    },
                    {
                        "username": "pushpit_singh",
                        "content": "Us bhai Us"
                    },
                    {
                        "username": "dileep9259",
                        "content": "wah !!! :P\\n"
                    }
                ]
            },
            {
                "id": 1570765,
                "content": [
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan anyone please explain with giving some examples also to make it clear what is asked? thanks"
                    },
                    {
                        "username": "LOVEGURU",
                        "content": "Gas is gas station, Cost is amount of gas required to travel from i to i+1 station. we need to find index .From that we can complete the journey if we do not find index return -1.\\nour main agenda is find index we can travel from i to n-1 in the circular way"
                    },
                    {
                        "username": "Joseph86",
                        "content": "[@calm27](/calm27) I was in 5th grade in 2015 :0"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "whoa..  ancient comments were full of respect and gratitude!"
                    },
                    {
                        "username": "calm27",
                        "content": "[@heisenberg280](/heisenberg280) no way 2015 was 8 years ago, mate. no way "
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "[@heisenberg280](/heisenberg280)  \\uD83D\\uDE02\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Msey",
                        "content": "[@heisenberg280](/heisenberg280) or not and gave up :)"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@studcoder569](/studcoder569) Jul 29, 2015"
                    },
                    {
                        "username": "studcoder569",
                        "content": "[@heisenberg280](/heisenberg280) Good point lol"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "[@heisenberg280](/heisenberg280) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@studcoder569](/studcoder569) love your dedication but after 8 long years she might have understood the question by now :)"
                    },
                    {
                        "username": "studcoder569",
                        "content": "The question is asking you to find a starting gas station on the circuit that will allow you to complete one round trip without running out of gas. It is possible for there to be no solution. If there is a solution, the test cases are written such that it is unique. The examples shown in the description illustrate how the road trip would work. "
                    },
                    {
                        "username": "dadick",
                        "content": "Hint: if you start from station `a` and stuck at `b`, then you can't get to `b` from any station between `a` and `b`."
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) at position a we are getting some positive value \"y\" and from a to b we are adding some \"x\"  ..so if x+y cant cross b then obviously x alone cant cross b....... in your case we can reach to position 2 but cant cross it"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) reached to position to 2 but we cant reach to next position ..\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "what if ,gas={2,3,1,5} cost={1,2,4,3} i start at station 0 and reach station 2, and get stuck there, but i can start at station 1 and reach station 2, so your hint is proved wrong successfully "
                    },
                    {
                        "username": "khan60939",
                        "content": "[@mimirave](/mimirave) same confusion"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Bye bye TLE \\uD83D\\uDC4B"
                    },
                    {
                        "username": "mimirave",
                        "content": "Am I misunderstanding this hint?: If I start at station 0, successfully get to station 1, successfully get to station 2 but cannot complete the trip to station 3, then I am stuck at station 2 and the hint says that I cannot get to station 2 from station 1.  "
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "thanks! overcame TLE"
                    },
                    {
                        "username": "Jayasurya_K",
                        "content": "Thanks Buddy! TLE cracked..!"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "Thanks! TLE eliminator hint"
                    },
                    {
                        "username": "vanchanr",
                        "content": "good one !"
                    },
                    {
                        "username": "huanpipt",
                        "content": "Overcome TLE with this tip :) "
                    },
                    {
                        "username": "w286432531",
                        "content": "Thanks. I went from TLE to accepted with this hint."
                    },
                    {
                        "username": "CourteousCoder",
                        "content": "In order to prepare for an interview, it is more important that I am able to recognized the pattern in this problem.\\n\\nCan someone please help me identify the pattern of this problem?\\n\\nIs this a variation of a classic problem in Computer Science?\\nIf so, which?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of those problems that don\\'t fall under any category. It simply is just understanding the problem and utilizing problem solving"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "so how was your interview\\n"
                    },
                    {
                        "username": "kardopaska",
                        "content": "This is a classic problem of misdirection.  Description clearly states that valid answers include travel in clockwise direction only!  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "yueyunpeng",
                        "content": "I solved it with a two pass algorithm fairly quickly, the idea is:\\n\\n1. First just assum the gas tank can fall below zero, complete a loop starting at position 0, and record the index with lowest amount of gas (possibly negative) in tank, call it `lowest_idx`.\\n\\n2. Complete a loop starting from `lowest_idx`, break and return `-1` if the tank falls below zero at any point. Return `lowest_idx` if it never fell below zero.\\n\\nSure it\\'s not one pass, but extremely easy to understand, guarantees to be O(N) time and O(1) space, and did pass all tests. Am I missing anything?"
                    },
                    {
                        "username": "ggx94",
                        "content": "[@Kaltu](/Kaltu) I think they have tried to fix it (test case 39/40 for me...) but there is still a bug. The solution is still not unique,"
                    },
                    {
                        "username": "crazytan",
                        "content": "What if there are multiple indices with lowest amount of gas?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "There is a bug in the testcase `gas=[2,1,0,0]`, `cost=[0,1,0,0]`, the problem statement says the solution is unique but start from every index can complete the circuit\\nThe system can detect duplicated solution if we rotate the pairs by 1 to `gas=[0,2,1,0]`, `cost=[0,0,1,0]`, then it says \"Invalid Testcase\" \"The answer should be unique.\"\\n\\nBefore LeetCode remove this bugged testcase, be sure to account this.\\nFor example, when computing lowest_idx, make sure you keep updating it when ever the lowest gas tank are hit, so we can skip the [0, 0] gas/cost pairs"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": " int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "NishantGautam",
                        "content": "[@Yue Yunpeng](/yueyunpeng) how did you arrive at the thinking that I have to start at the station with lowest amount of gas."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Trick to solve circular path problems: Explains in under three minutes:\\nhttps://youtu.be/IEnJSIOOtOg"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "[@er_sushant](/er_sushant)  we can move forward onle if gas>0 so we should always keep this in mind.so,if(gas<=0)break; we can\\'t move further"
                    },
                    {
                        "username": "er_sushant",
                        "content": "[@abhi098](/abhi098) we can guarantee at the last station when `gas >= 0`, this means there is enough gas to make one circular circuit atleast once. if we found `gas < 0`, in any of the station, means we don\\'t have enough gas to move to next station.\\nAlso try various test cases for better understanding."
                    },
                    {
                        "username": "abhi098",
                        "content": "[@jobless_lm10](/jobless_lm10) how can you guarentee that when gas >0 at the last station, you can complete the whole circle from where you start ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "no need to do second pass. If gas remaining at the end of first pass is less than 0 then we can never go round all stations from any station. Otherwise we can go round all from lowest_idx + 1."
                    },
                    {
                        "username": "evidem64",
                        "content": "Problem description states:\\n> If there exists a solution, it is guaranteed to be unique\\n\\nOn submission my solution fails for the following case:\\n> [1,2,3,4,5,6,7,8]\\n> [1,2,3,4,5,6,7,8]\\n\\nClearly, there IS a solution, but it\\'s NOT unique, since\\nyou can start at any of the stations.\\nExpected answer is 0 though, anything else gets rejected.\\n"
                    },
                    {
                        "username": "emil_i_lonneberga",
                        "content": "Another test case that failed to satisfy the uniqueness is gas = [2, 0, 0, 0, ..., 0], cost =[0, 1, 0, 0, ..., 0]. If the test cases cannot be guaranteed to be unique, then additional restrictions like finding the minimum of all viable starting index should be placed. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@nishant7372](/nishant7372) `gas=[2,1,0,0, .... ,0,0]`, `cost=[0,1,0,0, .... ,0,0]` This one is a system testcase, the expected answer is `0` but we can clearly see that every index is actually valid.\nAND, if we rotate it by 1 to `gas=[0,2,1,0,0, .... ,0]`, `cost=[0,0,1,0,0, .... ,0]` as a custom testcase, the system now complains it has non-unique answer.\nThe problem is a circular problem, simply shifting the index in the array representation should not make any difference."
                    },
                    {
                        "username": "labbiahmed",
                        "content": "only one time tank == 0 . in this scenario this test case invalid . every time when you arrived a next station your tank is empty. \\n"
                    },
                    {
                        "username": "mudit_loya",
                        "content": "yes .. the solution is not unique .. even i have testcases where there many solutions"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "Isn\\'t this an invalid test case. It\\'s giving me invalid test case output."
                    },
                    {
                        "username": "jotho_",
                        "content": "There are more than one correct starting stations for that testcase, so it will be rejected."
                    },
                    {
                        "username": "aneesh1029",
                        "content": "You are starting from starting station at 0th index so return the first station possible"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "I think we need to return the smallest possible answer"
                    },
                    {
                        "username": "nishant7372",
                        "content": "I think all the system testcases have a unique answer."
                    },
                    {
                        "username": "banty",
                        "content": "This is not a rant, I genuinly want to know what is it that this problem trying to test so that I can practice it more and be better at it"
                    },
                    {
                        "username": "RB213",
                        "content": "This question is stupid, the language is so convoluted and examples are poor. But this situation does happen in real life when customers/product can\\'t express the problem clearly and engineers build poorly designed system. "
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "It is simply about problem solving skill + greedy technique i think"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "The problem does not state we want the smallest index as a result.\\n\\n[1,6,3,4,5]\\n[3,4,5,1,2]\\n\\nSo, why the answer 3 is not accpeted for the above test case ??\\n"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "The question mentions that the answer is unique. Your test case has two answers. Hence, the wrong one."
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question is very confusing. "
                    },
                    {
                        "username": "pavankumar",
                        "content": "Hi all,\\nI've written the code in suchaway that my solution validates all possible starting positions. I know that this is a very inefficient code to find the solution and finally i got time limit exceeded. can anybody give suggestions on how to solve this in an efficient way. I don't need code  but logic fine.\\n\\nThanks\\npavan kumar"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I know this comment is now almost a decade old at this point but here\\'s what I did. Try keeping track of the difference between the gas and cost as that\\'s what really matters for the problem. You might have to look when to avoid (hint the value will be negative so you can\\'t reach that place anyways). Here\\'s an example:\\n```[1,2,3,4,5] gas\\n[3,4,5,1,2] cost\\n[-2,-2,-2,3,3] -> difference between gas and cost (use variable instead of array for better space)\\n  0  1   2 3 4 -> index\\n```\\nthe net value till index 2 is negative (always -2 so we can ignore till there because it is not possible to move to the next point from these position.\\nfor index 3 this can be a possible answer. But what about having another net negative value in between (say -4)\\n```\\n[-2,-2,-2,3,-4,3]\\n```\\nwe can no longer use the index 3 now. But if you look closely we will find that for the above case it\\'s impossible to have a solution (output is -1). Reason is becase sum(gas)-sum(cost) is negative.\\nBut what for \\n```\\n[-2,-2,-2,3,-4,10]\\n```\\nHere we will keep track of the `minimum valid index`. Since, the answer is unique we can have only 1 valid index. Hence, using a Integer.MAX_VALUE as the initial answer and choosing the min and reassigning it to Integer.MAX_VALUE when the initially possible valid index (the index 3 in this case) is incorrect answer.\\n\\nLink to code: https://leetcode.com/problems/gas-station/solutions/3012347/easy-python-solution/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`The most unbelievable thing about this question isn\\'t that the car has unlimited gas tank, but the fact that I have got money to pay for it`"
                    },
                    {
                        "username": "pushpit_singh",
                        "content": "Us bhai Us"
                    },
                    {
                        "username": "dileep9259",
                        "content": "wah !!! :P\\n"
                    }
                ]
            },
            {
                "id": 1746548,
                "content": [
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan anyone please explain with giving some examples also to make it clear what is asked? thanks"
                    },
                    {
                        "username": "LOVEGURU",
                        "content": "Gas is gas station, Cost is amount of gas required to travel from i to i+1 station. we need to find index .From that we can complete the journey if we do not find index return -1.\\nour main agenda is find index we can travel from i to n-1 in the circular way"
                    },
                    {
                        "username": "Joseph86",
                        "content": "[@calm27](/calm27) I was in 5th grade in 2015 :0"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "whoa..  ancient comments were full of respect and gratitude!"
                    },
                    {
                        "username": "calm27",
                        "content": "[@heisenberg280](/heisenberg280) no way 2015 was 8 years ago, mate. no way "
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "[@heisenberg280](/heisenberg280)  \\uD83D\\uDE02\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Msey",
                        "content": "[@heisenberg280](/heisenberg280) or not and gave up :)"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@studcoder569](/studcoder569) Jul 29, 2015"
                    },
                    {
                        "username": "studcoder569",
                        "content": "[@heisenberg280](/heisenberg280) Good point lol"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "[@heisenberg280](/heisenberg280) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@studcoder569](/studcoder569) love your dedication but after 8 long years she might have understood the question by now :)"
                    },
                    {
                        "username": "studcoder569",
                        "content": "The question is asking you to find a starting gas station on the circuit that will allow you to complete one round trip without running out of gas. It is possible for there to be no solution. If there is a solution, the test cases are written such that it is unique. The examples shown in the description illustrate how the road trip would work. "
                    },
                    {
                        "username": "dadick",
                        "content": "Hint: if you start from station `a` and stuck at `b`, then you can't get to `b` from any station between `a` and `b`."
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) at position a we are getting some positive value \"y\" and from a to b we are adding some \"x\"  ..so if x+y cant cross b then obviously x alone cant cross b....... in your case we can reach to position 2 but cant cross it"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) reached to position to 2 but we cant reach to next position ..\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "what if ,gas={2,3,1,5} cost={1,2,4,3} i start at station 0 and reach station 2, and get stuck there, but i can start at station 1 and reach station 2, so your hint is proved wrong successfully "
                    },
                    {
                        "username": "khan60939",
                        "content": "[@mimirave](/mimirave) same confusion"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Bye bye TLE \\uD83D\\uDC4B"
                    },
                    {
                        "username": "mimirave",
                        "content": "Am I misunderstanding this hint?: If I start at station 0, successfully get to station 1, successfully get to station 2 but cannot complete the trip to station 3, then I am stuck at station 2 and the hint says that I cannot get to station 2 from station 1.  "
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "thanks! overcame TLE"
                    },
                    {
                        "username": "Jayasurya_K",
                        "content": "Thanks Buddy! TLE cracked..!"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "Thanks! TLE eliminator hint"
                    },
                    {
                        "username": "vanchanr",
                        "content": "good one !"
                    },
                    {
                        "username": "huanpipt",
                        "content": "Overcome TLE with this tip :) "
                    },
                    {
                        "username": "w286432531",
                        "content": "Thanks. I went from TLE to accepted with this hint."
                    },
                    {
                        "username": "CourteousCoder",
                        "content": "In order to prepare for an interview, it is more important that I am able to recognized the pattern in this problem.\\n\\nCan someone please help me identify the pattern of this problem?\\n\\nIs this a variation of a classic problem in Computer Science?\\nIf so, which?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of those problems that don\\'t fall under any category. It simply is just understanding the problem and utilizing problem solving"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "so how was your interview\\n"
                    },
                    {
                        "username": "kardopaska",
                        "content": "This is a classic problem of misdirection.  Description clearly states that valid answers include travel in clockwise direction only!  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "yueyunpeng",
                        "content": "I solved it with a two pass algorithm fairly quickly, the idea is:\\n\\n1. First just assum the gas tank can fall below zero, complete a loop starting at position 0, and record the index with lowest amount of gas (possibly negative) in tank, call it `lowest_idx`.\\n\\n2. Complete a loop starting from `lowest_idx`, break and return `-1` if the tank falls below zero at any point. Return `lowest_idx` if it never fell below zero.\\n\\nSure it\\'s not one pass, but extremely easy to understand, guarantees to be O(N) time and O(1) space, and did pass all tests. Am I missing anything?"
                    },
                    {
                        "username": "ggx94",
                        "content": "[@Kaltu](/Kaltu) I think they have tried to fix it (test case 39/40 for me...) but there is still a bug. The solution is still not unique,"
                    },
                    {
                        "username": "crazytan",
                        "content": "What if there are multiple indices with lowest amount of gas?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "There is a bug in the testcase `gas=[2,1,0,0]`, `cost=[0,1,0,0]`, the problem statement says the solution is unique but start from every index can complete the circuit\\nThe system can detect duplicated solution if we rotate the pairs by 1 to `gas=[0,2,1,0]`, `cost=[0,0,1,0]`, then it says \"Invalid Testcase\" \"The answer should be unique.\"\\n\\nBefore LeetCode remove this bugged testcase, be sure to account this.\\nFor example, when computing lowest_idx, make sure you keep updating it when ever the lowest gas tank are hit, so we can skip the [0, 0] gas/cost pairs"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": " int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "NishantGautam",
                        "content": "[@Yue Yunpeng](/yueyunpeng) how did you arrive at the thinking that I have to start at the station with lowest amount of gas."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Trick to solve circular path problems: Explains in under three minutes:\\nhttps://youtu.be/IEnJSIOOtOg"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "[@er_sushant](/er_sushant)  we can move forward onle if gas>0 so we should always keep this in mind.so,if(gas<=0)break; we can\\'t move further"
                    },
                    {
                        "username": "er_sushant",
                        "content": "[@abhi098](/abhi098) we can guarantee at the last station when `gas >= 0`, this means there is enough gas to make one circular circuit atleast once. if we found `gas < 0`, in any of the station, means we don\\'t have enough gas to move to next station.\\nAlso try various test cases for better understanding."
                    },
                    {
                        "username": "abhi098",
                        "content": "[@jobless_lm10](/jobless_lm10) how can you guarentee that when gas >0 at the last station, you can complete the whole circle from where you start ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "no need to do second pass. If gas remaining at the end of first pass is less than 0 then we can never go round all stations from any station. Otherwise we can go round all from lowest_idx + 1."
                    },
                    {
                        "username": "evidem64",
                        "content": "Problem description states:\\n> If there exists a solution, it is guaranteed to be unique\\n\\nOn submission my solution fails for the following case:\\n> [1,2,3,4,5,6,7,8]\\n> [1,2,3,4,5,6,7,8]\\n\\nClearly, there IS a solution, but it\\'s NOT unique, since\\nyou can start at any of the stations.\\nExpected answer is 0 though, anything else gets rejected.\\n"
                    },
                    {
                        "username": "emil_i_lonneberga",
                        "content": "Another test case that failed to satisfy the uniqueness is gas = [2, 0, 0, 0, ..., 0], cost =[0, 1, 0, 0, ..., 0]. If the test cases cannot be guaranteed to be unique, then additional restrictions like finding the minimum of all viable starting index should be placed. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@nishant7372](/nishant7372) `gas=[2,1,0,0, .... ,0,0]`, `cost=[0,1,0,0, .... ,0,0]` This one is a system testcase, the expected answer is `0` but we can clearly see that every index is actually valid.\nAND, if we rotate it by 1 to `gas=[0,2,1,0,0, .... ,0]`, `cost=[0,0,1,0,0, .... ,0]` as a custom testcase, the system now complains it has non-unique answer.\nThe problem is a circular problem, simply shifting the index in the array representation should not make any difference."
                    },
                    {
                        "username": "labbiahmed",
                        "content": "only one time tank == 0 . in this scenario this test case invalid . every time when you arrived a next station your tank is empty. \\n"
                    },
                    {
                        "username": "mudit_loya",
                        "content": "yes .. the solution is not unique .. even i have testcases where there many solutions"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "Isn\\'t this an invalid test case. It\\'s giving me invalid test case output."
                    },
                    {
                        "username": "jotho_",
                        "content": "There are more than one correct starting stations for that testcase, so it will be rejected."
                    },
                    {
                        "username": "aneesh1029",
                        "content": "You are starting from starting station at 0th index so return the first station possible"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "I think we need to return the smallest possible answer"
                    },
                    {
                        "username": "nishant7372",
                        "content": "I think all the system testcases have a unique answer."
                    },
                    {
                        "username": "banty",
                        "content": "This is not a rant, I genuinly want to know what is it that this problem trying to test so that I can practice it more and be better at it"
                    },
                    {
                        "username": "RB213",
                        "content": "This question is stupid, the language is so convoluted and examples are poor. But this situation does happen in real life when customers/product can\\'t express the problem clearly and engineers build poorly designed system. "
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "It is simply about problem solving skill + greedy technique i think"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "The problem does not state we want the smallest index as a result.\\n\\n[1,6,3,4,5]\\n[3,4,5,1,2]\\n\\nSo, why the answer 3 is not accpeted for the above test case ??\\n"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "The question mentions that the answer is unique. Your test case has two answers. Hence, the wrong one."
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question is very confusing. "
                    },
                    {
                        "username": "pavankumar",
                        "content": "Hi all,\\nI've written the code in suchaway that my solution validates all possible starting positions. I know that this is a very inefficient code to find the solution and finally i got time limit exceeded. can anybody give suggestions on how to solve this in an efficient way. I don't need code  but logic fine.\\n\\nThanks\\npavan kumar"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I know this comment is now almost a decade old at this point but here\\'s what I did. Try keeping track of the difference between the gas and cost as that\\'s what really matters for the problem. You might have to look when to avoid (hint the value will be negative so you can\\'t reach that place anyways). Here\\'s an example:\\n```[1,2,3,4,5] gas\\n[3,4,5,1,2] cost\\n[-2,-2,-2,3,3] -> difference between gas and cost (use variable instead of array for better space)\\n  0  1   2 3 4 -> index\\n```\\nthe net value till index 2 is negative (always -2 so we can ignore till there because it is not possible to move to the next point from these position.\\nfor index 3 this can be a possible answer. But what about having another net negative value in between (say -4)\\n```\\n[-2,-2,-2,3,-4,3]\\n```\\nwe can no longer use the index 3 now. But if you look closely we will find that for the above case it\\'s impossible to have a solution (output is -1). Reason is becase sum(gas)-sum(cost) is negative.\\nBut what for \\n```\\n[-2,-2,-2,3,-4,10]\\n```\\nHere we will keep track of the `minimum valid index`. Since, the answer is unique we can have only 1 valid index. Hence, using a Integer.MAX_VALUE as the initial answer and choosing the min and reassigning it to Integer.MAX_VALUE when the initially possible valid index (the index 3 in this case) is incorrect answer.\\n\\nLink to code: https://leetcode.com/problems/gas-station/solutions/3012347/easy-python-solution/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`The most unbelievable thing about this question isn\\'t that the car has unlimited gas tank, but the fact that I have got money to pay for it`"
                    },
                    {
                        "username": "pushpit_singh",
                        "content": "Us bhai Us"
                    },
                    {
                        "username": "dileep9259",
                        "content": "wah !!! :P\\n"
                    }
                ]
            },
            {
                "id": 1567882,
                "content": [
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan anyone please explain with giving some examples also to make it clear what is asked? thanks"
                    },
                    {
                        "username": "LOVEGURU",
                        "content": "Gas is gas station, Cost is amount of gas required to travel from i to i+1 station. we need to find index .From that we can complete the journey if we do not find index return -1.\\nour main agenda is find index we can travel from i to n-1 in the circular way"
                    },
                    {
                        "username": "Joseph86",
                        "content": "[@calm27](/calm27) I was in 5th grade in 2015 :0"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "whoa..  ancient comments were full of respect and gratitude!"
                    },
                    {
                        "username": "calm27",
                        "content": "[@heisenberg280](/heisenberg280) no way 2015 was 8 years ago, mate. no way "
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "[@heisenberg280](/heisenberg280)  \\uD83D\\uDE02\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Msey",
                        "content": "[@heisenberg280](/heisenberg280) or not and gave up :)"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@studcoder569](/studcoder569) Jul 29, 2015"
                    },
                    {
                        "username": "studcoder569",
                        "content": "[@heisenberg280](/heisenberg280) Good point lol"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "[@heisenberg280](/heisenberg280) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@studcoder569](/studcoder569) love your dedication but after 8 long years she might have understood the question by now :)"
                    },
                    {
                        "username": "studcoder569",
                        "content": "The question is asking you to find a starting gas station on the circuit that will allow you to complete one round trip without running out of gas. It is possible for there to be no solution. If there is a solution, the test cases are written such that it is unique. The examples shown in the description illustrate how the road trip would work. "
                    },
                    {
                        "username": "dadick",
                        "content": "Hint: if you start from station `a` and stuck at `b`, then you can't get to `b` from any station between `a` and `b`."
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) at position a we are getting some positive value \"y\" and from a to b we are adding some \"x\"  ..so if x+y cant cross b then obviously x alone cant cross b....... in your case we can reach to position 2 but cant cross it"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) reached to position to 2 but we cant reach to next position ..\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "what if ,gas={2,3,1,5} cost={1,2,4,3} i start at station 0 and reach station 2, and get stuck there, but i can start at station 1 and reach station 2, so your hint is proved wrong successfully "
                    },
                    {
                        "username": "khan60939",
                        "content": "[@mimirave](/mimirave) same confusion"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Bye bye TLE \\uD83D\\uDC4B"
                    },
                    {
                        "username": "mimirave",
                        "content": "Am I misunderstanding this hint?: If I start at station 0, successfully get to station 1, successfully get to station 2 but cannot complete the trip to station 3, then I am stuck at station 2 and the hint says that I cannot get to station 2 from station 1.  "
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "thanks! overcame TLE"
                    },
                    {
                        "username": "Jayasurya_K",
                        "content": "Thanks Buddy! TLE cracked..!"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "Thanks! TLE eliminator hint"
                    },
                    {
                        "username": "vanchanr",
                        "content": "good one !"
                    },
                    {
                        "username": "huanpipt",
                        "content": "Overcome TLE with this tip :) "
                    },
                    {
                        "username": "w286432531",
                        "content": "Thanks. I went from TLE to accepted with this hint."
                    },
                    {
                        "username": "CourteousCoder",
                        "content": "In order to prepare for an interview, it is more important that I am able to recognized the pattern in this problem.\\n\\nCan someone please help me identify the pattern of this problem?\\n\\nIs this a variation of a classic problem in Computer Science?\\nIf so, which?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of those problems that don\\'t fall under any category. It simply is just understanding the problem and utilizing problem solving"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "so how was your interview\\n"
                    },
                    {
                        "username": "kardopaska",
                        "content": "This is a classic problem of misdirection.  Description clearly states that valid answers include travel in clockwise direction only!  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "yueyunpeng",
                        "content": "I solved it with a two pass algorithm fairly quickly, the idea is:\\n\\n1. First just assum the gas tank can fall below zero, complete a loop starting at position 0, and record the index with lowest amount of gas (possibly negative) in tank, call it `lowest_idx`.\\n\\n2. Complete a loop starting from `lowest_idx`, break and return `-1` if the tank falls below zero at any point. Return `lowest_idx` if it never fell below zero.\\n\\nSure it\\'s not one pass, but extremely easy to understand, guarantees to be O(N) time and O(1) space, and did pass all tests. Am I missing anything?"
                    },
                    {
                        "username": "ggx94",
                        "content": "[@Kaltu](/Kaltu) I think they have tried to fix it (test case 39/40 for me...) but there is still a bug. The solution is still not unique,"
                    },
                    {
                        "username": "crazytan",
                        "content": "What if there are multiple indices with lowest amount of gas?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "There is a bug in the testcase `gas=[2,1,0,0]`, `cost=[0,1,0,0]`, the problem statement says the solution is unique but start from every index can complete the circuit\\nThe system can detect duplicated solution if we rotate the pairs by 1 to `gas=[0,2,1,0]`, `cost=[0,0,1,0]`, then it says \"Invalid Testcase\" \"The answer should be unique.\"\\n\\nBefore LeetCode remove this bugged testcase, be sure to account this.\\nFor example, when computing lowest_idx, make sure you keep updating it when ever the lowest gas tank are hit, so we can skip the [0, 0] gas/cost pairs"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": " int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "NishantGautam",
                        "content": "[@Yue Yunpeng](/yueyunpeng) how did you arrive at the thinking that I have to start at the station with lowest amount of gas."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Trick to solve circular path problems: Explains in under three minutes:\\nhttps://youtu.be/IEnJSIOOtOg"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "[@er_sushant](/er_sushant)  we can move forward onle if gas>0 so we should always keep this in mind.so,if(gas<=0)break; we can\\'t move further"
                    },
                    {
                        "username": "er_sushant",
                        "content": "[@abhi098](/abhi098) we can guarantee at the last station when `gas >= 0`, this means there is enough gas to make one circular circuit atleast once. if we found `gas < 0`, in any of the station, means we don\\'t have enough gas to move to next station.\\nAlso try various test cases for better understanding."
                    },
                    {
                        "username": "abhi098",
                        "content": "[@jobless_lm10](/jobless_lm10) how can you guarentee that when gas >0 at the last station, you can complete the whole circle from where you start ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "no need to do second pass. If gas remaining at the end of first pass is less than 0 then we can never go round all stations from any station. Otherwise we can go round all from lowest_idx + 1."
                    },
                    {
                        "username": "evidem64",
                        "content": "Problem description states:\\n> If there exists a solution, it is guaranteed to be unique\\n\\nOn submission my solution fails for the following case:\\n> [1,2,3,4,5,6,7,8]\\n> [1,2,3,4,5,6,7,8]\\n\\nClearly, there IS a solution, but it\\'s NOT unique, since\\nyou can start at any of the stations.\\nExpected answer is 0 though, anything else gets rejected.\\n"
                    },
                    {
                        "username": "emil_i_lonneberga",
                        "content": "Another test case that failed to satisfy the uniqueness is gas = [2, 0, 0, 0, ..., 0], cost =[0, 1, 0, 0, ..., 0]. If the test cases cannot be guaranteed to be unique, then additional restrictions like finding the minimum of all viable starting index should be placed. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@nishant7372](/nishant7372) `gas=[2,1,0,0, .... ,0,0]`, `cost=[0,1,0,0, .... ,0,0]` This one is a system testcase, the expected answer is `0` but we can clearly see that every index is actually valid.\nAND, if we rotate it by 1 to `gas=[0,2,1,0,0, .... ,0]`, `cost=[0,0,1,0,0, .... ,0]` as a custom testcase, the system now complains it has non-unique answer.\nThe problem is a circular problem, simply shifting the index in the array representation should not make any difference."
                    },
                    {
                        "username": "labbiahmed",
                        "content": "only one time tank == 0 . in this scenario this test case invalid . every time when you arrived a next station your tank is empty. \\n"
                    },
                    {
                        "username": "mudit_loya",
                        "content": "yes .. the solution is not unique .. even i have testcases where there many solutions"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "Isn\\'t this an invalid test case. It\\'s giving me invalid test case output."
                    },
                    {
                        "username": "jotho_",
                        "content": "There are more than one correct starting stations for that testcase, so it will be rejected."
                    },
                    {
                        "username": "aneesh1029",
                        "content": "You are starting from starting station at 0th index so return the first station possible"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "I think we need to return the smallest possible answer"
                    },
                    {
                        "username": "nishant7372",
                        "content": "I think all the system testcases have a unique answer."
                    },
                    {
                        "username": "banty",
                        "content": "This is not a rant, I genuinly want to know what is it that this problem trying to test so that I can practice it more and be better at it"
                    },
                    {
                        "username": "RB213",
                        "content": "This question is stupid, the language is so convoluted and examples are poor. But this situation does happen in real life when customers/product can\\'t express the problem clearly and engineers build poorly designed system. "
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "It is simply about problem solving skill + greedy technique i think"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "The problem does not state we want the smallest index as a result.\\n\\n[1,6,3,4,5]\\n[3,4,5,1,2]\\n\\nSo, why the answer 3 is not accpeted for the above test case ??\\n"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "The question mentions that the answer is unique. Your test case has two answers. Hence, the wrong one."
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question is very confusing. "
                    },
                    {
                        "username": "pavankumar",
                        "content": "Hi all,\\nI've written the code in suchaway that my solution validates all possible starting positions. I know that this is a very inefficient code to find the solution and finally i got time limit exceeded. can anybody give suggestions on how to solve this in an efficient way. I don't need code  but logic fine.\\n\\nThanks\\npavan kumar"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I know this comment is now almost a decade old at this point but here\\'s what I did. Try keeping track of the difference between the gas and cost as that\\'s what really matters for the problem. You might have to look when to avoid (hint the value will be negative so you can\\'t reach that place anyways). Here\\'s an example:\\n```[1,2,3,4,5] gas\\n[3,4,5,1,2] cost\\n[-2,-2,-2,3,3] -> difference between gas and cost (use variable instead of array for better space)\\n  0  1   2 3 4 -> index\\n```\\nthe net value till index 2 is negative (always -2 so we can ignore till there because it is not possible to move to the next point from these position.\\nfor index 3 this can be a possible answer. But what about having another net negative value in between (say -4)\\n```\\n[-2,-2,-2,3,-4,3]\\n```\\nwe can no longer use the index 3 now. But if you look closely we will find that for the above case it\\'s impossible to have a solution (output is -1). Reason is becase sum(gas)-sum(cost) is negative.\\nBut what for \\n```\\n[-2,-2,-2,3,-4,10]\\n```\\nHere we will keep track of the `minimum valid index`. Since, the answer is unique we can have only 1 valid index. Hence, using a Integer.MAX_VALUE as the initial answer and choosing the min and reassigning it to Integer.MAX_VALUE when the initially possible valid index (the index 3 in this case) is incorrect answer.\\n\\nLink to code: https://leetcode.com/problems/gas-station/solutions/3012347/easy-python-solution/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`The most unbelievable thing about this question isn\\'t that the car has unlimited gas tank, but the fact that I have got money to pay for it`"
                    },
                    {
                        "username": "pushpit_singh",
                        "content": "Us bhai Us"
                    },
                    {
                        "username": "dileep9259",
                        "content": "wah !!! :P\\n"
                    }
                ]
            },
            {
                "id": 1745596,
                "content": [
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan anyone please explain with giving some examples also to make it clear what is asked? thanks"
                    },
                    {
                        "username": "LOVEGURU",
                        "content": "Gas is gas station, Cost is amount of gas required to travel from i to i+1 station. we need to find index .From that we can complete the journey if we do not find index return -1.\\nour main agenda is find index we can travel from i to n-1 in the circular way"
                    },
                    {
                        "username": "Joseph86",
                        "content": "[@calm27](/calm27) I was in 5th grade in 2015 :0"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "whoa..  ancient comments were full of respect and gratitude!"
                    },
                    {
                        "username": "calm27",
                        "content": "[@heisenberg280](/heisenberg280) no way 2015 was 8 years ago, mate. no way "
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "[@heisenberg280](/heisenberg280)  \\uD83D\\uDE02\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Msey",
                        "content": "[@heisenberg280](/heisenberg280) or not and gave up :)"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@studcoder569](/studcoder569) Jul 29, 2015"
                    },
                    {
                        "username": "studcoder569",
                        "content": "[@heisenberg280](/heisenberg280) Good point lol"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "[@heisenberg280](/heisenberg280) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@studcoder569](/studcoder569) love your dedication but after 8 long years she might have understood the question by now :)"
                    },
                    {
                        "username": "studcoder569",
                        "content": "The question is asking you to find a starting gas station on the circuit that will allow you to complete one round trip without running out of gas. It is possible for there to be no solution. If there is a solution, the test cases are written such that it is unique. The examples shown in the description illustrate how the road trip would work. "
                    },
                    {
                        "username": "dadick",
                        "content": "Hint: if you start from station `a` and stuck at `b`, then you can't get to `b` from any station between `a` and `b`."
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) at position a we are getting some positive value \"y\" and from a to b we are adding some \"x\"  ..so if x+y cant cross b then obviously x alone cant cross b....... in your case we can reach to position 2 but cant cross it"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) reached to position to 2 but we cant reach to next position ..\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "what if ,gas={2,3,1,5} cost={1,2,4,3} i start at station 0 and reach station 2, and get stuck there, but i can start at station 1 and reach station 2, so your hint is proved wrong successfully "
                    },
                    {
                        "username": "khan60939",
                        "content": "[@mimirave](/mimirave) same confusion"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Bye bye TLE \\uD83D\\uDC4B"
                    },
                    {
                        "username": "mimirave",
                        "content": "Am I misunderstanding this hint?: If I start at station 0, successfully get to station 1, successfully get to station 2 but cannot complete the trip to station 3, then I am stuck at station 2 and the hint says that I cannot get to station 2 from station 1.  "
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "thanks! overcame TLE"
                    },
                    {
                        "username": "Jayasurya_K",
                        "content": "Thanks Buddy! TLE cracked..!"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "Thanks! TLE eliminator hint"
                    },
                    {
                        "username": "vanchanr",
                        "content": "good one !"
                    },
                    {
                        "username": "huanpipt",
                        "content": "Overcome TLE with this tip :) "
                    },
                    {
                        "username": "w286432531",
                        "content": "Thanks. I went from TLE to accepted with this hint."
                    },
                    {
                        "username": "CourteousCoder",
                        "content": "In order to prepare for an interview, it is more important that I am able to recognized the pattern in this problem.\\n\\nCan someone please help me identify the pattern of this problem?\\n\\nIs this a variation of a classic problem in Computer Science?\\nIf so, which?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of those problems that don\\'t fall under any category. It simply is just understanding the problem and utilizing problem solving"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "so how was your interview\\n"
                    },
                    {
                        "username": "kardopaska",
                        "content": "This is a classic problem of misdirection.  Description clearly states that valid answers include travel in clockwise direction only!  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "yueyunpeng",
                        "content": "I solved it with a two pass algorithm fairly quickly, the idea is:\\n\\n1. First just assum the gas tank can fall below zero, complete a loop starting at position 0, and record the index with lowest amount of gas (possibly negative) in tank, call it `lowest_idx`.\\n\\n2. Complete a loop starting from `lowest_idx`, break and return `-1` if the tank falls below zero at any point. Return `lowest_idx` if it never fell below zero.\\n\\nSure it\\'s not one pass, but extremely easy to understand, guarantees to be O(N) time and O(1) space, and did pass all tests. Am I missing anything?"
                    },
                    {
                        "username": "ggx94",
                        "content": "[@Kaltu](/Kaltu) I think they have tried to fix it (test case 39/40 for me...) but there is still a bug. The solution is still not unique,"
                    },
                    {
                        "username": "crazytan",
                        "content": "What if there are multiple indices with lowest amount of gas?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "There is a bug in the testcase `gas=[2,1,0,0]`, `cost=[0,1,0,0]`, the problem statement says the solution is unique but start from every index can complete the circuit\\nThe system can detect duplicated solution if we rotate the pairs by 1 to `gas=[0,2,1,0]`, `cost=[0,0,1,0]`, then it says \"Invalid Testcase\" \"The answer should be unique.\"\\n\\nBefore LeetCode remove this bugged testcase, be sure to account this.\\nFor example, when computing lowest_idx, make sure you keep updating it when ever the lowest gas tank are hit, so we can skip the [0, 0] gas/cost pairs"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": " int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "NishantGautam",
                        "content": "[@Yue Yunpeng](/yueyunpeng) how did you arrive at the thinking that I have to start at the station with lowest amount of gas."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Trick to solve circular path problems: Explains in under three minutes:\\nhttps://youtu.be/IEnJSIOOtOg"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "[@er_sushant](/er_sushant)  we can move forward onle if gas>0 so we should always keep this in mind.so,if(gas<=0)break; we can\\'t move further"
                    },
                    {
                        "username": "er_sushant",
                        "content": "[@abhi098](/abhi098) we can guarantee at the last station when `gas >= 0`, this means there is enough gas to make one circular circuit atleast once. if we found `gas < 0`, in any of the station, means we don\\'t have enough gas to move to next station.\\nAlso try various test cases for better understanding."
                    },
                    {
                        "username": "abhi098",
                        "content": "[@jobless_lm10](/jobless_lm10) how can you guarentee that when gas >0 at the last station, you can complete the whole circle from where you start ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "no need to do second pass. If gas remaining at the end of first pass is less than 0 then we can never go round all stations from any station. Otherwise we can go round all from lowest_idx + 1."
                    },
                    {
                        "username": "evidem64",
                        "content": "Problem description states:\\n> If there exists a solution, it is guaranteed to be unique\\n\\nOn submission my solution fails for the following case:\\n> [1,2,3,4,5,6,7,8]\\n> [1,2,3,4,5,6,7,8]\\n\\nClearly, there IS a solution, but it\\'s NOT unique, since\\nyou can start at any of the stations.\\nExpected answer is 0 though, anything else gets rejected.\\n"
                    },
                    {
                        "username": "emil_i_lonneberga",
                        "content": "Another test case that failed to satisfy the uniqueness is gas = [2, 0, 0, 0, ..., 0], cost =[0, 1, 0, 0, ..., 0]. If the test cases cannot be guaranteed to be unique, then additional restrictions like finding the minimum of all viable starting index should be placed. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@nishant7372](/nishant7372) `gas=[2,1,0,0, .... ,0,0]`, `cost=[0,1,0,0, .... ,0,0]` This one is a system testcase, the expected answer is `0` but we can clearly see that every index is actually valid.\nAND, if we rotate it by 1 to `gas=[0,2,1,0,0, .... ,0]`, `cost=[0,0,1,0,0, .... ,0]` as a custom testcase, the system now complains it has non-unique answer.\nThe problem is a circular problem, simply shifting the index in the array representation should not make any difference."
                    },
                    {
                        "username": "labbiahmed",
                        "content": "only one time tank == 0 . in this scenario this test case invalid . every time when you arrived a next station your tank is empty. \\n"
                    },
                    {
                        "username": "mudit_loya",
                        "content": "yes .. the solution is not unique .. even i have testcases where there many solutions"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "Isn\\'t this an invalid test case. It\\'s giving me invalid test case output."
                    },
                    {
                        "username": "jotho_",
                        "content": "There are more than one correct starting stations for that testcase, so it will be rejected."
                    },
                    {
                        "username": "aneesh1029",
                        "content": "You are starting from starting station at 0th index so return the first station possible"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "I think we need to return the smallest possible answer"
                    },
                    {
                        "username": "nishant7372",
                        "content": "I think all the system testcases have a unique answer."
                    },
                    {
                        "username": "banty",
                        "content": "This is not a rant, I genuinly want to know what is it that this problem trying to test so that I can practice it more and be better at it"
                    },
                    {
                        "username": "RB213",
                        "content": "This question is stupid, the language is so convoluted and examples are poor. But this situation does happen in real life when customers/product can\\'t express the problem clearly and engineers build poorly designed system. "
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "It is simply about problem solving skill + greedy technique i think"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "The problem does not state we want the smallest index as a result.\\n\\n[1,6,3,4,5]\\n[3,4,5,1,2]\\n\\nSo, why the answer 3 is not accpeted for the above test case ??\\n"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "The question mentions that the answer is unique. Your test case has two answers. Hence, the wrong one."
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question is very confusing. "
                    },
                    {
                        "username": "pavankumar",
                        "content": "Hi all,\\nI've written the code in suchaway that my solution validates all possible starting positions. I know that this is a very inefficient code to find the solution and finally i got time limit exceeded. can anybody give suggestions on how to solve this in an efficient way. I don't need code  but logic fine.\\n\\nThanks\\npavan kumar"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I know this comment is now almost a decade old at this point but here\\'s what I did. Try keeping track of the difference between the gas and cost as that\\'s what really matters for the problem. You might have to look when to avoid (hint the value will be negative so you can\\'t reach that place anyways). Here\\'s an example:\\n```[1,2,3,4,5] gas\\n[3,4,5,1,2] cost\\n[-2,-2,-2,3,3] -> difference between gas and cost (use variable instead of array for better space)\\n  0  1   2 3 4 -> index\\n```\\nthe net value till index 2 is negative (always -2 so we can ignore till there because it is not possible to move to the next point from these position.\\nfor index 3 this can be a possible answer. But what about having another net negative value in between (say -4)\\n```\\n[-2,-2,-2,3,-4,3]\\n```\\nwe can no longer use the index 3 now. But if you look closely we will find that for the above case it\\'s impossible to have a solution (output is -1). Reason is becase sum(gas)-sum(cost) is negative.\\nBut what for \\n```\\n[-2,-2,-2,3,-4,10]\\n```\\nHere we will keep track of the `minimum valid index`. Since, the answer is unique we can have only 1 valid index. Hence, using a Integer.MAX_VALUE as the initial answer and choosing the min and reassigning it to Integer.MAX_VALUE when the initially possible valid index (the index 3 in this case) is incorrect answer.\\n\\nLink to code: https://leetcode.com/problems/gas-station/solutions/3012347/easy-python-solution/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`The most unbelievable thing about this question isn\\'t that the car has unlimited gas tank, but the fact that I have got money to pay for it`"
                    },
                    {
                        "username": "pushpit_singh",
                        "content": "Us bhai Us"
                    },
                    {
                        "username": "dileep9259",
                        "content": "wah !!! :P\\n"
                    }
                ]
            },
            {
                "id": 1565115,
                "content": [
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan anyone please explain with giving some examples also to make it clear what is asked? thanks"
                    },
                    {
                        "username": "LOVEGURU",
                        "content": "Gas is gas station, Cost is amount of gas required to travel from i to i+1 station. we need to find index .From that we can complete the journey if we do not find index return -1.\\nour main agenda is find index we can travel from i to n-1 in the circular way"
                    },
                    {
                        "username": "Joseph86",
                        "content": "[@calm27](/calm27) I was in 5th grade in 2015 :0"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "whoa..  ancient comments were full of respect and gratitude!"
                    },
                    {
                        "username": "calm27",
                        "content": "[@heisenberg280](/heisenberg280) no way 2015 was 8 years ago, mate. no way "
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "[@heisenberg280](/heisenberg280)  \\uD83D\\uDE02\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Msey",
                        "content": "[@heisenberg280](/heisenberg280) or not and gave up :)"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@studcoder569](/studcoder569) Jul 29, 2015"
                    },
                    {
                        "username": "studcoder569",
                        "content": "[@heisenberg280](/heisenberg280) Good point lol"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "[@heisenberg280](/heisenberg280) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@studcoder569](/studcoder569) love your dedication but after 8 long years she might have understood the question by now :)"
                    },
                    {
                        "username": "studcoder569",
                        "content": "The question is asking you to find a starting gas station on the circuit that will allow you to complete one round trip without running out of gas. It is possible for there to be no solution. If there is a solution, the test cases are written such that it is unique. The examples shown in the description illustrate how the road trip would work. "
                    },
                    {
                        "username": "dadick",
                        "content": "Hint: if you start from station `a` and stuck at `b`, then you can't get to `b` from any station between `a` and `b`."
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) at position a we are getting some positive value \"y\" and from a to b we are adding some \"x\"  ..so if x+y cant cross b then obviously x alone cant cross b....... in your case we can reach to position 2 but cant cross it"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) reached to position to 2 but we cant reach to next position ..\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "what if ,gas={2,3,1,5} cost={1,2,4,3} i start at station 0 and reach station 2, and get stuck there, but i can start at station 1 and reach station 2, so your hint is proved wrong successfully "
                    },
                    {
                        "username": "khan60939",
                        "content": "[@mimirave](/mimirave) same confusion"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Bye bye TLE \\uD83D\\uDC4B"
                    },
                    {
                        "username": "mimirave",
                        "content": "Am I misunderstanding this hint?: If I start at station 0, successfully get to station 1, successfully get to station 2 but cannot complete the trip to station 3, then I am stuck at station 2 and the hint says that I cannot get to station 2 from station 1.  "
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "thanks! overcame TLE"
                    },
                    {
                        "username": "Jayasurya_K",
                        "content": "Thanks Buddy! TLE cracked..!"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "Thanks! TLE eliminator hint"
                    },
                    {
                        "username": "vanchanr",
                        "content": "good one !"
                    },
                    {
                        "username": "huanpipt",
                        "content": "Overcome TLE with this tip :) "
                    },
                    {
                        "username": "w286432531",
                        "content": "Thanks. I went from TLE to accepted with this hint."
                    },
                    {
                        "username": "CourteousCoder",
                        "content": "In order to prepare for an interview, it is more important that I am able to recognized the pattern in this problem.\\n\\nCan someone please help me identify the pattern of this problem?\\n\\nIs this a variation of a classic problem in Computer Science?\\nIf so, which?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of those problems that don\\'t fall under any category. It simply is just understanding the problem and utilizing problem solving"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "so how was your interview\\n"
                    },
                    {
                        "username": "kardopaska",
                        "content": "This is a classic problem of misdirection.  Description clearly states that valid answers include travel in clockwise direction only!  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "yueyunpeng",
                        "content": "I solved it with a two pass algorithm fairly quickly, the idea is:\\n\\n1. First just assum the gas tank can fall below zero, complete a loop starting at position 0, and record the index with lowest amount of gas (possibly negative) in tank, call it `lowest_idx`.\\n\\n2. Complete a loop starting from `lowest_idx`, break and return `-1` if the tank falls below zero at any point. Return `lowest_idx` if it never fell below zero.\\n\\nSure it\\'s not one pass, but extremely easy to understand, guarantees to be O(N) time and O(1) space, and did pass all tests. Am I missing anything?"
                    },
                    {
                        "username": "ggx94",
                        "content": "[@Kaltu](/Kaltu) I think they have tried to fix it (test case 39/40 for me...) but there is still a bug. The solution is still not unique,"
                    },
                    {
                        "username": "crazytan",
                        "content": "What if there are multiple indices with lowest amount of gas?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "There is a bug in the testcase `gas=[2,1,0,0]`, `cost=[0,1,0,0]`, the problem statement says the solution is unique but start from every index can complete the circuit\\nThe system can detect duplicated solution if we rotate the pairs by 1 to `gas=[0,2,1,0]`, `cost=[0,0,1,0]`, then it says \"Invalid Testcase\" \"The answer should be unique.\"\\n\\nBefore LeetCode remove this bugged testcase, be sure to account this.\\nFor example, when computing lowest_idx, make sure you keep updating it when ever the lowest gas tank are hit, so we can skip the [0, 0] gas/cost pairs"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": " int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "NishantGautam",
                        "content": "[@Yue Yunpeng](/yueyunpeng) how did you arrive at the thinking that I have to start at the station with lowest amount of gas."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Trick to solve circular path problems: Explains in under three minutes:\\nhttps://youtu.be/IEnJSIOOtOg"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "[@er_sushant](/er_sushant)  we can move forward onle if gas>0 so we should always keep this in mind.so,if(gas<=0)break; we can\\'t move further"
                    },
                    {
                        "username": "er_sushant",
                        "content": "[@abhi098](/abhi098) we can guarantee at the last station when `gas >= 0`, this means there is enough gas to make one circular circuit atleast once. if we found `gas < 0`, in any of the station, means we don\\'t have enough gas to move to next station.\\nAlso try various test cases for better understanding."
                    },
                    {
                        "username": "abhi098",
                        "content": "[@jobless_lm10](/jobless_lm10) how can you guarentee that when gas >0 at the last station, you can complete the whole circle from where you start ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "no need to do second pass. If gas remaining at the end of first pass is less than 0 then we can never go round all stations from any station. Otherwise we can go round all from lowest_idx + 1."
                    },
                    {
                        "username": "evidem64",
                        "content": "Problem description states:\\n> If there exists a solution, it is guaranteed to be unique\\n\\nOn submission my solution fails for the following case:\\n> [1,2,3,4,5,6,7,8]\\n> [1,2,3,4,5,6,7,8]\\n\\nClearly, there IS a solution, but it\\'s NOT unique, since\\nyou can start at any of the stations.\\nExpected answer is 0 though, anything else gets rejected.\\n"
                    },
                    {
                        "username": "emil_i_lonneberga",
                        "content": "Another test case that failed to satisfy the uniqueness is gas = [2, 0, 0, 0, ..., 0], cost =[0, 1, 0, 0, ..., 0]. If the test cases cannot be guaranteed to be unique, then additional restrictions like finding the minimum of all viable starting index should be placed. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@nishant7372](/nishant7372) `gas=[2,1,0,0, .... ,0,0]`, `cost=[0,1,0,0, .... ,0,0]` This one is a system testcase, the expected answer is `0` but we can clearly see that every index is actually valid.\nAND, if we rotate it by 1 to `gas=[0,2,1,0,0, .... ,0]`, `cost=[0,0,1,0,0, .... ,0]` as a custom testcase, the system now complains it has non-unique answer.\nThe problem is a circular problem, simply shifting the index in the array representation should not make any difference."
                    },
                    {
                        "username": "labbiahmed",
                        "content": "only one time tank == 0 . in this scenario this test case invalid . every time when you arrived a next station your tank is empty. \\n"
                    },
                    {
                        "username": "mudit_loya",
                        "content": "yes .. the solution is not unique .. even i have testcases where there many solutions"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "Isn\\'t this an invalid test case. It\\'s giving me invalid test case output."
                    },
                    {
                        "username": "jotho_",
                        "content": "There are more than one correct starting stations for that testcase, so it will be rejected."
                    },
                    {
                        "username": "aneesh1029",
                        "content": "You are starting from starting station at 0th index so return the first station possible"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "I think we need to return the smallest possible answer"
                    },
                    {
                        "username": "nishant7372",
                        "content": "I think all the system testcases have a unique answer."
                    },
                    {
                        "username": "banty",
                        "content": "This is not a rant, I genuinly want to know what is it that this problem trying to test so that I can practice it more and be better at it"
                    },
                    {
                        "username": "RB213",
                        "content": "This question is stupid, the language is so convoluted and examples are poor. But this situation does happen in real life when customers/product can\\'t express the problem clearly and engineers build poorly designed system. "
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "It is simply about problem solving skill + greedy technique i think"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "The problem does not state we want the smallest index as a result.\\n\\n[1,6,3,4,5]\\n[3,4,5,1,2]\\n\\nSo, why the answer 3 is not accpeted for the above test case ??\\n"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "The question mentions that the answer is unique. Your test case has two answers. Hence, the wrong one."
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question is very confusing. "
                    },
                    {
                        "username": "pavankumar",
                        "content": "Hi all,\\nI've written the code in suchaway that my solution validates all possible starting positions. I know that this is a very inefficient code to find the solution and finally i got time limit exceeded. can anybody give suggestions on how to solve this in an efficient way. I don't need code  but logic fine.\\n\\nThanks\\npavan kumar"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I know this comment is now almost a decade old at this point but here\\'s what I did. Try keeping track of the difference between the gas and cost as that\\'s what really matters for the problem. You might have to look when to avoid (hint the value will be negative so you can\\'t reach that place anyways). Here\\'s an example:\\n```[1,2,3,4,5] gas\\n[3,4,5,1,2] cost\\n[-2,-2,-2,3,3] -> difference between gas and cost (use variable instead of array for better space)\\n  0  1   2 3 4 -> index\\n```\\nthe net value till index 2 is negative (always -2 so we can ignore till there because it is not possible to move to the next point from these position.\\nfor index 3 this can be a possible answer. But what about having another net negative value in between (say -4)\\n```\\n[-2,-2,-2,3,-4,3]\\n```\\nwe can no longer use the index 3 now. But if you look closely we will find that for the above case it\\'s impossible to have a solution (output is -1). Reason is becase sum(gas)-sum(cost) is negative.\\nBut what for \\n```\\n[-2,-2,-2,3,-4,10]\\n```\\nHere we will keep track of the `minimum valid index`. Since, the answer is unique we can have only 1 valid index. Hence, using a Integer.MAX_VALUE as the initial answer and choosing the min and reassigning it to Integer.MAX_VALUE when the initially possible valid index (the index 3 in this case) is incorrect answer.\\n\\nLink to code: https://leetcode.com/problems/gas-station/solutions/3012347/easy-python-solution/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`The most unbelievable thing about this question isn\\'t that the car has unlimited gas tank, but the fact that I have got money to pay for it`"
                    },
                    {
                        "username": "pushpit_singh",
                        "content": "Us bhai Us"
                    },
                    {
                        "username": "dileep9259",
                        "content": "wah !!! :P\\n"
                    }
                ]
            },
            {
                "id": 1745609,
                "content": [
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan anyone please explain with giving some examples also to make it clear what is asked? thanks"
                    },
                    {
                        "username": "LOVEGURU",
                        "content": "Gas is gas station, Cost is amount of gas required to travel from i to i+1 station. we need to find index .From that we can complete the journey if we do not find index return -1.\\nour main agenda is find index we can travel from i to n-1 in the circular way"
                    },
                    {
                        "username": "Joseph86",
                        "content": "[@calm27](/calm27) I was in 5th grade in 2015 :0"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "whoa..  ancient comments were full of respect and gratitude!"
                    },
                    {
                        "username": "calm27",
                        "content": "[@heisenberg280](/heisenberg280) no way 2015 was 8 years ago, mate. no way "
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "[@heisenberg280](/heisenberg280)  \\uD83D\\uDE02\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Msey",
                        "content": "[@heisenberg280](/heisenberg280) or not and gave up :)"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@studcoder569](/studcoder569) Jul 29, 2015"
                    },
                    {
                        "username": "studcoder569",
                        "content": "[@heisenberg280](/heisenberg280) Good point lol"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "[@heisenberg280](/heisenberg280) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@studcoder569](/studcoder569) love your dedication but after 8 long years she might have understood the question by now :)"
                    },
                    {
                        "username": "studcoder569",
                        "content": "The question is asking you to find a starting gas station on the circuit that will allow you to complete one round trip without running out of gas. It is possible for there to be no solution. If there is a solution, the test cases are written such that it is unique. The examples shown in the description illustrate how the road trip would work. "
                    },
                    {
                        "username": "dadick",
                        "content": "Hint: if you start from station `a` and stuck at `b`, then you can't get to `b` from any station between `a` and `b`."
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) at position a we are getting some positive value \"y\" and from a to b we are adding some \"x\"  ..so if x+y cant cross b then obviously x alone cant cross b....... in your case we can reach to position 2 but cant cross it"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) reached to position to 2 but we cant reach to next position ..\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "what if ,gas={2,3,1,5} cost={1,2,4,3} i start at station 0 and reach station 2, and get stuck there, but i can start at station 1 and reach station 2, so your hint is proved wrong successfully "
                    },
                    {
                        "username": "khan60939",
                        "content": "[@mimirave](/mimirave) same confusion"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Bye bye TLE \\uD83D\\uDC4B"
                    },
                    {
                        "username": "mimirave",
                        "content": "Am I misunderstanding this hint?: If I start at station 0, successfully get to station 1, successfully get to station 2 but cannot complete the trip to station 3, then I am stuck at station 2 and the hint says that I cannot get to station 2 from station 1.  "
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "thanks! overcame TLE"
                    },
                    {
                        "username": "Jayasurya_K",
                        "content": "Thanks Buddy! TLE cracked..!"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "Thanks! TLE eliminator hint"
                    },
                    {
                        "username": "vanchanr",
                        "content": "good one !"
                    },
                    {
                        "username": "huanpipt",
                        "content": "Overcome TLE with this tip :) "
                    },
                    {
                        "username": "w286432531",
                        "content": "Thanks. I went from TLE to accepted with this hint."
                    },
                    {
                        "username": "CourteousCoder",
                        "content": "In order to prepare for an interview, it is more important that I am able to recognized the pattern in this problem.\\n\\nCan someone please help me identify the pattern of this problem?\\n\\nIs this a variation of a classic problem in Computer Science?\\nIf so, which?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of those problems that don\\'t fall under any category. It simply is just understanding the problem and utilizing problem solving"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "so how was your interview\\n"
                    },
                    {
                        "username": "kardopaska",
                        "content": "This is a classic problem of misdirection.  Description clearly states that valid answers include travel in clockwise direction only!  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "yueyunpeng",
                        "content": "I solved it with a two pass algorithm fairly quickly, the idea is:\\n\\n1. First just assum the gas tank can fall below zero, complete a loop starting at position 0, and record the index with lowest amount of gas (possibly negative) in tank, call it `lowest_idx`.\\n\\n2. Complete a loop starting from `lowest_idx`, break and return `-1` if the tank falls below zero at any point. Return `lowest_idx` if it never fell below zero.\\n\\nSure it\\'s not one pass, but extremely easy to understand, guarantees to be O(N) time and O(1) space, and did pass all tests. Am I missing anything?"
                    },
                    {
                        "username": "ggx94",
                        "content": "[@Kaltu](/Kaltu) I think they have tried to fix it (test case 39/40 for me...) but there is still a bug. The solution is still not unique,"
                    },
                    {
                        "username": "crazytan",
                        "content": "What if there are multiple indices with lowest amount of gas?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "There is a bug in the testcase `gas=[2,1,0,0]`, `cost=[0,1,0,0]`, the problem statement says the solution is unique but start from every index can complete the circuit\\nThe system can detect duplicated solution if we rotate the pairs by 1 to `gas=[0,2,1,0]`, `cost=[0,0,1,0]`, then it says \"Invalid Testcase\" \"The answer should be unique.\"\\n\\nBefore LeetCode remove this bugged testcase, be sure to account this.\\nFor example, when computing lowest_idx, make sure you keep updating it when ever the lowest gas tank are hit, so we can skip the [0, 0] gas/cost pairs"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": " int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "NishantGautam",
                        "content": "[@Yue Yunpeng](/yueyunpeng) how did you arrive at the thinking that I have to start at the station with lowest amount of gas."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Trick to solve circular path problems: Explains in under three minutes:\\nhttps://youtu.be/IEnJSIOOtOg"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "[@er_sushant](/er_sushant)  we can move forward onle if gas>0 so we should always keep this in mind.so,if(gas<=0)break; we can\\'t move further"
                    },
                    {
                        "username": "er_sushant",
                        "content": "[@abhi098](/abhi098) we can guarantee at the last station when `gas >= 0`, this means there is enough gas to make one circular circuit atleast once. if we found `gas < 0`, in any of the station, means we don\\'t have enough gas to move to next station.\\nAlso try various test cases for better understanding."
                    },
                    {
                        "username": "abhi098",
                        "content": "[@jobless_lm10](/jobless_lm10) how can you guarentee that when gas >0 at the last station, you can complete the whole circle from where you start ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "no need to do second pass. If gas remaining at the end of first pass is less than 0 then we can never go round all stations from any station. Otherwise we can go round all from lowest_idx + 1."
                    },
                    {
                        "username": "evidem64",
                        "content": "Problem description states:\\n> If there exists a solution, it is guaranteed to be unique\\n\\nOn submission my solution fails for the following case:\\n> [1,2,3,4,5,6,7,8]\\n> [1,2,3,4,5,6,7,8]\\n\\nClearly, there IS a solution, but it\\'s NOT unique, since\\nyou can start at any of the stations.\\nExpected answer is 0 though, anything else gets rejected.\\n"
                    },
                    {
                        "username": "emil_i_lonneberga",
                        "content": "Another test case that failed to satisfy the uniqueness is gas = [2, 0, 0, 0, ..., 0], cost =[0, 1, 0, 0, ..., 0]. If the test cases cannot be guaranteed to be unique, then additional restrictions like finding the minimum of all viable starting index should be placed. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@nishant7372](/nishant7372) `gas=[2,1,0,0, .... ,0,0]`, `cost=[0,1,0,0, .... ,0,0]` This one is a system testcase, the expected answer is `0` but we can clearly see that every index is actually valid.\nAND, if we rotate it by 1 to `gas=[0,2,1,0,0, .... ,0]`, `cost=[0,0,1,0,0, .... ,0]` as a custom testcase, the system now complains it has non-unique answer.\nThe problem is a circular problem, simply shifting the index in the array representation should not make any difference."
                    },
                    {
                        "username": "labbiahmed",
                        "content": "only one time tank == 0 . in this scenario this test case invalid . every time when you arrived a next station your tank is empty. \\n"
                    },
                    {
                        "username": "mudit_loya",
                        "content": "yes .. the solution is not unique .. even i have testcases where there many solutions"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "Isn\\'t this an invalid test case. It\\'s giving me invalid test case output."
                    },
                    {
                        "username": "jotho_",
                        "content": "There are more than one correct starting stations for that testcase, so it will be rejected."
                    },
                    {
                        "username": "aneesh1029",
                        "content": "You are starting from starting station at 0th index so return the first station possible"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "I think we need to return the smallest possible answer"
                    },
                    {
                        "username": "nishant7372",
                        "content": "I think all the system testcases have a unique answer."
                    },
                    {
                        "username": "banty",
                        "content": "This is not a rant, I genuinly want to know what is it that this problem trying to test so that I can practice it more and be better at it"
                    },
                    {
                        "username": "RB213",
                        "content": "This question is stupid, the language is so convoluted and examples are poor. But this situation does happen in real life when customers/product can\\'t express the problem clearly and engineers build poorly designed system. "
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "It is simply about problem solving skill + greedy technique i think"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "The problem does not state we want the smallest index as a result.\\n\\n[1,6,3,4,5]\\n[3,4,5,1,2]\\n\\nSo, why the answer 3 is not accpeted for the above test case ??\\n"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "The question mentions that the answer is unique. Your test case has two answers. Hence, the wrong one."
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question is very confusing. "
                    },
                    {
                        "username": "pavankumar",
                        "content": "Hi all,\\nI've written the code in suchaway that my solution validates all possible starting positions. I know that this is a very inefficient code to find the solution and finally i got time limit exceeded. can anybody give suggestions on how to solve this in an efficient way. I don't need code  but logic fine.\\n\\nThanks\\npavan kumar"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I know this comment is now almost a decade old at this point but here\\'s what I did. Try keeping track of the difference between the gas and cost as that\\'s what really matters for the problem. You might have to look when to avoid (hint the value will be negative so you can\\'t reach that place anyways). Here\\'s an example:\\n```[1,2,3,4,5] gas\\n[3,4,5,1,2] cost\\n[-2,-2,-2,3,3] -> difference between gas and cost (use variable instead of array for better space)\\n  0  1   2 3 4 -> index\\n```\\nthe net value till index 2 is negative (always -2 so we can ignore till there because it is not possible to move to the next point from these position.\\nfor index 3 this can be a possible answer. But what about having another net negative value in between (say -4)\\n```\\n[-2,-2,-2,3,-4,3]\\n```\\nwe can no longer use the index 3 now. But if you look closely we will find that for the above case it\\'s impossible to have a solution (output is -1). Reason is becase sum(gas)-sum(cost) is negative.\\nBut what for \\n```\\n[-2,-2,-2,3,-4,10]\\n```\\nHere we will keep track of the `minimum valid index`. Since, the answer is unique we can have only 1 valid index. Hence, using a Integer.MAX_VALUE as the initial answer and choosing the min and reassigning it to Integer.MAX_VALUE when the initially possible valid index (the index 3 in this case) is incorrect answer.\\n\\nLink to code: https://leetcode.com/problems/gas-station/solutions/3012347/easy-python-solution/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`The most unbelievable thing about this question isn\\'t that the car has unlimited gas tank, but the fact that I have got money to pay for it`"
                    },
                    {
                        "username": "pushpit_singh",
                        "content": "Us bhai Us"
                    },
                    {
                        "username": "dileep9259",
                        "content": "wah !!! :P\\n"
                    }
                ]
            },
            {
                "id": 1572282,
                "content": [
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan anyone please explain with giving some examples also to make it clear what is asked? thanks"
                    },
                    {
                        "username": "LOVEGURU",
                        "content": "Gas is gas station, Cost is amount of gas required to travel from i to i+1 station. we need to find index .From that we can complete the journey if we do not find index return -1.\\nour main agenda is find index we can travel from i to n-1 in the circular way"
                    },
                    {
                        "username": "Joseph86",
                        "content": "[@calm27](/calm27) I was in 5th grade in 2015 :0"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "whoa..  ancient comments were full of respect and gratitude!"
                    },
                    {
                        "username": "calm27",
                        "content": "[@heisenberg280](/heisenberg280) no way 2015 was 8 years ago, mate. no way "
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "[@heisenberg280](/heisenberg280)  \\uD83D\\uDE02\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Msey",
                        "content": "[@heisenberg280](/heisenberg280) or not and gave up :)"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@studcoder569](/studcoder569) Jul 29, 2015"
                    },
                    {
                        "username": "studcoder569",
                        "content": "[@heisenberg280](/heisenberg280) Good point lol"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "[@heisenberg280](/heisenberg280) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@studcoder569](/studcoder569) love your dedication but after 8 long years she might have understood the question by now :)"
                    },
                    {
                        "username": "studcoder569",
                        "content": "The question is asking you to find a starting gas station on the circuit that will allow you to complete one round trip without running out of gas. It is possible for there to be no solution. If there is a solution, the test cases are written such that it is unique. The examples shown in the description illustrate how the road trip would work. "
                    },
                    {
                        "username": "dadick",
                        "content": "Hint: if you start from station `a` and stuck at `b`, then you can't get to `b` from any station between `a` and `b`."
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) at position a we are getting some positive value \"y\" and from a to b we are adding some \"x\"  ..so if x+y cant cross b then obviously x alone cant cross b....... in your case we can reach to position 2 but cant cross it"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) reached to position to 2 but we cant reach to next position ..\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "what if ,gas={2,3,1,5} cost={1,2,4,3} i start at station 0 and reach station 2, and get stuck there, but i can start at station 1 and reach station 2, so your hint is proved wrong successfully "
                    },
                    {
                        "username": "khan60939",
                        "content": "[@mimirave](/mimirave) same confusion"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Bye bye TLE \\uD83D\\uDC4B"
                    },
                    {
                        "username": "mimirave",
                        "content": "Am I misunderstanding this hint?: If I start at station 0, successfully get to station 1, successfully get to station 2 but cannot complete the trip to station 3, then I am stuck at station 2 and the hint says that I cannot get to station 2 from station 1.  "
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "thanks! overcame TLE"
                    },
                    {
                        "username": "Jayasurya_K",
                        "content": "Thanks Buddy! TLE cracked..!"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "Thanks! TLE eliminator hint"
                    },
                    {
                        "username": "vanchanr",
                        "content": "good one !"
                    },
                    {
                        "username": "huanpipt",
                        "content": "Overcome TLE with this tip :) "
                    },
                    {
                        "username": "w286432531",
                        "content": "Thanks. I went from TLE to accepted with this hint."
                    },
                    {
                        "username": "CourteousCoder",
                        "content": "In order to prepare for an interview, it is more important that I am able to recognized the pattern in this problem.\\n\\nCan someone please help me identify the pattern of this problem?\\n\\nIs this a variation of a classic problem in Computer Science?\\nIf so, which?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of those problems that don\\'t fall under any category. It simply is just understanding the problem and utilizing problem solving"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "so how was your interview\\n"
                    },
                    {
                        "username": "kardopaska",
                        "content": "This is a classic problem of misdirection.  Description clearly states that valid answers include travel in clockwise direction only!  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "yueyunpeng",
                        "content": "I solved it with a two pass algorithm fairly quickly, the idea is:\\n\\n1. First just assum the gas tank can fall below zero, complete a loop starting at position 0, and record the index with lowest amount of gas (possibly negative) in tank, call it `lowest_idx`.\\n\\n2. Complete a loop starting from `lowest_idx`, break and return `-1` if the tank falls below zero at any point. Return `lowest_idx` if it never fell below zero.\\n\\nSure it\\'s not one pass, but extremely easy to understand, guarantees to be O(N) time and O(1) space, and did pass all tests. Am I missing anything?"
                    },
                    {
                        "username": "ggx94",
                        "content": "[@Kaltu](/Kaltu) I think they have tried to fix it (test case 39/40 for me...) but there is still a bug. The solution is still not unique,"
                    },
                    {
                        "username": "crazytan",
                        "content": "What if there are multiple indices with lowest amount of gas?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "There is a bug in the testcase `gas=[2,1,0,0]`, `cost=[0,1,0,0]`, the problem statement says the solution is unique but start from every index can complete the circuit\\nThe system can detect duplicated solution if we rotate the pairs by 1 to `gas=[0,2,1,0]`, `cost=[0,0,1,0]`, then it says \"Invalid Testcase\" \"The answer should be unique.\"\\n\\nBefore LeetCode remove this bugged testcase, be sure to account this.\\nFor example, when computing lowest_idx, make sure you keep updating it when ever the lowest gas tank are hit, so we can skip the [0, 0] gas/cost pairs"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": " int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "NishantGautam",
                        "content": "[@Yue Yunpeng](/yueyunpeng) how did you arrive at the thinking that I have to start at the station with lowest amount of gas."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Trick to solve circular path problems: Explains in under three minutes:\\nhttps://youtu.be/IEnJSIOOtOg"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "[@er_sushant](/er_sushant)  we can move forward onle if gas>0 so we should always keep this in mind.so,if(gas<=0)break; we can\\'t move further"
                    },
                    {
                        "username": "er_sushant",
                        "content": "[@abhi098](/abhi098) we can guarantee at the last station when `gas >= 0`, this means there is enough gas to make one circular circuit atleast once. if we found `gas < 0`, in any of the station, means we don\\'t have enough gas to move to next station.\\nAlso try various test cases for better understanding."
                    },
                    {
                        "username": "abhi098",
                        "content": "[@jobless_lm10](/jobless_lm10) how can you guarentee that when gas >0 at the last station, you can complete the whole circle from where you start ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "no need to do second pass. If gas remaining at the end of first pass is less than 0 then we can never go round all stations from any station. Otherwise we can go round all from lowest_idx + 1."
                    },
                    {
                        "username": "evidem64",
                        "content": "Problem description states:\\n> If there exists a solution, it is guaranteed to be unique\\n\\nOn submission my solution fails for the following case:\\n> [1,2,3,4,5,6,7,8]\\n> [1,2,3,4,5,6,7,8]\\n\\nClearly, there IS a solution, but it\\'s NOT unique, since\\nyou can start at any of the stations.\\nExpected answer is 0 though, anything else gets rejected.\\n"
                    },
                    {
                        "username": "emil_i_lonneberga",
                        "content": "Another test case that failed to satisfy the uniqueness is gas = [2, 0, 0, 0, ..., 0], cost =[0, 1, 0, 0, ..., 0]. If the test cases cannot be guaranteed to be unique, then additional restrictions like finding the minimum of all viable starting index should be placed. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@nishant7372](/nishant7372) `gas=[2,1,0,0, .... ,0,0]`, `cost=[0,1,0,0, .... ,0,0]` This one is a system testcase, the expected answer is `0` but we can clearly see that every index is actually valid.\nAND, if we rotate it by 1 to `gas=[0,2,1,0,0, .... ,0]`, `cost=[0,0,1,0,0, .... ,0]` as a custom testcase, the system now complains it has non-unique answer.\nThe problem is a circular problem, simply shifting the index in the array representation should not make any difference."
                    },
                    {
                        "username": "labbiahmed",
                        "content": "only one time tank == 0 . in this scenario this test case invalid . every time when you arrived a next station your tank is empty. \\n"
                    },
                    {
                        "username": "mudit_loya",
                        "content": "yes .. the solution is not unique .. even i have testcases where there many solutions"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "Isn\\'t this an invalid test case. It\\'s giving me invalid test case output."
                    },
                    {
                        "username": "jotho_",
                        "content": "There are more than one correct starting stations for that testcase, so it will be rejected."
                    },
                    {
                        "username": "aneesh1029",
                        "content": "You are starting from starting station at 0th index so return the first station possible"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "I think we need to return the smallest possible answer"
                    },
                    {
                        "username": "nishant7372",
                        "content": "I think all the system testcases have a unique answer."
                    },
                    {
                        "username": "banty",
                        "content": "This is not a rant, I genuinly want to know what is it that this problem trying to test so that I can practice it more and be better at it"
                    },
                    {
                        "username": "RB213",
                        "content": "This question is stupid, the language is so convoluted and examples are poor. But this situation does happen in real life when customers/product can\\'t express the problem clearly and engineers build poorly designed system. "
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "It is simply about problem solving skill + greedy technique i think"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "The problem does not state we want the smallest index as a result.\\n\\n[1,6,3,4,5]\\n[3,4,5,1,2]\\n\\nSo, why the answer 3 is not accpeted for the above test case ??\\n"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "The question mentions that the answer is unique. Your test case has two answers. Hence, the wrong one."
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question is very confusing. "
                    },
                    {
                        "username": "pavankumar",
                        "content": "Hi all,\\nI've written the code in suchaway that my solution validates all possible starting positions. I know that this is a very inefficient code to find the solution and finally i got time limit exceeded. can anybody give suggestions on how to solve this in an efficient way. I don't need code  but logic fine.\\n\\nThanks\\npavan kumar"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I know this comment is now almost a decade old at this point but here\\'s what I did. Try keeping track of the difference between the gas and cost as that\\'s what really matters for the problem. You might have to look when to avoid (hint the value will be negative so you can\\'t reach that place anyways). Here\\'s an example:\\n```[1,2,3,4,5] gas\\n[3,4,5,1,2] cost\\n[-2,-2,-2,3,3] -> difference between gas and cost (use variable instead of array for better space)\\n  0  1   2 3 4 -> index\\n```\\nthe net value till index 2 is negative (always -2 so we can ignore till there because it is not possible to move to the next point from these position.\\nfor index 3 this can be a possible answer. But what about having another net negative value in between (say -4)\\n```\\n[-2,-2,-2,3,-4,3]\\n```\\nwe can no longer use the index 3 now. But if you look closely we will find that for the above case it\\'s impossible to have a solution (output is -1). Reason is becase sum(gas)-sum(cost) is negative.\\nBut what for \\n```\\n[-2,-2,-2,3,-4,10]\\n```\\nHere we will keep track of the `minimum valid index`. Since, the answer is unique we can have only 1 valid index. Hence, using a Integer.MAX_VALUE as the initial answer and choosing the min and reassigning it to Integer.MAX_VALUE when the initially possible valid index (the index 3 in this case) is incorrect answer.\\n\\nLink to code: https://leetcode.com/problems/gas-station/solutions/3012347/easy-python-solution/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`The most unbelievable thing about this question isn\\'t that the car has unlimited gas tank, but the fact that I have got money to pay for it`"
                    },
                    {
                        "username": "pushpit_singh",
                        "content": "Us bhai Us"
                    },
                    {
                        "username": "dileep9259",
                        "content": "wah !!! :P\\n"
                    }
                ]
            },
            {
                "id": 1574644,
                "content": [
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan anyone please explain with giving some examples also to make it clear what is asked? thanks"
                    },
                    {
                        "username": "LOVEGURU",
                        "content": "Gas is gas station, Cost is amount of gas required to travel from i to i+1 station. we need to find index .From that we can complete the journey if we do not find index return -1.\\nour main agenda is find index we can travel from i to n-1 in the circular way"
                    },
                    {
                        "username": "Joseph86",
                        "content": "[@calm27](/calm27) I was in 5th grade in 2015 :0"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "whoa..  ancient comments were full of respect and gratitude!"
                    },
                    {
                        "username": "calm27",
                        "content": "[@heisenberg280](/heisenberg280) no way 2015 was 8 years ago, mate. no way "
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "[@heisenberg280](/heisenberg280)  \\uD83D\\uDE02\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Msey",
                        "content": "[@heisenberg280](/heisenberg280) or not and gave up :)"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@studcoder569](/studcoder569) Jul 29, 2015"
                    },
                    {
                        "username": "studcoder569",
                        "content": "[@heisenberg280](/heisenberg280) Good point lol"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "[@heisenberg280](/heisenberg280) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@studcoder569](/studcoder569) love your dedication but after 8 long years she might have understood the question by now :)"
                    },
                    {
                        "username": "studcoder569",
                        "content": "The question is asking you to find a starting gas station on the circuit that will allow you to complete one round trip without running out of gas. It is possible for there to be no solution. If there is a solution, the test cases are written such that it is unique. The examples shown in the description illustrate how the road trip would work. "
                    },
                    {
                        "username": "dadick",
                        "content": "Hint: if you start from station `a` and stuck at `b`, then you can't get to `b` from any station between `a` and `b`."
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) at position a we are getting some positive value \"y\" and from a to b we are adding some \"x\"  ..so if x+y cant cross b then obviously x alone cant cross b....... in your case we can reach to position 2 but cant cross it"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) reached to position to 2 but we cant reach to next position ..\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "what if ,gas={2,3,1,5} cost={1,2,4,3} i start at station 0 and reach station 2, and get stuck there, but i can start at station 1 and reach station 2, so your hint is proved wrong successfully "
                    },
                    {
                        "username": "khan60939",
                        "content": "[@mimirave](/mimirave) same confusion"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Bye bye TLE \\uD83D\\uDC4B"
                    },
                    {
                        "username": "mimirave",
                        "content": "Am I misunderstanding this hint?: If I start at station 0, successfully get to station 1, successfully get to station 2 but cannot complete the trip to station 3, then I am stuck at station 2 and the hint says that I cannot get to station 2 from station 1.  "
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "thanks! overcame TLE"
                    },
                    {
                        "username": "Jayasurya_K",
                        "content": "Thanks Buddy! TLE cracked..!"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "Thanks! TLE eliminator hint"
                    },
                    {
                        "username": "vanchanr",
                        "content": "good one !"
                    },
                    {
                        "username": "huanpipt",
                        "content": "Overcome TLE with this tip :) "
                    },
                    {
                        "username": "w286432531",
                        "content": "Thanks. I went from TLE to accepted with this hint."
                    },
                    {
                        "username": "CourteousCoder",
                        "content": "In order to prepare for an interview, it is more important that I am able to recognized the pattern in this problem.\\n\\nCan someone please help me identify the pattern of this problem?\\n\\nIs this a variation of a classic problem in Computer Science?\\nIf so, which?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of those problems that don\\'t fall under any category. It simply is just understanding the problem and utilizing problem solving"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "so how was your interview\\n"
                    },
                    {
                        "username": "kardopaska",
                        "content": "This is a classic problem of misdirection.  Description clearly states that valid answers include travel in clockwise direction only!  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "yueyunpeng",
                        "content": "I solved it with a two pass algorithm fairly quickly, the idea is:\\n\\n1. First just assum the gas tank can fall below zero, complete a loop starting at position 0, and record the index with lowest amount of gas (possibly negative) in tank, call it `lowest_idx`.\\n\\n2. Complete a loop starting from `lowest_idx`, break and return `-1` if the tank falls below zero at any point. Return `lowest_idx` if it never fell below zero.\\n\\nSure it\\'s not one pass, but extremely easy to understand, guarantees to be O(N) time and O(1) space, and did pass all tests. Am I missing anything?"
                    },
                    {
                        "username": "ggx94",
                        "content": "[@Kaltu](/Kaltu) I think they have tried to fix it (test case 39/40 for me...) but there is still a bug. The solution is still not unique,"
                    },
                    {
                        "username": "crazytan",
                        "content": "What if there are multiple indices with lowest amount of gas?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "There is a bug in the testcase `gas=[2,1,0,0]`, `cost=[0,1,0,0]`, the problem statement says the solution is unique but start from every index can complete the circuit\\nThe system can detect duplicated solution if we rotate the pairs by 1 to `gas=[0,2,1,0]`, `cost=[0,0,1,0]`, then it says \"Invalid Testcase\" \"The answer should be unique.\"\\n\\nBefore LeetCode remove this bugged testcase, be sure to account this.\\nFor example, when computing lowest_idx, make sure you keep updating it when ever the lowest gas tank are hit, so we can skip the [0, 0] gas/cost pairs"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": " int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "NishantGautam",
                        "content": "[@Yue Yunpeng](/yueyunpeng) how did you arrive at the thinking that I have to start at the station with lowest amount of gas."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Trick to solve circular path problems: Explains in under three minutes:\\nhttps://youtu.be/IEnJSIOOtOg"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "[@er_sushant](/er_sushant)  we can move forward onle if gas>0 so we should always keep this in mind.so,if(gas<=0)break; we can\\'t move further"
                    },
                    {
                        "username": "er_sushant",
                        "content": "[@abhi098](/abhi098) we can guarantee at the last station when `gas >= 0`, this means there is enough gas to make one circular circuit atleast once. if we found `gas < 0`, in any of the station, means we don\\'t have enough gas to move to next station.\\nAlso try various test cases for better understanding."
                    },
                    {
                        "username": "abhi098",
                        "content": "[@jobless_lm10](/jobless_lm10) how can you guarentee that when gas >0 at the last station, you can complete the whole circle from where you start ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "no need to do second pass. If gas remaining at the end of first pass is less than 0 then we can never go round all stations from any station. Otherwise we can go round all from lowest_idx + 1."
                    },
                    {
                        "username": "evidem64",
                        "content": "Problem description states:\\n> If there exists a solution, it is guaranteed to be unique\\n\\nOn submission my solution fails for the following case:\\n> [1,2,3,4,5,6,7,8]\\n> [1,2,3,4,5,6,7,8]\\n\\nClearly, there IS a solution, but it\\'s NOT unique, since\\nyou can start at any of the stations.\\nExpected answer is 0 though, anything else gets rejected.\\n"
                    },
                    {
                        "username": "emil_i_lonneberga",
                        "content": "Another test case that failed to satisfy the uniqueness is gas = [2, 0, 0, 0, ..., 0], cost =[0, 1, 0, 0, ..., 0]. If the test cases cannot be guaranteed to be unique, then additional restrictions like finding the minimum of all viable starting index should be placed. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@nishant7372](/nishant7372) `gas=[2,1,0,0, .... ,0,0]`, `cost=[0,1,0,0, .... ,0,0]` This one is a system testcase, the expected answer is `0` but we can clearly see that every index is actually valid.\nAND, if we rotate it by 1 to `gas=[0,2,1,0,0, .... ,0]`, `cost=[0,0,1,0,0, .... ,0]` as a custom testcase, the system now complains it has non-unique answer.\nThe problem is a circular problem, simply shifting the index in the array representation should not make any difference."
                    },
                    {
                        "username": "labbiahmed",
                        "content": "only one time tank == 0 . in this scenario this test case invalid . every time when you arrived a next station your tank is empty. \\n"
                    },
                    {
                        "username": "mudit_loya",
                        "content": "yes .. the solution is not unique .. even i have testcases where there many solutions"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "Isn\\'t this an invalid test case. It\\'s giving me invalid test case output."
                    },
                    {
                        "username": "jotho_",
                        "content": "There are more than one correct starting stations for that testcase, so it will be rejected."
                    },
                    {
                        "username": "aneesh1029",
                        "content": "You are starting from starting station at 0th index so return the first station possible"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "I think we need to return the smallest possible answer"
                    },
                    {
                        "username": "nishant7372",
                        "content": "I think all the system testcases have a unique answer."
                    },
                    {
                        "username": "banty",
                        "content": "This is not a rant, I genuinly want to know what is it that this problem trying to test so that I can practice it more and be better at it"
                    },
                    {
                        "username": "RB213",
                        "content": "This question is stupid, the language is so convoluted and examples are poor. But this situation does happen in real life when customers/product can\\'t express the problem clearly and engineers build poorly designed system. "
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "It is simply about problem solving skill + greedy technique i think"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "The problem does not state we want the smallest index as a result.\\n\\n[1,6,3,4,5]\\n[3,4,5,1,2]\\n\\nSo, why the answer 3 is not accpeted for the above test case ??\\n"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "The question mentions that the answer is unique. Your test case has two answers. Hence, the wrong one."
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question is very confusing. "
                    },
                    {
                        "username": "pavankumar",
                        "content": "Hi all,\\nI've written the code in suchaway that my solution validates all possible starting positions. I know that this is a very inefficient code to find the solution and finally i got time limit exceeded. can anybody give suggestions on how to solve this in an efficient way. I don't need code  but logic fine.\\n\\nThanks\\npavan kumar"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I know this comment is now almost a decade old at this point but here\\'s what I did. Try keeping track of the difference between the gas and cost as that\\'s what really matters for the problem. You might have to look when to avoid (hint the value will be negative so you can\\'t reach that place anyways). Here\\'s an example:\\n```[1,2,3,4,5] gas\\n[3,4,5,1,2] cost\\n[-2,-2,-2,3,3] -> difference between gas and cost (use variable instead of array for better space)\\n  0  1   2 3 4 -> index\\n```\\nthe net value till index 2 is negative (always -2 so we can ignore till there because it is not possible to move to the next point from these position.\\nfor index 3 this can be a possible answer. But what about having another net negative value in between (say -4)\\n```\\n[-2,-2,-2,3,-4,3]\\n```\\nwe can no longer use the index 3 now. But if you look closely we will find that for the above case it\\'s impossible to have a solution (output is -1). Reason is becase sum(gas)-sum(cost) is negative.\\nBut what for \\n```\\n[-2,-2,-2,3,-4,10]\\n```\\nHere we will keep track of the `minimum valid index`. Since, the answer is unique we can have only 1 valid index. Hence, using a Integer.MAX_VALUE as the initial answer and choosing the min and reassigning it to Integer.MAX_VALUE when the initially possible valid index (the index 3 in this case) is incorrect answer.\\n\\nLink to code: https://leetcode.com/problems/gas-station/solutions/3012347/easy-python-solution/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`The most unbelievable thing about this question isn\\'t that the car has unlimited gas tank, but the fact that I have got money to pay for it`"
                    },
                    {
                        "username": "pushpit_singh",
                        "content": "Us bhai Us"
                    },
                    {
                        "username": "dileep9259",
                        "content": "wah !!! :P\\n"
                    }
                ]
            },
            {
                "id": 1570784,
                "content": [
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan anyone please explain with giving some examples also to make it clear what is asked? thanks"
                    },
                    {
                        "username": "LOVEGURU",
                        "content": "Gas is gas station, Cost is amount of gas required to travel from i to i+1 station. we need to find index .From that we can complete the journey if we do not find index return -1.\\nour main agenda is find index we can travel from i to n-1 in the circular way"
                    },
                    {
                        "username": "Joseph86",
                        "content": "[@calm27](/calm27) I was in 5th grade in 2015 :0"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "whoa..  ancient comments were full of respect and gratitude!"
                    },
                    {
                        "username": "calm27",
                        "content": "[@heisenberg280](/heisenberg280) no way 2015 was 8 years ago, mate. no way "
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "[@heisenberg280](/heisenberg280)  \\uD83D\\uDE02\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Msey",
                        "content": "[@heisenberg280](/heisenberg280) or not and gave up :)"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@studcoder569](/studcoder569) Jul 29, 2015"
                    },
                    {
                        "username": "studcoder569",
                        "content": "[@heisenberg280](/heisenberg280) Good point lol"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "[@heisenberg280](/heisenberg280) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@studcoder569](/studcoder569) love your dedication but after 8 long years she might have understood the question by now :)"
                    },
                    {
                        "username": "studcoder569",
                        "content": "The question is asking you to find a starting gas station on the circuit that will allow you to complete one round trip without running out of gas. It is possible for there to be no solution. If there is a solution, the test cases are written such that it is unique. The examples shown in the description illustrate how the road trip would work. "
                    },
                    {
                        "username": "dadick",
                        "content": "Hint: if you start from station `a` and stuck at `b`, then you can't get to `b` from any station between `a` and `b`."
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) at position a we are getting some positive value \"y\" and from a to b we are adding some \"x\"  ..so if x+y cant cross b then obviously x alone cant cross b....... in your case we can reach to position 2 but cant cross it"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) reached to position to 2 but we cant reach to next position ..\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "what if ,gas={2,3,1,5} cost={1,2,4,3} i start at station 0 and reach station 2, and get stuck there, but i can start at station 1 and reach station 2, so your hint is proved wrong successfully "
                    },
                    {
                        "username": "khan60939",
                        "content": "[@mimirave](/mimirave) same confusion"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Bye bye TLE \\uD83D\\uDC4B"
                    },
                    {
                        "username": "mimirave",
                        "content": "Am I misunderstanding this hint?: If I start at station 0, successfully get to station 1, successfully get to station 2 but cannot complete the trip to station 3, then I am stuck at station 2 and the hint says that I cannot get to station 2 from station 1.  "
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "thanks! overcame TLE"
                    },
                    {
                        "username": "Jayasurya_K",
                        "content": "Thanks Buddy! TLE cracked..!"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "Thanks! TLE eliminator hint"
                    },
                    {
                        "username": "vanchanr",
                        "content": "good one !"
                    },
                    {
                        "username": "huanpipt",
                        "content": "Overcome TLE with this tip :) "
                    },
                    {
                        "username": "w286432531",
                        "content": "Thanks. I went from TLE to accepted with this hint."
                    },
                    {
                        "username": "CourteousCoder",
                        "content": "In order to prepare for an interview, it is more important that I am able to recognized the pattern in this problem.\\n\\nCan someone please help me identify the pattern of this problem?\\n\\nIs this a variation of a classic problem in Computer Science?\\nIf so, which?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of those problems that don\\'t fall under any category. It simply is just understanding the problem and utilizing problem solving"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "so how was your interview\\n"
                    },
                    {
                        "username": "kardopaska",
                        "content": "This is a classic problem of misdirection.  Description clearly states that valid answers include travel in clockwise direction only!  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "yueyunpeng",
                        "content": "I solved it with a two pass algorithm fairly quickly, the idea is:\\n\\n1. First just assum the gas tank can fall below zero, complete a loop starting at position 0, and record the index with lowest amount of gas (possibly negative) in tank, call it `lowest_idx`.\\n\\n2. Complete a loop starting from `lowest_idx`, break and return `-1` if the tank falls below zero at any point. Return `lowest_idx` if it never fell below zero.\\n\\nSure it\\'s not one pass, but extremely easy to understand, guarantees to be O(N) time and O(1) space, and did pass all tests. Am I missing anything?"
                    },
                    {
                        "username": "ggx94",
                        "content": "[@Kaltu](/Kaltu) I think they have tried to fix it (test case 39/40 for me...) but there is still a bug. The solution is still not unique,"
                    },
                    {
                        "username": "crazytan",
                        "content": "What if there are multiple indices with lowest amount of gas?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "There is a bug in the testcase `gas=[2,1,0,0]`, `cost=[0,1,0,0]`, the problem statement says the solution is unique but start from every index can complete the circuit\\nThe system can detect duplicated solution if we rotate the pairs by 1 to `gas=[0,2,1,0]`, `cost=[0,0,1,0]`, then it says \"Invalid Testcase\" \"The answer should be unique.\"\\n\\nBefore LeetCode remove this bugged testcase, be sure to account this.\\nFor example, when computing lowest_idx, make sure you keep updating it when ever the lowest gas tank are hit, so we can skip the [0, 0] gas/cost pairs"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": " int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "NishantGautam",
                        "content": "[@Yue Yunpeng](/yueyunpeng) how did you arrive at the thinking that I have to start at the station with lowest amount of gas."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Trick to solve circular path problems: Explains in under three minutes:\\nhttps://youtu.be/IEnJSIOOtOg"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "[@er_sushant](/er_sushant)  we can move forward onle if gas>0 so we should always keep this in mind.so,if(gas<=0)break; we can\\'t move further"
                    },
                    {
                        "username": "er_sushant",
                        "content": "[@abhi098](/abhi098) we can guarantee at the last station when `gas >= 0`, this means there is enough gas to make one circular circuit atleast once. if we found `gas < 0`, in any of the station, means we don\\'t have enough gas to move to next station.\\nAlso try various test cases for better understanding."
                    },
                    {
                        "username": "abhi098",
                        "content": "[@jobless_lm10](/jobless_lm10) how can you guarentee that when gas >0 at the last station, you can complete the whole circle from where you start ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "no need to do second pass. If gas remaining at the end of first pass is less than 0 then we can never go round all stations from any station. Otherwise we can go round all from lowest_idx + 1."
                    },
                    {
                        "username": "evidem64",
                        "content": "Problem description states:\\n> If there exists a solution, it is guaranteed to be unique\\n\\nOn submission my solution fails for the following case:\\n> [1,2,3,4,5,6,7,8]\\n> [1,2,3,4,5,6,7,8]\\n\\nClearly, there IS a solution, but it\\'s NOT unique, since\\nyou can start at any of the stations.\\nExpected answer is 0 though, anything else gets rejected.\\n"
                    },
                    {
                        "username": "emil_i_lonneberga",
                        "content": "Another test case that failed to satisfy the uniqueness is gas = [2, 0, 0, 0, ..., 0], cost =[0, 1, 0, 0, ..., 0]. If the test cases cannot be guaranteed to be unique, then additional restrictions like finding the minimum of all viable starting index should be placed. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@nishant7372](/nishant7372) `gas=[2,1,0,0, .... ,0,0]`, `cost=[0,1,0,0, .... ,0,0]` This one is a system testcase, the expected answer is `0` but we can clearly see that every index is actually valid.\nAND, if we rotate it by 1 to `gas=[0,2,1,0,0, .... ,0]`, `cost=[0,0,1,0,0, .... ,0]` as a custom testcase, the system now complains it has non-unique answer.\nThe problem is a circular problem, simply shifting the index in the array representation should not make any difference."
                    },
                    {
                        "username": "labbiahmed",
                        "content": "only one time tank == 0 . in this scenario this test case invalid . every time when you arrived a next station your tank is empty. \\n"
                    },
                    {
                        "username": "mudit_loya",
                        "content": "yes .. the solution is not unique .. even i have testcases where there many solutions"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "Isn\\'t this an invalid test case. It\\'s giving me invalid test case output."
                    },
                    {
                        "username": "jotho_",
                        "content": "There are more than one correct starting stations for that testcase, so it will be rejected."
                    },
                    {
                        "username": "aneesh1029",
                        "content": "You are starting from starting station at 0th index so return the first station possible"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "I think we need to return the smallest possible answer"
                    },
                    {
                        "username": "nishant7372",
                        "content": "I think all the system testcases have a unique answer."
                    },
                    {
                        "username": "banty",
                        "content": "This is not a rant, I genuinly want to know what is it that this problem trying to test so that I can practice it more and be better at it"
                    },
                    {
                        "username": "RB213",
                        "content": "This question is stupid, the language is so convoluted and examples are poor. But this situation does happen in real life when customers/product can\\'t express the problem clearly and engineers build poorly designed system. "
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "It is simply about problem solving skill + greedy technique i think"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "The problem does not state we want the smallest index as a result.\\n\\n[1,6,3,4,5]\\n[3,4,5,1,2]\\n\\nSo, why the answer 3 is not accpeted for the above test case ??\\n"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "The question mentions that the answer is unique. Your test case has two answers. Hence, the wrong one."
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question is very confusing. "
                    },
                    {
                        "username": "pavankumar",
                        "content": "Hi all,\\nI've written the code in suchaway that my solution validates all possible starting positions. I know that this is a very inefficient code to find the solution and finally i got time limit exceeded. can anybody give suggestions on how to solve this in an efficient way. I don't need code  but logic fine.\\n\\nThanks\\npavan kumar"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I know this comment is now almost a decade old at this point but here\\'s what I did. Try keeping track of the difference between the gas and cost as that\\'s what really matters for the problem. You might have to look when to avoid (hint the value will be negative so you can\\'t reach that place anyways). Here\\'s an example:\\n```[1,2,3,4,5] gas\\n[3,4,5,1,2] cost\\n[-2,-2,-2,3,3] -> difference between gas and cost (use variable instead of array for better space)\\n  0  1   2 3 4 -> index\\n```\\nthe net value till index 2 is negative (always -2 so we can ignore till there because it is not possible to move to the next point from these position.\\nfor index 3 this can be a possible answer. But what about having another net negative value in between (say -4)\\n```\\n[-2,-2,-2,3,-4,3]\\n```\\nwe can no longer use the index 3 now. But if you look closely we will find that for the above case it\\'s impossible to have a solution (output is -1). Reason is becase sum(gas)-sum(cost) is negative.\\nBut what for \\n```\\n[-2,-2,-2,3,-4,10]\\n```\\nHere we will keep track of the `minimum valid index`. Since, the answer is unique we can have only 1 valid index. Hence, using a Integer.MAX_VALUE as the initial answer and choosing the min and reassigning it to Integer.MAX_VALUE when the initially possible valid index (the index 3 in this case) is incorrect answer.\\n\\nLink to code: https://leetcode.com/problems/gas-station/solutions/3012347/easy-python-solution/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`The most unbelievable thing about this question isn\\'t that the car has unlimited gas tank, but the fact that I have got money to pay for it`"
                    },
                    {
                        "username": "pushpit_singh",
                        "content": "Us bhai Us"
                    },
                    {
                        "username": "dileep9259",
                        "content": "wah !!! :P\\n"
                    }
                ]
            },
            {
                "id": 1576270,
                "content": [
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan anyone please explain with giving some examples also to make it clear what is asked? thanks"
                    },
                    {
                        "username": "LOVEGURU",
                        "content": "Gas is gas station, Cost is amount of gas required to travel from i to i+1 station. we need to find index .From that we can complete the journey if we do not find index return -1.\\nour main agenda is find index we can travel from i to n-1 in the circular way"
                    },
                    {
                        "username": "Joseph86",
                        "content": "[@calm27](/calm27) I was in 5th grade in 2015 :0"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "whoa..  ancient comments were full of respect and gratitude!"
                    },
                    {
                        "username": "calm27",
                        "content": "[@heisenberg280](/heisenberg280) no way 2015 was 8 years ago, mate. no way "
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "[@heisenberg280](/heisenberg280)  \\uD83D\\uDE02\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Msey",
                        "content": "[@heisenberg280](/heisenberg280) or not and gave up :)"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@studcoder569](/studcoder569) Jul 29, 2015"
                    },
                    {
                        "username": "studcoder569",
                        "content": "[@heisenberg280](/heisenberg280) Good point lol"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "[@heisenberg280](/heisenberg280) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@studcoder569](/studcoder569) love your dedication but after 8 long years she might have understood the question by now :)"
                    },
                    {
                        "username": "studcoder569",
                        "content": "The question is asking you to find a starting gas station on the circuit that will allow you to complete one round trip without running out of gas. It is possible for there to be no solution. If there is a solution, the test cases are written such that it is unique. The examples shown in the description illustrate how the road trip would work. "
                    },
                    {
                        "username": "dadick",
                        "content": "Hint: if you start from station `a` and stuck at `b`, then you can't get to `b` from any station between `a` and `b`."
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) at position a we are getting some positive value \"y\" and from a to b we are adding some \"x\"  ..so if x+y cant cross b then obviously x alone cant cross b....... in your case we can reach to position 2 but cant cross it"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) reached to position to 2 but we cant reach to next position ..\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "what if ,gas={2,3,1,5} cost={1,2,4,3} i start at station 0 and reach station 2, and get stuck there, but i can start at station 1 and reach station 2, so your hint is proved wrong successfully "
                    },
                    {
                        "username": "khan60939",
                        "content": "[@mimirave](/mimirave) same confusion"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Bye bye TLE \\uD83D\\uDC4B"
                    },
                    {
                        "username": "mimirave",
                        "content": "Am I misunderstanding this hint?: If I start at station 0, successfully get to station 1, successfully get to station 2 but cannot complete the trip to station 3, then I am stuck at station 2 and the hint says that I cannot get to station 2 from station 1.  "
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "thanks! overcame TLE"
                    },
                    {
                        "username": "Jayasurya_K",
                        "content": "Thanks Buddy! TLE cracked..!"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "Thanks! TLE eliminator hint"
                    },
                    {
                        "username": "vanchanr",
                        "content": "good one !"
                    },
                    {
                        "username": "huanpipt",
                        "content": "Overcome TLE with this tip :) "
                    },
                    {
                        "username": "w286432531",
                        "content": "Thanks. I went from TLE to accepted with this hint."
                    },
                    {
                        "username": "CourteousCoder",
                        "content": "In order to prepare for an interview, it is more important that I am able to recognized the pattern in this problem.\\n\\nCan someone please help me identify the pattern of this problem?\\n\\nIs this a variation of a classic problem in Computer Science?\\nIf so, which?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of those problems that don\\'t fall under any category. It simply is just understanding the problem and utilizing problem solving"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "so how was your interview\\n"
                    },
                    {
                        "username": "kardopaska",
                        "content": "This is a classic problem of misdirection.  Description clearly states that valid answers include travel in clockwise direction only!  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "yueyunpeng",
                        "content": "I solved it with a two pass algorithm fairly quickly, the idea is:\\n\\n1. First just assum the gas tank can fall below zero, complete a loop starting at position 0, and record the index with lowest amount of gas (possibly negative) in tank, call it `lowest_idx`.\\n\\n2. Complete a loop starting from `lowest_idx`, break and return `-1` if the tank falls below zero at any point. Return `lowest_idx` if it never fell below zero.\\n\\nSure it\\'s not one pass, but extremely easy to understand, guarantees to be O(N) time and O(1) space, and did pass all tests. Am I missing anything?"
                    },
                    {
                        "username": "ggx94",
                        "content": "[@Kaltu](/Kaltu) I think they have tried to fix it (test case 39/40 for me...) but there is still a bug. The solution is still not unique,"
                    },
                    {
                        "username": "crazytan",
                        "content": "What if there are multiple indices with lowest amount of gas?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "There is a bug in the testcase `gas=[2,1,0,0]`, `cost=[0,1,0,0]`, the problem statement says the solution is unique but start from every index can complete the circuit\\nThe system can detect duplicated solution if we rotate the pairs by 1 to `gas=[0,2,1,0]`, `cost=[0,0,1,0]`, then it says \"Invalid Testcase\" \"The answer should be unique.\"\\n\\nBefore LeetCode remove this bugged testcase, be sure to account this.\\nFor example, when computing lowest_idx, make sure you keep updating it when ever the lowest gas tank are hit, so we can skip the [0, 0] gas/cost pairs"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": " int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "NishantGautam",
                        "content": "[@Yue Yunpeng](/yueyunpeng) how did you arrive at the thinking that I have to start at the station with lowest amount of gas."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Trick to solve circular path problems: Explains in under three minutes:\\nhttps://youtu.be/IEnJSIOOtOg"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "[@er_sushant](/er_sushant)  we can move forward onle if gas>0 so we should always keep this in mind.so,if(gas<=0)break; we can\\'t move further"
                    },
                    {
                        "username": "er_sushant",
                        "content": "[@abhi098](/abhi098) we can guarantee at the last station when `gas >= 0`, this means there is enough gas to make one circular circuit atleast once. if we found `gas < 0`, in any of the station, means we don\\'t have enough gas to move to next station.\\nAlso try various test cases for better understanding."
                    },
                    {
                        "username": "abhi098",
                        "content": "[@jobless_lm10](/jobless_lm10) how can you guarentee that when gas >0 at the last station, you can complete the whole circle from where you start ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "no need to do second pass. If gas remaining at the end of first pass is less than 0 then we can never go round all stations from any station. Otherwise we can go round all from lowest_idx + 1."
                    },
                    {
                        "username": "evidem64",
                        "content": "Problem description states:\\n> If there exists a solution, it is guaranteed to be unique\\n\\nOn submission my solution fails for the following case:\\n> [1,2,3,4,5,6,7,8]\\n> [1,2,3,4,5,6,7,8]\\n\\nClearly, there IS a solution, but it\\'s NOT unique, since\\nyou can start at any of the stations.\\nExpected answer is 0 though, anything else gets rejected.\\n"
                    },
                    {
                        "username": "emil_i_lonneberga",
                        "content": "Another test case that failed to satisfy the uniqueness is gas = [2, 0, 0, 0, ..., 0], cost =[0, 1, 0, 0, ..., 0]. If the test cases cannot be guaranteed to be unique, then additional restrictions like finding the minimum of all viable starting index should be placed. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@nishant7372](/nishant7372) `gas=[2,1,0,0, .... ,0,0]`, `cost=[0,1,0,0, .... ,0,0]` This one is a system testcase, the expected answer is `0` but we can clearly see that every index is actually valid.\nAND, if we rotate it by 1 to `gas=[0,2,1,0,0, .... ,0]`, `cost=[0,0,1,0,0, .... ,0]` as a custom testcase, the system now complains it has non-unique answer.\nThe problem is a circular problem, simply shifting the index in the array representation should not make any difference."
                    },
                    {
                        "username": "labbiahmed",
                        "content": "only one time tank == 0 . in this scenario this test case invalid . every time when you arrived a next station your tank is empty. \\n"
                    },
                    {
                        "username": "mudit_loya",
                        "content": "yes .. the solution is not unique .. even i have testcases where there many solutions"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "Isn\\'t this an invalid test case. It\\'s giving me invalid test case output."
                    },
                    {
                        "username": "jotho_",
                        "content": "There are more than one correct starting stations for that testcase, so it will be rejected."
                    },
                    {
                        "username": "aneesh1029",
                        "content": "You are starting from starting station at 0th index so return the first station possible"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "I think we need to return the smallest possible answer"
                    },
                    {
                        "username": "nishant7372",
                        "content": "I think all the system testcases have a unique answer."
                    },
                    {
                        "username": "banty",
                        "content": "This is not a rant, I genuinly want to know what is it that this problem trying to test so that I can practice it more and be better at it"
                    },
                    {
                        "username": "RB213",
                        "content": "This question is stupid, the language is so convoluted and examples are poor. But this situation does happen in real life when customers/product can\\'t express the problem clearly and engineers build poorly designed system. "
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "It is simply about problem solving skill + greedy technique i think"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "The problem does not state we want the smallest index as a result.\\n\\n[1,6,3,4,5]\\n[3,4,5,1,2]\\n\\nSo, why the answer 3 is not accpeted for the above test case ??\\n"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "The question mentions that the answer is unique. Your test case has two answers. Hence, the wrong one."
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question is very confusing. "
                    },
                    {
                        "username": "pavankumar",
                        "content": "Hi all,\\nI've written the code in suchaway that my solution validates all possible starting positions. I know that this is a very inefficient code to find the solution and finally i got time limit exceeded. can anybody give suggestions on how to solve this in an efficient way. I don't need code  but logic fine.\\n\\nThanks\\npavan kumar"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I know this comment is now almost a decade old at this point but here\\'s what I did. Try keeping track of the difference between the gas and cost as that\\'s what really matters for the problem. You might have to look when to avoid (hint the value will be negative so you can\\'t reach that place anyways). Here\\'s an example:\\n```[1,2,3,4,5] gas\\n[3,4,5,1,2] cost\\n[-2,-2,-2,3,3] -> difference between gas and cost (use variable instead of array for better space)\\n  0  1   2 3 4 -> index\\n```\\nthe net value till index 2 is negative (always -2 so we can ignore till there because it is not possible to move to the next point from these position.\\nfor index 3 this can be a possible answer. But what about having another net negative value in between (say -4)\\n```\\n[-2,-2,-2,3,-4,3]\\n```\\nwe can no longer use the index 3 now. But if you look closely we will find that for the above case it\\'s impossible to have a solution (output is -1). Reason is becase sum(gas)-sum(cost) is negative.\\nBut what for \\n```\\n[-2,-2,-2,3,-4,10]\\n```\\nHere we will keep track of the `minimum valid index`. Since, the answer is unique we can have only 1 valid index. Hence, using a Integer.MAX_VALUE as the initial answer and choosing the min and reassigning it to Integer.MAX_VALUE when the initially possible valid index (the index 3 in this case) is incorrect answer.\\n\\nLink to code: https://leetcode.com/problems/gas-station/solutions/3012347/easy-python-solution/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`The most unbelievable thing about this question isn\\'t that the car has unlimited gas tank, but the fact that I have got money to pay for it`"
                    },
                    {
                        "username": "pushpit_singh",
                        "content": "Us bhai Us"
                    },
                    {
                        "username": "dileep9259",
                        "content": "wah !!! :P\\n"
                    }
                ]
            },
            {
                "id": 1570765,
                "content": [
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan anyone please explain with giving some examples also to make it clear what is asked? thanks"
                    },
                    {
                        "username": "LOVEGURU",
                        "content": "Gas is gas station, Cost is amount of gas required to travel from i to i+1 station. we need to find index .From that we can complete the journey if we do not find index return -1.\\nour main agenda is find index we can travel from i to n-1 in the circular way"
                    },
                    {
                        "username": "Joseph86",
                        "content": "[@calm27](/calm27) I was in 5th grade in 2015 :0"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "whoa..  ancient comments were full of respect and gratitude!"
                    },
                    {
                        "username": "calm27",
                        "content": "[@heisenberg280](/heisenberg280) no way 2015 was 8 years ago, mate. no way "
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "[@heisenberg280](/heisenberg280)  \\uD83D\\uDE02\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Msey",
                        "content": "[@heisenberg280](/heisenberg280) or not and gave up :)"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@studcoder569](/studcoder569) Jul 29, 2015"
                    },
                    {
                        "username": "studcoder569",
                        "content": "[@heisenberg280](/heisenberg280) Good point lol"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "[@heisenberg280](/heisenberg280) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@studcoder569](/studcoder569) love your dedication but after 8 long years she might have understood the question by now :)"
                    },
                    {
                        "username": "studcoder569",
                        "content": "The question is asking you to find a starting gas station on the circuit that will allow you to complete one round trip without running out of gas. It is possible for there to be no solution. If there is a solution, the test cases are written such that it is unique. The examples shown in the description illustrate how the road trip would work. "
                    },
                    {
                        "username": "dadick",
                        "content": "Hint: if you start from station `a` and stuck at `b`, then you can't get to `b` from any station between `a` and `b`."
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) at position a we are getting some positive value \"y\" and from a to b we are adding some \"x\"  ..so if x+y cant cross b then obviously x alone cant cross b....... in your case we can reach to position 2 but cant cross it"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) reached to position to 2 but we cant reach to next position ..\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "what if ,gas={2,3,1,5} cost={1,2,4,3} i start at station 0 and reach station 2, and get stuck there, but i can start at station 1 and reach station 2, so your hint is proved wrong successfully "
                    },
                    {
                        "username": "khan60939",
                        "content": "[@mimirave](/mimirave) same confusion"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Bye bye TLE \\uD83D\\uDC4B"
                    },
                    {
                        "username": "mimirave",
                        "content": "Am I misunderstanding this hint?: If I start at station 0, successfully get to station 1, successfully get to station 2 but cannot complete the trip to station 3, then I am stuck at station 2 and the hint says that I cannot get to station 2 from station 1.  "
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "thanks! overcame TLE"
                    },
                    {
                        "username": "Jayasurya_K",
                        "content": "Thanks Buddy! TLE cracked..!"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "Thanks! TLE eliminator hint"
                    },
                    {
                        "username": "vanchanr",
                        "content": "good one !"
                    },
                    {
                        "username": "huanpipt",
                        "content": "Overcome TLE with this tip :) "
                    },
                    {
                        "username": "w286432531",
                        "content": "Thanks. I went from TLE to accepted with this hint."
                    },
                    {
                        "username": "CourteousCoder",
                        "content": "In order to prepare for an interview, it is more important that I am able to recognized the pattern in this problem.\\n\\nCan someone please help me identify the pattern of this problem?\\n\\nIs this a variation of a classic problem in Computer Science?\\nIf so, which?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of those problems that don\\'t fall under any category. It simply is just understanding the problem and utilizing problem solving"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "so how was your interview\\n"
                    },
                    {
                        "username": "kardopaska",
                        "content": "This is a classic problem of misdirection.  Description clearly states that valid answers include travel in clockwise direction only!  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "yueyunpeng",
                        "content": "I solved it with a two pass algorithm fairly quickly, the idea is:\\n\\n1. First just assum the gas tank can fall below zero, complete a loop starting at position 0, and record the index with lowest amount of gas (possibly negative) in tank, call it `lowest_idx`.\\n\\n2. Complete a loop starting from `lowest_idx`, break and return `-1` if the tank falls below zero at any point. Return `lowest_idx` if it never fell below zero.\\n\\nSure it\\'s not one pass, but extremely easy to understand, guarantees to be O(N) time and O(1) space, and did pass all tests. Am I missing anything?"
                    },
                    {
                        "username": "ggx94",
                        "content": "[@Kaltu](/Kaltu) I think they have tried to fix it (test case 39/40 for me...) but there is still a bug. The solution is still not unique,"
                    },
                    {
                        "username": "crazytan",
                        "content": "What if there are multiple indices with lowest amount of gas?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "There is a bug in the testcase `gas=[2,1,0,0]`, `cost=[0,1,0,0]`, the problem statement says the solution is unique but start from every index can complete the circuit\\nThe system can detect duplicated solution if we rotate the pairs by 1 to `gas=[0,2,1,0]`, `cost=[0,0,1,0]`, then it says \"Invalid Testcase\" \"The answer should be unique.\"\\n\\nBefore LeetCode remove this bugged testcase, be sure to account this.\\nFor example, when computing lowest_idx, make sure you keep updating it when ever the lowest gas tank are hit, so we can skip the [0, 0] gas/cost pairs"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": " int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "NishantGautam",
                        "content": "[@Yue Yunpeng](/yueyunpeng) how did you arrive at the thinking that I have to start at the station with lowest amount of gas."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Trick to solve circular path problems: Explains in under three minutes:\\nhttps://youtu.be/IEnJSIOOtOg"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "[@er_sushant](/er_sushant)  we can move forward onle if gas>0 so we should always keep this in mind.so,if(gas<=0)break; we can\\'t move further"
                    },
                    {
                        "username": "er_sushant",
                        "content": "[@abhi098](/abhi098) we can guarantee at the last station when `gas >= 0`, this means there is enough gas to make one circular circuit atleast once. if we found `gas < 0`, in any of the station, means we don\\'t have enough gas to move to next station.\\nAlso try various test cases for better understanding."
                    },
                    {
                        "username": "abhi098",
                        "content": "[@jobless_lm10](/jobless_lm10) how can you guarentee that when gas >0 at the last station, you can complete the whole circle from where you start ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "no need to do second pass. If gas remaining at the end of first pass is less than 0 then we can never go round all stations from any station. Otherwise we can go round all from lowest_idx + 1."
                    },
                    {
                        "username": "evidem64",
                        "content": "Problem description states:\\n> If there exists a solution, it is guaranteed to be unique\\n\\nOn submission my solution fails for the following case:\\n> [1,2,3,4,5,6,7,8]\\n> [1,2,3,4,5,6,7,8]\\n\\nClearly, there IS a solution, but it\\'s NOT unique, since\\nyou can start at any of the stations.\\nExpected answer is 0 though, anything else gets rejected.\\n"
                    },
                    {
                        "username": "emil_i_lonneberga",
                        "content": "Another test case that failed to satisfy the uniqueness is gas = [2, 0, 0, 0, ..., 0], cost =[0, 1, 0, 0, ..., 0]. If the test cases cannot be guaranteed to be unique, then additional restrictions like finding the minimum of all viable starting index should be placed. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@nishant7372](/nishant7372) `gas=[2,1,0,0, .... ,0,0]`, `cost=[0,1,0,0, .... ,0,0]` This one is a system testcase, the expected answer is `0` but we can clearly see that every index is actually valid.\nAND, if we rotate it by 1 to `gas=[0,2,1,0,0, .... ,0]`, `cost=[0,0,1,0,0, .... ,0]` as a custom testcase, the system now complains it has non-unique answer.\nThe problem is a circular problem, simply shifting the index in the array representation should not make any difference."
                    },
                    {
                        "username": "labbiahmed",
                        "content": "only one time tank == 0 . in this scenario this test case invalid . every time when you arrived a next station your tank is empty. \\n"
                    },
                    {
                        "username": "mudit_loya",
                        "content": "yes .. the solution is not unique .. even i have testcases where there many solutions"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "Isn\\'t this an invalid test case. It\\'s giving me invalid test case output."
                    },
                    {
                        "username": "jotho_",
                        "content": "There are more than one correct starting stations for that testcase, so it will be rejected."
                    },
                    {
                        "username": "aneesh1029",
                        "content": "You are starting from starting station at 0th index so return the first station possible"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "I think we need to return the smallest possible answer"
                    },
                    {
                        "username": "nishant7372",
                        "content": "I think all the system testcases have a unique answer."
                    },
                    {
                        "username": "banty",
                        "content": "This is not a rant, I genuinly want to know what is it that this problem trying to test so that I can practice it more and be better at it"
                    },
                    {
                        "username": "RB213",
                        "content": "This question is stupid, the language is so convoluted and examples are poor. But this situation does happen in real life when customers/product can\\'t express the problem clearly and engineers build poorly designed system. "
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "It is simply about problem solving skill + greedy technique i think"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "The problem does not state we want the smallest index as a result.\\n\\n[1,6,3,4,5]\\n[3,4,5,1,2]\\n\\nSo, why the answer 3 is not accpeted for the above test case ??\\n"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "The question mentions that the answer is unique. Your test case has two answers. Hence, the wrong one."
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question is very confusing. "
                    },
                    {
                        "username": "pavankumar",
                        "content": "Hi all,\\nI've written the code in suchaway that my solution validates all possible starting positions. I know that this is a very inefficient code to find the solution and finally i got time limit exceeded. can anybody give suggestions on how to solve this in an efficient way. I don't need code  but logic fine.\\n\\nThanks\\npavan kumar"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I know this comment is now almost a decade old at this point but here\\'s what I did. Try keeping track of the difference between the gas and cost as that\\'s what really matters for the problem. You might have to look when to avoid (hint the value will be negative so you can\\'t reach that place anyways). Here\\'s an example:\\n```[1,2,3,4,5] gas\\n[3,4,5,1,2] cost\\n[-2,-2,-2,3,3] -> difference between gas and cost (use variable instead of array for better space)\\n  0  1   2 3 4 -> index\\n```\\nthe net value till index 2 is negative (always -2 so we can ignore till there because it is not possible to move to the next point from these position.\\nfor index 3 this can be a possible answer. But what about having another net negative value in between (say -4)\\n```\\n[-2,-2,-2,3,-4,3]\\n```\\nwe can no longer use the index 3 now. But if you look closely we will find that for the above case it\\'s impossible to have a solution (output is -1). Reason is becase sum(gas)-sum(cost) is negative.\\nBut what for \\n```\\n[-2,-2,-2,3,-4,10]\\n```\\nHere we will keep track of the `minimum valid index`. Since, the answer is unique we can have only 1 valid index. Hence, using a Integer.MAX_VALUE as the initial answer and choosing the min and reassigning it to Integer.MAX_VALUE when the initially possible valid index (the index 3 in this case) is incorrect answer.\\n\\nLink to code: https://leetcode.com/problems/gas-station/solutions/3012347/easy-python-solution/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`The most unbelievable thing about this question isn\\'t that the car has unlimited gas tank, but the fact that I have got money to pay for it`"
                    },
                    {
                        "username": "pushpit_singh",
                        "content": "Us bhai Us"
                    },
                    {
                        "username": "dileep9259",
                        "content": "wah !!! :P\\n"
                    }
                ]
            },
            {
                "id": 1746548,
                "content": [
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan anyone please explain with giving some examples also to make it clear what is asked? thanks"
                    },
                    {
                        "username": "LOVEGURU",
                        "content": "Gas is gas station, Cost is amount of gas required to travel from i to i+1 station. we need to find index .From that we can complete the journey if we do not find index return -1.\\nour main agenda is find index we can travel from i to n-1 in the circular way"
                    },
                    {
                        "username": "Joseph86",
                        "content": "[@calm27](/calm27) I was in 5th grade in 2015 :0"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "whoa..  ancient comments were full of respect and gratitude!"
                    },
                    {
                        "username": "calm27",
                        "content": "[@heisenberg280](/heisenberg280) no way 2015 was 8 years ago, mate. no way "
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "[@heisenberg280](/heisenberg280)  \\uD83D\\uDE02\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Msey",
                        "content": "[@heisenberg280](/heisenberg280) or not and gave up :)"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@studcoder569](/studcoder569) Jul 29, 2015"
                    },
                    {
                        "username": "studcoder569",
                        "content": "[@heisenberg280](/heisenberg280) Good point lol"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "[@heisenberg280](/heisenberg280) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@studcoder569](/studcoder569) love your dedication but after 8 long years she might have understood the question by now :)"
                    },
                    {
                        "username": "studcoder569",
                        "content": "The question is asking you to find a starting gas station on the circuit that will allow you to complete one round trip without running out of gas. It is possible for there to be no solution. If there is a solution, the test cases are written such that it is unique. The examples shown in the description illustrate how the road trip would work. "
                    },
                    {
                        "username": "dadick",
                        "content": "Hint: if you start from station `a` and stuck at `b`, then you can't get to `b` from any station between `a` and `b`."
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) at position a we are getting some positive value \"y\" and from a to b we are adding some \"x\"  ..so if x+y cant cross b then obviously x alone cant cross b....... in your case we can reach to position 2 but cant cross it"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) reached to position to 2 but we cant reach to next position ..\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "what if ,gas={2,3,1,5} cost={1,2,4,3} i start at station 0 and reach station 2, and get stuck there, but i can start at station 1 and reach station 2, so your hint is proved wrong successfully "
                    },
                    {
                        "username": "khan60939",
                        "content": "[@mimirave](/mimirave) same confusion"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Bye bye TLE \\uD83D\\uDC4B"
                    },
                    {
                        "username": "mimirave",
                        "content": "Am I misunderstanding this hint?: If I start at station 0, successfully get to station 1, successfully get to station 2 but cannot complete the trip to station 3, then I am stuck at station 2 and the hint says that I cannot get to station 2 from station 1.  "
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "thanks! overcame TLE"
                    },
                    {
                        "username": "Jayasurya_K",
                        "content": "Thanks Buddy! TLE cracked..!"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "Thanks! TLE eliminator hint"
                    },
                    {
                        "username": "vanchanr",
                        "content": "good one !"
                    },
                    {
                        "username": "huanpipt",
                        "content": "Overcome TLE with this tip :) "
                    },
                    {
                        "username": "w286432531",
                        "content": "Thanks. I went from TLE to accepted with this hint."
                    },
                    {
                        "username": "CourteousCoder",
                        "content": "In order to prepare for an interview, it is more important that I am able to recognized the pattern in this problem.\\n\\nCan someone please help me identify the pattern of this problem?\\n\\nIs this a variation of a classic problem in Computer Science?\\nIf so, which?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of those problems that don\\'t fall under any category. It simply is just understanding the problem and utilizing problem solving"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "so how was your interview\\n"
                    },
                    {
                        "username": "kardopaska",
                        "content": "This is a classic problem of misdirection.  Description clearly states that valid answers include travel in clockwise direction only!  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "yueyunpeng",
                        "content": "I solved it with a two pass algorithm fairly quickly, the idea is:\\n\\n1. First just assum the gas tank can fall below zero, complete a loop starting at position 0, and record the index with lowest amount of gas (possibly negative) in tank, call it `lowest_idx`.\\n\\n2. Complete a loop starting from `lowest_idx`, break and return `-1` if the tank falls below zero at any point. Return `lowest_idx` if it never fell below zero.\\n\\nSure it\\'s not one pass, but extremely easy to understand, guarantees to be O(N) time and O(1) space, and did pass all tests. Am I missing anything?"
                    },
                    {
                        "username": "ggx94",
                        "content": "[@Kaltu](/Kaltu) I think they have tried to fix it (test case 39/40 for me...) but there is still a bug. The solution is still not unique,"
                    },
                    {
                        "username": "crazytan",
                        "content": "What if there are multiple indices with lowest amount of gas?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "There is a bug in the testcase `gas=[2,1,0,0]`, `cost=[0,1,0,0]`, the problem statement says the solution is unique but start from every index can complete the circuit\\nThe system can detect duplicated solution if we rotate the pairs by 1 to `gas=[0,2,1,0]`, `cost=[0,0,1,0]`, then it says \"Invalid Testcase\" \"The answer should be unique.\"\\n\\nBefore LeetCode remove this bugged testcase, be sure to account this.\\nFor example, when computing lowest_idx, make sure you keep updating it when ever the lowest gas tank are hit, so we can skip the [0, 0] gas/cost pairs"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": " int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "NishantGautam",
                        "content": "[@Yue Yunpeng](/yueyunpeng) how did you arrive at the thinking that I have to start at the station with lowest amount of gas."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Trick to solve circular path problems: Explains in under three minutes:\\nhttps://youtu.be/IEnJSIOOtOg"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "[@er_sushant](/er_sushant)  we can move forward onle if gas>0 so we should always keep this in mind.so,if(gas<=0)break; we can\\'t move further"
                    },
                    {
                        "username": "er_sushant",
                        "content": "[@abhi098](/abhi098) we can guarantee at the last station when `gas >= 0`, this means there is enough gas to make one circular circuit atleast once. if we found `gas < 0`, in any of the station, means we don\\'t have enough gas to move to next station.\\nAlso try various test cases for better understanding."
                    },
                    {
                        "username": "abhi098",
                        "content": "[@jobless_lm10](/jobless_lm10) how can you guarentee that when gas >0 at the last station, you can complete the whole circle from where you start ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "no need to do second pass. If gas remaining at the end of first pass is less than 0 then we can never go round all stations from any station. Otherwise we can go round all from lowest_idx + 1."
                    },
                    {
                        "username": "evidem64",
                        "content": "Problem description states:\\n> If there exists a solution, it is guaranteed to be unique\\n\\nOn submission my solution fails for the following case:\\n> [1,2,3,4,5,6,7,8]\\n> [1,2,3,4,5,6,7,8]\\n\\nClearly, there IS a solution, but it\\'s NOT unique, since\\nyou can start at any of the stations.\\nExpected answer is 0 though, anything else gets rejected.\\n"
                    },
                    {
                        "username": "emil_i_lonneberga",
                        "content": "Another test case that failed to satisfy the uniqueness is gas = [2, 0, 0, 0, ..., 0], cost =[0, 1, 0, 0, ..., 0]. If the test cases cannot be guaranteed to be unique, then additional restrictions like finding the minimum of all viable starting index should be placed. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@nishant7372](/nishant7372) `gas=[2,1,0,0, .... ,0,0]`, `cost=[0,1,0,0, .... ,0,0]` This one is a system testcase, the expected answer is `0` but we can clearly see that every index is actually valid.\nAND, if we rotate it by 1 to `gas=[0,2,1,0,0, .... ,0]`, `cost=[0,0,1,0,0, .... ,0]` as a custom testcase, the system now complains it has non-unique answer.\nThe problem is a circular problem, simply shifting the index in the array representation should not make any difference."
                    },
                    {
                        "username": "labbiahmed",
                        "content": "only one time tank == 0 . in this scenario this test case invalid . every time when you arrived a next station your tank is empty. \\n"
                    },
                    {
                        "username": "mudit_loya",
                        "content": "yes .. the solution is not unique .. even i have testcases where there many solutions"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "Isn\\'t this an invalid test case. It\\'s giving me invalid test case output."
                    },
                    {
                        "username": "jotho_",
                        "content": "There are more than one correct starting stations for that testcase, so it will be rejected."
                    },
                    {
                        "username": "aneesh1029",
                        "content": "You are starting from starting station at 0th index so return the first station possible"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "I think we need to return the smallest possible answer"
                    },
                    {
                        "username": "nishant7372",
                        "content": "I think all the system testcases have a unique answer."
                    },
                    {
                        "username": "banty",
                        "content": "This is not a rant, I genuinly want to know what is it that this problem trying to test so that I can practice it more and be better at it"
                    },
                    {
                        "username": "RB213",
                        "content": "This question is stupid, the language is so convoluted and examples are poor. But this situation does happen in real life when customers/product can\\'t express the problem clearly and engineers build poorly designed system. "
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "It is simply about problem solving skill + greedy technique i think"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "The problem does not state we want the smallest index as a result.\\n\\n[1,6,3,4,5]\\n[3,4,5,1,2]\\n\\nSo, why the answer 3 is not accpeted for the above test case ??\\n"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "The question mentions that the answer is unique. Your test case has two answers. Hence, the wrong one."
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question is very confusing. "
                    },
                    {
                        "username": "pavankumar",
                        "content": "Hi all,\\nI've written the code in suchaway that my solution validates all possible starting positions. I know that this is a very inefficient code to find the solution and finally i got time limit exceeded. can anybody give suggestions on how to solve this in an efficient way. I don't need code  but logic fine.\\n\\nThanks\\npavan kumar"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I know this comment is now almost a decade old at this point but here\\'s what I did. Try keeping track of the difference between the gas and cost as that\\'s what really matters for the problem. You might have to look when to avoid (hint the value will be negative so you can\\'t reach that place anyways). Here\\'s an example:\\n```[1,2,3,4,5] gas\\n[3,4,5,1,2] cost\\n[-2,-2,-2,3,3] -> difference between gas and cost (use variable instead of array for better space)\\n  0  1   2 3 4 -> index\\n```\\nthe net value till index 2 is negative (always -2 so we can ignore till there because it is not possible to move to the next point from these position.\\nfor index 3 this can be a possible answer. But what about having another net negative value in between (say -4)\\n```\\n[-2,-2,-2,3,-4,3]\\n```\\nwe can no longer use the index 3 now. But if you look closely we will find that for the above case it\\'s impossible to have a solution (output is -1). Reason is becase sum(gas)-sum(cost) is negative.\\nBut what for \\n```\\n[-2,-2,-2,3,-4,10]\\n```\\nHere we will keep track of the `minimum valid index`. Since, the answer is unique we can have only 1 valid index. Hence, using a Integer.MAX_VALUE as the initial answer and choosing the min and reassigning it to Integer.MAX_VALUE when the initially possible valid index (the index 3 in this case) is incorrect answer.\\n\\nLink to code: https://leetcode.com/problems/gas-station/solutions/3012347/easy-python-solution/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`The most unbelievable thing about this question isn\\'t that the car has unlimited gas tank, but the fact that I have got money to pay for it`"
                    },
                    {
                        "username": "pushpit_singh",
                        "content": "Us bhai Us"
                    },
                    {
                        "username": "dileep9259",
                        "content": "wah !!! :P\\n"
                    }
                ]
            },
            {
                "id": 1567882,
                "content": [
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan anyone please explain with giving some examples also to make it clear what is asked? thanks"
                    },
                    {
                        "username": "LOVEGURU",
                        "content": "Gas is gas station, Cost is amount of gas required to travel from i to i+1 station. we need to find index .From that we can complete the journey if we do not find index return -1.\\nour main agenda is find index we can travel from i to n-1 in the circular way"
                    },
                    {
                        "username": "Joseph86",
                        "content": "[@calm27](/calm27) I was in 5th grade in 2015 :0"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "whoa..  ancient comments were full of respect and gratitude!"
                    },
                    {
                        "username": "calm27",
                        "content": "[@heisenberg280](/heisenberg280) no way 2015 was 8 years ago, mate. no way "
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "[@heisenberg280](/heisenberg280)  \\uD83D\\uDE02\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Msey",
                        "content": "[@heisenberg280](/heisenberg280) or not and gave up :)"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@studcoder569](/studcoder569) Jul 29, 2015"
                    },
                    {
                        "username": "studcoder569",
                        "content": "[@heisenberg280](/heisenberg280) Good point lol"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "[@heisenberg280](/heisenberg280) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@studcoder569](/studcoder569) love your dedication but after 8 long years she might have understood the question by now :)"
                    },
                    {
                        "username": "studcoder569",
                        "content": "The question is asking you to find a starting gas station on the circuit that will allow you to complete one round trip without running out of gas. It is possible for there to be no solution. If there is a solution, the test cases are written such that it is unique. The examples shown in the description illustrate how the road trip would work. "
                    },
                    {
                        "username": "dadick",
                        "content": "Hint: if you start from station `a` and stuck at `b`, then you can't get to `b` from any station between `a` and `b`."
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) at position a we are getting some positive value \"y\" and from a to b we are adding some \"x\"  ..so if x+y cant cross b then obviously x alone cant cross b....... in your case we can reach to position 2 but cant cross it"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) reached to position to 2 but we cant reach to next position ..\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "what if ,gas={2,3,1,5} cost={1,2,4,3} i start at station 0 and reach station 2, and get stuck there, but i can start at station 1 and reach station 2, so your hint is proved wrong successfully "
                    },
                    {
                        "username": "khan60939",
                        "content": "[@mimirave](/mimirave) same confusion"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Bye bye TLE \\uD83D\\uDC4B"
                    },
                    {
                        "username": "mimirave",
                        "content": "Am I misunderstanding this hint?: If I start at station 0, successfully get to station 1, successfully get to station 2 but cannot complete the trip to station 3, then I am stuck at station 2 and the hint says that I cannot get to station 2 from station 1.  "
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "thanks! overcame TLE"
                    },
                    {
                        "username": "Jayasurya_K",
                        "content": "Thanks Buddy! TLE cracked..!"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "Thanks! TLE eliminator hint"
                    },
                    {
                        "username": "vanchanr",
                        "content": "good one !"
                    },
                    {
                        "username": "huanpipt",
                        "content": "Overcome TLE with this tip :) "
                    },
                    {
                        "username": "w286432531",
                        "content": "Thanks. I went from TLE to accepted with this hint."
                    },
                    {
                        "username": "CourteousCoder",
                        "content": "In order to prepare for an interview, it is more important that I am able to recognized the pattern in this problem.\\n\\nCan someone please help me identify the pattern of this problem?\\n\\nIs this a variation of a classic problem in Computer Science?\\nIf so, which?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of those problems that don\\'t fall under any category. It simply is just understanding the problem and utilizing problem solving"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "so how was your interview\\n"
                    },
                    {
                        "username": "kardopaska",
                        "content": "This is a classic problem of misdirection.  Description clearly states that valid answers include travel in clockwise direction only!  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "yueyunpeng",
                        "content": "I solved it with a two pass algorithm fairly quickly, the idea is:\\n\\n1. First just assum the gas tank can fall below zero, complete a loop starting at position 0, and record the index with lowest amount of gas (possibly negative) in tank, call it `lowest_idx`.\\n\\n2. Complete a loop starting from `lowest_idx`, break and return `-1` if the tank falls below zero at any point. Return `lowest_idx` if it never fell below zero.\\n\\nSure it\\'s not one pass, but extremely easy to understand, guarantees to be O(N) time and O(1) space, and did pass all tests. Am I missing anything?"
                    },
                    {
                        "username": "ggx94",
                        "content": "[@Kaltu](/Kaltu) I think they have tried to fix it (test case 39/40 for me...) but there is still a bug. The solution is still not unique,"
                    },
                    {
                        "username": "crazytan",
                        "content": "What if there are multiple indices with lowest amount of gas?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "There is a bug in the testcase `gas=[2,1,0,0]`, `cost=[0,1,0,0]`, the problem statement says the solution is unique but start from every index can complete the circuit\\nThe system can detect duplicated solution if we rotate the pairs by 1 to `gas=[0,2,1,0]`, `cost=[0,0,1,0]`, then it says \"Invalid Testcase\" \"The answer should be unique.\"\\n\\nBefore LeetCode remove this bugged testcase, be sure to account this.\\nFor example, when computing lowest_idx, make sure you keep updating it when ever the lowest gas tank are hit, so we can skip the [0, 0] gas/cost pairs"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": " int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "NishantGautam",
                        "content": "[@Yue Yunpeng](/yueyunpeng) how did you arrive at the thinking that I have to start at the station with lowest amount of gas."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Trick to solve circular path problems: Explains in under three minutes:\\nhttps://youtu.be/IEnJSIOOtOg"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "[@er_sushant](/er_sushant)  we can move forward onle if gas>0 so we should always keep this in mind.so,if(gas<=0)break; we can\\'t move further"
                    },
                    {
                        "username": "er_sushant",
                        "content": "[@abhi098](/abhi098) we can guarantee at the last station when `gas >= 0`, this means there is enough gas to make one circular circuit atleast once. if we found `gas < 0`, in any of the station, means we don\\'t have enough gas to move to next station.\\nAlso try various test cases for better understanding."
                    },
                    {
                        "username": "abhi098",
                        "content": "[@jobless_lm10](/jobless_lm10) how can you guarentee that when gas >0 at the last station, you can complete the whole circle from where you start ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "no need to do second pass. If gas remaining at the end of first pass is less than 0 then we can never go round all stations from any station. Otherwise we can go round all from lowest_idx + 1."
                    },
                    {
                        "username": "evidem64",
                        "content": "Problem description states:\\n> If there exists a solution, it is guaranteed to be unique\\n\\nOn submission my solution fails for the following case:\\n> [1,2,3,4,5,6,7,8]\\n> [1,2,3,4,5,6,7,8]\\n\\nClearly, there IS a solution, but it\\'s NOT unique, since\\nyou can start at any of the stations.\\nExpected answer is 0 though, anything else gets rejected.\\n"
                    },
                    {
                        "username": "emil_i_lonneberga",
                        "content": "Another test case that failed to satisfy the uniqueness is gas = [2, 0, 0, 0, ..., 0], cost =[0, 1, 0, 0, ..., 0]. If the test cases cannot be guaranteed to be unique, then additional restrictions like finding the minimum of all viable starting index should be placed. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@nishant7372](/nishant7372) `gas=[2,1,0,0, .... ,0,0]`, `cost=[0,1,0,0, .... ,0,0]` This one is a system testcase, the expected answer is `0` but we can clearly see that every index is actually valid.\nAND, if we rotate it by 1 to `gas=[0,2,1,0,0, .... ,0]`, `cost=[0,0,1,0,0, .... ,0]` as a custom testcase, the system now complains it has non-unique answer.\nThe problem is a circular problem, simply shifting the index in the array representation should not make any difference."
                    },
                    {
                        "username": "labbiahmed",
                        "content": "only one time tank == 0 . in this scenario this test case invalid . every time when you arrived a next station your tank is empty. \\n"
                    },
                    {
                        "username": "mudit_loya",
                        "content": "yes .. the solution is not unique .. even i have testcases where there many solutions"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "Isn\\'t this an invalid test case. It\\'s giving me invalid test case output."
                    },
                    {
                        "username": "jotho_",
                        "content": "There are more than one correct starting stations for that testcase, so it will be rejected."
                    },
                    {
                        "username": "aneesh1029",
                        "content": "You are starting from starting station at 0th index so return the first station possible"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "I think we need to return the smallest possible answer"
                    },
                    {
                        "username": "nishant7372",
                        "content": "I think all the system testcases have a unique answer."
                    },
                    {
                        "username": "banty",
                        "content": "This is not a rant, I genuinly want to know what is it that this problem trying to test so that I can practice it more and be better at it"
                    },
                    {
                        "username": "RB213",
                        "content": "This question is stupid, the language is so convoluted and examples are poor. But this situation does happen in real life when customers/product can\\'t express the problem clearly and engineers build poorly designed system. "
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "It is simply about problem solving skill + greedy technique i think"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "The problem does not state we want the smallest index as a result.\\n\\n[1,6,3,4,5]\\n[3,4,5,1,2]\\n\\nSo, why the answer 3 is not accpeted for the above test case ??\\n"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "The question mentions that the answer is unique. Your test case has two answers. Hence, the wrong one."
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question is very confusing. "
                    },
                    {
                        "username": "pavankumar",
                        "content": "Hi all,\\nI've written the code in suchaway that my solution validates all possible starting positions. I know that this is a very inefficient code to find the solution and finally i got time limit exceeded. can anybody give suggestions on how to solve this in an efficient way. I don't need code  but logic fine.\\n\\nThanks\\npavan kumar"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I know this comment is now almost a decade old at this point but here\\'s what I did. Try keeping track of the difference between the gas and cost as that\\'s what really matters for the problem. You might have to look when to avoid (hint the value will be negative so you can\\'t reach that place anyways). Here\\'s an example:\\n```[1,2,3,4,5] gas\\n[3,4,5,1,2] cost\\n[-2,-2,-2,3,3] -> difference between gas and cost (use variable instead of array for better space)\\n  0  1   2 3 4 -> index\\n```\\nthe net value till index 2 is negative (always -2 so we can ignore till there because it is not possible to move to the next point from these position.\\nfor index 3 this can be a possible answer. But what about having another net negative value in between (say -4)\\n```\\n[-2,-2,-2,3,-4,3]\\n```\\nwe can no longer use the index 3 now. But if you look closely we will find that for the above case it\\'s impossible to have a solution (output is -1). Reason is becase sum(gas)-sum(cost) is negative.\\nBut what for \\n```\\n[-2,-2,-2,3,-4,10]\\n```\\nHere we will keep track of the `minimum valid index`. Since, the answer is unique we can have only 1 valid index. Hence, using a Integer.MAX_VALUE as the initial answer and choosing the min and reassigning it to Integer.MAX_VALUE when the initially possible valid index (the index 3 in this case) is incorrect answer.\\n\\nLink to code: https://leetcode.com/problems/gas-station/solutions/3012347/easy-python-solution/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`The most unbelievable thing about this question isn\\'t that the car has unlimited gas tank, but the fact that I have got money to pay for it`"
                    },
                    {
                        "username": "pushpit_singh",
                        "content": "Us bhai Us"
                    },
                    {
                        "username": "dileep9259",
                        "content": "wah !!! :P\\n"
                    }
                ]
            },
            {
                "id": 1745596,
                "content": [
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan anyone please explain with giving some examples also to make it clear what is asked? thanks"
                    },
                    {
                        "username": "LOVEGURU",
                        "content": "Gas is gas station, Cost is amount of gas required to travel from i to i+1 station. we need to find index .From that we can complete the journey if we do not find index return -1.\\nour main agenda is find index we can travel from i to n-1 in the circular way"
                    },
                    {
                        "username": "Joseph86",
                        "content": "[@calm27](/calm27) I was in 5th grade in 2015 :0"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "whoa..  ancient comments were full of respect and gratitude!"
                    },
                    {
                        "username": "calm27",
                        "content": "[@heisenberg280](/heisenberg280) no way 2015 was 8 years ago, mate. no way "
                    },
                    {
                        "username": "7h3w17ch3r",
                        "content": "[@heisenberg280](/heisenberg280)  \\uD83D\\uDE02\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Msey",
                        "content": "[@heisenberg280](/heisenberg280) or not and gave up :)"
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@studcoder569](/studcoder569) Jul 29, 2015"
                    },
                    {
                        "username": "studcoder569",
                        "content": "[@heisenberg280](/heisenberg280) Good point lol"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "[@heisenberg280](/heisenberg280) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@studcoder569](/studcoder569) love your dedication but after 8 long years she might have understood the question by now :)"
                    },
                    {
                        "username": "studcoder569",
                        "content": "The question is asking you to find a starting gas station on the circuit that will allow you to complete one round trip without running out of gas. It is possible for there to be no solution. If there is a solution, the test cases are written such that it is unique. The examples shown in the description illustrate how the road trip would work. "
                    },
                    {
                        "username": "dadick",
                        "content": "Hint: if you start from station `a` and stuck at `b`, then you can't get to `b` from any station between `a` and `b`."
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) at position a we are getting some positive value \"y\" and from a to b we are adding some \"x\"  ..so if x+y cant cross b then obviously x alone cant cross b....... in your case we can reach to position 2 but cant cross it"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@geekyshark](/geekyshark) reached to position to 2 but we cant reach to next position ..\\n"
                    },
                    {
                        "username": "geekyshark",
                        "content": "what if ,gas={2,3,1,5} cost={1,2,4,3} i start at station 0 and reach station 2, and get stuck there, but i can start at station 1 and reach station 2, so your hint is proved wrong successfully "
                    },
                    {
                        "username": "khan60939",
                        "content": "[@mimirave](/mimirave) same confusion"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Bye bye TLE \\uD83D\\uDC4B"
                    },
                    {
                        "username": "mimirave",
                        "content": "Am I misunderstanding this hint?: If I start at station 0, successfully get to station 1, successfully get to station 2 but cannot complete the trip to station 3, then I am stuck at station 2 and the hint says that I cannot get to station 2 from station 1.  "
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "thanks! overcame TLE"
                    },
                    {
                        "username": "Jayasurya_K",
                        "content": "Thanks Buddy! TLE cracked..!"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "Thanks! TLE eliminator hint"
                    },
                    {
                        "username": "vanchanr",
                        "content": "good one !"
                    },
                    {
                        "username": "huanpipt",
                        "content": "Overcome TLE with this tip :) "
                    },
                    {
                        "username": "w286432531",
                        "content": "Thanks. I went from TLE to accepted with this hint."
                    },
                    {
                        "username": "CourteousCoder",
                        "content": "In order to prepare for an interview, it is more important that I am able to recognized the pattern in this problem.\\n\\nCan someone please help me identify the pattern of this problem?\\n\\nIs this a variation of a classic problem in Computer Science?\\nIf so, which?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of those problems that don\\'t fall under any category. It simply is just understanding the problem and utilizing problem solving"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "so how was your interview\\n"
                    },
                    {
                        "username": "kardopaska",
                        "content": "This is a classic problem of misdirection.  Description clearly states that valid answers include travel in clockwise direction only!  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "yueyunpeng",
                        "content": "I solved it with a two pass algorithm fairly quickly, the idea is:\\n\\n1. First just assum the gas tank can fall below zero, complete a loop starting at position 0, and record the index with lowest amount of gas (possibly negative) in tank, call it `lowest_idx`.\\n\\n2. Complete a loop starting from `lowest_idx`, break and return `-1` if the tank falls below zero at any point. Return `lowest_idx` if it never fell below zero.\\n\\nSure it\\'s not one pass, but extremely easy to understand, guarantees to be O(N) time and O(1) space, and did pass all tests. Am I missing anything?"
                    },
                    {
                        "username": "ggx94",
                        "content": "[@Kaltu](/Kaltu) I think they have tried to fix it (test case 39/40 for me...) but there is still a bug. The solution is still not unique,"
                    },
                    {
                        "username": "crazytan",
                        "content": "What if there are multiple indices with lowest amount of gas?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "There is a bug in the testcase `gas=[2,1,0,0]`, `cost=[0,1,0,0]`, the problem statement says the solution is unique but start from every index can complete the circuit\\nThe system can detect duplicated solution if we rotate the pairs by 1 to `gas=[0,2,1,0]`, `cost=[0,0,1,0]`, then it says \"Invalid Testcase\" \"The answer should be unique.\"\\n\\nBefore LeetCode remove this bugged testcase, be sure to account this.\\nFor example, when computing lowest_idx, make sure you keep updating it when ever the lowest gas tank are hit, so we can skip the [0, 0] gas/cost pairs"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": " int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "NishantGautam",
                        "content": "[@Yue Yunpeng](/yueyunpeng) how did you arrive at the thinking that I have to start at the station with lowest amount of gas."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Trick to solve circular path problems: Explains in under three minutes:\\nhttps://youtu.be/IEnJSIOOtOg"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "[@er_sushant](/er_sushant)  we can move forward onle if gas>0 so we should always keep this in mind.so,if(gas<=0)break; we can\\'t move further"
                    },
                    {
                        "username": "er_sushant",
                        "content": "[@abhi098](/abhi098) we can guarantee at the last station when `gas >= 0`, this means there is enough gas to make one circular circuit atleast once. if we found `gas < 0`, in any of the station, means we don\\'t have enough gas to move to next station.\\nAlso try various test cases for better understanding."
                    },
                    {
                        "username": "abhi098",
                        "content": "[@jobless_lm10](/jobless_lm10) how can you guarentee that when gas >0 at the last station, you can complete the whole circle from where you start ?"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "no need to do second pass. If gas remaining at the end of first pass is less than 0 then we can never go round all stations from any station. Otherwise we can go round all from lowest_idx + 1."
                    },
                    {
                        "username": "evidem64",
                        "content": "Problem description states:\\n> If there exists a solution, it is guaranteed to be unique\\n\\nOn submission my solution fails for the following case:\\n> [1,2,3,4,5,6,7,8]\\n> [1,2,3,4,5,6,7,8]\\n\\nClearly, there IS a solution, but it\\'s NOT unique, since\\nyou can start at any of the stations.\\nExpected answer is 0 though, anything else gets rejected.\\n"
                    },
                    {
                        "username": "emil_i_lonneberga",
                        "content": "Another test case that failed to satisfy the uniqueness is gas = [2, 0, 0, 0, ..., 0], cost =[0, 1, 0, 0, ..., 0]. If the test cases cannot be guaranteed to be unique, then additional restrictions like finding the minimum of all viable starting index should be placed. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "[@nishant7372](/nishant7372) `gas=[2,1,0,0, .... ,0,0]`, `cost=[0,1,0,0, .... ,0,0]` This one is a system testcase, the expected answer is `0` but we can clearly see that every index is actually valid.\nAND, if we rotate it by 1 to `gas=[0,2,1,0,0, .... ,0]`, `cost=[0,0,1,0,0, .... ,0]` as a custom testcase, the system now complains it has non-unique answer.\nThe problem is a circular problem, simply shifting the index in the array representation should not make any difference."
                    },
                    {
                        "username": "labbiahmed",
                        "content": "only one time tank == 0 . in this scenario this test case invalid . every time when you arrived a next station your tank is empty. \\n"
                    },
                    {
                        "username": "mudit_loya",
                        "content": "yes .. the solution is not unique .. even i have testcases where there many solutions"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "Isn\\'t this an invalid test case. It\\'s giving me invalid test case output."
                    },
                    {
                        "username": "jotho_",
                        "content": "There are more than one correct starting stations for that testcase, so it will be rejected."
                    },
                    {
                        "username": "aneesh1029",
                        "content": "You are starting from starting station at 0th index so return the first station possible"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "I think we need to return the smallest possible answer"
                    },
                    {
                        "username": "nishant7372",
                        "content": "I think all the system testcases have a unique answer."
                    },
                    {
                        "username": "banty",
                        "content": "This is not a rant, I genuinly want to know what is it that this problem trying to test so that I can practice it more and be better at it"
                    },
                    {
                        "username": "RB213",
                        "content": "This question is stupid, the language is so convoluted and examples are poor. But this situation does happen in real life when customers/product can\\'t express the problem clearly and engineers build poorly designed system. "
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "It is simply about problem solving skill + greedy technique i think"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "The problem does not state we want the smallest index as a result.\\n\\n[1,6,3,4,5]\\n[3,4,5,1,2]\\n\\nSo, why the answer 3 is not accpeted for the above test case ??\\n"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "The question mentions that the answer is unique. Your test case has two answers. Hence, the wrong one."
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question is very confusing. "
                    },
                    {
                        "username": "pavankumar",
                        "content": "Hi all,\\nI've written the code in suchaway that my solution validates all possible starting positions. I know that this is a very inefficient code to find the solution and finally i got time limit exceeded. can anybody give suggestions on how to solve this in an efficient way. I don't need code  but logic fine.\\n\\nThanks\\npavan kumar"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I know this comment is now almost a decade old at this point but here\\'s what I did. Try keeping track of the difference between the gas and cost as that\\'s what really matters for the problem. You might have to look when to avoid (hint the value will be negative so you can\\'t reach that place anyways). Here\\'s an example:\\n```[1,2,3,4,5] gas\\n[3,4,5,1,2] cost\\n[-2,-2,-2,3,3] -> difference between gas and cost (use variable instead of array for better space)\\n  0  1   2 3 4 -> index\\n```\\nthe net value till index 2 is negative (always -2 so we can ignore till there because it is not possible to move to the next point from these position.\\nfor index 3 this can be a possible answer. But what about having another net negative value in between (say -4)\\n```\\n[-2,-2,-2,3,-4,3]\\n```\\nwe can no longer use the index 3 now. But if you look closely we will find that for the above case it\\'s impossible to have a solution (output is -1). Reason is becase sum(gas)-sum(cost) is negative.\\nBut what for \\n```\\n[-2,-2,-2,3,-4,10]\\n```\\nHere we will keep track of the `minimum valid index`. Since, the answer is unique we can have only 1 valid index. Hence, using a Integer.MAX_VALUE as the initial answer and choosing the min and reassigning it to Integer.MAX_VALUE when the initially possible valid index (the index 3 in this case) is incorrect answer.\\n\\nLink to code: https://leetcode.com/problems/gas-station/solutions/3012347/easy-python-solution/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`The most unbelievable thing about this question isn\\'t that the car has unlimited gas tank, but the fact that I have got money to pay for it`"
                    },
                    {
                        "username": "pushpit_singh",
                        "content": "Us bhai Us"
                    },
                    {
                        "username": "dileep9259",
                        "content": "wah !!! :P\\n"
                    }
                ]
            },
            {
                "id": 1745530,
                "content": [
                    {
                        "username": "Kratos50",
                        "content": "`I got interview in a couple hours but LeetCode streak is more important `"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/gas-station/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One pass.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "fact-1: If car starts at A and can not reach B. Any station between A and B can not reach B.(B is the first station that A can not reach.)\\nfact-2: If the total number of gas is bigger than the total number of cost. There must be a solution.\\n\\nproof copied from mgh: https://leetcode.com/problems/gas-station/discuss/42568/Share-some-of-my-ideas.\\n\\nproof-1: In any station between A and B, let\\'s say C. C will have gas left in our tank, if we go from A to that station. We can\\'t reach B from A with some gas(may be 0) left in the tank in C, so we can\\'t reach B from C with an empty tank.\\n\\nproof-2: If the gas is more than the cost in total, there must be some stations we have enough gas to go through them. Let\\'s say they are **green** stations. So the other stations are **red**. The **adjacent stations** with **same color** can be joined together as one. Then there must be a red station that can be joined into a precedent green station unless there isn\\'t any red station, because the total gas is more than the total cost. In other words, all of the stations will join into a green station at last.\\n\\nthen reversely how we merge the stations, we can find the first station.\\n[G]<-[G,R]: start from first station in G\\n[G]<-[G,R]<-[G,R,G,R]:\\n\\nhere lets denote [GRGR] as [G1R1G2R2], then:\\n1. G1-R1+G2 > R2 but G1-R1<0, then we start from first station in G2\\n2. G1-R1>0 and G2-R2>0, start from first station in either G1 or G2"
                    },
                    {
                        "username": "sjy",
                        "content": "I submit my codes (which are successful compiled  by my local compiler) and the OJ return\\n\"Compile Error: cannot access JsonArray\". \\nThen I copied and submitted some AC solutions from discuss sections, the OJ just return the same Error.\\nThen I just code  \"return 1;\" and try to get a \"Wrong Ans\", but the OJ still return Compile Error.  \\nFYI:  my web browser is Chromium, the Chrome for Linux."
                    },
                    {
                        "username": "sohochaser",
                        "content": "For example, I start from 4th station, the last station will be the 3rd one, do I need travel from 3rd to the 4th as 4th is the starting station?"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "[@Dhananjay40](/Dhananjay40) lol"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@naveenve1609](/naveenve1609) He\\'s prolly Done done with this problem after 9 freaking years"
                    },
                    {
                        "username": "naveenve1609",
                        "content": "Yes, its need to travel to 4th station to complete the circuit "
                    },
                    {
                        "username": "MaddyCoderBack",
                        "content": "just use simple greedy technique just follow these steps\\n1. total_gas_sum <total_cost_sum return -1;\\n2. define two var start=0, curr_sum=0;\\n3. now iterate over loop i=0 to i=gas.size();\\n4 curr=(gas[i]-cost[i]) \\n5. if(curr<0) \\n6. increment start=start+1;\\n7. and set curr=0;\\n8. at the end return start."
                    },
                    {
                        "username": "cannium",
                        "content": "Or the car just visit every gas station once?"
                    },
                    {
                        "username": "ravisvats",
                        "content": "Here are more sample inputs, try these before submitting.\\ngas = [1,2,3,4,5]\\ncost = [3,4,5,1,2]\\ngas = [5, 1, 2, 3, 4]\\ncost = [4, 4, 1, 5, 1]\\ngas = [2]\\ncost = [2]\\ngas = [3,1,1]\\ncost = [1,2,2]"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[3,2,1,1,4]\\ncost=[2,1,2,3,2]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "The last sentence from the problem description states \"If there exists a solution, it is **guaranteed** to be **unique**\"\n\nThis is violated for testcases similar to the 40th testcase, for example, if `gas=[2,0,0]` `cost=[0,1,0]` the expected answer is `0`.\nHowever, one can also start from `2` and complete the circuit.\n\nSince this is a circular problem, a simple rotation should still work.\nIf the rotated version was manually inputted as a custom testcase `gas=[0,2,0]` `cost=[0,0,1]`, the answer from the official testcase should also be rotated to `1`.\nHowever, the system says \"Invalid Testcase\" and \"The answer should be unique.\"\n\nMeaning that the system successfully detects there are non-unique solutions for `gas=[0,2,0]` `cost=[0,0,1]`, but fails to detect it in the official testcase ` gas=[2,0,0]` `cost=[0,1,0]`"
                    },
                    {
                        "username": "gjulianm",
                        "content": "One of the test cases does not have a unique solution. It\\'s gas = [2,0, lotsofzeros] with cost = [0,1,0,lotsofzeros]. With those parameters, any station other than 1 is a valid solution. That test case should be invalidated."
                    }
                ]
            },
            {
                "id": 1565923,
                "content": [
                    {
                        "username": "Kratos50",
                        "content": "`I got interview in a couple hours but LeetCode streak is more important `"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/gas-station/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One pass.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "fact-1: If car starts at A and can not reach B. Any station between A and B can not reach B.(B is the first station that A can not reach.)\\nfact-2: If the total number of gas is bigger than the total number of cost. There must be a solution.\\n\\nproof copied from mgh: https://leetcode.com/problems/gas-station/discuss/42568/Share-some-of-my-ideas.\\n\\nproof-1: In any station between A and B, let\\'s say C. C will have gas left in our tank, if we go from A to that station. We can\\'t reach B from A with some gas(may be 0) left in the tank in C, so we can\\'t reach B from C with an empty tank.\\n\\nproof-2: If the gas is more than the cost in total, there must be some stations we have enough gas to go through them. Let\\'s say they are **green** stations. So the other stations are **red**. The **adjacent stations** with **same color** can be joined together as one. Then there must be a red station that can be joined into a precedent green station unless there isn\\'t any red station, because the total gas is more than the total cost. In other words, all of the stations will join into a green station at last.\\n\\nthen reversely how we merge the stations, we can find the first station.\\n[G]<-[G,R]: start from first station in G\\n[G]<-[G,R]<-[G,R,G,R]:\\n\\nhere lets denote [GRGR] as [G1R1G2R2], then:\\n1. G1-R1+G2 > R2 but G1-R1<0, then we start from first station in G2\\n2. G1-R1>0 and G2-R2>0, start from first station in either G1 or G2"
                    },
                    {
                        "username": "sjy",
                        "content": "I submit my codes (which are successful compiled  by my local compiler) and the OJ return\\n\"Compile Error: cannot access JsonArray\". \\nThen I copied and submitted some AC solutions from discuss sections, the OJ just return the same Error.\\nThen I just code  \"return 1;\" and try to get a \"Wrong Ans\", but the OJ still return Compile Error.  \\nFYI:  my web browser is Chromium, the Chrome for Linux."
                    },
                    {
                        "username": "sohochaser",
                        "content": "For example, I start from 4th station, the last station will be the 3rd one, do I need travel from 3rd to the 4th as 4th is the starting station?"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "[@Dhananjay40](/Dhananjay40) lol"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@naveenve1609](/naveenve1609) He\\'s prolly Done done with this problem after 9 freaking years"
                    },
                    {
                        "username": "naveenve1609",
                        "content": "Yes, its need to travel to 4th station to complete the circuit "
                    },
                    {
                        "username": "MaddyCoderBack",
                        "content": "just use simple greedy technique just follow these steps\\n1. total_gas_sum <total_cost_sum return -1;\\n2. define two var start=0, curr_sum=0;\\n3. now iterate over loop i=0 to i=gas.size();\\n4 curr=(gas[i]-cost[i]) \\n5. if(curr<0) \\n6. increment start=start+1;\\n7. and set curr=0;\\n8. at the end return start."
                    },
                    {
                        "username": "cannium",
                        "content": "Or the car just visit every gas station once?"
                    },
                    {
                        "username": "ravisvats",
                        "content": "Here are more sample inputs, try these before submitting.\\ngas = [1,2,3,4,5]\\ncost = [3,4,5,1,2]\\ngas = [5, 1, 2, 3, 4]\\ncost = [4, 4, 1, 5, 1]\\ngas = [2]\\ncost = [2]\\ngas = [3,1,1]\\ncost = [1,2,2]"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[3,2,1,1,4]\\ncost=[2,1,2,3,2]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "The last sentence from the problem description states \"If there exists a solution, it is **guaranteed** to be **unique**\"\n\nThis is violated for testcases similar to the 40th testcase, for example, if `gas=[2,0,0]` `cost=[0,1,0]` the expected answer is `0`.\nHowever, one can also start from `2` and complete the circuit.\n\nSince this is a circular problem, a simple rotation should still work.\nIf the rotated version was manually inputted as a custom testcase `gas=[0,2,0]` `cost=[0,0,1]`, the answer from the official testcase should also be rotated to `1`.\nHowever, the system says \"Invalid Testcase\" and \"The answer should be unique.\"\n\nMeaning that the system successfully detects there are non-unique solutions for `gas=[0,2,0]` `cost=[0,0,1]`, but fails to detect it in the official testcase ` gas=[2,0,0]` `cost=[0,1,0]`"
                    },
                    {
                        "username": "gjulianm",
                        "content": "One of the test cases does not have a unique solution. It\\'s gas = [2,0, lotsofzeros] with cost = [0,1,0,lotsofzeros]. With those parameters, any station other than 1 is a valid solution. That test case should be invalidated."
                    }
                ]
            },
            {
                "id": 1573388,
                "content": [
                    {
                        "username": "Kratos50",
                        "content": "`I got interview in a couple hours but LeetCode streak is more important `"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/gas-station/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One pass.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "fact-1: If car starts at A and can not reach B. Any station between A and B can not reach B.(B is the first station that A can not reach.)\\nfact-2: If the total number of gas is bigger than the total number of cost. There must be a solution.\\n\\nproof copied from mgh: https://leetcode.com/problems/gas-station/discuss/42568/Share-some-of-my-ideas.\\n\\nproof-1: In any station between A and B, let\\'s say C. C will have gas left in our tank, if we go from A to that station. We can\\'t reach B from A with some gas(may be 0) left in the tank in C, so we can\\'t reach B from C with an empty tank.\\n\\nproof-2: If the gas is more than the cost in total, there must be some stations we have enough gas to go through them. Let\\'s say they are **green** stations. So the other stations are **red**. The **adjacent stations** with **same color** can be joined together as one. Then there must be a red station that can be joined into a precedent green station unless there isn\\'t any red station, because the total gas is more than the total cost. In other words, all of the stations will join into a green station at last.\\n\\nthen reversely how we merge the stations, we can find the first station.\\n[G]<-[G,R]: start from first station in G\\n[G]<-[G,R]<-[G,R,G,R]:\\n\\nhere lets denote [GRGR] as [G1R1G2R2], then:\\n1. G1-R1+G2 > R2 but G1-R1<0, then we start from first station in G2\\n2. G1-R1>0 and G2-R2>0, start from first station in either G1 or G2"
                    },
                    {
                        "username": "sjy",
                        "content": "I submit my codes (which are successful compiled  by my local compiler) and the OJ return\\n\"Compile Error: cannot access JsonArray\". \\nThen I copied and submitted some AC solutions from discuss sections, the OJ just return the same Error.\\nThen I just code  \"return 1;\" and try to get a \"Wrong Ans\", but the OJ still return Compile Error.  \\nFYI:  my web browser is Chromium, the Chrome for Linux."
                    },
                    {
                        "username": "sohochaser",
                        "content": "For example, I start from 4th station, the last station will be the 3rd one, do I need travel from 3rd to the 4th as 4th is the starting station?"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "[@Dhananjay40](/Dhananjay40) lol"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@naveenve1609](/naveenve1609) He\\'s prolly Done done with this problem after 9 freaking years"
                    },
                    {
                        "username": "naveenve1609",
                        "content": "Yes, its need to travel to 4th station to complete the circuit "
                    },
                    {
                        "username": "MaddyCoderBack",
                        "content": "just use simple greedy technique just follow these steps\\n1. total_gas_sum <total_cost_sum return -1;\\n2. define two var start=0, curr_sum=0;\\n3. now iterate over loop i=0 to i=gas.size();\\n4 curr=(gas[i]-cost[i]) \\n5. if(curr<0) \\n6. increment start=start+1;\\n7. and set curr=0;\\n8. at the end return start."
                    },
                    {
                        "username": "cannium",
                        "content": "Or the car just visit every gas station once?"
                    },
                    {
                        "username": "ravisvats",
                        "content": "Here are more sample inputs, try these before submitting.\\ngas = [1,2,3,4,5]\\ncost = [3,4,5,1,2]\\ngas = [5, 1, 2, 3, 4]\\ncost = [4, 4, 1, 5, 1]\\ngas = [2]\\ncost = [2]\\ngas = [3,1,1]\\ncost = [1,2,2]"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[3,2,1,1,4]\\ncost=[2,1,2,3,2]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "The last sentence from the problem description states \"If there exists a solution, it is **guaranteed** to be **unique**\"\n\nThis is violated for testcases similar to the 40th testcase, for example, if `gas=[2,0,0]` `cost=[0,1,0]` the expected answer is `0`.\nHowever, one can also start from `2` and complete the circuit.\n\nSince this is a circular problem, a simple rotation should still work.\nIf the rotated version was manually inputted as a custom testcase `gas=[0,2,0]` `cost=[0,0,1]`, the answer from the official testcase should also be rotated to `1`.\nHowever, the system says \"Invalid Testcase\" and \"The answer should be unique.\"\n\nMeaning that the system successfully detects there are non-unique solutions for `gas=[0,2,0]` `cost=[0,0,1]`, but fails to detect it in the official testcase ` gas=[2,0,0]` `cost=[0,1,0]`"
                    },
                    {
                        "username": "gjulianm",
                        "content": "One of the test cases does not have a unique solution. It\\'s gas = [2,0, lotsofzeros] with cost = [0,1,0,lotsofzeros]. With those parameters, any station other than 1 is a valid solution. That test case should be invalidated."
                    }
                ]
            },
            {
                "id": 1566750,
                "content": [
                    {
                        "username": "Kratos50",
                        "content": "`I got interview in a couple hours but LeetCode streak is more important `"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/gas-station/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One pass.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "fact-1: If car starts at A and can not reach B. Any station between A and B can not reach B.(B is the first station that A can not reach.)\\nfact-2: If the total number of gas is bigger than the total number of cost. There must be a solution.\\n\\nproof copied from mgh: https://leetcode.com/problems/gas-station/discuss/42568/Share-some-of-my-ideas.\\n\\nproof-1: In any station between A and B, let\\'s say C. C will have gas left in our tank, if we go from A to that station. We can\\'t reach B from A with some gas(may be 0) left in the tank in C, so we can\\'t reach B from C with an empty tank.\\n\\nproof-2: If the gas is more than the cost in total, there must be some stations we have enough gas to go through them. Let\\'s say they are **green** stations. So the other stations are **red**. The **adjacent stations** with **same color** can be joined together as one. Then there must be a red station that can be joined into a precedent green station unless there isn\\'t any red station, because the total gas is more than the total cost. In other words, all of the stations will join into a green station at last.\\n\\nthen reversely how we merge the stations, we can find the first station.\\n[G]<-[G,R]: start from first station in G\\n[G]<-[G,R]<-[G,R,G,R]:\\n\\nhere lets denote [GRGR] as [G1R1G2R2], then:\\n1. G1-R1+G2 > R2 but G1-R1<0, then we start from first station in G2\\n2. G1-R1>0 and G2-R2>0, start from first station in either G1 or G2"
                    },
                    {
                        "username": "sjy",
                        "content": "I submit my codes (which are successful compiled  by my local compiler) and the OJ return\\n\"Compile Error: cannot access JsonArray\". \\nThen I copied and submitted some AC solutions from discuss sections, the OJ just return the same Error.\\nThen I just code  \"return 1;\" and try to get a \"Wrong Ans\", but the OJ still return Compile Error.  \\nFYI:  my web browser is Chromium, the Chrome for Linux."
                    },
                    {
                        "username": "sohochaser",
                        "content": "For example, I start from 4th station, the last station will be the 3rd one, do I need travel from 3rd to the 4th as 4th is the starting station?"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "[@Dhananjay40](/Dhananjay40) lol"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@naveenve1609](/naveenve1609) He\\'s prolly Done done with this problem after 9 freaking years"
                    },
                    {
                        "username": "naveenve1609",
                        "content": "Yes, its need to travel to 4th station to complete the circuit "
                    },
                    {
                        "username": "MaddyCoderBack",
                        "content": "just use simple greedy technique just follow these steps\\n1. total_gas_sum <total_cost_sum return -1;\\n2. define two var start=0, curr_sum=0;\\n3. now iterate over loop i=0 to i=gas.size();\\n4 curr=(gas[i]-cost[i]) \\n5. if(curr<0) \\n6. increment start=start+1;\\n7. and set curr=0;\\n8. at the end return start."
                    },
                    {
                        "username": "cannium",
                        "content": "Or the car just visit every gas station once?"
                    },
                    {
                        "username": "ravisvats",
                        "content": "Here are more sample inputs, try these before submitting.\\ngas = [1,2,3,4,5]\\ncost = [3,4,5,1,2]\\ngas = [5, 1, 2, 3, 4]\\ncost = [4, 4, 1, 5, 1]\\ngas = [2]\\ncost = [2]\\ngas = [3,1,1]\\ncost = [1,2,2]"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[3,2,1,1,4]\\ncost=[2,1,2,3,2]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "The last sentence from the problem description states \"If there exists a solution, it is **guaranteed** to be **unique**\"\n\nThis is violated for testcases similar to the 40th testcase, for example, if `gas=[2,0,0]` `cost=[0,1,0]` the expected answer is `0`.\nHowever, one can also start from `2` and complete the circuit.\n\nSince this is a circular problem, a simple rotation should still work.\nIf the rotated version was manually inputted as a custom testcase `gas=[0,2,0]` `cost=[0,0,1]`, the answer from the official testcase should also be rotated to `1`.\nHowever, the system says \"Invalid Testcase\" and \"The answer should be unique.\"\n\nMeaning that the system successfully detects there are non-unique solutions for `gas=[0,2,0]` `cost=[0,0,1]`, but fails to detect it in the official testcase ` gas=[2,0,0]` `cost=[0,1,0]`"
                    },
                    {
                        "username": "gjulianm",
                        "content": "One of the test cases does not have a unique solution. It\\'s gas = [2,0, lotsofzeros] with cost = [0,1,0,lotsofzeros]. With those parameters, any station other than 1 is a valid solution. That test case should be invalidated."
                    }
                ]
            },
            {
                "id": 1566751,
                "content": [
                    {
                        "username": "Kratos50",
                        "content": "`I got interview in a couple hours but LeetCode streak is more important `"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/gas-station/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One pass.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "fact-1: If car starts at A and can not reach B. Any station between A and B can not reach B.(B is the first station that A can not reach.)\\nfact-2: If the total number of gas is bigger than the total number of cost. There must be a solution.\\n\\nproof copied from mgh: https://leetcode.com/problems/gas-station/discuss/42568/Share-some-of-my-ideas.\\n\\nproof-1: In any station between A and B, let\\'s say C. C will have gas left in our tank, if we go from A to that station. We can\\'t reach B from A with some gas(may be 0) left in the tank in C, so we can\\'t reach B from C with an empty tank.\\n\\nproof-2: If the gas is more than the cost in total, there must be some stations we have enough gas to go through them. Let\\'s say they are **green** stations. So the other stations are **red**. The **adjacent stations** with **same color** can be joined together as one. Then there must be a red station that can be joined into a precedent green station unless there isn\\'t any red station, because the total gas is more than the total cost. In other words, all of the stations will join into a green station at last.\\n\\nthen reversely how we merge the stations, we can find the first station.\\n[G]<-[G,R]: start from first station in G\\n[G]<-[G,R]<-[G,R,G,R]:\\n\\nhere lets denote [GRGR] as [G1R1G2R2], then:\\n1. G1-R1+G2 > R2 but G1-R1<0, then we start from first station in G2\\n2. G1-R1>0 and G2-R2>0, start from first station in either G1 or G2"
                    },
                    {
                        "username": "sjy",
                        "content": "I submit my codes (which are successful compiled  by my local compiler) and the OJ return\\n\"Compile Error: cannot access JsonArray\". \\nThen I copied and submitted some AC solutions from discuss sections, the OJ just return the same Error.\\nThen I just code  \"return 1;\" and try to get a \"Wrong Ans\", but the OJ still return Compile Error.  \\nFYI:  my web browser is Chromium, the Chrome for Linux."
                    },
                    {
                        "username": "sohochaser",
                        "content": "For example, I start from 4th station, the last station will be the 3rd one, do I need travel from 3rd to the 4th as 4th is the starting station?"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "[@Dhananjay40](/Dhananjay40) lol"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@naveenve1609](/naveenve1609) He\\'s prolly Done done with this problem after 9 freaking years"
                    },
                    {
                        "username": "naveenve1609",
                        "content": "Yes, its need to travel to 4th station to complete the circuit "
                    },
                    {
                        "username": "MaddyCoderBack",
                        "content": "just use simple greedy technique just follow these steps\\n1. total_gas_sum <total_cost_sum return -1;\\n2. define two var start=0, curr_sum=0;\\n3. now iterate over loop i=0 to i=gas.size();\\n4 curr=(gas[i]-cost[i]) \\n5. if(curr<0) \\n6. increment start=start+1;\\n7. and set curr=0;\\n8. at the end return start."
                    },
                    {
                        "username": "cannium",
                        "content": "Or the car just visit every gas station once?"
                    },
                    {
                        "username": "ravisvats",
                        "content": "Here are more sample inputs, try these before submitting.\\ngas = [1,2,3,4,5]\\ncost = [3,4,5,1,2]\\ngas = [5, 1, 2, 3, 4]\\ncost = [4, 4, 1, 5, 1]\\ngas = [2]\\ncost = [2]\\ngas = [3,1,1]\\ncost = [1,2,2]"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[3,2,1,1,4]\\ncost=[2,1,2,3,2]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "The last sentence from the problem description states \"If there exists a solution, it is **guaranteed** to be **unique**\"\n\nThis is violated for testcases similar to the 40th testcase, for example, if `gas=[2,0,0]` `cost=[0,1,0]` the expected answer is `0`.\nHowever, one can also start from `2` and complete the circuit.\n\nSince this is a circular problem, a simple rotation should still work.\nIf the rotated version was manually inputted as a custom testcase `gas=[0,2,0]` `cost=[0,0,1]`, the answer from the official testcase should also be rotated to `1`.\nHowever, the system says \"Invalid Testcase\" and \"The answer should be unique.\"\n\nMeaning that the system successfully detects there are non-unique solutions for `gas=[0,2,0]` `cost=[0,0,1]`, but fails to detect it in the official testcase ` gas=[2,0,0]` `cost=[0,1,0]`"
                    },
                    {
                        "username": "gjulianm",
                        "content": "One of the test cases does not have a unique solution. It\\'s gas = [2,0, lotsofzeros] with cost = [0,1,0,lotsofzeros]. With those parameters, any station other than 1 is a valid solution. That test case should be invalidated."
                    }
                ]
            },
            {
                "id": 1745773,
                "content": [
                    {
                        "username": "Kratos50",
                        "content": "`I got interview in a couple hours but LeetCode streak is more important `"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/gas-station/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One pass.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "fact-1: If car starts at A and can not reach B. Any station between A and B can not reach B.(B is the first station that A can not reach.)\\nfact-2: If the total number of gas is bigger than the total number of cost. There must be a solution.\\n\\nproof copied from mgh: https://leetcode.com/problems/gas-station/discuss/42568/Share-some-of-my-ideas.\\n\\nproof-1: In any station between A and B, let\\'s say C. C will have gas left in our tank, if we go from A to that station. We can\\'t reach B from A with some gas(may be 0) left in the tank in C, so we can\\'t reach B from C with an empty tank.\\n\\nproof-2: If the gas is more than the cost in total, there must be some stations we have enough gas to go through them. Let\\'s say they are **green** stations. So the other stations are **red**. The **adjacent stations** with **same color** can be joined together as one. Then there must be a red station that can be joined into a precedent green station unless there isn\\'t any red station, because the total gas is more than the total cost. In other words, all of the stations will join into a green station at last.\\n\\nthen reversely how we merge the stations, we can find the first station.\\n[G]<-[G,R]: start from first station in G\\n[G]<-[G,R]<-[G,R,G,R]:\\n\\nhere lets denote [GRGR] as [G1R1G2R2], then:\\n1. G1-R1+G2 > R2 but G1-R1<0, then we start from first station in G2\\n2. G1-R1>0 and G2-R2>0, start from first station in either G1 or G2"
                    },
                    {
                        "username": "sjy",
                        "content": "I submit my codes (which are successful compiled  by my local compiler) and the OJ return\\n\"Compile Error: cannot access JsonArray\". \\nThen I copied and submitted some AC solutions from discuss sections, the OJ just return the same Error.\\nThen I just code  \"return 1;\" and try to get a \"Wrong Ans\", but the OJ still return Compile Error.  \\nFYI:  my web browser is Chromium, the Chrome for Linux."
                    },
                    {
                        "username": "sohochaser",
                        "content": "For example, I start from 4th station, the last station will be the 3rd one, do I need travel from 3rd to the 4th as 4th is the starting station?"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "[@Dhananjay40](/Dhananjay40) lol"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@naveenve1609](/naveenve1609) He\\'s prolly Done done with this problem after 9 freaking years"
                    },
                    {
                        "username": "naveenve1609",
                        "content": "Yes, its need to travel to 4th station to complete the circuit "
                    },
                    {
                        "username": "MaddyCoderBack",
                        "content": "just use simple greedy technique just follow these steps\\n1. total_gas_sum <total_cost_sum return -1;\\n2. define two var start=0, curr_sum=0;\\n3. now iterate over loop i=0 to i=gas.size();\\n4 curr=(gas[i]-cost[i]) \\n5. if(curr<0) \\n6. increment start=start+1;\\n7. and set curr=0;\\n8. at the end return start."
                    },
                    {
                        "username": "cannium",
                        "content": "Or the car just visit every gas station once?"
                    },
                    {
                        "username": "ravisvats",
                        "content": "Here are more sample inputs, try these before submitting.\\ngas = [1,2,3,4,5]\\ncost = [3,4,5,1,2]\\ngas = [5, 1, 2, 3, 4]\\ncost = [4, 4, 1, 5, 1]\\ngas = [2]\\ncost = [2]\\ngas = [3,1,1]\\ncost = [1,2,2]"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[3,2,1,1,4]\\ncost=[2,1,2,3,2]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "The last sentence from the problem description states \"If there exists a solution, it is **guaranteed** to be **unique**\"\n\nThis is violated for testcases similar to the 40th testcase, for example, if `gas=[2,0,0]` `cost=[0,1,0]` the expected answer is `0`.\nHowever, one can also start from `2` and complete the circuit.\n\nSince this is a circular problem, a simple rotation should still work.\nIf the rotated version was manually inputted as a custom testcase `gas=[0,2,0]` `cost=[0,0,1]`, the answer from the official testcase should also be rotated to `1`.\nHowever, the system says \"Invalid Testcase\" and \"The answer should be unique.\"\n\nMeaning that the system successfully detects there are non-unique solutions for `gas=[0,2,0]` `cost=[0,0,1]`, but fails to detect it in the official testcase ` gas=[2,0,0]` `cost=[0,1,0]`"
                    },
                    {
                        "username": "gjulianm",
                        "content": "One of the test cases does not have a unique solution. It\\'s gas = [2,0, lotsofzeros] with cost = [0,1,0,lotsofzeros]. With those parameters, any station other than 1 is a valid solution. That test case should be invalidated."
                    }
                ]
            },
            {
                "id": 1567209,
                "content": [
                    {
                        "username": "Kratos50",
                        "content": "`I got interview in a couple hours but LeetCode streak is more important `"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/gas-station/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One pass.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "fact-1: If car starts at A and can not reach B. Any station between A and B can not reach B.(B is the first station that A can not reach.)\\nfact-2: If the total number of gas is bigger than the total number of cost. There must be a solution.\\n\\nproof copied from mgh: https://leetcode.com/problems/gas-station/discuss/42568/Share-some-of-my-ideas.\\n\\nproof-1: In any station between A and B, let\\'s say C. C will have gas left in our tank, if we go from A to that station. We can\\'t reach B from A with some gas(may be 0) left in the tank in C, so we can\\'t reach B from C with an empty tank.\\n\\nproof-2: If the gas is more than the cost in total, there must be some stations we have enough gas to go through them. Let\\'s say they are **green** stations. So the other stations are **red**. The **adjacent stations** with **same color** can be joined together as one. Then there must be a red station that can be joined into a precedent green station unless there isn\\'t any red station, because the total gas is more than the total cost. In other words, all of the stations will join into a green station at last.\\n\\nthen reversely how we merge the stations, we can find the first station.\\n[G]<-[G,R]: start from first station in G\\n[G]<-[G,R]<-[G,R,G,R]:\\n\\nhere lets denote [GRGR] as [G1R1G2R2], then:\\n1. G1-R1+G2 > R2 but G1-R1<0, then we start from first station in G2\\n2. G1-R1>0 and G2-R2>0, start from first station in either G1 or G2"
                    },
                    {
                        "username": "sjy",
                        "content": "I submit my codes (which are successful compiled  by my local compiler) and the OJ return\\n\"Compile Error: cannot access JsonArray\". \\nThen I copied and submitted some AC solutions from discuss sections, the OJ just return the same Error.\\nThen I just code  \"return 1;\" and try to get a \"Wrong Ans\", but the OJ still return Compile Error.  \\nFYI:  my web browser is Chromium, the Chrome for Linux."
                    },
                    {
                        "username": "sohochaser",
                        "content": "For example, I start from 4th station, the last station will be the 3rd one, do I need travel from 3rd to the 4th as 4th is the starting station?"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "[@Dhananjay40](/Dhananjay40) lol"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@naveenve1609](/naveenve1609) He\\'s prolly Done done with this problem after 9 freaking years"
                    },
                    {
                        "username": "naveenve1609",
                        "content": "Yes, its need to travel to 4th station to complete the circuit "
                    },
                    {
                        "username": "MaddyCoderBack",
                        "content": "just use simple greedy technique just follow these steps\\n1. total_gas_sum <total_cost_sum return -1;\\n2. define two var start=0, curr_sum=0;\\n3. now iterate over loop i=0 to i=gas.size();\\n4 curr=(gas[i]-cost[i]) \\n5. if(curr<0) \\n6. increment start=start+1;\\n7. and set curr=0;\\n8. at the end return start."
                    },
                    {
                        "username": "cannium",
                        "content": "Or the car just visit every gas station once?"
                    },
                    {
                        "username": "ravisvats",
                        "content": "Here are more sample inputs, try these before submitting.\\ngas = [1,2,3,4,5]\\ncost = [3,4,5,1,2]\\ngas = [5, 1, 2, 3, 4]\\ncost = [4, 4, 1, 5, 1]\\ngas = [2]\\ncost = [2]\\ngas = [3,1,1]\\ncost = [1,2,2]"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[3,2,1,1,4]\\ncost=[2,1,2,3,2]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "The last sentence from the problem description states \"If there exists a solution, it is **guaranteed** to be **unique**\"\n\nThis is violated for testcases similar to the 40th testcase, for example, if `gas=[2,0,0]` `cost=[0,1,0]` the expected answer is `0`.\nHowever, one can also start from `2` and complete the circuit.\n\nSince this is a circular problem, a simple rotation should still work.\nIf the rotated version was manually inputted as a custom testcase `gas=[0,2,0]` `cost=[0,0,1]`, the answer from the official testcase should also be rotated to `1`.\nHowever, the system says \"Invalid Testcase\" and \"The answer should be unique.\"\n\nMeaning that the system successfully detects there are non-unique solutions for `gas=[0,2,0]` `cost=[0,0,1]`, but fails to detect it in the official testcase ` gas=[2,0,0]` `cost=[0,1,0]`"
                    },
                    {
                        "username": "gjulianm",
                        "content": "One of the test cases does not have a unique solution. It\\'s gas = [2,0, lotsofzeros] with cost = [0,1,0,lotsofzeros]. With those parameters, any station other than 1 is a valid solution. That test case should be invalidated."
                    }
                ]
            },
            {
                "id": 1971195,
                "content": [
                    {
                        "username": "Kratos50",
                        "content": "`I got interview in a couple hours but LeetCode streak is more important `"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/gas-station/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One pass.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "fact-1: If car starts at A and can not reach B. Any station between A and B can not reach B.(B is the first station that A can not reach.)\\nfact-2: If the total number of gas is bigger than the total number of cost. There must be a solution.\\n\\nproof copied from mgh: https://leetcode.com/problems/gas-station/discuss/42568/Share-some-of-my-ideas.\\n\\nproof-1: In any station between A and B, let\\'s say C. C will have gas left in our tank, if we go from A to that station. We can\\'t reach B from A with some gas(may be 0) left in the tank in C, so we can\\'t reach B from C with an empty tank.\\n\\nproof-2: If the gas is more than the cost in total, there must be some stations we have enough gas to go through them. Let\\'s say they are **green** stations. So the other stations are **red**. The **adjacent stations** with **same color** can be joined together as one. Then there must be a red station that can be joined into a precedent green station unless there isn\\'t any red station, because the total gas is more than the total cost. In other words, all of the stations will join into a green station at last.\\n\\nthen reversely how we merge the stations, we can find the first station.\\n[G]<-[G,R]: start from first station in G\\n[G]<-[G,R]<-[G,R,G,R]:\\n\\nhere lets denote [GRGR] as [G1R1G2R2], then:\\n1. G1-R1+G2 > R2 but G1-R1<0, then we start from first station in G2\\n2. G1-R1>0 and G2-R2>0, start from first station in either G1 or G2"
                    },
                    {
                        "username": "sjy",
                        "content": "I submit my codes (which are successful compiled  by my local compiler) and the OJ return\\n\"Compile Error: cannot access JsonArray\". \\nThen I copied and submitted some AC solutions from discuss sections, the OJ just return the same Error.\\nThen I just code  \"return 1;\" and try to get a \"Wrong Ans\", but the OJ still return Compile Error.  \\nFYI:  my web browser is Chromium, the Chrome for Linux."
                    },
                    {
                        "username": "sohochaser",
                        "content": "For example, I start from 4th station, the last station will be the 3rd one, do I need travel from 3rd to the 4th as 4th is the starting station?"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "[@Dhananjay40](/Dhananjay40) lol"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@naveenve1609](/naveenve1609) He\\'s prolly Done done with this problem after 9 freaking years"
                    },
                    {
                        "username": "naveenve1609",
                        "content": "Yes, its need to travel to 4th station to complete the circuit "
                    },
                    {
                        "username": "MaddyCoderBack",
                        "content": "just use simple greedy technique just follow these steps\\n1. total_gas_sum <total_cost_sum return -1;\\n2. define two var start=0, curr_sum=0;\\n3. now iterate over loop i=0 to i=gas.size();\\n4 curr=(gas[i]-cost[i]) \\n5. if(curr<0) \\n6. increment start=start+1;\\n7. and set curr=0;\\n8. at the end return start."
                    },
                    {
                        "username": "cannium",
                        "content": "Or the car just visit every gas station once?"
                    },
                    {
                        "username": "ravisvats",
                        "content": "Here are more sample inputs, try these before submitting.\\ngas = [1,2,3,4,5]\\ncost = [3,4,5,1,2]\\ngas = [5, 1, 2, 3, 4]\\ncost = [4, 4, 1, 5, 1]\\ngas = [2]\\ncost = [2]\\ngas = [3,1,1]\\ncost = [1,2,2]"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[3,2,1,1,4]\\ncost=[2,1,2,3,2]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "The last sentence from the problem description states \"If there exists a solution, it is **guaranteed** to be **unique**\"\n\nThis is violated for testcases similar to the 40th testcase, for example, if `gas=[2,0,0]` `cost=[0,1,0]` the expected answer is `0`.\nHowever, one can also start from `2` and complete the circuit.\n\nSince this is a circular problem, a simple rotation should still work.\nIf the rotated version was manually inputted as a custom testcase `gas=[0,2,0]` `cost=[0,0,1]`, the answer from the official testcase should also be rotated to `1`.\nHowever, the system says \"Invalid Testcase\" and \"The answer should be unique.\"\n\nMeaning that the system successfully detects there are non-unique solutions for `gas=[0,2,0]` `cost=[0,0,1]`, but fails to detect it in the official testcase ` gas=[2,0,0]` `cost=[0,1,0]`"
                    },
                    {
                        "username": "gjulianm",
                        "content": "One of the test cases does not have a unique solution. It\\'s gas = [2,0, lotsofzeros] with cost = [0,1,0,lotsofzeros]. With those parameters, any station other than 1 is a valid solution. That test case should be invalidated."
                    }
                ]
            },
            {
                "id": 1934048,
                "content": [
                    {
                        "username": "Kratos50",
                        "content": "`I got interview in a couple hours but LeetCode streak is more important `"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/gas-station/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One pass.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "fact-1: If car starts at A and can not reach B. Any station between A and B can not reach B.(B is the first station that A can not reach.)\\nfact-2: If the total number of gas is bigger than the total number of cost. There must be a solution.\\n\\nproof copied from mgh: https://leetcode.com/problems/gas-station/discuss/42568/Share-some-of-my-ideas.\\n\\nproof-1: In any station between A and B, let\\'s say C. C will have gas left in our tank, if we go from A to that station. We can\\'t reach B from A with some gas(may be 0) left in the tank in C, so we can\\'t reach B from C with an empty tank.\\n\\nproof-2: If the gas is more than the cost in total, there must be some stations we have enough gas to go through them. Let\\'s say they are **green** stations. So the other stations are **red**. The **adjacent stations** with **same color** can be joined together as one. Then there must be a red station that can be joined into a precedent green station unless there isn\\'t any red station, because the total gas is more than the total cost. In other words, all of the stations will join into a green station at last.\\n\\nthen reversely how we merge the stations, we can find the first station.\\n[G]<-[G,R]: start from first station in G\\n[G]<-[G,R]<-[G,R,G,R]:\\n\\nhere lets denote [GRGR] as [G1R1G2R2], then:\\n1. G1-R1+G2 > R2 but G1-R1<0, then we start from first station in G2\\n2. G1-R1>0 and G2-R2>0, start from first station in either G1 or G2"
                    },
                    {
                        "username": "sjy",
                        "content": "I submit my codes (which are successful compiled  by my local compiler) and the OJ return\\n\"Compile Error: cannot access JsonArray\". \\nThen I copied and submitted some AC solutions from discuss sections, the OJ just return the same Error.\\nThen I just code  \"return 1;\" and try to get a \"Wrong Ans\", but the OJ still return Compile Error.  \\nFYI:  my web browser is Chromium, the Chrome for Linux."
                    },
                    {
                        "username": "sohochaser",
                        "content": "For example, I start from 4th station, the last station will be the 3rd one, do I need travel from 3rd to the 4th as 4th is the starting station?"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "[@Dhananjay40](/Dhananjay40) lol"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@naveenve1609](/naveenve1609) He\\'s prolly Done done with this problem after 9 freaking years"
                    },
                    {
                        "username": "naveenve1609",
                        "content": "Yes, its need to travel to 4th station to complete the circuit "
                    },
                    {
                        "username": "MaddyCoderBack",
                        "content": "just use simple greedy technique just follow these steps\\n1. total_gas_sum <total_cost_sum return -1;\\n2. define two var start=0, curr_sum=0;\\n3. now iterate over loop i=0 to i=gas.size();\\n4 curr=(gas[i]-cost[i]) \\n5. if(curr<0) \\n6. increment start=start+1;\\n7. and set curr=0;\\n8. at the end return start."
                    },
                    {
                        "username": "cannium",
                        "content": "Or the car just visit every gas station once?"
                    },
                    {
                        "username": "ravisvats",
                        "content": "Here are more sample inputs, try these before submitting.\\ngas = [1,2,3,4,5]\\ncost = [3,4,5,1,2]\\ngas = [5, 1, 2, 3, 4]\\ncost = [4, 4, 1, 5, 1]\\ngas = [2]\\ncost = [2]\\ngas = [3,1,1]\\ncost = [1,2,2]"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[3,2,1,1,4]\\ncost=[2,1,2,3,2]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "The last sentence from the problem description states \"If there exists a solution, it is **guaranteed** to be **unique**\"\n\nThis is violated for testcases similar to the 40th testcase, for example, if `gas=[2,0,0]` `cost=[0,1,0]` the expected answer is `0`.\nHowever, one can also start from `2` and complete the circuit.\n\nSince this is a circular problem, a simple rotation should still work.\nIf the rotated version was manually inputted as a custom testcase `gas=[0,2,0]` `cost=[0,0,1]`, the answer from the official testcase should also be rotated to `1`.\nHowever, the system says \"Invalid Testcase\" and \"The answer should be unique.\"\n\nMeaning that the system successfully detects there are non-unique solutions for `gas=[0,2,0]` `cost=[0,0,1]`, but fails to detect it in the official testcase ` gas=[2,0,0]` `cost=[0,1,0]`"
                    },
                    {
                        "username": "gjulianm",
                        "content": "One of the test cases does not have a unique solution. It\\'s gas = [2,0, lotsofzeros] with cost = [0,1,0,lotsofzeros]. With those parameters, any station other than 1 is a valid solution. That test case should be invalidated."
                    }
                ]
            },
            {
                "id": 2038008,
                "content": [
                    {
                        "username": "Kratos50",
                        "content": "`I got interview in a couple hours but LeetCode streak is more important `"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/gas-station/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One pass.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "fact-1: If car starts at A and can not reach B. Any station between A and B can not reach B.(B is the first station that A can not reach.)\\nfact-2: If the total number of gas is bigger than the total number of cost. There must be a solution.\\n\\nproof copied from mgh: https://leetcode.com/problems/gas-station/discuss/42568/Share-some-of-my-ideas.\\n\\nproof-1: In any station between A and B, let\\'s say C. C will have gas left in our tank, if we go from A to that station. We can\\'t reach B from A with some gas(may be 0) left in the tank in C, so we can\\'t reach B from C with an empty tank.\\n\\nproof-2: If the gas is more than the cost in total, there must be some stations we have enough gas to go through them. Let\\'s say they are **green** stations. So the other stations are **red**. The **adjacent stations** with **same color** can be joined together as one. Then there must be a red station that can be joined into a precedent green station unless there isn\\'t any red station, because the total gas is more than the total cost. In other words, all of the stations will join into a green station at last.\\n\\nthen reversely how we merge the stations, we can find the first station.\\n[G]<-[G,R]: start from first station in G\\n[G]<-[G,R]<-[G,R,G,R]:\\n\\nhere lets denote [GRGR] as [G1R1G2R2], then:\\n1. G1-R1+G2 > R2 but G1-R1<0, then we start from first station in G2\\n2. G1-R1>0 and G2-R2>0, start from first station in either G1 or G2"
                    },
                    {
                        "username": "sjy",
                        "content": "I submit my codes (which are successful compiled  by my local compiler) and the OJ return\\n\"Compile Error: cannot access JsonArray\". \\nThen I copied and submitted some AC solutions from discuss sections, the OJ just return the same Error.\\nThen I just code  \"return 1;\" and try to get a \"Wrong Ans\", but the OJ still return Compile Error.  \\nFYI:  my web browser is Chromium, the Chrome for Linux."
                    },
                    {
                        "username": "sohochaser",
                        "content": "For example, I start from 4th station, the last station will be the 3rd one, do I need travel from 3rd to the 4th as 4th is the starting station?"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "[@Dhananjay40](/Dhananjay40) lol"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@naveenve1609](/naveenve1609) He\\'s prolly Done done with this problem after 9 freaking years"
                    },
                    {
                        "username": "naveenve1609",
                        "content": "Yes, its need to travel to 4th station to complete the circuit "
                    },
                    {
                        "username": "MaddyCoderBack",
                        "content": "just use simple greedy technique just follow these steps\\n1. total_gas_sum <total_cost_sum return -1;\\n2. define two var start=0, curr_sum=0;\\n3. now iterate over loop i=0 to i=gas.size();\\n4 curr=(gas[i]-cost[i]) \\n5. if(curr<0) \\n6. increment start=start+1;\\n7. and set curr=0;\\n8. at the end return start."
                    },
                    {
                        "username": "cannium",
                        "content": "Or the car just visit every gas station once?"
                    },
                    {
                        "username": "ravisvats",
                        "content": "Here are more sample inputs, try these before submitting.\\ngas = [1,2,3,4,5]\\ncost = [3,4,5,1,2]\\ngas = [5, 1, 2, 3, 4]\\ncost = [4, 4, 1, 5, 1]\\ngas = [2]\\ncost = [2]\\ngas = [3,1,1]\\ncost = [1,2,2]"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[3,2,1,1,4]\\ncost=[2,1,2,3,2]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "The last sentence from the problem description states \"If there exists a solution, it is **guaranteed** to be **unique**\"\n\nThis is violated for testcases similar to the 40th testcase, for example, if `gas=[2,0,0]` `cost=[0,1,0]` the expected answer is `0`.\nHowever, one can also start from `2` and complete the circuit.\n\nSince this is a circular problem, a simple rotation should still work.\nIf the rotated version was manually inputted as a custom testcase `gas=[0,2,0]` `cost=[0,0,1]`, the answer from the official testcase should also be rotated to `1`.\nHowever, the system says \"Invalid Testcase\" and \"The answer should be unique.\"\n\nMeaning that the system successfully detects there are non-unique solutions for `gas=[0,2,0]` `cost=[0,0,1]`, but fails to detect it in the official testcase ` gas=[2,0,0]` `cost=[0,1,0]`"
                    },
                    {
                        "username": "gjulianm",
                        "content": "One of the test cases does not have a unique solution. It\\'s gas = [2,0, lotsofzeros] with cost = [0,1,0,lotsofzeros]. With those parameters, any station other than 1 is a valid solution. That test case should be invalidated."
                    }
                ]
            },
            {
                "id": 2006186,
                "content": [
                    {
                        "username": "rstone13",
                        "content": "I am proud to say that, by looking at this problem on and off over the past week or so, I managed to come up with a solution without looking at the editorial. To be fair, that\\'s not fast enough to pass an interview, but at least I\\'m getting to where I can come to solutions on my own."
                    },
                    {
                        "username": "S_Basu",
                        "content": "**Can somebody please help me to improve the efficiency?**\\n*I am not posting the solution here as this shows TLE just asking for suggestions for improvisation*\\n- This is showing **Time Limit Exceeded**.\\n- It successfully ran 35 out of 37 test cases.\\n- It\\'s time complexity is $$O(n.n)$$\\n\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) \\n    {\\n        int len = gas.length;\\n        for(int i=0; i<len; i++)\\n        {\\n            int gasRem = 0;\\n            for(int j=i;j<len; j++)\\n            {\\n                gasRem += gas[j]-cost[j];\\n                if(gasRem>=0)\\n                    continue;\\n                else\\n                    break;\\n            }\\n            for(int j=0;j<i; j++)\\n            {\\n                if(gasRem>=0)\\n                    gasRem += gas[j]-cost[j];\\n                if(gasRem>=0)\\n                    continue;\\n                else\\n                    break;\\n            }\\n            if(gasRem>=0)\\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@tusharthakur05](/tusharthakur05)  Yes in my case all testcases passed only when it was reduced to $$O(n)$$"
                    },
                    {
                        "username": "tusharthakur05",
                        "content": "I was also solving this problem in the same way.\\nbut you need to reduce its complexity to O(N)."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Easy if we see this problem lightly:\\n- Return -1 if sum of total costs is greater than sum of total gas we can obtain\\n- After that, we can try from initial station, If total gas remaining  becomes less than 0 reaching any station, reset the collected gas, and try again from next station from where it is currently at. This way, you can find the starting station which will not reach less than 0 while traveling.\\nHints: No need for while loop, no need to access earlier indexes after reaching final index of station."
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@Prashant Ghimire](/prashantghi8) sir can you give a bit detailed explanation please. It would mean a lot (pls a bit explanation with a short example if possible)."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "[@abhi098](/abhi098) If you are iterating from the first index(earliest) to further. and when you reach the last index, why do you now have to go back to earlier index? The earlier indexes will already be checked right- when we reach till final?? I think my last sentence is not clear to what i wanted to mean"
                    },
                    {
                        "username": "abhi098",
                        "content": "why \"no need to access earlier indexes after reaching final index of station.\" ??\\n"
                    },
                    {
                        "username": "naveen17797",
                        "content": "Replace \"costs\" with \"fuel usage\", had to reread several times to understand the example"
                    },
                    {
                        "username": "nainikatrivedi05",
                        "content": "runtime error :("
                    },
                    {
                        "username": "alok900000",
                        "content": "Hi everyone can anybody solve my problem as it is showing 37/37 test case passed  for this code but also showing time limit exceed\\n class Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n\\n     int answer=0,k=0;\\n\\n         for(int i=0;i<gas.length;i++)\\n         {\\n           k=0;\\n           answer=gas[i];\\n           if(answer==0)\\n           continue;\\n           else if(answer-cost[i]<0)\\n           continue;\\n            for(int j=i;k<gas.length;j++)\\n            {\\n                  if(answer-cost[j%gas.length]>=0)\\n                  answer=answer-cost[j%gas.length]+gas[(j+1)%gas.length];\\n                  else\\n                    break;\\n                 ++k;\\n            }\\n            if(k==gas.length)\\n            return i;\\n         }\\n         return -1;\\n    }\\n}"
                    },
                    {
                        "username": "ssm2252221",
                        "content": "For Input [5, 5, 1, 3, 4] [8, 1, 7, 1, 1] there are more then one possible solutios (4 & 3)  but acc to statement if there is a solution iw will be unique.\\nCan anyone clarify?"
                    },
                    {
                        "username": "notphoenix",
                        "content": "Here I am still driving cycle !xD"
                    },
                    {
                        "username": "pandey11082000",
                        "content": "lol "
                    },
                    {
                        "username": "LoSeR101",
                        "content": "Hi guys wont index =2 (station =2 ) also give the answer for the  very first test case?\\n gas = [1,2,3,4,5], cost = [3,4,5,1,2]\\n\\nMy version of dry running it \\n initial gas =3+0\\n To reach station 3 : 3+4-5=2\\n To reach station 4 : 2+5-1=6\\n To reach station 0 : 6+1-2=5\\n To reach station 1 : 5+2-3=4\\nNow to reach station 2  from 1 the cost is 4 ..so why isn\\'t this the answer please help\\n                           \\n\\n"
                    },
                    {
                        "username": "LoSeR101",
                        "content": "[@prashantghi8](/prashantghi8)  got it! Thank you for answering my silly doubt"
                    },
                    {
                        "username": "LoSeR101",
                        "content": "[@thisannie](/thisannie) right now i understood it . Thank you for answering my silly doubt "
                    },
                    {
                        "username": "thisannie",
                        "content": "No. it wont because the gas of index 3 will be added to tank only after you reach there and in order to reach to station 3 you need 5 units of gas but you only have 3 units in your tank so index is not answer."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "How are you going to station 3 from 2 if it costs 5 and you only got 3???"
                    },
                    {
                        "username": "anirban1",
                        "content": "# Intuition\\nLet `prefSum` be the array of summation of `gas[i]-cost[i]` for $$0<=i<length(gas)$$.\\nLet `i-th` element be the global minima in the `prefSum` array, then `(i+1)-th` index is our answer if and only if our `prefSum` ends in a non-negative value.\\n\\n# Approach\\nCalculate prefix sum of the `gas[i]-cost[i]` & keep track of global minimum value. If at any point the sum is greater than the global minimum value record the index at this point and continue.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        idx,s,g_min=-1,0,0\\n        for i in range(len(gas)):\\n            s+=gas[i]-cost[i]\\n            if s<g_min:\\n                g_min=s\\n                idx=-1\\n            elif idx==-1:\\n                idx=i\\n        return idx if s>=0 else -1\\n```"
                    }
                ]
            },
            {
                "id": 1746038,
                "content": [
                    {
                        "username": "rstone13",
                        "content": "I am proud to say that, by looking at this problem on and off over the past week or so, I managed to come up with a solution without looking at the editorial. To be fair, that\\'s not fast enough to pass an interview, but at least I\\'m getting to where I can come to solutions on my own."
                    },
                    {
                        "username": "S_Basu",
                        "content": "**Can somebody please help me to improve the efficiency?**\\n*I am not posting the solution here as this shows TLE just asking for suggestions for improvisation*\\n- This is showing **Time Limit Exceeded**.\\n- It successfully ran 35 out of 37 test cases.\\n- It\\'s time complexity is $$O(n.n)$$\\n\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) \\n    {\\n        int len = gas.length;\\n        for(int i=0; i<len; i++)\\n        {\\n            int gasRem = 0;\\n            for(int j=i;j<len; j++)\\n            {\\n                gasRem += gas[j]-cost[j];\\n                if(gasRem>=0)\\n                    continue;\\n                else\\n                    break;\\n            }\\n            for(int j=0;j<i; j++)\\n            {\\n                if(gasRem>=0)\\n                    gasRem += gas[j]-cost[j];\\n                if(gasRem>=0)\\n                    continue;\\n                else\\n                    break;\\n            }\\n            if(gasRem>=0)\\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@tusharthakur05](/tusharthakur05)  Yes in my case all testcases passed only when it was reduced to $$O(n)$$"
                    },
                    {
                        "username": "tusharthakur05",
                        "content": "I was also solving this problem in the same way.\\nbut you need to reduce its complexity to O(N)."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Easy if we see this problem lightly:\\n- Return -1 if sum of total costs is greater than sum of total gas we can obtain\\n- After that, we can try from initial station, If total gas remaining  becomes less than 0 reaching any station, reset the collected gas, and try again from next station from where it is currently at. This way, you can find the starting station which will not reach less than 0 while traveling.\\nHints: No need for while loop, no need to access earlier indexes after reaching final index of station."
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@Prashant Ghimire](/prashantghi8) sir can you give a bit detailed explanation please. It would mean a lot (pls a bit explanation with a short example if possible)."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "[@abhi098](/abhi098) If you are iterating from the first index(earliest) to further. and when you reach the last index, why do you now have to go back to earlier index? The earlier indexes will already be checked right- when we reach till final?? I think my last sentence is not clear to what i wanted to mean"
                    },
                    {
                        "username": "abhi098",
                        "content": "why \"no need to access earlier indexes after reaching final index of station.\" ??\\n"
                    },
                    {
                        "username": "naveen17797",
                        "content": "Replace \"costs\" with \"fuel usage\", had to reread several times to understand the example"
                    },
                    {
                        "username": "nainikatrivedi05",
                        "content": "runtime error :("
                    },
                    {
                        "username": "alok900000",
                        "content": "Hi everyone can anybody solve my problem as it is showing 37/37 test case passed  for this code but also showing time limit exceed\\n class Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n\\n     int answer=0,k=0;\\n\\n         for(int i=0;i<gas.length;i++)\\n         {\\n           k=0;\\n           answer=gas[i];\\n           if(answer==0)\\n           continue;\\n           else if(answer-cost[i]<0)\\n           continue;\\n            for(int j=i;k<gas.length;j++)\\n            {\\n                  if(answer-cost[j%gas.length]>=0)\\n                  answer=answer-cost[j%gas.length]+gas[(j+1)%gas.length];\\n                  else\\n                    break;\\n                 ++k;\\n            }\\n            if(k==gas.length)\\n            return i;\\n         }\\n         return -1;\\n    }\\n}"
                    },
                    {
                        "username": "ssm2252221",
                        "content": "For Input [5, 5, 1, 3, 4] [8, 1, 7, 1, 1] there are more then one possible solutios (4 & 3)  but acc to statement if there is a solution iw will be unique.\\nCan anyone clarify?"
                    },
                    {
                        "username": "notphoenix",
                        "content": "Here I am still driving cycle !xD"
                    },
                    {
                        "username": "pandey11082000",
                        "content": "lol "
                    },
                    {
                        "username": "LoSeR101",
                        "content": "Hi guys wont index =2 (station =2 ) also give the answer for the  very first test case?\\n gas = [1,2,3,4,5], cost = [3,4,5,1,2]\\n\\nMy version of dry running it \\n initial gas =3+0\\n To reach station 3 : 3+4-5=2\\n To reach station 4 : 2+5-1=6\\n To reach station 0 : 6+1-2=5\\n To reach station 1 : 5+2-3=4\\nNow to reach station 2  from 1 the cost is 4 ..so why isn\\'t this the answer please help\\n                           \\n\\n"
                    },
                    {
                        "username": "LoSeR101",
                        "content": "[@prashantghi8](/prashantghi8)  got it! Thank you for answering my silly doubt"
                    },
                    {
                        "username": "LoSeR101",
                        "content": "[@thisannie](/thisannie) right now i understood it . Thank you for answering my silly doubt "
                    },
                    {
                        "username": "thisannie",
                        "content": "No. it wont because the gas of index 3 will be added to tank only after you reach there and in order to reach to station 3 you need 5 units of gas but you only have 3 units in your tank so index is not answer."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "How are you going to station 3 from 2 if it costs 5 and you only got 3???"
                    },
                    {
                        "username": "anirban1",
                        "content": "# Intuition\\nLet `prefSum` be the array of summation of `gas[i]-cost[i]` for $$0<=i<length(gas)$$.\\nLet `i-th` element be the global minima in the `prefSum` array, then `(i+1)-th` index is our answer if and only if our `prefSum` ends in a non-negative value.\\n\\n# Approach\\nCalculate prefix sum of the `gas[i]-cost[i]` & keep track of global minimum value. If at any point the sum is greater than the global minimum value record the index at this point and continue.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        idx,s,g_min=-1,0,0\\n        for i in range(len(gas)):\\n            s+=gas[i]-cost[i]\\n            if s<g_min:\\n                g_min=s\\n                idx=-1\\n            elif idx==-1:\\n                idx=i\\n        return idx if s>=0 else -1\\n```"
                    }
                ]
            },
            {
                "id": 1745927,
                "content": [
                    {
                        "username": "rstone13",
                        "content": "I am proud to say that, by looking at this problem on and off over the past week or so, I managed to come up with a solution without looking at the editorial. To be fair, that\\'s not fast enough to pass an interview, but at least I\\'m getting to where I can come to solutions on my own."
                    },
                    {
                        "username": "S_Basu",
                        "content": "**Can somebody please help me to improve the efficiency?**\\n*I am not posting the solution here as this shows TLE just asking for suggestions for improvisation*\\n- This is showing **Time Limit Exceeded**.\\n- It successfully ran 35 out of 37 test cases.\\n- It\\'s time complexity is $$O(n.n)$$\\n\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) \\n    {\\n        int len = gas.length;\\n        for(int i=0; i<len; i++)\\n        {\\n            int gasRem = 0;\\n            for(int j=i;j<len; j++)\\n            {\\n                gasRem += gas[j]-cost[j];\\n                if(gasRem>=0)\\n                    continue;\\n                else\\n                    break;\\n            }\\n            for(int j=0;j<i; j++)\\n            {\\n                if(gasRem>=0)\\n                    gasRem += gas[j]-cost[j];\\n                if(gasRem>=0)\\n                    continue;\\n                else\\n                    break;\\n            }\\n            if(gasRem>=0)\\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@tusharthakur05](/tusharthakur05)  Yes in my case all testcases passed only when it was reduced to $$O(n)$$"
                    },
                    {
                        "username": "tusharthakur05",
                        "content": "I was also solving this problem in the same way.\\nbut you need to reduce its complexity to O(N)."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Easy if we see this problem lightly:\\n- Return -1 if sum of total costs is greater than sum of total gas we can obtain\\n- After that, we can try from initial station, If total gas remaining  becomes less than 0 reaching any station, reset the collected gas, and try again from next station from where it is currently at. This way, you can find the starting station which will not reach less than 0 while traveling.\\nHints: No need for while loop, no need to access earlier indexes after reaching final index of station."
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@Prashant Ghimire](/prashantghi8) sir can you give a bit detailed explanation please. It would mean a lot (pls a bit explanation with a short example if possible)."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "[@abhi098](/abhi098) If you are iterating from the first index(earliest) to further. and when you reach the last index, why do you now have to go back to earlier index? The earlier indexes will already be checked right- when we reach till final?? I think my last sentence is not clear to what i wanted to mean"
                    },
                    {
                        "username": "abhi098",
                        "content": "why \"no need to access earlier indexes after reaching final index of station.\" ??\\n"
                    },
                    {
                        "username": "naveen17797",
                        "content": "Replace \"costs\" with \"fuel usage\", had to reread several times to understand the example"
                    },
                    {
                        "username": "nainikatrivedi05",
                        "content": "runtime error :("
                    },
                    {
                        "username": "alok900000",
                        "content": "Hi everyone can anybody solve my problem as it is showing 37/37 test case passed  for this code but also showing time limit exceed\\n class Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n\\n     int answer=0,k=0;\\n\\n         for(int i=0;i<gas.length;i++)\\n         {\\n           k=0;\\n           answer=gas[i];\\n           if(answer==0)\\n           continue;\\n           else if(answer-cost[i]<0)\\n           continue;\\n            for(int j=i;k<gas.length;j++)\\n            {\\n                  if(answer-cost[j%gas.length]>=0)\\n                  answer=answer-cost[j%gas.length]+gas[(j+1)%gas.length];\\n                  else\\n                    break;\\n                 ++k;\\n            }\\n            if(k==gas.length)\\n            return i;\\n         }\\n         return -1;\\n    }\\n}"
                    },
                    {
                        "username": "ssm2252221",
                        "content": "For Input [5, 5, 1, 3, 4] [8, 1, 7, 1, 1] there are more then one possible solutios (4 & 3)  but acc to statement if there is a solution iw will be unique.\\nCan anyone clarify?"
                    },
                    {
                        "username": "notphoenix",
                        "content": "Here I am still driving cycle !xD"
                    },
                    {
                        "username": "pandey11082000",
                        "content": "lol "
                    },
                    {
                        "username": "LoSeR101",
                        "content": "Hi guys wont index =2 (station =2 ) also give the answer for the  very first test case?\\n gas = [1,2,3,4,5], cost = [3,4,5,1,2]\\n\\nMy version of dry running it \\n initial gas =3+0\\n To reach station 3 : 3+4-5=2\\n To reach station 4 : 2+5-1=6\\n To reach station 0 : 6+1-2=5\\n To reach station 1 : 5+2-3=4\\nNow to reach station 2  from 1 the cost is 4 ..so why isn\\'t this the answer please help\\n                           \\n\\n"
                    },
                    {
                        "username": "LoSeR101",
                        "content": "[@prashantghi8](/prashantghi8)  got it! Thank you for answering my silly doubt"
                    },
                    {
                        "username": "LoSeR101",
                        "content": "[@thisannie](/thisannie) right now i understood it . Thank you for answering my silly doubt "
                    },
                    {
                        "username": "thisannie",
                        "content": "No. it wont because the gas of index 3 will be added to tank only after you reach there and in order to reach to station 3 you need 5 units of gas but you only have 3 units in your tank so index is not answer."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "How are you going to station 3 from 2 if it costs 5 and you only got 3???"
                    },
                    {
                        "username": "anirban1",
                        "content": "# Intuition\\nLet `prefSum` be the array of summation of `gas[i]-cost[i]` for $$0<=i<length(gas)$$.\\nLet `i-th` element be the global minima in the `prefSum` array, then `(i+1)-th` index is our answer if and only if our `prefSum` ends in a non-negative value.\\n\\n# Approach\\nCalculate prefix sum of the `gas[i]-cost[i]` & keep track of global minimum value. If at any point the sum is greater than the global minimum value record the index at this point and continue.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        idx,s,g_min=-1,0,0\\n        for i in range(len(gas)):\\n            s+=gas[i]-cost[i]\\n            if s<g_min:\\n                g_min=s\\n                idx=-1\\n            elif idx==-1:\\n                idx=i\\n        return idx if s>=0 else -1\\n```"
                    }
                ]
            },
            {
                "id": 2046614,
                "content": [
                    {
                        "username": "rstone13",
                        "content": "I am proud to say that, by looking at this problem on and off over the past week or so, I managed to come up with a solution without looking at the editorial. To be fair, that\\'s not fast enough to pass an interview, but at least I\\'m getting to where I can come to solutions on my own."
                    },
                    {
                        "username": "S_Basu",
                        "content": "**Can somebody please help me to improve the efficiency?**\\n*I am not posting the solution here as this shows TLE just asking for suggestions for improvisation*\\n- This is showing **Time Limit Exceeded**.\\n- It successfully ran 35 out of 37 test cases.\\n- It\\'s time complexity is $$O(n.n)$$\\n\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) \\n    {\\n        int len = gas.length;\\n        for(int i=0; i<len; i++)\\n        {\\n            int gasRem = 0;\\n            for(int j=i;j<len; j++)\\n            {\\n                gasRem += gas[j]-cost[j];\\n                if(gasRem>=0)\\n                    continue;\\n                else\\n                    break;\\n            }\\n            for(int j=0;j<i; j++)\\n            {\\n                if(gasRem>=0)\\n                    gasRem += gas[j]-cost[j];\\n                if(gasRem>=0)\\n                    continue;\\n                else\\n                    break;\\n            }\\n            if(gasRem>=0)\\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@tusharthakur05](/tusharthakur05)  Yes in my case all testcases passed only when it was reduced to $$O(n)$$"
                    },
                    {
                        "username": "tusharthakur05",
                        "content": "I was also solving this problem in the same way.\\nbut you need to reduce its complexity to O(N)."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Easy if we see this problem lightly:\\n- Return -1 if sum of total costs is greater than sum of total gas we can obtain\\n- After that, we can try from initial station, If total gas remaining  becomes less than 0 reaching any station, reset the collected gas, and try again from next station from where it is currently at. This way, you can find the starting station which will not reach less than 0 while traveling.\\nHints: No need for while loop, no need to access earlier indexes after reaching final index of station."
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@Prashant Ghimire](/prashantghi8) sir can you give a bit detailed explanation please. It would mean a lot (pls a bit explanation with a short example if possible)."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "[@abhi098](/abhi098) If you are iterating from the first index(earliest) to further. and when you reach the last index, why do you now have to go back to earlier index? The earlier indexes will already be checked right- when we reach till final?? I think my last sentence is not clear to what i wanted to mean"
                    },
                    {
                        "username": "abhi098",
                        "content": "why \"no need to access earlier indexes after reaching final index of station.\" ??\\n"
                    },
                    {
                        "username": "naveen17797",
                        "content": "Replace \"costs\" with \"fuel usage\", had to reread several times to understand the example"
                    },
                    {
                        "username": "nainikatrivedi05",
                        "content": "runtime error :("
                    },
                    {
                        "username": "alok900000",
                        "content": "Hi everyone can anybody solve my problem as it is showing 37/37 test case passed  for this code but also showing time limit exceed\\n class Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n\\n     int answer=0,k=0;\\n\\n         for(int i=0;i<gas.length;i++)\\n         {\\n           k=0;\\n           answer=gas[i];\\n           if(answer==0)\\n           continue;\\n           else if(answer-cost[i]<0)\\n           continue;\\n            for(int j=i;k<gas.length;j++)\\n            {\\n                  if(answer-cost[j%gas.length]>=0)\\n                  answer=answer-cost[j%gas.length]+gas[(j+1)%gas.length];\\n                  else\\n                    break;\\n                 ++k;\\n            }\\n            if(k==gas.length)\\n            return i;\\n         }\\n         return -1;\\n    }\\n}"
                    },
                    {
                        "username": "ssm2252221",
                        "content": "For Input [5, 5, 1, 3, 4] [8, 1, 7, 1, 1] there are more then one possible solutios (4 & 3)  but acc to statement if there is a solution iw will be unique.\\nCan anyone clarify?"
                    },
                    {
                        "username": "notphoenix",
                        "content": "Here I am still driving cycle !xD"
                    },
                    {
                        "username": "pandey11082000",
                        "content": "lol "
                    },
                    {
                        "username": "LoSeR101",
                        "content": "Hi guys wont index =2 (station =2 ) also give the answer for the  very first test case?\\n gas = [1,2,3,4,5], cost = [3,4,5,1,2]\\n\\nMy version of dry running it \\n initial gas =3+0\\n To reach station 3 : 3+4-5=2\\n To reach station 4 : 2+5-1=6\\n To reach station 0 : 6+1-2=5\\n To reach station 1 : 5+2-3=4\\nNow to reach station 2  from 1 the cost is 4 ..so why isn\\'t this the answer please help\\n                           \\n\\n"
                    },
                    {
                        "username": "LoSeR101",
                        "content": "[@prashantghi8](/prashantghi8)  got it! Thank you for answering my silly doubt"
                    },
                    {
                        "username": "LoSeR101",
                        "content": "[@thisannie](/thisannie) right now i understood it . Thank you for answering my silly doubt "
                    },
                    {
                        "username": "thisannie",
                        "content": "No. it wont because the gas of index 3 will be added to tank only after you reach there and in order to reach to station 3 you need 5 units of gas but you only have 3 units in your tank so index is not answer."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "How are you going to station 3 from 2 if it costs 5 and you only got 3???"
                    },
                    {
                        "username": "anirban1",
                        "content": "# Intuition\\nLet `prefSum` be the array of summation of `gas[i]-cost[i]` for $$0<=i<length(gas)$$.\\nLet `i-th` element be the global minima in the `prefSum` array, then `(i+1)-th` index is our answer if and only if our `prefSum` ends in a non-negative value.\\n\\n# Approach\\nCalculate prefix sum of the `gas[i]-cost[i]` & keep track of global minimum value. If at any point the sum is greater than the global minimum value record the index at this point and continue.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        idx,s,g_min=-1,0,0\\n        for i in range(len(gas)):\\n            s+=gas[i]-cost[i]\\n            if s<g_min:\\n                g_min=s\\n                idx=-1\\n            elif idx==-1:\\n                idx=i\\n        return idx if s>=0 else -1\\n```"
                    }
                ]
            },
            {
                "id": 1940257,
                "content": [
                    {
                        "username": "rstone13",
                        "content": "I am proud to say that, by looking at this problem on and off over the past week or so, I managed to come up with a solution without looking at the editorial. To be fair, that\\'s not fast enough to pass an interview, but at least I\\'m getting to where I can come to solutions on my own."
                    },
                    {
                        "username": "S_Basu",
                        "content": "**Can somebody please help me to improve the efficiency?**\\n*I am not posting the solution here as this shows TLE just asking for suggestions for improvisation*\\n- This is showing **Time Limit Exceeded**.\\n- It successfully ran 35 out of 37 test cases.\\n- It\\'s time complexity is $$O(n.n)$$\\n\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) \\n    {\\n        int len = gas.length;\\n        for(int i=0; i<len; i++)\\n        {\\n            int gasRem = 0;\\n            for(int j=i;j<len; j++)\\n            {\\n                gasRem += gas[j]-cost[j];\\n                if(gasRem>=0)\\n                    continue;\\n                else\\n                    break;\\n            }\\n            for(int j=0;j<i; j++)\\n            {\\n                if(gasRem>=0)\\n                    gasRem += gas[j]-cost[j];\\n                if(gasRem>=0)\\n                    continue;\\n                else\\n                    break;\\n            }\\n            if(gasRem>=0)\\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@tusharthakur05](/tusharthakur05)  Yes in my case all testcases passed only when it was reduced to $$O(n)$$"
                    },
                    {
                        "username": "tusharthakur05",
                        "content": "I was also solving this problem in the same way.\\nbut you need to reduce its complexity to O(N)."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Easy if we see this problem lightly:\\n- Return -1 if sum of total costs is greater than sum of total gas we can obtain\\n- After that, we can try from initial station, If total gas remaining  becomes less than 0 reaching any station, reset the collected gas, and try again from next station from where it is currently at. This way, you can find the starting station which will not reach less than 0 while traveling.\\nHints: No need for while loop, no need to access earlier indexes after reaching final index of station."
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@Prashant Ghimire](/prashantghi8) sir can you give a bit detailed explanation please. It would mean a lot (pls a bit explanation with a short example if possible)."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "[@abhi098](/abhi098) If you are iterating from the first index(earliest) to further. and when you reach the last index, why do you now have to go back to earlier index? The earlier indexes will already be checked right- when we reach till final?? I think my last sentence is not clear to what i wanted to mean"
                    },
                    {
                        "username": "abhi098",
                        "content": "why \"no need to access earlier indexes after reaching final index of station.\" ??\\n"
                    },
                    {
                        "username": "naveen17797",
                        "content": "Replace \"costs\" with \"fuel usage\", had to reread several times to understand the example"
                    },
                    {
                        "username": "nainikatrivedi05",
                        "content": "runtime error :("
                    },
                    {
                        "username": "alok900000",
                        "content": "Hi everyone can anybody solve my problem as it is showing 37/37 test case passed  for this code but also showing time limit exceed\\n class Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n\\n     int answer=0,k=0;\\n\\n         for(int i=0;i<gas.length;i++)\\n         {\\n           k=0;\\n           answer=gas[i];\\n           if(answer==0)\\n           continue;\\n           else if(answer-cost[i]<0)\\n           continue;\\n            for(int j=i;k<gas.length;j++)\\n            {\\n                  if(answer-cost[j%gas.length]>=0)\\n                  answer=answer-cost[j%gas.length]+gas[(j+1)%gas.length];\\n                  else\\n                    break;\\n                 ++k;\\n            }\\n            if(k==gas.length)\\n            return i;\\n         }\\n         return -1;\\n    }\\n}"
                    },
                    {
                        "username": "ssm2252221",
                        "content": "For Input [5, 5, 1, 3, 4] [8, 1, 7, 1, 1] there are more then one possible solutios (4 & 3)  but acc to statement if there is a solution iw will be unique.\\nCan anyone clarify?"
                    },
                    {
                        "username": "notphoenix",
                        "content": "Here I am still driving cycle !xD"
                    },
                    {
                        "username": "pandey11082000",
                        "content": "lol "
                    },
                    {
                        "username": "LoSeR101",
                        "content": "Hi guys wont index =2 (station =2 ) also give the answer for the  very first test case?\\n gas = [1,2,3,4,5], cost = [3,4,5,1,2]\\n\\nMy version of dry running it \\n initial gas =3+0\\n To reach station 3 : 3+4-5=2\\n To reach station 4 : 2+5-1=6\\n To reach station 0 : 6+1-2=5\\n To reach station 1 : 5+2-3=4\\nNow to reach station 2  from 1 the cost is 4 ..so why isn\\'t this the answer please help\\n                           \\n\\n"
                    },
                    {
                        "username": "LoSeR101",
                        "content": "[@prashantghi8](/prashantghi8)  got it! Thank you for answering my silly doubt"
                    },
                    {
                        "username": "LoSeR101",
                        "content": "[@thisannie](/thisannie) right now i understood it . Thank you for answering my silly doubt "
                    },
                    {
                        "username": "thisannie",
                        "content": "No. it wont because the gas of index 3 will be added to tank only after you reach there and in order to reach to station 3 you need 5 units of gas but you only have 3 units in your tank so index is not answer."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "How are you going to station 3 from 2 if it costs 5 and you only got 3???"
                    },
                    {
                        "username": "anirban1",
                        "content": "# Intuition\\nLet `prefSum` be the array of summation of `gas[i]-cost[i]` for $$0<=i<length(gas)$$.\\nLet `i-th` element be the global minima in the `prefSum` array, then `(i+1)-th` index is our answer if and only if our `prefSum` ends in a non-negative value.\\n\\n# Approach\\nCalculate prefix sum of the `gas[i]-cost[i]` & keep track of global minimum value. If at any point the sum is greater than the global minimum value record the index at this point and continue.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        idx,s,g_min=-1,0,0\\n        for i in range(len(gas)):\\n            s+=gas[i]-cost[i]\\n            if s<g_min:\\n                g_min=s\\n                idx=-1\\n            elif idx==-1:\\n                idx=i\\n        return idx if s>=0 else -1\\n```"
                    }
                ]
            },
            {
                "id": 1746750,
                "content": [
                    {
                        "username": "rstone13",
                        "content": "I am proud to say that, by looking at this problem on and off over the past week or so, I managed to come up with a solution without looking at the editorial. To be fair, that\\'s not fast enough to pass an interview, but at least I\\'m getting to where I can come to solutions on my own."
                    },
                    {
                        "username": "S_Basu",
                        "content": "**Can somebody please help me to improve the efficiency?**\\n*I am not posting the solution here as this shows TLE just asking for suggestions for improvisation*\\n- This is showing **Time Limit Exceeded**.\\n- It successfully ran 35 out of 37 test cases.\\n- It\\'s time complexity is $$O(n.n)$$\\n\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) \\n    {\\n        int len = gas.length;\\n        for(int i=0; i<len; i++)\\n        {\\n            int gasRem = 0;\\n            for(int j=i;j<len; j++)\\n            {\\n                gasRem += gas[j]-cost[j];\\n                if(gasRem>=0)\\n                    continue;\\n                else\\n                    break;\\n            }\\n            for(int j=0;j<i; j++)\\n            {\\n                if(gasRem>=0)\\n                    gasRem += gas[j]-cost[j];\\n                if(gasRem>=0)\\n                    continue;\\n                else\\n                    break;\\n            }\\n            if(gasRem>=0)\\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@tusharthakur05](/tusharthakur05)  Yes in my case all testcases passed only when it was reduced to $$O(n)$$"
                    },
                    {
                        "username": "tusharthakur05",
                        "content": "I was also solving this problem in the same way.\\nbut you need to reduce its complexity to O(N)."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Easy if we see this problem lightly:\\n- Return -1 if sum of total costs is greater than sum of total gas we can obtain\\n- After that, we can try from initial station, If total gas remaining  becomes less than 0 reaching any station, reset the collected gas, and try again from next station from where it is currently at. This way, you can find the starting station which will not reach less than 0 while traveling.\\nHints: No need for while loop, no need to access earlier indexes after reaching final index of station."
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@Prashant Ghimire](/prashantghi8) sir can you give a bit detailed explanation please. It would mean a lot (pls a bit explanation with a short example if possible)."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "[@abhi098](/abhi098) If you are iterating from the first index(earliest) to further. and when you reach the last index, why do you now have to go back to earlier index? The earlier indexes will already be checked right- when we reach till final?? I think my last sentence is not clear to what i wanted to mean"
                    },
                    {
                        "username": "abhi098",
                        "content": "why \"no need to access earlier indexes after reaching final index of station.\" ??\\n"
                    },
                    {
                        "username": "naveen17797",
                        "content": "Replace \"costs\" with \"fuel usage\", had to reread several times to understand the example"
                    },
                    {
                        "username": "nainikatrivedi05",
                        "content": "runtime error :("
                    },
                    {
                        "username": "alok900000",
                        "content": "Hi everyone can anybody solve my problem as it is showing 37/37 test case passed  for this code but also showing time limit exceed\\n class Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n\\n     int answer=0,k=0;\\n\\n         for(int i=0;i<gas.length;i++)\\n         {\\n           k=0;\\n           answer=gas[i];\\n           if(answer==0)\\n           continue;\\n           else if(answer-cost[i]<0)\\n           continue;\\n            for(int j=i;k<gas.length;j++)\\n            {\\n                  if(answer-cost[j%gas.length]>=0)\\n                  answer=answer-cost[j%gas.length]+gas[(j+1)%gas.length];\\n                  else\\n                    break;\\n                 ++k;\\n            }\\n            if(k==gas.length)\\n            return i;\\n         }\\n         return -1;\\n    }\\n}"
                    },
                    {
                        "username": "ssm2252221",
                        "content": "For Input [5, 5, 1, 3, 4] [8, 1, 7, 1, 1] there are more then one possible solutios (4 & 3)  but acc to statement if there is a solution iw will be unique.\\nCan anyone clarify?"
                    },
                    {
                        "username": "notphoenix",
                        "content": "Here I am still driving cycle !xD"
                    },
                    {
                        "username": "pandey11082000",
                        "content": "lol "
                    },
                    {
                        "username": "LoSeR101",
                        "content": "Hi guys wont index =2 (station =2 ) also give the answer for the  very first test case?\\n gas = [1,2,3,4,5], cost = [3,4,5,1,2]\\n\\nMy version of dry running it \\n initial gas =3+0\\n To reach station 3 : 3+4-5=2\\n To reach station 4 : 2+5-1=6\\n To reach station 0 : 6+1-2=5\\n To reach station 1 : 5+2-3=4\\nNow to reach station 2  from 1 the cost is 4 ..so why isn\\'t this the answer please help\\n                           \\n\\n"
                    },
                    {
                        "username": "LoSeR101",
                        "content": "[@prashantghi8](/prashantghi8)  got it! Thank you for answering my silly doubt"
                    },
                    {
                        "username": "LoSeR101",
                        "content": "[@thisannie](/thisannie) right now i understood it . Thank you for answering my silly doubt "
                    },
                    {
                        "username": "thisannie",
                        "content": "No. it wont because the gas of index 3 will be added to tank only after you reach there and in order to reach to station 3 you need 5 units of gas but you only have 3 units in your tank so index is not answer."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "How are you going to station 3 from 2 if it costs 5 and you only got 3???"
                    },
                    {
                        "username": "anirban1",
                        "content": "# Intuition\\nLet `prefSum` be the array of summation of `gas[i]-cost[i]` for $$0<=i<length(gas)$$.\\nLet `i-th` element be the global minima in the `prefSum` array, then `(i+1)-th` index is our answer if and only if our `prefSum` ends in a non-negative value.\\n\\n# Approach\\nCalculate prefix sum of the `gas[i]-cost[i]` & keep track of global minimum value. If at any point the sum is greater than the global minimum value record the index at this point and continue.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        idx,s,g_min=-1,0,0\\n        for i in range(len(gas)):\\n            s+=gas[i]-cost[i]\\n            if s<g_min:\\n                g_min=s\\n                idx=-1\\n            elif idx==-1:\\n                idx=i\\n        return idx if s>=0 else -1\\n```"
                    }
                ]
            },
            {
                "id": 1746617,
                "content": [
                    {
                        "username": "rstone13",
                        "content": "I am proud to say that, by looking at this problem on and off over the past week or so, I managed to come up with a solution without looking at the editorial. To be fair, that\\'s not fast enough to pass an interview, but at least I\\'m getting to where I can come to solutions on my own."
                    },
                    {
                        "username": "S_Basu",
                        "content": "**Can somebody please help me to improve the efficiency?**\\n*I am not posting the solution here as this shows TLE just asking for suggestions for improvisation*\\n- This is showing **Time Limit Exceeded**.\\n- It successfully ran 35 out of 37 test cases.\\n- It\\'s time complexity is $$O(n.n)$$\\n\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) \\n    {\\n        int len = gas.length;\\n        for(int i=0; i<len; i++)\\n        {\\n            int gasRem = 0;\\n            for(int j=i;j<len; j++)\\n            {\\n                gasRem += gas[j]-cost[j];\\n                if(gasRem>=0)\\n                    continue;\\n                else\\n                    break;\\n            }\\n            for(int j=0;j<i; j++)\\n            {\\n                if(gasRem>=0)\\n                    gasRem += gas[j]-cost[j];\\n                if(gasRem>=0)\\n                    continue;\\n                else\\n                    break;\\n            }\\n            if(gasRem>=0)\\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@tusharthakur05](/tusharthakur05)  Yes in my case all testcases passed only when it was reduced to $$O(n)$$"
                    },
                    {
                        "username": "tusharthakur05",
                        "content": "I was also solving this problem in the same way.\\nbut you need to reduce its complexity to O(N)."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Easy if we see this problem lightly:\\n- Return -1 if sum of total costs is greater than sum of total gas we can obtain\\n- After that, we can try from initial station, If total gas remaining  becomes less than 0 reaching any station, reset the collected gas, and try again from next station from where it is currently at. This way, you can find the starting station which will not reach less than 0 while traveling.\\nHints: No need for while loop, no need to access earlier indexes after reaching final index of station."
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@Prashant Ghimire](/prashantghi8) sir can you give a bit detailed explanation please. It would mean a lot (pls a bit explanation with a short example if possible)."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "[@abhi098](/abhi098) If you are iterating from the first index(earliest) to further. and when you reach the last index, why do you now have to go back to earlier index? The earlier indexes will already be checked right- when we reach till final?? I think my last sentence is not clear to what i wanted to mean"
                    },
                    {
                        "username": "abhi098",
                        "content": "why \"no need to access earlier indexes after reaching final index of station.\" ??\\n"
                    },
                    {
                        "username": "naveen17797",
                        "content": "Replace \"costs\" with \"fuel usage\", had to reread several times to understand the example"
                    },
                    {
                        "username": "nainikatrivedi05",
                        "content": "runtime error :("
                    },
                    {
                        "username": "alok900000",
                        "content": "Hi everyone can anybody solve my problem as it is showing 37/37 test case passed  for this code but also showing time limit exceed\\n class Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n\\n     int answer=0,k=0;\\n\\n         for(int i=0;i<gas.length;i++)\\n         {\\n           k=0;\\n           answer=gas[i];\\n           if(answer==0)\\n           continue;\\n           else if(answer-cost[i]<0)\\n           continue;\\n            for(int j=i;k<gas.length;j++)\\n            {\\n                  if(answer-cost[j%gas.length]>=0)\\n                  answer=answer-cost[j%gas.length]+gas[(j+1)%gas.length];\\n                  else\\n                    break;\\n                 ++k;\\n            }\\n            if(k==gas.length)\\n            return i;\\n         }\\n         return -1;\\n    }\\n}"
                    },
                    {
                        "username": "ssm2252221",
                        "content": "For Input [5, 5, 1, 3, 4] [8, 1, 7, 1, 1] there are more then one possible solutios (4 & 3)  but acc to statement if there is a solution iw will be unique.\\nCan anyone clarify?"
                    },
                    {
                        "username": "notphoenix",
                        "content": "Here I am still driving cycle !xD"
                    },
                    {
                        "username": "pandey11082000",
                        "content": "lol "
                    },
                    {
                        "username": "LoSeR101",
                        "content": "Hi guys wont index =2 (station =2 ) also give the answer for the  very first test case?\\n gas = [1,2,3,4,5], cost = [3,4,5,1,2]\\n\\nMy version of dry running it \\n initial gas =3+0\\n To reach station 3 : 3+4-5=2\\n To reach station 4 : 2+5-1=6\\n To reach station 0 : 6+1-2=5\\n To reach station 1 : 5+2-3=4\\nNow to reach station 2  from 1 the cost is 4 ..so why isn\\'t this the answer please help\\n                           \\n\\n"
                    },
                    {
                        "username": "LoSeR101",
                        "content": "[@prashantghi8](/prashantghi8)  got it! Thank you for answering my silly doubt"
                    },
                    {
                        "username": "LoSeR101",
                        "content": "[@thisannie](/thisannie) right now i understood it . Thank you for answering my silly doubt "
                    },
                    {
                        "username": "thisannie",
                        "content": "No. it wont because the gas of index 3 will be added to tank only after you reach there and in order to reach to station 3 you need 5 units of gas but you only have 3 units in your tank so index is not answer."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "How are you going to station 3 from 2 if it costs 5 and you only got 3???"
                    },
                    {
                        "username": "anirban1",
                        "content": "# Intuition\\nLet `prefSum` be the array of summation of `gas[i]-cost[i]` for $$0<=i<length(gas)$$.\\nLet `i-th` element be the global minima in the `prefSum` array, then `(i+1)-th` index is our answer if and only if our `prefSum` ends in a non-negative value.\\n\\n# Approach\\nCalculate prefix sum of the `gas[i]-cost[i]` & keep track of global minimum value. If at any point the sum is greater than the global minimum value record the index at this point and continue.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        idx,s,g_min=-1,0,0\\n        for i in range(len(gas)):\\n            s+=gas[i]-cost[i]\\n            if s<g_min:\\n                g_min=s\\n                idx=-1\\n            elif idx==-1:\\n                idx=i\\n        return idx if s>=0 else -1\\n```"
                    }
                ]
            },
            {
                "id": 1746407,
                "content": [
                    {
                        "username": "rstone13",
                        "content": "I am proud to say that, by looking at this problem on and off over the past week or so, I managed to come up with a solution without looking at the editorial. To be fair, that\\'s not fast enough to pass an interview, but at least I\\'m getting to where I can come to solutions on my own."
                    },
                    {
                        "username": "S_Basu",
                        "content": "**Can somebody please help me to improve the efficiency?**\\n*I am not posting the solution here as this shows TLE just asking for suggestions for improvisation*\\n- This is showing **Time Limit Exceeded**.\\n- It successfully ran 35 out of 37 test cases.\\n- It\\'s time complexity is $$O(n.n)$$\\n\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) \\n    {\\n        int len = gas.length;\\n        for(int i=0; i<len; i++)\\n        {\\n            int gasRem = 0;\\n            for(int j=i;j<len; j++)\\n            {\\n                gasRem += gas[j]-cost[j];\\n                if(gasRem>=0)\\n                    continue;\\n                else\\n                    break;\\n            }\\n            for(int j=0;j<i; j++)\\n            {\\n                if(gasRem>=0)\\n                    gasRem += gas[j]-cost[j];\\n                if(gasRem>=0)\\n                    continue;\\n                else\\n                    break;\\n            }\\n            if(gasRem>=0)\\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@tusharthakur05](/tusharthakur05)  Yes in my case all testcases passed only when it was reduced to $$O(n)$$"
                    },
                    {
                        "username": "tusharthakur05",
                        "content": "I was also solving this problem in the same way.\\nbut you need to reduce its complexity to O(N)."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Easy if we see this problem lightly:\\n- Return -1 if sum of total costs is greater than sum of total gas we can obtain\\n- After that, we can try from initial station, If total gas remaining  becomes less than 0 reaching any station, reset the collected gas, and try again from next station from where it is currently at. This way, you can find the starting station which will not reach less than 0 while traveling.\\nHints: No need for while loop, no need to access earlier indexes after reaching final index of station."
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@Prashant Ghimire](/prashantghi8) sir can you give a bit detailed explanation please. It would mean a lot (pls a bit explanation with a short example if possible)."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "[@abhi098](/abhi098) If you are iterating from the first index(earliest) to further. and when you reach the last index, why do you now have to go back to earlier index? The earlier indexes will already be checked right- when we reach till final?? I think my last sentence is not clear to what i wanted to mean"
                    },
                    {
                        "username": "abhi098",
                        "content": "why \"no need to access earlier indexes after reaching final index of station.\" ??\\n"
                    },
                    {
                        "username": "naveen17797",
                        "content": "Replace \"costs\" with \"fuel usage\", had to reread several times to understand the example"
                    },
                    {
                        "username": "nainikatrivedi05",
                        "content": "runtime error :("
                    },
                    {
                        "username": "alok900000",
                        "content": "Hi everyone can anybody solve my problem as it is showing 37/37 test case passed  for this code but also showing time limit exceed\\n class Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n\\n     int answer=0,k=0;\\n\\n         for(int i=0;i<gas.length;i++)\\n         {\\n           k=0;\\n           answer=gas[i];\\n           if(answer==0)\\n           continue;\\n           else if(answer-cost[i]<0)\\n           continue;\\n            for(int j=i;k<gas.length;j++)\\n            {\\n                  if(answer-cost[j%gas.length]>=0)\\n                  answer=answer-cost[j%gas.length]+gas[(j+1)%gas.length];\\n                  else\\n                    break;\\n                 ++k;\\n            }\\n            if(k==gas.length)\\n            return i;\\n         }\\n         return -1;\\n    }\\n}"
                    },
                    {
                        "username": "ssm2252221",
                        "content": "For Input [5, 5, 1, 3, 4] [8, 1, 7, 1, 1] there are more then one possible solutios (4 & 3)  but acc to statement if there is a solution iw will be unique.\\nCan anyone clarify?"
                    },
                    {
                        "username": "notphoenix",
                        "content": "Here I am still driving cycle !xD"
                    },
                    {
                        "username": "pandey11082000",
                        "content": "lol "
                    },
                    {
                        "username": "LoSeR101",
                        "content": "Hi guys wont index =2 (station =2 ) also give the answer for the  very first test case?\\n gas = [1,2,3,4,5], cost = [3,4,5,1,2]\\n\\nMy version of dry running it \\n initial gas =3+0\\n To reach station 3 : 3+4-5=2\\n To reach station 4 : 2+5-1=6\\n To reach station 0 : 6+1-2=5\\n To reach station 1 : 5+2-3=4\\nNow to reach station 2  from 1 the cost is 4 ..so why isn\\'t this the answer please help\\n                           \\n\\n"
                    },
                    {
                        "username": "LoSeR101",
                        "content": "[@prashantghi8](/prashantghi8)  got it! Thank you for answering my silly doubt"
                    },
                    {
                        "username": "LoSeR101",
                        "content": "[@thisannie](/thisannie) right now i understood it . Thank you for answering my silly doubt "
                    },
                    {
                        "username": "thisannie",
                        "content": "No. it wont because the gas of index 3 will be added to tank only after you reach there and in order to reach to station 3 you need 5 units of gas but you only have 3 units in your tank so index is not answer."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "How are you going to station 3 from 2 if it costs 5 and you only got 3???"
                    },
                    {
                        "username": "anirban1",
                        "content": "# Intuition\\nLet `prefSum` be the array of summation of `gas[i]-cost[i]` for $$0<=i<length(gas)$$.\\nLet `i-th` element be the global minima in the `prefSum` array, then `(i+1)-th` index is our answer if and only if our `prefSum` ends in a non-negative value.\\n\\n# Approach\\nCalculate prefix sum of the `gas[i]-cost[i]` & keep track of global minimum value. If at any point the sum is greater than the global minimum value record the index at this point and continue.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        idx,s,g_min=-1,0,0\\n        for i in range(len(gas)):\\n            s+=gas[i]-cost[i]\\n            if s<g_min:\\n                g_min=s\\n                idx=-1\\n            elif idx==-1:\\n                idx=i\\n        return idx if s>=0 else -1\\n```"
                    }
                ]
            },
            {
                "id": 1745808,
                "content": [
                    {
                        "username": "rstone13",
                        "content": "I am proud to say that, by looking at this problem on and off over the past week or so, I managed to come up with a solution without looking at the editorial. To be fair, that\\'s not fast enough to pass an interview, but at least I\\'m getting to where I can come to solutions on my own."
                    },
                    {
                        "username": "S_Basu",
                        "content": "**Can somebody please help me to improve the efficiency?**\\n*I am not posting the solution here as this shows TLE just asking for suggestions for improvisation*\\n- This is showing **Time Limit Exceeded**.\\n- It successfully ran 35 out of 37 test cases.\\n- It\\'s time complexity is $$O(n.n)$$\\n\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) \\n    {\\n        int len = gas.length;\\n        for(int i=0; i<len; i++)\\n        {\\n            int gasRem = 0;\\n            for(int j=i;j<len; j++)\\n            {\\n                gasRem += gas[j]-cost[j];\\n                if(gasRem>=0)\\n                    continue;\\n                else\\n                    break;\\n            }\\n            for(int j=0;j<i; j++)\\n            {\\n                if(gasRem>=0)\\n                    gasRem += gas[j]-cost[j];\\n                if(gasRem>=0)\\n                    continue;\\n                else\\n                    break;\\n            }\\n            if(gasRem>=0)\\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@tusharthakur05](/tusharthakur05)  Yes in my case all testcases passed only when it was reduced to $$O(n)$$"
                    },
                    {
                        "username": "tusharthakur05",
                        "content": "I was also solving this problem in the same way.\\nbut you need to reduce its complexity to O(N)."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Easy if we see this problem lightly:\\n- Return -1 if sum of total costs is greater than sum of total gas we can obtain\\n- After that, we can try from initial station, If total gas remaining  becomes less than 0 reaching any station, reset the collected gas, and try again from next station from where it is currently at. This way, you can find the starting station which will not reach less than 0 while traveling.\\nHints: No need for while loop, no need to access earlier indexes after reaching final index of station."
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@Prashant Ghimire](/prashantghi8) sir can you give a bit detailed explanation please. It would mean a lot (pls a bit explanation with a short example if possible)."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "[@abhi098](/abhi098) If you are iterating from the first index(earliest) to further. and when you reach the last index, why do you now have to go back to earlier index? The earlier indexes will already be checked right- when we reach till final?? I think my last sentence is not clear to what i wanted to mean"
                    },
                    {
                        "username": "abhi098",
                        "content": "why \"no need to access earlier indexes after reaching final index of station.\" ??\\n"
                    },
                    {
                        "username": "naveen17797",
                        "content": "Replace \"costs\" with \"fuel usage\", had to reread several times to understand the example"
                    },
                    {
                        "username": "nainikatrivedi05",
                        "content": "runtime error :("
                    },
                    {
                        "username": "alok900000",
                        "content": "Hi everyone can anybody solve my problem as it is showing 37/37 test case passed  for this code but also showing time limit exceed\\n class Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n\\n     int answer=0,k=0;\\n\\n         for(int i=0;i<gas.length;i++)\\n         {\\n           k=0;\\n           answer=gas[i];\\n           if(answer==0)\\n           continue;\\n           else if(answer-cost[i]<0)\\n           continue;\\n            for(int j=i;k<gas.length;j++)\\n            {\\n                  if(answer-cost[j%gas.length]>=0)\\n                  answer=answer-cost[j%gas.length]+gas[(j+1)%gas.length];\\n                  else\\n                    break;\\n                 ++k;\\n            }\\n            if(k==gas.length)\\n            return i;\\n         }\\n         return -1;\\n    }\\n}"
                    },
                    {
                        "username": "ssm2252221",
                        "content": "For Input [5, 5, 1, 3, 4] [8, 1, 7, 1, 1] there are more then one possible solutios (4 & 3)  but acc to statement if there is a solution iw will be unique.\\nCan anyone clarify?"
                    },
                    {
                        "username": "notphoenix",
                        "content": "Here I am still driving cycle !xD"
                    },
                    {
                        "username": "pandey11082000",
                        "content": "lol "
                    },
                    {
                        "username": "LoSeR101",
                        "content": "Hi guys wont index =2 (station =2 ) also give the answer for the  very first test case?\\n gas = [1,2,3,4,5], cost = [3,4,5,1,2]\\n\\nMy version of dry running it \\n initial gas =3+0\\n To reach station 3 : 3+4-5=2\\n To reach station 4 : 2+5-1=6\\n To reach station 0 : 6+1-2=5\\n To reach station 1 : 5+2-3=4\\nNow to reach station 2  from 1 the cost is 4 ..so why isn\\'t this the answer please help\\n                           \\n\\n"
                    },
                    {
                        "username": "LoSeR101",
                        "content": "[@prashantghi8](/prashantghi8)  got it! Thank you for answering my silly doubt"
                    },
                    {
                        "username": "LoSeR101",
                        "content": "[@thisannie](/thisannie) right now i understood it . Thank you for answering my silly doubt "
                    },
                    {
                        "username": "thisannie",
                        "content": "No. it wont because the gas of index 3 will be added to tank only after you reach there and in order to reach to station 3 you need 5 units of gas but you only have 3 units in your tank so index is not answer."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "How are you going to station 3 from 2 if it costs 5 and you only got 3???"
                    },
                    {
                        "username": "anirban1",
                        "content": "# Intuition\\nLet `prefSum` be the array of summation of `gas[i]-cost[i]` for $$0<=i<length(gas)$$.\\nLet `i-th` element be the global minima in the `prefSum` array, then `(i+1)-th` index is our answer if and only if our `prefSum` ends in a non-negative value.\\n\\n# Approach\\nCalculate prefix sum of the `gas[i]-cost[i]` & keep track of global minimum value. If at any point the sum is greater than the global minimum value record the index at this point and continue.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        idx,s,g_min=-1,0,0\\n        for i in range(len(gas)):\\n            s+=gas[i]-cost[i]\\n            if s<g_min:\\n                g_min=s\\n                idx=-1\\n            elif idx==-1:\\n                idx=i\\n        return idx if s>=0 else -1\\n```"
                    }
                ]
            },
            {
                "id": 1745622,
                "content": [
                    {
                        "username": "rstone13",
                        "content": "I am proud to say that, by looking at this problem on and off over the past week or so, I managed to come up with a solution without looking at the editorial. To be fair, that\\'s not fast enough to pass an interview, but at least I\\'m getting to where I can come to solutions on my own."
                    },
                    {
                        "username": "S_Basu",
                        "content": "**Can somebody please help me to improve the efficiency?**\\n*I am not posting the solution here as this shows TLE just asking for suggestions for improvisation*\\n- This is showing **Time Limit Exceeded**.\\n- It successfully ran 35 out of 37 test cases.\\n- It\\'s time complexity is $$O(n.n)$$\\n\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) \\n    {\\n        int len = gas.length;\\n        for(int i=0; i<len; i++)\\n        {\\n            int gasRem = 0;\\n            for(int j=i;j<len; j++)\\n            {\\n                gasRem += gas[j]-cost[j];\\n                if(gasRem>=0)\\n                    continue;\\n                else\\n                    break;\\n            }\\n            for(int j=0;j<i; j++)\\n            {\\n                if(gasRem>=0)\\n                    gasRem += gas[j]-cost[j];\\n                if(gasRem>=0)\\n                    continue;\\n                else\\n                    break;\\n            }\\n            if(gasRem>=0)\\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@tusharthakur05](/tusharthakur05)  Yes in my case all testcases passed only when it was reduced to $$O(n)$$"
                    },
                    {
                        "username": "tusharthakur05",
                        "content": "I was also solving this problem in the same way.\\nbut you need to reduce its complexity to O(N)."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Easy if we see this problem lightly:\\n- Return -1 if sum of total costs is greater than sum of total gas we can obtain\\n- After that, we can try from initial station, If total gas remaining  becomes less than 0 reaching any station, reset the collected gas, and try again from next station from where it is currently at. This way, you can find the starting station which will not reach less than 0 while traveling.\\nHints: No need for while loop, no need to access earlier indexes after reaching final index of station."
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@Prashant Ghimire](/prashantghi8) sir can you give a bit detailed explanation please. It would mean a lot (pls a bit explanation with a short example if possible)."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "[@abhi098](/abhi098) If you are iterating from the first index(earliest) to further. and when you reach the last index, why do you now have to go back to earlier index? The earlier indexes will already be checked right- when we reach till final?? I think my last sentence is not clear to what i wanted to mean"
                    },
                    {
                        "username": "abhi098",
                        "content": "why \"no need to access earlier indexes after reaching final index of station.\" ??\\n"
                    },
                    {
                        "username": "naveen17797",
                        "content": "Replace \"costs\" with \"fuel usage\", had to reread several times to understand the example"
                    },
                    {
                        "username": "nainikatrivedi05",
                        "content": "runtime error :("
                    },
                    {
                        "username": "alok900000",
                        "content": "Hi everyone can anybody solve my problem as it is showing 37/37 test case passed  for this code but also showing time limit exceed\\n class Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n\\n     int answer=0,k=0;\\n\\n         for(int i=0;i<gas.length;i++)\\n         {\\n           k=0;\\n           answer=gas[i];\\n           if(answer==0)\\n           continue;\\n           else if(answer-cost[i]<0)\\n           continue;\\n            for(int j=i;k<gas.length;j++)\\n            {\\n                  if(answer-cost[j%gas.length]>=0)\\n                  answer=answer-cost[j%gas.length]+gas[(j+1)%gas.length];\\n                  else\\n                    break;\\n                 ++k;\\n            }\\n            if(k==gas.length)\\n            return i;\\n         }\\n         return -1;\\n    }\\n}"
                    },
                    {
                        "username": "ssm2252221",
                        "content": "For Input [5, 5, 1, 3, 4] [8, 1, 7, 1, 1] there are more then one possible solutios (4 & 3)  but acc to statement if there is a solution iw will be unique.\\nCan anyone clarify?"
                    },
                    {
                        "username": "notphoenix",
                        "content": "Here I am still driving cycle !xD"
                    },
                    {
                        "username": "pandey11082000",
                        "content": "lol "
                    },
                    {
                        "username": "LoSeR101",
                        "content": "Hi guys wont index =2 (station =2 ) also give the answer for the  very first test case?\\n gas = [1,2,3,4,5], cost = [3,4,5,1,2]\\n\\nMy version of dry running it \\n initial gas =3+0\\n To reach station 3 : 3+4-5=2\\n To reach station 4 : 2+5-1=6\\n To reach station 0 : 6+1-2=5\\n To reach station 1 : 5+2-3=4\\nNow to reach station 2  from 1 the cost is 4 ..so why isn\\'t this the answer please help\\n                           \\n\\n"
                    },
                    {
                        "username": "LoSeR101",
                        "content": "[@prashantghi8](/prashantghi8)  got it! Thank you for answering my silly doubt"
                    },
                    {
                        "username": "LoSeR101",
                        "content": "[@thisannie](/thisannie) right now i understood it . Thank you for answering my silly doubt "
                    },
                    {
                        "username": "thisannie",
                        "content": "No. it wont because the gas of index 3 will be added to tank only after you reach there and in order to reach to station 3 you need 5 units of gas but you only have 3 units in your tank so index is not answer."
                    },
                    {
                        "username": "prashantghi8",
                        "content": "How are you going to station 3 from 2 if it costs 5 and you only got 3???"
                    },
                    {
                        "username": "anirban1",
                        "content": "# Intuition\\nLet `prefSum` be the array of summation of `gas[i]-cost[i]` for $$0<=i<length(gas)$$.\\nLet `i-th` element be the global minima in the `prefSum` array, then `(i+1)-th` index is our answer if and only if our `prefSum` ends in a non-negative value.\\n\\n# Approach\\nCalculate prefix sum of the `gas[i]-cost[i]` & keep track of global minimum value. If at any point the sum is greater than the global minimum value record the index at this point and continue.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        idx,s,g_min=-1,0,0\\n        for i in range(len(gas)):\\n            s+=gas[i]-cost[i]\\n            if s<g_min:\\n                g_min=s\\n                idx=-1\\n            elif idx==-1:\\n                idx=i\\n        return idx if s>=0 else -1\\n```"
                    }
                ]
            },
            {
                "id": 1654060,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    // return max distance that can reach, otherwise can complete and return -1\\n    int startWithN(int start, vector<int>& gas, vector<int>& cost) {\\n        int sum = 0, n = gas.size();\\n        for(int i = 0; i < n; ++i) {\\n            int distance = (i+start) % n;\\n            sum += (gas[distance] - cost[distance]);\\n            //printf(\"sum %d\\\\n\", sum);\\n            if(sum < 0) {\\n                return distance;\\n            }\\n        }\\n        return -1;\\n    }\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size();\\n        for(int i = 0; i < n; ++i) {\\n            \\n            int k = startWithN(i, gas, cost);\\n            //printf(\"start with %d, %d\\\\n\", i,k);\\n            if(k == -1) {\\n                return i;\\n            } else if(k > i) {\\n                i = k;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "unknown_unknown",
                        "content": "![image](https://assets.leetcode.com/users/images/10216980-50f9-4b3e-99a4-43f5257ea46d_1644235608.0222747.png)\\n"
                    },
                    {
                        "username": "mandy1339",
                        "content": "I really hope I don\\'t get a problem like this on a contest or I will run out of time doing the medium."
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "gas  [4,5,2,6,5,3]\\ncost [3,2,7,3,2,9]\\nOJ return is 3 instead of -1 .\\n\\nthen i suppose in this problem we dont need to go back to the starting station : after get station[2] , we finished the  travel . \\nbut  when sample is \\n\\ngas [2,4]\\ncost [3,4]\\n\\nOJ return is -1 . Is the OJ's code or test sample correct ?"
                    },
                    {
                        "username": "ck8300983",
                        "content": "I use the following input to test my code :  \\ngas [4 0 1]  \\ncost [3 2 1] \\n\\nand the OJ show the expected answer is 2 instead of -1. Is this an error for the Run code test?"
                    },
                    {
                        "username": "bazza",
                        "content": "The question asks if a trip can be made successfully, but it leaves out the definition of successfully. In an interview, I would ask the following questions (heck, I want the following questions answered by anyone before I even continue on this problems):\\n\\n  1. Would the idea be to complete a circuit and keep the cost below 1 unit per distance?\\n  2. Can there be negative costs (so we can earn money)?\\n  3. How big can the number of stations be?\\n\\nThe last two questions can be easily deduced from the online judge if one has patients. But the first question is essential to this problem.\\n\\nDoes anyone have insight?"
                    },
                    {
                        "username": "duhaime",
                        "content": "Here\\'s one of the test cases:\\n\\ngas = [4]\\ncost = [5]\\n\\nThe car starts at index 0 and must return to where it is located. The cost must be 0, and the travel must be possible, regardless of the amount of gas available at the station, because we\\'re already there."
                    },
                    {
                        "username": "comeonelton",
                        "content": "Here is a case.\\ngas[4, 1, 3, 6, 1]\\ncost[2, 4, 2, 2, 3]\\n\\nSolution: starting index(begin from 0) could be 2 and 3.\\n\\nAm I missing something?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "easy c++.\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int sum_gas=0,sum_cost=0,start=0,curr=0;\\n        for(int i=0;i<cost.size();i++){\\n            sum_gas+=gas[i];\\n            sum_cost+=cost[i];\\n        }\\n        if(sum_gas<sum_cost)return -1;\\n        for(int i=0;i<gas.size();i++){\\n            curr+=gas[i]-cost[i];\\n            if(curr<0){start=i+1;\\n            curr=0;}\\n        }\\n        return start;\\n    }"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Some of test cases:\\ng3 = [5,1,2,3,4]; c3 = [4,4,1,5,1] # 4\\ng4 = [3,1,1]; c4 = [1,2,2] # 0\\ng5 = [5,5,1,3,4]; c5 = [8,1,7,1,1] # 3\\ng6 = [1,2,3,4,5,5,70]; c6 = [2,3,4,3,9,6,2] # 6\\ng8 = [2,5,1,4,3]; c8 = [3,2,2,2,6] # 1\\n"
                    }
                ]
            },
            {
                "id": 1576351,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    // return max distance that can reach, otherwise can complete and return -1\\n    int startWithN(int start, vector<int>& gas, vector<int>& cost) {\\n        int sum = 0, n = gas.size();\\n        for(int i = 0; i < n; ++i) {\\n            int distance = (i+start) % n;\\n            sum += (gas[distance] - cost[distance]);\\n            //printf(\"sum %d\\\\n\", sum);\\n            if(sum < 0) {\\n                return distance;\\n            }\\n        }\\n        return -1;\\n    }\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size();\\n        for(int i = 0; i < n; ++i) {\\n            \\n            int k = startWithN(i, gas, cost);\\n            //printf(\"start with %d, %d\\\\n\", i,k);\\n            if(k == -1) {\\n                return i;\\n            } else if(k > i) {\\n                i = k;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "unknown_unknown",
                        "content": "![image](https://assets.leetcode.com/users/images/10216980-50f9-4b3e-99a4-43f5257ea46d_1644235608.0222747.png)\\n"
                    },
                    {
                        "username": "mandy1339",
                        "content": "I really hope I don\\'t get a problem like this on a contest or I will run out of time doing the medium."
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "gas  [4,5,2,6,5,3]\\ncost [3,2,7,3,2,9]\\nOJ return is 3 instead of -1 .\\n\\nthen i suppose in this problem we dont need to go back to the starting station : after get station[2] , we finished the  travel . \\nbut  when sample is \\n\\ngas [2,4]\\ncost [3,4]\\n\\nOJ return is -1 . Is the OJ's code or test sample correct ?"
                    },
                    {
                        "username": "ck8300983",
                        "content": "I use the following input to test my code :  \\ngas [4 0 1]  \\ncost [3 2 1] \\n\\nand the OJ show the expected answer is 2 instead of -1. Is this an error for the Run code test?"
                    },
                    {
                        "username": "bazza",
                        "content": "The question asks if a trip can be made successfully, but it leaves out the definition of successfully. In an interview, I would ask the following questions (heck, I want the following questions answered by anyone before I even continue on this problems):\\n\\n  1. Would the idea be to complete a circuit and keep the cost below 1 unit per distance?\\n  2. Can there be negative costs (so we can earn money)?\\n  3. How big can the number of stations be?\\n\\nThe last two questions can be easily deduced from the online judge if one has patients. But the first question is essential to this problem.\\n\\nDoes anyone have insight?"
                    },
                    {
                        "username": "duhaime",
                        "content": "Here\\'s one of the test cases:\\n\\ngas = [4]\\ncost = [5]\\n\\nThe car starts at index 0 and must return to where it is located. The cost must be 0, and the travel must be possible, regardless of the amount of gas available at the station, because we\\'re already there."
                    },
                    {
                        "username": "comeonelton",
                        "content": "Here is a case.\\ngas[4, 1, 3, 6, 1]\\ncost[2, 4, 2, 2, 3]\\n\\nSolution: starting index(begin from 0) could be 2 and 3.\\n\\nAm I missing something?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "easy c++.\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int sum_gas=0,sum_cost=0,start=0,curr=0;\\n        for(int i=0;i<cost.size();i++){\\n            sum_gas+=gas[i];\\n            sum_cost+=cost[i];\\n        }\\n        if(sum_gas<sum_cost)return -1;\\n        for(int i=0;i<gas.size();i++){\\n            curr+=gas[i]-cost[i];\\n            if(curr<0){start=i+1;\\n            curr=0;}\\n        }\\n        return start;\\n    }"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Some of test cases:\\ng3 = [5,1,2,3,4]; c3 = [4,4,1,5,1] # 4\\ng4 = [3,1,1]; c4 = [1,2,2] # 0\\ng5 = [5,5,1,3,4]; c5 = [8,1,7,1,1] # 3\\ng6 = [1,2,3,4,5,5,70]; c6 = [2,3,4,3,9,6,2] # 6\\ng8 = [2,5,1,4,3]; c8 = [3,2,2,2,6] # 1\\n"
                    }
                ]
            },
            {
                "id": 1576271,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    // return max distance that can reach, otherwise can complete and return -1\\n    int startWithN(int start, vector<int>& gas, vector<int>& cost) {\\n        int sum = 0, n = gas.size();\\n        for(int i = 0; i < n; ++i) {\\n            int distance = (i+start) % n;\\n            sum += (gas[distance] - cost[distance]);\\n            //printf(\"sum %d\\\\n\", sum);\\n            if(sum < 0) {\\n                return distance;\\n            }\\n        }\\n        return -1;\\n    }\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size();\\n        for(int i = 0; i < n; ++i) {\\n            \\n            int k = startWithN(i, gas, cost);\\n            //printf(\"start with %d, %d\\\\n\", i,k);\\n            if(k == -1) {\\n                return i;\\n            } else if(k > i) {\\n                i = k;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "unknown_unknown",
                        "content": "![image](https://assets.leetcode.com/users/images/10216980-50f9-4b3e-99a4-43f5257ea46d_1644235608.0222747.png)\\n"
                    },
                    {
                        "username": "mandy1339",
                        "content": "I really hope I don\\'t get a problem like this on a contest or I will run out of time doing the medium."
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "gas  [4,5,2,6,5,3]\\ncost [3,2,7,3,2,9]\\nOJ return is 3 instead of -1 .\\n\\nthen i suppose in this problem we dont need to go back to the starting station : after get station[2] , we finished the  travel . \\nbut  when sample is \\n\\ngas [2,4]\\ncost [3,4]\\n\\nOJ return is -1 . Is the OJ's code or test sample correct ?"
                    },
                    {
                        "username": "ck8300983",
                        "content": "I use the following input to test my code :  \\ngas [4 0 1]  \\ncost [3 2 1] \\n\\nand the OJ show the expected answer is 2 instead of -1. Is this an error for the Run code test?"
                    },
                    {
                        "username": "bazza",
                        "content": "The question asks if a trip can be made successfully, but it leaves out the definition of successfully. In an interview, I would ask the following questions (heck, I want the following questions answered by anyone before I even continue on this problems):\\n\\n  1. Would the idea be to complete a circuit and keep the cost below 1 unit per distance?\\n  2. Can there be negative costs (so we can earn money)?\\n  3. How big can the number of stations be?\\n\\nThe last two questions can be easily deduced from the online judge if one has patients. But the first question is essential to this problem.\\n\\nDoes anyone have insight?"
                    },
                    {
                        "username": "duhaime",
                        "content": "Here\\'s one of the test cases:\\n\\ngas = [4]\\ncost = [5]\\n\\nThe car starts at index 0 and must return to where it is located. The cost must be 0, and the travel must be possible, regardless of the amount of gas available at the station, because we\\'re already there."
                    },
                    {
                        "username": "comeonelton",
                        "content": "Here is a case.\\ngas[4, 1, 3, 6, 1]\\ncost[2, 4, 2, 2, 3]\\n\\nSolution: starting index(begin from 0) could be 2 and 3.\\n\\nAm I missing something?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "easy c++.\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int sum_gas=0,sum_cost=0,start=0,curr=0;\\n        for(int i=0;i<cost.size();i++){\\n            sum_gas+=gas[i];\\n            sum_cost+=cost[i];\\n        }\\n        if(sum_gas<sum_cost)return -1;\\n        for(int i=0;i<gas.size();i++){\\n            curr+=gas[i]-cost[i];\\n            if(curr<0){start=i+1;\\n            curr=0;}\\n        }\\n        return start;\\n    }"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Some of test cases:\\ng3 = [5,1,2,3,4]; c3 = [4,4,1,5,1] # 4\\ng4 = [3,1,1]; c4 = [1,2,2] # 0\\ng5 = [5,5,1,3,4]; c5 = [8,1,7,1,1] # 3\\ng6 = [1,2,3,4,5,5,70]; c6 = [2,3,4,3,9,6,2] # 6\\ng8 = [2,5,1,4,3]; c8 = [3,2,2,2,6] # 1\\n"
                    }
                ]
            },
            {
                "id": 1571285,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    // return max distance that can reach, otherwise can complete and return -1\\n    int startWithN(int start, vector<int>& gas, vector<int>& cost) {\\n        int sum = 0, n = gas.size();\\n        for(int i = 0; i < n; ++i) {\\n            int distance = (i+start) % n;\\n            sum += (gas[distance] - cost[distance]);\\n            //printf(\"sum %d\\\\n\", sum);\\n            if(sum < 0) {\\n                return distance;\\n            }\\n        }\\n        return -1;\\n    }\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size();\\n        for(int i = 0; i < n; ++i) {\\n            \\n            int k = startWithN(i, gas, cost);\\n            //printf(\"start with %d, %d\\\\n\", i,k);\\n            if(k == -1) {\\n                return i;\\n            } else if(k > i) {\\n                i = k;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "unknown_unknown",
                        "content": "![image](https://assets.leetcode.com/users/images/10216980-50f9-4b3e-99a4-43f5257ea46d_1644235608.0222747.png)\\n"
                    },
                    {
                        "username": "mandy1339",
                        "content": "I really hope I don\\'t get a problem like this on a contest or I will run out of time doing the medium."
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "gas  [4,5,2,6,5,3]\\ncost [3,2,7,3,2,9]\\nOJ return is 3 instead of -1 .\\n\\nthen i suppose in this problem we dont need to go back to the starting station : after get station[2] , we finished the  travel . \\nbut  when sample is \\n\\ngas [2,4]\\ncost [3,4]\\n\\nOJ return is -1 . Is the OJ's code or test sample correct ?"
                    },
                    {
                        "username": "ck8300983",
                        "content": "I use the following input to test my code :  \\ngas [4 0 1]  \\ncost [3 2 1] \\n\\nand the OJ show the expected answer is 2 instead of -1. Is this an error for the Run code test?"
                    },
                    {
                        "username": "bazza",
                        "content": "The question asks if a trip can be made successfully, but it leaves out the definition of successfully. In an interview, I would ask the following questions (heck, I want the following questions answered by anyone before I even continue on this problems):\\n\\n  1. Would the idea be to complete a circuit and keep the cost below 1 unit per distance?\\n  2. Can there be negative costs (so we can earn money)?\\n  3. How big can the number of stations be?\\n\\nThe last two questions can be easily deduced from the online judge if one has patients. But the first question is essential to this problem.\\n\\nDoes anyone have insight?"
                    },
                    {
                        "username": "duhaime",
                        "content": "Here\\'s one of the test cases:\\n\\ngas = [4]\\ncost = [5]\\n\\nThe car starts at index 0 and must return to where it is located. The cost must be 0, and the travel must be possible, regardless of the amount of gas available at the station, because we\\'re already there."
                    },
                    {
                        "username": "comeonelton",
                        "content": "Here is a case.\\ngas[4, 1, 3, 6, 1]\\ncost[2, 4, 2, 2, 3]\\n\\nSolution: starting index(begin from 0) could be 2 and 3.\\n\\nAm I missing something?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "easy c++.\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int sum_gas=0,sum_cost=0,start=0,curr=0;\\n        for(int i=0;i<cost.size();i++){\\n            sum_gas+=gas[i];\\n            sum_cost+=cost[i];\\n        }\\n        if(sum_gas<sum_cost)return -1;\\n        for(int i=0;i<gas.size();i++){\\n            curr+=gas[i]-cost[i];\\n            if(curr<0){start=i+1;\\n            curr=0;}\\n        }\\n        return start;\\n    }"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Some of test cases:\\ng3 = [5,1,2,3,4]; c3 = [4,4,1,5,1] # 4\\ng4 = [3,1,1]; c4 = [1,2,2] # 0\\ng5 = [5,5,1,3,4]; c5 = [8,1,7,1,1] # 3\\ng6 = [1,2,3,4,5,5,70]; c6 = [2,3,4,3,9,6,2] # 6\\ng8 = [2,5,1,4,3]; c8 = [3,2,2,2,6] # 1\\n"
                    }
                ]
            },
            {
                "id": 1571286,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    // return max distance that can reach, otherwise can complete and return -1\\n    int startWithN(int start, vector<int>& gas, vector<int>& cost) {\\n        int sum = 0, n = gas.size();\\n        for(int i = 0; i < n; ++i) {\\n            int distance = (i+start) % n;\\n            sum += (gas[distance] - cost[distance]);\\n            //printf(\"sum %d\\\\n\", sum);\\n            if(sum < 0) {\\n                return distance;\\n            }\\n        }\\n        return -1;\\n    }\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size();\\n        for(int i = 0; i < n; ++i) {\\n            \\n            int k = startWithN(i, gas, cost);\\n            //printf(\"start with %d, %d\\\\n\", i,k);\\n            if(k == -1) {\\n                return i;\\n            } else if(k > i) {\\n                i = k;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "unknown_unknown",
                        "content": "![image](https://assets.leetcode.com/users/images/10216980-50f9-4b3e-99a4-43f5257ea46d_1644235608.0222747.png)\\n"
                    },
                    {
                        "username": "mandy1339",
                        "content": "I really hope I don\\'t get a problem like this on a contest or I will run out of time doing the medium."
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "gas  [4,5,2,6,5,3]\\ncost [3,2,7,3,2,9]\\nOJ return is 3 instead of -1 .\\n\\nthen i suppose in this problem we dont need to go back to the starting station : after get station[2] , we finished the  travel . \\nbut  when sample is \\n\\ngas [2,4]\\ncost [3,4]\\n\\nOJ return is -1 . Is the OJ's code or test sample correct ?"
                    },
                    {
                        "username": "ck8300983",
                        "content": "I use the following input to test my code :  \\ngas [4 0 1]  \\ncost [3 2 1] \\n\\nand the OJ show the expected answer is 2 instead of -1. Is this an error for the Run code test?"
                    },
                    {
                        "username": "bazza",
                        "content": "The question asks if a trip can be made successfully, but it leaves out the definition of successfully. In an interview, I would ask the following questions (heck, I want the following questions answered by anyone before I even continue on this problems):\\n\\n  1. Would the idea be to complete a circuit and keep the cost below 1 unit per distance?\\n  2. Can there be negative costs (so we can earn money)?\\n  3. How big can the number of stations be?\\n\\nThe last two questions can be easily deduced from the online judge if one has patients. But the first question is essential to this problem.\\n\\nDoes anyone have insight?"
                    },
                    {
                        "username": "duhaime",
                        "content": "Here\\'s one of the test cases:\\n\\ngas = [4]\\ncost = [5]\\n\\nThe car starts at index 0 and must return to where it is located. The cost must be 0, and the travel must be possible, regardless of the amount of gas available at the station, because we\\'re already there."
                    },
                    {
                        "username": "comeonelton",
                        "content": "Here is a case.\\ngas[4, 1, 3, 6, 1]\\ncost[2, 4, 2, 2, 3]\\n\\nSolution: starting index(begin from 0) could be 2 and 3.\\n\\nAm I missing something?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "easy c++.\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int sum_gas=0,sum_cost=0,start=0,curr=0;\\n        for(int i=0;i<cost.size();i++){\\n            sum_gas+=gas[i];\\n            sum_cost+=cost[i];\\n        }\\n        if(sum_gas<sum_cost)return -1;\\n        for(int i=0;i<gas.size();i++){\\n            curr+=gas[i]-cost[i];\\n            if(curr<0){start=i+1;\\n            curr=0;}\\n        }\\n        return start;\\n    }"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Some of test cases:\\ng3 = [5,1,2,3,4]; c3 = [4,4,1,5,1] # 4\\ng4 = [3,1,1]; c4 = [1,2,2] # 0\\ng5 = [5,5,1,3,4]; c5 = [8,1,7,1,1] # 3\\ng6 = [1,2,3,4,5,5,70]; c6 = [2,3,4,3,9,6,2] # 6\\ng8 = [2,5,1,4,3]; c8 = [3,2,2,2,6] # 1\\n"
                    }
                ]
            },
            {
                "id": 1567210,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    // return max distance that can reach, otherwise can complete and return -1\\n    int startWithN(int start, vector<int>& gas, vector<int>& cost) {\\n        int sum = 0, n = gas.size();\\n        for(int i = 0; i < n; ++i) {\\n            int distance = (i+start) % n;\\n            sum += (gas[distance] - cost[distance]);\\n            //printf(\"sum %d\\\\n\", sum);\\n            if(sum < 0) {\\n                return distance;\\n            }\\n        }\\n        return -1;\\n    }\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size();\\n        for(int i = 0; i < n; ++i) {\\n            \\n            int k = startWithN(i, gas, cost);\\n            //printf(\"start with %d, %d\\\\n\", i,k);\\n            if(k == -1) {\\n                return i;\\n            } else if(k > i) {\\n                i = k;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "unknown_unknown",
                        "content": "![image](https://assets.leetcode.com/users/images/10216980-50f9-4b3e-99a4-43f5257ea46d_1644235608.0222747.png)\\n"
                    },
                    {
                        "username": "mandy1339",
                        "content": "I really hope I don\\'t get a problem like this on a contest or I will run out of time doing the medium."
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "gas  [4,5,2,6,5,3]\\ncost [3,2,7,3,2,9]\\nOJ return is 3 instead of -1 .\\n\\nthen i suppose in this problem we dont need to go back to the starting station : after get station[2] , we finished the  travel . \\nbut  when sample is \\n\\ngas [2,4]\\ncost [3,4]\\n\\nOJ return is -1 . Is the OJ's code or test sample correct ?"
                    },
                    {
                        "username": "ck8300983",
                        "content": "I use the following input to test my code :  \\ngas [4 0 1]  \\ncost [3 2 1] \\n\\nand the OJ show the expected answer is 2 instead of -1. Is this an error for the Run code test?"
                    },
                    {
                        "username": "bazza",
                        "content": "The question asks if a trip can be made successfully, but it leaves out the definition of successfully. In an interview, I would ask the following questions (heck, I want the following questions answered by anyone before I even continue on this problems):\\n\\n  1. Would the idea be to complete a circuit and keep the cost below 1 unit per distance?\\n  2. Can there be negative costs (so we can earn money)?\\n  3. How big can the number of stations be?\\n\\nThe last two questions can be easily deduced from the online judge if one has patients. But the first question is essential to this problem.\\n\\nDoes anyone have insight?"
                    },
                    {
                        "username": "duhaime",
                        "content": "Here\\'s one of the test cases:\\n\\ngas = [4]\\ncost = [5]\\n\\nThe car starts at index 0 and must return to where it is located. The cost must be 0, and the travel must be possible, regardless of the amount of gas available at the station, because we\\'re already there."
                    },
                    {
                        "username": "comeonelton",
                        "content": "Here is a case.\\ngas[4, 1, 3, 6, 1]\\ncost[2, 4, 2, 2, 3]\\n\\nSolution: starting index(begin from 0) could be 2 and 3.\\n\\nAm I missing something?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "easy c++.\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int sum_gas=0,sum_cost=0,start=0,curr=0;\\n        for(int i=0;i<cost.size();i++){\\n            sum_gas+=gas[i];\\n            sum_cost+=cost[i];\\n        }\\n        if(sum_gas<sum_cost)return -1;\\n        for(int i=0;i<gas.size();i++){\\n            curr+=gas[i]-cost[i];\\n            if(curr<0){start=i+1;\\n            curr=0;}\\n        }\\n        return start;\\n    }"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Some of test cases:\\ng3 = [5,1,2,3,4]; c3 = [4,4,1,5,1] # 4\\ng4 = [3,1,1]; c4 = [1,2,2] # 0\\ng5 = [5,5,1,3,4]; c5 = [8,1,7,1,1] # 3\\ng6 = [1,2,3,4,5,5,70]; c6 = [2,3,4,3,9,6,2] # 6\\ng8 = [2,5,1,4,3]; c8 = [3,2,2,2,6] # 1\\n"
                    }
                ]
            },
            {
                "id": 1575755,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    // return max distance that can reach, otherwise can complete and return -1\\n    int startWithN(int start, vector<int>& gas, vector<int>& cost) {\\n        int sum = 0, n = gas.size();\\n        for(int i = 0; i < n; ++i) {\\n            int distance = (i+start) % n;\\n            sum += (gas[distance] - cost[distance]);\\n            //printf(\"sum %d\\\\n\", sum);\\n            if(sum < 0) {\\n                return distance;\\n            }\\n        }\\n        return -1;\\n    }\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size();\\n        for(int i = 0; i < n; ++i) {\\n            \\n            int k = startWithN(i, gas, cost);\\n            //printf(\"start with %d, %d\\\\n\", i,k);\\n            if(k == -1) {\\n                return i;\\n            } else if(k > i) {\\n                i = k;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "unknown_unknown",
                        "content": "![image](https://assets.leetcode.com/users/images/10216980-50f9-4b3e-99a4-43f5257ea46d_1644235608.0222747.png)\\n"
                    },
                    {
                        "username": "mandy1339",
                        "content": "I really hope I don\\'t get a problem like this on a contest or I will run out of time doing the medium."
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "gas  [4,5,2,6,5,3]\\ncost [3,2,7,3,2,9]\\nOJ return is 3 instead of -1 .\\n\\nthen i suppose in this problem we dont need to go back to the starting station : after get station[2] , we finished the  travel . \\nbut  when sample is \\n\\ngas [2,4]\\ncost [3,4]\\n\\nOJ return is -1 . Is the OJ's code or test sample correct ?"
                    },
                    {
                        "username": "ck8300983",
                        "content": "I use the following input to test my code :  \\ngas [4 0 1]  \\ncost [3 2 1] \\n\\nand the OJ show the expected answer is 2 instead of -1. Is this an error for the Run code test?"
                    },
                    {
                        "username": "bazza",
                        "content": "The question asks if a trip can be made successfully, but it leaves out the definition of successfully. In an interview, I would ask the following questions (heck, I want the following questions answered by anyone before I even continue on this problems):\\n\\n  1. Would the idea be to complete a circuit and keep the cost below 1 unit per distance?\\n  2. Can there be negative costs (so we can earn money)?\\n  3. How big can the number of stations be?\\n\\nThe last two questions can be easily deduced from the online judge if one has patients. But the first question is essential to this problem.\\n\\nDoes anyone have insight?"
                    },
                    {
                        "username": "duhaime",
                        "content": "Here\\'s one of the test cases:\\n\\ngas = [4]\\ncost = [5]\\n\\nThe car starts at index 0 and must return to where it is located. The cost must be 0, and the travel must be possible, regardless of the amount of gas available at the station, because we\\'re already there."
                    },
                    {
                        "username": "comeonelton",
                        "content": "Here is a case.\\ngas[4, 1, 3, 6, 1]\\ncost[2, 4, 2, 2, 3]\\n\\nSolution: starting index(begin from 0) could be 2 and 3.\\n\\nAm I missing something?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "easy c++.\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int sum_gas=0,sum_cost=0,start=0,curr=0;\\n        for(int i=0;i<cost.size();i++){\\n            sum_gas+=gas[i];\\n            sum_cost+=cost[i];\\n        }\\n        if(sum_gas<sum_cost)return -1;\\n        for(int i=0;i<gas.size();i++){\\n            curr+=gas[i]-cost[i];\\n            if(curr<0){start=i+1;\\n            curr=0;}\\n        }\\n        return start;\\n    }"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Some of test cases:\\ng3 = [5,1,2,3,4]; c3 = [4,4,1,5,1] # 4\\ng4 = [3,1,1]; c4 = [1,2,2] # 0\\ng5 = [5,5,1,3,4]; c5 = [8,1,7,1,1] # 3\\ng6 = [1,2,3,4,5,5,70]; c6 = [2,3,4,3,9,6,2] # 6\\ng8 = [2,5,1,4,3]; c8 = [3,2,2,2,6] # 1\\n"
                    }
                ]
            },
            {
                "id": 1568951,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    // return max distance that can reach, otherwise can complete and return -1\\n    int startWithN(int start, vector<int>& gas, vector<int>& cost) {\\n        int sum = 0, n = gas.size();\\n        for(int i = 0; i < n; ++i) {\\n            int distance = (i+start) % n;\\n            sum += (gas[distance] - cost[distance]);\\n            //printf(\"sum %d\\\\n\", sum);\\n            if(sum < 0) {\\n                return distance;\\n            }\\n        }\\n        return -1;\\n    }\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size();\\n        for(int i = 0; i < n; ++i) {\\n            \\n            int k = startWithN(i, gas, cost);\\n            //printf(\"start with %d, %d\\\\n\", i,k);\\n            if(k == -1) {\\n                return i;\\n            } else if(k > i) {\\n                i = k;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "unknown_unknown",
                        "content": "![image](https://assets.leetcode.com/users/images/10216980-50f9-4b3e-99a4-43f5257ea46d_1644235608.0222747.png)\\n"
                    },
                    {
                        "username": "mandy1339",
                        "content": "I really hope I don\\'t get a problem like this on a contest or I will run out of time doing the medium."
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "gas  [4,5,2,6,5,3]\\ncost [3,2,7,3,2,9]\\nOJ return is 3 instead of -1 .\\n\\nthen i suppose in this problem we dont need to go back to the starting station : after get station[2] , we finished the  travel . \\nbut  when sample is \\n\\ngas [2,4]\\ncost [3,4]\\n\\nOJ return is -1 . Is the OJ's code or test sample correct ?"
                    },
                    {
                        "username": "ck8300983",
                        "content": "I use the following input to test my code :  \\ngas [4 0 1]  \\ncost [3 2 1] \\n\\nand the OJ show the expected answer is 2 instead of -1. Is this an error for the Run code test?"
                    },
                    {
                        "username": "bazza",
                        "content": "The question asks if a trip can be made successfully, but it leaves out the definition of successfully. In an interview, I would ask the following questions (heck, I want the following questions answered by anyone before I even continue on this problems):\\n\\n  1. Would the idea be to complete a circuit and keep the cost below 1 unit per distance?\\n  2. Can there be negative costs (so we can earn money)?\\n  3. How big can the number of stations be?\\n\\nThe last two questions can be easily deduced from the online judge if one has patients. But the first question is essential to this problem.\\n\\nDoes anyone have insight?"
                    },
                    {
                        "username": "duhaime",
                        "content": "Here\\'s one of the test cases:\\n\\ngas = [4]\\ncost = [5]\\n\\nThe car starts at index 0 and must return to where it is located. The cost must be 0, and the travel must be possible, regardless of the amount of gas available at the station, because we\\'re already there."
                    },
                    {
                        "username": "comeonelton",
                        "content": "Here is a case.\\ngas[4, 1, 3, 6, 1]\\ncost[2, 4, 2, 2, 3]\\n\\nSolution: starting index(begin from 0) could be 2 and 3.\\n\\nAm I missing something?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "easy c++.\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int sum_gas=0,sum_cost=0,start=0,curr=0;\\n        for(int i=0;i<cost.size();i++){\\n            sum_gas+=gas[i];\\n            sum_cost+=cost[i];\\n        }\\n        if(sum_gas<sum_cost)return -1;\\n        for(int i=0;i<gas.size();i++){\\n            curr+=gas[i]-cost[i];\\n            if(curr<0){start=i+1;\\n            curr=0;}\\n        }\\n        return start;\\n    }"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Some of test cases:\\ng3 = [5,1,2,3,4]; c3 = [4,4,1,5,1] # 4\\ng4 = [3,1,1]; c4 = [1,2,2] # 0\\ng5 = [5,5,1,3,4]; c5 = [8,1,7,1,1] # 3\\ng6 = [1,2,3,4,5,5,70]; c6 = [2,3,4,3,9,6,2] # 6\\ng8 = [2,5,1,4,3]; c8 = [3,2,2,2,6] # 1\\n"
                    }
                ]
            },
            {
                "id": 1746082,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    // return max distance that can reach, otherwise can complete and return -1\\n    int startWithN(int start, vector<int>& gas, vector<int>& cost) {\\n        int sum = 0, n = gas.size();\\n        for(int i = 0; i < n; ++i) {\\n            int distance = (i+start) % n;\\n            sum += (gas[distance] - cost[distance]);\\n            //printf(\"sum %d\\\\n\", sum);\\n            if(sum < 0) {\\n                return distance;\\n            }\\n        }\\n        return -1;\\n    }\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size();\\n        for(int i = 0; i < n; ++i) {\\n            \\n            int k = startWithN(i, gas, cost);\\n            //printf(\"start with %d, %d\\\\n\", i,k);\\n            if(k == -1) {\\n                return i;\\n            } else if(k > i) {\\n                i = k;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "unknown_unknown",
                        "content": "![image](https://assets.leetcode.com/users/images/10216980-50f9-4b3e-99a4-43f5257ea46d_1644235608.0222747.png)\\n"
                    },
                    {
                        "username": "mandy1339",
                        "content": "I really hope I don\\'t get a problem like this on a contest or I will run out of time doing the medium."
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "gas  [4,5,2,6,5,3]\\ncost [3,2,7,3,2,9]\\nOJ return is 3 instead of -1 .\\n\\nthen i suppose in this problem we dont need to go back to the starting station : after get station[2] , we finished the  travel . \\nbut  when sample is \\n\\ngas [2,4]\\ncost [3,4]\\n\\nOJ return is -1 . Is the OJ's code or test sample correct ?"
                    },
                    {
                        "username": "ck8300983",
                        "content": "I use the following input to test my code :  \\ngas [4 0 1]  \\ncost [3 2 1] \\n\\nand the OJ show the expected answer is 2 instead of -1. Is this an error for the Run code test?"
                    },
                    {
                        "username": "bazza",
                        "content": "The question asks if a trip can be made successfully, but it leaves out the definition of successfully. In an interview, I would ask the following questions (heck, I want the following questions answered by anyone before I even continue on this problems):\\n\\n  1. Would the idea be to complete a circuit and keep the cost below 1 unit per distance?\\n  2. Can there be negative costs (so we can earn money)?\\n  3. How big can the number of stations be?\\n\\nThe last two questions can be easily deduced from the online judge if one has patients. But the first question is essential to this problem.\\n\\nDoes anyone have insight?"
                    },
                    {
                        "username": "duhaime",
                        "content": "Here\\'s one of the test cases:\\n\\ngas = [4]\\ncost = [5]\\n\\nThe car starts at index 0 and must return to where it is located. The cost must be 0, and the travel must be possible, regardless of the amount of gas available at the station, because we\\'re already there."
                    },
                    {
                        "username": "comeonelton",
                        "content": "Here is a case.\\ngas[4, 1, 3, 6, 1]\\ncost[2, 4, 2, 2, 3]\\n\\nSolution: starting index(begin from 0) could be 2 and 3.\\n\\nAm I missing something?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "easy c++.\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int sum_gas=0,sum_cost=0,start=0,curr=0;\\n        for(int i=0;i<cost.size();i++){\\n            sum_gas+=gas[i];\\n            sum_cost+=cost[i];\\n        }\\n        if(sum_gas<sum_cost)return -1;\\n        for(int i=0;i<gas.size();i++){\\n            curr+=gas[i]-cost[i];\\n            if(curr<0){start=i+1;\\n            curr=0;}\\n        }\\n        return start;\\n    }"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Some of test cases:\\ng3 = [5,1,2,3,4]; c3 = [4,4,1,5,1] # 4\\ng4 = [3,1,1]; c4 = [1,2,2] # 0\\ng5 = [5,5,1,3,4]; c5 = [8,1,7,1,1] # 3\\ng6 = [1,2,3,4,5,5,70]; c6 = [2,3,4,3,9,6,2] # 6\\ng8 = [2,5,1,4,3]; c8 = [3,2,2,2,6] # 1\\n"
                    }
                ]
            },
            {
                "id": 2067104,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    // return max distance that can reach, otherwise can complete and return -1\\n    int startWithN(int start, vector<int>& gas, vector<int>& cost) {\\n        int sum = 0, n = gas.size();\\n        for(int i = 0; i < n; ++i) {\\n            int distance = (i+start) % n;\\n            sum += (gas[distance] - cost[distance]);\\n            //printf(\"sum %d\\\\n\", sum);\\n            if(sum < 0) {\\n                return distance;\\n            }\\n        }\\n        return -1;\\n    }\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n = gas.size();\\n        for(int i = 0; i < n; ++i) {\\n            \\n            int k = startWithN(i, gas, cost);\\n            //printf(\"start with %d, %d\\\\n\", i,k);\\n            if(k == -1) {\\n                return i;\\n            } else if(k > i) {\\n                i = k;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "unknown_unknown",
                        "content": "![image](https://assets.leetcode.com/users/images/10216980-50f9-4b3e-99a4-43f5257ea46d_1644235608.0222747.png)\\n"
                    },
                    {
                        "username": "mandy1339",
                        "content": "I really hope I don\\'t get a problem like this on a contest or I will run out of time doing the medium."
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "gas  [4,5,2,6,5,3]\\ncost [3,2,7,3,2,9]\\nOJ return is 3 instead of -1 .\\n\\nthen i suppose in this problem we dont need to go back to the starting station : after get station[2] , we finished the  travel . \\nbut  when sample is \\n\\ngas [2,4]\\ncost [3,4]\\n\\nOJ return is -1 . Is the OJ's code or test sample correct ?"
                    },
                    {
                        "username": "ck8300983",
                        "content": "I use the following input to test my code :  \\ngas [4 0 1]  \\ncost [3 2 1] \\n\\nand the OJ show the expected answer is 2 instead of -1. Is this an error for the Run code test?"
                    },
                    {
                        "username": "bazza",
                        "content": "The question asks if a trip can be made successfully, but it leaves out the definition of successfully. In an interview, I would ask the following questions (heck, I want the following questions answered by anyone before I even continue on this problems):\\n\\n  1. Would the idea be to complete a circuit and keep the cost below 1 unit per distance?\\n  2. Can there be negative costs (so we can earn money)?\\n  3. How big can the number of stations be?\\n\\nThe last two questions can be easily deduced from the online judge if one has patients. But the first question is essential to this problem.\\n\\nDoes anyone have insight?"
                    },
                    {
                        "username": "duhaime",
                        "content": "Here\\'s one of the test cases:\\n\\ngas = [4]\\ncost = [5]\\n\\nThe car starts at index 0 and must return to where it is located. The cost must be 0, and the travel must be possible, regardless of the amount of gas available at the station, because we\\'re already there."
                    },
                    {
                        "username": "comeonelton",
                        "content": "Here is a case.\\ngas[4, 1, 3, 6, 1]\\ncost[2, 4, 2, 2, 3]\\n\\nSolution: starting index(begin from 0) could be 2 and 3.\\n\\nAm I missing something?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "easy c++.\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int sum_gas=0,sum_cost=0,start=0,curr=0;\\n        for(int i=0;i<cost.size();i++){\\n            sum_gas+=gas[i];\\n            sum_cost+=cost[i];\\n        }\\n        if(sum_gas<sum_cost)return -1;\\n        for(int i=0;i<gas.size();i++){\\n            curr+=gas[i]-cost[i];\\n            if(curr<0){start=i+1;\\n            curr=0;}\\n        }\\n        return start;\\n    }"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Some of test cases:\\ng3 = [5,1,2,3,4]; c3 = [4,4,1,5,1] # 4\\ng4 = [3,1,1]; c4 = [1,2,2] # 0\\ng5 = [5,5,1,3,4]; c5 = [8,1,7,1,1] # 3\\ng6 = [1,2,3,4,5,5,70]; c6 = [2,3,4,3,9,6,2] # 6\\ng8 = [2,5,1,4,3]; c8 = [3,2,2,2,6] # 1\\n"
                    }
                ]
            },
            {
                "id": 2061844,
                "content": [
                    {
                        "username": "MrZydeco",
                        "content": "I don\\'t agree with your answer for the edge case where n=gas.length=cost.length = 1. If there\\'s only one gas station, there\\'s no gas needed to travel to the next station, because there is no next gas station. And so it shouldn\\'t matter how much gas you have (even 0). You\\'re already at the destination!\\n\\nI SHOULD NOT HAVE TO SUBMIT CODE THAT IS GRADED WRONG TO LEARN WHAT YOU ARE THINKING. YOU NEED TO EXPLAIN IT IN THE PROBLEM.\\n"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Think greedily, at any position(index), if the difference between gas and cost is negative, it implies that position(index) won\\'t be our starting point !! Think greedy, move on and check the same at the next position.\\n\\nHope this helps :\\nhttps://leetcode.com/problems/gas-station/solutions/4032025/java-solution-easy-to-understand-beats-94-users/"
                    },
                    {
                        "username": "FalkorX",
                        "content": "The problem that I have with the tests is that you can indeed go from one station to the next if the difference between gas and cost is 0, which is not negative. If a station has 3 gas and the cost to the next station is also 3, I can definitely start there. The same is true if the station has 0 gas, but 0 is needed to go to the next station."
                    },
                    {
                        "username": "Nik6174",
                        "content": "It initially seemed quite difficult, but once I stated to break down the problem into different parts, it call became easy.\\nI solved with the following approach:\\n1) Find the difference of the two arrays\\n2) Find the cumulative value of the difference\\n3) Start at the index just after the index of minimum element.\\nNote: In case of multiple min value indexes, we have to find the index such that it\\'s next index is minimum. that is simple if the index is anything except the last one, as in that case we will have to take the 0th index."
                    },
                    {
                        "username": "ankitk742",
                        "content": "1. Brute force approach will take O (n^2) and you will get TLE.\\n\\n2. While moving we are either adding the gas tanks or decreasing the gas tanks ( gas[i]-cost[i]). So anytime while moving if the gas tanks becomes negative it implies we can\\'t move any further .\\n\\n3. So your first task would be to check for that position from where you can move further without your gas tank  < 0.\\n\\n4. Finally when giving the answer check if the sum of gas tanks > sum of cost tanks if yes you can return the first position i.e you got in step 3\\n\\n5. Else return 1.\\n\\n\\nP.S : I couldn\\'t able to solve this problem myself :-( but tried hard to get the understanding. Hope it helps "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is a simple programming problem if you take for granted that solution exists iff sum(gas) >= sum(cost). The necessity part of this criterion is obvious, but the sufficiency part is not at all. Does anyone has a strong math proof of this, i.e. sum(gas) >= sum(cost) yields the existence of the solution?"
                    },
                    {
                        "username": "firezdog",
                        "content": "It seems like you could just use back-tracking for this -- every station is at some position on the route (if a route exists)?"
                    },
                    {
                        "username": "FalkorX",
                        "content": "The task states\\n> If there exists a solution, it is guaranteed to be unique\\n\\nBut I am afraid this is not the case for the test cases that are running when I submit. I ran into this example (slightly simplified):\\n```\\ngas = [2, 0, 0, 0]\\ncost = [0, 1, 0, 0]\\n```\\nThe expected output is `0` which is one possible answer, but my solution is `2`, which is also possible, since it requires no gas to go from `2 -> 3 -> 0`. Hence the solution is not unique."
                    },
                    {
                        "username": "user1242L",
                        "content": "The code isn\\'t terminating despite entering the if statement where it says return i as shown in the image below.\\nhttps://i.stack.imgur.com/wQ8gN.png \\n\\nHere is the full code:\\n\\n`class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int temp, flag;\\n\\n        for(int i=0;i<n;i++){\\n            temp=0;\\n            flag=0;\\n            cout<<\"i: \"<<i;\\n            for(int j=i;j!=i || flag==0;j++){\\n                \\n                if(j==n && i==0)\\n                    break;\\n                if(j==n)\\n                    j=0;\\n                if(j==i)\\n                    flag=1;\\n                \\n                temp=temp+gas[j];\\n                temp=temp-cost[j];\\n                cout<<\" J: \"<<j<<\" Temp: \"<<temp<<endl;\\n                if(temp<0 && j!=n-1){\\n                    i=j;\\n                    break;\\n                }\\n                if(temp<0)\\n                    break;\\n            }\\n            if(temp>=0){\\n                cout<<\"HI\"<<endl;\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};`\\n\\nI tried putting a break statement after return i as well and it didn\\'t help.\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "for the given example the gains are [-2,-2,-2,3,3] I understand that we dont take first three indices as valid starting points. But we take the first 3 since it allows us to reach the end. But the \"second\" 3 or the last index also lets us reach the end. Why not take that? how do you know without checking that the first is the correct one.\\n\\nI have seen multiple solutions/explainations but all of them say \"THAT IS HOW GREEDY WORKS\". If someone could explain this without the greedy catchphrase I\\'d appreciate it. Since I won\\'t know for sure that this is greedy. "
                    },
                    {
                        "username": "MK_2510",
                        "content": "Can anyone tell me whats wrong with this code and why it is returning after first iteration only?\\n\\n\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int i=0;\\n        while(gas[i]<cost[i]) {\\n            i++;\\n            if(i==gas.size())\\n            return -1;\\n        }\\n        \\n        int start=i;\\n       \\n        int tank=gas[start]-cost[start]+gas[start+1];\\n        int j=start+1;\\n        while(j!=start){\\n            if(j==gas.size()) \\n                j=0;\\n             if(tank<gas[j]){ return -1;}\\n            tank=tank-cost[j]+gas[j+1];\\n           \\n            j++;\\n           \\n        }\\n        return start;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2053618,
                "content": [
                    {
                        "username": "MrZydeco",
                        "content": "I don\\'t agree with your answer for the edge case where n=gas.length=cost.length = 1. If there\\'s only one gas station, there\\'s no gas needed to travel to the next station, because there is no next gas station. And so it shouldn\\'t matter how much gas you have (even 0). You\\'re already at the destination!\\n\\nI SHOULD NOT HAVE TO SUBMIT CODE THAT IS GRADED WRONG TO LEARN WHAT YOU ARE THINKING. YOU NEED TO EXPLAIN IT IN THE PROBLEM.\\n"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Think greedily, at any position(index), if the difference between gas and cost is negative, it implies that position(index) won\\'t be our starting point !! Think greedy, move on and check the same at the next position.\\n\\nHope this helps :\\nhttps://leetcode.com/problems/gas-station/solutions/4032025/java-solution-easy-to-understand-beats-94-users/"
                    },
                    {
                        "username": "FalkorX",
                        "content": "The problem that I have with the tests is that you can indeed go from one station to the next if the difference between gas and cost is 0, which is not negative. If a station has 3 gas and the cost to the next station is also 3, I can definitely start there. The same is true if the station has 0 gas, but 0 is needed to go to the next station."
                    },
                    {
                        "username": "Nik6174",
                        "content": "It initially seemed quite difficult, but once I stated to break down the problem into different parts, it call became easy.\\nI solved with the following approach:\\n1) Find the difference of the two arrays\\n2) Find the cumulative value of the difference\\n3) Start at the index just after the index of minimum element.\\nNote: In case of multiple min value indexes, we have to find the index such that it\\'s next index is minimum. that is simple if the index is anything except the last one, as in that case we will have to take the 0th index."
                    },
                    {
                        "username": "ankitk742",
                        "content": "1. Brute force approach will take O (n^2) and you will get TLE.\\n\\n2. While moving we are either adding the gas tanks or decreasing the gas tanks ( gas[i]-cost[i]). So anytime while moving if the gas tanks becomes negative it implies we can\\'t move any further .\\n\\n3. So your first task would be to check for that position from where you can move further without your gas tank  < 0.\\n\\n4. Finally when giving the answer check if the sum of gas tanks > sum of cost tanks if yes you can return the first position i.e you got in step 3\\n\\n5. Else return 1.\\n\\n\\nP.S : I couldn\\'t able to solve this problem myself :-( but tried hard to get the understanding. Hope it helps "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is a simple programming problem if you take for granted that solution exists iff sum(gas) >= sum(cost). The necessity part of this criterion is obvious, but the sufficiency part is not at all. Does anyone has a strong math proof of this, i.e. sum(gas) >= sum(cost) yields the existence of the solution?"
                    },
                    {
                        "username": "firezdog",
                        "content": "It seems like you could just use back-tracking for this -- every station is at some position on the route (if a route exists)?"
                    },
                    {
                        "username": "FalkorX",
                        "content": "The task states\\n> If there exists a solution, it is guaranteed to be unique\\n\\nBut I am afraid this is not the case for the test cases that are running when I submit. I ran into this example (slightly simplified):\\n```\\ngas = [2, 0, 0, 0]\\ncost = [0, 1, 0, 0]\\n```\\nThe expected output is `0` which is one possible answer, but my solution is `2`, which is also possible, since it requires no gas to go from `2 -> 3 -> 0`. Hence the solution is not unique."
                    },
                    {
                        "username": "user1242L",
                        "content": "The code isn\\'t terminating despite entering the if statement where it says return i as shown in the image below.\\nhttps://i.stack.imgur.com/wQ8gN.png \\n\\nHere is the full code:\\n\\n`class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int temp, flag;\\n\\n        for(int i=0;i<n;i++){\\n            temp=0;\\n            flag=0;\\n            cout<<\"i: \"<<i;\\n            for(int j=i;j!=i || flag==0;j++){\\n                \\n                if(j==n && i==0)\\n                    break;\\n                if(j==n)\\n                    j=0;\\n                if(j==i)\\n                    flag=1;\\n                \\n                temp=temp+gas[j];\\n                temp=temp-cost[j];\\n                cout<<\" J: \"<<j<<\" Temp: \"<<temp<<endl;\\n                if(temp<0 && j!=n-1){\\n                    i=j;\\n                    break;\\n                }\\n                if(temp<0)\\n                    break;\\n            }\\n            if(temp>=0){\\n                cout<<\"HI\"<<endl;\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};`\\n\\nI tried putting a break statement after return i as well and it didn\\'t help.\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "for the given example the gains are [-2,-2,-2,3,3] I understand that we dont take first three indices as valid starting points. But we take the first 3 since it allows us to reach the end. But the \"second\" 3 or the last index also lets us reach the end. Why not take that? how do you know without checking that the first is the correct one.\\n\\nI have seen multiple solutions/explainations but all of them say \"THAT IS HOW GREEDY WORKS\". If someone could explain this without the greedy catchphrase I\\'d appreciate it. Since I won\\'t know for sure that this is greedy. "
                    },
                    {
                        "username": "MK_2510",
                        "content": "Can anyone tell me whats wrong with this code and why it is returning after first iteration only?\\n\\n\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int i=0;\\n        while(gas[i]<cost[i]) {\\n            i++;\\n            if(i==gas.size())\\n            return -1;\\n        }\\n        \\n        int start=i;\\n       \\n        int tank=gas[start]-cost[start]+gas[start+1];\\n        int j=start+1;\\n        while(j!=start){\\n            if(j==gas.size()) \\n                j=0;\\n             if(tank<gas[j]){ return -1;}\\n            tank=tank-cost[j]+gas[j+1];\\n           \\n            j++;\\n           \\n        }\\n        return start;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2046844,
                "content": [
                    {
                        "username": "MrZydeco",
                        "content": "I don\\'t agree with your answer for the edge case where n=gas.length=cost.length = 1. If there\\'s only one gas station, there\\'s no gas needed to travel to the next station, because there is no next gas station. And so it shouldn\\'t matter how much gas you have (even 0). You\\'re already at the destination!\\n\\nI SHOULD NOT HAVE TO SUBMIT CODE THAT IS GRADED WRONG TO LEARN WHAT YOU ARE THINKING. YOU NEED TO EXPLAIN IT IN THE PROBLEM.\\n"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Think greedily, at any position(index), if the difference between gas and cost is negative, it implies that position(index) won\\'t be our starting point !! Think greedy, move on and check the same at the next position.\\n\\nHope this helps :\\nhttps://leetcode.com/problems/gas-station/solutions/4032025/java-solution-easy-to-understand-beats-94-users/"
                    },
                    {
                        "username": "FalkorX",
                        "content": "The problem that I have with the tests is that you can indeed go from one station to the next if the difference between gas and cost is 0, which is not negative. If a station has 3 gas and the cost to the next station is also 3, I can definitely start there. The same is true if the station has 0 gas, but 0 is needed to go to the next station."
                    },
                    {
                        "username": "Nik6174",
                        "content": "It initially seemed quite difficult, but once I stated to break down the problem into different parts, it call became easy.\\nI solved with the following approach:\\n1) Find the difference of the two arrays\\n2) Find the cumulative value of the difference\\n3) Start at the index just after the index of minimum element.\\nNote: In case of multiple min value indexes, we have to find the index such that it\\'s next index is minimum. that is simple if the index is anything except the last one, as in that case we will have to take the 0th index."
                    },
                    {
                        "username": "ankitk742",
                        "content": "1. Brute force approach will take O (n^2) and you will get TLE.\\n\\n2. While moving we are either adding the gas tanks or decreasing the gas tanks ( gas[i]-cost[i]). So anytime while moving if the gas tanks becomes negative it implies we can\\'t move any further .\\n\\n3. So your first task would be to check for that position from where you can move further without your gas tank  < 0.\\n\\n4. Finally when giving the answer check if the sum of gas tanks > sum of cost tanks if yes you can return the first position i.e you got in step 3\\n\\n5. Else return 1.\\n\\n\\nP.S : I couldn\\'t able to solve this problem myself :-( but tried hard to get the understanding. Hope it helps "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is a simple programming problem if you take for granted that solution exists iff sum(gas) >= sum(cost). The necessity part of this criterion is obvious, but the sufficiency part is not at all. Does anyone has a strong math proof of this, i.e. sum(gas) >= sum(cost) yields the existence of the solution?"
                    },
                    {
                        "username": "firezdog",
                        "content": "It seems like you could just use back-tracking for this -- every station is at some position on the route (if a route exists)?"
                    },
                    {
                        "username": "FalkorX",
                        "content": "The task states\\n> If there exists a solution, it is guaranteed to be unique\\n\\nBut I am afraid this is not the case for the test cases that are running when I submit. I ran into this example (slightly simplified):\\n```\\ngas = [2, 0, 0, 0]\\ncost = [0, 1, 0, 0]\\n```\\nThe expected output is `0` which is one possible answer, but my solution is `2`, which is also possible, since it requires no gas to go from `2 -> 3 -> 0`. Hence the solution is not unique."
                    },
                    {
                        "username": "user1242L",
                        "content": "The code isn\\'t terminating despite entering the if statement where it says return i as shown in the image below.\\nhttps://i.stack.imgur.com/wQ8gN.png \\n\\nHere is the full code:\\n\\n`class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int temp, flag;\\n\\n        for(int i=0;i<n;i++){\\n            temp=0;\\n            flag=0;\\n            cout<<\"i: \"<<i;\\n            for(int j=i;j!=i || flag==0;j++){\\n                \\n                if(j==n && i==0)\\n                    break;\\n                if(j==n)\\n                    j=0;\\n                if(j==i)\\n                    flag=1;\\n                \\n                temp=temp+gas[j];\\n                temp=temp-cost[j];\\n                cout<<\" J: \"<<j<<\" Temp: \"<<temp<<endl;\\n                if(temp<0 && j!=n-1){\\n                    i=j;\\n                    break;\\n                }\\n                if(temp<0)\\n                    break;\\n            }\\n            if(temp>=0){\\n                cout<<\"HI\"<<endl;\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};`\\n\\nI tried putting a break statement after return i as well and it didn\\'t help.\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "for the given example the gains are [-2,-2,-2,3,3] I understand that we dont take first three indices as valid starting points. But we take the first 3 since it allows us to reach the end. But the \"second\" 3 or the last index also lets us reach the end. Why not take that? how do you know without checking that the first is the correct one.\\n\\nI have seen multiple solutions/explainations but all of them say \"THAT IS HOW GREEDY WORKS\". If someone could explain this without the greedy catchphrase I\\'d appreciate it. Since I won\\'t know for sure that this is greedy. "
                    },
                    {
                        "username": "MK_2510",
                        "content": "Can anyone tell me whats wrong with this code and why it is returning after first iteration only?\\n\\n\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int i=0;\\n        while(gas[i]<cost[i]) {\\n            i++;\\n            if(i==gas.size())\\n            return -1;\\n        }\\n        \\n        int start=i;\\n       \\n        int tank=gas[start]-cost[start]+gas[start+1];\\n        int j=start+1;\\n        while(j!=start){\\n            if(j==gas.size()) \\n                j=0;\\n             if(tank<gas[j]){ return -1;}\\n            tank=tank-cost[j]+gas[j+1];\\n           \\n            j++;\\n           \\n        }\\n        return start;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2035593,
                "content": [
                    {
                        "username": "MrZydeco",
                        "content": "I don\\'t agree with your answer for the edge case where n=gas.length=cost.length = 1. If there\\'s only one gas station, there\\'s no gas needed to travel to the next station, because there is no next gas station. And so it shouldn\\'t matter how much gas you have (even 0). You\\'re already at the destination!\\n\\nI SHOULD NOT HAVE TO SUBMIT CODE THAT IS GRADED WRONG TO LEARN WHAT YOU ARE THINKING. YOU NEED TO EXPLAIN IT IN THE PROBLEM.\\n"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Think greedily, at any position(index), if the difference between gas and cost is negative, it implies that position(index) won\\'t be our starting point !! Think greedy, move on and check the same at the next position.\\n\\nHope this helps :\\nhttps://leetcode.com/problems/gas-station/solutions/4032025/java-solution-easy-to-understand-beats-94-users/"
                    },
                    {
                        "username": "FalkorX",
                        "content": "The problem that I have with the tests is that you can indeed go from one station to the next if the difference between gas and cost is 0, which is not negative. If a station has 3 gas and the cost to the next station is also 3, I can definitely start there. The same is true if the station has 0 gas, but 0 is needed to go to the next station."
                    },
                    {
                        "username": "Nik6174",
                        "content": "It initially seemed quite difficult, but once I stated to break down the problem into different parts, it call became easy.\\nI solved with the following approach:\\n1) Find the difference of the two arrays\\n2) Find the cumulative value of the difference\\n3) Start at the index just after the index of minimum element.\\nNote: In case of multiple min value indexes, we have to find the index such that it\\'s next index is minimum. that is simple if the index is anything except the last one, as in that case we will have to take the 0th index."
                    },
                    {
                        "username": "ankitk742",
                        "content": "1. Brute force approach will take O (n^2) and you will get TLE.\\n\\n2. While moving we are either adding the gas tanks or decreasing the gas tanks ( gas[i]-cost[i]). So anytime while moving if the gas tanks becomes negative it implies we can\\'t move any further .\\n\\n3. So your first task would be to check for that position from where you can move further without your gas tank  < 0.\\n\\n4. Finally when giving the answer check if the sum of gas tanks > sum of cost tanks if yes you can return the first position i.e you got in step 3\\n\\n5. Else return 1.\\n\\n\\nP.S : I couldn\\'t able to solve this problem myself :-( but tried hard to get the understanding. Hope it helps "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is a simple programming problem if you take for granted that solution exists iff sum(gas) >= sum(cost). The necessity part of this criterion is obvious, but the sufficiency part is not at all. Does anyone has a strong math proof of this, i.e. sum(gas) >= sum(cost) yields the existence of the solution?"
                    },
                    {
                        "username": "firezdog",
                        "content": "It seems like you could just use back-tracking for this -- every station is at some position on the route (if a route exists)?"
                    },
                    {
                        "username": "FalkorX",
                        "content": "The task states\\n> If there exists a solution, it is guaranteed to be unique\\n\\nBut I am afraid this is not the case for the test cases that are running when I submit. I ran into this example (slightly simplified):\\n```\\ngas = [2, 0, 0, 0]\\ncost = [0, 1, 0, 0]\\n```\\nThe expected output is `0` which is one possible answer, but my solution is `2`, which is also possible, since it requires no gas to go from `2 -> 3 -> 0`. Hence the solution is not unique."
                    },
                    {
                        "username": "user1242L",
                        "content": "The code isn\\'t terminating despite entering the if statement where it says return i as shown in the image below.\\nhttps://i.stack.imgur.com/wQ8gN.png \\n\\nHere is the full code:\\n\\n`class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int temp, flag;\\n\\n        for(int i=0;i<n;i++){\\n            temp=0;\\n            flag=0;\\n            cout<<\"i: \"<<i;\\n            for(int j=i;j!=i || flag==0;j++){\\n                \\n                if(j==n && i==0)\\n                    break;\\n                if(j==n)\\n                    j=0;\\n                if(j==i)\\n                    flag=1;\\n                \\n                temp=temp+gas[j];\\n                temp=temp-cost[j];\\n                cout<<\" J: \"<<j<<\" Temp: \"<<temp<<endl;\\n                if(temp<0 && j!=n-1){\\n                    i=j;\\n                    break;\\n                }\\n                if(temp<0)\\n                    break;\\n            }\\n            if(temp>=0){\\n                cout<<\"HI\"<<endl;\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};`\\n\\nI tried putting a break statement after return i as well and it didn\\'t help.\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "for the given example the gains are [-2,-2,-2,3,3] I understand that we dont take first three indices as valid starting points. But we take the first 3 since it allows us to reach the end. But the \"second\" 3 or the last index also lets us reach the end. Why not take that? how do you know without checking that the first is the correct one.\\n\\nI have seen multiple solutions/explainations but all of them say \"THAT IS HOW GREEDY WORKS\". If someone could explain this without the greedy catchphrase I\\'d appreciate it. Since I won\\'t know for sure that this is greedy. "
                    },
                    {
                        "username": "MK_2510",
                        "content": "Can anyone tell me whats wrong with this code and why it is returning after first iteration only?\\n\\n\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int i=0;\\n        while(gas[i]<cost[i]) {\\n            i++;\\n            if(i==gas.size())\\n            return -1;\\n        }\\n        \\n        int start=i;\\n       \\n        int tank=gas[start]-cost[start]+gas[start+1];\\n        int j=start+1;\\n        while(j!=start){\\n            if(j==gas.size()) \\n                j=0;\\n             if(tank<gas[j]){ return -1;}\\n            tank=tank-cost[j]+gas[j+1];\\n           \\n            j++;\\n           \\n        }\\n        return start;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2029651,
                "content": [
                    {
                        "username": "MrZydeco",
                        "content": "I don\\'t agree with your answer for the edge case where n=gas.length=cost.length = 1. If there\\'s only one gas station, there\\'s no gas needed to travel to the next station, because there is no next gas station. And so it shouldn\\'t matter how much gas you have (even 0). You\\'re already at the destination!\\n\\nI SHOULD NOT HAVE TO SUBMIT CODE THAT IS GRADED WRONG TO LEARN WHAT YOU ARE THINKING. YOU NEED TO EXPLAIN IT IN THE PROBLEM.\\n"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Think greedily, at any position(index), if the difference between gas and cost is negative, it implies that position(index) won\\'t be our starting point !! Think greedy, move on and check the same at the next position.\\n\\nHope this helps :\\nhttps://leetcode.com/problems/gas-station/solutions/4032025/java-solution-easy-to-understand-beats-94-users/"
                    },
                    {
                        "username": "FalkorX",
                        "content": "The problem that I have with the tests is that you can indeed go from one station to the next if the difference between gas and cost is 0, which is not negative. If a station has 3 gas and the cost to the next station is also 3, I can definitely start there. The same is true if the station has 0 gas, but 0 is needed to go to the next station."
                    },
                    {
                        "username": "Nik6174",
                        "content": "It initially seemed quite difficult, but once I stated to break down the problem into different parts, it call became easy.\\nI solved with the following approach:\\n1) Find the difference of the two arrays\\n2) Find the cumulative value of the difference\\n3) Start at the index just after the index of minimum element.\\nNote: In case of multiple min value indexes, we have to find the index such that it\\'s next index is minimum. that is simple if the index is anything except the last one, as in that case we will have to take the 0th index."
                    },
                    {
                        "username": "ankitk742",
                        "content": "1. Brute force approach will take O (n^2) and you will get TLE.\\n\\n2. While moving we are either adding the gas tanks or decreasing the gas tanks ( gas[i]-cost[i]). So anytime while moving if the gas tanks becomes negative it implies we can\\'t move any further .\\n\\n3. So your first task would be to check for that position from where you can move further without your gas tank  < 0.\\n\\n4. Finally when giving the answer check if the sum of gas tanks > sum of cost tanks if yes you can return the first position i.e you got in step 3\\n\\n5. Else return 1.\\n\\n\\nP.S : I couldn\\'t able to solve this problem myself :-( but tried hard to get the understanding. Hope it helps "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is a simple programming problem if you take for granted that solution exists iff sum(gas) >= sum(cost). The necessity part of this criterion is obvious, but the sufficiency part is not at all. Does anyone has a strong math proof of this, i.e. sum(gas) >= sum(cost) yields the existence of the solution?"
                    },
                    {
                        "username": "firezdog",
                        "content": "It seems like you could just use back-tracking for this -- every station is at some position on the route (if a route exists)?"
                    },
                    {
                        "username": "FalkorX",
                        "content": "The task states\\n> If there exists a solution, it is guaranteed to be unique\\n\\nBut I am afraid this is not the case for the test cases that are running when I submit. I ran into this example (slightly simplified):\\n```\\ngas = [2, 0, 0, 0]\\ncost = [0, 1, 0, 0]\\n```\\nThe expected output is `0` which is one possible answer, but my solution is `2`, which is also possible, since it requires no gas to go from `2 -> 3 -> 0`. Hence the solution is not unique."
                    },
                    {
                        "username": "user1242L",
                        "content": "The code isn\\'t terminating despite entering the if statement where it says return i as shown in the image below.\\nhttps://i.stack.imgur.com/wQ8gN.png \\n\\nHere is the full code:\\n\\n`class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int temp, flag;\\n\\n        for(int i=0;i<n;i++){\\n            temp=0;\\n            flag=0;\\n            cout<<\"i: \"<<i;\\n            for(int j=i;j!=i || flag==0;j++){\\n                \\n                if(j==n && i==0)\\n                    break;\\n                if(j==n)\\n                    j=0;\\n                if(j==i)\\n                    flag=1;\\n                \\n                temp=temp+gas[j];\\n                temp=temp-cost[j];\\n                cout<<\" J: \"<<j<<\" Temp: \"<<temp<<endl;\\n                if(temp<0 && j!=n-1){\\n                    i=j;\\n                    break;\\n                }\\n                if(temp<0)\\n                    break;\\n            }\\n            if(temp>=0){\\n                cout<<\"HI\"<<endl;\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};`\\n\\nI tried putting a break statement after return i as well and it didn\\'t help.\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "for the given example the gains are [-2,-2,-2,3,3] I understand that we dont take first three indices as valid starting points. But we take the first 3 since it allows us to reach the end. But the \"second\" 3 or the last index also lets us reach the end. Why not take that? how do you know without checking that the first is the correct one.\\n\\nI have seen multiple solutions/explainations but all of them say \"THAT IS HOW GREEDY WORKS\". If someone could explain this without the greedy catchphrase I\\'d appreciate it. Since I won\\'t know for sure that this is greedy. "
                    },
                    {
                        "username": "MK_2510",
                        "content": "Can anyone tell me whats wrong with this code and why it is returning after first iteration only?\\n\\n\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int i=0;\\n        while(gas[i]<cost[i]) {\\n            i++;\\n            if(i==gas.size())\\n            return -1;\\n        }\\n        \\n        int start=i;\\n       \\n        int tank=gas[start]-cost[start]+gas[start+1];\\n        int j=start+1;\\n        while(j!=start){\\n            if(j==gas.size()) \\n                j=0;\\n             if(tank<gas[j]){ return -1;}\\n            tank=tank-cost[j]+gas[j+1];\\n           \\n            j++;\\n           \\n        }\\n        return start;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2008461,
                "content": [
                    {
                        "username": "MrZydeco",
                        "content": "I don\\'t agree with your answer for the edge case where n=gas.length=cost.length = 1. If there\\'s only one gas station, there\\'s no gas needed to travel to the next station, because there is no next gas station. And so it shouldn\\'t matter how much gas you have (even 0). You\\'re already at the destination!\\n\\nI SHOULD NOT HAVE TO SUBMIT CODE THAT IS GRADED WRONG TO LEARN WHAT YOU ARE THINKING. YOU NEED TO EXPLAIN IT IN THE PROBLEM.\\n"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Think greedily, at any position(index), if the difference between gas and cost is negative, it implies that position(index) won\\'t be our starting point !! Think greedy, move on and check the same at the next position.\\n\\nHope this helps :\\nhttps://leetcode.com/problems/gas-station/solutions/4032025/java-solution-easy-to-understand-beats-94-users/"
                    },
                    {
                        "username": "FalkorX",
                        "content": "The problem that I have with the tests is that you can indeed go from one station to the next if the difference between gas and cost is 0, which is not negative. If a station has 3 gas and the cost to the next station is also 3, I can definitely start there. The same is true if the station has 0 gas, but 0 is needed to go to the next station."
                    },
                    {
                        "username": "Nik6174",
                        "content": "It initially seemed quite difficult, but once I stated to break down the problem into different parts, it call became easy.\\nI solved with the following approach:\\n1) Find the difference of the two arrays\\n2) Find the cumulative value of the difference\\n3) Start at the index just after the index of minimum element.\\nNote: In case of multiple min value indexes, we have to find the index such that it\\'s next index is minimum. that is simple if the index is anything except the last one, as in that case we will have to take the 0th index."
                    },
                    {
                        "username": "ankitk742",
                        "content": "1. Brute force approach will take O (n^2) and you will get TLE.\\n\\n2. While moving we are either adding the gas tanks or decreasing the gas tanks ( gas[i]-cost[i]). So anytime while moving if the gas tanks becomes negative it implies we can\\'t move any further .\\n\\n3. So your first task would be to check for that position from where you can move further without your gas tank  < 0.\\n\\n4. Finally when giving the answer check if the sum of gas tanks > sum of cost tanks if yes you can return the first position i.e you got in step 3\\n\\n5. Else return 1.\\n\\n\\nP.S : I couldn\\'t able to solve this problem myself :-( but tried hard to get the understanding. Hope it helps "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is a simple programming problem if you take for granted that solution exists iff sum(gas) >= sum(cost). The necessity part of this criterion is obvious, but the sufficiency part is not at all. Does anyone has a strong math proof of this, i.e. sum(gas) >= sum(cost) yields the existence of the solution?"
                    },
                    {
                        "username": "firezdog",
                        "content": "It seems like you could just use back-tracking for this -- every station is at some position on the route (if a route exists)?"
                    },
                    {
                        "username": "FalkorX",
                        "content": "The task states\\n> If there exists a solution, it is guaranteed to be unique\\n\\nBut I am afraid this is not the case for the test cases that are running when I submit. I ran into this example (slightly simplified):\\n```\\ngas = [2, 0, 0, 0]\\ncost = [0, 1, 0, 0]\\n```\\nThe expected output is `0` which is one possible answer, but my solution is `2`, which is also possible, since it requires no gas to go from `2 -> 3 -> 0`. Hence the solution is not unique."
                    },
                    {
                        "username": "user1242L",
                        "content": "The code isn\\'t terminating despite entering the if statement where it says return i as shown in the image below.\\nhttps://i.stack.imgur.com/wQ8gN.png \\n\\nHere is the full code:\\n\\n`class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int temp, flag;\\n\\n        for(int i=0;i<n;i++){\\n            temp=0;\\n            flag=0;\\n            cout<<\"i: \"<<i;\\n            for(int j=i;j!=i || flag==0;j++){\\n                \\n                if(j==n && i==0)\\n                    break;\\n                if(j==n)\\n                    j=0;\\n                if(j==i)\\n                    flag=1;\\n                \\n                temp=temp+gas[j];\\n                temp=temp-cost[j];\\n                cout<<\" J: \"<<j<<\" Temp: \"<<temp<<endl;\\n                if(temp<0 && j!=n-1){\\n                    i=j;\\n                    break;\\n                }\\n                if(temp<0)\\n                    break;\\n            }\\n            if(temp>=0){\\n                cout<<\"HI\"<<endl;\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};`\\n\\nI tried putting a break statement after return i as well and it didn\\'t help.\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "for the given example the gains are [-2,-2,-2,3,3] I understand that we dont take first three indices as valid starting points. But we take the first 3 since it allows us to reach the end. But the \"second\" 3 or the last index also lets us reach the end. Why not take that? how do you know without checking that the first is the correct one.\\n\\nI have seen multiple solutions/explainations but all of them say \"THAT IS HOW GREEDY WORKS\". If someone could explain this without the greedy catchphrase I\\'d appreciate it. Since I won\\'t know for sure that this is greedy. "
                    },
                    {
                        "username": "MK_2510",
                        "content": "Can anyone tell me whats wrong with this code and why it is returning after first iteration only?\\n\\n\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int i=0;\\n        while(gas[i]<cost[i]) {\\n            i++;\\n            if(i==gas.size())\\n            return -1;\\n        }\\n        \\n        int start=i;\\n       \\n        int tank=gas[start]-cost[start]+gas[start+1];\\n        int j=start+1;\\n        while(j!=start){\\n            if(j==gas.size()) \\n                j=0;\\n             if(tank<gas[j]){ return -1;}\\n            tank=tank-cost[j]+gas[j+1];\\n           \\n            j++;\\n           \\n        }\\n        return start;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1994487,
                "content": [
                    {
                        "username": "MrZydeco",
                        "content": "I don\\'t agree with your answer for the edge case where n=gas.length=cost.length = 1. If there\\'s only one gas station, there\\'s no gas needed to travel to the next station, because there is no next gas station. And so it shouldn\\'t matter how much gas you have (even 0). You\\'re already at the destination!\\n\\nI SHOULD NOT HAVE TO SUBMIT CODE THAT IS GRADED WRONG TO LEARN WHAT YOU ARE THINKING. YOU NEED TO EXPLAIN IT IN THE PROBLEM.\\n"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Think greedily, at any position(index), if the difference between gas and cost is negative, it implies that position(index) won\\'t be our starting point !! Think greedy, move on and check the same at the next position.\\n\\nHope this helps :\\nhttps://leetcode.com/problems/gas-station/solutions/4032025/java-solution-easy-to-understand-beats-94-users/"
                    },
                    {
                        "username": "FalkorX",
                        "content": "The problem that I have with the tests is that you can indeed go from one station to the next if the difference between gas and cost is 0, which is not negative. If a station has 3 gas and the cost to the next station is also 3, I can definitely start there. The same is true if the station has 0 gas, but 0 is needed to go to the next station."
                    },
                    {
                        "username": "Nik6174",
                        "content": "It initially seemed quite difficult, but once I stated to break down the problem into different parts, it call became easy.\\nI solved with the following approach:\\n1) Find the difference of the two arrays\\n2) Find the cumulative value of the difference\\n3) Start at the index just after the index of minimum element.\\nNote: In case of multiple min value indexes, we have to find the index such that it\\'s next index is minimum. that is simple if the index is anything except the last one, as in that case we will have to take the 0th index."
                    },
                    {
                        "username": "ankitk742",
                        "content": "1. Brute force approach will take O (n^2) and you will get TLE.\\n\\n2. While moving we are either adding the gas tanks or decreasing the gas tanks ( gas[i]-cost[i]). So anytime while moving if the gas tanks becomes negative it implies we can\\'t move any further .\\n\\n3. So your first task would be to check for that position from where you can move further without your gas tank  < 0.\\n\\n4. Finally when giving the answer check if the sum of gas tanks > sum of cost tanks if yes you can return the first position i.e you got in step 3\\n\\n5. Else return 1.\\n\\n\\nP.S : I couldn\\'t able to solve this problem myself :-( but tried hard to get the understanding. Hope it helps "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is a simple programming problem if you take for granted that solution exists iff sum(gas) >= sum(cost). The necessity part of this criterion is obvious, but the sufficiency part is not at all. Does anyone has a strong math proof of this, i.e. sum(gas) >= sum(cost) yields the existence of the solution?"
                    },
                    {
                        "username": "firezdog",
                        "content": "It seems like you could just use back-tracking for this -- every station is at some position on the route (if a route exists)?"
                    },
                    {
                        "username": "FalkorX",
                        "content": "The task states\\n> If there exists a solution, it is guaranteed to be unique\\n\\nBut I am afraid this is not the case for the test cases that are running when I submit. I ran into this example (slightly simplified):\\n```\\ngas = [2, 0, 0, 0]\\ncost = [0, 1, 0, 0]\\n```\\nThe expected output is `0` which is one possible answer, but my solution is `2`, which is also possible, since it requires no gas to go from `2 -> 3 -> 0`. Hence the solution is not unique."
                    },
                    {
                        "username": "user1242L",
                        "content": "The code isn\\'t terminating despite entering the if statement where it says return i as shown in the image below.\\nhttps://i.stack.imgur.com/wQ8gN.png \\n\\nHere is the full code:\\n\\n`class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int temp, flag;\\n\\n        for(int i=0;i<n;i++){\\n            temp=0;\\n            flag=0;\\n            cout<<\"i: \"<<i;\\n            for(int j=i;j!=i || flag==0;j++){\\n                \\n                if(j==n && i==0)\\n                    break;\\n                if(j==n)\\n                    j=0;\\n                if(j==i)\\n                    flag=1;\\n                \\n                temp=temp+gas[j];\\n                temp=temp-cost[j];\\n                cout<<\" J: \"<<j<<\" Temp: \"<<temp<<endl;\\n                if(temp<0 && j!=n-1){\\n                    i=j;\\n                    break;\\n                }\\n                if(temp<0)\\n                    break;\\n            }\\n            if(temp>=0){\\n                cout<<\"HI\"<<endl;\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};`\\n\\nI tried putting a break statement after return i as well and it didn\\'t help.\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "for the given example the gains are [-2,-2,-2,3,3] I understand that we dont take first three indices as valid starting points. But we take the first 3 since it allows us to reach the end. But the \"second\" 3 or the last index also lets us reach the end. Why not take that? how do you know without checking that the first is the correct one.\\n\\nI have seen multiple solutions/explainations but all of them say \"THAT IS HOW GREEDY WORKS\". If someone could explain this without the greedy catchphrase I\\'d appreciate it. Since I won\\'t know for sure that this is greedy. "
                    },
                    {
                        "username": "MK_2510",
                        "content": "Can anyone tell me whats wrong with this code and why it is returning after first iteration only?\\n\\n\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int i=0;\\n        while(gas[i]<cost[i]) {\\n            i++;\\n            if(i==gas.size())\\n            return -1;\\n        }\\n        \\n        int start=i;\\n       \\n        int tank=gas[start]-cost[start]+gas[start+1];\\n        int j=start+1;\\n        while(j!=start){\\n            if(j==gas.size()) \\n                j=0;\\n             if(tank<gas[j]){ return -1;}\\n            tank=tank-cost[j]+gas[j+1];\\n           \\n            j++;\\n           \\n        }\\n        return start;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1988562,
                "content": [
                    {
                        "username": "MrZydeco",
                        "content": "I don\\'t agree with your answer for the edge case where n=gas.length=cost.length = 1. If there\\'s only one gas station, there\\'s no gas needed to travel to the next station, because there is no next gas station. And so it shouldn\\'t matter how much gas you have (even 0). You\\'re already at the destination!\\n\\nI SHOULD NOT HAVE TO SUBMIT CODE THAT IS GRADED WRONG TO LEARN WHAT YOU ARE THINKING. YOU NEED TO EXPLAIN IT IN THE PROBLEM.\\n"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Think greedily, at any position(index), if the difference between gas and cost is negative, it implies that position(index) won\\'t be our starting point !! Think greedy, move on and check the same at the next position.\\n\\nHope this helps :\\nhttps://leetcode.com/problems/gas-station/solutions/4032025/java-solution-easy-to-understand-beats-94-users/"
                    },
                    {
                        "username": "FalkorX",
                        "content": "The problem that I have with the tests is that you can indeed go from one station to the next if the difference between gas and cost is 0, which is not negative. If a station has 3 gas and the cost to the next station is also 3, I can definitely start there. The same is true if the station has 0 gas, but 0 is needed to go to the next station."
                    },
                    {
                        "username": "Nik6174",
                        "content": "It initially seemed quite difficult, but once I stated to break down the problem into different parts, it call became easy.\\nI solved with the following approach:\\n1) Find the difference of the two arrays\\n2) Find the cumulative value of the difference\\n3) Start at the index just after the index of minimum element.\\nNote: In case of multiple min value indexes, we have to find the index such that it\\'s next index is minimum. that is simple if the index is anything except the last one, as in that case we will have to take the 0th index."
                    },
                    {
                        "username": "ankitk742",
                        "content": "1. Brute force approach will take O (n^2) and you will get TLE.\\n\\n2. While moving we are either adding the gas tanks or decreasing the gas tanks ( gas[i]-cost[i]). So anytime while moving if the gas tanks becomes negative it implies we can\\'t move any further .\\n\\n3. So your first task would be to check for that position from where you can move further without your gas tank  < 0.\\n\\n4. Finally when giving the answer check if the sum of gas tanks > sum of cost tanks if yes you can return the first position i.e you got in step 3\\n\\n5. Else return 1.\\n\\n\\nP.S : I couldn\\'t able to solve this problem myself :-( but tried hard to get the understanding. Hope it helps "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is a simple programming problem if you take for granted that solution exists iff sum(gas) >= sum(cost). The necessity part of this criterion is obvious, but the sufficiency part is not at all. Does anyone has a strong math proof of this, i.e. sum(gas) >= sum(cost) yields the existence of the solution?"
                    },
                    {
                        "username": "firezdog",
                        "content": "It seems like you could just use back-tracking for this -- every station is at some position on the route (if a route exists)?"
                    },
                    {
                        "username": "FalkorX",
                        "content": "The task states\\n> If there exists a solution, it is guaranteed to be unique\\n\\nBut I am afraid this is not the case for the test cases that are running when I submit. I ran into this example (slightly simplified):\\n```\\ngas = [2, 0, 0, 0]\\ncost = [0, 1, 0, 0]\\n```\\nThe expected output is `0` which is one possible answer, but my solution is `2`, which is also possible, since it requires no gas to go from `2 -> 3 -> 0`. Hence the solution is not unique."
                    },
                    {
                        "username": "user1242L",
                        "content": "The code isn\\'t terminating despite entering the if statement where it says return i as shown in the image below.\\nhttps://i.stack.imgur.com/wQ8gN.png \\n\\nHere is the full code:\\n\\n`class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int temp, flag;\\n\\n        for(int i=0;i<n;i++){\\n            temp=0;\\n            flag=0;\\n            cout<<\"i: \"<<i;\\n            for(int j=i;j!=i || flag==0;j++){\\n                \\n                if(j==n && i==0)\\n                    break;\\n                if(j==n)\\n                    j=0;\\n                if(j==i)\\n                    flag=1;\\n                \\n                temp=temp+gas[j];\\n                temp=temp-cost[j];\\n                cout<<\" J: \"<<j<<\" Temp: \"<<temp<<endl;\\n                if(temp<0 && j!=n-1){\\n                    i=j;\\n                    break;\\n                }\\n                if(temp<0)\\n                    break;\\n            }\\n            if(temp>=0){\\n                cout<<\"HI\"<<endl;\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};`\\n\\nI tried putting a break statement after return i as well and it didn\\'t help.\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "for the given example the gains are [-2,-2,-2,3,3] I understand that we dont take first three indices as valid starting points. But we take the first 3 since it allows us to reach the end. But the \"second\" 3 or the last index also lets us reach the end. Why not take that? how do you know without checking that the first is the correct one.\\n\\nI have seen multiple solutions/explainations but all of them say \"THAT IS HOW GREEDY WORKS\". If someone could explain this without the greedy catchphrase I\\'d appreciate it. Since I won\\'t know for sure that this is greedy. "
                    },
                    {
                        "username": "MK_2510",
                        "content": "Can anyone tell me whats wrong with this code and why it is returning after first iteration only?\\n\\n\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int i=0;\\n        while(gas[i]<cost[i]) {\\n            i++;\\n            if(i==gas.size())\\n            return -1;\\n        }\\n        \\n        int start=i;\\n       \\n        int tank=gas[start]-cost[start]+gas[start+1];\\n        int j=start+1;\\n        while(j!=start){\\n            if(j==gas.size()) \\n                j=0;\\n             if(tank<gas[j]){ return -1;}\\n            tank=tank-cost[j]+gas[j+1];\\n           \\n            j++;\\n           \\n        }\\n        return start;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1986363,
                "content": [
                    {
                        "username": "MrZydeco",
                        "content": "I don\\'t agree with your answer for the edge case where n=gas.length=cost.length = 1. If there\\'s only one gas station, there\\'s no gas needed to travel to the next station, because there is no next gas station. And so it shouldn\\'t matter how much gas you have (even 0). You\\'re already at the destination!\\n\\nI SHOULD NOT HAVE TO SUBMIT CODE THAT IS GRADED WRONG TO LEARN WHAT YOU ARE THINKING. YOU NEED TO EXPLAIN IT IN THE PROBLEM.\\n"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Think greedily, at any position(index), if the difference between gas and cost is negative, it implies that position(index) won\\'t be our starting point !! Think greedy, move on and check the same at the next position.\\n\\nHope this helps :\\nhttps://leetcode.com/problems/gas-station/solutions/4032025/java-solution-easy-to-understand-beats-94-users/"
                    },
                    {
                        "username": "FalkorX",
                        "content": "The problem that I have with the tests is that you can indeed go from one station to the next if the difference between gas and cost is 0, which is not negative. If a station has 3 gas and the cost to the next station is also 3, I can definitely start there. The same is true if the station has 0 gas, but 0 is needed to go to the next station."
                    },
                    {
                        "username": "Nik6174",
                        "content": "It initially seemed quite difficult, but once I stated to break down the problem into different parts, it call became easy.\\nI solved with the following approach:\\n1) Find the difference of the two arrays\\n2) Find the cumulative value of the difference\\n3) Start at the index just after the index of minimum element.\\nNote: In case of multiple min value indexes, we have to find the index such that it\\'s next index is minimum. that is simple if the index is anything except the last one, as in that case we will have to take the 0th index."
                    },
                    {
                        "username": "ankitk742",
                        "content": "1. Brute force approach will take O (n^2) and you will get TLE.\\n\\n2. While moving we are either adding the gas tanks or decreasing the gas tanks ( gas[i]-cost[i]). So anytime while moving if the gas tanks becomes negative it implies we can\\'t move any further .\\n\\n3. So your first task would be to check for that position from where you can move further without your gas tank  < 0.\\n\\n4. Finally when giving the answer check if the sum of gas tanks > sum of cost tanks if yes you can return the first position i.e you got in step 3\\n\\n5. Else return 1.\\n\\n\\nP.S : I couldn\\'t able to solve this problem myself :-( but tried hard to get the understanding. Hope it helps "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is a simple programming problem if you take for granted that solution exists iff sum(gas) >= sum(cost). The necessity part of this criterion is obvious, but the sufficiency part is not at all. Does anyone has a strong math proof of this, i.e. sum(gas) >= sum(cost) yields the existence of the solution?"
                    },
                    {
                        "username": "firezdog",
                        "content": "It seems like you could just use back-tracking for this -- every station is at some position on the route (if a route exists)?"
                    },
                    {
                        "username": "FalkorX",
                        "content": "The task states\\n> If there exists a solution, it is guaranteed to be unique\\n\\nBut I am afraid this is not the case for the test cases that are running when I submit. I ran into this example (slightly simplified):\\n```\\ngas = [2, 0, 0, 0]\\ncost = [0, 1, 0, 0]\\n```\\nThe expected output is `0` which is one possible answer, but my solution is `2`, which is also possible, since it requires no gas to go from `2 -> 3 -> 0`. Hence the solution is not unique."
                    },
                    {
                        "username": "user1242L",
                        "content": "The code isn\\'t terminating despite entering the if statement where it says return i as shown in the image below.\\nhttps://i.stack.imgur.com/wQ8gN.png \\n\\nHere is the full code:\\n\\n`class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int temp, flag;\\n\\n        for(int i=0;i<n;i++){\\n            temp=0;\\n            flag=0;\\n            cout<<\"i: \"<<i;\\n            for(int j=i;j!=i || flag==0;j++){\\n                \\n                if(j==n && i==0)\\n                    break;\\n                if(j==n)\\n                    j=0;\\n                if(j==i)\\n                    flag=1;\\n                \\n                temp=temp+gas[j];\\n                temp=temp-cost[j];\\n                cout<<\" J: \"<<j<<\" Temp: \"<<temp<<endl;\\n                if(temp<0 && j!=n-1){\\n                    i=j;\\n                    break;\\n                }\\n                if(temp<0)\\n                    break;\\n            }\\n            if(temp>=0){\\n                cout<<\"HI\"<<endl;\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};`\\n\\nI tried putting a break statement after return i as well and it didn\\'t help.\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "for the given example the gains are [-2,-2,-2,3,3] I understand that we dont take first three indices as valid starting points. But we take the first 3 since it allows us to reach the end. But the \"second\" 3 or the last index also lets us reach the end. Why not take that? how do you know without checking that the first is the correct one.\\n\\nI have seen multiple solutions/explainations but all of them say \"THAT IS HOW GREEDY WORKS\". If someone could explain this without the greedy catchphrase I\\'d appreciate it. Since I won\\'t know for sure that this is greedy. "
                    },
                    {
                        "username": "MK_2510",
                        "content": "Can anyone tell me whats wrong with this code and why it is returning after first iteration only?\\n\\n\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int i=0;\\n        while(gas[i]<cost[i]) {\\n            i++;\\n            if(i==gas.size())\\n            return -1;\\n        }\\n        \\n        int start=i;\\n       \\n        int tank=gas[start]-cost[start]+gas[start+1];\\n        int j=start+1;\\n        while(j!=start){\\n            if(j==gas.size()) \\n                j=0;\\n             if(tank<gas[j]){ return -1;}\\n            tank=tank-cost[j]+gas[j+1];\\n           \\n            j++;\\n           \\n        }\\n        return start;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1967774,
                "content": [
                    {
                        "username": "MrZydeco",
                        "content": "I don\\'t agree with your answer for the edge case where n=gas.length=cost.length = 1. If there\\'s only one gas station, there\\'s no gas needed to travel to the next station, because there is no next gas station. And so it shouldn\\'t matter how much gas you have (even 0). You\\'re already at the destination!\\n\\nI SHOULD NOT HAVE TO SUBMIT CODE THAT IS GRADED WRONG TO LEARN WHAT YOU ARE THINKING. YOU NEED TO EXPLAIN IT IN THE PROBLEM.\\n"
                    },
                    {
                        "username": "Lakshya009",
                        "content": "Think greedily, at any position(index), if the difference between gas and cost is negative, it implies that position(index) won\\'t be our starting point !! Think greedy, move on and check the same at the next position.\\n\\nHope this helps :\\nhttps://leetcode.com/problems/gas-station/solutions/4032025/java-solution-easy-to-understand-beats-94-users/"
                    },
                    {
                        "username": "FalkorX",
                        "content": "The problem that I have with the tests is that you can indeed go from one station to the next if the difference between gas and cost is 0, which is not negative. If a station has 3 gas and the cost to the next station is also 3, I can definitely start there. The same is true if the station has 0 gas, but 0 is needed to go to the next station."
                    },
                    {
                        "username": "Nik6174",
                        "content": "It initially seemed quite difficult, but once I stated to break down the problem into different parts, it call became easy.\\nI solved with the following approach:\\n1) Find the difference of the two arrays\\n2) Find the cumulative value of the difference\\n3) Start at the index just after the index of minimum element.\\nNote: In case of multiple min value indexes, we have to find the index such that it\\'s next index is minimum. that is simple if the index is anything except the last one, as in that case we will have to take the 0th index."
                    },
                    {
                        "username": "ankitk742",
                        "content": "1. Brute force approach will take O (n^2) and you will get TLE.\\n\\n2. While moving we are either adding the gas tanks or decreasing the gas tanks ( gas[i]-cost[i]). So anytime while moving if the gas tanks becomes negative it implies we can\\'t move any further .\\n\\n3. So your first task would be to check for that position from where you can move further without your gas tank  < 0.\\n\\n4. Finally when giving the answer check if the sum of gas tanks > sum of cost tanks if yes you can return the first position i.e you got in step 3\\n\\n5. Else return 1.\\n\\n\\nP.S : I couldn\\'t able to solve this problem myself :-( but tried hard to get the understanding. Hope it helps "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is a simple programming problem if you take for granted that solution exists iff sum(gas) >= sum(cost). The necessity part of this criterion is obvious, but the sufficiency part is not at all. Does anyone has a strong math proof of this, i.e. sum(gas) >= sum(cost) yields the existence of the solution?"
                    },
                    {
                        "username": "firezdog",
                        "content": "It seems like you could just use back-tracking for this -- every station is at some position on the route (if a route exists)?"
                    },
                    {
                        "username": "FalkorX",
                        "content": "The task states\\n> If there exists a solution, it is guaranteed to be unique\\n\\nBut I am afraid this is not the case for the test cases that are running when I submit. I ran into this example (slightly simplified):\\n```\\ngas = [2, 0, 0, 0]\\ncost = [0, 1, 0, 0]\\n```\\nThe expected output is `0` which is one possible answer, but my solution is `2`, which is also possible, since it requires no gas to go from `2 -> 3 -> 0`. Hence the solution is not unique."
                    },
                    {
                        "username": "user1242L",
                        "content": "The code isn\\'t terminating despite entering the if statement where it says return i as shown in the image below.\\nhttps://i.stack.imgur.com/wQ8gN.png \\n\\nHere is the full code:\\n\\n`class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        \\n        int n=gas.size();\\n        int temp, flag;\\n\\n        for(int i=0;i<n;i++){\\n            temp=0;\\n            flag=0;\\n            cout<<\"i: \"<<i;\\n            for(int j=i;j!=i || flag==0;j++){\\n                \\n                if(j==n && i==0)\\n                    break;\\n                if(j==n)\\n                    j=0;\\n                if(j==i)\\n                    flag=1;\\n                \\n                temp=temp+gas[j];\\n                temp=temp-cost[j];\\n                cout<<\" J: \"<<j<<\" Temp: \"<<temp<<endl;\\n                if(temp<0 && j!=n-1){\\n                    i=j;\\n                    break;\\n                }\\n                if(temp<0)\\n                    break;\\n            }\\n            if(temp>=0){\\n                cout<<\"HI\"<<endl;\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};`\\n\\nI tried putting a break statement after return i as well and it didn\\'t help.\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "for the given example the gains are [-2,-2,-2,3,3] I understand that we dont take first three indices as valid starting points. But we take the first 3 since it allows us to reach the end. But the \"second\" 3 or the last index also lets us reach the end. Why not take that? how do you know without checking that the first is the correct one.\\n\\nI have seen multiple solutions/explainations but all of them say \"THAT IS HOW GREEDY WORKS\". If someone could explain this without the greedy catchphrase I\\'d appreciate it. Since I won\\'t know for sure that this is greedy. "
                    },
                    {
                        "username": "MK_2510",
                        "content": "Can anyone tell me whats wrong with this code and why it is returning after first iteration only?\\n\\n\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int i=0;\\n        while(gas[i]<cost[i]) {\\n            i++;\\n            if(i==gas.size())\\n            return -1;\\n        }\\n        \\n        int start=i;\\n       \\n        int tank=gas[start]-cost[start]+gas[start+1];\\n        int j=start+1;\\n        while(j!=start){\\n            if(j==gas.size()) \\n                j=0;\\n             if(tank<gas[j]){ return -1;}\\n            tank=tank-cost[j]+gas[j+1];\\n           \\n            j++;\\n           \\n        }\\n        return start;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1961996,
                "content": [
                    {
                        "username": "worsecoder",
                        "content": "For the input gas=[2,0,0,0,0,0] and cost=[0,1,0,0,0,0], why should the answer by 0 rather than 2?"
                    },
                    {
                        "username": "user1502o",
                        "content": "How can I open my discussion in new Tab?"
                    },
                    {
                        "username": "psionl0",
                        "content": "WOW. How did my solution perform so poorly? It is just a simple O(N) traversal through the array - once.\\nhttps://leetcode.com/submissions/detail/970208247/"
                    },
                    {
                        "username": "omkar_4535",
                        "content": " gas : [4,5,3,1,4]\ncost : [5,4,3,4,2]\nexpected output is -1 \nhow is it possible \nhere from gas station index 4 we can complete whole circuit\nthen why they are asking for -1\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "start index 4: gas = 4 units\\nGoto index 0: gas = 4-2 = 2 units\\nGoto index 1: gas = 2+4-5 = 1 unit\\nGoto index 2: gas = 1+3-3 = 1 units\\nGoto index 3: gas = 1+1-4 = -2 units\\n\\nNope. You won\\'t make it."
                    },
                    {
                        "username": "3boodr",
                        "content": "I\\'ve seen the greedy solution but i still don\\'t understand it. Guess i\\'m just dumb."
                    },
                    {
                        "username": "normanlmfung",
                        "content": "For example 1, Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2] Output: 3. But if you start at 2 also works. \\n\\n\\ttank = 3 (i==2 starting gas, no initial cost)\\n\\t\\n\\t+4-5\\n\\ttank = 2\\n\\t\\n\\t+5-1\\n\\ttank = 6\\n\\t\\n\\t+1-2\\n\\ttank = 5\\n\\t\\n\\t+2-3\\n\\ttank = 4\\n\\t\\n\\t+3-4\\n\\ttank = 3"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you\\'ve misunderstood the problem, if you start at i = 2 you just have 3 gas but you need 5 gas to move forward then this case is not valid.\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "this question is crap, so poorly explained. they made an effort to explain but its still not clear. "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "Can someone provide more testcases for me for this problem,please!...\\n"
                    },
                    {
                        "username": "user4270nA",
                        "content": "Hello,\\nOne the testcases to the question is:\\ngas = [4,5,2,6,5,3]\\ncost = [3,2,7,3,2,9]\\nI am able to find a solution starting at index 0 but it isn\\'t unique. The answer given is -1. But the question guarantees that the solution will be unique."
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        if(n==1)\\n        {\\n            if(gas[0]>=cost[0])\\n            return 0;\\n            else\\n            return -1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            gas[i]=gas[i]-cost[i];\\n        }\\n        long long sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=gas[i];\\n        }\\n        if(sum<0)\\n        return -1;\\n        int g=0,fi=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(gas[i]>0){\\n                long long sum1=0,count=0;\\n               for(int j=i;j<n+i;j++)\\n               {\\n                   count++;\\n                   sum1+=gas[j%n];\\n                   if(sum1<0)\\n                   break;\\n               }\\n               if(count==n)\\n               fi=i;\\n\\n             }\\n        }\\n        return fi;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amazing!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1932638,
                "content": [
                    {
                        "username": "worsecoder",
                        "content": "For the input gas=[2,0,0,0,0,0] and cost=[0,1,0,0,0,0], why should the answer by 0 rather than 2?"
                    },
                    {
                        "username": "user1502o",
                        "content": "How can I open my discussion in new Tab?"
                    },
                    {
                        "username": "psionl0",
                        "content": "WOW. How did my solution perform so poorly? It is just a simple O(N) traversal through the array - once.\\nhttps://leetcode.com/submissions/detail/970208247/"
                    },
                    {
                        "username": "omkar_4535",
                        "content": " gas : [4,5,3,1,4]\ncost : [5,4,3,4,2]\nexpected output is -1 \nhow is it possible \nhere from gas station index 4 we can complete whole circuit\nthen why they are asking for -1\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "start index 4: gas = 4 units\\nGoto index 0: gas = 4-2 = 2 units\\nGoto index 1: gas = 2+4-5 = 1 unit\\nGoto index 2: gas = 1+3-3 = 1 units\\nGoto index 3: gas = 1+1-4 = -2 units\\n\\nNope. You won\\'t make it."
                    },
                    {
                        "username": "3boodr",
                        "content": "I\\'ve seen the greedy solution but i still don\\'t understand it. Guess i\\'m just dumb."
                    },
                    {
                        "username": "normanlmfung",
                        "content": "For example 1, Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2] Output: 3. But if you start at 2 also works. \\n\\n\\ttank = 3 (i==2 starting gas, no initial cost)\\n\\t\\n\\t+4-5\\n\\ttank = 2\\n\\t\\n\\t+5-1\\n\\ttank = 6\\n\\t\\n\\t+1-2\\n\\ttank = 5\\n\\t\\n\\t+2-3\\n\\ttank = 4\\n\\t\\n\\t+3-4\\n\\ttank = 3"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you\\'ve misunderstood the problem, if you start at i = 2 you just have 3 gas but you need 5 gas to move forward then this case is not valid.\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "this question is crap, so poorly explained. they made an effort to explain but its still not clear. "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "Can someone provide more testcases for me for this problem,please!...\\n"
                    },
                    {
                        "username": "user4270nA",
                        "content": "Hello,\\nOne the testcases to the question is:\\ngas = [4,5,2,6,5,3]\\ncost = [3,2,7,3,2,9]\\nI am able to find a solution starting at index 0 but it isn\\'t unique. The answer given is -1. But the question guarantees that the solution will be unique."
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        if(n==1)\\n        {\\n            if(gas[0]>=cost[0])\\n            return 0;\\n            else\\n            return -1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            gas[i]=gas[i]-cost[i];\\n        }\\n        long long sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=gas[i];\\n        }\\n        if(sum<0)\\n        return -1;\\n        int g=0,fi=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(gas[i]>0){\\n                long long sum1=0,count=0;\\n               for(int j=i;j<n+i;j++)\\n               {\\n                   count++;\\n                   sum1+=gas[j%n];\\n                   if(sum1<0)\\n                   break;\\n               }\\n               if(count==n)\\n               fi=i;\\n\\n             }\\n        }\\n        return fi;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amazing!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1927794,
                "content": [
                    {
                        "username": "worsecoder",
                        "content": "For the input gas=[2,0,0,0,0,0] and cost=[0,1,0,0,0,0], why should the answer by 0 rather than 2?"
                    },
                    {
                        "username": "user1502o",
                        "content": "How can I open my discussion in new Tab?"
                    },
                    {
                        "username": "psionl0",
                        "content": "WOW. How did my solution perform so poorly? It is just a simple O(N) traversal through the array - once.\\nhttps://leetcode.com/submissions/detail/970208247/"
                    },
                    {
                        "username": "omkar_4535",
                        "content": " gas : [4,5,3,1,4]\ncost : [5,4,3,4,2]\nexpected output is -1 \nhow is it possible \nhere from gas station index 4 we can complete whole circuit\nthen why they are asking for -1\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "start index 4: gas = 4 units\\nGoto index 0: gas = 4-2 = 2 units\\nGoto index 1: gas = 2+4-5 = 1 unit\\nGoto index 2: gas = 1+3-3 = 1 units\\nGoto index 3: gas = 1+1-4 = -2 units\\n\\nNope. You won\\'t make it."
                    },
                    {
                        "username": "3boodr",
                        "content": "I\\'ve seen the greedy solution but i still don\\'t understand it. Guess i\\'m just dumb."
                    },
                    {
                        "username": "normanlmfung",
                        "content": "For example 1, Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2] Output: 3. But if you start at 2 also works. \\n\\n\\ttank = 3 (i==2 starting gas, no initial cost)\\n\\t\\n\\t+4-5\\n\\ttank = 2\\n\\t\\n\\t+5-1\\n\\ttank = 6\\n\\t\\n\\t+1-2\\n\\ttank = 5\\n\\t\\n\\t+2-3\\n\\ttank = 4\\n\\t\\n\\t+3-4\\n\\ttank = 3"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you\\'ve misunderstood the problem, if you start at i = 2 you just have 3 gas but you need 5 gas to move forward then this case is not valid.\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "this question is crap, so poorly explained. they made an effort to explain but its still not clear. "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "Can someone provide more testcases for me for this problem,please!...\\n"
                    },
                    {
                        "username": "user4270nA",
                        "content": "Hello,\\nOne the testcases to the question is:\\ngas = [4,5,2,6,5,3]\\ncost = [3,2,7,3,2,9]\\nI am able to find a solution starting at index 0 but it isn\\'t unique. The answer given is -1. But the question guarantees that the solution will be unique."
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        if(n==1)\\n        {\\n            if(gas[0]>=cost[0])\\n            return 0;\\n            else\\n            return -1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            gas[i]=gas[i]-cost[i];\\n        }\\n        long long sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=gas[i];\\n        }\\n        if(sum<0)\\n        return -1;\\n        int g=0,fi=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(gas[i]>0){\\n                long long sum1=0,count=0;\\n               for(int j=i;j<n+i;j++)\\n               {\\n                   count++;\\n                   sum1+=gas[j%n];\\n                   if(sum1<0)\\n                   break;\\n               }\\n               if(count==n)\\n               fi=i;\\n\\n             }\\n        }\\n        return fi;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amazing!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1926665,
                "content": [
                    {
                        "username": "worsecoder",
                        "content": "For the input gas=[2,0,0,0,0,0] and cost=[0,1,0,0,0,0], why should the answer by 0 rather than 2?"
                    },
                    {
                        "username": "user1502o",
                        "content": "How can I open my discussion in new Tab?"
                    },
                    {
                        "username": "psionl0",
                        "content": "WOW. How did my solution perform so poorly? It is just a simple O(N) traversal through the array - once.\\nhttps://leetcode.com/submissions/detail/970208247/"
                    },
                    {
                        "username": "omkar_4535",
                        "content": " gas : [4,5,3,1,4]\ncost : [5,4,3,4,2]\nexpected output is -1 \nhow is it possible \nhere from gas station index 4 we can complete whole circuit\nthen why they are asking for -1\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "start index 4: gas = 4 units\\nGoto index 0: gas = 4-2 = 2 units\\nGoto index 1: gas = 2+4-5 = 1 unit\\nGoto index 2: gas = 1+3-3 = 1 units\\nGoto index 3: gas = 1+1-4 = -2 units\\n\\nNope. You won\\'t make it."
                    },
                    {
                        "username": "3boodr",
                        "content": "I\\'ve seen the greedy solution but i still don\\'t understand it. Guess i\\'m just dumb."
                    },
                    {
                        "username": "normanlmfung",
                        "content": "For example 1, Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2] Output: 3. But if you start at 2 also works. \\n\\n\\ttank = 3 (i==2 starting gas, no initial cost)\\n\\t\\n\\t+4-5\\n\\ttank = 2\\n\\t\\n\\t+5-1\\n\\ttank = 6\\n\\t\\n\\t+1-2\\n\\ttank = 5\\n\\t\\n\\t+2-3\\n\\ttank = 4\\n\\t\\n\\t+3-4\\n\\ttank = 3"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you\\'ve misunderstood the problem, if you start at i = 2 you just have 3 gas but you need 5 gas to move forward then this case is not valid.\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "this question is crap, so poorly explained. they made an effort to explain but its still not clear. "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "Can someone provide more testcases for me for this problem,please!...\\n"
                    },
                    {
                        "username": "user4270nA",
                        "content": "Hello,\\nOne the testcases to the question is:\\ngas = [4,5,2,6,5,3]\\ncost = [3,2,7,3,2,9]\\nI am able to find a solution starting at index 0 but it isn\\'t unique. The answer given is -1. But the question guarantees that the solution will be unique."
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        if(n==1)\\n        {\\n            if(gas[0]>=cost[0])\\n            return 0;\\n            else\\n            return -1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            gas[i]=gas[i]-cost[i];\\n        }\\n        long long sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=gas[i];\\n        }\\n        if(sum<0)\\n        return -1;\\n        int g=0,fi=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(gas[i]>0){\\n                long long sum1=0,count=0;\\n               for(int j=i;j<n+i;j++)\\n               {\\n                   count++;\\n                   sum1+=gas[j%n];\\n                   if(sum1<0)\\n                   break;\\n               }\\n               if(count==n)\\n               fi=i;\\n\\n             }\\n        }\\n        return fi;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amazing!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1922897,
                "content": [
                    {
                        "username": "worsecoder",
                        "content": "For the input gas=[2,0,0,0,0,0] and cost=[0,1,0,0,0,0], why should the answer by 0 rather than 2?"
                    },
                    {
                        "username": "user1502o",
                        "content": "How can I open my discussion in new Tab?"
                    },
                    {
                        "username": "psionl0",
                        "content": "WOW. How did my solution perform so poorly? It is just a simple O(N) traversal through the array - once.\\nhttps://leetcode.com/submissions/detail/970208247/"
                    },
                    {
                        "username": "omkar_4535",
                        "content": " gas : [4,5,3,1,4]\ncost : [5,4,3,4,2]\nexpected output is -1 \nhow is it possible \nhere from gas station index 4 we can complete whole circuit\nthen why they are asking for -1\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "start index 4: gas = 4 units\\nGoto index 0: gas = 4-2 = 2 units\\nGoto index 1: gas = 2+4-5 = 1 unit\\nGoto index 2: gas = 1+3-3 = 1 units\\nGoto index 3: gas = 1+1-4 = -2 units\\n\\nNope. You won\\'t make it."
                    },
                    {
                        "username": "3boodr",
                        "content": "I\\'ve seen the greedy solution but i still don\\'t understand it. Guess i\\'m just dumb."
                    },
                    {
                        "username": "normanlmfung",
                        "content": "For example 1, Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2] Output: 3. But if you start at 2 also works. \\n\\n\\ttank = 3 (i==2 starting gas, no initial cost)\\n\\t\\n\\t+4-5\\n\\ttank = 2\\n\\t\\n\\t+5-1\\n\\ttank = 6\\n\\t\\n\\t+1-2\\n\\ttank = 5\\n\\t\\n\\t+2-3\\n\\ttank = 4\\n\\t\\n\\t+3-4\\n\\ttank = 3"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you\\'ve misunderstood the problem, if you start at i = 2 you just have 3 gas but you need 5 gas to move forward then this case is not valid.\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "this question is crap, so poorly explained. they made an effort to explain but its still not clear. "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "Can someone provide more testcases for me for this problem,please!...\\n"
                    },
                    {
                        "username": "user4270nA",
                        "content": "Hello,\\nOne the testcases to the question is:\\ngas = [4,5,2,6,5,3]\\ncost = [3,2,7,3,2,9]\\nI am able to find a solution starting at index 0 but it isn\\'t unique. The answer given is -1. But the question guarantees that the solution will be unique."
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        if(n==1)\\n        {\\n            if(gas[0]>=cost[0])\\n            return 0;\\n            else\\n            return -1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            gas[i]=gas[i]-cost[i];\\n        }\\n        long long sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=gas[i];\\n        }\\n        if(sum<0)\\n        return -1;\\n        int g=0,fi=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(gas[i]>0){\\n                long long sum1=0,count=0;\\n               for(int j=i;j<n+i;j++)\\n               {\\n                   count++;\\n                   sum1+=gas[j%n];\\n                   if(sum1<0)\\n                   break;\\n               }\\n               if(count==n)\\n               fi=i;\\n\\n             }\\n        }\\n        return fi;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amazing!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1903635,
                "content": [
                    {
                        "username": "worsecoder",
                        "content": "For the input gas=[2,0,0,0,0,0] and cost=[0,1,0,0,0,0], why should the answer by 0 rather than 2?"
                    },
                    {
                        "username": "user1502o",
                        "content": "How can I open my discussion in new Tab?"
                    },
                    {
                        "username": "psionl0",
                        "content": "WOW. How did my solution perform so poorly? It is just a simple O(N) traversal through the array - once.\\nhttps://leetcode.com/submissions/detail/970208247/"
                    },
                    {
                        "username": "omkar_4535",
                        "content": " gas : [4,5,3,1,4]\ncost : [5,4,3,4,2]\nexpected output is -1 \nhow is it possible \nhere from gas station index 4 we can complete whole circuit\nthen why they are asking for -1\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "start index 4: gas = 4 units\\nGoto index 0: gas = 4-2 = 2 units\\nGoto index 1: gas = 2+4-5 = 1 unit\\nGoto index 2: gas = 1+3-3 = 1 units\\nGoto index 3: gas = 1+1-4 = -2 units\\n\\nNope. You won\\'t make it."
                    },
                    {
                        "username": "3boodr",
                        "content": "I\\'ve seen the greedy solution but i still don\\'t understand it. Guess i\\'m just dumb."
                    },
                    {
                        "username": "normanlmfung",
                        "content": "For example 1, Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2] Output: 3. But if you start at 2 also works. \\n\\n\\ttank = 3 (i==2 starting gas, no initial cost)\\n\\t\\n\\t+4-5\\n\\ttank = 2\\n\\t\\n\\t+5-1\\n\\ttank = 6\\n\\t\\n\\t+1-2\\n\\ttank = 5\\n\\t\\n\\t+2-3\\n\\ttank = 4\\n\\t\\n\\t+3-4\\n\\ttank = 3"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you\\'ve misunderstood the problem, if you start at i = 2 you just have 3 gas but you need 5 gas to move forward then this case is not valid.\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "this question is crap, so poorly explained. they made an effort to explain but its still not clear. "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "Can someone provide more testcases for me for this problem,please!...\\n"
                    },
                    {
                        "username": "user4270nA",
                        "content": "Hello,\\nOne the testcases to the question is:\\ngas = [4,5,2,6,5,3]\\ncost = [3,2,7,3,2,9]\\nI am able to find a solution starting at index 0 but it isn\\'t unique. The answer given is -1. But the question guarantees that the solution will be unique."
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        if(n==1)\\n        {\\n            if(gas[0]>=cost[0])\\n            return 0;\\n            else\\n            return -1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            gas[i]=gas[i]-cost[i];\\n        }\\n        long long sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=gas[i];\\n        }\\n        if(sum<0)\\n        return -1;\\n        int g=0,fi=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(gas[i]>0){\\n                long long sum1=0,count=0;\\n               for(int j=i;j<n+i;j++)\\n               {\\n                   count++;\\n                   sum1+=gas[j%n];\\n                   if(sum1<0)\\n                   break;\\n               }\\n               if(count==n)\\n               fi=i;\\n\\n             }\\n        }\\n        return fi;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amazing!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1900276,
                "content": [
                    {
                        "username": "worsecoder",
                        "content": "For the input gas=[2,0,0,0,0,0] and cost=[0,1,0,0,0,0], why should the answer by 0 rather than 2?"
                    },
                    {
                        "username": "user1502o",
                        "content": "How can I open my discussion in new Tab?"
                    },
                    {
                        "username": "psionl0",
                        "content": "WOW. How did my solution perform so poorly? It is just a simple O(N) traversal through the array - once.\\nhttps://leetcode.com/submissions/detail/970208247/"
                    },
                    {
                        "username": "omkar_4535",
                        "content": " gas : [4,5,3,1,4]\ncost : [5,4,3,4,2]\nexpected output is -1 \nhow is it possible \nhere from gas station index 4 we can complete whole circuit\nthen why they are asking for -1\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "start index 4: gas = 4 units\\nGoto index 0: gas = 4-2 = 2 units\\nGoto index 1: gas = 2+4-5 = 1 unit\\nGoto index 2: gas = 1+3-3 = 1 units\\nGoto index 3: gas = 1+1-4 = -2 units\\n\\nNope. You won\\'t make it."
                    },
                    {
                        "username": "3boodr",
                        "content": "I\\'ve seen the greedy solution but i still don\\'t understand it. Guess i\\'m just dumb."
                    },
                    {
                        "username": "normanlmfung",
                        "content": "For example 1, Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2] Output: 3. But if you start at 2 also works. \\n\\n\\ttank = 3 (i==2 starting gas, no initial cost)\\n\\t\\n\\t+4-5\\n\\ttank = 2\\n\\t\\n\\t+5-1\\n\\ttank = 6\\n\\t\\n\\t+1-2\\n\\ttank = 5\\n\\t\\n\\t+2-3\\n\\ttank = 4\\n\\t\\n\\t+3-4\\n\\ttank = 3"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you\\'ve misunderstood the problem, if you start at i = 2 you just have 3 gas but you need 5 gas to move forward then this case is not valid.\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "this question is crap, so poorly explained. they made an effort to explain but its still not clear. "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "Can someone provide more testcases for me for this problem,please!...\\n"
                    },
                    {
                        "username": "user4270nA",
                        "content": "Hello,\\nOne the testcases to the question is:\\ngas = [4,5,2,6,5,3]\\ncost = [3,2,7,3,2,9]\\nI am able to find a solution starting at index 0 but it isn\\'t unique. The answer given is -1. But the question guarantees that the solution will be unique."
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        if(n==1)\\n        {\\n            if(gas[0]>=cost[0])\\n            return 0;\\n            else\\n            return -1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            gas[i]=gas[i]-cost[i];\\n        }\\n        long long sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=gas[i];\\n        }\\n        if(sum<0)\\n        return -1;\\n        int g=0,fi=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(gas[i]>0){\\n                long long sum1=0,count=0;\\n               for(int j=i;j<n+i;j++)\\n               {\\n                   count++;\\n                   sum1+=gas[j%n];\\n                   if(sum1<0)\\n                   break;\\n               }\\n               if(count==n)\\n               fi=i;\\n\\n             }\\n        }\\n        return fi;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amazing!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1849898,
                "content": [
                    {
                        "username": "worsecoder",
                        "content": "For the input gas=[2,0,0,0,0,0] and cost=[0,1,0,0,0,0], why should the answer by 0 rather than 2?"
                    },
                    {
                        "username": "user1502o",
                        "content": "How can I open my discussion in new Tab?"
                    },
                    {
                        "username": "psionl0",
                        "content": "WOW. How did my solution perform so poorly? It is just a simple O(N) traversal through the array - once.\\nhttps://leetcode.com/submissions/detail/970208247/"
                    },
                    {
                        "username": "omkar_4535",
                        "content": " gas : [4,5,3,1,4]\ncost : [5,4,3,4,2]\nexpected output is -1 \nhow is it possible \nhere from gas station index 4 we can complete whole circuit\nthen why they are asking for -1\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "start index 4: gas = 4 units\\nGoto index 0: gas = 4-2 = 2 units\\nGoto index 1: gas = 2+4-5 = 1 unit\\nGoto index 2: gas = 1+3-3 = 1 units\\nGoto index 3: gas = 1+1-4 = -2 units\\n\\nNope. You won\\'t make it."
                    },
                    {
                        "username": "3boodr",
                        "content": "I\\'ve seen the greedy solution but i still don\\'t understand it. Guess i\\'m just dumb."
                    },
                    {
                        "username": "normanlmfung",
                        "content": "For example 1, Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2] Output: 3. But if you start at 2 also works. \\n\\n\\ttank = 3 (i==2 starting gas, no initial cost)\\n\\t\\n\\t+4-5\\n\\ttank = 2\\n\\t\\n\\t+5-1\\n\\ttank = 6\\n\\t\\n\\t+1-2\\n\\ttank = 5\\n\\t\\n\\t+2-3\\n\\ttank = 4\\n\\t\\n\\t+3-4\\n\\ttank = 3"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you\\'ve misunderstood the problem, if you start at i = 2 you just have 3 gas but you need 5 gas to move forward then this case is not valid.\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "this question is crap, so poorly explained. they made an effort to explain but its still not clear. "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "Can someone provide more testcases for me for this problem,please!...\\n"
                    },
                    {
                        "username": "user4270nA",
                        "content": "Hello,\\nOne the testcases to the question is:\\ngas = [4,5,2,6,5,3]\\ncost = [3,2,7,3,2,9]\\nI am able to find a solution starting at index 0 but it isn\\'t unique. The answer given is -1. But the question guarantees that the solution will be unique."
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        if(n==1)\\n        {\\n            if(gas[0]>=cost[0])\\n            return 0;\\n            else\\n            return -1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            gas[i]=gas[i]-cost[i];\\n        }\\n        long long sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=gas[i];\\n        }\\n        if(sum<0)\\n        return -1;\\n        int g=0,fi=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(gas[i]>0){\\n                long long sum1=0,count=0;\\n               for(int j=i;j<n+i;j++)\\n               {\\n                   count++;\\n                   sum1+=gas[j%n];\\n                   if(sum1<0)\\n                   break;\\n               }\\n               if(count==n)\\n               fi=i;\\n\\n             }\\n        }\\n        return fi;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amazing!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1827113,
                "content": [
                    {
                        "username": "worsecoder",
                        "content": "For the input gas=[2,0,0,0,0,0] and cost=[0,1,0,0,0,0], why should the answer by 0 rather than 2?"
                    },
                    {
                        "username": "user1502o",
                        "content": "How can I open my discussion in new Tab?"
                    },
                    {
                        "username": "psionl0",
                        "content": "WOW. How did my solution perform so poorly? It is just a simple O(N) traversal through the array - once.\\nhttps://leetcode.com/submissions/detail/970208247/"
                    },
                    {
                        "username": "omkar_4535",
                        "content": " gas : [4,5,3,1,4]\ncost : [5,4,3,4,2]\nexpected output is -1 \nhow is it possible \nhere from gas station index 4 we can complete whole circuit\nthen why they are asking for -1\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "start index 4: gas = 4 units\\nGoto index 0: gas = 4-2 = 2 units\\nGoto index 1: gas = 2+4-5 = 1 unit\\nGoto index 2: gas = 1+3-3 = 1 units\\nGoto index 3: gas = 1+1-4 = -2 units\\n\\nNope. You won\\'t make it."
                    },
                    {
                        "username": "3boodr",
                        "content": "I\\'ve seen the greedy solution but i still don\\'t understand it. Guess i\\'m just dumb."
                    },
                    {
                        "username": "normanlmfung",
                        "content": "For example 1, Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2] Output: 3. But if you start at 2 also works. \\n\\n\\ttank = 3 (i==2 starting gas, no initial cost)\\n\\t\\n\\t+4-5\\n\\ttank = 2\\n\\t\\n\\t+5-1\\n\\ttank = 6\\n\\t\\n\\t+1-2\\n\\ttank = 5\\n\\t\\n\\t+2-3\\n\\ttank = 4\\n\\t\\n\\t+3-4\\n\\ttank = 3"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you\\'ve misunderstood the problem, if you start at i = 2 you just have 3 gas but you need 5 gas to move forward then this case is not valid.\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "this question is crap, so poorly explained. they made an effort to explain but its still not clear. "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "Can someone provide more testcases for me for this problem,please!...\\n"
                    },
                    {
                        "username": "user4270nA",
                        "content": "Hello,\\nOne the testcases to the question is:\\ngas = [4,5,2,6,5,3]\\ncost = [3,2,7,3,2,9]\\nI am able to find a solution starting at index 0 but it isn\\'t unique. The answer given is -1. But the question guarantees that the solution will be unique."
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        if(n==1)\\n        {\\n            if(gas[0]>=cost[0])\\n            return 0;\\n            else\\n            return -1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            gas[i]=gas[i]-cost[i];\\n        }\\n        long long sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=gas[i];\\n        }\\n        if(sum<0)\\n        return -1;\\n        int g=0,fi=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(gas[i]>0){\\n                long long sum1=0,count=0;\\n               for(int j=i;j<n+i;j++)\\n               {\\n                   count++;\\n                   sum1+=gas[j%n];\\n                   if(sum1<0)\\n                   break;\\n               }\\n               if(count==n)\\n               fi=i;\\n\\n             }\\n        }\\n        return fi;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amazing!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1799694,
                "content": [
                    {
                        "username": "worsecoder",
                        "content": "For the input gas=[2,0,0,0,0,0] and cost=[0,1,0,0,0,0], why should the answer by 0 rather than 2?"
                    },
                    {
                        "username": "user1502o",
                        "content": "How can I open my discussion in new Tab?"
                    },
                    {
                        "username": "psionl0",
                        "content": "WOW. How did my solution perform so poorly? It is just a simple O(N) traversal through the array - once.\\nhttps://leetcode.com/submissions/detail/970208247/"
                    },
                    {
                        "username": "omkar_4535",
                        "content": " gas : [4,5,3,1,4]\ncost : [5,4,3,4,2]\nexpected output is -1 \nhow is it possible \nhere from gas station index 4 we can complete whole circuit\nthen why they are asking for -1\n "
                    },
                    {
                        "username": "psionl0",
                        "content": "start index 4: gas = 4 units\\nGoto index 0: gas = 4-2 = 2 units\\nGoto index 1: gas = 2+4-5 = 1 unit\\nGoto index 2: gas = 1+3-3 = 1 units\\nGoto index 3: gas = 1+1-4 = -2 units\\n\\nNope. You won\\'t make it."
                    },
                    {
                        "username": "3boodr",
                        "content": "I\\'ve seen the greedy solution but i still don\\'t understand it. Guess i\\'m just dumb."
                    },
                    {
                        "username": "normanlmfung",
                        "content": "For example 1, Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2] Output: 3. But if you start at 2 also works. \\n\\n\\ttank = 3 (i==2 starting gas, no initial cost)\\n\\t\\n\\t+4-5\\n\\ttank = 2\\n\\t\\n\\t+5-1\\n\\ttank = 6\\n\\t\\n\\t+1-2\\n\\ttank = 5\\n\\t\\n\\t+2-3\\n\\ttank = 4\\n\\t\\n\\t+3-4\\n\\ttank = 3"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you\\'ve misunderstood the problem, if you start at i = 2 you just have 3 gas but you need 5 gas to move forward then this case is not valid.\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "this question is crap, so poorly explained. they made an effort to explain but its still not clear. "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "Can someone provide more testcases for me for this problem,please!...\\n"
                    },
                    {
                        "username": "user4270nA",
                        "content": "Hello,\\nOne the testcases to the question is:\\ngas = [4,5,2,6,5,3]\\ncost = [3,2,7,3,2,9]\\nI am able to find a solution starting at index 0 but it isn\\'t unique. The answer given is -1. But the question guarantees that the solution will be unique."
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        if(n==1)\\n        {\\n            if(gas[0]>=cost[0])\\n            return 0;\\n            else\\n            return -1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            gas[i]=gas[i]-cost[i];\\n        }\\n        long long sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=gas[i];\\n        }\\n        if(sum<0)\\n        return -1;\\n        int g=0,fi=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(gas[i]>0){\\n                long long sum1=0,count=0;\\n               for(int j=i;j<n+i;j++)\\n               {\\n                   count++;\\n                   sum1+=gas[j%n];\\n                   if(sum1<0)\\n                   break;\\n               }\\n               if(count==n)\\n               fi=i;\\n\\n             }\\n        }\\n        return fi;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amazing!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1799693,
                "content": [
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "can someone expain this. All test cases passed then also showing TLE"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "How the solution is Greedy ???? mtlb kuchh bhi ?"
                    },
                    {
                        "username": "princethet",
                        "content": "It is going clock-wise or anticlock-wise little confusing ???  "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Kartik0071",
                        "content": "def canCompleteCircuit(gas, cost):\\n    n = len(gas)\\n    for i in range(n):\\n        tank = 0\\n        for j in range(n):\\n            k = (i + j) % n\\n            tank += gas[k] - cost[k]\\n            if tank < 0:\\n                break\\n        if tank >= 0:\\n            return i\\n    return -1\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mahendar_1234",
                        "content": "I think this question is related to whether the rotation of the array is equal or not please if anyone agrees, give an upvote and try to solve this like array rotation."
                    },
                    {
                        "username": "devanshusharma0223",
                        "content": "Last test case not working...It shows time limit exceeded.\\n\\nLast executed input \\ngas = \\n\\ncan someone please tell me the problem"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "How come, in Typescript array.reduce produced a worse result than for loop? \\n"
                    },
                    {
                        "username": "LogiqueClergyman",
                        "content": "Could someone please help me out here:\n\n public int canCompleteCircuit(int[] gas, int[] cost) {\n        int i = 0, index = 0, gasleft = 0;\n        while ( true ) {\n            while ( i < gas.length ) {\n                if ( gas[i] < cost[i] )\n                i++;\n                else\n                break;\n            }\n            index = i;\n            while ( gasleft + gas [index] >= cost [index] ) {         //at this line\n                gasleft = gasleft + gas [index] - cost [index];\n                index++;\n                if ( index == gas.length ) index = 0;\n                if ( index == i ) return index;\n            }\n        i++;\n        }.\nCould someone please tell me why is it giving me this error at line 11? If I run this same code in IntelliJ it works fine."
                    },
                    {
                        "username": "seeker_777",
                        "content": "#1 Look for test case 34 because what gonna give time limit exceeded problem!!!"
                    }
                ]
            },
            {
                "id": 1794031,
                "content": [
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "can someone expain this. All test cases passed then also showing TLE"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "How the solution is Greedy ???? mtlb kuchh bhi ?"
                    },
                    {
                        "username": "princethet",
                        "content": "It is going clock-wise or anticlock-wise little confusing ???  "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Kartik0071",
                        "content": "def canCompleteCircuit(gas, cost):\\n    n = len(gas)\\n    for i in range(n):\\n        tank = 0\\n        for j in range(n):\\n            k = (i + j) % n\\n            tank += gas[k] - cost[k]\\n            if tank < 0:\\n                break\\n        if tank >= 0:\\n            return i\\n    return -1\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mahendar_1234",
                        "content": "I think this question is related to whether the rotation of the array is equal or not please if anyone agrees, give an upvote and try to solve this like array rotation."
                    },
                    {
                        "username": "devanshusharma0223",
                        "content": "Last test case not working...It shows time limit exceeded.\\n\\nLast executed input \\ngas = \\n\\ncan someone please tell me the problem"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "How come, in Typescript array.reduce produced a worse result than for loop? \\n"
                    },
                    {
                        "username": "LogiqueClergyman",
                        "content": "Could someone please help me out here:\n\n public int canCompleteCircuit(int[] gas, int[] cost) {\n        int i = 0, index = 0, gasleft = 0;\n        while ( true ) {\n            while ( i < gas.length ) {\n                if ( gas[i] < cost[i] )\n                i++;\n                else\n                break;\n            }\n            index = i;\n            while ( gasleft + gas [index] >= cost [index] ) {         //at this line\n                gasleft = gasleft + gas [index] - cost [index];\n                index++;\n                if ( index == gas.length ) index = 0;\n                if ( index == i ) return index;\n            }\n        i++;\n        }.\nCould someone please tell me why is it giving me this error at line 11? If I run this same code in IntelliJ it works fine."
                    },
                    {
                        "username": "seeker_777",
                        "content": "#1 Look for test case 34 because what gonna give time limit exceeded problem!!!"
                    }
                ]
            },
            {
                "id": 1769695,
                "content": [
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "can someone expain this. All test cases passed then also showing TLE"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "How the solution is Greedy ???? mtlb kuchh bhi ?"
                    },
                    {
                        "username": "princethet",
                        "content": "It is going clock-wise or anticlock-wise little confusing ???  "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Kartik0071",
                        "content": "def canCompleteCircuit(gas, cost):\\n    n = len(gas)\\n    for i in range(n):\\n        tank = 0\\n        for j in range(n):\\n            k = (i + j) % n\\n            tank += gas[k] - cost[k]\\n            if tank < 0:\\n                break\\n        if tank >= 0:\\n            return i\\n    return -1\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mahendar_1234",
                        "content": "I think this question is related to whether the rotation of the array is equal or not please if anyone agrees, give an upvote and try to solve this like array rotation."
                    },
                    {
                        "username": "devanshusharma0223",
                        "content": "Last test case not working...It shows time limit exceeded.\\n\\nLast executed input \\ngas = \\n\\ncan someone please tell me the problem"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "How come, in Typescript array.reduce produced a worse result than for loop? \\n"
                    },
                    {
                        "username": "LogiqueClergyman",
                        "content": "Could someone please help me out here:\n\n public int canCompleteCircuit(int[] gas, int[] cost) {\n        int i = 0, index = 0, gasleft = 0;\n        while ( true ) {\n            while ( i < gas.length ) {\n                if ( gas[i] < cost[i] )\n                i++;\n                else\n                break;\n            }\n            index = i;\n            while ( gasleft + gas [index] >= cost [index] ) {         //at this line\n                gasleft = gasleft + gas [index] - cost [index];\n                index++;\n                if ( index == gas.length ) index = 0;\n                if ( index == i ) return index;\n            }\n        i++;\n        }.\nCould someone please tell me why is it giving me this error at line 11? If I run this same code in IntelliJ it works fine."
                    },
                    {
                        "username": "seeker_777",
                        "content": "#1 Look for test case 34 because what gonna give time limit exceeded problem!!!"
                    }
                ]
            },
            {
                "id": 1756352,
                "content": [
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "can someone expain this. All test cases passed then also showing TLE"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "How the solution is Greedy ???? mtlb kuchh bhi ?"
                    },
                    {
                        "username": "princethet",
                        "content": "It is going clock-wise or anticlock-wise little confusing ???  "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Kartik0071",
                        "content": "def canCompleteCircuit(gas, cost):\\n    n = len(gas)\\n    for i in range(n):\\n        tank = 0\\n        for j in range(n):\\n            k = (i + j) % n\\n            tank += gas[k] - cost[k]\\n            if tank < 0:\\n                break\\n        if tank >= 0:\\n            return i\\n    return -1\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mahendar_1234",
                        "content": "I think this question is related to whether the rotation of the array is equal or not please if anyone agrees, give an upvote and try to solve this like array rotation."
                    },
                    {
                        "username": "devanshusharma0223",
                        "content": "Last test case not working...It shows time limit exceeded.\\n\\nLast executed input \\ngas = \\n\\ncan someone please tell me the problem"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "How come, in Typescript array.reduce produced a worse result than for loop? \\n"
                    },
                    {
                        "username": "LogiqueClergyman",
                        "content": "Could someone please help me out here:\n\n public int canCompleteCircuit(int[] gas, int[] cost) {\n        int i = 0, index = 0, gasleft = 0;\n        while ( true ) {\n            while ( i < gas.length ) {\n                if ( gas[i] < cost[i] )\n                i++;\n                else\n                break;\n            }\n            index = i;\n            while ( gasleft + gas [index] >= cost [index] ) {         //at this line\n                gasleft = gasleft + gas [index] - cost [index];\n                index++;\n                if ( index == gas.length ) index = 0;\n                if ( index == i ) return index;\n            }\n        i++;\n        }.\nCould someone please tell me why is it giving me this error at line 11? If I run this same code in IntelliJ it works fine."
                    },
                    {
                        "username": "seeker_777",
                        "content": "#1 Look for test case 34 because what gonna give time limit exceeded problem!!!"
                    }
                ]
            },
            {
                "id": 1746825,
                "content": [
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "can someone expain this. All test cases passed then also showing TLE"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "How the solution is Greedy ???? mtlb kuchh bhi ?"
                    },
                    {
                        "username": "princethet",
                        "content": "It is going clock-wise or anticlock-wise little confusing ???  "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Kartik0071",
                        "content": "def canCompleteCircuit(gas, cost):\\n    n = len(gas)\\n    for i in range(n):\\n        tank = 0\\n        for j in range(n):\\n            k = (i + j) % n\\n            tank += gas[k] - cost[k]\\n            if tank < 0:\\n                break\\n        if tank >= 0:\\n            return i\\n    return -1\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mahendar_1234",
                        "content": "I think this question is related to whether the rotation of the array is equal or not please if anyone agrees, give an upvote and try to solve this like array rotation."
                    },
                    {
                        "username": "devanshusharma0223",
                        "content": "Last test case not working...It shows time limit exceeded.\\n\\nLast executed input \\ngas = \\n\\ncan someone please tell me the problem"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "How come, in Typescript array.reduce produced a worse result than for loop? \\n"
                    },
                    {
                        "username": "LogiqueClergyman",
                        "content": "Could someone please help me out here:\n\n public int canCompleteCircuit(int[] gas, int[] cost) {\n        int i = 0, index = 0, gasleft = 0;\n        while ( true ) {\n            while ( i < gas.length ) {\n                if ( gas[i] < cost[i] )\n                i++;\n                else\n                break;\n            }\n            index = i;\n            while ( gasleft + gas [index] >= cost [index] ) {         //at this line\n                gasleft = gasleft + gas [index] - cost [index];\n                index++;\n                if ( index == gas.length ) index = 0;\n                if ( index == i ) return index;\n            }\n        i++;\n        }.\nCould someone please tell me why is it giving me this error at line 11? If I run this same code in IntelliJ it works fine."
                    },
                    {
                        "username": "seeker_777",
                        "content": "#1 Look for test case 34 because what gonna give time limit exceeded problem!!!"
                    }
                ]
            },
            {
                "id": 1746673,
                "content": [
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "can someone expain this. All test cases passed then also showing TLE"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "How the solution is Greedy ???? mtlb kuchh bhi ?"
                    },
                    {
                        "username": "princethet",
                        "content": "It is going clock-wise or anticlock-wise little confusing ???  "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Kartik0071",
                        "content": "def canCompleteCircuit(gas, cost):\\n    n = len(gas)\\n    for i in range(n):\\n        tank = 0\\n        for j in range(n):\\n            k = (i + j) % n\\n            tank += gas[k] - cost[k]\\n            if tank < 0:\\n                break\\n        if tank >= 0:\\n            return i\\n    return -1\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mahendar_1234",
                        "content": "I think this question is related to whether the rotation of the array is equal or not please if anyone agrees, give an upvote and try to solve this like array rotation."
                    },
                    {
                        "username": "devanshusharma0223",
                        "content": "Last test case not working...It shows time limit exceeded.\\n\\nLast executed input \\ngas = \\n\\ncan someone please tell me the problem"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "How come, in Typescript array.reduce produced a worse result than for loop? \\n"
                    },
                    {
                        "username": "LogiqueClergyman",
                        "content": "Could someone please help me out here:\n\n public int canCompleteCircuit(int[] gas, int[] cost) {\n        int i = 0, index = 0, gasleft = 0;\n        while ( true ) {\n            while ( i < gas.length ) {\n                if ( gas[i] < cost[i] )\n                i++;\n                else\n                break;\n            }\n            index = i;\n            while ( gasleft + gas [index] >= cost [index] ) {         //at this line\n                gasleft = gasleft + gas [index] - cost [index];\n                index++;\n                if ( index == gas.length ) index = 0;\n                if ( index == i ) return index;\n            }\n        i++;\n        }.\nCould someone please tell me why is it giving me this error at line 11? If I run this same code in IntelliJ it works fine."
                    },
                    {
                        "username": "seeker_777",
                        "content": "#1 Look for test case 34 because what gonna give time limit exceeded problem!!!"
                    }
                ]
            },
            {
                "id": 1746671,
                "content": [
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "can someone expain this. All test cases passed then also showing TLE"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "How the solution is Greedy ???? mtlb kuchh bhi ?"
                    },
                    {
                        "username": "princethet",
                        "content": "It is going clock-wise or anticlock-wise little confusing ???  "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Kartik0071",
                        "content": "def canCompleteCircuit(gas, cost):\\n    n = len(gas)\\n    for i in range(n):\\n        tank = 0\\n        for j in range(n):\\n            k = (i + j) % n\\n            tank += gas[k] - cost[k]\\n            if tank < 0:\\n                break\\n        if tank >= 0:\\n            return i\\n    return -1\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mahendar_1234",
                        "content": "I think this question is related to whether the rotation of the array is equal or not please if anyone agrees, give an upvote and try to solve this like array rotation."
                    },
                    {
                        "username": "devanshusharma0223",
                        "content": "Last test case not working...It shows time limit exceeded.\\n\\nLast executed input \\ngas = \\n\\ncan someone please tell me the problem"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "How come, in Typescript array.reduce produced a worse result than for loop? \\n"
                    },
                    {
                        "username": "LogiqueClergyman",
                        "content": "Could someone please help me out here:\n\n public int canCompleteCircuit(int[] gas, int[] cost) {\n        int i = 0, index = 0, gasleft = 0;\n        while ( true ) {\n            while ( i < gas.length ) {\n                if ( gas[i] < cost[i] )\n                i++;\n                else\n                break;\n            }\n            index = i;\n            while ( gasleft + gas [index] >= cost [index] ) {         //at this line\n                gasleft = gasleft + gas [index] - cost [index];\n                index++;\n                if ( index == gas.length ) index = 0;\n                if ( index == i ) return index;\n            }\n        i++;\n        }.\nCould someone please tell me why is it giving me this error at line 11? If I run this same code in IntelliJ it works fine."
                    },
                    {
                        "username": "seeker_777",
                        "content": "#1 Look for test case 34 because what gonna give time limit exceeded problem!!!"
                    }
                ]
            },
            {
                "id": 1746608,
                "content": [
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "can someone expain this. All test cases passed then also showing TLE"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "How the solution is Greedy ???? mtlb kuchh bhi ?"
                    },
                    {
                        "username": "princethet",
                        "content": "It is going clock-wise or anticlock-wise little confusing ???  "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Kartik0071",
                        "content": "def canCompleteCircuit(gas, cost):\\n    n = len(gas)\\n    for i in range(n):\\n        tank = 0\\n        for j in range(n):\\n            k = (i + j) % n\\n            tank += gas[k] - cost[k]\\n            if tank < 0:\\n                break\\n        if tank >= 0:\\n            return i\\n    return -1\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mahendar_1234",
                        "content": "I think this question is related to whether the rotation of the array is equal or not please if anyone agrees, give an upvote and try to solve this like array rotation."
                    },
                    {
                        "username": "devanshusharma0223",
                        "content": "Last test case not working...It shows time limit exceeded.\\n\\nLast executed input \\ngas = \\n\\ncan someone please tell me the problem"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "How come, in Typescript array.reduce produced a worse result than for loop? \\n"
                    },
                    {
                        "username": "LogiqueClergyman",
                        "content": "Could someone please help me out here:\n\n public int canCompleteCircuit(int[] gas, int[] cost) {\n        int i = 0, index = 0, gasleft = 0;\n        while ( true ) {\n            while ( i < gas.length ) {\n                if ( gas[i] < cost[i] )\n                i++;\n                else\n                break;\n            }\n            index = i;\n            while ( gasleft + gas [index] >= cost [index] ) {         //at this line\n                gasleft = gasleft + gas [index] - cost [index];\n                index++;\n                if ( index == gas.length ) index = 0;\n                if ( index == i ) return index;\n            }\n        i++;\n        }.\nCould someone please tell me why is it giving me this error at line 11? If I run this same code in IntelliJ it works fine."
                    },
                    {
                        "username": "seeker_777",
                        "content": "#1 Look for test case 34 because what gonna give time limit exceeded problem!!!"
                    }
                ]
            },
            {
                "id": 1746604,
                "content": [
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "can someone expain this. All test cases passed then also showing TLE"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "How the solution is Greedy ???? mtlb kuchh bhi ?"
                    },
                    {
                        "username": "princethet",
                        "content": "It is going clock-wise or anticlock-wise little confusing ???  "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Kartik0071",
                        "content": "def canCompleteCircuit(gas, cost):\\n    n = len(gas)\\n    for i in range(n):\\n        tank = 0\\n        for j in range(n):\\n            k = (i + j) % n\\n            tank += gas[k] - cost[k]\\n            if tank < 0:\\n                break\\n        if tank >= 0:\\n            return i\\n    return -1\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mahendar_1234",
                        "content": "I think this question is related to whether the rotation of the array is equal or not please if anyone agrees, give an upvote and try to solve this like array rotation."
                    },
                    {
                        "username": "devanshusharma0223",
                        "content": "Last test case not working...It shows time limit exceeded.\\n\\nLast executed input \\ngas = \\n\\ncan someone please tell me the problem"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "How come, in Typescript array.reduce produced a worse result than for loop? \\n"
                    },
                    {
                        "username": "LogiqueClergyman",
                        "content": "Could someone please help me out here:\n\n public int canCompleteCircuit(int[] gas, int[] cost) {\n        int i = 0, index = 0, gasleft = 0;\n        while ( true ) {\n            while ( i < gas.length ) {\n                if ( gas[i] < cost[i] )\n                i++;\n                else\n                break;\n            }\n            index = i;\n            while ( gasleft + gas [index] >= cost [index] ) {         //at this line\n                gasleft = gasleft + gas [index] - cost [index];\n                index++;\n                if ( index == gas.length ) index = 0;\n                if ( index == i ) return index;\n            }\n        i++;\n        }.\nCould someone please tell me why is it giving me this error at line 11? If I run this same code in IntelliJ it works fine."
                    },
                    {
                        "username": "seeker_777",
                        "content": "#1 Look for test case 34 because what gonna give time limit exceeded problem!!!"
                    }
                ]
            },
            {
                "id": 1746559,
                "content": [
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "can someone expain this. All test cases passed then also showing TLE"
                    },
                    {
                        "username": "shivam2612002",
                        "content": "How the solution is Greedy ???? mtlb kuchh bhi ?"
                    },
                    {
                        "username": "princethet",
                        "content": "It is going clock-wise or anticlock-wise little confusing ???  "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Kartik0071",
                        "content": "def canCompleteCircuit(gas, cost):\\n    n = len(gas)\\n    for i in range(n):\\n        tank = 0\\n        for j in range(n):\\n            k = (i + j) % n\\n            tank += gas[k] - cost[k]\\n            if tank < 0:\\n                break\\n        if tank >= 0:\\n            return i\\n    return -1\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mahendar_1234",
                        "content": "I think this question is related to whether the rotation of the array is equal or not please if anyone agrees, give an upvote and try to solve this like array rotation."
                    },
                    {
                        "username": "devanshusharma0223",
                        "content": "Last test case not working...It shows time limit exceeded.\\n\\nLast executed input \\ngas = \\n\\ncan someone please tell me the problem"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "How come, in Typescript array.reduce produced a worse result than for loop? \\n"
                    },
                    {
                        "username": "LogiqueClergyman",
                        "content": "Could someone please help me out here:\n\n public int canCompleteCircuit(int[] gas, int[] cost) {\n        int i = 0, index = 0, gasleft = 0;\n        while ( true ) {\n            while ( i < gas.length ) {\n                if ( gas[i] < cost[i] )\n                i++;\n                else\n                break;\n            }\n            index = i;\n            while ( gasleft + gas [index] >= cost [index] ) {         //at this line\n                gasleft = gasleft + gas [index] - cost [index];\n                index++;\n                if ( index == gas.length ) index = 0;\n                if ( index == i ) return index;\n            }\n        i++;\n        }.\nCould someone please tell me why is it giving me this error at line 11? If I run this same code in IntelliJ it works fine."
                    },
                    {
                        "username": "seeker_777",
                        "content": "#1 Look for test case 34 because what gonna give time limit exceeded problem!!!"
                    }
                ]
            },
            {
                "id": 1746502,
                "content": [
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "VERY VERY SIMPLE and INTUTIVE SOLN\\n\\n int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n\\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "White73",
                        "content": "is there any way to calculate answer when there are more than 1 solution (i.e. not unique) "
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "is it possible to prove that if total gas is greater than total cost we will be able to \\ncomplete the trip?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Hmm, interesting "
                    },
                    {
                        "username": "ibeastking",
                        "content": "Can someone plz tell me that why we are not checking earlier indices while iterating the loop?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "[@ibeastking](/ibeastking)  We donot assume that earlier indices have satisfied the condition. We just start iterating from first index. And keep on adding gas we get and keep on subtracting gas it needs to reach next index. While doing this, if the gas we have is not sufficient to the gas it costs to reach next index. It means we need to try starting car from another index. And reset gas collected, and start from the next index to the index we reached before. \\nI hope you get what I mean."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@prashantghi8](/prashantghi8) Do we assume that earlier indices have satisfied the constraints or is that some logical thing??"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "We can solve this task by iterating from the first index, So how are we not checking earlier indices?? But we dont have to go back to earlier indices again after reaching final index of the gas stations"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "Hey all, if you guys are consoling/printing op while debugging, make sure you remove them before submitting answer, because if the print is running in loops it might throw Output limit exceeded error and might reject your solution even though it is correct. I just witnessed this, so writing here :)\\nHope this might be helpful"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I\\'d say first write the brute force approach, which won\\'t pass because of TLE. Then consider the fact that if you start at `i` and ends at `k` (ie. gas remained at k is < 0), then any point between `i` and `k` is NOT a valid point. \\nSo no need to write `for start in range(0, n)`, you can write a while loop `start = 0, while start < n: {.... do something ...}, start = k`.\\n\\nThere\\'s only 1 or 2 lines of code change between the valid approach and the brute-force approach."
                    },
                    {
                        "username": "kaustubh_dalvi_",
                        "content": "Hello everyone !!!\\nAccording to description and some of the test case we may conclude that we can return the index of minimum of cost. if we have N no. of minimum (i.e same cost at multiple gas station) then we can return the index of last minimum of the cost. Surprisingly it passed 28 testcases but failed on 29th which conclude that, finding the minimum is not sufficient...\\nCan anyone find other logic than this ??? (which accepts all the testcases...)"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Done and dusted\\uD83D\\uDE0E\\uD83E\\uDD1E...\\nAfter more than 2 hours \\uD83E\\uDD72"
                    },
                    {
                        "username": "er_sushant",
                        "content": "Isn\\'t this a greedy week?\\nSurprisingly, everyproblem solves using greedy!"
                    },
                    {
                        "username": "saurabha9540",
                        "content": "gas=[5,1,2,3,4]\\ncost=[4,4,1,5,1]\\n\\nI start at index 2 tank=2;\\nTo index 3=>2+3-1 so tank=4 units of gas\\nTo index 4=>4+4-5 so tank=3 units of gas\\nTo index 0=>3+5-1 so tank=7 units of gas\\nTo index 1=>7+1-4 so tank=4 units of gas \\n now to move back to index 2 I need 4 units of gas and I have 4 . So why is answer 4 instead of 2 ??\\n"
                    },
                    {
                        "username": "thisannie",
                        "content": "at Index 2: your tank will have tank = 2 units. now you want to move to index 3 but in order to reach to station 3 (index 3) you need 1 unit of fuel (cost[2]=1). as you have enough gas to reach to station 3, you can go to station 3.\\nat Index 3: your tank = 2-1+3 = 4 units. in order to travel to next station, you need 5 units of fuel (as cost[3]=5) but your tanks has only 4 units hence you can not travel further.\\n\\nmathematically,\\nyou need to subtract cost[i] first and then add gas[i+1].\\nso in your second step,\\n4-5=1 will be calculated first and (NOT 4+4-5 =3 )as it is negative you cant move further. "
                    }
                ]
            },
            {
                "id": 1746455,
                "content": [
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "VERY VERY SIMPLE and INTUTIVE SOLN\\n\\n int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n\\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "White73",
                        "content": "is there any way to calculate answer when there are more than 1 solution (i.e. not unique) "
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "is it possible to prove that if total gas is greater than total cost we will be able to \\ncomplete the trip?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Hmm, interesting "
                    },
                    {
                        "username": "ibeastking",
                        "content": "Can someone plz tell me that why we are not checking earlier indices while iterating the loop?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "[@ibeastking](/ibeastking)  We donot assume that earlier indices have satisfied the condition. We just start iterating from first index. And keep on adding gas we get and keep on subtracting gas it needs to reach next index. While doing this, if the gas we have is not sufficient to the gas it costs to reach next index. It means we need to try starting car from another index. And reset gas collected, and start from the next index to the index we reached before. \\nI hope you get what I mean."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@prashantghi8](/prashantghi8) Do we assume that earlier indices have satisfied the constraints or is that some logical thing??"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "We can solve this task by iterating from the first index, So how are we not checking earlier indices?? But we dont have to go back to earlier indices again after reaching final index of the gas stations"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "Hey all, if you guys are consoling/printing op while debugging, make sure you remove them before submitting answer, because if the print is running in loops it might throw Output limit exceeded error and might reject your solution even though it is correct. I just witnessed this, so writing here :)\\nHope this might be helpful"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I\\'d say first write the brute force approach, which won\\'t pass because of TLE. Then consider the fact that if you start at `i` and ends at `k` (ie. gas remained at k is < 0), then any point between `i` and `k` is NOT a valid point. \\nSo no need to write `for start in range(0, n)`, you can write a while loop `start = 0, while start < n: {.... do something ...}, start = k`.\\n\\nThere\\'s only 1 or 2 lines of code change between the valid approach and the brute-force approach."
                    },
                    {
                        "username": "kaustubh_dalvi_",
                        "content": "Hello everyone !!!\\nAccording to description and some of the test case we may conclude that we can return the index of minimum of cost. if we have N no. of minimum (i.e same cost at multiple gas station) then we can return the index of last minimum of the cost. Surprisingly it passed 28 testcases but failed on 29th which conclude that, finding the minimum is not sufficient...\\nCan anyone find other logic than this ??? (which accepts all the testcases...)"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Done and dusted\\uD83D\\uDE0E\\uD83E\\uDD1E...\\nAfter more than 2 hours \\uD83E\\uDD72"
                    },
                    {
                        "username": "er_sushant",
                        "content": "Isn\\'t this a greedy week?\\nSurprisingly, everyproblem solves using greedy!"
                    },
                    {
                        "username": "saurabha9540",
                        "content": "gas=[5,1,2,3,4]\\ncost=[4,4,1,5,1]\\n\\nI start at index 2 tank=2;\\nTo index 3=>2+3-1 so tank=4 units of gas\\nTo index 4=>4+4-5 so tank=3 units of gas\\nTo index 0=>3+5-1 so tank=7 units of gas\\nTo index 1=>7+1-4 so tank=4 units of gas \\n now to move back to index 2 I need 4 units of gas and I have 4 . So why is answer 4 instead of 2 ??\\n"
                    },
                    {
                        "username": "thisannie",
                        "content": "at Index 2: your tank will have tank = 2 units. now you want to move to index 3 but in order to reach to station 3 (index 3) you need 1 unit of fuel (cost[2]=1). as you have enough gas to reach to station 3, you can go to station 3.\\nat Index 3: your tank = 2-1+3 = 4 units. in order to travel to next station, you need 5 units of fuel (as cost[3]=5) but your tanks has only 4 units hence you can not travel further.\\n\\nmathematically,\\nyou need to subtract cost[i] first and then add gas[i+1].\\nso in your second step,\\n4-5=1 will be calculated first and (NOT 4+4-5 =3 )as it is negative you cant move further. "
                    }
                ]
            },
            {
                "id": 1746349,
                "content": [
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "VERY VERY SIMPLE and INTUTIVE SOLN\\n\\n int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n\\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "White73",
                        "content": "is there any way to calculate answer when there are more than 1 solution (i.e. not unique) "
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "is it possible to prove that if total gas is greater than total cost we will be able to \\ncomplete the trip?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Hmm, interesting "
                    },
                    {
                        "username": "ibeastking",
                        "content": "Can someone plz tell me that why we are not checking earlier indices while iterating the loop?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "[@ibeastking](/ibeastking)  We donot assume that earlier indices have satisfied the condition. We just start iterating from first index. And keep on adding gas we get and keep on subtracting gas it needs to reach next index. While doing this, if the gas we have is not sufficient to the gas it costs to reach next index. It means we need to try starting car from another index. And reset gas collected, and start from the next index to the index we reached before. \\nI hope you get what I mean."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@prashantghi8](/prashantghi8) Do we assume that earlier indices have satisfied the constraints or is that some logical thing??"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "We can solve this task by iterating from the first index, So how are we not checking earlier indices?? But we dont have to go back to earlier indices again after reaching final index of the gas stations"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "Hey all, if you guys are consoling/printing op while debugging, make sure you remove them before submitting answer, because if the print is running in loops it might throw Output limit exceeded error and might reject your solution even though it is correct. I just witnessed this, so writing here :)\\nHope this might be helpful"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I\\'d say first write the brute force approach, which won\\'t pass because of TLE. Then consider the fact that if you start at `i` and ends at `k` (ie. gas remained at k is < 0), then any point between `i` and `k` is NOT a valid point. \\nSo no need to write `for start in range(0, n)`, you can write a while loop `start = 0, while start < n: {.... do something ...}, start = k`.\\n\\nThere\\'s only 1 or 2 lines of code change between the valid approach and the brute-force approach."
                    },
                    {
                        "username": "kaustubh_dalvi_",
                        "content": "Hello everyone !!!\\nAccording to description and some of the test case we may conclude that we can return the index of minimum of cost. if we have N no. of minimum (i.e same cost at multiple gas station) then we can return the index of last minimum of the cost. Surprisingly it passed 28 testcases but failed on 29th which conclude that, finding the minimum is not sufficient...\\nCan anyone find other logic than this ??? (which accepts all the testcases...)"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Done and dusted\\uD83D\\uDE0E\\uD83E\\uDD1E...\\nAfter more than 2 hours \\uD83E\\uDD72"
                    },
                    {
                        "username": "er_sushant",
                        "content": "Isn\\'t this a greedy week?\\nSurprisingly, everyproblem solves using greedy!"
                    },
                    {
                        "username": "saurabha9540",
                        "content": "gas=[5,1,2,3,4]\\ncost=[4,4,1,5,1]\\n\\nI start at index 2 tank=2;\\nTo index 3=>2+3-1 so tank=4 units of gas\\nTo index 4=>4+4-5 so tank=3 units of gas\\nTo index 0=>3+5-1 so tank=7 units of gas\\nTo index 1=>7+1-4 so tank=4 units of gas \\n now to move back to index 2 I need 4 units of gas and I have 4 . So why is answer 4 instead of 2 ??\\n"
                    },
                    {
                        "username": "thisannie",
                        "content": "at Index 2: your tank will have tank = 2 units. now you want to move to index 3 but in order to reach to station 3 (index 3) you need 1 unit of fuel (cost[2]=1). as you have enough gas to reach to station 3, you can go to station 3.\\nat Index 3: your tank = 2-1+3 = 4 units. in order to travel to next station, you need 5 units of fuel (as cost[3]=5) but your tanks has only 4 units hence you can not travel further.\\n\\nmathematically,\\nyou need to subtract cost[i] first and then add gas[i+1].\\nso in your second step,\\n4-5=1 will be calculated first and (NOT 4+4-5 =3 )as it is negative you cant move further. "
                    }
                ]
            },
            {
                "id": 1746244,
                "content": [
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "VERY VERY SIMPLE and INTUTIVE SOLN\\n\\n int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n\\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "White73",
                        "content": "is there any way to calculate answer when there are more than 1 solution (i.e. not unique) "
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "is it possible to prove that if total gas is greater than total cost we will be able to \\ncomplete the trip?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Hmm, interesting "
                    },
                    {
                        "username": "ibeastking",
                        "content": "Can someone plz tell me that why we are not checking earlier indices while iterating the loop?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "[@ibeastking](/ibeastking)  We donot assume that earlier indices have satisfied the condition. We just start iterating from first index. And keep on adding gas we get and keep on subtracting gas it needs to reach next index. While doing this, if the gas we have is not sufficient to the gas it costs to reach next index. It means we need to try starting car from another index. And reset gas collected, and start from the next index to the index we reached before. \\nI hope you get what I mean."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@prashantghi8](/prashantghi8) Do we assume that earlier indices have satisfied the constraints or is that some logical thing??"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "We can solve this task by iterating from the first index, So how are we not checking earlier indices?? But we dont have to go back to earlier indices again after reaching final index of the gas stations"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "Hey all, if you guys are consoling/printing op while debugging, make sure you remove them before submitting answer, because if the print is running in loops it might throw Output limit exceeded error and might reject your solution even though it is correct. I just witnessed this, so writing here :)\\nHope this might be helpful"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I\\'d say first write the brute force approach, which won\\'t pass because of TLE. Then consider the fact that if you start at `i` and ends at `k` (ie. gas remained at k is < 0), then any point between `i` and `k` is NOT a valid point. \\nSo no need to write `for start in range(0, n)`, you can write a while loop `start = 0, while start < n: {.... do something ...}, start = k`.\\n\\nThere\\'s only 1 or 2 lines of code change between the valid approach and the brute-force approach."
                    },
                    {
                        "username": "kaustubh_dalvi_",
                        "content": "Hello everyone !!!\\nAccording to description and some of the test case we may conclude that we can return the index of minimum of cost. if we have N no. of minimum (i.e same cost at multiple gas station) then we can return the index of last minimum of the cost. Surprisingly it passed 28 testcases but failed on 29th which conclude that, finding the minimum is not sufficient...\\nCan anyone find other logic than this ??? (which accepts all the testcases...)"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Done and dusted\\uD83D\\uDE0E\\uD83E\\uDD1E...\\nAfter more than 2 hours \\uD83E\\uDD72"
                    },
                    {
                        "username": "er_sushant",
                        "content": "Isn\\'t this a greedy week?\\nSurprisingly, everyproblem solves using greedy!"
                    },
                    {
                        "username": "saurabha9540",
                        "content": "gas=[5,1,2,3,4]\\ncost=[4,4,1,5,1]\\n\\nI start at index 2 tank=2;\\nTo index 3=>2+3-1 so tank=4 units of gas\\nTo index 4=>4+4-5 so tank=3 units of gas\\nTo index 0=>3+5-1 so tank=7 units of gas\\nTo index 1=>7+1-4 so tank=4 units of gas \\n now to move back to index 2 I need 4 units of gas and I have 4 . So why is answer 4 instead of 2 ??\\n"
                    },
                    {
                        "username": "thisannie",
                        "content": "at Index 2: your tank will have tank = 2 units. now you want to move to index 3 but in order to reach to station 3 (index 3) you need 1 unit of fuel (cost[2]=1). as you have enough gas to reach to station 3, you can go to station 3.\\nat Index 3: your tank = 2-1+3 = 4 units. in order to travel to next station, you need 5 units of fuel (as cost[3]=5) but your tanks has only 4 units hence you can not travel further.\\n\\nmathematically,\\nyou need to subtract cost[i] first and then add gas[i+1].\\nso in your second step,\\n4-5=1 will be calculated first and (NOT 4+4-5 =3 )as it is negative you cant move further. "
                    }
                ]
            },
            {
                "id": 1746170,
                "content": [
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "VERY VERY SIMPLE and INTUTIVE SOLN\\n\\n int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n\\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "White73",
                        "content": "is there any way to calculate answer when there are more than 1 solution (i.e. not unique) "
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "is it possible to prove that if total gas is greater than total cost we will be able to \\ncomplete the trip?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Hmm, interesting "
                    },
                    {
                        "username": "ibeastking",
                        "content": "Can someone plz tell me that why we are not checking earlier indices while iterating the loop?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "[@ibeastking](/ibeastking)  We donot assume that earlier indices have satisfied the condition. We just start iterating from first index. And keep on adding gas we get and keep on subtracting gas it needs to reach next index. While doing this, if the gas we have is not sufficient to the gas it costs to reach next index. It means we need to try starting car from another index. And reset gas collected, and start from the next index to the index we reached before. \\nI hope you get what I mean."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@prashantghi8](/prashantghi8) Do we assume that earlier indices have satisfied the constraints or is that some logical thing??"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "We can solve this task by iterating from the first index, So how are we not checking earlier indices?? But we dont have to go back to earlier indices again after reaching final index of the gas stations"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "Hey all, if you guys are consoling/printing op while debugging, make sure you remove them before submitting answer, because if the print is running in loops it might throw Output limit exceeded error and might reject your solution even though it is correct. I just witnessed this, so writing here :)\\nHope this might be helpful"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I\\'d say first write the brute force approach, which won\\'t pass because of TLE. Then consider the fact that if you start at `i` and ends at `k` (ie. gas remained at k is < 0), then any point between `i` and `k` is NOT a valid point. \\nSo no need to write `for start in range(0, n)`, you can write a while loop `start = 0, while start < n: {.... do something ...}, start = k`.\\n\\nThere\\'s only 1 or 2 lines of code change between the valid approach and the brute-force approach."
                    },
                    {
                        "username": "kaustubh_dalvi_",
                        "content": "Hello everyone !!!\\nAccording to description and some of the test case we may conclude that we can return the index of minimum of cost. if we have N no. of minimum (i.e same cost at multiple gas station) then we can return the index of last minimum of the cost. Surprisingly it passed 28 testcases but failed on 29th which conclude that, finding the minimum is not sufficient...\\nCan anyone find other logic than this ??? (which accepts all the testcases...)"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Done and dusted\\uD83D\\uDE0E\\uD83E\\uDD1E...\\nAfter more than 2 hours \\uD83E\\uDD72"
                    },
                    {
                        "username": "er_sushant",
                        "content": "Isn\\'t this a greedy week?\\nSurprisingly, everyproblem solves using greedy!"
                    },
                    {
                        "username": "saurabha9540",
                        "content": "gas=[5,1,2,3,4]\\ncost=[4,4,1,5,1]\\n\\nI start at index 2 tank=2;\\nTo index 3=>2+3-1 so tank=4 units of gas\\nTo index 4=>4+4-5 so tank=3 units of gas\\nTo index 0=>3+5-1 so tank=7 units of gas\\nTo index 1=>7+1-4 so tank=4 units of gas \\n now to move back to index 2 I need 4 units of gas and I have 4 . So why is answer 4 instead of 2 ??\\n"
                    },
                    {
                        "username": "thisannie",
                        "content": "at Index 2: your tank will have tank = 2 units. now you want to move to index 3 but in order to reach to station 3 (index 3) you need 1 unit of fuel (cost[2]=1). as you have enough gas to reach to station 3, you can go to station 3.\\nat Index 3: your tank = 2-1+3 = 4 units. in order to travel to next station, you need 5 units of fuel (as cost[3]=5) but your tanks has only 4 units hence you can not travel further.\\n\\nmathematically,\\nyou need to subtract cost[i] first and then add gas[i+1].\\nso in your second step,\\n4-5=1 will be calculated first and (NOT 4+4-5 =3 )as it is negative you cant move further. "
                    }
                ]
            },
            {
                "id": 1746162,
                "content": [
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "VERY VERY SIMPLE and INTUTIVE SOLN\\n\\n int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n\\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "White73",
                        "content": "is there any way to calculate answer when there are more than 1 solution (i.e. not unique) "
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "is it possible to prove that if total gas is greater than total cost we will be able to \\ncomplete the trip?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Hmm, interesting "
                    },
                    {
                        "username": "ibeastking",
                        "content": "Can someone plz tell me that why we are not checking earlier indices while iterating the loop?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "[@ibeastking](/ibeastking)  We donot assume that earlier indices have satisfied the condition. We just start iterating from first index. And keep on adding gas we get and keep on subtracting gas it needs to reach next index. While doing this, if the gas we have is not sufficient to the gas it costs to reach next index. It means we need to try starting car from another index. And reset gas collected, and start from the next index to the index we reached before. \\nI hope you get what I mean."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@prashantghi8](/prashantghi8) Do we assume that earlier indices have satisfied the constraints or is that some logical thing??"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "We can solve this task by iterating from the first index, So how are we not checking earlier indices?? But we dont have to go back to earlier indices again after reaching final index of the gas stations"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "Hey all, if you guys are consoling/printing op while debugging, make sure you remove them before submitting answer, because if the print is running in loops it might throw Output limit exceeded error and might reject your solution even though it is correct. I just witnessed this, so writing here :)\\nHope this might be helpful"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I\\'d say first write the brute force approach, which won\\'t pass because of TLE. Then consider the fact that if you start at `i` and ends at `k` (ie. gas remained at k is < 0), then any point between `i` and `k` is NOT a valid point. \\nSo no need to write `for start in range(0, n)`, you can write a while loop `start = 0, while start < n: {.... do something ...}, start = k`.\\n\\nThere\\'s only 1 or 2 lines of code change between the valid approach and the brute-force approach."
                    },
                    {
                        "username": "kaustubh_dalvi_",
                        "content": "Hello everyone !!!\\nAccording to description and some of the test case we may conclude that we can return the index of minimum of cost. if we have N no. of minimum (i.e same cost at multiple gas station) then we can return the index of last minimum of the cost. Surprisingly it passed 28 testcases but failed on 29th which conclude that, finding the minimum is not sufficient...\\nCan anyone find other logic than this ??? (which accepts all the testcases...)"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Done and dusted\\uD83D\\uDE0E\\uD83E\\uDD1E...\\nAfter more than 2 hours \\uD83E\\uDD72"
                    },
                    {
                        "username": "er_sushant",
                        "content": "Isn\\'t this a greedy week?\\nSurprisingly, everyproblem solves using greedy!"
                    },
                    {
                        "username": "saurabha9540",
                        "content": "gas=[5,1,2,3,4]\\ncost=[4,4,1,5,1]\\n\\nI start at index 2 tank=2;\\nTo index 3=>2+3-1 so tank=4 units of gas\\nTo index 4=>4+4-5 so tank=3 units of gas\\nTo index 0=>3+5-1 so tank=7 units of gas\\nTo index 1=>7+1-4 so tank=4 units of gas \\n now to move back to index 2 I need 4 units of gas and I have 4 . So why is answer 4 instead of 2 ??\\n"
                    },
                    {
                        "username": "thisannie",
                        "content": "at Index 2: your tank will have tank = 2 units. now you want to move to index 3 but in order to reach to station 3 (index 3) you need 1 unit of fuel (cost[2]=1). as you have enough gas to reach to station 3, you can go to station 3.\\nat Index 3: your tank = 2-1+3 = 4 units. in order to travel to next station, you need 5 units of fuel (as cost[3]=5) but your tanks has only 4 units hence you can not travel further.\\n\\nmathematically,\\nyou need to subtract cost[i] first and then add gas[i+1].\\nso in your second step,\\n4-5=1 will be calculated first and (NOT 4+4-5 =3 )as it is negative you cant move further. "
                    }
                ]
            },
            {
                "id": 1746159,
                "content": [
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "VERY VERY SIMPLE and INTUTIVE SOLN\\n\\n int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n\\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "White73",
                        "content": "is there any way to calculate answer when there are more than 1 solution (i.e. not unique) "
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "is it possible to prove that if total gas is greater than total cost we will be able to \\ncomplete the trip?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Hmm, interesting "
                    },
                    {
                        "username": "ibeastking",
                        "content": "Can someone plz tell me that why we are not checking earlier indices while iterating the loop?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "[@ibeastking](/ibeastking)  We donot assume that earlier indices have satisfied the condition. We just start iterating from first index. And keep on adding gas we get and keep on subtracting gas it needs to reach next index. While doing this, if the gas we have is not sufficient to the gas it costs to reach next index. It means we need to try starting car from another index. And reset gas collected, and start from the next index to the index we reached before. \\nI hope you get what I mean."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@prashantghi8](/prashantghi8) Do we assume that earlier indices have satisfied the constraints or is that some logical thing??"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "We can solve this task by iterating from the first index, So how are we not checking earlier indices?? But we dont have to go back to earlier indices again after reaching final index of the gas stations"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "Hey all, if you guys are consoling/printing op while debugging, make sure you remove them before submitting answer, because if the print is running in loops it might throw Output limit exceeded error and might reject your solution even though it is correct. I just witnessed this, so writing here :)\\nHope this might be helpful"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I\\'d say first write the brute force approach, which won\\'t pass because of TLE. Then consider the fact that if you start at `i` and ends at `k` (ie. gas remained at k is < 0), then any point between `i` and `k` is NOT a valid point. \\nSo no need to write `for start in range(0, n)`, you can write a while loop `start = 0, while start < n: {.... do something ...}, start = k`.\\n\\nThere\\'s only 1 or 2 lines of code change between the valid approach and the brute-force approach."
                    },
                    {
                        "username": "kaustubh_dalvi_",
                        "content": "Hello everyone !!!\\nAccording to description and some of the test case we may conclude that we can return the index of minimum of cost. if we have N no. of minimum (i.e same cost at multiple gas station) then we can return the index of last minimum of the cost. Surprisingly it passed 28 testcases but failed on 29th which conclude that, finding the minimum is not sufficient...\\nCan anyone find other logic than this ??? (which accepts all the testcases...)"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Done and dusted\\uD83D\\uDE0E\\uD83E\\uDD1E...\\nAfter more than 2 hours \\uD83E\\uDD72"
                    },
                    {
                        "username": "er_sushant",
                        "content": "Isn\\'t this a greedy week?\\nSurprisingly, everyproblem solves using greedy!"
                    },
                    {
                        "username": "saurabha9540",
                        "content": "gas=[5,1,2,3,4]\\ncost=[4,4,1,5,1]\\n\\nI start at index 2 tank=2;\\nTo index 3=>2+3-1 so tank=4 units of gas\\nTo index 4=>4+4-5 so tank=3 units of gas\\nTo index 0=>3+5-1 so tank=7 units of gas\\nTo index 1=>7+1-4 so tank=4 units of gas \\n now to move back to index 2 I need 4 units of gas and I have 4 . So why is answer 4 instead of 2 ??\\n"
                    },
                    {
                        "username": "thisannie",
                        "content": "at Index 2: your tank will have tank = 2 units. now you want to move to index 3 but in order to reach to station 3 (index 3) you need 1 unit of fuel (cost[2]=1). as you have enough gas to reach to station 3, you can go to station 3.\\nat Index 3: your tank = 2-1+3 = 4 units. in order to travel to next station, you need 5 units of fuel (as cost[3]=5) but your tanks has only 4 units hence you can not travel further.\\n\\nmathematically,\\nyou need to subtract cost[i] first and then add gas[i+1].\\nso in your second step,\\n4-5=1 will be calculated first and (NOT 4+4-5 =3 )as it is negative you cant move further. "
                    }
                ]
            },
            {
                "id": 1746068,
                "content": [
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "VERY VERY SIMPLE and INTUTIVE SOLN\\n\\n int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n\\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "White73",
                        "content": "is there any way to calculate answer when there are more than 1 solution (i.e. not unique) "
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "is it possible to prove that if total gas is greater than total cost we will be able to \\ncomplete the trip?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Hmm, interesting "
                    },
                    {
                        "username": "ibeastking",
                        "content": "Can someone plz tell me that why we are not checking earlier indices while iterating the loop?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "[@ibeastking](/ibeastking)  We donot assume that earlier indices have satisfied the condition. We just start iterating from first index. And keep on adding gas we get and keep on subtracting gas it needs to reach next index. While doing this, if the gas we have is not sufficient to the gas it costs to reach next index. It means we need to try starting car from another index. And reset gas collected, and start from the next index to the index we reached before. \\nI hope you get what I mean."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@prashantghi8](/prashantghi8) Do we assume that earlier indices have satisfied the constraints or is that some logical thing??"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "We can solve this task by iterating from the first index, So how are we not checking earlier indices?? But we dont have to go back to earlier indices again after reaching final index of the gas stations"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "Hey all, if you guys are consoling/printing op while debugging, make sure you remove them before submitting answer, because if the print is running in loops it might throw Output limit exceeded error and might reject your solution even though it is correct. I just witnessed this, so writing here :)\\nHope this might be helpful"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I\\'d say first write the brute force approach, which won\\'t pass because of TLE. Then consider the fact that if you start at `i` and ends at `k` (ie. gas remained at k is < 0), then any point between `i` and `k` is NOT a valid point. \\nSo no need to write `for start in range(0, n)`, you can write a while loop `start = 0, while start < n: {.... do something ...}, start = k`.\\n\\nThere\\'s only 1 or 2 lines of code change between the valid approach and the brute-force approach."
                    },
                    {
                        "username": "kaustubh_dalvi_",
                        "content": "Hello everyone !!!\\nAccording to description and some of the test case we may conclude that we can return the index of minimum of cost. if we have N no. of minimum (i.e same cost at multiple gas station) then we can return the index of last minimum of the cost. Surprisingly it passed 28 testcases but failed on 29th which conclude that, finding the minimum is not sufficient...\\nCan anyone find other logic than this ??? (which accepts all the testcases...)"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Done and dusted\\uD83D\\uDE0E\\uD83E\\uDD1E...\\nAfter more than 2 hours \\uD83E\\uDD72"
                    },
                    {
                        "username": "er_sushant",
                        "content": "Isn\\'t this a greedy week?\\nSurprisingly, everyproblem solves using greedy!"
                    },
                    {
                        "username": "saurabha9540",
                        "content": "gas=[5,1,2,3,4]\\ncost=[4,4,1,5,1]\\n\\nI start at index 2 tank=2;\\nTo index 3=>2+3-1 so tank=4 units of gas\\nTo index 4=>4+4-5 so tank=3 units of gas\\nTo index 0=>3+5-1 so tank=7 units of gas\\nTo index 1=>7+1-4 so tank=4 units of gas \\n now to move back to index 2 I need 4 units of gas and I have 4 . So why is answer 4 instead of 2 ??\\n"
                    },
                    {
                        "username": "thisannie",
                        "content": "at Index 2: your tank will have tank = 2 units. now you want to move to index 3 but in order to reach to station 3 (index 3) you need 1 unit of fuel (cost[2]=1). as you have enough gas to reach to station 3, you can go to station 3.\\nat Index 3: your tank = 2-1+3 = 4 units. in order to travel to next station, you need 5 units of fuel (as cost[3]=5) but your tanks has only 4 units hence you can not travel further.\\n\\nmathematically,\\nyou need to subtract cost[i] first and then add gas[i+1].\\nso in your second step,\\n4-5=1 will be calculated first and (NOT 4+4-5 =3 )as it is negative you cant move further. "
                    }
                ]
            },
            {
                "id": 1746048,
                "content": [
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "VERY VERY SIMPLE and INTUTIVE SOLN\\n\\n int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n\\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "White73",
                        "content": "is there any way to calculate answer when there are more than 1 solution (i.e. not unique) "
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "is it possible to prove that if total gas is greater than total cost we will be able to \\ncomplete the trip?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Hmm, interesting "
                    },
                    {
                        "username": "ibeastking",
                        "content": "Can someone plz tell me that why we are not checking earlier indices while iterating the loop?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "[@ibeastking](/ibeastking)  We donot assume that earlier indices have satisfied the condition. We just start iterating from first index. And keep on adding gas we get and keep on subtracting gas it needs to reach next index. While doing this, if the gas we have is not sufficient to the gas it costs to reach next index. It means we need to try starting car from another index. And reset gas collected, and start from the next index to the index we reached before. \\nI hope you get what I mean."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@prashantghi8](/prashantghi8) Do we assume that earlier indices have satisfied the constraints or is that some logical thing??"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "We can solve this task by iterating from the first index, So how are we not checking earlier indices?? But we dont have to go back to earlier indices again after reaching final index of the gas stations"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "Hey all, if you guys are consoling/printing op while debugging, make sure you remove them before submitting answer, because if the print is running in loops it might throw Output limit exceeded error and might reject your solution even though it is correct. I just witnessed this, so writing here :)\\nHope this might be helpful"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I\\'d say first write the brute force approach, which won\\'t pass because of TLE. Then consider the fact that if you start at `i` and ends at `k` (ie. gas remained at k is < 0), then any point between `i` and `k` is NOT a valid point. \\nSo no need to write `for start in range(0, n)`, you can write a while loop `start = 0, while start < n: {.... do something ...}, start = k`.\\n\\nThere\\'s only 1 or 2 lines of code change between the valid approach and the brute-force approach."
                    },
                    {
                        "username": "kaustubh_dalvi_",
                        "content": "Hello everyone !!!\\nAccording to description and some of the test case we may conclude that we can return the index of minimum of cost. if we have N no. of minimum (i.e same cost at multiple gas station) then we can return the index of last minimum of the cost. Surprisingly it passed 28 testcases but failed on 29th which conclude that, finding the minimum is not sufficient...\\nCan anyone find other logic than this ??? (which accepts all the testcases...)"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Done and dusted\\uD83D\\uDE0E\\uD83E\\uDD1E...\\nAfter more than 2 hours \\uD83E\\uDD72"
                    },
                    {
                        "username": "er_sushant",
                        "content": "Isn\\'t this a greedy week?\\nSurprisingly, everyproblem solves using greedy!"
                    },
                    {
                        "username": "saurabha9540",
                        "content": "gas=[5,1,2,3,4]\\ncost=[4,4,1,5,1]\\n\\nI start at index 2 tank=2;\\nTo index 3=>2+3-1 so tank=4 units of gas\\nTo index 4=>4+4-5 so tank=3 units of gas\\nTo index 0=>3+5-1 so tank=7 units of gas\\nTo index 1=>7+1-4 so tank=4 units of gas \\n now to move back to index 2 I need 4 units of gas and I have 4 . So why is answer 4 instead of 2 ??\\n"
                    },
                    {
                        "username": "thisannie",
                        "content": "at Index 2: your tank will have tank = 2 units. now you want to move to index 3 but in order to reach to station 3 (index 3) you need 1 unit of fuel (cost[2]=1). as you have enough gas to reach to station 3, you can go to station 3.\\nat Index 3: your tank = 2-1+3 = 4 units. in order to travel to next station, you need 5 units of fuel (as cost[3]=5) but your tanks has only 4 units hence you can not travel further.\\n\\nmathematically,\\nyou need to subtract cost[i] first and then add gas[i+1].\\nso in your second step,\\n4-5=1 will be calculated first and (NOT 4+4-5 =3 )as it is negative you cant move further. "
                    }
                ]
            },
            {
                "id": 1745993,
                "content": [
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "VERY VERY SIMPLE and INTUTIVE SOLN\\n\\n int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n\\n        int n=gas.size();\\n        int index=0;\\n        int balance=0 , rent=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(cost[i]>gas[i]+balance){\\n                index=i+1;\\n                rent+=-(cost[i]-(gas[i]+balance));\\n                balance=0;\\n            }else{\\n                balance+=(gas[i]-cost[i]);\\n            }\\n        }\\n        return rent+balance>=0?index:-1;\\n    }"
                    },
                    {
                        "username": "White73",
                        "content": "is there any way to calculate answer when there are more than 1 solution (i.e. not unique) "
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "is it possible to prove that if total gas is greater than total cost we will be able to \\ncomplete the trip?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Hmm, interesting "
                    },
                    {
                        "username": "ibeastking",
                        "content": "Can someone plz tell me that why we are not checking earlier indices while iterating the loop?"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "[@ibeastking](/ibeastking)  We donot assume that earlier indices have satisfied the condition. We just start iterating from first index. And keep on adding gas we get and keep on subtracting gas it needs to reach next index. While doing this, if the gas we have is not sufficient to the gas it costs to reach next index. It means we need to try starting car from another index. And reset gas collected, and start from the next index to the index we reached before. \\nI hope you get what I mean."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@prashantghi8](/prashantghi8) Do we assume that earlier indices have satisfied the constraints or is that some logical thing??"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "We can solve this task by iterating from the first index, So how are we not checking earlier indices?? But we dont have to go back to earlier indices again after reaching final index of the gas stations"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "Hey all, if you guys are consoling/printing op while debugging, make sure you remove them before submitting answer, because if the print is running in loops it might throw Output limit exceeded error and might reject your solution even though it is correct. I just witnessed this, so writing here :)\\nHope this might be helpful"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I\\'d say first write the brute force approach, which won\\'t pass because of TLE. Then consider the fact that if you start at `i` and ends at `k` (ie. gas remained at k is < 0), then any point between `i` and `k` is NOT a valid point. \\nSo no need to write `for start in range(0, n)`, you can write a while loop `start = 0, while start < n: {.... do something ...}, start = k`.\\n\\nThere\\'s only 1 or 2 lines of code change between the valid approach and the brute-force approach."
                    },
                    {
                        "username": "kaustubh_dalvi_",
                        "content": "Hello everyone !!!\\nAccording to description and some of the test case we may conclude that we can return the index of minimum of cost. if we have N no. of minimum (i.e same cost at multiple gas station) then we can return the index of last minimum of the cost. Surprisingly it passed 28 testcases but failed on 29th which conclude that, finding the minimum is not sufficient...\\nCan anyone find other logic than this ??? (which accepts all the testcases...)"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Done and dusted\\uD83D\\uDE0E\\uD83E\\uDD1E...\\nAfter more than 2 hours \\uD83E\\uDD72"
                    },
                    {
                        "username": "er_sushant",
                        "content": "Isn\\'t this a greedy week?\\nSurprisingly, everyproblem solves using greedy!"
                    },
                    {
                        "username": "saurabha9540",
                        "content": "gas=[5,1,2,3,4]\\ncost=[4,4,1,5,1]\\n\\nI start at index 2 tank=2;\\nTo index 3=>2+3-1 so tank=4 units of gas\\nTo index 4=>4+4-5 so tank=3 units of gas\\nTo index 0=>3+5-1 so tank=7 units of gas\\nTo index 1=>7+1-4 so tank=4 units of gas \\n now to move back to index 2 I need 4 units of gas and I have 4 . So why is answer 4 instead of 2 ??\\n"
                    },
                    {
                        "username": "thisannie",
                        "content": "at Index 2: your tank will have tank = 2 units. now you want to move to index 3 but in order to reach to station 3 (index 3) you need 1 unit of fuel (cost[2]=1). as you have enough gas to reach to station 3, you can go to station 3.\\nat Index 3: your tank = 2-1+3 = 4 units. in order to travel to next station, you need 5 units of fuel (as cost[3]=5) but your tanks has only 4 units hence you can not travel further.\\n\\nmathematically,\\nyou need to subtract cost[i] first and then add gas[i+1].\\nso in your second step,\\n4-5=1 will be calculated first and (NOT 4+4-5 =3 )as it is negative you cant move further. "
                    }
                ]
            },
            {
                "id": 1745990,
                "content": [
                    {
                        "username": "UltimateMeta",
                        "content": "The wording of the question is slightly wrong. In this line, `You have a car with an unlimited gas tank and it costs cost[i] of gas to travel`, it should be  `it costs cost[i] units of gas to travel` because cost means in terms of money. So, if there were no test cases given, it is not possible to solve this if we don\\'t assume that it does not mean money when is says `cost` but that it means `units`. This felt confusing to me until I saw/analyzed the test cases given."
                    },
                    {
                        "username": "Msey",
                        "content": "Ancient problem as we see"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                           \\n                  class Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        start, n, s = 0, len(gas), 0\\n\\n        for i in range(2 * n):\\n            s += gas[i % n] - cost[i % n]\\n\\n            if s < 0: s, start = 0, i + 1\\n            if i >= start + n: return start\\n        return -1\\n\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if sum(gas) < sum(cost): \\n            return -1\\n        n, start, res = len(gas), 0, 0\\n        for i in range(n):\\n            res += gas[i] - cost[i]\\n            if res < 0:\\n                start, res = i+1, 0\\n        return start"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                   \\n\\n              class Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        start, n, s = 0, len(gas), 0\\n\\n        for i in range(2 * n):\\n            s += gas[i % n] - cost[i % n]\\n\\n            if s < 0: s, start = 0, i + 1\\n            if i >= start + n: return start\\n            \\n        return -1"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Solved with greedy approach, \\nbut i believe it can be solved using dfs or topdown approach can someone give me sample code? \\n\\ngot TLE when tried apply dfs or topdown "
                    },
                    {
                        "username": "mayankK135",
                        "content": "The question is not so obvious like you can figure out it\\'s a greed problem but actual solution is quite simple but hard to figure out. So here is an explanation to get the solution -\\n1. check whether or not the sum of gas is greater than sum of cost . if not return -1 as no solution can exist . Else a solution will definitely exist and its given that the solution is unique. \\n2. to find the solution use greedy approach use a variable total_sum and keep on adding the difference of gas[i]-cost[i] to it if the total_sum <0 than reset it to 0 and set the answer to i+1;\\n\\n"
                    },
                    {
                        "username": "omaramin622",
                        "content": "when the number of stations is one. you still should check if (gas[0] >= cost[0]).\\n\\nI just felt the answer is always 0 when number of stations is one, but this is not correct and may anyone will think like me. you have to check."
                    },
                    {
                        "username": "jaishankar101",
                        "content": "substract gas[i] with cost[i] and store it in an array;\\nnow find the index to start the addition such that the result is >=0 and return that index. \\n( ps : add the elements of the array if they are negative then no solution exists)"
                    },
                    {
                        "username": "khannaabhishek1010",
                        "content": "I am solving leetcode for last 2 months still I dont solve any question on my own. Only 10% I am able to solve it by own. Why it do so??"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@khannaabhishek1010](/khannaabhishek1010)  All the best bro"
                    },
                    {
                        "username": "khannaabhishek1010",
                        "content": "[@S_Basu](/S_Basu) Thanks bro I am really looking forward for this"
                    },
                    {
                        "username": "S_Basu",
                        "content": "I guess it is OK to take time, as long as you are constantly trying to understand and consistently putting in efforts. Gradually you will become really good like a PRO. \\nSlow & Steady wins the race.\\n\\nIt is OK to see solutions but try to understand the approaches and try on your own first.\\nBest wishes. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "six519",
                        "content": "Found a solution on my own but got a time limit exceeded error. :D Answered the problem by reading other solutions. I\\'m not be able to solve the problem if no posted solutions available.  LOL!!"
                    }
                ]
            },
            {
                "id": 1745969,
                "content": [
                    {
                        "username": "UltimateMeta",
                        "content": "The wording of the question is slightly wrong. In this line, `You have a car with an unlimited gas tank and it costs cost[i] of gas to travel`, it should be  `it costs cost[i] units of gas to travel` because cost means in terms of money. So, if there were no test cases given, it is not possible to solve this if we don\\'t assume that it does not mean money when is says `cost` but that it means `units`. This felt confusing to me until I saw/analyzed the test cases given."
                    },
                    {
                        "username": "Msey",
                        "content": "Ancient problem as we see"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                           \\n                  class Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        start, n, s = 0, len(gas), 0\\n\\n        for i in range(2 * n):\\n            s += gas[i % n] - cost[i % n]\\n\\n            if s < 0: s, start = 0, i + 1\\n            if i >= start + n: return start\\n        return -1\\n\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if sum(gas) < sum(cost): \\n            return -1\\n        n, start, res = len(gas), 0, 0\\n        for i in range(n):\\n            res += gas[i] - cost[i]\\n            if res < 0:\\n                start, res = i+1, 0\\n        return start"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                   \\n\\n              class Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        start, n, s = 0, len(gas), 0\\n\\n        for i in range(2 * n):\\n            s += gas[i % n] - cost[i % n]\\n\\n            if s < 0: s, start = 0, i + 1\\n            if i >= start + n: return start\\n            \\n        return -1"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Solved with greedy approach, \\nbut i believe it can be solved using dfs or topdown approach can someone give me sample code? \\n\\ngot TLE when tried apply dfs or topdown "
                    },
                    {
                        "username": "mayankK135",
                        "content": "The question is not so obvious like you can figure out it\\'s a greed problem but actual solution is quite simple but hard to figure out. So here is an explanation to get the solution -\\n1. check whether or not the sum of gas is greater than sum of cost . if not return -1 as no solution can exist . Else a solution will definitely exist and its given that the solution is unique. \\n2. to find the solution use greedy approach use a variable total_sum and keep on adding the difference of gas[i]-cost[i] to it if the total_sum <0 than reset it to 0 and set the answer to i+1;\\n\\n"
                    },
                    {
                        "username": "omaramin622",
                        "content": "when the number of stations is one. you still should check if (gas[0] >= cost[0]).\\n\\nI just felt the answer is always 0 when number of stations is one, but this is not correct and may anyone will think like me. you have to check."
                    },
                    {
                        "username": "jaishankar101",
                        "content": "substract gas[i] with cost[i] and store it in an array;\\nnow find the index to start the addition such that the result is >=0 and return that index. \\n( ps : add the elements of the array if they are negative then no solution exists)"
                    },
                    {
                        "username": "khannaabhishek1010",
                        "content": "I am solving leetcode for last 2 months still I dont solve any question on my own. Only 10% I am able to solve it by own. Why it do so??"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@khannaabhishek1010](/khannaabhishek1010)  All the best bro"
                    },
                    {
                        "username": "khannaabhishek1010",
                        "content": "[@S_Basu](/S_Basu) Thanks bro I am really looking forward for this"
                    },
                    {
                        "username": "S_Basu",
                        "content": "I guess it is OK to take time, as long as you are constantly trying to understand and consistently putting in efforts. Gradually you will become really good like a PRO. \\nSlow & Steady wins the race.\\n\\nIt is OK to see solutions but try to understand the approaches and try on your own first.\\nBest wishes. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "six519",
                        "content": "Found a solution on my own but got a time limit exceeded error. :D Answered the problem by reading other solutions. I\\'m not be able to solve the problem if no posted solutions available.  LOL!!"
                    }
                ]
            },
            {
                "id": 1745792,
                "content": [
                    {
                        "username": "UltimateMeta",
                        "content": "The wording of the question is slightly wrong. In this line, `You have a car with an unlimited gas tank and it costs cost[i] of gas to travel`, it should be  `it costs cost[i] units of gas to travel` because cost means in terms of money. So, if there were no test cases given, it is not possible to solve this if we don\\'t assume that it does not mean money when is says `cost` but that it means `units`. This felt confusing to me until I saw/analyzed the test cases given."
                    },
                    {
                        "username": "Msey",
                        "content": "Ancient problem as we see"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                           \\n                  class Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        start, n, s = 0, len(gas), 0\\n\\n        for i in range(2 * n):\\n            s += gas[i % n] - cost[i % n]\\n\\n            if s < 0: s, start = 0, i + 1\\n            if i >= start + n: return start\\n        return -1\\n\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if sum(gas) < sum(cost): \\n            return -1\\n        n, start, res = len(gas), 0, 0\\n        for i in range(n):\\n            res += gas[i] - cost[i]\\n            if res < 0:\\n                start, res = i+1, 0\\n        return start"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                   \\n\\n              class Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        start, n, s = 0, len(gas), 0\\n\\n        for i in range(2 * n):\\n            s += gas[i % n] - cost[i % n]\\n\\n            if s < 0: s, start = 0, i + 1\\n            if i >= start + n: return start\\n            \\n        return -1"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Solved with greedy approach, \\nbut i believe it can be solved using dfs or topdown approach can someone give me sample code? \\n\\ngot TLE when tried apply dfs or topdown "
                    },
                    {
                        "username": "mayankK135",
                        "content": "The question is not so obvious like you can figure out it\\'s a greed problem but actual solution is quite simple but hard to figure out. So here is an explanation to get the solution -\\n1. check whether or not the sum of gas is greater than sum of cost . if not return -1 as no solution can exist . Else a solution will definitely exist and its given that the solution is unique. \\n2. to find the solution use greedy approach use a variable total_sum and keep on adding the difference of gas[i]-cost[i] to it if the total_sum <0 than reset it to 0 and set the answer to i+1;\\n\\n"
                    },
                    {
                        "username": "omaramin622",
                        "content": "when the number of stations is one. you still should check if (gas[0] >= cost[0]).\\n\\nI just felt the answer is always 0 when number of stations is one, but this is not correct and may anyone will think like me. you have to check."
                    },
                    {
                        "username": "jaishankar101",
                        "content": "substract gas[i] with cost[i] and store it in an array;\\nnow find the index to start the addition such that the result is >=0 and return that index. \\n( ps : add the elements of the array if they are negative then no solution exists)"
                    },
                    {
                        "username": "khannaabhishek1010",
                        "content": "I am solving leetcode for last 2 months still I dont solve any question on my own. Only 10% I am able to solve it by own. Why it do so??"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@khannaabhishek1010](/khannaabhishek1010)  All the best bro"
                    },
                    {
                        "username": "khannaabhishek1010",
                        "content": "[@S_Basu](/S_Basu) Thanks bro I am really looking forward for this"
                    },
                    {
                        "username": "S_Basu",
                        "content": "I guess it is OK to take time, as long as you are constantly trying to understand and consistently putting in efforts. Gradually you will become really good like a PRO. \\nSlow & Steady wins the race.\\n\\nIt is OK to see solutions but try to understand the approaches and try on your own first.\\nBest wishes. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "six519",
                        "content": "Found a solution on my own but got a time limit exceeded error. :D Answered the problem by reading other solutions. I\\'m not be able to solve the problem if no posted solutions available.  LOL!!"
                    }
                ]
            },
            {
                "id": 1745785,
                "content": [
                    {
                        "username": "UltimateMeta",
                        "content": "The wording of the question is slightly wrong. In this line, `You have a car with an unlimited gas tank and it costs cost[i] of gas to travel`, it should be  `it costs cost[i] units of gas to travel` because cost means in terms of money. So, if there were no test cases given, it is not possible to solve this if we don\\'t assume that it does not mean money when is says `cost` but that it means `units`. This felt confusing to me until I saw/analyzed the test cases given."
                    },
                    {
                        "username": "Msey",
                        "content": "Ancient problem as we see"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                           \\n                  class Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        start, n, s = 0, len(gas), 0\\n\\n        for i in range(2 * n):\\n            s += gas[i % n] - cost[i % n]\\n\\n            if s < 0: s, start = 0, i + 1\\n            if i >= start + n: return start\\n        return -1\\n\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if sum(gas) < sum(cost): \\n            return -1\\n        n, start, res = len(gas), 0, 0\\n        for i in range(n):\\n            res += gas[i] - cost[i]\\n            if res < 0:\\n                start, res = i+1, 0\\n        return start"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                   \\n\\n              class Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        start, n, s = 0, len(gas), 0\\n\\n        for i in range(2 * n):\\n            s += gas[i % n] - cost[i % n]\\n\\n            if s < 0: s, start = 0, i + 1\\n            if i >= start + n: return start\\n            \\n        return -1"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Solved with greedy approach, \\nbut i believe it can be solved using dfs or topdown approach can someone give me sample code? \\n\\ngot TLE when tried apply dfs or topdown "
                    },
                    {
                        "username": "mayankK135",
                        "content": "The question is not so obvious like you can figure out it\\'s a greed problem but actual solution is quite simple but hard to figure out. So here is an explanation to get the solution -\\n1. check whether or not the sum of gas is greater than sum of cost . if not return -1 as no solution can exist . Else a solution will definitely exist and its given that the solution is unique. \\n2. to find the solution use greedy approach use a variable total_sum and keep on adding the difference of gas[i]-cost[i] to it if the total_sum <0 than reset it to 0 and set the answer to i+1;\\n\\n"
                    },
                    {
                        "username": "omaramin622",
                        "content": "when the number of stations is one. you still should check if (gas[0] >= cost[0]).\\n\\nI just felt the answer is always 0 when number of stations is one, but this is not correct and may anyone will think like me. you have to check."
                    },
                    {
                        "username": "jaishankar101",
                        "content": "substract gas[i] with cost[i] and store it in an array;\\nnow find the index to start the addition such that the result is >=0 and return that index. \\n( ps : add the elements of the array if they are negative then no solution exists)"
                    },
                    {
                        "username": "khannaabhishek1010",
                        "content": "I am solving leetcode for last 2 months still I dont solve any question on my own. Only 10% I am able to solve it by own. Why it do so??"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@khannaabhishek1010](/khannaabhishek1010)  All the best bro"
                    },
                    {
                        "username": "khannaabhishek1010",
                        "content": "[@S_Basu](/S_Basu) Thanks bro I am really looking forward for this"
                    },
                    {
                        "username": "S_Basu",
                        "content": "I guess it is OK to take time, as long as you are constantly trying to understand and consistently putting in efforts. Gradually you will become really good like a PRO. \\nSlow & Steady wins the race.\\n\\nIt is OK to see solutions but try to understand the approaches and try on your own first.\\nBest wishes. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "six519",
                        "content": "Found a solution on my own but got a time limit exceeded error. :D Answered the problem by reading other solutions. I\\'m not be able to solve the problem if no posted solutions available.  LOL!!"
                    }
                ]
            },
            {
                "id": 1745761,
                "content": [
                    {
                        "username": "UltimateMeta",
                        "content": "The wording of the question is slightly wrong. In this line, `You have a car with an unlimited gas tank and it costs cost[i] of gas to travel`, it should be  `it costs cost[i] units of gas to travel` because cost means in terms of money. So, if there were no test cases given, it is not possible to solve this if we don\\'t assume that it does not mean money when is says `cost` but that it means `units`. This felt confusing to me until I saw/analyzed the test cases given."
                    },
                    {
                        "username": "Msey",
                        "content": "Ancient problem as we see"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                           \\n                  class Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        start, n, s = 0, len(gas), 0\\n\\n        for i in range(2 * n):\\n            s += gas[i % n] - cost[i % n]\\n\\n            if s < 0: s, start = 0, i + 1\\n            if i >= start + n: return start\\n        return -1\\n\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if sum(gas) < sum(cost): \\n            return -1\\n        n, start, res = len(gas), 0, 0\\n        for i in range(n):\\n            res += gas[i] - cost[i]\\n            if res < 0:\\n                start, res = i+1, 0\\n        return start"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                   \\n\\n              class Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        start, n, s = 0, len(gas), 0\\n\\n        for i in range(2 * n):\\n            s += gas[i % n] - cost[i % n]\\n\\n            if s < 0: s, start = 0, i + 1\\n            if i >= start + n: return start\\n            \\n        return -1"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Solved with greedy approach, \\nbut i believe it can be solved using dfs or topdown approach can someone give me sample code? \\n\\ngot TLE when tried apply dfs or topdown "
                    },
                    {
                        "username": "mayankK135",
                        "content": "The question is not so obvious like you can figure out it\\'s a greed problem but actual solution is quite simple but hard to figure out. So here is an explanation to get the solution -\\n1. check whether or not the sum of gas is greater than sum of cost . if not return -1 as no solution can exist . Else a solution will definitely exist and its given that the solution is unique. \\n2. to find the solution use greedy approach use a variable total_sum and keep on adding the difference of gas[i]-cost[i] to it if the total_sum <0 than reset it to 0 and set the answer to i+1;\\n\\n"
                    },
                    {
                        "username": "omaramin622",
                        "content": "when the number of stations is one. you still should check if (gas[0] >= cost[0]).\\n\\nI just felt the answer is always 0 when number of stations is one, but this is not correct and may anyone will think like me. you have to check."
                    },
                    {
                        "username": "jaishankar101",
                        "content": "substract gas[i] with cost[i] and store it in an array;\\nnow find the index to start the addition such that the result is >=0 and return that index. \\n( ps : add the elements of the array if they are negative then no solution exists)"
                    },
                    {
                        "username": "khannaabhishek1010",
                        "content": "I am solving leetcode for last 2 months still I dont solve any question on my own. Only 10% I am able to solve it by own. Why it do so??"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@khannaabhishek1010](/khannaabhishek1010)  All the best bro"
                    },
                    {
                        "username": "khannaabhishek1010",
                        "content": "[@S_Basu](/S_Basu) Thanks bro I am really looking forward for this"
                    },
                    {
                        "username": "S_Basu",
                        "content": "I guess it is OK to take time, as long as you are constantly trying to understand and consistently putting in efforts. Gradually you will become really good like a PRO. \\nSlow & Steady wins the race.\\n\\nIt is OK to see solutions but try to understand the approaches and try on your own first.\\nBest wishes. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "six519",
                        "content": "Found a solution on my own but got a time limit exceeded error. :D Answered the problem by reading other solutions. I\\'m not be able to solve the problem if no posted solutions available.  LOL!!"
                    }
                ]
            },
            {
                "id": 1745745,
                "content": [
                    {
                        "username": "UltimateMeta",
                        "content": "The wording of the question is slightly wrong. In this line, `You have a car with an unlimited gas tank and it costs cost[i] of gas to travel`, it should be  `it costs cost[i] units of gas to travel` because cost means in terms of money. So, if there were no test cases given, it is not possible to solve this if we don\\'t assume that it does not mean money when is says `cost` but that it means `units`. This felt confusing to me until I saw/analyzed the test cases given."
                    },
                    {
                        "username": "Msey",
                        "content": "Ancient problem as we see"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                           \\n                  class Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        start, n, s = 0, len(gas), 0\\n\\n        for i in range(2 * n):\\n            s += gas[i % n] - cost[i % n]\\n\\n            if s < 0: s, start = 0, i + 1\\n            if i >= start + n: return start\\n        return -1\\n\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if sum(gas) < sum(cost): \\n            return -1\\n        n, start, res = len(gas), 0, 0\\n        for i in range(n):\\n            res += gas[i] - cost[i]\\n            if res < 0:\\n                start, res = i+1, 0\\n        return start"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                   \\n\\n              class Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        start, n, s = 0, len(gas), 0\\n\\n        for i in range(2 * n):\\n            s += gas[i % n] - cost[i % n]\\n\\n            if s < 0: s, start = 0, i + 1\\n            if i >= start + n: return start\\n            \\n        return -1"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Solved with greedy approach, \\nbut i believe it can be solved using dfs or topdown approach can someone give me sample code? \\n\\ngot TLE when tried apply dfs or topdown "
                    },
                    {
                        "username": "mayankK135",
                        "content": "The question is not so obvious like you can figure out it\\'s a greed problem but actual solution is quite simple but hard to figure out. So here is an explanation to get the solution -\\n1. check whether or not the sum of gas is greater than sum of cost . if not return -1 as no solution can exist . Else a solution will definitely exist and its given that the solution is unique. \\n2. to find the solution use greedy approach use a variable total_sum and keep on adding the difference of gas[i]-cost[i] to it if the total_sum <0 than reset it to 0 and set the answer to i+1;\\n\\n"
                    },
                    {
                        "username": "omaramin622",
                        "content": "when the number of stations is one. you still should check if (gas[0] >= cost[0]).\\n\\nI just felt the answer is always 0 when number of stations is one, but this is not correct and may anyone will think like me. you have to check."
                    },
                    {
                        "username": "jaishankar101",
                        "content": "substract gas[i] with cost[i] and store it in an array;\\nnow find the index to start the addition such that the result is >=0 and return that index. \\n( ps : add the elements of the array if they are negative then no solution exists)"
                    },
                    {
                        "username": "khannaabhishek1010",
                        "content": "I am solving leetcode for last 2 months still I dont solve any question on my own. Only 10% I am able to solve it by own. Why it do so??"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@khannaabhishek1010](/khannaabhishek1010)  All the best bro"
                    },
                    {
                        "username": "khannaabhishek1010",
                        "content": "[@S_Basu](/S_Basu) Thanks bro I am really looking forward for this"
                    },
                    {
                        "username": "S_Basu",
                        "content": "I guess it is OK to take time, as long as you are constantly trying to understand and consistently putting in efforts. Gradually you will become really good like a PRO. \\nSlow & Steady wins the race.\\n\\nIt is OK to see solutions but try to understand the approaches and try on your own first.\\nBest wishes. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "six519",
                        "content": "Found a solution on my own but got a time limit exceeded error. :D Answered the problem by reading other solutions. I\\'m not be able to solve the problem if no posted solutions available.  LOL!!"
                    }
                ]
            },
            {
                "id": 1745721,
                "content": [
                    {
                        "username": "UltimateMeta",
                        "content": "The wording of the question is slightly wrong. In this line, `You have a car with an unlimited gas tank and it costs cost[i] of gas to travel`, it should be  `it costs cost[i] units of gas to travel` because cost means in terms of money. So, if there were no test cases given, it is not possible to solve this if we don\\'t assume that it does not mean money when is says `cost` but that it means `units`. This felt confusing to me until I saw/analyzed the test cases given."
                    },
                    {
                        "username": "Msey",
                        "content": "Ancient problem as we see"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                           \\n                  class Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        start, n, s = 0, len(gas), 0\\n\\n        for i in range(2 * n):\\n            s += gas[i % n] - cost[i % n]\\n\\n            if s < 0: s, start = 0, i + 1\\n            if i >= start + n: return start\\n        return -1\\n\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if sum(gas) < sum(cost): \\n            return -1\\n        n, start, res = len(gas), 0, 0\\n        for i in range(n):\\n            res += gas[i] - cost[i]\\n            if res < 0:\\n                start, res = i+1, 0\\n        return start"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                   \\n\\n              class Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        start, n, s = 0, len(gas), 0\\n\\n        for i in range(2 * n):\\n            s += gas[i % n] - cost[i % n]\\n\\n            if s < 0: s, start = 0, i + 1\\n            if i >= start + n: return start\\n            \\n        return -1"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Solved with greedy approach, \\nbut i believe it can be solved using dfs or topdown approach can someone give me sample code? \\n\\ngot TLE when tried apply dfs or topdown "
                    },
                    {
                        "username": "mayankK135",
                        "content": "The question is not so obvious like you can figure out it\\'s a greed problem but actual solution is quite simple but hard to figure out. So here is an explanation to get the solution -\\n1. check whether or not the sum of gas is greater than sum of cost . if not return -1 as no solution can exist . Else a solution will definitely exist and its given that the solution is unique. \\n2. to find the solution use greedy approach use a variable total_sum and keep on adding the difference of gas[i]-cost[i] to it if the total_sum <0 than reset it to 0 and set the answer to i+1;\\n\\n"
                    },
                    {
                        "username": "omaramin622",
                        "content": "when the number of stations is one. you still should check if (gas[0] >= cost[0]).\\n\\nI just felt the answer is always 0 when number of stations is one, but this is not correct and may anyone will think like me. you have to check."
                    },
                    {
                        "username": "jaishankar101",
                        "content": "substract gas[i] with cost[i] and store it in an array;\\nnow find the index to start the addition such that the result is >=0 and return that index. \\n( ps : add the elements of the array if they are negative then no solution exists)"
                    },
                    {
                        "username": "khannaabhishek1010",
                        "content": "I am solving leetcode for last 2 months still I dont solve any question on my own. Only 10% I am able to solve it by own. Why it do so??"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@khannaabhishek1010](/khannaabhishek1010)  All the best bro"
                    },
                    {
                        "username": "khannaabhishek1010",
                        "content": "[@S_Basu](/S_Basu) Thanks bro I am really looking forward for this"
                    },
                    {
                        "username": "S_Basu",
                        "content": "I guess it is OK to take time, as long as you are constantly trying to understand and consistently putting in efforts. Gradually you will become really good like a PRO. \\nSlow & Steady wins the race.\\n\\nIt is OK to see solutions but try to understand the approaches and try on your own first.\\nBest wishes. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "six519",
                        "content": "Found a solution on my own but got a time limit exceeded error. :D Answered the problem by reading other solutions. I\\'m not be able to solve the problem if no posted solutions available.  LOL!!"
                    }
                ]
            },
            {
                "id": 1745720,
                "content": [
                    {
                        "username": "UltimateMeta",
                        "content": "The wording of the question is slightly wrong. In this line, `You have a car with an unlimited gas tank and it costs cost[i] of gas to travel`, it should be  `it costs cost[i] units of gas to travel` because cost means in terms of money. So, if there were no test cases given, it is not possible to solve this if we don\\'t assume that it does not mean money when is says `cost` but that it means `units`. This felt confusing to me until I saw/analyzed the test cases given."
                    },
                    {
                        "username": "Msey",
                        "content": "Ancient problem as we see"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                           \\n                  class Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        start, n, s = 0, len(gas), 0\\n\\n        for i in range(2 * n):\\n            s += gas[i % n] - cost[i % n]\\n\\n            if s < 0: s, start = 0, i + 1\\n            if i >= start + n: return start\\n        return -1\\n\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if sum(gas) < sum(cost): \\n            return -1\\n        n, start, res = len(gas), 0, 0\\n        for i in range(n):\\n            res += gas[i] - cost[i]\\n            if res < 0:\\n                start, res = i+1, 0\\n        return start"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                   \\n\\n              class Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        start, n, s = 0, len(gas), 0\\n\\n        for i in range(2 * n):\\n            s += gas[i % n] - cost[i % n]\\n\\n            if s < 0: s, start = 0, i + 1\\n            if i >= start + n: return start\\n            \\n        return -1"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Solved with greedy approach, \\nbut i believe it can be solved using dfs or topdown approach can someone give me sample code? \\n\\ngot TLE when tried apply dfs or topdown "
                    },
                    {
                        "username": "mayankK135",
                        "content": "The question is not so obvious like you can figure out it\\'s a greed problem but actual solution is quite simple but hard to figure out. So here is an explanation to get the solution -\\n1. check whether or not the sum of gas is greater than sum of cost . if not return -1 as no solution can exist . Else a solution will definitely exist and its given that the solution is unique. \\n2. to find the solution use greedy approach use a variable total_sum and keep on adding the difference of gas[i]-cost[i] to it if the total_sum <0 than reset it to 0 and set the answer to i+1;\\n\\n"
                    },
                    {
                        "username": "omaramin622",
                        "content": "when the number of stations is one. you still should check if (gas[0] >= cost[0]).\\n\\nI just felt the answer is always 0 when number of stations is one, but this is not correct and may anyone will think like me. you have to check."
                    },
                    {
                        "username": "jaishankar101",
                        "content": "substract gas[i] with cost[i] and store it in an array;\\nnow find the index to start the addition such that the result is >=0 and return that index. \\n( ps : add the elements of the array if they are negative then no solution exists)"
                    },
                    {
                        "username": "khannaabhishek1010",
                        "content": "I am solving leetcode for last 2 months still I dont solve any question on my own. Only 10% I am able to solve it by own. Why it do so??"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@khannaabhishek1010](/khannaabhishek1010)  All the best bro"
                    },
                    {
                        "username": "khannaabhishek1010",
                        "content": "[@S_Basu](/S_Basu) Thanks bro I am really looking forward for this"
                    },
                    {
                        "username": "S_Basu",
                        "content": "I guess it is OK to take time, as long as you are constantly trying to understand and consistently putting in efforts. Gradually you will become really good like a PRO. \\nSlow & Steady wins the race.\\n\\nIt is OK to see solutions but try to understand the approaches and try on your own first.\\nBest wishes. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "six519",
                        "content": "Found a solution on my own but got a time limit exceeded error. :D Answered the problem by reading other solutions. I\\'m not be able to solve the problem if no posted solutions available.  LOL!!"
                    }
                ]
            },
            {
                "id": 1745711,
                "content": [
                    {
                        "username": "UltimateMeta",
                        "content": "The wording of the question is slightly wrong. In this line, `You have a car with an unlimited gas tank and it costs cost[i] of gas to travel`, it should be  `it costs cost[i] units of gas to travel` because cost means in terms of money. So, if there were no test cases given, it is not possible to solve this if we don\\'t assume that it does not mean money when is says `cost` but that it means `units`. This felt confusing to me until I saw/analyzed the test cases given."
                    },
                    {
                        "username": "Msey",
                        "content": "Ancient problem as we see"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                           \\n                  class Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        start, n, s = 0, len(gas), 0\\n\\n        for i in range(2 * n):\\n            s += gas[i % n] - cost[i % n]\\n\\n            if s < 0: s, start = 0, i + 1\\n            if i >= start + n: return start\\n        return -1\\n\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if sum(gas) < sum(cost): \\n            return -1\\n        n, start, res = len(gas), 0, 0\\n        for i in range(n):\\n            res += gas[i] - cost[i]\\n            if res < 0:\\n                start, res = i+1, 0\\n        return start"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                   \\n\\n              class Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        start, n, s = 0, len(gas), 0\\n\\n        for i in range(2 * n):\\n            s += gas[i % n] - cost[i % n]\\n\\n            if s < 0: s, start = 0, i + 1\\n            if i >= start + n: return start\\n            \\n        return -1"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Solved with greedy approach, \\nbut i believe it can be solved using dfs or topdown approach can someone give me sample code? \\n\\ngot TLE when tried apply dfs or topdown "
                    },
                    {
                        "username": "mayankK135",
                        "content": "The question is not so obvious like you can figure out it\\'s a greed problem but actual solution is quite simple but hard to figure out. So here is an explanation to get the solution -\\n1. check whether or not the sum of gas is greater than sum of cost . if not return -1 as no solution can exist . Else a solution will definitely exist and its given that the solution is unique. \\n2. to find the solution use greedy approach use a variable total_sum and keep on adding the difference of gas[i]-cost[i] to it if the total_sum <0 than reset it to 0 and set the answer to i+1;\\n\\n"
                    },
                    {
                        "username": "omaramin622",
                        "content": "when the number of stations is one. you still should check if (gas[0] >= cost[0]).\\n\\nI just felt the answer is always 0 when number of stations is one, but this is not correct and may anyone will think like me. you have to check."
                    },
                    {
                        "username": "jaishankar101",
                        "content": "substract gas[i] with cost[i] and store it in an array;\\nnow find the index to start the addition such that the result is >=0 and return that index. \\n( ps : add the elements of the array if they are negative then no solution exists)"
                    },
                    {
                        "username": "khannaabhishek1010",
                        "content": "I am solving leetcode for last 2 months still I dont solve any question on my own. Only 10% I am able to solve it by own. Why it do so??"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@khannaabhishek1010](/khannaabhishek1010)  All the best bro"
                    },
                    {
                        "username": "khannaabhishek1010",
                        "content": "[@S_Basu](/S_Basu) Thanks bro I am really looking forward for this"
                    },
                    {
                        "username": "S_Basu",
                        "content": "I guess it is OK to take time, as long as you are constantly trying to understand and consistently putting in efforts. Gradually you will become really good like a PRO. \\nSlow & Steady wins the race.\\n\\nIt is OK to see solutions but try to understand the approaches and try on your own first.\\nBest wishes. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "six519",
                        "content": "Found a solution on my own but got a time limit exceeded error. :D Answered the problem by reading other solutions. I\\'m not be able to solve the problem if no posted solutions available.  LOL!!"
                    }
                ]
            },
            {
                "id": 1745707,
                "content": [
                    {
                        "username": "UltimateMeta",
                        "content": "The wording of the question is slightly wrong. In this line, `You have a car with an unlimited gas tank and it costs cost[i] of gas to travel`, it should be  `it costs cost[i] units of gas to travel` because cost means in terms of money. So, if there were no test cases given, it is not possible to solve this if we don\\'t assume that it does not mean money when is says `cost` but that it means `units`. This felt confusing to me until I saw/analyzed the test cases given."
                    },
                    {
                        "username": "Msey",
                        "content": "Ancient problem as we see"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                           \\n                  class Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        start, n, s = 0, len(gas), 0\\n\\n        for i in range(2 * n):\\n            s += gas[i % n] - cost[i % n]\\n\\n            if s < 0: s, start = 0, i + 1\\n            if i >= start + n: return start\\n        return -1\\n\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        if sum(gas) < sum(cost): \\n            return -1\\n        n, start, res = len(gas), 0, 0\\n        for i in range(n):\\n            res += gas[i] - cost[i]\\n            if res < 0:\\n                start, res = i+1, 0\\n        return start"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                   \\n\\n              class Solution:\\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\\n        start, n, s = 0, len(gas), 0\\n\\n        for i in range(2 * n):\\n            s += gas[i % n] - cost[i % n]\\n\\n            if s < 0: s, start = 0, i + 1\\n            if i >= start + n: return start\\n            \\n        return -1"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Solved with greedy approach, \\nbut i believe it can be solved using dfs or topdown approach can someone give me sample code? \\n\\ngot TLE when tried apply dfs or topdown "
                    },
                    {
                        "username": "mayankK135",
                        "content": "The question is not so obvious like you can figure out it\\'s a greed problem but actual solution is quite simple but hard to figure out. So here is an explanation to get the solution -\\n1. check whether or not the sum of gas is greater than sum of cost . if not return -1 as no solution can exist . Else a solution will definitely exist and its given that the solution is unique. \\n2. to find the solution use greedy approach use a variable total_sum and keep on adding the difference of gas[i]-cost[i] to it if the total_sum <0 than reset it to 0 and set the answer to i+1;\\n\\n"
                    },
                    {
                        "username": "omaramin622",
                        "content": "when the number of stations is one. you still should check if (gas[0] >= cost[0]).\\n\\nI just felt the answer is always 0 when number of stations is one, but this is not correct and may anyone will think like me. you have to check."
                    },
                    {
                        "username": "jaishankar101",
                        "content": "substract gas[i] with cost[i] and store it in an array;\\nnow find the index to start the addition such that the result is >=0 and return that index. \\n( ps : add the elements of the array if they are negative then no solution exists)"
                    },
                    {
                        "username": "khannaabhishek1010",
                        "content": "I am solving leetcode for last 2 months still I dont solve any question on my own. Only 10% I am able to solve it by own. Why it do so??"
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@khannaabhishek1010](/khannaabhishek1010)  All the best bro"
                    },
                    {
                        "username": "khannaabhishek1010",
                        "content": "[@S_Basu](/S_Basu) Thanks bro I am really looking forward for this"
                    },
                    {
                        "username": "S_Basu",
                        "content": "I guess it is OK to take time, as long as you are constantly trying to understand and consistently putting in efforts. Gradually you will become really good like a PRO. \\nSlow & Steady wins the race.\\n\\nIt is OK to see solutions but try to understand the approaches and try on your own first.\\nBest wishes. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "six519",
                        "content": "Found a solution on my own but got a time limit exceeded error. :D Answered the problem by reading other solutions. I\\'m not be able to solve the problem if no posted solutions available.  LOL!!"
                    }
                ]
            },
            {
                "id": 1745694,
                "content": [
                    {
                        "username": "iaarzoo40",
                        "content": "Using C++  ||  Easy and Clean Code\\n\\n***Code***\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        int total_gas=0,total_cost=0;\\n        int curr_gas=0, starting_point=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            //these two variable are to check if no case is possible\\n            total_gas+=gas[i];\\n            total_cost+=cost[i];\\n            //for checking the total present gas at index i\\n            curr_gas+=gas[i]-cost[i];\\n            if(curr_gas<0)\\n            {\\n               //there is a breakdown....so we will start from next point or index\\n                starting_point=i+1;\\n                //reset our fuel \\n                curr_gas=0;\\n            }\\n        }\\n        return (total_gas<total_cost)?-1:starting_point;     \\n    }\\n};\\n```"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "The Algorithm for the code is definitely easy but intuition is really challenging\\n"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Agree...When you see the solution it seems so easy. At each index x that you fail to reach you have already verified that you can go from 0-x so you do not need to do it again. But in an interview I dont think you can think of this unless you have see it before. "
                    },
                    {
                        "username": "iamsanko",
                        "content": "the O(N) time and O(1) space is correct"
                    },
                    {
                        "username": "richyan",
                        "content": "a simple solution in javascript - O(n)\n\nvar canCompleteCircuit = function(gas, cost) {\n\n    let start = 0, total = 0, sum = 0;\n    for (let i = 0; i < gas.length; i++) {\n        gas[i] -= cost[i];\n        total += gas[i];\n        sum += gas[i]\n        if (sum < 0) {\n            sum = 0;\n            start = i + 1;\n        }\n    }\n    if (total < 0) return -1;\n    return start;\n};"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Another good question Array maunpulation\\nHint: Calculate difference of gases and cost at each index and manupulate your start index"
                    },
                    {
                        "username": "BristolJ",
                        "content": "What?!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: circular array "
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int current = 0;\\n        int total_fuel = 0, total_cost = 0;\\n        int start = 0;\\n        for(int i=0; i<gas.size(); i++) {\\n            total_fuel += gas[i];\\n        }\\n\\n        for(int i=0; i<gas.size(); i++) {\\n            total_cost += cost[i];\\n        }\\n        if(total_fuel < total_cost){\\n            return -1;\\n        }\\n        for(int i=0; i<gas.size(); i++) {\\n            current += (gas[i] - cost[i]);\\n            if(current < 0){\\n                start = i + 1;\\n                current = 0;\\n            }\\n        }\\n        return start;\\n    }\\n}; @"
                    },
                    {
                        "username": "Satyam_456",
                        "content": "Problem---> Showing Time Limit Exceeded Error for 3 test cases \\nCode-->\\npublic int canCompleteCircuit(int[] gas, int[] cost) {\\n        int i = 0;\\n\\t\\twhile (i < gas.length) {\\n\\t\\t\\tif (gas[i] >= cost[i]) {\\n\\t\\t\\t\\tint curr_gas = 0;\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tint st = -1;\\n\\n\\t\\t\\t\\tfor (int idx = i; idx < i + gas.length; idx++) {\\n\\t\\t\\t\\t\\tint idx1 = idx % gas.length;\\n\\t\\t\\t\\t\\tif (idx1 == i) {\\n\\t\\t\\t\\t\\t\\tst = idx1;\\n\\t\\t\\t\\t\\t\\tcurr_gas = gas[idx1] - cost[idx1];\\n\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcurr_gas = curr_gas - cost[idx1];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (curr_gas < 0) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcurr_gas = curr_gas + gas[(idx1 + 1) % gas.length];\\n\\t\\t\\t\\t\\tcount++;\\n//\\t\\t\\t\\t\\tSystem.out.println(curr_gas);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (count == gas.length) {\\n\\t\\t\\t\\t\\treturn st;\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n}"
                    },
                    {
                        "username": "Saurabhmehtaleetcode",
                        "content": "I am not seeing many people sharing solutions in the discussion section after the UI change . It was great to see people coming up with good and concise solutions with their explanations .   "
                    }
                ]
            },
            {
                "id": 1745666,
                "content": [
                    {
                        "username": "iaarzoo40",
                        "content": "Using C++  ||  Easy and Clean Code\\n\\n***Code***\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        int total_gas=0,total_cost=0;\\n        int curr_gas=0, starting_point=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            //these two variable are to check if no case is possible\\n            total_gas+=gas[i];\\n            total_cost+=cost[i];\\n            //for checking the total present gas at index i\\n            curr_gas+=gas[i]-cost[i];\\n            if(curr_gas<0)\\n            {\\n               //there is a breakdown....so we will start from next point or index\\n                starting_point=i+1;\\n                //reset our fuel \\n                curr_gas=0;\\n            }\\n        }\\n        return (total_gas<total_cost)?-1:starting_point;     \\n    }\\n};\\n```"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "The Algorithm for the code is definitely easy but intuition is really challenging\\n"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Agree...When you see the solution it seems so easy. At each index x that you fail to reach you have already verified that you can go from 0-x so you do not need to do it again. But in an interview I dont think you can think of this unless you have see it before. "
                    },
                    {
                        "username": "iamsanko",
                        "content": "the O(N) time and O(1) space is correct"
                    },
                    {
                        "username": "richyan",
                        "content": "a simple solution in javascript - O(n)\n\nvar canCompleteCircuit = function(gas, cost) {\n\n    let start = 0, total = 0, sum = 0;\n    for (let i = 0; i < gas.length; i++) {\n        gas[i] -= cost[i];\n        total += gas[i];\n        sum += gas[i]\n        if (sum < 0) {\n            sum = 0;\n            start = i + 1;\n        }\n    }\n    if (total < 0) return -1;\n    return start;\n};"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Another good question Array maunpulation\\nHint: Calculate difference of gases and cost at each index and manupulate your start index"
                    },
                    {
                        "username": "BristolJ",
                        "content": "What?!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: circular array "
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int current = 0;\\n        int total_fuel = 0, total_cost = 0;\\n        int start = 0;\\n        for(int i=0; i<gas.size(); i++) {\\n            total_fuel += gas[i];\\n        }\\n\\n        for(int i=0; i<gas.size(); i++) {\\n            total_cost += cost[i];\\n        }\\n        if(total_fuel < total_cost){\\n            return -1;\\n        }\\n        for(int i=0; i<gas.size(); i++) {\\n            current += (gas[i] - cost[i]);\\n            if(current < 0){\\n                start = i + 1;\\n                current = 0;\\n            }\\n        }\\n        return start;\\n    }\\n}; @"
                    },
                    {
                        "username": "Satyam_456",
                        "content": "Problem---> Showing Time Limit Exceeded Error for 3 test cases \\nCode-->\\npublic int canCompleteCircuit(int[] gas, int[] cost) {\\n        int i = 0;\\n\\t\\twhile (i < gas.length) {\\n\\t\\t\\tif (gas[i] >= cost[i]) {\\n\\t\\t\\t\\tint curr_gas = 0;\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tint st = -1;\\n\\n\\t\\t\\t\\tfor (int idx = i; idx < i + gas.length; idx++) {\\n\\t\\t\\t\\t\\tint idx1 = idx % gas.length;\\n\\t\\t\\t\\t\\tif (idx1 == i) {\\n\\t\\t\\t\\t\\t\\tst = idx1;\\n\\t\\t\\t\\t\\t\\tcurr_gas = gas[idx1] - cost[idx1];\\n\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcurr_gas = curr_gas - cost[idx1];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (curr_gas < 0) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcurr_gas = curr_gas + gas[(idx1 + 1) % gas.length];\\n\\t\\t\\t\\t\\tcount++;\\n//\\t\\t\\t\\t\\tSystem.out.println(curr_gas);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (count == gas.length) {\\n\\t\\t\\t\\t\\treturn st;\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n}"
                    },
                    {
                        "username": "Saurabhmehtaleetcode",
                        "content": "I am not seeing many people sharing solutions in the discussion section after the UI change . It was great to see people coming up with good and concise solutions with their explanations .   "
                    }
                ]
            },
            {
                "id": 1745647,
                "content": [
                    {
                        "username": "iaarzoo40",
                        "content": "Using C++  ||  Easy and Clean Code\\n\\n***Code***\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        int total_gas=0,total_cost=0;\\n        int curr_gas=0, starting_point=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            //these two variable are to check if no case is possible\\n            total_gas+=gas[i];\\n            total_cost+=cost[i];\\n            //for checking the total present gas at index i\\n            curr_gas+=gas[i]-cost[i];\\n            if(curr_gas<0)\\n            {\\n               //there is a breakdown....so we will start from next point or index\\n                starting_point=i+1;\\n                //reset our fuel \\n                curr_gas=0;\\n            }\\n        }\\n        return (total_gas<total_cost)?-1:starting_point;     \\n    }\\n};\\n```"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "The Algorithm for the code is definitely easy but intuition is really challenging\\n"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Agree...When you see the solution it seems so easy. At each index x that you fail to reach you have already verified that you can go from 0-x so you do not need to do it again. But in an interview I dont think you can think of this unless you have see it before. "
                    },
                    {
                        "username": "iamsanko",
                        "content": "the O(N) time and O(1) space is correct"
                    },
                    {
                        "username": "richyan",
                        "content": "a simple solution in javascript - O(n)\n\nvar canCompleteCircuit = function(gas, cost) {\n\n    let start = 0, total = 0, sum = 0;\n    for (let i = 0; i < gas.length; i++) {\n        gas[i] -= cost[i];\n        total += gas[i];\n        sum += gas[i]\n        if (sum < 0) {\n            sum = 0;\n            start = i + 1;\n        }\n    }\n    if (total < 0) return -1;\n    return start;\n};"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Another good question Array maunpulation\\nHint: Calculate difference of gases and cost at each index and manupulate your start index"
                    },
                    {
                        "username": "BristolJ",
                        "content": "What?!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: circular array "
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int current = 0;\\n        int total_fuel = 0, total_cost = 0;\\n        int start = 0;\\n        for(int i=0; i<gas.size(); i++) {\\n            total_fuel += gas[i];\\n        }\\n\\n        for(int i=0; i<gas.size(); i++) {\\n            total_cost += cost[i];\\n        }\\n        if(total_fuel < total_cost){\\n            return -1;\\n        }\\n        for(int i=0; i<gas.size(); i++) {\\n            current += (gas[i] - cost[i]);\\n            if(current < 0){\\n                start = i + 1;\\n                current = 0;\\n            }\\n        }\\n        return start;\\n    }\\n}; @"
                    },
                    {
                        "username": "Satyam_456",
                        "content": "Problem---> Showing Time Limit Exceeded Error for 3 test cases \\nCode-->\\npublic int canCompleteCircuit(int[] gas, int[] cost) {\\n        int i = 0;\\n\\t\\twhile (i < gas.length) {\\n\\t\\t\\tif (gas[i] >= cost[i]) {\\n\\t\\t\\t\\tint curr_gas = 0;\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tint st = -1;\\n\\n\\t\\t\\t\\tfor (int idx = i; idx < i + gas.length; idx++) {\\n\\t\\t\\t\\t\\tint idx1 = idx % gas.length;\\n\\t\\t\\t\\t\\tif (idx1 == i) {\\n\\t\\t\\t\\t\\t\\tst = idx1;\\n\\t\\t\\t\\t\\t\\tcurr_gas = gas[idx1] - cost[idx1];\\n\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcurr_gas = curr_gas - cost[idx1];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (curr_gas < 0) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcurr_gas = curr_gas + gas[(idx1 + 1) % gas.length];\\n\\t\\t\\t\\t\\tcount++;\\n//\\t\\t\\t\\t\\tSystem.out.println(curr_gas);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (count == gas.length) {\\n\\t\\t\\t\\t\\treturn st;\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n}"
                    },
                    {
                        "username": "Saurabhmehtaleetcode",
                        "content": "I am not seeing many people sharing solutions in the discussion section after the UI change . It was great to see people coming up with good and concise solutions with their explanations .   "
                    }
                ]
            },
            {
                "id": 1745642,
                "content": [
                    {
                        "username": "iaarzoo40",
                        "content": "Using C++  ||  Easy and Clean Code\\n\\n***Code***\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        int total_gas=0,total_cost=0;\\n        int curr_gas=0, starting_point=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            //these two variable are to check if no case is possible\\n            total_gas+=gas[i];\\n            total_cost+=cost[i];\\n            //for checking the total present gas at index i\\n            curr_gas+=gas[i]-cost[i];\\n            if(curr_gas<0)\\n            {\\n               //there is a breakdown....so we will start from next point or index\\n                starting_point=i+1;\\n                //reset our fuel \\n                curr_gas=0;\\n            }\\n        }\\n        return (total_gas<total_cost)?-1:starting_point;     \\n    }\\n};\\n```"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "The Algorithm for the code is definitely easy but intuition is really challenging\\n"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Agree...When you see the solution it seems so easy. At each index x that you fail to reach you have already verified that you can go from 0-x so you do not need to do it again. But in an interview I dont think you can think of this unless you have see it before. "
                    },
                    {
                        "username": "iamsanko",
                        "content": "the O(N) time and O(1) space is correct"
                    },
                    {
                        "username": "richyan",
                        "content": "a simple solution in javascript - O(n)\n\nvar canCompleteCircuit = function(gas, cost) {\n\n    let start = 0, total = 0, sum = 0;\n    for (let i = 0; i < gas.length; i++) {\n        gas[i] -= cost[i];\n        total += gas[i];\n        sum += gas[i]\n        if (sum < 0) {\n            sum = 0;\n            start = i + 1;\n        }\n    }\n    if (total < 0) return -1;\n    return start;\n};"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Another good question Array maunpulation\\nHint: Calculate difference of gases and cost at each index and manupulate your start index"
                    },
                    {
                        "username": "BristolJ",
                        "content": "What?!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: circular array "
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int current = 0;\\n        int total_fuel = 0, total_cost = 0;\\n        int start = 0;\\n        for(int i=0; i<gas.size(); i++) {\\n            total_fuel += gas[i];\\n        }\\n\\n        for(int i=0; i<gas.size(); i++) {\\n            total_cost += cost[i];\\n        }\\n        if(total_fuel < total_cost){\\n            return -1;\\n        }\\n        for(int i=0; i<gas.size(); i++) {\\n            current += (gas[i] - cost[i]);\\n            if(current < 0){\\n                start = i + 1;\\n                current = 0;\\n            }\\n        }\\n        return start;\\n    }\\n}; @"
                    },
                    {
                        "username": "Satyam_456",
                        "content": "Problem---> Showing Time Limit Exceeded Error for 3 test cases \\nCode-->\\npublic int canCompleteCircuit(int[] gas, int[] cost) {\\n        int i = 0;\\n\\t\\twhile (i < gas.length) {\\n\\t\\t\\tif (gas[i] >= cost[i]) {\\n\\t\\t\\t\\tint curr_gas = 0;\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tint st = -1;\\n\\n\\t\\t\\t\\tfor (int idx = i; idx < i + gas.length; idx++) {\\n\\t\\t\\t\\t\\tint idx1 = idx % gas.length;\\n\\t\\t\\t\\t\\tif (idx1 == i) {\\n\\t\\t\\t\\t\\t\\tst = idx1;\\n\\t\\t\\t\\t\\t\\tcurr_gas = gas[idx1] - cost[idx1];\\n\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcurr_gas = curr_gas - cost[idx1];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (curr_gas < 0) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcurr_gas = curr_gas + gas[(idx1 + 1) % gas.length];\\n\\t\\t\\t\\t\\tcount++;\\n//\\t\\t\\t\\t\\tSystem.out.println(curr_gas);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (count == gas.length) {\\n\\t\\t\\t\\t\\treturn st;\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n}"
                    },
                    {
                        "username": "Saurabhmehtaleetcode",
                        "content": "I am not seeing many people sharing solutions in the discussion section after the UI change . It was great to see people coming up with good and concise solutions with their explanations .   "
                    }
                ]
            },
            {
                "id": 1745632,
                "content": [
                    {
                        "username": "iaarzoo40",
                        "content": "Using C++  ||  Easy and Clean Code\\n\\n***Code***\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        int total_gas=0,total_cost=0;\\n        int curr_gas=0, starting_point=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            //these two variable are to check if no case is possible\\n            total_gas+=gas[i];\\n            total_cost+=cost[i];\\n            //for checking the total present gas at index i\\n            curr_gas+=gas[i]-cost[i];\\n            if(curr_gas<0)\\n            {\\n               //there is a breakdown....so we will start from next point or index\\n                starting_point=i+1;\\n                //reset our fuel \\n                curr_gas=0;\\n            }\\n        }\\n        return (total_gas<total_cost)?-1:starting_point;     \\n    }\\n};\\n```"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "The Algorithm for the code is definitely easy but intuition is really challenging\\n"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Agree...When you see the solution it seems so easy. At each index x that you fail to reach you have already verified that you can go from 0-x so you do not need to do it again. But in an interview I dont think you can think of this unless you have see it before. "
                    },
                    {
                        "username": "iamsanko",
                        "content": "the O(N) time and O(1) space is correct"
                    },
                    {
                        "username": "richyan",
                        "content": "a simple solution in javascript - O(n)\n\nvar canCompleteCircuit = function(gas, cost) {\n\n    let start = 0, total = 0, sum = 0;\n    for (let i = 0; i < gas.length; i++) {\n        gas[i] -= cost[i];\n        total += gas[i];\n        sum += gas[i]\n        if (sum < 0) {\n            sum = 0;\n            start = i + 1;\n        }\n    }\n    if (total < 0) return -1;\n    return start;\n};"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Another good question Array maunpulation\\nHint: Calculate difference of gases and cost at each index and manupulate your start index"
                    },
                    {
                        "username": "BristolJ",
                        "content": "What?!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: circular array "
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int current = 0;\\n        int total_fuel = 0, total_cost = 0;\\n        int start = 0;\\n        for(int i=0; i<gas.size(); i++) {\\n            total_fuel += gas[i];\\n        }\\n\\n        for(int i=0; i<gas.size(); i++) {\\n            total_cost += cost[i];\\n        }\\n        if(total_fuel < total_cost){\\n            return -1;\\n        }\\n        for(int i=0; i<gas.size(); i++) {\\n            current += (gas[i] - cost[i]);\\n            if(current < 0){\\n                start = i + 1;\\n                current = 0;\\n            }\\n        }\\n        return start;\\n    }\\n}; @"
                    },
                    {
                        "username": "Satyam_456",
                        "content": "Problem---> Showing Time Limit Exceeded Error for 3 test cases \\nCode-->\\npublic int canCompleteCircuit(int[] gas, int[] cost) {\\n        int i = 0;\\n\\t\\twhile (i < gas.length) {\\n\\t\\t\\tif (gas[i] >= cost[i]) {\\n\\t\\t\\t\\tint curr_gas = 0;\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tint st = -1;\\n\\n\\t\\t\\t\\tfor (int idx = i; idx < i + gas.length; idx++) {\\n\\t\\t\\t\\t\\tint idx1 = idx % gas.length;\\n\\t\\t\\t\\t\\tif (idx1 == i) {\\n\\t\\t\\t\\t\\t\\tst = idx1;\\n\\t\\t\\t\\t\\t\\tcurr_gas = gas[idx1] - cost[idx1];\\n\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcurr_gas = curr_gas - cost[idx1];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (curr_gas < 0) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcurr_gas = curr_gas + gas[(idx1 + 1) % gas.length];\\n\\t\\t\\t\\t\\tcount++;\\n//\\t\\t\\t\\t\\tSystem.out.println(curr_gas);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (count == gas.length) {\\n\\t\\t\\t\\t\\treturn st;\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n}"
                    },
                    {
                        "username": "Saurabhmehtaleetcode",
                        "content": "I am not seeing many people sharing solutions in the discussion section after the UI change . It was great to see people coming up with good and concise solutions with their explanations .   "
                    }
                ]
            },
            {
                "id": 1745567,
                "content": [
                    {
                        "username": "iaarzoo40",
                        "content": "Using C++  ||  Easy and Clean Code\\n\\n***Code***\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        int total_gas=0,total_cost=0;\\n        int curr_gas=0, starting_point=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            //these two variable are to check if no case is possible\\n            total_gas+=gas[i];\\n            total_cost+=cost[i];\\n            //for checking the total present gas at index i\\n            curr_gas+=gas[i]-cost[i];\\n            if(curr_gas<0)\\n            {\\n               //there is a breakdown....so we will start from next point or index\\n                starting_point=i+1;\\n                //reset our fuel \\n                curr_gas=0;\\n            }\\n        }\\n        return (total_gas<total_cost)?-1:starting_point;     \\n    }\\n};\\n```"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "The Algorithm for the code is definitely easy but intuition is really challenging\\n"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Agree...When you see the solution it seems so easy. At each index x that you fail to reach you have already verified that you can go from 0-x so you do not need to do it again. But in an interview I dont think you can think of this unless you have see it before. "
                    },
                    {
                        "username": "iamsanko",
                        "content": "the O(N) time and O(1) space is correct"
                    },
                    {
                        "username": "richyan",
                        "content": "a simple solution in javascript - O(n)\n\nvar canCompleteCircuit = function(gas, cost) {\n\n    let start = 0, total = 0, sum = 0;\n    for (let i = 0; i < gas.length; i++) {\n        gas[i] -= cost[i];\n        total += gas[i];\n        sum += gas[i]\n        if (sum < 0) {\n            sum = 0;\n            start = i + 1;\n        }\n    }\n    if (total < 0) return -1;\n    return start;\n};"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Another good question Array maunpulation\\nHint: Calculate difference of gases and cost at each index and manupulate your start index"
                    },
                    {
                        "username": "BristolJ",
                        "content": "What?!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: circular array "
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int current = 0;\\n        int total_fuel = 0, total_cost = 0;\\n        int start = 0;\\n        for(int i=0; i<gas.size(); i++) {\\n            total_fuel += gas[i];\\n        }\\n\\n        for(int i=0; i<gas.size(); i++) {\\n            total_cost += cost[i];\\n        }\\n        if(total_fuel < total_cost){\\n            return -1;\\n        }\\n        for(int i=0; i<gas.size(); i++) {\\n            current += (gas[i] - cost[i]);\\n            if(current < 0){\\n                start = i + 1;\\n                current = 0;\\n            }\\n        }\\n        return start;\\n    }\\n}; @"
                    },
                    {
                        "username": "Satyam_456",
                        "content": "Problem---> Showing Time Limit Exceeded Error for 3 test cases \\nCode-->\\npublic int canCompleteCircuit(int[] gas, int[] cost) {\\n        int i = 0;\\n\\t\\twhile (i < gas.length) {\\n\\t\\t\\tif (gas[i] >= cost[i]) {\\n\\t\\t\\t\\tint curr_gas = 0;\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tint st = -1;\\n\\n\\t\\t\\t\\tfor (int idx = i; idx < i + gas.length; idx++) {\\n\\t\\t\\t\\t\\tint idx1 = idx % gas.length;\\n\\t\\t\\t\\t\\tif (idx1 == i) {\\n\\t\\t\\t\\t\\t\\tst = idx1;\\n\\t\\t\\t\\t\\t\\tcurr_gas = gas[idx1] - cost[idx1];\\n\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcurr_gas = curr_gas - cost[idx1];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (curr_gas < 0) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcurr_gas = curr_gas + gas[(idx1 + 1) % gas.length];\\n\\t\\t\\t\\t\\tcount++;\\n//\\t\\t\\t\\t\\tSystem.out.println(curr_gas);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (count == gas.length) {\\n\\t\\t\\t\\t\\treturn st;\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n}"
                    },
                    {
                        "username": "Saurabhmehtaleetcode",
                        "content": "I am not seeing many people sharing solutions in the discussion section after the UI change . It was great to see people coming up with good and concise solutions with their explanations .   "
                    }
                ]
            },
            {
                "id": 1745518,
                "content": [
                    {
                        "username": "iaarzoo40",
                        "content": "Using C++  ||  Easy and Clean Code\\n\\n***Code***\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        int total_gas=0,total_cost=0;\\n        int curr_gas=0, starting_point=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            //these two variable are to check if no case is possible\\n            total_gas+=gas[i];\\n            total_cost+=cost[i];\\n            //for checking the total present gas at index i\\n            curr_gas+=gas[i]-cost[i];\\n            if(curr_gas<0)\\n            {\\n               //there is a breakdown....so we will start from next point or index\\n                starting_point=i+1;\\n                //reset our fuel \\n                curr_gas=0;\\n            }\\n        }\\n        return (total_gas<total_cost)?-1:starting_point;     \\n    }\\n};\\n```"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "The Algorithm for the code is definitely easy but intuition is really challenging\\n"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Agree...When you see the solution it seems so easy. At each index x that you fail to reach you have already verified that you can go from 0-x so you do not need to do it again. But in an interview I dont think you can think of this unless you have see it before. "
                    },
                    {
                        "username": "iamsanko",
                        "content": "the O(N) time and O(1) space is correct"
                    },
                    {
                        "username": "richyan",
                        "content": "a simple solution in javascript - O(n)\n\nvar canCompleteCircuit = function(gas, cost) {\n\n    let start = 0, total = 0, sum = 0;\n    for (let i = 0; i < gas.length; i++) {\n        gas[i] -= cost[i];\n        total += gas[i];\n        sum += gas[i]\n        if (sum < 0) {\n            sum = 0;\n            start = i + 1;\n        }\n    }\n    if (total < 0) return -1;\n    return start;\n};"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Another good question Array maunpulation\\nHint: Calculate difference of gases and cost at each index and manupulate your start index"
                    },
                    {
                        "username": "BristolJ",
                        "content": "What?!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: circular array "
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int current = 0;\\n        int total_fuel = 0, total_cost = 0;\\n        int start = 0;\\n        for(int i=0; i<gas.size(); i++) {\\n            total_fuel += gas[i];\\n        }\\n\\n        for(int i=0; i<gas.size(); i++) {\\n            total_cost += cost[i];\\n        }\\n        if(total_fuel < total_cost){\\n            return -1;\\n        }\\n        for(int i=0; i<gas.size(); i++) {\\n            current += (gas[i] - cost[i]);\\n            if(current < 0){\\n                start = i + 1;\\n                current = 0;\\n            }\\n        }\\n        return start;\\n    }\\n}; @"
                    },
                    {
                        "username": "Satyam_456",
                        "content": "Problem---> Showing Time Limit Exceeded Error for 3 test cases \\nCode-->\\npublic int canCompleteCircuit(int[] gas, int[] cost) {\\n        int i = 0;\\n\\t\\twhile (i < gas.length) {\\n\\t\\t\\tif (gas[i] >= cost[i]) {\\n\\t\\t\\t\\tint curr_gas = 0;\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tint st = -1;\\n\\n\\t\\t\\t\\tfor (int idx = i; idx < i + gas.length; idx++) {\\n\\t\\t\\t\\t\\tint idx1 = idx % gas.length;\\n\\t\\t\\t\\t\\tif (idx1 == i) {\\n\\t\\t\\t\\t\\t\\tst = idx1;\\n\\t\\t\\t\\t\\t\\tcurr_gas = gas[idx1] - cost[idx1];\\n\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcurr_gas = curr_gas - cost[idx1];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (curr_gas < 0) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcurr_gas = curr_gas + gas[(idx1 + 1) % gas.length];\\n\\t\\t\\t\\t\\tcount++;\\n//\\t\\t\\t\\t\\tSystem.out.println(curr_gas);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (count == gas.length) {\\n\\t\\t\\t\\t\\treturn st;\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n}"
                    },
                    {
                        "username": "Saurabhmehtaleetcode",
                        "content": "I am not seeing many people sharing solutions in the discussion section after the UI change . It was great to see people coming up with good and concise solutions with their explanations .   "
                    }
                ]
            },
            {
                "id": 1724300,
                "content": [
                    {
                        "username": "iaarzoo40",
                        "content": "Using C++  ||  Easy and Clean Code\\n\\n***Code***\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        int total_gas=0,total_cost=0;\\n        int curr_gas=0, starting_point=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            //these two variable are to check if no case is possible\\n            total_gas+=gas[i];\\n            total_cost+=cost[i];\\n            //for checking the total present gas at index i\\n            curr_gas+=gas[i]-cost[i];\\n            if(curr_gas<0)\\n            {\\n               //there is a breakdown....so we will start from next point or index\\n                starting_point=i+1;\\n                //reset our fuel \\n                curr_gas=0;\\n            }\\n        }\\n        return (total_gas<total_cost)?-1:starting_point;     \\n    }\\n};\\n```"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "The Algorithm for the code is definitely easy but intuition is really challenging\\n"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Agree...When you see the solution it seems so easy. At each index x that you fail to reach you have already verified that you can go from 0-x so you do not need to do it again. But in an interview I dont think you can think of this unless you have see it before. "
                    },
                    {
                        "username": "iamsanko",
                        "content": "the O(N) time and O(1) space is correct"
                    },
                    {
                        "username": "richyan",
                        "content": "a simple solution in javascript - O(n)\n\nvar canCompleteCircuit = function(gas, cost) {\n\n    let start = 0, total = 0, sum = 0;\n    for (let i = 0; i < gas.length; i++) {\n        gas[i] -= cost[i];\n        total += gas[i];\n        sum += gas[i]\n        if (sum < 0) {\n            sum = 0;\n            start = i + 1;\n        }\n    }\n    if (total < 0) return -1;\n    return start;\n};"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Another good question Array maunpulation\\nHint: Calculate difference of gases and cost at each index and manupulate your start index"
                    },
                    {
                        "username": "BristolJ",
                        "content": "What?!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: circular array "
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int current = 0;\\n        int total_fuel = 0, total_cost = 0;\\n        int start = 0;\\n        for(int i=0; i<gas.size(); i++) {\\n            total_fuel += gas[i];\\n        }\\n\\n        for(int i=0; i<gas.size(); i++) {\\n            total_cost += cost[i];\\n        }\\n        if(total_fuel < total_cost){\\n            return -1;\\n        }\\n        for(int i=0; i<gas.size(); i++) {\\n            current += (gas[i] - cost[i]);\\n            if(current < 0){\\n                start = i + 1;\\n                current = 0;\\n            }\\n        }\\n        return start;\\n    }\\n}; @"
                    },
                    {
                        "username": "Satyam_456",
                        "content": "Problem---> Showing Time Limit Exceeded Error for 3 test cases \\nCode-->\\npublic int canCompleteCircuit(int[] gas, int[] cost) {\\n        int i = 0;\\n\\t\\twhile (i < gas.length) {\\n\\t\\t\\tif (gas[i] >= cost[i]) {\\n\\t\\t\\t\\tint curr_gas = 0;\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tint st = -1;\\n\\n\\t\\t\\t\\tfor (int idx = i; idx < i + gas.length; idx++) {\\n\\t\\t\\t\\t\\tint idx1 = idx % gas.length;\\n\\t\\t\\t\\t\\tif (idx1 == i) {\\n\\t\\t\\t\\t\\t\\tst = idx1;\\n\\t\\t\\t\\t\\t\\tcurr_gas = gas[idx1] - cost[idx1];\\n\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcurr_gas = curr_gas - cost[idx1];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (curr_gas < 0) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcurr_gas = curr_gas + gas[(idx1 + 1) % gas.length];\\n\\t\\t\\t\\t\\tcount++;\\n//\\t\\t\\t\\t\\tSystem.out.println(curr_gas);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (count == gas.length) {\\n\\t\\t\\t\\t\\treturn st;\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n}"
                    },
                    {
                        "username": "Saurabhmehtaleetcode",
                        "content": "I am not seeing many people sharing solutions in the discussion section after the UI change . It was great to see people coming up with good and concise solutions with their explanations .   "
                    }
                ]
            },
            {
                "id": 1720926,
                "content": [
                    {
                        "username": "iaarzoo40",
                        "content": "Using C++  ||  Easy and Clean Code\\n\\n***Code***\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        int total_gas=0,total_cost=0;\\n        int curr_gas=0, starting_point=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            //these two variable are to check if no case is possible\\n            total_gas+=gas[i];\\n            total_cost+=cost[i];\\n            //for checking the total present gas at index i\\n            curr_gas+=gas[i]-cost[i];\\n            if(curr_gas<0)\\n            {\\n               //there is a breakdown....so we will start from next point or index\\n                starting_point=i+1;\\n                //reset our fuel \\n                curr_gas=0;\\n            }\\n        }\\n        return (total_gas<total_cost)?-1:starting_point;     \\n    }\\n};\\n```"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "The Algorithm for the code is definitely easy but intuition is really challenging\\n"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Agree...When you see the solution it seems so easy. At each index x that you fail to reach you have already verified that you can go from 0-x so you do not need to do it again. But in an interview I dont think you can think of this unless you have see it before. "
                    },
                    {
                        "username": "iamsanko",
                        "content": "the O(N) time and O(1) space is correct"
                    },
                    {
                        "username": "richyan",
                        "content": "a simple solution in javascript - O(n)\n\nvar canCompleteCircuit = function(gas, cost) {\n\n    let start = 0, total = 0, sum = 0;\n    for (let i = 0; i < gas.length; i++) {\n        gas[i] -= cost[i];\n        total += gas[i];\n        sum += gas[i]\n        if (sum < 0) {\n            sum = 0;\n            start = i + 1;\n        }\n    }\n    if (total < 0) return -1;\n    return start;\n};"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Another good question Array maunpulation\\nHint: Calculate difference of gases and cost at each index and manupulate your start index"
                    },
                    {
                        "username": "BristolJ",
                        "content": "What?!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: circular array "
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int current = 0;\\n        int total_fuel = 0, total_cost = 0;\\n        int start = 0;\\n        for(int i=0; i<gas.size(); i++) {\\n            total_fuel += gas[i];\\n        }\\n\\n        for(int i=0; i<gas.size(); i++) {\\n            total_cost += cost[i];\\n        }\\n        if(total_fuel < total_cost){\\n            return -1;\\n        }\\n        for(int i=0; i<gas.size(); i++) {\\n            current += (gas[i] - cost[i]);\\n            if(current < 0){\\n                start = i + 1;\\n                current = 0;\\n            }\\n        }\\n        return start;\\n    }\\n}; @"
                    },
                    {
                        "username": "Satyam_456",
                        "content": "Problem---> Showing Time Limit Exceeded Error for 3 test cases \\nCode-->\\npublic int canCompleteCircuit(int[] gas, int[] cost) {\\n        int i = 0;\\n\\t\\twhile (i < gas.length) {\\n\\t\\t\\tif (gas[i] >= cost[i]) {\\n\\t\\t\\t\\tint curr_gas = 0;\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tint st = -1;\\n\\n\\t\\t\\t\\tfor (int idx = i; idx < i + gas.length; idx++) {\\n\\t\\t\\t\\t\\tint idx1 = idx % gas.length;\\n\\t\\t\\t\\t\\tif (idx1 == i) {\\n\\t\\t\\t\\t\\t\\tst = idx1;\\n\\t\\t\\t\\t\\t\\tcurr_gas = gas[idx1] - cost[idx1];\\n\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcurr_gas = curr_gas - cost[idx1];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (curr_gas < 0) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcurr_gas = curr_gas + gas[(idx1 + 1) % gas.length];\\n\\t\\t\\t\\t\\tcount++;\\n//\\t\\t\\t\\t\\tSystem.out.println(curr_gas);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (count == gas.length) {\\n\\t\\t\\t\\t\\treturn st;\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n}"
                    },
                    {
                        "username": "Saurabhmehtaleetcode",
                        "content": "I am not seeing many people sharing solutions in the discussion section after the UI change . It was great to see people coming up with good and concise solutions with their explanations .   "
                    }
                ]
            },
            {
                "id": 1670747,
                "content": [
                    {
                        "username": "iaarzoo40",
                        "content": "Using C++  ||  Easy and Clean Code\\n\\n***Code***\\n```\\nclass Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int n=gas.size();\\n        int total_gas=0,total_cost=0;\\n        int curr_gas=0, starting_point=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            //these two variable are to check if no case is possible\\n            total_gas+=gas[i];\\n            total_cost+=cost[i];\\n            //for checking the total present gas at index i\\n            curr_gas+=gas[i]-cost[i];\\n            if(curr_gas<0)\\n            {\\n               //there is a breakdown....so we will start from next point or index\\n                starting_point=i+1;\\n                //reset our fuel \\n                curr_gas=0;\\n            }\\n        }\\n        return (total_gas<total_cost)?-1:starting_point;     \\n    }\\n};\\n```"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "The Algorithm for the code is definitely easy but intuition is really challenging\\n"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Agree...When you see the solution it seems so easy. At each index x that you fail to reach you have already verified that you can go from 0-x so you do not need to do it again. But in an interview I dont think you can think of this unless you have see it before. "
                    },
                    {
                        "username": "iamsanko",
                        "content": "the O(N) time and O(1) space is correct"
                    },
                    {
                        "username": "richyan",
                        "content": "a simple solution in javascript - O(n)\n\nvar canCompleteCircuit = function(gas, cost) {\n\n    let start = 0, total = 0, sum = 0;\n    for (let i = 0; i < gas.length; i++) {\n        gas[i] -= cost[i];\n        total += gas[i];\n        sum += gas[i]\n        if (sum < 0) {\n            sum = 0;\n            start = i + 1;\n        }\n    }\n    if (total < 0) return -1;\n    return start;\n};"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Another good question Array maunpulation\\nHint: Calculate difference of gases and cost at each index and manupulate your start index"
                    },
                    {
                        "username": "BristolJ",
                        "content": "What?!"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: circular array "
                    },
                    {
                        "username": "Paras_Saxena",
                        "content": "class Solution {\\npublic:\\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\\n        int current = 0;\\n        int total_fuel = 0, total_cost = 0;\\n        int start = 0;\\n        for(int i=0; i<gas.size(); i++) {\\n            total_fuel += gas[i];\\n        }\\n\\n        for(int i=0; i<gas.size(); i++) {\\n            total_cost += cost[i];\\n        }\\n        if(total_fuel < total_cost){\\n            return -1;\\n        }\\n        for(int i=0; i<gas.size(); i++) {\\n            current += (gas[i] - cost[i]);\\n            if(current < 0){\\n                start = i + 1;\\n                current = 0;\\n            }\\n        }\\n        return start;\\n    }\\n}; @"
                    },
                    {
                        "username": "Satyam_456",
                        "content": "Problem---> Showing Time Limit Exceeded Error for 3 test cases \\nCode-->\\npublic int canCompleteCircuit(int[] gas, int[] cost) {\\n        int i = 0;\\n\\t\\twhile (i < gas.length) {\\n\\t\\t\\tif (gas[i] >= cost[i]) {\\n\\t\\t\\t\\tint curr_gas = 0;\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tint st = -1;\\n\\n\\t\\t\\t\\tfor (int idx = i; idx < i + gas.length; idx++) {\\n\\t\\t\\t\\t\\tint idx1 = idx % gas.length;\\n\\t\\t\\t\\t\\tif (idx1 == i) {\\n\\t\\t\\t\\t\\t\\tst = idx1;\\n\\t\\t\\t\\t\\t\\tcurr_gas = gas[idx1] - cost[idx1];\\n\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcurr_gas = curr_gas - cost[idx1];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (curr_gas < 0) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcurr_gas = curr_gas + gas[(idx1 + 1) % gas.length];\\n\\t\\t\\t\\t\\tcount++;\\n//\\t\\t\\t\\t\\tSystem.out.println(curr_gas);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (count == gas.length) {\\n\\t\\t\\t\\t\\treturn st;\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n}"
                    },
                    {
                        "username": "Saurabhmehtaleetcode",
                        "content": "I am not seeing many people sharing solutions in the discussion section after the UI change . It was great to see people coming up with good and concise solutions with their explanations .   "
                    }
                ]
            }
        ]
    }
]