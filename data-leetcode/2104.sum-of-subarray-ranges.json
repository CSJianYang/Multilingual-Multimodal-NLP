[
    {
        "title": "Sum of Subarray Ranges",
        "question_content": "You are given an integer array nums. The range of a subarray of nums is the difference between the largest and smallest element in the subarray.\nReturn the sum of all subarray ranges of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: 4\nExplanation: The 6 subarrays of nums are the following:\n[1], range = largest - smallest = 1 - 1 = 0 \n[2], range = 2 - 2 = 0\n[3], range = 3 - 3 = 0\n[1,2], range = 2 - 1 = 1\n[2,3], range = 3 - 2 = 1\n[1,2,3], range = 3 - 1 = 2\nSo the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.\nExample 2:\n\nInput: nums = [1,3,3]\nOutput: 4\nExplanation: The 6 subarrays of nums are the following:\n[1], range = largest - smallest = 1 - 1 = 0\n[3], range = 3 - 3 = 0\n[3], range = 3 - 3 = 0\n[1,3], range = 3 - 1 = 2\n[3,3], range = 3 - 3 = 0\n[1,3,3], range = 3 - 1 = 2\nSo the sum of all ranges is 0 + 0 + 0 + 2 + 0 + 2 = 4.\n\nExample 3:\n\nInput: nums = [4,-2,-3,4,1]\nOutput: 59\nExplanation: The sum of all subarray ranges of nums is 59.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 1000\n\t-109 <= nums[i] <= 109\n\n&nbsp;\nFollow-up: Could you find a solution with O(n) time complexity?",
        "solutions": [
            {
                "id": 1624222,
                "title": "java-c-python-o-n-solution-detailed-explanation",
                "content": "# **Solution 0, Brute Force**\\nTime `O(n^3)`\\nSpace `O(1)`\\n<br>\\n\\n# **Solution 1, Two Loops Solution**\\nTime `O(n^2)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public long subArrayRanges(int[] A) {\\n        long res = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            int max = A[i], min = A[i];\\n            for (int j = i; j < A.length; j++) {\\n                max = Math.max(max, A[j]);\\n                min = Math.min(min, A[j]);\\n                res += max - min;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    long long subArrayRanges(vector<int>& A) {\\n        long long res = 0;\\n        for (int i = 0; i < A.size(); i++) {\\n            int ma = A[i], mi = A[i];\\n            for (int j = i; j < A.size(); j++) {\\n                ma = max(ma, A[j]);\\n                mi = min(mi, A[j]);\\n                res += ma - mi;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**Python**\\n```py\\n    def subArrayRanges(self, A):\\n        res = 0\\n        n = len(A)\\n        for i in xrange(n):\\n            l,r = A[i],A[i]\\n            for j in xrange(i, n):\\n                l = min(l, A[j])\\n                r = max(r, A[j])\\n                res += r - l\\n        return res\\n```\\n\\n# **Solution 2, O(n) Stack Solution**\\nFollow the explanation in [907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/170750/)\\n\\n# Intuition\\nres = sum(A[i] * f(i))\\nwhere f(i) is the number of subarrays,\\nin which A[i] is the minimum.\\n\\nTo get f(i), we need to find out:\\nleft[i], the length of strict bigger numbers on the left of A[i],\\nright[i], the length of bigger numbers on the right of A[i].\\n\\nThen,\\nleft[i] + 1 equals to\\nthe number of subarray ending with A[i],\\nand A[i] is single minimum.\\n\\nright[i] + 1 equals to\\nthe number of subarray starting with A[i],\\nand A[i] is the first minimum.\\n\\nFinally f(i) = (left[i] + 1) * (right[i] + 1)\\n\\nFor [3,1,2,4] as example:\\nleft + 1 = [1,2,1,1]\\nright + 1 = [1,3,2,1]\\nf = [1,6,2,1]\\nres = 3 * 1 + 1 * 6 + 2 * 2 + 4 * 1 = 17\\n\\n\\n# Explanation\\nTo calculate left[i] and right[i],\\nwe use two increasing stacks.\\n\\nIt will be easy if you can refer to this problem and my post:\\n901. Online Stock Span\\nI copy some of my codes from this solution.\\n\\n\\n# Complexity\\nAll elements will be pushed twice and popped at most twice\\nTime `O(n)`\\nSpace `O(n)`\\n\\n**Java**\\n```java\\n    public long subArrayRanges(int[] A) {\\n        int n = A.length, j, k;\\n        long res = 0;\\n        \\n        Stack<Integer> s = new Stack<>();\\n        for (int i = 0; i <= n; i++) {\\n            while (!s.isEmpty() && A[s.peek()] > (i == n ? Integer.MIN_VALUE : A[i])) {\\n                j = s.pop();\\n                k = s.isEmpty() ? -1 : s.peek();\\n                res -= (long)A[j] * (i - j) * (j - k);\\n\\n            }\\n            s.push(i);\\n        }\\n        \\n        s.clear();\\n        for (int i = 0; i <= n; i++) {\\n            while (!s.isEmpty() && A[s.peek()] < (i == n ? Integer.MAX_VALUE : A[i])) {\\n                j = s.pop();\\n                k = s.isEmpty() ? -1 : s.peek();\\n                res += (long)A[j] * (i - j) * (j - k);\\n\\n            }\\n            s.push(i);\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    long long subArrayRanges(vector<int>& A) {\\n        long res = 0, n = A.size(), j, k;\\n        stack<int> s;\\n        for (int i = 0; i <= n; ++i) {\\n            while (!s.empty() && A[s.top()] > (i == n ? -2e9 : A[i])) {\\n                j = s.top(), s.pop();\\n                k = s.empty() ? -1 : s.top();\\n                res -= (long)A[j] * (i - j) * (j - k);\\n            }\\n            s.push(i);\\n        }\\n        s = stack<int>();\\n        for (int i = 0; i <= n; ++i) {\\n            while (!s.empty() && A[s.top()] < (i == n ? 2e9 : A[i])) {\\n                j = s.top(), s.pop();\\n                k = s.empty() ? -1 : s.top();\\n                res += (long)A[j] * (i - j) * (j - k);\\n            }\\n            s.push(i);\\n        }\\n        return res;\\n    }\\n```\\n**Python**\\n```py\\n    def subArrayRanges(self, A0):\\n        res = 0\\n        inf = float(\\'inf\\')\\n        A = [-inf] + A0 + [-inf]\\n        s = []\\n        for i, x in enumerate(A):\\n            while s and A[s[-1]] > x:\\n                j = s.pop()\\n                k = s[-1]\\n                res -= A[j] * (i - j) * (j - k)\\n            s.append(i)\\n            \\n        A = [inf] + A0 + [inf]\\n        s = []\\n        for i, x in enumerate(A):\\n            while s and A[s[-1]] < x:\\n                j = s.pop()\\n                k = s[-1]\\n                res += A[j] * (i - j) * (j - k)\\n            s.append(i)\\n        return res\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Stack"
                ],
                "code": "```java\\n    public long subArrayRanges(int[] A) {\\n        long res = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            int max = A[i], min = A[i];\\n            for (int j = i; j < A.length; j++) {\\n                max = Math.max(max, A[j]);\\n                min = Math.min(min, A[j]);\\n                res += max - min;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    long long subArrayRanges(vector<int>& A) {\\n        long long res = 0;\\n        for (int i = 0; i < A.size(); i++) {\\n            int ma = A[i], mi = A[i];\\n            for (int j = i; j < A.size(); j++) {\\n                ma = max(ma, A[j]);\\n                mi = min(mi, A[j]);\\n                res += ma - mi;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def subArrayRanges(self, A):\\n        res = 0\\n        n = len(A)\\n        for i in xrange(n):\\n            l,r = A[i],A[i]\\n            for j in xrange(i, n):\\n                l = min(l, A[j])\\n                r = max(r, A[j])\\n                res += r - l\\n        return res\\n```\n```java\\n    public long subArrayRanges(int[] A) {\\n        int n = A.length, j, k;\\n        long res = 0;\\n        \\n        Stack<Integer> s = new Stack<>();\\n        for (int i = 0; i <= n; i++) {\\n            while (!s.isEmpty() && A[s.peek()] > (i == n ? Integer.MIN_VALUE : A[i])) {\\n                j = s.pop();\\n                k = s.isEmpty() ? -1 : s.peek();\\n                res -= (long)A[j] * (i - j) * (j - k);\\n\\n            }\\n            s.push(i);\\n        }\\n        \\n        s.clear();\\n        for (int i = 0; i <= n; i++) {\\n            while (!s.isEmpty() && A[s.peek()] < (i == n ? Integer.MAX_VALUE : A[i])) {\\n                j = s.pop();\\n                k = s.isEmpty() ? -1 : s.peek();\\n                res += (long)A[j] * (i - j) * (j - k);\\n\\n            }\\n            s.push(i);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    long long subArrayRanges(vector<int>& A) {\\n        long res = 0, n = A.size(), j, k;\\n        stack<int> s;\\n        for (int i = 0; i <= n; ++i) {\\n            while (!s.empty() && A[s.top()] > (i == n ? -2e9 : A[i])) {\\n                j = s.top(), s.pop();\\n                k = s.empty() ? -1 : s.top();\\n                res -= (long)A[j] * (i - j) * (j - k);\\n            }\\n            s.push(i);\\n        }\\n        s = stack<int>();\\n        for (int i = 0; i <= n; ++i) {\\n            while (!s.empty() && A[s.top()] < (i == n ? 2e9 : A[i])) {\\n                j = s.top(), s.pop();\\n                k = s.empty() ? -1 : s.top();\\n                res += (long)A[j] * (i - j) * (j - k);\\n            }\\n            s.push(i);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def subArrayRanges(self, A0):\\n        res = 0\\n        inf = float(\\'inf\\')\\n        A = [-inf] + A0 + [-inf]\\n        s = []\\n        for i, x in enumerate(A):\\n            while s and A[s[-1]] > x:\\n                j = s.pop()\\n                k = s[-1]\\n                res -= A[j] * (i - j) * (j - k)\\n            s.append(i)\\n            \\n        A = [inf] + A0 + [inf]\\n        s = []\\n        for i, x in enumerate(A):\\n            while s and A[s[-1]] < x:\\n                j = s.pop()\\n                k = s[-1]\\n                res += A[j] * (i - j) * (j - k)\\n            s.append(i)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1626628,
                "title": "o-n-solution-with-monotonous-stack-full-explaination",
                "content": "## Approach 1: Simple O(n2) solution\\n```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        int n=nums.size();\\n        long long res=0;\\n        for(int i=0;i<n-1;i++){\\n            int maxi=nums[i], mini=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                if(nums[j]>maxi)maxi=nums[j];\\n                else if(nums[j]<mini)mini=nums[j];\\n                res+=maxi-mini;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n## Approach 2: O(n) solution\\n**What is monotonous increase stack?**\\nRoughly speaking, the elements in the an monotonous increase stack keeps an increasing order.\\n\\n**What can monotonous increase stack do?**\\n**(1) find the previous less element of each element in a vector with O(n) time**:\\nWhat is the previous less element of an element?\\nFor example:\\n[3, 7, 8, 4]\\nThe previous less element of 7 is 3.\\nThe previous less element of 8 is 7.\\nThe previous less element of 4 is 3.\\nThere is no previous less element for 3.\\nInstead of directly pushing the element itself, for simplicity, we can push the index.\\n\\n**(2) find the next less element of each element in a vector with O(n) time:**\\nWhat is the next less element of an element?\\nFor example:\\n[3, 7, 8, 4]\\nThe next less element of 8 is 4.\\nThe next less element of 7 is 4.\\nThere is no next less element for 3 and 4.\\n\\n**How can the monotonous increase stack be applied to this problem?**\\nFor example: Consider the **element 3** in the following vector:\\n\\n                            [2, 9, 7, 8, 3, 4, 6, 1]\\n\\t\\t\\t            (i=0)|      (j=4)|   (k=7)|\\n\\t\\t\\t\\t\\t\\t      m=4-0=4     n=7-4=3\\n\\t             the previous less             the next less \\n\\t                element of 3                element of 3\\n\\nAfter finding both NLE and PLE of 3, we can determine the\\ndistance between 3 and 2(previous less)= (j-i) = 4 =m, and \\nthe distance between 3 and 1(next less)= (k-j) = 3=n.\\nIn this example, the distance is 4 and 3 respectively.\\n**How many subarrays with 3 being its minimum value?**\\nNo. of subarrays with 3 being its minimum value= m * n = (j-i) * (k-j) =4 * 3=12\\nHere, these are-\\n* 9 7 8 3 \\n* 9 7 8 3 4 \\n* 9 7 8 3 4 6 \\n* 7 8 3 \\n* 7 8 3 4 \\n* 7 8 3 4 6 \\n* 8 3 \\n* 8 3 4 \\n* 8 3 4 6 \\n* 3 \\n* 3 4 \\n* 3 4 6\\n\\n**Proof of multiplication give us the number of sub-arrays**\\nThe max array length with 3 as min element has m + n - 1 elements\\n [m={9, 7, 8, 3}, n={3, 4, 6}] => {9, 7, 8, 3, 4, 6 } = A (with m + n - 1 elements)\\n\\n```\\nThe number of subarray we have for the array A with length m + n - 1 is \\n=1 + 2 + 3 + 4 + ... + m + n - 1 = Summation(1 +...+ (m + n - 1)),\\n=(m + n - 1) (m + n) / 2\\n```\\nSince 3 should be the minimum number,  we need to subtract number of subarrays which do not contain 3, which are subarrays of [9,7,8] with length (m - 1) and [4,6] with length (n - 1), \\n```\\nnumber of subarrays for \\n[9,7,8] is S1 = (m - 1 + 1)(m - 1) / 2 = m(m - 1) / 2 \\n[4,6] is S2 = n(n - 1) / 2\\n```\\n\\nFinally, we have\\n\\n```\\nS3 - S2 - S1 = (m + n - 1)(m + n)/2 - m(m - 1)/2 - n(n - 1)/2 \\n                       = (n^2 + mn - n + mn + m^2 - m - n^2 + n - m^2 + m) / 2\\n                       = (2 * m * n) / 2\\n                       = m * n \\n```\\n, which is left distance multiply right distance.\\n**How much the element 3 contributes to the sum of the minimum element of all subarrays?**\\nIt is 3*(4*3)\\n\\nIn general each index i in the array contributes in the sum of the minimum element of all subarrays-\\n`(A[i] * left[i] * right[i]) `\\nwhere -\\n  left[i] =the distance between element A[i] and its PLE.\\n  right[i] =the distance between element A[i] and its NLE.\\n\\nFor better understanding of monotonous stak you may refer-\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/discuss/178876/stack-solution-with-very-detailed-explanation-step-by-step\\n\\n With the same method, we can also find the sum of the maximum element of all subarrays.\\n\\nThe solution for this problem can be formulated as sum(max(b)) - sum(min(b)), where b ranges over every (contiguous) subarray of n.\\n\\nFinal Solution-\\n```\\nlong long subArrayRanges(vector<int>& n) {\\n    return sumSubarrayComp(n, less<int>()) - sumSubarrayComp(n, greater<int>());\\n}    \\nlong long sumSubarrayComp(vector<int>& n, function<bool (int, int)> comp) {\\n    long long res = 0;\\n    vector<int> s;\\n    for (int i = 0; i <= n.size(); ++i) {\\n        while (!s.empty() && (i == n.size() || comp(n[s.back()], n[i]))) {\\n            int j = s.back(), k = s.size() < 2 ? -1 : s[s.size() - 2]; \\n            res += (long long)(i - j) * (j - k) * n[j];\\n            s.pop_back();\\n        }\\n        s.push_back(i);\\n    }    \\n    return res;\\n}\\n```\\nor\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long subArrayRanges(vector<int>& nums) {\\n        int n=nums.size();\\n        long long sum=0;\\n        stack<int>st;\\n        vector<int> minPrev(n,-1),minNext(n,n),maxPrev(n,-1),maxNext(n,n);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            while(!st.empty()&&nums[st.top()]>=nums[i]){st.pop();}\\n            if(!st.empty()){minPrev[i]=st.top();}\\n            st.push(i);\\n        }\\n        while(!st.empty()){st.pop();}\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty()&&nums[st.top()]>nums[i]){st.pop();}\\n            if(!st.empty()){minNext[i]=st.top();}\\n            st.push(i);\\n        }\\n        \\n         for(int i=0;i<n;i++)\\n         {\\n            while(!st.empty()&&nums[st.top()]<=nums[i]){st.pop();}\\n            if(!st.empty()){maxPrev[i]=st.top();}\\n            st.push(i);\\n         }\\n         while(!st.empty()){st.pop();}\\n         for(int i=n-1;i>=0;i--)\\n         {\\n            while(!st.empty()&&nums[st.top()]<nums[i]){st.pop();}\\n            if(!st.empty()){maxNext[i]=st.top();}\\n            st.push(i);\\n         }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            long long leftMin=i-minPrev[i],rightMin=minNext[i]-i;\\n            long long leftMax=i-maxPrev[i],rightMax=maxNext[i]-i;\\n            sum+=(leftMax*rightMax-leftMin*rightMin)*nums[i];\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        int n=nums.size();\\n        long long res=0;\\n        for(int i=0;i<n-1;i++){\\n            int maxi=nums[i], mini=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                if(nums[j]>maxi)maxi=nums[j];\\n                else if(nums[j]<mini)mini=nums[j];\\n                res+=maxi-mini;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nThe number of subarray we have for the array A with length m + n - 1 is \\n=1 + 2 + 3 + 4 + ... + m + n - 1 = Summation(1 +...+ (m + n - 1)),\\n=(m + n - 1) (m + n) / 2\\n```\n```\\nnumber of subarrays for \\n[9,7,8] is S1 = (m - 1 + 1)(m - 1) / 2 = m(m - 1) / 2 \\n[4,6] is S2 = n(n - 1) / 2\\n```\n```\\nS3 - S2 - S1 = (m + n - 1)(m + n)/2 - m(m - 1)/2 - n(n - 1)/2 \\n                       = (n^2 + mn - n + mn + m^2 - m - n^2 + n - m^2 + m) / 2\\n                       = (2 * m * n) / 2\\n                       = m * n \\n```\n```\\nlong long subArrayRanges(vector<int>& n) {\\n    return sumSubarrayComp(n, less<int>()) - sumSubarrayComp(n, greater<int>());\\n}    \\nlong long sumSubarrayComp(vector<int>& n, function<bool (int, int)> comp) {\\n    long long res = 0;\\n    vector<int> s;\\n    for (int i = 0; i <= n.size(); ++i) {\\n        while (!s.empty() && (i == n.size() || comp(n[s.back()], n[i]))) {\\n            int j = s.back(), k = s.size() < 2 ? -1 : s[s.size() - 2]; \\n            res += (long long)(i - j) * (j - k) * n[j];\\n            s.pop_back();\\n        }\\n        s.push_back(i);\\n    }    \\n    return res;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    long long subArrayRanges(vector<int>& nums) {\\n        int n=nums.size();\\n        long long sum=0;\\n        stack<int>st;\\n        vector<int> minPrev(n,-1),minNext(n,n),maxPrev(n,-1),maxNext(n,n);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            while(!st.empty()&&nums[st.top()]>=nums[i]){st.pop();}\\n            if(!st.empty()){minPrev[i]=st.top();}\\n            st.push(i);\\n        }\\n        while(!st.empty()){st.pop();}\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty()&&nums[st.top()]>nums[i]){st.pop();}\\n            if(!st.empty()){minNext[i]=st.top();}\\n            st.push(i);\\n        }\\n        \\n         for(int i=0;i<n;i++)\\n         {\\n            while(!st.empty()&&nums[st.top()]<=nums[i]){st.pop();}\\n            if(!st.empty()){maxPrev[i]=st.top();}\\n            st.push(i);\\n         }\\n         while(!st.empty()){st.pop();}\\n         for(int i=n-1;i>=0;i--)\\n         {\\n            while(!st.empty()&&nums[st.top()]<nums[i]){st.pop();}\\n            if(!st.empty()){maxNext[i]=st.top();}\\n            st.push(i);\\n         }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            long long leftMin=i-minPrev[i],rightMin=minNext[i]-i;\\n            long long leftMax=i-maxPrev[i],rightMax=maxNext[i]-i;\\n            sum+=(leftMax*rightMax-leftMin*rightMin)*nums[i];\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624268,
                "title": "reformulate-problem-o-n",
                "content": "Because `n` is limited to 1,000, a quadratic (two cycles) solution should work. It is much more fun, however, to figure out a linear algorithm.\\n\\n#### Approach 1: Reformulate Problem O(n)\\nLet\\'s ask a different question - what is the sum of the minimum element of all subarrays?  This is exactly this problem: [907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/). With this method, we can also find the sum of the maximum element of all subarrays.\\n\\nThe solution for this problem can be formulated as `sum(max(b)) - sum(min(b))`, where `b` ranges over every (contiguous) subarray of `n`.\\n\\nAs a quick refresher, if an element is smaller than `x` elements before and `y` elements after, that element is the smallest for `(x + 1) * (y + 1)` subarrays.\\n\\nWe can model this using a monostack, where we store positions of increasing elements. When an element `i` is smaller than the element `j` on the top of the stack, we have `i - j` larger elements after `j`. We pop element `j` from the stack, and now a smaller element `k` is on top. So, we have `j - k` larger elements before `j`. Thus, the sum of corresponding subarrays is `(i - j) * (j - k) * n[j]`.\\n\\n![image](https://assets.leetcode.com/users/images/5bf43bc0-d653-4300-aaa6-1df8aa707375_1639300408.195556.png)\\n\\nIn this example, we insert element `4`, removing elements there all the way to `3`.\\n1. Popping `7`, it forms (6 - 5) * (5 - 4) = 1 subarray.\\n2. Popping `6`, it forms (6 - 4) * (4 - 3) = 2 subarray.\\n3. Popping `5`, it forms `(i - j) * (j - k)` subarrays, which is `(6 - 3) * (3 - 0) == 9`.\\n\\n**C++**\\n```cpp\\nlong long subArrayRanges(vector<int>& n) {\\n    return sumSubarrayComp(n, less<int>()) - sumSubarrayComp(n, greater<int>());\\n}    \\nlong long sumSubarrayComp(vector<int>& n, function<bool (int, int)> comp) {\\n    long long res = 0;\\n    vector<int> s;\\n    for (int i = 0; i <= n.size(); ++i) {\\n        while (!s.empty() && (i == n.size() || comp(n[s.back()], n[i]))) {\\n            int j = s.back(), k = s.size() < 2 ? -1 : s[s.size() - 2]; \\n            res += (long long)(i - j) * (j - k) * n[j];\\n            s.pop_back();\\n        }\\n        s.push_back(i);\\n    }    \\n    return res;\\n}\\n```\\n\\n#### Approach 2: Two Cycles O(n2)\\n**C++**\\n```cpp\\nlong long subArrayRanges(vector<int>& nums) {\\n    long long res = 0;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        int sm = nums[i], lg = nums[i];\\n        for (int j = i + 1; j < nums.size(); ++j) {\\n            sm = min(sm, nums[j]);\\n            lg = max(lg, nums[j]);     \\n            res += lg - sm;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nlong long subArrayRanges(vector<int>& n) {\\n    return sumSubarrayComp(n, less<int>()) - sumSubarrayComp(n, greater<int>());\\n}    \\nlong long sumSubarrayComp(vector<int>& n, function<bool (int, int)> comp) {\\n    long long res = 0;\\n    vector<int> s;\\n    for (int i = 0; i <= n.size(); ++i) {\\n        while (!s.empty() && (i == n.size() || comp(n[s.back()], n[i]))) {\\n            int j = s.back(), k = s.size() < 2 ? -1 : s[s.size() - 2]; \\n            res += (long long)(i - j) * (j - k) * n[j];\\n            s.pop_back();\\n        }\\n        s.push_back(i);\\n    }    \\n    return res;\\n}\\n```\n```cpp\\nlong long subArrayRanges(vector<int>& nums) {\\n    long long res = 0;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        int sm = nums[i], lg = nums[i];\\n        for (int j = i + 1; j < nums.size(); ++j) {\\n            sm = min(sm, nums[j]);\\n            lg = max(lg, nums[j]);     \\n            res += lg - sm;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1696344,
                "title": "java-well-explained-with-examples-o-n",
                "content": "Let\\'s say the array is [3,1,2,4].\\nSubarrays will be:\\n\\n\\tSubarrays           Max-Min\\n\\n\\t[3]                 3 - 3\\t= 0\\n\\t[3,1]\\t\\t\\t\\t3 - 1\\t= 2\\n\\t[3,1,2]\\t\\t\\t\\t3 - 1\\t= 2\\n\\t[3,1,2,4]\\t\\t\\t4 - 1\\t= 3\\n\\t  [1]\\t\\t\\t\\t1 - 1\\t= 0\\n\\t  [1,2]\\t\\t\\t\\t2 - 1\\t= 1\\n\\t  [1,2,4]\\t\\t\\t4 - 1\\t= 3\\n\\t\\t[2]\\t\\t\\t\\t2 - 2\\t= 0\\n\\t\\t[2,4]\\t\\t\\t4 - 2\\t= 2\\n\\t\\t  [4]\\t\\t\\t4 - 4\\t= 0\\n\\nAnswer would be = 0+2+2+3+0+1+3+0+2+0 = 13\\n\\nLet us calculate the total number of occurrences of maximum and minimum elements from these subarrays.\\n\\nMaximum side occurrences:  **-------------------- reference (1)**\\n\\'3\\' occurred 3 times\\n\\'1\\' occurred 1 times\\n\\'2\\' occurred 2 times\\n\\'4\\' occurred 4 times\\n\\nMinimum side occurrences:  **-------------------- reference (2)**\\n\\'3\\' occurred 1 times\\n\\'1\\' occurred 6 times\\n\\'2\\' occurred 2 times\\n\\'4\\' occurred 1 times\\n\\nIf we subtract the sum of total minimum value from the sum of total maximum value. Then also we can get the result right?\\ni.e. \\n\\n\\tMaximum side sum\\t\\t\\t\\t\\t\\tMinimum side sum\\n\\t(3*3) + (1*1) + 2*2) + (4*4)= 30\\t\\t(3*1)+ (1*6) + (2*2) + (4*1) = 17\\nso, 30 - 17 = 13.\\n\\nwe can again reduce the problem.\\nLets us consider the situation for occurences of 3.\\nWe were getting,\\n\\n\\tMaximum side sum\\t\\t\\tMinimum side sum\\n\\t(3*3) = 9\\t\\t\\t\\t\\t(3*1) = 3\\nans = 9-3 = 6\\n\\nIf we just subtract the minimum occurrences of 3 from the maximum occurrences of 3 and then multiply the value of 3 i.e. 3. Than also we can get the same answer.\\nThat is:\\n\\n\\t(Max occur - Min occur)*value\\n\\t(3         -         1)*3\\n= 2*3 = 6\\nsame answer right?\\n\\nWe can do the same for the whole array.\\n(3-1) * 3 + (1-6) * 1 + (2-2) * 2 + (4-1) * 4\\n=2 * 3 + (-5) * 1 + 0 * 2 + 3 * 4\\n=6 - 5 + 0 + 12\\n=13\\n\\nSo, now our question is how we can get the maximum/minimum occurrences of 3,4,2 or 1.\\nFor this you refer to Leetcode 907. https://leetcode.com/problems/sum-of-subarray-minimums/\\nelse, go through a short explaination:\\n\\nTo find the number of minimum occurrences, we need to find,\\nthe elements greater than the current element on left (including itself) * the elements greater than the current element on right (including itself)\\n\\narray is:\\n[3, 1, 2, 4]\\ngreater than the current element from left:\\n[1, 2, 1, 1]\\nfrom right,\\n[1, 3, 2, 1]\\n\\nso, to get the minimum occurrences\\' count we need to multiply both the arrays\\' elements for each position.\\ni.e.:\\npos 0 (val = 3) occurrence = (1 * 1) = 1\\npos 1 (val = 1) occurrence = (2 * 3) = 6\\npos 2 (val = 2) occurrence = (1 * 2) = 2\\npos 3 (val = 4) occurrence = (1 * 1) = 1\\nMatch these values with **reference (2)**, see they are same.\\n\\nSimilarly to find maximum occurrences we need do find the lesser element for each element.\\n\\narray is:\\n[3, 1, 2, 4]\\nlesser than the current element from left:\\n[1, 1, 2, 4]\\nfrom right,\\n[3, 1, 1, 1]\\n\\nAnd minimum occurrences\\' would be:\\npos 0 (val = 3) occurrence = (1 * 3) = 3\\npos 1 (val = 1) occurrence = (1 * 1) = 1\\npos 2 (val = 2) occurrence = (2 * 1) = 2\\npos 3 (val = 4) occurrence = (4 * 1) = 4\\nMatch with **reference (1)**.\\n\\nSo, ultimately answer would be ,\\n(maximum occurrences - minimum occurrences)* value for each element.\\n((1 * 3)-(1 * 1))*3 + ((1 * 1)-(2 * 3))*1 + ((2 * 1)-(1 * 2))*2 + ((4 * 1)-(1 * 1))*4\\n=(3-1) * 3 + (1-6) * 1 + (2-2) * 2 + (4-1) * 4\\n=2 * 3 + (-5) * 1 + 0 * 2 + 3 * 4\\n=6 - 5 + 0 + 12\\n=13\\n\\n\\nWe can use monotonic stack to get the lesser or greater values for each element.\\n\\n\\t**Note:**\\n\\tIf we get duplicate elements like [3, 1, 2, 4, 2], we need to go until we get <= element from the left and < element from the right or the vice versa.\\n\\tSame for the generation of greater counts.\\n\\n\\nHere is the code.\\n```\\nclass Solution {\\n    class Node{\\n        long val, displace;\\n        Node(long val, long displace){\\n            this.val = val;\\n            this.displace = displace;\\n        }\\n    }\\n    public long subArrayRanges(int[] nums) {\\n        \\n        //lesser than current element\\n        Stack<Node> stack = new Stack<>();\\n        //from left\\n        long [] lesserLeft = new long[nums.length];\\n        for (int i = 0; i< nums.length; i++){\\n            long count = 1;\\n            while(stack.size()>0 && stack.peek().val<=nums[i]){\\n                count+=stack.pop().displace;\\n            }\\n            stack.add(new Node(nums[i], count));\\n            lesserLeft[i] = count;\\n        }\\n        stack.clear();\\n        //from right\\n        long[] lesserRight = new long[nums.length];\\n        for (int i = nums.length-1; i>=0; i--){\\n            long count = 1;\\n            while(stack.size()>0 && stack.peek().val<nums[i]){\\n                count+=stack.pop().displace;\\n            }\\n            stack.add(new Node(nums[i], count));\\n            lesserRight[i] = count;\\n        }\\n        \\n        \\n        //greater than current element\\n        stack.clear();\\n        //from left\\n        long [] greaterLeft = new long[nums.length];\\n        for (int i = 0; i< nums.length; i++){\\n            long count = 1;\\n            while(stack.size()>0 && stack.peek().val>=nums[i]){\\n                count+=stack.pop().displace;\\n            }\\n            stack.add(new Node(nums[i], count));\\n            greaterLeft[i] = count;\\n        }\\n        stack.clear();\\n        //from right\\n        long[] greaterRight = new long[nums.length];\\n        for (int i = nums.length-1; i>=0; i--){\\n            long count = 1;\\n            while(stack.size()>0 && stack.peek().val>nums[i]){\\n                count+=stack.pop().displace;\\n            }\\n            stack.add(new Node(nums[i], count));\\n            greaterRight[i] = count;\\n        }        \\n        \\n        long ans = 0;\\n        //Now we subtract the count of minimum occurrences from the count of maximum occurrences\\n        \\n        for (int i = 0; i< nums.length; i++){\\n            ans+=((lesserLeft[i]*lesserRight[i]) - (greaterLeft[i]*greaterRight[i]))*nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    class Node{\\n        long val, displace;\\n        Node(long val, long displace){\\n            this.val = val;\\n            this.displace = displace;\\n        }\\n    }\\n    public long subArrayRanges(int[] nums) {\\n        \\n        //lesser than current element\\n        Stack<Node> stack = new Stack<>();\\n        //from left\\n        long [] lesserLeft = new long[nums.length];\\n        for (int i = 0; i< nums.length; i++){\\n            long count = 1;\\n            while(stack.size()>0 && stack.peek().val<=nums[i]){\\n                count+=stack.pop().displace;\\n            }\\n            stack.add(new Node(nums[i], count));\\n            lesserLeft[i] = count;\\n        }\\n        stack.clear();\\n        //from right\\n        long[] lesserRight = new long[nums.length];\\n        for (int i = nums.length-1; i>=0; i--){\\n            long count = 1;\\n            while(stack.size()>0 && stack.peek().val<nums[i]){\\n                count+=stack.pop().displace;\\n            }\\n            stack.add(new Node(nums[i], count));\\n            lesserRight[i] = count;\\n        }\\n        \\n        \\n        //greater than current element\\n        stack.clear();\\n        //from left\\n        long [] greaterLeft = new long[nums.length];\\n        for (int i = 0; i< nums.length; i++){\\n            long count = 1;\\n            while(stack.size()>0 && stack.peek().val>=nums[i]){\\n                count+=stack.pop().displace;\\n            }\\n            stack.add(new Node(nums[i], count));\\n            greaterLeft[i] = count;\\n        }\\n        stack.clear();\\n        //from right\\n        long[] greaterRight = new long[nums.length];\\n        for (int i = nums.length-1; i>=0; i--){\\n            long count = 1;\\n            while(stack.size()>0 && stack.peek().val>nums[i]){\\n                count+=stack.pop().displace;\\n            }\\n            stack.add(new Node(nums[i], count));\\n            greaterRight[i] = count;\\n        }        \\n        \\n        long ans = 0;\\n        //Now we subtract the count of minimum occurrences from the count of maximum occurrences\\n        \\n        for (int i = 0; i< nums.length; i++){\\n            ans+=((lesserLeft[i]*lesserRight[i]) - (greaterLeft[i]*greaterRight[i]))*nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979763,
                "title": "python-stack-o-n-solution-with-inline-explanation",
                "content": "```python\\n\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        # the answer will be sum{ Max(subarray) - Min(subarray) } over all possible subarray\\n        # which decomposes to sum{Max(subarray)} - sum{Min(subarray)} over all possible subarray\\n        # so totalsum = maxsum - minsum\\n        # we calculate minsum and maxsum in two different loops\\n        minsum = maxsum = 0\\n        \\n        # first calculate sum{ Min(subarray) } over all subarrays\\n        # sum{ Min(subarray) } = sum(f(i) * nums[i]) ; i=0..n-1\\n        # where f(i) is number of subarrays where nums[i] is the minimum value\\n        # f(i) = (i - index of the previous smaller value) * (index of the next smaller value - i) * nums[i]\\n        # we can claculate these indices in linear time using a monotonically increasing stack.\\n        stack = []\\n        for next_smaller in range(n + 1):\\n\\t\\t\\t# we pop from the stack in order to satisfy the monotonically increasing order property\\n\\t\\t\\t# if we reach the end of the iteration and there are elements present in the stack, we pop all of them\\n            while stack and (next_smaller == n or nums[stack[-1]] > nums[next_smaller]):\\n                i = stack.pop()\\n                prev_smaller = stack[-1] if stack else -1\\n                minsum += nums[i] * (next_smaller - i) * (i - prev_smaller)\\n            stack.append(next_smaller)\\n            \\n        # then calculate sum{ Max(subarray) } over all subarrays\\n        # sum{ Max(subarray) } = sum(f\\'(i) * nums[i]) ; i=0..n-1\\n        # where f\\'(i) is number of subarrays where nums[i] is the maximum value\\n        # f\\'(i) = (i - index of the previous larger value) - (index of the next larger value - i) * nums[i]\\n        # this time we use a monotonically decreasing stack.\\n        stack = []\\n        for next_larger in range(n + 1):\\n\\t\\t\\t# we pop from the stack in order to satisfy the monotonically decreasing order property\\n\\t\\t\\t# if we reach the end of the iteration and there are elements present in the stack, we pop all of them\\n            while stack and (next_larger == n or nums[stack[-1]] < nums[next_larger]):\\n                i = stack.pop()\\n                prev_larger = stack[-1] if stack else -1\\n                maxsum += nums[i] * (next_larger - i) * (i - prev_larger)\\n            stack.append(next_larger)\\n        \\n        return maxsum - minsum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```python\\n\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        # the answer will be sum{ Max(subarray) - Min(subarray) } over all possible subarray\\n        # which decomposes to sum{Max(subarray)} - sum{Min(subarray)} over all possible subarray\\n        # so totalsum = maxsum - minsum\\n        # we calculate minsum and maxsum in two different loops\\n        minsum = maxsum = 0\\n        \\n        # first calculate sum{ Min(subarray) } over all subarrays\\n        # sum{ Min(subarray) } = sum(f(i) * nums[i]) ; i=0..n-1\\n        # where f(i) is number of subarrays where nums[i] is the minimum value\\n        # f(i) = (i - index of the previous smaller value) * (index of the next smaller value - i) * nums[i]\\n        # we can claculate these indices in linear time using a monotonically increasing stack.\\n        stack = []\\n        for next_smaller in range(n + 1):\\n\\t\\t\\t# we pop from the stack in order to satisfy the monotonically increasing order property\\n\\t\\t\\t# if we reach the end of the iteration and there are elements present in the stack, we pop all of them\\n            while stack and (next_smaller == n or nums[stack[-1]] > nums[next_smaller]):\\n                i = stack.pop()\\n                prev_smaller = stack[-1] if stack else -1\\n                minsum += nums[i] * (next_smaller - i) * (i - prev_smaller)\\n            stack.append(next_smaller)\\n            \\n        # then calculate sum{ Max(subarray) } over all subarrays\\n        # sum{ Max(subarray) } = sum(f\\'(i) * nums[i]) ; i=0..n-1\\n        # where f\\'(i) is number of subarrays where nums[i] is the maximum value\\n        # f\\'(i) = (i - index of the previous larger value) - (index of the next larger value - i) * nums[i]\\n        # this time we use a monotonically decreasing stack.\\n        stack = []\\n        for next_larger in range(n + 1):\\n\\t\\t\\t# we pop from the stack in order to satisfy the monotonically decreasing order property\\n\\t\\t\\t# if we reach the end of the iteration and there are elements present in the stack, we pop all of them\\n            while stack and (next_larger == n or nums[stack[-1]] < nums[next_larger]):\\n                i = stack.pop()\\n                prev_larger = stack[-1] if stack else -1\\n                maxsum += nums[i] * (next_larger - i) * (i - prev_larger)\\n            stack.append(next_larger)\\n        \\n        return maxsum - minsum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413551,
                "title": "2-monotonic-stack-easy-to-understand-plus-a-lot-of-explanations",
                "content": "Let\\'s take the example 3 `nums = [4,-2,-3,4,1]`.\\nFor every subset, we need to find its max and min. Then do sum += max-min\\n```\\n\\t\\t                max        min\\n[]\\n[4]                     4           4          sum = 4-4\\n[4,-2]                  4          -2          sum = (4-4) + (4-(-2))\\n[4,-2,-3]               4          -3          sum = (4-4) + (4-(-2)) + (4-(-3)) \\n[4,-2,-3,4]             4          -3          ...\\n[4,-2,-3,4]             4          -3          ...\\n[4,-2,-3,4,1]           4          -3          ...\\n[-2,-3,4,1]             4          -3          ...\\n[-3,4,1]                4          -3          ...\\n[4,1]                   4           1          ...\\n[1]                     1           1          ...\\n[-2,-3,4]               4          -3          ...\\n[-2,-3]                -2          -3          ...\\n[-2]                   -2          -2          ...\\n[-3]                   -3          -3          ...\\n[1]                     1           1          sum = (4-4) + (4-(-2)) + (4-(-3)) +...\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   from this function, we can find a pattern\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   => (a-b) + (c-d) + (e-f) +...\\n                                                   => (a+c+e+...) - (b+d+f+....)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   => (ALL MAX) - (ALL MIN)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   where left side is the max value (a,c,e...) in each subarray \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     right value is min value (b,d,f...) in each subarray\\n```\\nWith this concept, all we need to do is find how many time i-th element is the max/min. And inorder to do that, we need to know i-th element\\'s prev lesser/larger and next lesser/larger. So that we can get use them to find a range.\\n\\n```\\nFor example: if we are look at :  nums = [4,-2,-3,4,1], current target = -3\\n1. the range of it is being a max number [4,-2,{-3},4,1] because its prev larger is -2 and next larger is 4\\n2. the range of it is being a min number [{4,-2,-3,4,1}] because there is no prev lesser and there is no next lesser \\nwhen we have the left bound and right bound, we can just count how many times we can put a { in left and still contains target \\n* how many times we can put } in right and still contains target\\n[{4,-2,-3,4,1], [4,{-2,-3,4,1],[4,-2,{-3,4,1] = 3 \\n[4,-2,-3,4,1}], [4,-2,-3,4},1],[4,-2,-3},4,1] = 3\\n3 * 3 = 9\\n\\n[4,-2,{-3},4,1]  there is only 1 place you can put { and } so 1 * 1 = 1\\n\\nthis means in (a+c+e+...) the target = -3 has been appeared 1 times and (b+d+f+....) 3 has been appeared 9 times.\\nwe can simple record this by ALL MAX += 1* -3, ALL MIN += 9 * -3\\n```\\n\\nOur next question is how to find prev lesser/larger and next lesser/larger. When we see lesser/larger first thing that pop up in mind should be monotonic stack.\\n\\n```\\nAn increasing(1->2->3) monotonic stack is used to find prev lesser and next lesser\\n[4,-2,-3,4,1]\\nBegin: Stack =[-3, 4] \\ninput = 1, becuase 4 > 1, pop 4. Stack = [-3].\\nNow this means 4\\'s next lessor is 1, then we can use peek() to find prev lesser which is -3.\\n\\nAn decreasing(3->2->1) monotonic stack is used to find prev larger and next larger\\n[4,-2,-3,4,1]\\nBegin: Stack =[4,-2,-3] \\ninput = 4, becuase -3 < 4, pop -3. Stack = [4,-2].\\nNow this means -3\\'s next larger is 4, then we can use peek() to find prev lesser which is -2.\\nagain we pop -2 because -2 < 4. Stack = [4].\\nSimilarly, -2\\'s next larger is 4, then we can use peek() to find prev lesser which is 4.\\n```\\nBecuase we are finding both lesser and larger, we are going to use both monotonic stack.\\nAlso, becuase we are looking for ranges instead of actual values, we should store indexs and use it to get values in the nums[]\\n\\n```\\nNow, we know we only need to do 5 things to complete this question\\n1. create 2 monotonic stacks\\n2. make a for loop to go through all elements in nums\\n3. for each elements, we add it to both stacks\\n\\t4. duing adding, we will get some elements from pop(). And we know the prev lesser/larger and next lesser/larger \\n\\t5. use the prev lesser/larger and next lesser/larger to calculate the range and record it.\\n6. return the recorded number\\n\\n\\nThere are also 2 edge cases we need to consider.\\n1. when we peek() in stack, the stack is empty\\n\\tFor example, in [4,-2,-3,4,1] into a increasing monotonic stack  [4] -> 4>-2, pop 4. now stack is [] OR the next iteration [-2] -> -2>-3, pop -2. stack is []\\n\\t\\n\\tMy solution :\\n\\t\\tIf there is no elements in the stack, that means for i-th element, there is no prev lesser(in this case). \\n\\t\\tSo it will have (i + 1) spots to put {. \\n\\t\\t\\n2. what if there are elements never get poped out after we go though all elements. \\n    For example we put [3,2,1] in decreasing monotonic stack, they all have no next larger\\n\\t\\n\\tMy solution : \\n\\t\\tif there is left overs in the stack, that means they all have no next larger(in this case). \\n\\t\\tSo they all have (nums.length - i) spots to put }.\\n```\\n\\n\\n```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        long result = 0;\\n        Stack<Integer> inc = new Stack<>();\\n        Stack<Integer> dec = new Stack<>();\\n        for(int i = 0 ; i <= nums.length ; i ++){\\n            while(!inc.isEmpty() && ( i == nums.length || nums[inc.peek()] < nums[i])){\\n                int currIndex = inc.pop();\\n                int leftBound = inc.isEmpty() ? -1 : inc.peek(); \\n                int rightBound = i;\\n                result += (currIndex - leftBound) * (rightBound - currIndex) * (long) nums[currIndex];                \\n            }\\n            while(!dec.isEmpty() && (i == nums.length || nums[dec.peek()] > nums[i])){\\n                int currIndex = dec.pop();\\n                int leftBound = dec.isEmpty()? -1 : dec.peek(); \\n                int rightBound = i;\\n                result -= (currIndex - leftBound) * (rightBound - currIndex) * (long) nums[currIndex];\\n            }\\n            inc.push(i);\\n            dec.push(i);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\nThere are lot of duplicated code in 2 while loop. You can optimize it by create a helper function and pass in either a flag or a comparator to shrink it to 1 while loop :) I\\'m just too lazy",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "```\\n\\t\\t                max        min\\n[]\\n[4]                     4           4          sum = 4-4\\n[4,-2]                  4          -2          sum = (4-4) + (4-(-2))\\n[4,-2,-3]               4          -3          sum = (4-4) + (4-(-2)) + (4-(-3)) \\n[4,-2,-3,4]             4          -3          ...\\n[4,-2,-3,4]             4          -3          ...\\n[4,-2,-3,4,1]           4          -3          ...\\n[-2,-3,4,1]             4          -3          ...\\n[-3,4,1]                4          -3          ...\\n[4,1]                   4           1          ...\\n[1]                     1           1          ...\\n[-2,-3,4]               4          -3          ...\\n[-2,-3]                -2          -3          ...\\n[-2]                   -2          -2          ...\\n[-3]                   -3          -3          ...\\n[1]                     1           1          sum = (4-4) + (4-(-2)) + (4-(-3)) +...\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   from this function, we can find a pattern\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   => (a-b) + (c-d) + (e-f) +...\\n                                                   => (a+c+e+...) - (b+d+f+....)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   => (ALL MAX) - (ALL MIN)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   where left side is the max value (a,c,e...) in each subarray \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     right value is min value (b,d,f...) in each subarray\\n```\n```\\nFor example: if we are look at :  nums = [4,-2,-3,4,1], current target = -3\\n1. the range of it is being a max number [4,-2,{-3},4,1] because its prev larger is -2 and next larger is 4\\n2. the range of it is being a min number [{4,-2,-3,4,1}] because there is no prev lesser and there is no next lesser \\nwhen we have the left bound and right bound, we can just count how many times we can put a { in left and still contains target \\n* how many times we can put } in right and still contains target\\n[{4,-2,-3,4,1], [4,{-2,-3,4,1],[4,-2,{-3,4,1] = 3 \\n[4,-2,-3,4,1}], [4,-2,-3,4},1],[4,-2,-3},4,1] = 3\\n3 * 3 = 9\\n\\n[4,-2,{-3},4,1]  there is only 1 place you can put { and } so 1 * 1 = 1\\n\\nthis means in (a+c+e+...) the target = -3 has been appeared 1 times and (b+d+f+....) 3 has been appeared 9 times.\\nwe can simple record this by ALL MAX += 1* -3, ALL MIN += 9 * -3\\n```\n```\\nAn increasing(1->2->3) monotonic stack is used to find prev lesser and next lesser\\n[4,-2,-3,4,1]\\nBegin: Stack =[-3, 4] \\ninput = 1, becuase 4 > 1, pop 4. Stack = [-3].\\nNow this means 4\\'s next lessor is 1, then we can use peek() to find prev lesser which is -3.\\n\\nAn decreasing(3->2->1) monotonic stack is used to find prev larger and next larger\\n[4,-2,-3,4,1]\\nBegin: Stack =[4,-2,-3] \\ninput = 4, becuase -3 < 4, pop -3. Stack = [4,-2].\\nNow this means -3\\'s next larger is 4, then we can use peek() to find prev lesser which is -2.\\nagain we pop -2 because -2 < 4. Stack = [4].\\nSimilarly, -2\\'s next larger is 4, then we can use peek() to find prev lesser which is 4.\\n```\n```\\nNow, we know we only need to do 5 things to complete this question\\n1. create 2 monotonic stacks\\n2. make a for loop to go through all elements in nums\\n3. for each elements, we add it to both stacks\\n\\t4. duing adding, we will get some elements from pop(). And we know the prev lesser/larger and next lesser/larger \\n\\t5. use the prev lesser/larger and next lesser/larger to calculate the range and record it.\\n6. return the recorded number\\n\\n\\nThere are also 2 edge cases we need to consider.\\n1. when we peek() in stack, the stack is empty\\n\\tFor example, in [4,-2,-3,4,1] into a increasing monotonic stack  [4] -> 4>-2, pop 4. now stack is [] OR the next iteration [-2] -> -2>-3, pop -2. stack is []\\n\\t\\n\\tMy solution :\\n\\t\\tIf there is no elements in the stack, that means for i-th element, there is no prev lesser(in this case). \\n\\t\\tSo it will have (i + 1) spots to put {. \\n\\t\\t\\n2. what if there are elements never get poped out after we go though all elements. \\n    For example we put [3,2,1] in decreasing monotonic stack, they all have no next larger\\n\\t\\n\\tMy solution : \\n\\t\\tif there is left overs in the stack, that means they all have no next larger(in this case). \\n\\t\\tSo they all have (nums.length - i) spots to put }.\\n```\n```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        long result = 0;\\n        Stack<Integer> inc = new Stack<>();\\n        Stack<Integer> dec = new Stack<>();\\n        for(int i = 0 ; i <= nums.length ; i ++){\\n            while(!inc.isEmpty() && ( i == nums.length || nums[inc.peek()] < nums[i])){\\n                int currIndex = inc.pop();\\n                int leftBound = inc.isEmpty() ? -1 : inc.peek(); \\n                int rightBound = i;\\n                result += (currIndex - leftBound) * (rightBound - currIndex) * (long) nums[currIndex];                \\n            }\\n            while(!dec.isEmpty() && (i == nums.length || nums[dec.peek()] > nums[i])){\\n                int currIndex = dec.pop();\\n                int leftBound = dec.isEmpty()? -1 : dec.peek(); \\n                int rightBound = i;\\n                result -= (currIndex - leftBound) * (rightBound - currIndex) * (long) nums[currIndex];\\n            }\\n            inc.push(i);\\n            dec.push(i);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625501,
                "title": "javascript-all-solutions-with-a-step-by-step-tackling-of-the-problem",
                "content": "# Prompt\\n\\nWe\\'re prompted to return the sum of all the subarray ranges (a subarray range is the difference between its max and min values); e.g. let [1, 2, 3] be our array of `nums`, all of its subarrays are the following\\n- [1]: Min = 1, max = 1\\n- [1, 2]: Min = 1, max = 2\\n- [1, 2, 3]: Min = 1, max = 3\\n- [2]: Min = 2, max =2\\n- [2, 3]: Min = 2, max = 3\\n- [3]: Min = 3, max = 3\\nThe answer for the previous example will be (1 - 1) + (2 - 1) + (3 - 1) + (2 - 2) + (3 - 2) + (3 - 3) = 4\\n\\n# Approach\\n\\nBy observing the prompt we can take one of two approaches to solve this problem (naive, optimal approaches):\\n\\n1. The naive approach will be to simply get all of the subarrays and add to the result the difference between their max and min values. This approach can be done in two ways either with **3 `for` loops** or **2 `for` loops** having `O(n^3)` and `O(n^2)` time complexities respectively.\\n2. The more interesting approach is to think about this problem in a slightly different way; instead of getting the max and min values for each subarray then sum to the result their difference, we can instead **sum all of the max values** and substract from that the **sum of all the min values**; e.g. instead of writing the answer like that `(1 - 1) + (2 - 1) + (3 - 1) + (2 - 2) + (3 - 2) + (3 - 3) = 4`, we can also write it this way `(1 + 2 + 3 + 2 + 3 + 3) - (1 + 1 + 1 + 2 + 2 + 3) = 4`. which means to find the answer for this problem we can see how many times a certian number was a max in all of the subarrays that included it and how many times it was a min in the same subarrays! To do this we need to consider using a monotonic stack in which we add the index of our number and pop any previously inserted values in the stack **if and only if** they\\'re smaller than us, that\\'s how we end up getting the left range that includes all the possible subarrays that we are the max value in; the right range will be achived when we (the number) get poped by a value that\\'s greater than us. (Please read the comments in the code carefully, it will make things more clear).\\n\\n**1. Naive approaches:**\\n\\n```\\n// O(n^3) time | O(1) space\\nvar subArrayRanges = function(nums) {\\n\\tlet res = 0\\n\\tfor (let i = 1; i < nums.length; i++) {\\n\\t\\tfor (let j = 0; j < i; j++) {\\n\\t\\t\\tlet smallest = nums[i], biggest = nums[i]\\n\\t\\t\\tfor (let k = j; k < i; k++) {\\n\\t\\t\\t\\tsmallest = Math.min(smallest, nums[k])\\n\\t\\t\\t\\tbiggest = Math.max(biggest, nums[k])\\n\\t\\t\\t}\\n\\t\\t\\tres += biggest - smallest\\n\\t\\t}\\n\\t}\\n\\treturn res\\n};\\n```\\n\\n```\\n// O(n^2) time | O(1) space\\nvar subArrayRanges = function(nums) {\\n\\tlet res = 0\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tlet smallest = nums[i], biggest = nums[i]\\n\\t\\tfor (let j = i; j < nums.length; j++) {\\n\\t\\t\\tsmallest = Math.min(smallest, nums[j])\\n\\t\\t\\tbiggest = Math.max(biggest, nums[j])\\n\\t\\t\\tres += biggest - smallest\\n\\t\\t}\\n\\t}\\n\\treturn res\\n};\\n```\\n\\n**2. Optimal approach:**\\n\\n```\\n// O(n) time | O(n) space\\nvar subArrayRanges = function(nums) {\\n\\t/**\\n\\t * The max range for each value in a negative copy of the array will be the min range...\\n\\t * for the same value in the positive array.\\n\\t */\\n\\tconst N = nums.map(n => -n)\\n\\treturn getMaxRange(nums) + getMaxRange(N)\\n\\n\\tfunction getMaxRange(nums) {\\n\\t\\t/**\\n\\t\\t * Monotonic stack initialized with a -1 for potential edge cases where we have...\\n\\t\\t * no values in the stack and we wanna calculate the left range of the poped number.\\n\\t\\t */\\n\\t\\tconst S = [-1]\\n\\t\\tnums.push(Infinity)\\n\\t\\tlet res = 0\\n\\t\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\t\\t/**\\n\\t\\t\\t * If we\\'re poping values that\\'re smaller than us that mean we gonna end up with a...\\n\\t\\t\\t * boundary to our left that\\'s greater than us, meaning we extended our range to include...\\n\\t\\t\\t * all of the values that\\'re smaller than us, meaning we got the full left range...\\n\\t\\t\\t * in which we are the max.\\n\\t\\t\\t */\\n\\t\\t\\t/**\\n\\t\\t\\t * We will get the right range when a value from future position in the array pop us out...\\n\\t\\t\\t * that\\'s why we have an Infinity value at the end of the array that will pop the last...\\n\\t\\t  \\t * number out!\\n\\t\\t\\t */\\n\\t\\t\\twhile (nums[S[S.length - 1]] < nums[i]) {\\n\\t\\t\\t\\tconst MOST_MAX = S.pop(),\\n\\t\\t\\t\\t\\tLEFT_BOUNDARY = S[S.length - 1]\\n\\t\\t\\t\\tconst LEFT_RANGE = MOST_MAX - LEFT_BOUNDARY,\\n\\t\\t\\t\\t\\tRIGHT_RANGE = i - MOST_MAX\\n\\t\\t\\t\\t/**\\n\\t\\t\\t\\t * By multiplying all these 3 values we get exactly how many times this number...\\n\\t\\t\\t\\t * was a max in its range!\\n\\t\\t\\t\\t */\\n\\t\\t\\t\\tres += nums[MOST_MAX] * LEFT_RANGE * RIGHT_RANGE\\n\\t\\t\\t}\\n\\t\\t\\tS.push(i)\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// O(n^3) time | O(1) space\\nvar subArrayRanges = function(nums) {\\n\\tlet res = 0\\n\\tfor (let i = 1; i < nums.length; i++) {\\n\\t\\tfor (let j = 0; j < i; j++) {\\n\\t\\t\\tlet smallest = nums[i], biggest = nums[i]\\n\\t\\t\\tfor (let k = j; k < i; k++) {\\n\\t\\t\\t\\tsmallest = Math.min(smallest, nums[k])\\n\\t\\t\\t\\tbiggest = Math.max(biggest, nums[k])\\n\\t\\t\\t}\\n\\t\\t\\tres += biggest - smallest\\n\\t\\t}\\n\\t}\\n\\treturn res\\n};\\n```\n```\\n// O(n^2) time | O(1) space\\nvar subArrayRanges = function(nums) {\\n\\tlet res = 0\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tlet smallest = nums[i], biggest = nums[i]\\n\\t\\tfor (let j = i; j < nums.length; j++) {\\n\\t\\t\\tsmallest = Math.min(smallest, nums[j])\\n\\t\\t\\tbiggest = Math.max(biggest, nums[j])\\n\\t\\t\\tres += biggest - smallest\\n\\t\\t}\\n\\t}\\n\\treturn res\\n};\\n```\n```\\n// O(n) time | O(n) space\\nvar subArrayRanges = function(nums) {\\n\\t/**\\n\\t * The max range for each value in a negative copy of the array will be the min range...\\n\\t * for the same value in the positive array.\\n\\t */\\n\\tconst N = nums.map(n => -n)\\n\\treturn getMaxRange(nums) + getMaxRange(N)\\n\\n\\tfunction getMaxRange(nums) {\\n\\t\\t/**\\n\\t\\t * Monotonic stack initialized with a -1 for potential edge cases where we have...\\n\\t\\t * no values in the stack and we wanna calculate the left range of the poped number.\\n\\t\\t */\\n\\t\\tconst S = [-1]\\n\\t\\tnums.push(Infinity)\\n\\t\\tlet res = 0\\n\\t\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\t\\t/**\\n\\t\\t\\t * If we\\'re poping values that\\'re smaller than us that mean we gonna end up with a...\\n\\t\\t\\t * boundary to our left that\\'s greater than us, meaning we extended our range to include...\\n\\t\\t\\t * all of the values that\\'re smaller than us, meaning we got the full left range...\\n\\t\\t\\t * in which we are the max.\\n\\t\\t\\t */\\n\\t\\t\\t/**\\n\\t\\t\\t * We will get the right range when a value from future position in the array pop us out...\\n\\t\\t\\t * that\\'s why we have an Infinity value at the end of the array that will pop the last...\\n\\t\\t  \\t * number out!\\n\\t\\t\\t */\\n\\t\\t\\twhile (nums[S[S.length - 1]] < nums[i]) {\\n\\t\\t\\t\\tconst MOST_MAX = S.pop(),\\n\\t\\t\\t\\t\\tLEFT_BOUNDARY = S[S.length - 1]\\n\\t\\t\\t\\tconst LEFT_RANGE = MOST_MAX - LEFT_BOUNDARY,\\n\\t\\t\\t\\t\\tRIGHT_RANGE = i - MOST_MAX\\n\\t\\t\\t\\t/**\\n\\t\\t\\t\\t * By multiplying all these 3 values we get exactly how many times this number...\\n\\t\\t\\t\\t * was a max in its range!\\n\\t\\t\\t\\t */\\n\\t\\t\\t\\tres += nums[MOST_MAX] * LEFT_RANGE * RIGHT_RANGE\\n\\t\\t\\t}\\n\\t\\t\\tS.push(i)\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2059690,
                "title": "java-3-solutions-with-explanation-monotonic-stack-o-n",
                "content": "### \\u2714\\uFE0F Solution 0: Brute Force\\nTime: `O(n^3)`\\nSpace: `O(1)`\\n\\n----\\n### \\u2714\\uFE0F Solution 1: Two Loops\\nTime: `O(n^2)`\\nSpace: `O(1)`\\n#### Java\\n```java\\npublic long subArrayRanges(int[] nums) {\\n\\tint n = nums.length;\\n\\tlong res = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint min = nums[i], max = nums[i];\\n\\t\\tfor (int j = i; j < n; j++) {\\n\\t\\t\\tmin = Math.min(min, nums[j]);\\n\\t\\t\\tmax = Math.max(max, nums[j]);\\n\\t\\t\\tres += max - min;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```\\n\\n----\\n### \\u2714\\uFE0F Solution 2: Stack\\n#### Intuition\\nsum of subarray range = sum of subarray max - sum of subarray min\\n\\nto calculate the subarray max/min, we can use monotonic stack \\n(for more information, could refer to [monotonic queue summary | LeetCode](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/204290/Monotonic-Queue-Summary))\\n- max: decreasing stack\\n- min: increasing stack\\n\\n\\n#### Explanation\\n1. given a current index `i`, pop out all index `cur` from stack where `nums[cur] <= nums[i]`\\n2. when pop out a index `cur` from stack, the left boundary is `stack.peek()`, right boundary is `i`\\nthe times of `nums[cur]` being max is `|left boundary - cur| * |right boundary - cur|`\\nthe sum of max at cur = `|left boundary - cur| * |right boundary - cur| * nums[cur]` \\n\\n3. after the traversing all nums, the rest elements in stack can be handled in the similar way.\\nleft boundary: `stack.peek()`, right boundary: `n`\\n\\n#### Complexity\\nTime: `O(n)`\\nSpace: `O(n)`\\n#### Java\\n```\\npublic long subArrayRanges(int[] nums) {\\n\\tint n = nums.length;\\n\\tlong sum = 0;\\n\\tDeque<Integer> q = new ArrayDeque<>(); // store index\\n\\n\\tq.add(-1);\\n\\tfor (int i = 0; i <= n; i++) {\\n\\t\\twhile (q.peekLast() != -1 && (i == n || nums[q.peekLast()] <= nums[i])) {\\n\\t\\t\\tint cur = q.removeLast();\\n\\t\\t\\tint left = q.peekLast();\\n\\t\\t\\tint right = i;\\n\\t\\t\\tsum += 1L * (cur - left) * (right - cur) * nums[cur];\\n\\t\\t}\\n\\t\\tq.add(i);\\n\\t}\\n\\n\\tq.clear();\\n\\tq.add(-1);\\n\\tfor (int i = 0; i <= n; i++) {\\n\\t\\twhile (q.peekLast() != -1 && (i == n || nums[q.peekLast()] >= nums[i])) {\\n\\t\\t\\tint cur = q.removeLast();\\n\\t\\t\\tint left = q.peekLast();\\n\\t\\t\\tint right = i;\\n\\t\\t\\tsum -= 1L * (cur - left) * (right - cur) * nums[cur];\\n\\t\\t}\\n\\t\\tq.add(i);\\n\\t}\\n\\treturn sum;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic long subArrayRanges(int[] nums) {\\n\\tint n = nums.length;\\n\\tlong res = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint min = nums[i], max = nums[i];\\n\\t\\tfor (int j = i; j < n; j++) {\\n\\t\\t\\tmin = Math.min(min, nums[j]);\\n\\t\\t\\tmax = Math.max(max, nums[j]);\\n\\t\\t\\tres += max - min;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```\n```\\npublic long subArrayRanges(int[] nums) {\\n\\tint n = nums.length;\\n\\tlong sum = 0;\\n\\tDeque<Integer> q = new ArrayDeque<>(); // store index\\n\\n\\tq.add(-1);\\n\\tfor (int i = 0; i <= n; i++) {\\n\\t\\twhile (q.peekLast() != -1 && (i == n || nums[q.peekLast()] <= nums[i])) {\\n\\t\\t\\tint cur = q.removeLast();\\n\\t\\t\\tint left = q.peekLast();\\n\\t\\t\\tint right = i;\\n\\t\\t\\tsum += 1L * (cur - left) * (right - cur) * nums[cur];\\n\\t\\t}\\n\\t\\tq.add(i);\\n\\t}\\n\\n\\tq.clear();\\n\\tq.add(-1);\\n\\tfor (int i = 0; i <= n; i++) {\\n\\t\\twhile (q.peekLast() != -1 && (i == n || nums[q.peekLast()] >= nums[i])) {\\n\\t\\t\\tint cur = q.removeLast();\\n\\t\\t\\tint left = q.peekLast();\\n\\t\\t\\tint right = i;\\n\\t\\t\\tsum -= 1L * (cur - left) * (right - cur) * nums[cur];\\n\\t\\t}\\n\\t\\tq.add(i);\\n\\t}\\n\\treturn sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1624416,
                "title": "python3-stack",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/f57038d6cca9ccb356a137b3af67fba615a067dd) for solutions of weekly 271. \\n\\n```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        \\n        def fn(op): \\n            \"\"\"Return min sum (if given gt) or max sum (if given lt).\"\"\"\\n            ans = 0 \\n            stack = []\\n            for i in range(len(nums) + 1): \\n                while stack and (i == len(nums) or op(nums[stack[-1]], nums[i])): \\n                    mid = stack.pop()\\n                    ii = stack[-1] if stack else -1 \\n                    ans += nums[mid] * (i - mid) * (mid - ii)\\n                stack.append(i)\\n            return ans \\n        \\n        return fn(lt) - fn(gt)\\n```\\n\\n**Related problems**\\n[907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/949064/Python3-stack-O(N))",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        \\n        def fn(op): \\n            \"\"\"Return min sum (if given gt) or max sum (if given lt).\"\"\"\\n            ans = 0 \\n            stack = []\\n            for i in range(len(nums) + 1): \\n                while stack and (i == len(nums) or op(nums[stack[-1]], nums[i])): \\n                    mid = stack.pop()\\n                    ii = stack[-1] if stack else -1 \\n                    ans += nums[mid] * (i - mid) * (mid - ii)\\n                stack.append(i)\\n            return ans \\n        \\n        return fn(lt) - fn(gt)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927221,
                "title": "complete-explanation-intuition-explained-with-images-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Rather than checking for all subarrays of nums and finding the largest and smallest of all subarrays, we can reduce our calculations\\n- We can simply **find the contribution of each element of nums in the final answer**\\n- So now problem  boils down to three  tasks \\n    - For each element in nums find the **number of subarrays in which that element is minimum** [Let count of such subarrays be **minCount**]\\n    - For each element in nums find the **number of subarrays in which that element is maximum** [Let count of such subarrays be **maxCount**]\\n    - (1)Contribution of each element = **+(maxCount * nums[i])**\\n     (2)Contribution of each element = **-(minCount * nums[i])**                              \\n\\n\\n//=======================================================================================================================\\n**### Task to calculate [Number of subarrays in which nums[i] is minimum]**\\n\\n- Let us first find the range in which nums[i] remains minimum\\n- Any element (nums[i]) will **remain minimum till an element, smaller than it is found**\\n- So for the **left bound** of range = find the **first smaller element than nums[i] to it\\'s left**\\n- So for the **right bound** of range = find the **first smaller element than nums[i] to it\\'s right**\\n**IMP**=>[A correction to these statements will be made later, with the reason for change explained \\uD83D\\uDC47]\\n\\n![mohak2.JPG](https://assets.leetcode.com/users/images/8e1cc2bb-1cb4-45dd-b272-762b5d4507a6_1671422369.3013868.jpeg)\\n\\n- Consider the above array\\n    - **For i = 3, nums[i] = 4**\\n        - First element smaller to it\\'s left = 2 [nums[0]]\\n        - First element smaller to it\\'s right = 1 [nums[6]]\\n        - Range in which (nums[3] = 4) is smallest => (i = 1 to i = 5 )\\n        - [4, 6, **4**, 14, 5] is the range in which nums[3] = 4 is minimum\\n        \\n- So we have got the range in which nums[i] is minimum\\n- Now task is to count all the subarrays from this range which contains nums[3] = 4 in it\\n- Consider **nums[3] = 4 as the pivot element which is compulsory to include** in all subarrays and elements to left as [4, 6] and elements to right as [14, 5], Then all subarrays will be as follows =>\\n\\n![mohak3.JPG](https://assets.leetcode.com/users/images/cdd1d14b-5888-4ba2-99d1-4a1475c22883_1671423633.54998.jpeg)\\n\\n- So pivot =4\\n    left elements = [\\' \\', 4, 6] = [leftCount = 3]\\n    right elements = [\\' \\', 14, 5] = [rightCount = 3]\\n    **(left combinations) , 4, (right combinations)**\\n    **([\\'\\'], [6], [4, 6]) , 4 , ([14], [14, 5], [\\'\\'])**\\n\\n\\n- Now just do cross product to get the above subarrays\\n\\t- Eg=> \\n\\t\\t\\t\\t  [\\'\\'] + 4 + [14] = [4, 14]\\n\\t\\t\\t\\t  [\\'\\'] + 4 + [14, 5] = [4, 14, 5]\\n\\t\\t\\t\\t  [\\'\\'] + 4 + [\\'\\'] = [4]\\n\\t\\t\\t\\t  [6] + 4 + [14] = [6, 4, 14]\\n\\t\\t\\t\\t  [6] + 4 + [14, 5] = [6, 4, 14, 5]\\n\\t\\t\\t\\t  [6] + 4 + [\\'\\'] = [6, 4]\\n\\t\\t\\t\\t  [4, 6] + 4 + [14] = [4, 6, 4, 15]\\n\\t\\t\\t\\t  [4, 6] + 4 + [14, 5] = [4, 6, 4, 14, 5]\\n\\t\\t\\t\\t  [4, 6] + 4 + [\\'\\'] = [4, 6, 4]\\n\\t\\t\\t\\t  \\n-Total subarrays = (3 * 3) = 9, \\n-Thus **subarray count = (left range elements count) * (right range elements count)**\\n\\n**Similarly we can do for the MAXIMUM CASE**\\n//========================================================================================================================================\\n\\n- So we got our approach, **but NO :(**\\n- We missed the cases where we are doing duplicated calculations\\n- In our case see for elements **(nums[1] = 4) and (nums[3] = 4)**, we are duplicating some subarrays of we go by our approach =>\\n\\n![mohak4.JPG](https://assets.leetcode.com/users/images/c465de65-6f03-4fdc-abee-d2824c8c4ee4_1671425113.44709.jpeg)\\n\\n- As we can see subarrays like [4, 6, 4] is being duplicated here\\n- This duplicacy will happen for duplicate elements in the same range\\n- We need to count  these subarrays\\'s answer only once\\n- So a solution to prevent this duplicacy would be =>\\n\\t- As we will be traversing the arrays from left to right\\n\\t- We give the responsibility for the right duplicate to handle all subarrays\\n\\t\\t- For any element\\n\\t\\t- **Left bound = find the first  element strictly smaller than curr** (to the left)\\n\\t\\t- **Right bound = find the first element smaller than equal to curr** (to the right)\\n\\t- Rest everything will remains same\\n\\n\\n//=======================================================================================================================================\\n\\n**Final Algo**\\n1. Find the **first left strictly smaller** element using monotonic stack\\n   Find the **first right smaller or equal** element using monotonic stack\\n\\n2. Find the  **first left strictly greater** element using monotonic stack method\\n    Find the  **first right greater or equal** element using monotonic stack method\\n\\n3. Calculate the range \\n4. Calculate the number of subarrays in which the curr element contributes\\n5. Add/subtract contribution of each element in final answer\\n \\n\\n//=========================================================================================================================================\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getPrevious(vector<int>&nums, bool isPrevSmall)\\n    {\\n        //(isPrevSmall = true) ===> previous smaller element problem using stack\\n        //(isPrevSmall = false) ==> previous greater element problem using stack\\n        //There could me many ways to solve this using monotonic stack, simpler way shown below\\n        int n = nums.size();\\n        stack<int>st;\\n        vector<int>ans(n, -1);\\n        st.push(n - 1);\\n        for (int i = n - 2; i >= 0; i--)\\n        {\\n            int curr = nums[i];\\n            //============================================\\n            while(!st.empty())\\n            {\\n                bool condition = (isPrevSmall)? (curr < nums[st.top()]) : (curr > nums[st.top()]);\\n                if (condition == true)\\n                {\\n                    ans[st.top()] = i;\\n                    st.pop();\\n                }\\n                else break;\\n            }\\n            //=================================================\\n            st.push(i);\\n        }\\n        return ans;    \\n    }\\n    vector<int> getNext(vector<int>&nums, bool isNextSmall)\\n    {\\n        //(isPrevSmall = true) ===> next smaller/equal element problem using stack\\n        //(isPrevSmall = false) ==> next smaller/equal element problem using stack\\n        int n = nums.size();\\n        vector<int>ans(n, n);\\n        stack<int>st;\\n        st.push(0);\\n        for (int i = 1; i < n; i++)\\n        {\\n            int curr = nums[i];\\n            //======================================\\n            while(!st.empty())\\n            {\\n                int topIdx = st.top();\\n                bool condition = (isNextSmall)? (curr <= nums[topIdx]) : (curr >= nums[topIdx]);\\n\\t\\t\\t\\t//DON\\'T MISS THE \"EQUAL TO\" CASE :)\\n                if (condition == true)\\n                {\\n                    ans[topIdx] = i;\\n                    st.pop();\\n                }\\n                else break;\\n            }\\n            //===================================================\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n    long long subArrayRanges(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int>prevSmaller = getPrevious(nums, true);\\n        vector<int>prevGreater = getPrevious(nums, false);\\n        //===================================================\\n        vector<int>nextSmaller = getNext(nums, true);\\n        vector<int>nextGreater = getNext(nums, false);\\n        //=======================================================\\n        long long ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int prevRangeCount = i - prevSmaller[i];\\n            int nextRangeCount = nextSmaller[i] - i;\\n            long long minSubarrayCount = (long long)prevRangeCount * nextRangeCount;\\n            ans = ans - (long long)(nums[i] * minSubarrayCount);\\n            \\n            int prevRangeCount1 = i - prevGreater[i];\\n            int nextRangeCount1 = nextGreater[i] - i;\\n            long long maxSubarrayCount = prevRangeCount1 * nextRangeCount1;\\n            ans = ans + (long long)(nums[i] * maxSubarrayCount);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getPrevious(vector<int>&nums, bool isPrevSmall)\\n    {\\n        //(isPrevSmall = true) ===> previous smaller element problem using stack\\n        //(isPrevSmall = false) ==> previous greater element problem using stack\\n        //There could me many ways to solve this using monotonic stack, simpler way shown below\\n        int n = nums.size();\\n        stack<int>st;\\n        vector<int>ans(n, -1);\\n        st.push(n - 1);\\n        for (int i = n - 2; i >= 0; i--)\\n        {\\n            int curr = nums[i];\\n            //============================================\\n            while(!st.empty())\\n            {\\n                bool condition = (isPrevSmall)? (curr < nums[st.top()]) : (curr > nums[st.top()]);\\n                if (condition == true)\\n                {\\n                    ans[st.top()] = i;\\n                    st.pop();\\n                }\\n                else break;\\n            }\\n            //=================================================\\n            st.push(i);\\n        }\\n        return ans;    \\n    }\\n    vector<int> getNext(vector<int>&nums, bool isNextSmall)\\n    {\\n        //(isPrevSmall = true) ===> next smaller/equal element problem using stack\\n        //(isPrevSmall = false) ==> next smaller/equal element problem using stack\\n        int n = nums.size();\\n        vector<int>ans(n, n);\\n        stack<int>st;\\n        st.push(0);\\n        for (int i = 1; i < n; i++)\\n        {\\n            int curr = nums[i];\\n            //======================================\\n            while(!st.empty())\\n            {\\n                int topIdx = st.top();\\n                bool condition = (isNextSmall)? (curr <= nums[topIdx]) : (curr >= nums[topIdx]);\\n\\t\\t\\t\\t//DON\\'T MISS THE \"EQUAL TO\" CASE :)\\n                if (condition == true)\\n                {\\n                    ans[topIdx] = i;\\n                    st.pop();\\n                }\\n                else break;\\n            }\\n            //===================================================\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n    long long subArrayRanges(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int>prevSmaller = getPrevious(nums, true);\\n        vector<int>prevGreater = getPrevious(nums, false);\\n        //===================================================\\n        vector<int>nextSmaller = getNext(nums, true);\\n        vector<int>nextGreater = getNext(nums, false);\\n        //=======================================================\\n        long long ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int prevRangeCount = i - prevSmaller[i];\\n            int nextRangeCount = nextSmaller[i] - i;\\n            long long minSubarrayCount = (long long)prevRangeCount * nextRangeCount;\\n            ans = ans - (long long)(nums[i] * minSubarrayCount);\\n            \\n            int prevRangeCount1 = i - prevGreater[i];\\n            int nextRangeCount1 = nextGreater[i] - i;\\n            long long maxSubarrayCount = prevRangeCount1 * nextRangeCount1;\\n            ans = ans + (long long)(nums[i] * maxSubarrayCount);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732394,
                "title": "python-3-two-monotonic-stacks-o-n-time-o-n-space",
                "content": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        res = 0\\n        min_stack, max_stack = [], []\\n        n = len(nums)\\n        nums.append(0)\\n        for i, num in enumerate(nums):\\n            while min_stack and (i == n or num < nums[min_stack[-1]]):\\n                top = min_stack.pop()\\n                starts = top - min_stack[-1] if min_stack else top + 1\\n                ends = i - top\\n                res -= starts * ends * nums[top]             \\n            min_stack.append(i)       \\n            while max_stack and (i == n or num > nums[max_stack[-1]]):\\n                top = max_stack.pop()\\n                starts = top - max_stack[-1] if max_stack else top + 1\\n                ends = i - top\\n                res += starts * ends * nums[top]            \\n            max_stack.append(i)    \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        res = 0\\n        min_stack, max_stack = [], []\\n        n = len(nums)\\n        nums.append(0)\\n        for i, num in enumerate(nums):\\n            while min_stack and (i == n or num < nums[min_stack[-1]]):\\n                top = min_stack.pop()\\n                starts = top - min_stack[-1] if min_stack else top + 1\\n                ends = i - top\\n                res -= starts * ends * nums[top]             \\n            min_stack.append(i)       \\n            while max_stack and (i == n or num > nums[max_stack[-1]]):\\n                top = max_stack.pop()\\n                starts = top - max_stack[-1] if max_stack else top + 1\\n                ends = i - top\\n                res += starts * ends * nums[top]            \\n            max_stack.append(i)    \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1673144,
                "title": "c-solution-o-n-2-to-o-n-detailed-explanation-with-walkthrough-of-tricky-test-cases",
                "content": "# **Approach 1 - By considering every subsegment (Brute Force):-**\\n# \\n\\u25CF\\tWe will discover every possible subsegment while storing the minimum and maximum elements.\\n\\u25CF\\tAlso, we will keep adding the difference between the maximum and minimum values in every iteration.\\n\\n**C++ CODE:-** \\n\\n```\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\n\\nlong ValueOfA(int n, vector<int> &A)\\n{\\n    long ans = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        int mx = A[i], mn = A[i];\\n        for (int j = i + 1; j < n; j++)\\n        {\\n            mx = max(mx, A[j]);\\n            mn = min(mn, A[j]);\\n\\n            ans += (mx - mn);\\n        }\\n    }\\n    return ans;\\n}\\n\\nint main()\\n{\\n    int n;\\n    cin >> n;\\n    vector<int> A(n);\\n    for (int i = 0; i < n; i++)\\n        cin >> A[i];\\n    cout << ValueOfA(n, A);\\n}\\n```\\n\\n**Time Complexity -** *O(n^2)* \\u2013 As we are just iterating n times for every element. [where n is the length of the array].\\n**Space Complexity -** *O(1)* - As we just used 2 extra variables for storing maximum and minimum values, and no extra space.\\n\\n\\n***\\n\\n# **Approach 2 - By finding The Next Greater and Next Smaller Elements on left and right (Optimized):-** \\n\\n\\u25CF\\tWe will take the contribution of each element as addition/subtraction in the final answer.\\n\\u25CF\\tStanding on an element, if we see on the subsegments going on the right-hand side of it, the element will act as the minimum, till the elements are greater than it; i.e we need to find the next just smaller element than the current element on the right-hand side of it.\\n\\u25CF\\tSimilarly, it will act as the maximum, till the elements are smaller than it; i.e we need to find the next just greater element than the current element on the right-hand side of it.\\n\\u25CF\\tThe same is the case with the left-hand side.\\n\\u25CF\\tThus for a particular element, we will store the count of elements that are smaller, and that are greater; for both the left-hand side and the right-hand side.\\n\\u25CF\\tAs we know the counts, then for a particular element we will add to the final answer - [currentElement * cgl * cgr].  As this will be the contribution of the current element being as a maximum in all the subsegments, in which it is occurring.\\nSimilarly, for a particular element we will subtract from the final answer - [currentElement * csl * csr].  As this will be the contribution of the current element being as a minimum in all the subsegments, in which it is occurring.\\n\\n\\u25CF\\tThis can be done using stacks. We will store the indices of elements in the stack.\\n\\u25CF\\tFor finding the count of greater elements on left (cgl) and count of greater elements on right (cgr), we will keep popping the elements in the stack until it is not empty and the top element of the stack is less than or equal to the current element. \\nSo the current element will be the next greater element on the right of all the elements that are popped, and the difference between their positions will be the value of cgr for all the popped elements.\\n\\tAnd the current top element of the stack, due to which the popping was stopped will be the next greater element on left for the current element, and the difference between their positions will be the value of cgl for the current element.\\n\\u25CF\\tSimilarly, for finding the count of smaller elements on left (csl) and count of smaller elements on right (csr), we will keep popping the elements in the stack until it is not empty and the top element of the stack is greater than or equal to the current element. \\nSo the current element will be the next smaller element on the right of all the elements that are popped, and the difference between their positions will be the value of csr for all the popped elements.\\n\\tAnd the current top element of the stack, due to which the popping was stopped will be the next greater smaller on left for the current element, and the difference between their positions will be the value of csl for the current element.\\n\\n\\u25CF\\tThe remaining elements in the stack will have the values of cgl, csl, cgr, csr, as the default initial values.\\n\\u25CF\\tThe default initial value of cgl and csl for every element will be their index + 1 (the count of elements before it, including itself). And the default initial value of cgr and csr for every element will be their n - 1 (the count of elements after it, including itself).\\n\\n**C++ Code:-**\\n```\\nclass Pair\\n{\\npublic:\\n    int cgl, csl, cgr, csr;\\n    Pair()\\n    {\\n        this->cgl = 0;\\n        this->csl = 0;\\n        this->cgr = 0;\\n        this->csr = 0;\\n    }\\n};\\n\\nvoid fill_cgl_cgr(int n, vector<int> &A, vector<Pair> &conf)\\n{\\n    stack<int> st;\\n    for (int i = 0; i < n; i++)\\n    {\\n        while (!st.empty() && A[i] >= A[st.top()])\\n        {\\n            conf[st.top()].cgr = i - st.top();\\n            st.pop();\\n        }\\n        if (!st.empty())\\n            conf[i].cgl = i - st.top();\\n        st.push(i);\\n    }\\n}\\n\\nvoid fill_csl_csr(int n, vector<int> &A, vector<Pair> &conf)\\n{\\n    stack<int> st;\\n    for (int i = 0; i < n; i++)\\n    {\\n        while (!st.empty() && A[i] <= A[st.top()])\\n        {\\n            conf[st.top()].csr = i - st.top();\\n            st.pop();\\n        }\\n        if (!st.empty())\\n            conf[i].csl = i - st.top();\\n        st.push(i);\\n    }\\n}\\n\\nlong long ValueOfA(int n, vector<int> &A)\\n{\\n    long long ans = 0;\\n\\n    vector<Pair> conf(n);\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        conf[i].cgl = i + 1;\\n        conf[i].csl = i + 1;\\n        conf[i].cgr = n - i;\\n        conf[i].csr = n - i;\\n    }\\n\\n    fill_cgl_cgr(n, A, conf);\\n    fill_csl_csr(n, A, conf);\\n\\n    for (int i = 0; i < n; i++)\\n        ans += A[i] * (((long long)conf[i].cgl * conf[i].cgr) - ((long long)conf[i].csl * conf[i].csr));\\n\\n    return ans;\\n}\\nint main()\\n{\\n    int n;\\n    cin >> n;\\n    vector<int> A(n);\\n    for (int i = 0; i < n; i++)\\n        cin >> A[i];\\n    cout << ValueOfA(n, A);\\n}\\n```\\n\\n\\n**Time Complexity -** *O(n)* - As we are finding the values of cgl, cgr in linear time, and also the values of csl and csr in linear time. And then finding the contribution of each element in the linear time.\\n\\n**Space complexity -** *O(n)* - As we are storing the values of cgl, cgr, csl, csr in a linear array of size n. And also the stack space of size n (maximum).\\n\\n\\n\\n\\n**Test Cases:-**\\n\\n**Input1:** nums = [3,5,8,2]\\n**Output1:** 28\\n\\n**Explanation1:**\\n\\nFor every element x, we will do the following:\\nx = 3 -> cgl = 1, cgr = 1, csl = 1, csr = 3 -> contribution = 3*(1*1 - 1*3) = -6\\nx = 5 -> cgl = 2, cgr = 1, csl = 1, csr = 2 -> contribution = 5*(2*1 - 1*2) = 0\\nx = 8 -> cgl = 3, cgr = 2, csl = 1, csr = 1 -> contribution = 8*(3*2 - 1*1) = 40\\nx = 2 -> cgl = 1, cgr = 1, csl = 4, csr = 1 -> contribution = 2*(1*1 - 4*1) = -6\\n\\nSo the sum of all values is = (-6) + 0 + 40 + (-6) = 28.\\n\\n\\n**Input2:** nums = [1,3,3,1,2]\\n**Output2:** 17\\n\\n**Explanation2:**\\n\\nFor every element x, we will do the following:\\nx = 1 -> cgl = 1, cgr = 1, csl = 1, csr = 3 -> contribution = 1*(1*1 - 1*3) = -2\\nx = 3 -> cgl = 2, cgr = 1, csl = 1, csr = 1 -> contribution = 3*(2*1 - 1*1) = 3\\nx = 3 -> cgl = 3, cgr = 3, csl = 2, csr = 1 -> contribution = 3*(3*3 - 2*1) = 21\\nx = 1 -> cgl = 1, cgr = 1, csl = 4, csr = 2 -> contribution = 1*(1*1 - 4*2) = -7\\nx = 2 -> cgl = 2, cgr = 1, csl = 1, csr = 1 -> contribution = 2*(2*1 - 1*1) = 2\\n\\nSo the sum of all values is = (-2) + 3 + 21 + (-8) + 2 = 17.\\n\\n(Note that just for cgr, csr values, we are also considering equal element as the next just greater/smaller element on the right)\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\n\\nlong ValueOfA(int n, vector<int> &A)\\n{\\n    long ans = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        int mx = A[i], mn = A[i];\\n        for (int j = i + 1; j < n; j++)\\n        {\\n            mx = max(mx, A[j]);\\n            mn = min(mn, A[j]);\\n\\n            ans += (mx - mn);\\n        }\\n    }\\n    return ans;\\n}\\n\\nint main()\\n{\\n    int n;\\n    cin >> n;\\n    vector<int> A(n);\\n    for (int i = 0; i < n; i++)\\n        cin >> A[i];\\n    cout << ValueOfA(n, A);\\n}\\n```\n```\\nclass Pair\\n{\\npublic:\\n    int cgl, csl, cgr, csr;\\n    Pair()\\n    {\\n        this->cgl = 0;\\n        this->csl = 0;\\n        this->cgr = 0;\\n        this->csr = 0;\\n    }\\n};\\n\\nvoid fill_cgl_cgr(int n, vector<int> &A, vector<Pair> &conf)\\n{\\n    stack<int> st;\\n    for (int i = 0; i < n; i++)\\n    {\\n        while (!st.empty() && A[i] >= A[st.top()])\\n        {\\n            conf[st.top()].cgr = i - st.top();\\n            st.pop();\\n        }\\n        if (!st.empty())\\n            conf[i].cgl = i - st.top();\\n        st.push(i);\\n    }\\n}\\n\\nvoid fill_csl_csr(int n, vector<int> &A, vector<Pair> &conf)\\n{\\n    stack<int> st;\\n    for (int i = 0; i < n; i++)\\n    {\\n        while (!st.empty() && A[i] <= A[st.top()])\\n        {\\n            conf[st.top()].csr = i - st.top();\\n            st.pop();\\n        }\\n        if (!st.empty())\\n            conf[i].csl = i - st.top();\\n        st.push(i);\\n    }\\n}\\n\\nlong long ValueOfA(int n, vector<int> &A)\\n{\\n    long long ans = 0;\\n\\n    vector<Pair> conf(n);\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        conf[i].cgl = i + 1;\\n        conf[i].csl = i + 1;\\n        conf[i].cgr = n - i;\\n        conf[i].csr = n - i;\\n    }\\n\\n    fill_cgl_cgr(n, A, conf);\\n    fill_csl_csr(n, A, conf);\\n\\n    for (int i = 0; i < n; i++)\\n        ans += A[i] * (((long long)conf[i].cgl * conf[i].cgr) - ((long long)conf[i].csl * conf[i].csr));\\n\\n    return ans;\\n}\\nint main()\\n{\\n    int n;\\n    cin >> n;\\n    vector<int> A(n);\\n    for (int i = 0; i < n; i++)\\n        cin >> A[i];\\n    cout << ValueOfA(n, A);\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1624339,
                "title": "python3-better-brute-force-accepted",
                "content": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        answ=0\\n        for i in range(n):\\n            minSub=maxSub=nums[i]\\n            for j in range(i+1,n):\\n                minSub=min(minSub,nums[j])\\n                maxSub=max(maxSub,nums[j])\\n                answ+=maxSub-minSub\\n        return answ\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        answ=0\\n        for i in range(n):\\n            minSub=maxSub=nums[i]\\n            for j in range(i+1,n):\\n                minSub=min(minSub,nums[j])\\n                maxSub=max(maxSub,nums[j])\\n                answ+=maxSub-minSub\\n        return answ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206694,
                "title": "c-two-approaches-clean-code",
                "content": "### **Approach 1: Brute force O(N^2).**\\n\\nclass Solution {\\npublic:\\n\\n    long long subArrayRanges(vector<int>& nums) {\\n        long long ans = 0;\\n        \\n        for(int i=0; i<nums.size(); ++i){\\n            int mine = nums[i], maxe = nums[i];\\n            for(int j=i; j<nums.size(); ++j){\\n                mine = min(nums[j], mine);\\n                maxe = max(nums[j], maxe);\\n                ans += (maxe - mine);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n### **Approach 2: Using vector as stack O(N)**\\n\\nclass Solution {\\npublic:\\n\\n    long long subArrayRanges(vector<int>& nums) {\\n        int n = nums.size();\\n        long long sum = 0;\\n        vector<int> v;\\n        vector<int> prevMin(n, -1), nextMin(n, n), prevMax(n, -1), nextMax(n, n);\\n        \\n        for(int i=0; i<n; ++i){\\n            while(!v.empty() and nums[i] <= nums[v.back()]) v.pop_back();\\n            if(!v.empty()) prevMin[i] = v.back();\\n            v.push_back(i);\\n        }\\n        \\n        v.clear();\\n        \\n        for(int i=n-1; i>=0; --i){\\n            while(!v.empty() and nums[i] < nums[v.back()]) v.pop_back();\\n            if(!v.empty()) nextMin[i] = v.back();\\n            v.push_back(i);\\n        }\\n        \\n        v.clear();\\n        \\n        for(int i=0; i<n; ++i){\\n            while(!v.empty() and nums[i] >= nums[v.back()]) v.pop_back();\\n            if(!v.empty()) prevMax[i] = v.back();\\n            v.push_back(i);\\n        }\\n        \\n        v.clear();\\n        \\n        for(int i=n-1; i>=0; --i){\\n            while(!v.empty() and nums[i] > nums[v.back()]) v.pop_back();\\n            if(!v.empty()) nextMax[i] = v.back();\\n            v.push_back(i);\\n        }\\n        \\n        for(int i=0; i<n; ++i){\\n            long long leftMin = i - prevMin[i];\\n            long long rightMin = nextMin[i] - i;\\n            long long leftMax = i - prevMax[i];\\n            long long rightMax = nextMax[i] - i;\\n            \\n            sum += (leftMax*rightMax - leftMin*rightMin)*nums[i];\\n        }\\n        return sum;\\n    }\\n};\\n\\nFor detailed explaination refer to this masterpiece: https://leetcode.com/problems/sum-of-subarray-ranges/discuss/1626628/O(n)-solution-with-monotonous-stack-oror-Full-explaination\\n\\nNote: For better understanding and learning, consider dry running the code yourself.\\nFor doubt or query comment below.\\n**PLEASE UPVOTE IF HELPFUL!!!**",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n    long long subArrayRanges(vector<int>& nums) {\\n        long long ans = 0;\\n        \\n        for(int i=0; i<nums.size(); ++i){\\n            int mine = nums[i], maxe = nums[i];\\n            for(int j=i; j<nums.size(); ++j){\\n                mine = min(nums[j], mine);\\n                maxe = max(nums[j], maxe);\\n                ans += (maxe - mine);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1978628,
                "title": "python3-monotonus-stack-o-n",
                "content": "```\\n\"\"\"\\nif you are not sure what is monotonous stack go through the concept given in this post:\\n\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/discuss/178876/stack-solution-with-very-detailed-explanation-step-by-step\\n\\nhttps://leetcode.com/problems/sum-of-subarray-ranges/discuss/1624268/Reformulate-Problem-O(n)\\n\"\"\"\\n\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        \"\"\"\\n        [4,-2,-3,4,1]\\n        \\n        \"\"\"\\n        n = len(nums)\\n        \\n        min_stack = []\\n        min_sum = 0\\n\\n        for i in range(n + 1):\\n            while min_stack and nums[min_stack[-1]] > (nums[i] if i < n else -float(\\'Inf\\')):\\n                j = min_stack.pop()\\n                k = min_stack[-1] if min_stack else -1\\n                min_sum += (j - k) * (i - j) * nums[j]\\n            min_stack.append(i)\\n        \\n        max_stack = []\\n        max_sum = 0\\n        for i in range(n + 1):\\n            while max_stack and nums[max_stack[-1]] < (nums[i] if i < n else float(\\'Inf\\')):\\n                j = max_stack.pop()\\n                k = max_stack[-1] if max_stack else -1\\n                max_sum += (j - k) * (i - j) * nums[j]\\n\\n            max_stack.append(i)\\n        \\n        ans = max_sum - min_sum\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\nif you are not sure what is monotonous stack go through the concept given in this post:\\n\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/discuss/178876/stack-solution-with-very-detailed-explanation-step-by-step\\n\\nhttps://leetcode.com/problems/sum-of-subarray-ranges/discuss/1624268/Reformulate-Problem-O(n)\\n\"\"\"\\n\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        \"\"\"\\n        [4,-2,-3,4,1]\\n        \\n        \"\"\"\\n        n = len(nums)\\n        \\n        min_stack = []\\n        min_sum = 0\\n\\n        for i in range(n + 1):\\n            while min_stack and nums[min_stack[-1]] > (nums[i] if i < n else -float(\\'Inf\\')):\\n                j = min_stack.pop()\\n                k = min_stack[-1] if min_stack else -1\\n                min_sum += (j - k) * (i - j) * nums[j]\\n            min_stack.append(i)\\n        \\n        max_stack = []\\n        max_sum = 0\\n        for i in range(n + 1):\\n            while max_stack and nums[max_stack[-1]] < (nums[i] if i < n else float(\\'Inf\\')):\\n                j = max_stack.pop()\\n                k = max_stack[-1] if max_stack else -1\\n                max_sum += (j - k) * (i - j) * nums[j]\\n\\n            max_stack.append(i)\\n        \\n        ans = max_sum - min_sum\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624617,
                "title": "o-n-monostack-c",
                "content": "1. the sum of the range of all subarray => sum of the max of all subarray - the sum of the min of all subarray.\\n1. the sum of max for all subarray => for each element, **find the subarray that it remains the max element**\\n1. how to determine the subarray range```[i...max....j]```? we need to **find the previous and next greater**\\n1. previous and next greater problem is the keyword to think about the mono stack\\n1. for an decreasing mono stack, when the new element num break the constraint, \\n    1. the num is the next greater element\\n    1. the stack[-1] is the max element for this subarray. \\n    1. the stack[-2] is the prev greater element\\n1. so we know the possible choice for i, j in the ```[i....max...j]```, the answer for this element is num * left * right\\n1. common trick for the mono stack is to put a -1 marker in the stack and an n marker in the input array.\\n2. another trick is to convert nums to negetive, so the max_range could be re-used for the min_range \\n\\u200B\\n```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        vector<int> r = nums;\\n        for (int i = 0; i < r.size(); i++) {\\n            r[i] = -1 * r[i];\\n        }\\n        return max_range(nums) + max_range(r);\\n    }\\n    \\n    long long max_range(vector<int>& nums) {\\n        stack<pair<int,int>> stk({{-1, INT_MAX}});// i, val\\n        long long ans = 0;\\n        int n = nums.size();\\n        nums.push_back(INT_MAX);\\n        for (int i = 0; i < nums.size();i++) {\\n            int num = nums[i];\\n            while (num > stk.top().second){\\n                //find a max for a range\\n                auto [maxIdx, maxVal] = stk.top(); stk.pop();\\n                auto [prevIdx, _] = stk.top();\\n                int l = maxIdx - prevIdx;\\n                int r = i - maxIdx;\\n                ans += (long long)maxVal * l * r;\\n            }\\n            stk.push({i, num});\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```[i...max....j]```\n```[i....max...j]```\n```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        vector<int> r = nums;\\n        for (int i = 0; i < r.size(); i++) {\\n            r[i] = -1 * r[i];\\n        }\\n        return max_range(nums) + max_range(r);\\n    }\\n    \\n    long long max_range(vector<int>& nums) {\\n        stack<pair<int,int>> stk({{-1, INT_MAX}});// i, val\\n        long long ans = 0;\\n        int n = nums.size();\\n        nums.push_back(INT_MAX);\\n        for (int i = 0; i < nums.size();i++) {\\n            int num = nums[i];\\n            while (num > stk.top().second){\\n                //find a max for a range\\n                auto [maxIdx, maxVal] = stk.top(); stk.pop();\\n                auto [prevIdx, _] = stk.top();\\n                int l = maxIdx - prevIdx;\\n                int r = i - maxIdx;\\n                ans += (long long)maxVal * l * r;\\n            }\\n            stk.push({i, num});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475446,
                "title": "python-monostack-explanation-o-n-time-and-space",
                "content": "\\'\\'\\'\\nThere are alot of good answers that explains max_sum and min_sum initiative \\nHere I will try to explain how I analyzed and solved this monotonic stack problem\\n\\nAssuming you are familiar with monotonic stack but don\\'t know how to write the \"while\" part that pops the stack\\n\\nLet\\'s go with an example:\\n\\nnums = [2,3,4,1,5]\\n\\n5|----------X\\n4|----X\\n3| --X \\n2| X        \\n1|-------X   \\n---------------------------\\n\\nStep 1: Let\\'s see how many ranges do we have and what they are\\n\\n2: [2] [2,3] [2,4] [2,1] [2,5]\\n3: [3] [3,4] [3,1] [3,5]\\n4: [4] [4,1] [4,5]\\n1: [1] [1,5]\\n2: [5]\\n\\nStep 2: Let\\'s maintain a monotonicly increasing stack to keep the minimum of ranges\\nas a thump of rule, we always process a number when we pop it\\nso if we add 2 and then 3 and then 4 to our stack, we don\\'t process anything\\n\\nSo let\\'s write down the structure\\n\\nStep 3: Let\\'s pop!\\nwhen we reach to 1 (remember we never process the current item in mono stack problems)\\nwe pop 4 and so we can say [4] is found here\\nnow let\\'s pop 3, at this point we know that there is no element less than 3 after index of 3 cause if it was we didn\\'t have 3\\nin our stack so i (index of current element in for) minus index of 3 is the range that we can surely say everything in between doesn\\'t matter and 3 is the minimum for them\\nso we have [3] and [3,4] here\\nnow we pop 2 and same as above we have [2] and [2,3] and [2,3,4]\\n\\nAs you can see, if we just care about the minimum, we might as well just say the sum of min for all of these fetched ranges are:\\n\\n2: [2] [2,3] [2,4]  min in all ranges is 2\\n3: [3] [3,4]  min in all ranges is 3\\n4: [4] min in all ranges is 4\\n\\nSo the formula would be poped_item * (poped_index - i)\\n\\nwe push 1 to the stack BTW ATM :D\\n\\nStep 4:\\nNow that we have 1 in stack we can put 5 in the stack but we just need to process these items\\nSo like others we can just add a Integer.MIN_VALUE or float(\"-inf\") to or input array to do the trick\\n\\nNo let\\'s pop!\\nJust like step 3 we can pop 5 and then 1 and after this round we have checked and know the min for all of the following ranges:\\n2: [2] [2,3] [2,4]\\n3: [3] [3,4]\\n4: [4] \\n1: [1] [1,5]\\n2: [5]\\n\\nBut we should have come up with the following list!\\n\\n2: [2] [2,3] [2,4] [2,1] [2,5]\\n3: [3] [3,4] [3,1] [3,5]\\n4: [4] [4,1] [4,5]\\n1: [1] [1,5]\\n2: [5]\\n\\nTo find the missed ranges we should have looked into our stack and see what\\'s on the top (that\\'s our minimum for missed ranges) and then multiply them by their distance to i\\nand if the stack is empty then we might have some elements in the stack that we already poped. we don\\'t care what they were cause the were obviously greater than 1 (in this case)\\nSo it\\'s safe to say that the INDEX of whatever is on top of the stack or -1 should be multipled by the element that we poped from the stack (min of all of those ranges)\\n\\nSame goes with sum_max (second pass with min mono stack)\\n\\n\\'\\'\\'\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        \\n        st = []\\n        sum_min = 0\\n        for i,n in enumerate(nums+[float(\"-inf\")]):\\n            while st and nums[st[-1]] > n:\\n                j = st.pop()\\n                poped = nums[j]\\n                k = -1\\n                if st:\\n                    k = st[-1]\\n                sum_min += poped * (i - j)*(j - k)\\n            st.append(i)\\n        \\n        st = []\\n        sum_max = 0\\n        for i,n in enumerate(nums+[float(\"inf\")]):\\n            while st and nums[st[-1]] < n:\\n                j = st.pop()\\n                poped = nums[j]\\n                k = -1\\n                if st:\\n                    k = st[-1]\\n                sum_max += poped * (i - j)*(j - k)\\n            st.append(i)\\n        \\n        return sum_max - sum_min",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "\\'\\'\\'\\nThere are alot of good answers that explains max_sum and min_sum initiative \\nHere I will try to explain how I analyzed and solved this monotonic stack problem\\n\\nAssuming you are familiar with monotonic stack but don\\'t know how to write the \"while\" part that pops the stack\\n\\nLet\\'s go with an example:\\n\\nnums = [2,3,4,1,5]\\n\\n5|----------X\\n4|----X\\n3| --X \\n2| X        \\n1|-------X   \\n---------------------------\\n\\nStep 1: Let\\'s see how many ranges do we have and what they are\\n\\n2: [2] [2,3] [2,4] [2,1] [2,5]\\n3: [3] [3,4] [3,1] [3,5]\\n4: [4] [4,1] [4,5]\\n1: [1] [1,5]\\n2: [5]\\n\\nStep 2: Let\\'s maintain a monotonicly increasing stack to keep the minimum of ranges\\nas a thump of rule, we always process a number when we pop it\\nso if we add 2 and then 3 and then 4 to our stack, we don\\'t process anything\\n\\nSo let\\'s write down the structure\\n\\nStep 3: Let\\'s pop!\\nwhen we reach to 1 (remember we never process the current item in mono stack problems)\\nwe pop 4 and so we can say [4] is found here\\nnow let\\'s pop 3, at this point we know that there is no element less than 3 after index of 3 cause if it was we didn\\'t have 3\\nin our stack so i (index of current element in for) minus index of 3 is the range that we can surely say everything in between doesn\\'t matter and 3 is the minimum for them\\nso we have [3] and [3,4] here\\nnow we pop 2 and same as above we have [2] and [2,3] and [2,3,4]\\n\\nAs you can see, if we just care about the minimum, we might as well just say the sum of min for all of these fetched ranges are:\\n\\n2: [2] [2,3] [2,4]  min in all ranges is 2\\n3: [3] [3,4]  min in all ranges is 3\\n4: [4] min in all ranges is 4\\n\\nSo the formula would be poped_item * (poped_index - i)\\n\\nwe push 1 to the stack BTW ATM :D\\n\\nStep 4:\\nNow that we have 1 in stack we can put 5 in the stack but we just need to process these items\\nSo like others we can just add a Integer.MIN_VALUE or float(\"-inf\") to or input array to do the trick\\n\\nNo let\\'s pop!\\nJust like step 3 we can pop 5 and then 1 and after this round we have checked and know the min for all of the following ranges:\\n2: [2] [2,3] [2,4]\\n3: [3] [3,4]\\n4: [4] \\n1: [1] [1,5]\\n2: [5]\\n\\nBut we should have come up with the following list!\\n\\n2: [2] [2,3] [2,4] [2,1] [2,5]\\n3: [3] [3,4] [3,1] [3,5]\\n4: [4] [4,1] [4,5]\\n1: [1] [1,5]\\n2: [5]\\n\\nTo find the missed ranges we should have looked into our stack and see what\\'s on the top (that\\'s our minimum for missed ranges) and then multiply them by their distance to i\\nand if the stack is empty then we might have some elements in the stack that we already poped. we don\\'t care what they were cause the were obviously greater than 1 (in this case)\\nSo it\\'s safe to say that the INDEX of whatever is on top of the stack or -1 should be multipled by the element that we poped from the stack (min of all of those ranges)\\n\\nSame goes with sum_max (second pass with min mono stack)\\n\\n\\'\\'\\'\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        \\n        st = []\\n        sum_min = 0\\n        for i,n in enumerate(nums+[float(\"-inf\")]):\\n            while st and nums[st[-1]] > n:\\n                j = st.pop()\\n                poped = nums[j]\\n                k = -1\\n                if st:\\n                    k = st[-1]\\n                sum_min += poped * (i - j)*(j - k)\\n            st.append(i)\\n        \\n        st = []\\n        sum_max = 0\\n        for i,n in enumerate(nums+[float(\"inf\")]):\\n            while st and nums[st[-1]] < n:\\n                j = st.pop()\\n                poped = nums[j]\\n                k = -1\\n                if st:\\n                    k = st[-1]\\n                sum_max += poped * (i - j)*(j - k)\\n            st.append(i)\\n        \\n        return sum_max - sum_min",
                "codeTag": "Java"
            },
            {
                "id": 1772805,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    \\n    public long subArrayRanges(int[] nums) {\\n        int n = nums.length;\\n        long ans =0;\\n        \\n        Stack<Integer>st = new Stack<>();\\n        \\n        // add SubArray Maximums\\n        for(int i=0;i<=n;i++){\\n            \\n            while(!st.isEmpty() && (i==n|| nums[st.peek()] <nums[i])){\\n                \\n                int top = st.pop();\\n                int l = top - (st.isEmpty() ? -1 : st.peek() );\\n                int r =  i - top;\\n                \\n                ans +=  (long)nums[top]*l*r;\\n            }\\n            st.push(i);\\n        }\\n        \\n        st.clear();\\n        \\n        // subtract SubArray Minimums\\n        for(int i=0;i<=n;i++){\\n\\t\\t\\n            while(!st.isEmpty() && (i==n|| nums[st.peek()] >nums[i])){\\n                \\n                int top = st.pop();\\n                int l = top - (st.isEmpty() ? -1 : st.peek() );\\n                int r =  i - top;\\n                \\n                ans -=  (long)nums[top]*l*r;\\n            }\\n            st.push(i);\\n        }\\n        \\n        return ans;\\n\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public long subArrayRanges(int[] nums) {\\n        int n = nums.length;\\n        long ans =0;\\n        \\n        Stack<Integer>st = new Stack<>();\\n        \\n        // add SubArray Maximums\\n        for(int i=0;i<=n;i++){\\n            \\n            while(!st.isEmpty() && (i==n|| nums[st.peek()] <nums[i])){\\n                \\n                int top = st.pop();\\n                int l = top - (st.isEmpty() ? -1 : st.peek() );\\n                int r =  i - top;\\n                \\n                ans +=  (long)nums[top]*l*r;\\n            }\\n            st.push(i);\\n        }\\n        \\n        st.clear();\\n        \\n        // subtract SubArray Minimums\\n        for(int i=0;i<=n;i++){\\n\\t\\t\\n            while(!st.isEmpty() && (i==n|| nums[st.peek()] >nums[i])){\\n                \\n                int top = st.pop();\\n                int l = top - (st.isEmpty() ? -1 : st.peek() );\\n                int r =  i - top;\\n                \\n                ans -=  (long)nums[top]*l*r;\\n            }\\n            st.push(i);\\n        }\\n        \\n        return ans;\\n\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2470748,
                "title": "c-o-n-explained-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<int>st;\\n        vector<long long> min_l(n,0),max_l(n,0),min_r(n,0),max_r(n,0);\\n        for(int i = 0; i< n; i++){\\n          while(!st.empty() && nums[st.top()] > nums[i]){\\n            st.pop();\\n          }\\n          if(st.empty()){\\n            min_l[i] = i+1;\\n          }\\n          else{\\n            min_l[i] = i-st.top();\\n          }\\n          st.push(i);\\n        }\\n        while(!st.empty()) st.pop();\\n        for(int i = n-1; i>= 0; i--){\\n          while(!st.empty() && nums[st.top()] >= nums[i]){\\n            st.pop();\\n          }\\n          if(st.empty()){\\n            min_r[i] = n-i;\\n          }\\n          else{\\n            min_r[i] = st.top()-i;\\n          }\\n          st.push(i);\\n         }\\n        while(!st.empty()) st.pop();\\n        for(int i = 0; i< n; i++){\\n            while(!st.empty() && nums[st.top()] < nums[i]){\\n              st.pop();\\n            }\\n            if(st.empty()){\\n              max_l[i] = i+1;\\n            }\\n            else{\\n              max_l[i] = i-st.top();\\n            }\\n            st.push(i);\\n          }\\n          while(!st.empty()) st.pop();\\n          for(int i = n-1; i>= 0; i--){\\n            while(!st.empty() && nums[st.top()] <= nums[i]){\\n              st.pop();\\n            }\\n            if(st.empty()){\\n              max_r[i] = n-i;\\n            }\\n            else{\\n              max_r[i] = st.top()-i;\\n            }\\n            st.push(i);\\n          }\\n      long long ans = 0;\\n      for(int i = 0; i < n; i++){\\n        ans += (long)nums[i]*(max_l[i]*max_r[i] - min_l[i]*min_r[i]);\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<int>st;\\n        vector<long long> min_l(n,0),max_l(n,0),min_r(n,0),max_r(n,0);\\n        for(int i = 0; i< n; i++){\\n          while(!st.empty() && nums[st.top()] > nums[i]){\\n            st.pop();\\n          }\\n          if(st.empty()){\\n            min_l[i] = i+1;\\n          }\\n          else{\\n            min_l[i] = i-st.top();\\n          }\\n          st.push(i);\\n        }\\n        while(!st.empty()) st.pop();\\n        for(int i = n-1; i>= 0; i--){\\n          while(!st.empty() && nums[st.top()] >= nums[i]){\\n            st.pop();\\n          }\\n          if(st.empty()){\\n            min_r[i] = n-i;\\n          }\\n          else{\\n            min_r[i] = st.top()-i;\\n          }\\n          st.push(i);\\n         }\\n        while(!st.empty()) st.pop();\\n        for(int i = 0; i< n; i++){\\n            while(!st.empty() && nums[st.top()] < nums[i]){\\n              st.pop();\\n            }\\n            if(st.empty()){\\n              max_l[i] = i+1;\\n            }\\n            else{\\n              max_l[i] = i-st.top();\\n            }\\n            st.push(i);\\n          }\\n          while(!st.empty()) st.pop();\\n          for(int i = n-1; i>= 0; i--){\\n            while(!st.empty() && nums[st.top()] <= nums[i]){\\n              st.pop();\\n            }\\n            if(st.empty()){\\n              max_r[i] = n-i;\\n            }\\n            else{\\n              max_r[i] = st.top()-i;\\n            }\\n            st.push(i);\\n          }\\n      long long ans = 0;\\n      for(int i = 0; i < n; i++){\\n        ans += (long)nums[i]*(max_l[i]*max_r[i] - min_l[i]*min_r[i]);\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358128,
                "title": "java-o-n-solution-with-inline-comments",
                "content": "The approach is, \\n\\ncontribution of nums[j] = nums[j] * number of subarrays where its been minimum/maximum \\nWhen calculating the contribution as a minimum value we will subtract that contribution from the final result and for maximum we will add it to the final result. \\n\\nNOTE: The logic of the code works such that we will be calculating the contributions for the stack top and not the index which is defined by the current iteration\\nSo if i is the current iteration and j is the index on stack top, we will calculate contributions of value at index j till value at j is smaller or bigger than value at index i\\nThis calculation will take place as part of our monotonic stack logic. When calculating minimum, we will be using a increasing stack. Stack top will be the minimum after the value at index below stack top.\\nnumber of subarrays where its been minimum = (j - prev index till where it was minimum) * (i - j)\\nnumber of subarrays where its been maximum = (j - prev index till where nums[j] is max) * (i - j)\\n\\n```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        // Approach 2: Instead of finding min and max in a particular\\n        // subarray, find all the minimums in all subarrays and subtract\\n        // those minimums from the final result and also add all the maximums\\n        // And we will have our final answer.\\n        // NOTE: We will be calculating the max and min contribution of the value\\n        // at index stack top and not the value at index i\\n        Stack<Integer> stack = new Stack();\\n        long res = 0;\\n        \\n        // 1. Subtract minimums from the final sum\\n        // We will use the monotonically increasing stack such that\\n        // Stack top will be the index of the minimum value after\\n        // the previous index. All other indices at which the value\\n        // is greater will be popped to insert the current stack top\\n        // If we come across another value that is smaller than stack top,\\n        // this means that this is the end of range for the stack top till\\n        // which it was minimum\\n        for (int i = 0; i <= nums.length; i++) {\\n            // we use min_value here because we will be popping out all the remaining mimimums\\n            while (!stack.isEmpty() && nums[stack.peek()] > (i == nums.length ? Integer.MIN_VALUE : nums[i])) {\\n                int min = stack.pop();\\n                // -1 if its been the minimum ever since the first index\\n                int prevMin = stack.isEmpty() ? -1 : stack.peek();\\n                // we do not add one here (like how some explainations sugges) because we are already considering\\n                // all the indices from prevMin to min and i to min we do not\\n                // need to include prevMin and i in the current left and right\\n                // boundaries. we multiply all these together with nums[min]\\n                // is because (i - min) * (min - prevMin) will give us the total number of \\n                // subarrays and to calculate the subtractions we will need to subtract\\n                // that nums[min] number of subarray tinmes\\n                res -= (long) nums[min] * (i - min) * (min - prevMin);\\n            }\\n            // push once all the prev mins were calculated and their contributions added to\\n            // the result\\n            stack.push(i);            \\n        }\\n        \\n        stack.clear();\\n        // 2. Add maximums to the final sum\\n        // We will use a decreasing stack to ensure the stack top(max) is maximum\\n        // since prev max that is underneath the stack top. \\n        for (int i = 0; i <= nums.length; i++) {\\n            while (!stack.isEmpty() && nums[stack.peek()] < (i == nums.length ? Integer.MAX_VALUE : nums[i])) {\\n                int max = stack.pop();\\n                // this means max that we just popped is the maximum element\\n                // in so far since we had to remove all the elements to push\\n                // it to the top of the stack \\n                int prevMax = stack.isEmpty() ? -1 : stack.peek();\\n                res += (long) (nums[max]) * (i - max) * (max - prevMax);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        // Approach 2: Instead of finding min and max in a particular\\n        // subarray, find all the minimums in all subarrays and subtract\\n        // those minimums from the final result and also add all the maximums\\n        // And we will have our final answer.\\n        // NOTE: We will be calculating the max and min contribution of the value\\n        // at index stack top and not the value at index i\\n        Stack<Integer> stack = new Stack();\\n        long res = 0;\\n        \\n        // 1. Subtract minimums from the final sum\\n        // We will use the monotonically increasing stack such that\\n        // Stack top will be the index of the minimum value after\\n        // the previous index. All other indices at which the value\\n        // is greater will be popped to insert the current stack top\\n        // If we come across another value that is smaller than stack top,\\n        // this means that this is the end of range for the stack top till\\n        // which it was minimum\\n        for (int i = 0; i <= nums.length; i++) {\\n            // we use min_value here because we will be popping out all the remaining mimimums\\n            while (!stack.isEmpty() && nums[stack.peek()] > (i == nums.length ? Integer.MIN_VALUE : nums[i])) {\\n                int min = stack.pop();\\n                // -1 if its been the minimum ever since the first index\\n                int prevMin = stack.isEmpty() ? -1 : stack.peek();\\n                // we do not add one here (like how some explainations sugges) because we are already considering\\n                // all the indices from prevMin to min and i to min we do not\\n                // need to include prevMin and i in the current left and right\\n                // boundaries. we multiply all these together with nums[min]\\n                // is because (i - min) * (min - prevMin) will give us the total number of \\n                // subarrays and to calculate the subtractions we will need to subtract\\n                // that nums[min] number of subarray tinmes\\n                res -= (long) nums[min] * (i - min) * (min - prevMin);\\n            }\\n            // push once all the prev mins were calculated and their contributions added to\\n            // the result\\n            stack.push(i);            \\n        }\\n        \\n        stack.clear();\\n        // 2. Add maximums to the final sum\\n        // We will use a decreasing stack to ensure the stack top(max) is maximum\\n        // since prev max that is underneath the stack top. \\n        for (int i = 0; i <= nums.length; i++) {\\n            while (!stack.isEmpty() && nums[stack.peek()] < (i == nums.length ? Integer.MAX_VALUE : nums[i])) {\\n                int max = stack.pop();\\n                // this means max that we just popped is the maximum element\\n                // in so far since we had to remove all the elements to push\\n                // it to the top of the stack \\n                int prevMax = stack.isEmpty() ? -1 : stack.peek();\\n                res += (long) (nums[max]) * (i - max) * (max - prevMax);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044554,
                "title": "python3-monotonic-stack-o-n-time-complexity",
                "content": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        mon = monotonicStack()\\n        \\n        # for each element, check in how many sub-arrays arrays, it can be max\\n        # find the prev and next greater element\\n\\n        # for each element, check in how many sub-arrays arrays, it can be min\\n        # find the prev and next smaller element\\n        \\n        nse_l = mon.nextSmaller_left_idx(nums)\\n        nse_r = mon.nextSmaller_right_idx(nums)\\n        nge_l = mon.nextGreater_left_idx(nums)\\n        nge_r = mon.nextGreater_right_idx(nums)\\n        \\n        ans = 0\\n        \\n        for idx in range(len(nums)):\\n            smaller_left, smaller_right = nse_l[idx], nse_r[idx]\\n            greater_left, greater_right = nge_l[idx], nge_r[idx]\\n            \\n            if smaller_right == -1:\\n                smaller_right = len(nums)\\n            if greater_right == -1:\\n                greater_right = len(nums)\\n            \\n            min_val = (idx - smaller_left) * (smaller_right - idx) * nums[idx]\\n            max_val = (idx - greater_left) * (greater_right - idx) * nums[idx]\\n            \\n            ans += (max_val - min_val)\\n        return ans\\n        \\nclass monotonicStack:\\n    def nextGreater_right_idx(self,arr):\\n        ans = [None] * len(arr)\\n        stack = []\\n        for idx in range(len(arr)-1,-1,-1):\\n            while stack and arr[stack[-1]] < arr[idx]:\\n                stack.pop()\\n            if not stack:\\n                #no greater element\\n                ans[idx] = -1\\n            else:\\n                ans[idx] = stack[-1]\\n            stack.append(idx)\\n        return ans\\n                \\n    def nextGreater_left_idx(self,arr):\\n        ans = [None] * len(arr)\\n        stack = []\\n        for idx in range(len(arr)):\\n            while stack and arr[stack[-1]] <= arr[idx]:\\n                stack.pop()\\n            if not stack:\\n                #no greater element\\n                ans[idx] = -1\\n            else:\\n                ans[idx] = stack[-1]\\n            stack.append(idx)\\n        return ans \\n                \\n    def nextSmaller_right_idx(self,arr):\\n        ans = [None] * len(arr)\\n        stack = []\\n        for idx in range(len(arr)-1,-1,-1):\\n            while stack and arr[stack[-1]] > arr[idx]:\\n                stack.pop()\\n            if not stack:\\n                #no smaller element\\n                ans[idx] = -1\\n            else:\\n                ans[idx] = stack[-1]\\n            stack.append(idx)\\n        return ans \\n        \\n    def nextSmaller_left_idx(self,arr):\\n        ans = [None] * len(arr)\\n        stack = []\\n        for idx in range(len(arr)):\\n            while stack and arr[stack[-1]] >= arr[idx]:\\n                stack.pop()\\n            if not stack:\\n                #no smaller element\\n                ans[idx] = -1\\n            else:\\n                ans[idx] = stack[-1]\\n            stack.append(idx)\\n        return ans \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        mon = monotonicStack()\\n        \\n        # for each element, check in how many sub-arrays arrays, it can be max\\n        # find the prev and next greater element\\n\\n        # for each element, check in how many sub-arrays arrays, it can be min\\n        # find the prev and next smaller element\\n        \\n        nse_l = mon.nextSmaller_left_idx(nums)\\n        nse_r = mon.nextSmaller_right_idx(nums)\\n        nge_l = mon.nextGreater_left_idx(nums)\\n        nge_r = mon.nextGreater_right_idx(nums)\\n        \\n        ans = 0\\n        \\n        for idx in range(len(nums)):\\n            smaller_left, smaller_right = nse_l[idx], nse_r[idx]\\n            greater_left, greater_right = nge_l[idx], nge_r[idx]\\n            \\n            if smaller_right == -1:\\n                smaller_right = len(nums)\\n            if greater_right == -1:\\n                greater_right = len(nums)\\n            \\n            min_val = (idx - smaller_left) * (smaller_right - idx) * nums[idx]\\n            max_val = (idx - greater_left) * (greater_right - idx) * nums[idx]\\n            \\n            ans += (max_val - min_val)\\n        return ans\\n        \\nclass monotonicStack:\\n    def nextGreater_right_idx(self,arr):\\n        ans = [None] * len(arr)\\n        stack = []\\n        for idx in range(len(arr)-1,-1,-1):\\n            while stack and arr[stack[-1]] < arr[idx]:\\n                stack.pop()\\n            if not stack:\\n                #no greater element\\n                ans[idx] = -1\\n            else:\\n                ans[idx] = stack[-1]\\n            stack.append(idx)\\n        return ans\\n                \\n    def nextGreater_left_idx(self,arr):\\n        ans = [None] * len(arr)\\n        stack = []\\n        for idx in range(len(arr)):\\n            while stack and arr[stack[-1]] <= arr[idx]:\\n                stack.pop()\\n            if not stack:\\n                #no greater element\\n                ans[idx] = -1\\n            else:\\n                ans[idx] = stack[-1]\\n            stack.append(idx)\\n        return ans \\n                \\n    def nextSmaller_right_idx(self,arr):\\n        ans = [None] * len(arr)\\n        stack = []\\n        for idx in range(len(arr)-1,-1,-1):\\n            while stack and arr[stack[-1]] > arr[idx]:\\n                stack.pop()\\n            if not stack:\\n                #no smaller element\\n                ans[idx] = -1\\n            else:\\n                ans[idx] = stack[-1]\\n            stack.append(idx)\\n        return ans \\n        \\n    def nextSmaller_left_idx(self,arr):\\n        ans = [None] * len(arr)\\n        stack = []\\n        for idx in range(len(arr)):\\n            while stack and arr[stack[-1]] >= arr[idx]:\\n                stack.pop()\\n            if not stack:\\n                #no smaller element\\n                ans[idx] = -1\\n            else:\\n                ans[idx] = stack[-1]\\n            stack.append(idx)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968070,
                "title": "easy-readable-python-solution-o-n",
                "content": "Answer is `sum of max of all subarrays` - `sum of min of all subarrays`\\n\\nInspired from https://leetcode.com/problems/sum-of-subarray-minimums/discuss/257811/Python-O(n)-slightly-easier-to-grasp-solution-(explained)\\n\\nI am still using the same approach for `sum of min of all subarrays` and extended it to `sum of max of all subarrays` using decreasing monotonic stack. You need to understand the above solution to understand this. \\n\\n```python\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        nums = nums\\n        N = len(nums)\\n        maxRes = collections.defaultdict(int) # maxRes[-1] = 0 \\n        decMonoStack = []\\n        minRes = collections.defaultdict(int) # minRes[-1] = 0 \\n        incMonoStack = []\\n        \\n        for i in range(N):\\n            while decMonoStack and nums[decMonoStack[-1]] < nums[i]:\\n                decMonoStack.pop()\\n            j = decMonoStack[-1] if decMonoStack else -1\\n            maxRes[i] = maxRes[j] + (i - j) * nums[i]\\n            decMonoStack.append(i)\\n        \\n        for i in range(N):\\n            while incMonoStack and nums[incMonoStack[-1]] > nums[i]:\\n                incMonoStack.pop()\\n            j = incMonoStack[-1] if incMonoStack else -1\\n            minRes[i] = minRes[j] + (i - j) * nums[i]\\n            incMonoStack.append(i)\\n        \\n        return sum(maxRes.values()) - sum(minRes.values())\\n```\\nYou can merge them into one loop but I prefer to keep it separate.",
                "solutionTags": [
                    "Python",
                    "Monotonic Stack"
                ],
                "code": "```python\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        nums = nums\\n        N = len(nums)\\n        maxRes = collections.defaultdict(int) # maxRes[-1] = 0 \\n        decMonoStack = []\\n        minRes = collections.defaultdict(int) # minRes[-1] = 0 \\n        incMonoStack = []\\n        \\n        for i in range(N):\\n            while decMonoStack and nums[decMonoStack[-1]] < nums[i]:\\n                decMonoStack.pop()\\n            j = decMonoStack[-1] if decMonoStack else -1\\n            maxRes[i] = maxRes[j] + (i - j) * nums[i]\\n            decMonoStack.append(i)\\n        \\n        for i in range(N):\\n            while incMonoStack and nums[incMonoStack[-1]] > nums[i]:\\n                incMonoStack.pop()\\n            j = incMonoStack[-1] if incMonoStack else -1\\n            minRes[i] = minRes[j] + (i - j) * nums[i]\\n            incMonoStack.append(i)\\n        \\n        return sum(maxRes.values()) - sum(minRes.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885293,
                "title": "i-am-surprised-it-passed",
                "content": "```\\n\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar subArrayRanges = function(nums) {\\n    let sum = 0\\n    for (let i = 0; i < nums.length; i++){\\n        let smallest = Math.min(nums[i]);\\n        let largest = Math.max(nums[i]);\\n        for (let j = i; j < nums.length; j++){\\n            \\n            smallest = Math.min(nums[j], smallest);\\n            largest = Math.max(nums[j], largest);\\n            \\n            \\n            sum += (largest - smallest)\\n        }\\n    }\\n    return sum\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar subArrayRanges = function(nums) {\\n    let sum = 0\\n    for (let i = 0; i < nums.length; i++){\\n        let smallest = Math.min(nums[i]);\\n        let largest = Math.max(nums[i]);\\n        for (let j = i; j < nums.length; j++){\\n            \\n            smallest = Math.min(nums[j], smallest);\\n            largest = Math.max(nums[j], largest);\\n            \\n            \\n            sum += (largest - smallest)\\n        }\\n    }\\n    return sum\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1816597,
                "title": "java-version",
                "content": "Here\\'s the java version of the code  , you can read the explainations from this C++ solution \\nhttps://leetcode.com/problems/sum-of-subarray-ranges/discuss/1626628/O(n)-solution-with-monotonous-stack-oror-Full-explaination\\n\\n```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n       int n = nums.length;\\n        long sum=0;\\n        Stack<Integer> st = new Stack<>();\\n        int[] minPrev = new int[n];\\n        int[] minNext = new int[n];\\n        int[] maxPrev = new int[n];\\n        int[] maxNext = new int[n];\\n        \\n        Arrays.fill(minPrev , -1);\\n        Arrays.fill(minNext , n);\\n        Arrays.fill(maxPrev , -1 );\\n        Arrays.fill(maxNext , n);\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            while(!st.isEmpty() && nums[st.peek()] >= nums[i]){\\n                st.pop();\\n            }\\n            if(!st.isEmpty()){\\n                minPrev[i] = st.peek();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        st = new Stack<>();\\n        for(int i=n-1;i>=0;i--){\\n            while(!st.isEmpty() && nums[st.peek()] > nums[i]){\\n                st.pop();\\n            }\\n            if(!st.isEmpty()){\\n                minNext[i] = st.peek();\\n            }\\n            st.push(i);\\n        }\\n        \\n        st = new Stack<>();\\n        for(int i=0 ;i<n ;i++){\\n            while(!st.isEmpty() && nums[st.peek()] <= nums[i]){\\n                st.pop();\\n            }\\n            if(!st.isEmpty()){\\n                maxPrev[i] = st.peek();\\n            }\\n            st.push(i);\\n        }\\n        \\n        st = new Stack<>();\\n        for(int i=n-1 ; i>=0;i--){\\n            while(!st.isEmpty() && nums[st.peek()] < nums[i]){\\n                st.pop();\\n            }\\n            \\n            if(!st.isEmpty()){\\n                maxNext[i] = st.peek();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        \\n        for(int i=0 ;i <n;i++){\\n            long leftMin = i-minPrev[i];\\n            long rightMin = minNext[i]-i;\\n            long leftMax = i-maxPrev[i];\\n            long rightMax = maxNext[i]-i;\\n            sum+= (leftMax*rightMax - leftMin*rightMin)*nums[i];\\n        }\\n        \\n        return sum;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n       int n = nums.length;\\n        long sum=0;\\n        Stack<Integer> st = new Stack<>();\\n        int[] minPrev = new int[n];\\n        int[] minNext = new int[n];\\n        int[] maxPrev = new int[n];\\n        int[] maxNext = new int[n];\\n        \\n        Arrays.fill(minPrev , -1);\\n        Arrays.fill(minNext , n);\\n        Arrays.fill(maxPrev , -1 );\\n        Arrays.fill(maxNext , n);\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            while(!st.isEmpty() && nums[st.peek()] >= nums[i]){\\n                st.pop();\\n            }\\n            if(!st.isEmpty()){\\n                minPrev[i] = st.peek();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        st = new Stack<>();\\n        for(int i=n-1;i>=0;i--){\\n            while(!st.isEmpty() && nums[st.peek()] > nums[i]){\\n                st.pop();\\n            }\\n            if(!st.isEmpty()){\\n                minNext[i] = st.peek();\\n            }\\n            st.push(i);\\n        }\\n        \\n        st = new Stack<>();\\n        for(int i=0 ;i<n ;i++){\\n            while(!st.isEmpty() && nums[st.peek()] <= nums[i]){\\n                st.pop();\\n            }\\n            if(!st.isEmpty()){\\n                maxPrev[i] = st.peek();\\n            }\\n            st.push(i);\\n        }\\n        \\n        st = new Stack<>();\\n        for(int i=n-1 ; i>=0;i--){\\n            while(!st.isEmpty() && nums[st.peek()] < nums[i]){\\n                st.pop();\\n            }\\n            \\n            if(!st.isEmpty()){\\n                maxNext[i] = st.peek();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        \\n        for(int i=0 ;i <n;i++){\\n            long leftMin = i-minPrev[i];\\n            long rightMin = minNext[i]-i;\\n            long leftMax = i-maxPrev[i];\\n            long rightMax = maxNext[i]-i;\\n            sum+= (leftMax*rightMax - leftMin*rightMin)*nums[i];\\n        }\\n        \\n        return sum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639112,
                "title": "java-monotone-stack-math-o-n",
                "content": "Note that this solution\\'s idea is borrowed from this [post](https://leetcode.com/problems/sum-of-subarray-ranges/discuss/1626628/O(n)-solution-with-monotonous-stack-oror-Full-explaination), I am writing this to summarize my understanding/thought process.\\n\\n\\n### O(N) way\\nThis problem asks for the sum of all subarray ranges, the intuitive O(N^2) way of thinking about this is finding all subarrays and sum up all its (max_value - min_value).\\nIn order to get to O(N), we have to think about the issue differently:\\nFor each num, its contribution to the sum is: \\n`\\nnum *  (count_max - count_min)\\n`\\n`count_min`: number of times num is used as the min value aka in how many subarrays, num is the min value\\n`count_max`: number of times num is used as the max value aka in how many subarrays,  num is the max value\\n\\nNow, if we can compute `count_min` and `count_max`, the answer to this question will be:\\nsummation of `nums[i] * (count_max - count_min)`, where i is [0, nums.length - 1] \\n\\n### Computing count_max\\nIn order to compute the number of subarrays where num is the max value, we need to find:\\nthe previous number that is bigger than num, and the next number that is bigger than num.\\ne.g.:\\n`\\n[3, 1, 2, 1, 3]\\n`\\nFor i = 2, nums[i] = 2, the previous bigger number is at index h = 0, the next bigger number is at index j = 4.\\nLet left = (i - h) aka the distance from current number index to previous bigger index\\nLeft right = (j - i) aka the distance from current number index to next bigger index\\nmax_count = \\n```\\n(left + right - 1)! - (left - 1)! - (right - 1)! =\\n1 + left + right - 1) * (left + right - 1) / 2 - (1 + left - 1) * (left - 1) / 2 - (1 + right - 1) * (right - 1) / 2 =\\n((left^2 + left*right - left + left*right + right^2 - right) - (left ^ 2 - left) - (right ^ 2 - right)) / 2 =\\nleft * right\\n```\\n\\nSo far we established:\\n` max_count = left * right `, where left is the distance from index i to previous bigger index, and right is from index i to next bigger index. Now the problem becomes: compute each number\\'s previous/next bigger number\\'s index.\\n\\n\\n### Compute prevBigger\\nIn order to compute previous bigger and next bigger, we can use Monotone Stack: basically for nums[i], we need to create int[] prevBigger = new int[nums.length], as a quick reference to find the previous bigger number\\'s index. This part, hopefully is straightforward to explain in code:\\n```\\n    private static int[] getPrevBigger(int[] nums) {\\n        int[] prevBigger = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            int prevIndex = i - 1;\\n            while (prevIndex >= 0 && nums[prevIndex] < nums[i]) {\\n                prevIndex = prevBigger[prevIndex];\\n            }\\n            prevBigger[i] = prevIndex;\\n        } \\n        return prevBigger;\\n    }\\n```\\n\\n### Caveat\\nWhen computing prevBigger, nextBigger, prevSmaller, prevBigger for the previous step,\\nin the case of duplicate numbers (e.g. [1, 1]), each number may be counted as the max/min multiple times, causing this number to over-contribute to the result. To avoid such case, we can come up with ways to break ties e.g. number at a larger index wins.\\n\\n### Putting things together\\nresult = nums[i] * (max_count - min_count), where i is [0, nums.length - 1]\\nmax_count = number of subarrays where nums[i] is the max value\\nmax_count = left * right\\nleft = distance from previous bigger number\\\\\\'s index to current index\\nright = distance from next bigger number\\\\\\'s index to current index\\nmin_count = number of subarrays where nums[i] is  the min value (similar to max_count)\\n\\n### Solution\\n\\n```\\nclass Solution {\\n    \\n    public long subArrayRanges(int[] nums) {\\n        int[] prevSmaller = getPrevSmaller(nums);\\n        int[] prevBigger = getPrevBigger(nums);\\n\\t\\t// Stop at first duplicate to break ties so that duplicate numbers don\\'t over-contribute\\n        int[] nextSmallerOrEqual = getNextSmallerOrEqual(nums);\\n        int[] nextBiggerOrEqual = getNextBiggerOrEqual(nums);\\n        long total = 0L;\\n        for (int i = 0; i < nums.length; i++) {\\n            int minLeft = i - prevSmaller[i];\\n            int minRight = nextSmallerOrEqual[i] - i;\\n            long minContribution = (long) nums[i] * minLeft * minRight;\\n            int maxLeft = i - prevBigger[i];\\n            int maxRight = nextBiggerOrEqual[i] - i;\\n            long maxContribution = (long) nums[i] * maxLeft * maxRight;\\n            total += (maxContribution - minContribution);\\n        }\\n        return total;\\n    }\\n    \\n    private static int[] getPrevSmaller(int[] nums) {\\n        int[] prevSmaller = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            int prevIndex = i - 1;\\n            while (prevIndex >= 0 && nums[prevIndex] > nums[i]) {\\n                prevIndex = prevSmaller[prevIndex];\\n            }\\n            prevSmaller[i] = prevIndex;\\n        } \\n        return prevSmaller;\\n    }\\n    \\n    private static int[] getPrevBigger(int[] nums) {\\n        int[] prevBigger = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            int prevIndex = i - 1;\\n            while (prevIndex >= 0 && nums[prevIndex] < nums[i]) {\\n                prevIndex = prevBigger[prevIndex];\\n            }\\n            prevBigger[i] = prevIndex;\\n        } \\n        return prevBigger;\\n    }\\n    \\n    private static int[] getNextSmallerOrEqual(int[] nums) {\\n        int[] nextSmaller = new int[nums.length];\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            int nextIndex = i + 1;\\n            while (nextIndex <= nums.length - 1 && nums[nextIndex] >= nums[i]) {\\n                nextIndex = nextSmaller[nextIndex];\\n            }\\n            nextSmaller[i] = nextIndex;\\n        } \\n        return nextSmaller;\\n    }\\n    \\n        private static int[] getNextBiggerOrEqual(int[] nums) {\\n        int[] nextBigger = new int[nums.length];\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            int nextIndex = i + 1;\\n            while (nextIndex <= nums.length - 1 && nums[nextIndex] <= nums[i]) {\\n                nextIndex = nextBigger[nextIndex];\\n            }\\n            nextBigger[i] = nextIndex;\\n        } \\n        return nextBigger;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n(left + right - 1)! - (left - 1)! - (right - 1)! =\\n1 + left + right - 1) * (left + right - 1) / 2 - (1 + left - 1) * (left - 1) / 2 - (1 + right - 1) * (right - 1) / 2 =\\n((left^2 + left*right - left + left*right + right^2 - right) - (left ^ 2 - left) - (right ^ 2 - right)) / 2 =\\nleft * right\\n```\n```\\n    private static int[] getPrevBigger(int[] nums) {\\n        int[] prevBigger = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            int prevIndex = i - 1;\\n            while (prevIndex >= 0 && nums[prevIndex] < nums[i]) {\\n                prevIndex = prevBigger[prevIndex];\\n            }\\n            prevBigger[i] = prevIndex;\\n        } \\n        return prevBigger;\\n    }\\n```\n```\\nclass Solution {\\n    \\n    public long subArrayRanges(int[] nums) {\\n        int[] prevSmaller = getPrevSmaller(nums);\\n        int[] prevBigger = getPrevBigger(nums);\\n\\t\\t// Stop at first duplicate to break ties so that duplicate numbers don\\'t over-contribute\\n        int[] nextSmallerOrEqual = getNextSmallerOrEqual(nums);\\n        int[] nextBiggerOrEqual = getNextBiggerOrEqual(nums);\\n        long total = 0L;\\n        for (int i = 0; i < nums.length; i++) {\\n            int minLeft = i - prevSmaller[i];\\n            int minRight = nextSmallerOrEqual[i] - i;\\n            long minContribution = (long) nums[i] * minLeft * minRight;\\n            int maxLeft = i - prevBigger[i];\\n            int maxRight = nextBiggerOrEqual[i] - i;\\n            long maxContribution = (long) nums[i] * maxLeft * maxRight;\\n            total += (maxContribution - minContribution);\\n        }\\n        return total;\\n    }\\n    \\n    private static int[] getPrevSmaller(int[] nums) {\\n        int[] prevSmaller = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            int prevIndex = i - 1;\\n            while (prevIndex >= 0 && nums[prevIndex] > nums[i]) {\\n                prevIndex = prevSmaller[prevIndex];\\n            }\\n            prevSmaller[i] = prevIndex;\\n        } \\n        return prevSmaller;\\n    }\\n    \\n    private static int[] getPrevBigger(int[] nums) {\\n        int[] prevBigger = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            int prevIndex = i - 1;\\n            while (prevIndex >= 0 && nums[prevIndex] < nums[i]) {\\n                prevIndex = prevBigger[prevIndex];\\n            }\\n            prevBigger[i] = prevIndex;\\n        } \\n        return prevBigger;\\n    }\\n    \\n    private static int[] getNextSmallerOrEqual(int[] nums) {\\n        int[] nextSmaller = new int[nums.length];\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            int nextIndex = i + 1;\\n            while (nextIndex <= nums.length - 1 && nums[nextIndex] >= nums[i]) {\\n                nextIndex = nextSmaller[nextIndex];\\n            }\\n            nextSmaller[i] = nextIndex;\\n        } \\n        return nextSmaller;\\n    }\\n    \\n        private static int[] getNextBiggerOrEqual(int[] nums) {\\n        int[] nextBigger = new int[nums.length];\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            int nextIndex = i + 1;\\n            while (nextIndex <= nums.length - 1 && nums[nextIndex] <= nums[i]) {\\n                nextIndex = nextBigger[nextIndex];\\n            }\\n            nextBigger[i] = nextIndex;\\n        } \\n        return nextBigger;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624221,
                "title": "java-easy-explanation",
                "content": "```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        long [] out = new long[1];\\n        for(int i=0;i<nums.length;i++)\\n            dfs(out, nums, i, nums[i], nums[i], 1);\\n        return out[0];\\n    }\\n    \\n    private void dfs(long [] out, int[] nums, int i, int min, int max, int len){\\n        if(len > 1){ //computing only when max we have more one value in the sub array\\n            out[0]  += max -min;\\n        }\\n        if(i > nums.length-2) // return if already in the last position\\n            return;\\n        dfs(out, nums,i+1, Math.min(nums[i+1], min), Math.max(nums[i+1], max), len+1); // We dont need a sub array. Just max and min element is enough\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long subArrayRanges(int[] nums) {\\n        long [] out = new long[1];\\n        for(int i=0;i<nums.length;i++)\\n            dfs(out, nums, i, nums[i], nums[i], 1);\\n        return out[0];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3483884,
                "title": "c-approach-using-stacks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // finding NSL\\n    vector<int> getNSL(vector<int>& nums , int n){\\n        vector<int> v(n);\\n        stack<int> s;\\n        for(int i = 0 ;i<n;i++){\\n            if(s.empty()){\\n            v[i]=-1;\\n            }else{\\n                 while(s.size()!=0 && nums[s.top()]>nums[i]){\\n                     s.pop();\\n                 }\\n                 if(s.size()==0){\\n                     v[i]=-1;\\n                 }else{\\n                     v[i]=s.top();\\n                 }\\n             }\\n             s.push(i);\\n\\n        }\\n        return v;\\n    }\\n    //finding NSR\\n     vector<int> getNSR(vector<int>& nums , int n){\\n        vector<int> v(n);\\n                stack<int> s;\\n\\n        for(int i = n-1 ;i>=0;i--){\\n            if(s.empty()){\\n            v[i]=n;\\n            }else{\\n                 while(s.size()!=0 && nums[s.top()]>=nums[i]){\\n                     //we handle duplicates by = sign in one case\\n                     s.pop();\\n                 }\\n                 if(s.size()==0){\\n                     v[i]=n;\\n                 }else{\\n                     v[i]=s.top();\\n                 }\\n             }\\n             s.push(i);\\n\\n        }\\n        return v;\\n    }\\n    // finding NGR\\n    vector<int> getNGR(vector<int>& nums , int n){\\n        vector<int> v(n);\\n                stack<int> s;\\n\\n        for(int i = n-1 ;i>=0;i--){\\n            if(s.empty()){\\n            v[i]=n;\\n            }else{\\n                 while(s.size()!=0 && nums[s.top()]<=nums[i]){\\n                     //we handle duplicates by = sign in one case\\n                     s.pop();\\n                 }\\n                 if(s.size()==0){\\n                     v[i]=n;\\n                 }else{\\n                     v[i]=s.top();\\n                 }\\n             }\\n             s.push(i);\\n\\n        }\\n        return v;\\n    }\\n    //finding NGL\\n    vector<int> getNGL(vector<int>& nums , int n){\\n        vector<int> v(n);\\n                stack<int> s;\\n\\n        for(int i = 0 ;i<n;i++){\\n            if(s.empty()){\\n            v[i]=-1;\\n            }else{\\n                 while(s.size()!=0 && nums[s.top()]<nums[i]){\\n                     s.pop();\\n                 }\\n                 if(s.size()==0){\\n                     v[i]=-1;\\n                 }else{\\n                     v[i]=s.top();\\n                 }\\n             }\\n             s.push(i);\\n\\n        }\\n        return v;\\n    }\\n\\n   // approach for this is same as sum of minimums in a subarray\\n   // first we find  the sum of maximums in a subarray \\n   //second we find the sum of minimums in a subarray \\n   //later we subtarct them and we get the sum of ranges \\n   // sum of maximums of two arrays be a + b\\n   // sum of minimums of two arrays be c + d\\n   //we suntract (a+b)-(c+d);\\n   // we can write as (a-c)+(b-d)\\n   \\n    long long subArrayRanges(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> NGL = getNGL(nums,n);\\n        vector<int> NGR = getNGR(nums,n);\\n        vector<int> NSL = getNSL(nums,n);\\n        vector<int> NSR = getNSR(nums,n);\\n        long long sum = 0;\\n        for(int i =0;i<n;i++){\\n            long long ls = i - NSL[i];\\n            long long rs = NSR[i]-i;\\n            long long lg = i - NGL[i];\\n            long long rg = NGR[i]-i;\\n            long long totalsum = ((lg*rg)-(ls*rs))*nums[i];\\n            sum = sum+totalsum;\\n        }\\n        return sum ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // finding NSL\\n    vector<int> getNSL(vector<int>& nums , int n){\\n        vector<int> v(n);\\n        stack<int> s;\\n        for(int i = 0 ;i<n;i++){\\n            if(s.empty()){\\n            v[i]=-1;\\n            }else{\\n                 while(s.size()!=0 && nums[s.top()]>nums[i]){\\n                     s.pop();\\n                 }\\n                 if(s.size()==0){\\n                     v[i]=-1;\\n                 }else{\\n                     v[i]=s.top();\\n                 }\\n             }\\n             s.push(i);\\n\\n        }\\n        return v;\\n    }\\n    //finding NSR\\n     vector<int> getNSR(vector<int>& nums , int n){\\n        vector<int> v(n);\\n                stack<int> s;\\n\\n        for(int i = n-1 ;i>=0;i--){\\n            if(s.empty()){\\n            v[i]=n;\\n            }else{\\n                 while(s.size()!=0 && nums[s.top()]>=nums[i]){\\n                     //we handle duplicates by = sign in one case\\n                     s.pop();\\n                 }\\n                 if(s.size()==0){\\n                     v[i]=n;\\n                 }else{\\n                     v[i]=s.top();\\n                 }\\n             }\\n             s.push(i);\\n\\n        }\\n        return v;\\n    }\\n    // finding NGR\\n    vector<int> getNGR(vector<int>& nums , int n){\\n        vector<int> v(n);\\n                stack<int> s;\\n\\n        for(int i = n-1 ;i>=0;i--){\\n            if(s.empty()){\\n            v[i]=n;\\n            }else{\\n                 while(s.size()!=0 && nums[s.top()]<=nums[i]){\\n                     //we handle duplicates by = sign in one case\\n                     s.pop();\\n                 }\\n                 if(s.size()==0){\\n                     v[i]=n;\\n                 }else{\\n                     v[i]=s.top();\\n                 }\\n             }\\n             s.push(i);\\n\\n        }\\n        return v;\\n    }\\n    //finding NGL\\n    vector<int> getNGL(vector<int>& nums , int n){\\n        vector<int> v(n);\\n                stack<int> s;\\n\\n        for(int i = 0 ;i<n;i++){\\n            if(s.empty()){\\n            v[i]=-1;\\n            }else{\\n                 while(s.size()!=0 && nums[s.top()]<nums[i]){\\n                     s.pop();\\n                 }\\n                 if(s.size()==0){\\n                     v[i]=-1;\\n                 }else{\\n                     v[i]=s.top();\\n                 }\\n             }\\n             s.push(i);\\n\\n        }\\n        return v;\\n    }\\n\\n   // approach for this is same as sum of minimums in a subarray\\n   // first we find  the sum of maximums in a subarray \\n   //second we find the sum of minimums in a subarray \\n   //later we subtarct them and we get the sum of ranges \\n   // sum of maximums of two arrays be a + b\\n   // sum of minimums of two arrays be c + d\\n   //we suntract (a+b)-(c+d);\\n   // we can write as (a-c)+(b-d)\\n   \\n    long long subArrayRanges(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> NGL = getNGL(nums,n);\\n        vector<int> NGR = getNGR(nums,n);\\n        vector<int> NSL = getNSL(nums,n);\\n        vector<int> NSR = getNSR(nums,n);\\n        long long sum = 0;\\n        for(int i =0;i<n;i++){\\n            long long ls = i - NSL[i];\\n            long long rs = NSR[i]-i;\\n            long long lg = i - NGL[i];\\n            long long rg = NGR[i]-i;\\n            long long totalsum = ((lg*rg)-(ls*rs))*nums[i];\\n            sum = sum+totalsum;\\n        }\\n        return sum ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100406,
                "title": "java-stack-solution",
                "content": "The sum of all range maximum minus minimum results is equivalent to the sum of all range maximum minus the sum of all range minimum.\\n``` java\\nclass Solution {\\n        public long subArrayRanges(int[] nums) {\\n            return getSum(nums,false)-getSum(nums,true);\\n        }\\n\\n        private long getSum(int[] nums, boolean min){\\n            Stack<Integer> stack = new Stack<>();\\n            stack.push(-1);\\n            int n = nums.length;\\n            long sum = 0L;\\n            for(int i = 0; i <= n; i++){\\n                while (stack.peek()!=-1 && (i==n || (min && nums[stack.peek()]>nums[i]) || (!min && nums[stack.peek()]<nums[i]))){\\n                    int pos = stack.pop();\\n                    int v = nums[pos];\\n                    long dist = (i-pos)*(pos-stack.peek());\\n                    sum += dist*v;\\n                }\\n                stack.push(i);\\n            }\\n            return sum;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "``` java\\nclass Solution {\\n        public long subArrayRanges(int[] nums) {\\n            return getSum(nums,false)-getSum(nums,true);\\n        }\\n\\n        private long getSum(int[] nums, boolean min){\\n            Stack<Integer> stack = new Stack<>();\\n            stack.push(-1);\\n            int n = nums.length;\\n            long sum = 0L;\\n            for(int i = 0; i <= n; i++){\\n                while (stack.peek()!=-1 && (i==n || (min && nums[stack.peek()]>nums[i]) || (!min && nums[stack.peek()]<nums[i]))){\\n                    int pos = stack.pop();\\n                    int v = nums[pos];\\n                    long dist = (i-pos)*(pos-stack.peek());\\n                    sum += dist*v;\\n                }\\n                stack.push(i);\\n            }\\n            return sum;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624349,
                "title": "simple-brute-force-solution",
                "content": "```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        int n = nums.length;\\n        long sum = 0;\\n        for (int i = 0; i < n; ++i) {\\n            int min = nums[i], max = nums[i];\\n            for (int j = i; j < n; ++j) {\\n                min = Math.min(min, nums[j]);\\n                max = Math.max(max, nums[j]);\\n                sum += Math.abs(max - min);\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        int n = nums.length;\\n        long sum = 0;\\n        for (int i = 0; i < n; ++i) {\\n            int min = nums[i], max = nums[i];\\n            for (int j = i; j < n; ++j) {\\n                min = Math.min(min, nums[j]);\\n                max = Math.max(max, nums[j]);\\n                sum += Math.abs(max - min);\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624314,
                "title": "javascript-2104-sum-of-subarray-ranges",
                "content": "---\\n\\n- Weekly Contest 271 - https://leetcode.com/contest/weekly-contest-271/ranking/83/\\n  - Q1 answer\\n    - https://leetcode.com/problems/rings-and-rods/discuss/1624271/JavaScript-2103.-Rings-and-Rods\\n  - Q2 answer\\n    - https://leetcode.com/problems/sum-of-subarray-ranges/discuss/1624314/JavaScript-2104.-Sum-of-Subarray-Ranges\\n    - below\\n  - Q3 answer\\n    - https://leetcode.com/problems/watering-plants-ii/discuss/1624383/JavaScript-2105.-Watering-Plants-II\\n  - Q4 answer\\n    - https://leetcode.com/problems/maximum-fruits-harvested-after-at-most-k-steps/discuss/1626153/JavaScript-2106.-Maximum-Fruits-Harvested-After-at-Most-K-Steps\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar subArrayRanges = function (nums) {\\n    let n = nums.length;\\n\\n    let sum = 0;\\n    for (let i = 0; i < n; i++) {\\n        let min = Infinity;\\n        let max = -Infinity;\\n\\n        for (j = i; j < n; j++) {\\n            min = Math.min(min, nums[j]);\\n            max = Math.max(max, nums[j]);\\n            sum += max - min;\\n        }\\n    }\\n\\n    return sum;\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar subArrayRanges = function (nums) {\\n    let n = nums.length;\\n\\n    let sum = 0;\\n    for (let i = 0; i < n; i++) {\\n        let min = Infinity;\\n        let max = -Infinity;\\n\\n        for (j = i; j < n; j++) {\\n            min = Math.min(min, nums[j]);\\n            max = Math.max(max, nums[j]);\\n            sum += max - min;\\n        }\\n    }\\n\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1624233,
                "title": "simple-javascript-js-solution",
                "content": "```\\nvar subArrayRanges = function(nums) {\\n    let start = 0;\\n    let sum = 0;\\n\\n    while (start < nums.length) {\\n        let end = start;\\n        let min = Number.MAX_SAFE_INTEGER;\\n        let max = Number.MIN_SAFE_INTEGER;\\n        \\n        while (end < nums.length) {\\n            max = Math.max(max, nums[start], nums[end]);\\n            min = Math.min(min, nums[start], nums[end]);\\n            sum += max - min;\\n            end++;\\n        }\\n        start++;\\n    }\\n    \\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar subArrayRanges = function(nums) {\\n    let start = 0;\\n    let sum = 0;\\n\\n    while (start < nums.length) {\\n        let end = start;\\n        let min = Number.MAX_SAFE_INTEGER;\\n        let max = Number.MIN_SAFE_INTEGER;\\n        \\n        while (end < nums.length) {\\n            max = Math.max(max, nums[start], nums[end]);\\n            min = Math.min(min, nums[start], nums[end]);\\n            sum += max - min;\\n            end++;\\n        }\\n        start++;\\n    }\\n    \\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3163605,
                "title": "brute-force-c-time-o-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        long long int ans = 0;\\n        int n = nums.size(),i,j;\\n        long long int mx = LONG_MIN,mn = LONG_MAX;\\n        for(i = 0; i <n; i++){\\n            mx = nums[i];\\n            mn = nums[i];\\n            for(j = i; j>=0; j--){\\n                mx = max(mx,nums[j]*1LL);\\n                mn = min(mn,nums[j]*1LL);\\n                // cout<<mx-mn<<\" \";\\n                ans += mx-mn;\\n            }\\n            // cout<<endl;\\n        }\\n        return ans;}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        long long int ans = 0;\\n        int n = nums.size(),i,j;\\n        long long int mx = LONG_MIN,mn = LONG_MAX;\\n        for(i = 0; i <n; i++){\\n            mx = nums[i];\\n            mn = nums[i];\\n            for(j = i; j>=0; j--){\\n                mx = max(mx,nums[j]*1LL);\\n                mn = min(mn,nums[j]*1LL);\\n                // cout<<mx-mn<<\" \";\\n                ans += mx-mn;\\n            }\\n            // cout<<endl;\\n        }\\n        return ans;}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2510531,
                "title": "c-clean-code-o-n-using-mono-stack",
                "content": "The idea is what these most high voted answers have explained. However, I find it is hard to understand their code implementation. I have below code with well naming variables which I think would be easier to understand. Hope it helps.\\nThe idea was inspired by this post https://leetcode.com/problems/sum-of-subarray-minimums/discuss/178876/stack-solution-with-very-detailed-explanation-step-by-step\\n\\nleftLess[i] means the length between current nums[i] and the previous smaller numbers on the left side;\\nrightLess[i] means  the length between current nums[i] and the next smaller numbers on the right side;\\nleftLess[i] * rightLess[i] is the total subarrary counts, nums[i] is the smallest num in these subarrays.\\nSimiliarly, \\nleftLarger[i] means  the length between current nums[i] and the previous larger numbers on the left side;\\nrightLarger[i] means  the length between current nums[i] and the next larger numbers on the right side;\\nleftLarger[i] * rightLarger[i] is the total subarrary counts, nums[i] is the largest num in these subarrays.\\n\\n```\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        stack<int> increaseStk;\\n        stack<int> decreaseStk;\\n        int n = nums.size();\\n        vector<int> leftLess(n);\\n        vector<int> rightLess(n);\\n        vector<int> leftLarger(n);\\n        vector<int> rightLarger(n);\\n        // 1. Initialize\\n        for(int i=0; i<n; i++){\\n            leftLess[i] = leftLarger[i] = i+1;\\n            rightLess[i] = rightLarger[i] = n-i;            \\n        }\\n        // 2. Find leftLess and rightLess\\n        for(int i=0; i<n; i++){\\n            while(!increaseStk.empty() && nums[increaseStk.top()] > nums[i]){\\n                rightLess[increaseStk.top()] = i - increaseStk.top();\\n                increaseStk.pop();\\n            }\\n            leftLess[i] = increaseStk.empty() ? i + 1 : i - increaseStk.top();\\n            increaseStk.push(i);\\n        }\\n        // 3. Find leftLarger and rightLarger\\n        for(int i=0; i<n; i++){\\n            while(!decreaseStk.empty() && nums[decreaseStk.top()] < nums[i]){\\n                rightLarger[decreaseStk.top()] = i - decreaseStk.top();\\n                decreaseStk.pop();\\n            }\\n            leftLarger[i] = decreaseStk.empty() ? i + 1 : i - decreaseStk.top();\\n            decreaseStk.push(i);\\n        }\\n        // 4. accumulate sum of (larger - less) of nums[i]\\n        long long sum = 0;\\n        for(int i=0; i<n; i++){\\n            long long curDiff = leftLarger[i]*rightLarger[i] - leftLess[i]*rightLess[i];\\n            sum += nums[i] * curDiff;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        stack<int> increaseStk;\\n        stack<int> decreaseStk;\\n        int n = nums.size();\\n        vector<int> leftLess(n);\\n        vector<int> rightLess(n);\\n        vector<int> leftLarger(n);\\n        vector<int> rightLarger(n);\\n        // 1. Initialize\\n        for(int i=0; i<n; i++){\\n            leftLess[i] = leftLarger[i] = i+1;\\n            rightLess[i] = rightLarger[i] = n-i;            \\n        }\\n        // 2. Find leftLess and rightLess\\n        for(int i=0; i<n; i++){\\n            while(!increaseStk.empty() && nums[increaseStk.top()] > nums[i]){\\n                rightLess[increaseStk.top()] = i - increaseStk.top();\\n                increaseStk.pop();\\n            }\\n            leftLess[i] = increaseStk.empty() ? i + 1 : i - increaseStk.top();\\n            increaseStk.push(i);\\n        }\\n        // 3. Find leftLarger and rightLarger\\n        for(int i=0; i<n; i++){\\n            while(!decreaseStk.empty() && nums[decreaseStk.top()] < nums[i]){\\n                rightLarger[decreaseStk.top()] = i - decreaseStk.top();\\n                decreaseStk.pop();\\n            }\\n            leftLarger[i] = decreaseStk.empty() ? i + 1 : i - decreaseStk.top();\\n            decreaseStk.push(i);\\n        }\\n        // 4. accumulate sum of (larger - less) of nums[i]\\n        long long sum = 0;\\n        for(int i=0; i<n; i++){\\n            long long curDiff = leftLarger[i]*rightLarger[i] - leftLess[i]*rightLess[i];\\n            sum += nums[i] * curDiff;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2464051,
                "title": "simple-bruteforce-approach",
                "content": "\\tProcess:\\n\\t\\t1.Need to find the max and min values in a subarray and add it to the ans\\n\\t\\t\\n\\tCode:\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long subArrayRanges(vector<int>& arr) {\\n\\t\\t\\tlong long ans = 0;\\n\\t\\t\\tfor(int i = 0; i < arr.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint max = arr[i] , min = arr[i];\\n\\t\\t\\t\\tfor(int j = i + 1; j < arr.size(); j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(max < arr[j]) max = arr[j];\\n\\t\\t\\t\\t\\tif(min > arr[j]) min = arr[j];\\n\\t\\t\\t\\t\\tans += (max - min);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t-Yash:)",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long subArrayRanges(vector<int>& arr) {\\n\\t\\t\\tlong long ans = 0;\\n\\t\\t\\tfor(int i = 0; i < arr.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint max = arr[i] , min = arr[i];\\n\\t\\t\\t\\tfor(int j = i + 1; j < arr.size(); j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(max < arr[j]) max = arr[j];\\n\\t\\t\\t\\t\\tif(min > arr[j]) min = arr[j];\\n\\t\\t\\t\\t\\tans += (max - min);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2092160,
                "title": "faster-than-75-o-n-sol-easy-to-understand-monotonic-stack",
                "content": "class Solution {\\n\\n    public long subArrayRanges(int[] nums) {\\n\\t\\t/* for O(N) TC\\n\\t\\tstep -1 idea is to calculate that for a particular element in how many subarrays \\n\\t\\tit is considered as min value and in how many subarrays it is considered as \\n\\t\\tmax value, finally adding the contribution of this element in overall result (sum of subarray range) \\n\\t\\t\\n\\t\\tstep -2 doing this for each and every element of array \\n\\t\\t\\n\\t\\tfor more detailed explaination refer - https://leetcode.com/problems/sum-of-subarray-ranges/discuss/1626628/O(n)-solution-with-monotonous-stack-oror-Full-explaination\\n\\t\\t*/\\n\\t\\tlong sum=0;\\n        int n=nums.length;\\n        \\n        Stack<Integer> stack= new Stack<>();\\n        int[] minPrev= new int[n];\\n        int[] minNext= new int[n];\\n        int[] maxPrev= new int[n];\\n        int[] maxNext= new int[n];\\n        \\n        Arrays.fill(minPrev,-1);\\n        Arrays.fill(minNext,n);\\n        Arrays.fill(maxPrev,-1);\\n        Arrays.fill(maxNext,n);\\n        \\n        for(int i=0;i<n;i++){\\n            while(!stack.isEmpty() && nums[stack.peek()] > nums[i])\\n                stack.pop();\\n            \\n            if(!stack.isEmpty())\\n                minPrev[i]=stack.peek();\\n            \\n            stack.push(i);\\n        }\\n        \\n        stack.clear();\\n        for(int i=n-1;i>=0;i--){\\n            while(!stack.isEmpty() && nums[stack.peek()] >= nums[i])\\n                stack.pop();\\n            \\n            if(!stack.isEmpty())\\n                minNext[i]=stack.peek();\\n            \\n            stack.push(i);\\n        }\\n        \\n        stack.clear();\\n        for(int i=0;i<n;i++){\\n            while(!stack.isEmpty() && nums[stack.peek()] < nums[i])\\n                stack.pop();\\n            \\n            if(!stack.isEmpty())\\n                maxPrev[i]=stack.peek();\\n            \\n            stack.push(i);\\n        }\\n        \\n        stack.clear();\\n        for(int i=n-1;i>=0;i--){\\n            while(!stack.isEmpty() && nums[stack.peek()] <= nums[i])\\n                stack.pop();\\n            \\n            if(!stack.isEmpty())\\n                maxNext[i]=stack.peek();\\n            \\n            stack.push(i);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            long leftMin= i-minPrev[i];\\n            long rightMin= minNext[i]-i;\\n            long leftMax= i-maxPrev[i];\\n            long rightMax= maxNext[i]-i;\\n            \\n            sum+=(leftMax*rightMax - leftMin*rightMin)*nums[i];\\n        }\\n        \\n        return sum;\\n    }\\n}",
                "solutionTags": [
                    "Array",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "class Solution {\\n\\n    public long subArrayRanges(int[] nums) {\\n\\t\\t/* for O(N) TC\\n\\t\\tstep -1 idea is to calculate that for a particular element in how many subarrays \\n\\t\\tit is considered as min value and in how many subarrays it is considered as \\n\\t\\tmax value, finally adding the contribution of this element in overall result (sum of subarray range) \\n\\t\\t\\n\\t\\tstep -2 doing this for each and every element of array \\n\\t\\t\\n\\t\\tfor more detailed explaination refer - https://leetcode.com/problems/sum-of-subarray-ranges/discuss/1626628/O(n)-solution-with-monotonous-stack-oror-Full-explaination\\n\\t\\t*/\\n\\t\\tlong sum=0;\\n        int n=nums.length;\\n        \\n        Stack<Integer> stack= new Stack<>();\\n        int[] minPrev= new int[n];\\n        int[] minNext= new int[n];\\n        int[] maxPrev= new int[n];\\n        int[] maxNext= new int[n];\\n        \\n        Arrays.fill(minPrev,-1);\\n        Arrays.fill(minNext,n);\\n        Arrays.fill(maxPrev,-1);\\n        Arrays.fill(maxNext,n);\\n        \\n        for(int i=0;i<n;i++){\\n            while(!stack.isEmpty() && nums[stack.peek()] > nums[i])\\n                stack.pop();\\n            \\n            if(!stack.isEmpty())\\n                minPrev[i]=stack.peek();\\n            \\n            stack.push(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1929491,
                "title": "o-n-solution-two-stacks",
                "content": "Basic idea - loop through the array and for each element calculate the range sum of subarrays *ending* in that element, add this to the sum that we will eventually return.\\n\\nFor any current value, the sum of ranges ending in that element will be at minimum equal to the sum of ranges ending in the previous element. This will happen if the current element is not the min or max of any subarray that ends with it - we will just reuse previous subarray.\\n\\nNow we consider what cases the new element is either the min or max of a subarray. We will keep track of previous mins and maxes on two stacks that point to the indices of elements that were used as min or max. These will both be initialized to element 0. \\n\\nIn the max case , if the current element is greater than a previous max by a difference of *diff*, then all the subarrays that were using this previous max as the max in the range will now have their value increased by diff. So we look at the difference between the previous max and the previous, previous max to tell us the number of elements affected. We pop the previous max to see the value of the previous previous max. If there is no previous previous max (i.e. the stack is now empty after popping the previous max), then we use the previous max index as the multiplier, since all values before it were affected.\\n\\nIf we have this array and are now considering index 8 (with value 7):\\n1 2 5 1 0 4 1  2 **7**\\n\\nThe max stack will look as follows\\n7 5 2\\n\\nThat is, index 7 (value 2) is at the top.\\n\\nWe first pop 7. The difference between arr[8] and arr[7] is 7-2=5 and the difference between the index of this previous max and the index of the previous previous max is 7-5 = 2, then we increase our running total by 10. \\n\\nPopping 5, the difference between arr[8] and arr[5] is 7-4 = 3, and the difference between this index and the previous index that\\'s now on top of the stack is (5-2)=3, so increase our running sum by 3\\\\*3=9.\\n\\nFinally 7 is greater than arr[2] (5), so we pop the last value from the max stack. This difference is 7-5=2, and since there are no more values on the stack, we know that all remaining values in the array will have their range incremented to include this new max of 7, so we increase this by 2\\\\(2+1)=6.\\n\\nThe min case basically operates with equivalent logic as above. \\n\\nAfter an element has been processed for both its min and max stacks, it will be pushed to the top of both stacks, as depending on whether we increase or decrease it could be either a min or max in the future. \\n\\nSpace - O(n) for the two stacks\\nTime - also O(n) - each element is pushed on each of the stacks once, and then once popped it is never looked at again. \\n\\n\\n```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        long overallSum = 0;\\n        long lastSum = 0;\\n\\n        // keep indices or array indices that could be the max or min of some subarray. \\n        Stack<Integer> possibleMins = new Stack<Integer>();\\n        Stack<Integer> possibleMaxes = new Stack<Integer>();\\n        \\n        possibleMins.push(0);\\n        possibleMaxes.push(0);\\n        \\n        // for each element, find the sum of ranges for all subarrays that end in the current element\\n        for(int i = 1; i < nums.length; i++) {\\n            \\n            //the current sum of ranges is at least the value of the previous sum (in the case where the current element is\\n            // neither min nor max of any range)\\n            long nextSum = lastSum;\\n            \\n            \\n            // update cases where the current element will be the max\\n            while(!possibleMaxes.isEmpty() && nums[i]>nums[possibleMaxes.peek()]) {\\n                \\n                // find the diff from the old max, and how many elements this needs to be applied to\\n                int maxIndex = possibleMaxes.pop();\\n                long diff = nums[i]-nums[maxIndex];\\n                \\n                // if the old max was the only one on the stack, then it was larger than all the elements before it. \\n                // all ranges from 0 to the old max (inclusive) will now have the updated value\\n                int numApplied = possibleMaxes.isEmpty() ? maxIndex+1 : maxIndex-possibleMaxes.peek();\\n                \\n                nextSum += diff*numApplied;\\n            }\\n            \\n            // update cases where the current element will be the min\\n            while(!possibleMins.isEmpty() && nums[i]<nums[possibleMins.peek()]) {\\n                int minIndex = possibleMins.pop();\\n                long diff = nums[minIndex]-nums[i];\\n                int numApplied = possibleMins.isEmpty() ? minIndex+1 : minIndex-possibleMins.peek();\\n                nextSum += diff*numApplied;\\n            }\\n            possibleMins.push(i);\\n            possibleMaxes.push(i);\\n            lastSum = nextSum;\\n            overallSum += lastSum;\\n        }\\n        return overallSum;\\n    }\\n}```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        long overallSum = 0;\\n        long lastSum = 0;\\n\\n        // keep indices or array indices that could be the max or min of some subarray. \\n        Stack<Integer> possibleMins = new Stack<Integer>();\\n        Stack<Integer> possibleMaxes = new Stack<Integer>();\\n        \\n        possibleMins.push(0);\\n        possibleMaxes.push(0);\\n        \\n        // for each element, find the sum of ranges for all subarrays that end in the current element\\n        for(int i = 1; i < nums.length; i++) {\\n            \\n            //the current sum of ranges is at least the value of the previous sum (in the case where the current element is\\n            // neither min nor max of any range)\\n            long nextSum = lastSum;\\n            \\n            \\n            // update cases where the current element will be the max\\n            while(!possibleMaxes.isEmpty() && nums[i]>nums[possibleMaxes.peek()]) {\\n                \\n                // find the diff from the old max, and how many elements this needs to be applied to\\n                int maxIndex = possibleMaxes.pop();\\n                long diff = nums[i]-nums[maxIndex];\\n                \\n                // if the old max was the only one on the stack, then it was larger than all the elements before it. \\n                // all ranges from 0 to the old max (inclusive) will now have the updated value\\n                int numApplied = possibleMaxes.isEmpty() ? maxIndex+1 : maxIndex-possibleMaxes.peek();\\n                \\n                nextSum += diff*numApplied;\\n            }\\n            \\n            // update cases where the current element will be the min\\n            while(!possibleMins.isEmpty() && nums[i]<nums[possibleMins.peek()]) {\\n                int minIndex = possibleMins.pop();\\n                long diff = nums[minIndex]-nums[i];\\n                int numApplied = possibleMins.isEmpty() ? minIndex+1 : minIndex-possibleMins.peek();\\n                nextSum += diff*numApplied;\\n            }\\n            possibleMins.push(i);\\n            possibleMaxes.push(i);\\n            lastSum = nextSum;\\n            overallSum += lastSum;\\n        }\\n        return overallSum;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1906303,
                "title": "illustrated-explanation",
                "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/3d113a8a-e1d9-4e8b-a1df-6f8ed8861f89_1648897077.7995856.png)\\n\\n\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        \"\"\" O(N)TS \"\"\"\\n        stack, lo, hi, sum1, sum2 = [], {}, {}, {}, {}\\n\\n        # (1) find prev mins\\n        for i, n in reversed([*enumerate(nums)]):\\n            while stack and n < nums[stack[-1]]:\\n                lo[stack.pop()] = i\\n            stack += i,\\n\\n        # (2) find prev maxs\\n        stack = []\\n        for i, n in reversed([*enumerate(nums)]):\\n            while stack and n > nums[stack[-1]]:\\n                hi[stack.pop()] = i\\n            stack += i,\\n\\n        # (3) find subarr\\n        for i, n in enumerate(nums):\\n            sum1[i] = sum1[h] + n * (i - h) if (h := hi.get(i)) is not None else n * (i + 1)\\n            sum2[i] = sum2[l] + n * (i - l) if (l := lo.get(i)) is not None else n * (i + 1)\\n\\n        return sum(a - b for a, b in zip(sum1.values(), sum2.values()))",
                "solutionTags": [
                    "Python"
                ],
                "code": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/3d113a8a-e1d9-4e8b-a1df-6f8ed8861f89_1648897077.7995856.png)\\n\\n\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        \"\"\" O(N)TS \"\"\"\\n        stack, lo, hi, sum1, sum2 = [], {}, {}, {}, {}\\n\\n        # (1) find prev mins\\n        for i, n in reversed([*enumerate(nums)]):\\n            while stack and n < nums[stack[-1]]:\\n                lo[stack.pop()] = i\\n            stack += i,\\n\\n        # (2) find prev maxs\\n        stack = []\\n        for i, n in reversed([*enumerate(nums)]):\\n            while stack and n > nums[stack[-1]]:\\n                hi[stack.pop()] = i\\n            stack += i,\\n\\n        # (3) find subarr\\n        for i, n in enumerate(nums):\\n            sum1[i] = sum1[h] + n * (i - h) if (h := hi.get(i)) is not None else n * (i + 1)\\n            sum2[i] = sum2[l] + n * (i - l) if (l := lo.get(i)) is not None else n * (i + 1)\\n\\n        return sum(a - b for a, b in zip(sum1.values(), sum2.values()))",
                "codeTag": "Python3"
            },
            {
                "id": 1781534,
                "title": "java-monotonic-stack-fastee-than-90-o-n",
                "content": "```\\nclass Solution {\\n    \\n    class Pair {\\n        int index;\\n        long count;\\n        \\n        public Pair(int index, long count) {\\n            this.index = index;\\n            this.count = count;\\n        }\\n    }\\n    public long subArrayRanges(int[] nums) {\\n        \\n        ArrayDeque<Pair> stack = new ArrayDeque<>();\\n        int N = nums.length;\\n        long[] left = new long[N];\\n        long[] right = new long[N];\\n        long allMax = 0;\\n        long allMin = 0;\\n        \\n        //find allMax value\\n        \\n        for(int i = 0 ; i < nums.length ; i++) {\\n            long localCount = 1;\\n            while(!stack.isEmpty() && nums[stack.peek().index] <= nums[i]) {\\n                Pair p = stack.pop();\\n                localCount += p.count;\\n            }\\n            stack.push(new Pair(i, localCount));\\n            left[i] = localCount;\\n        }\\n        \\n        stack.clear();\\n        \\n        for(int i = nums.length - 1 ; i >= 0 ; i--) {\\n            long localCount = 1;\\n            while(!stack.isEmpty() && nums[stack.peek().index] < nums[i]) {\\n                Pair p = stack.pop();\\n                localCount += p.count;\\n            }\\n            stack.push(new Pair(i, localCount));\\n            right[i] = localCount;\\n        }\\n        \\n        for(int i = 0 ; i < N ; i++) {\\n            allMax += nums[i]*left[i]*right[i];\\n        }\\n        \\n        stack.clear();\\n        \\n        for(int i = 0 ; i < nums.length ; i++) {\\n            long localCount = 1;\\n            while(!stack.isEmpty() && nums[stack.peek().index] >= nums[i]) {\\n                Pair p = stack.pop();\\n                localCount += p.count;\\n            }\\n            stack.push(new Pair(i, localCount));\\n            left[i] = localCount;\\n        }\\n        \\n        stack.clear();\\n        \\n        for(int i = nums.length - 1 ; i >= 0 ; i--) {\\n            long localCount = 1;\\n            while(!stack.isEmpty() && nums[stack.peek().index] > nums[i]) {\\n                Pair p = stack.pop();\\n                localCount += p.count;\\n            }\\n            stack.push(new Pair(i, localCount));\\n            right[i] = localCount;\\n        }\\n        \\n        for(int i = 0 ; i < N ; i++) {\\n            allMin += nums[i]*left[i]*right[i];\\n        }\\n        \\n        return allMax - allMin;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class Pair {\\n        int index;\\n        long count;\\n        \\n        public Pair(int index, long count) {\\n            this.index = index;\\n            this.count = count;\\n        }\\n    }\\n    public long subArrayRanges(int[] nums) {\\n        \\n        ArrayDeque<Pair> stack = new ArrayDeque<>();\\n        int N = nums.length;\\n        long[] left = new long[N];\\n        long[] right = new long[N];\\n        long allMax = 0;\\n        long allMin = 0;\\n        \\n        //find allMax value\\n        \\n        for(int i = 0 ; i < nums.length ; i++) {\\n            long localCount = 1;\\n            while(!stack.isEmpty() && nums[stack.peek().index] <= nums[i]) {\\n                Pair p = stack.pop();\\n                localCount += p.count;\\n            }\\n            stack.push(new Pair(i, localCount));\\n            left[i] = localCount;\\n        }\\n        \\n        stack.clear();\\n        \\n        for(int i = nums.length - 1 ; i >= 0 ; i--) {\\n            long localCount = 1;\\n            while(!stack.isEmpty() && nums[stack.peek().index] < nums[i]) {\\n                Pair p = stack.pop();\\n                localCount += p.count;\\n            }\\n            stack.push(new Pair(i, localCount));\\n            right[i] = localCount;\\n        }\\n        \\n        for(int i = 0 ; i < N ; i++) {\\n            allMax += nums[i]*left[i]*right[i];\\n        }\\n        \\n        stack.clear();\\n        \\n        for(int i = 0 ; i < nums.length ; i++) {\\n            long localCount = 1;\\n            while(!stack.isEmpty() && nums[stack.peek().index] >= nums[i]) {\\n                Pair p = stack.pop();\\n                localCount += p.count;\\n            }\\n            stack.push(new Pair(i, localCount));\\n            left[i] = localCount;\\n        }\\n        \\n        stack.clear();\\n        \\n        for(int i = nums.length - 1 ; i >= 0 ; i--) {\\n            long localCount = 1;\\n            while(!stack.isEmpty() && nums[stack.peek().index] > nums[i]) {\\n                Pair p = stack.pop();\\n                localCount += p.count;\\n            }\\n            stack.push(new Pair(i, localCount));\\n            right[i] = localCount;\\n        }\\n        \\n        for(int i = 0 ; i < N ; i++) {\\n            allMin += nums[i]*left[i]*right[i];\\n        }\\n        \\n        return allMax - allMin;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624463,
                "title": "java-o-n-solution-monotonic-stack",
                "content": "\\nWe can use monotonic stack to fine next largest and next smallest elements on their right and left.\\nWe use the same logic to find how much left and right the current element can be maximum and minimum.\\n\\nNext Greater Element Proble :- https://leetcode.com/problems/next-greater-element-i/\\n\\nThe below code can be written as more consice and smaller, But made it longer for readability.\\n\\n\\n```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        \\n        long result = 0;\\n        \\n        int[] nextSmallestLeft = findNextSmallestLeftIndex(nums);\\n        int[] nextSmallestRight = findNextSmallestRightIndex(nums);\\n      \\n        \\n        int[] nextLargestLeft = findNextLargestLeftIndex(nums);\\n        int[] nextLargestRight = findNextLargestRightIndex(nums);\\n        \\n      \\n        \\n        for(int index = 0; index< nums.length; index++){\\n            \\n            // how much left and right the current ELement can be the minimum\\n            long minleftCount = (index - nextSmallestLeft[index]) -1;\\n            long minrightCount = (nextSmallestRight[index] - index) -1;\\n            \\n            // how much left and right the current ELement can be the maximum\\n            long maxleftCount = (index - nextLargestLeft[index] ) -1;\\n            long maxrightCount = (nextLargestRight[index] - index) -1;\\n            \\n           \\n            // count of subarrays  for which current elemnt is minimum\\n            long totalMinCount = minleftCount + minrightCount + (minleftCount * minrightCount);\\n            // count of subarrays  for which current elemnt is maximum\\n            long totalMaxCount = maxleftCount + maxrightCount + (maxleftCount * maxrightCount);\\n            \\n            result += ( totalMaxCount - totalMinCount) * nums[index];\\n            \\n           \\n        }\\n        \\n        return result;\\n        \\n        \\n    }\\n    \\n   \\n    private int[] findNextSmallestLeftIndex(int[] nums){\\n        \\n        int[] result = new int[nums.length];\\n        \\n        Stack<Integer> decreasingStack = new Stack<>();\\n        \\n        \\n        for(int index = 0; index<nums.length; index++){\\n\\n            while(!decreasingStack.isEmpty() && nums[decreasingStack.peek()] > nums[index] ){\\n\\n                decreasingStack.pop();\\n\\n            }    \\n            \\n\\n            if(decreasingStack.isEmpty()){\\n                result[index] = -1;\\n\\n            }\\n            else{\\n\\n                result[index] = decreasingStack.peek();\\n            }\\n\\n            decreasingStack.push(index);\\n\\n\\n        }    \\n        return result;\\n    }\\n    \\n    private int[] findNextSmallestRightIndex(int[] nums){\\n       int[] result = new int[nums.length];\\n        \\n        Stack<Integer> decreasingStack = new Stack<>();\\n        \\n            \\n        for(int index = nums.length-1; index>=0; index--){\\n\\n\\n            while(!decreasingStack.isEmpty() && nums[decreasingStack.peek()] >= nums[index] ){\\n\\n                decreasingStack.pop();\\n\\n            }    \\n     \\n            if(decreasingStack.isEmpty()){\\n                result[index] = nums.length;\\n\\n            }\\n            else{\\n\\n                result[index] = decreasingStack.peek();\\n            }\\n\\n            decreasingStack.push(index);\\n\\n\\n        }\\n            \\n        \\n        return result;\\n        \\n\\n    }\\n    \\n     private int[] findNextLargestLeftIndex(int[] nums){\\n        \\n        int[] result = new int[nums.length];\\n        \\n        Stack<Integer> increasingStack = new Stack<>();\\n        \\n\\n        for(int index = 0; index<nums.length; index++){\\n\\n            while(!increasingStack.isEmpty() && nums[increasingStack.peek()] < nums[index] ){\\n\\n                increasingStack.pop();\\n\\n            }\\n\\n            if(increasingStack.isEmpty()){\\n                result[index] = -1;\\n\\n            }\\n            else{\\n\\n                result[index] = increasingStack.peek();\\n            }\\n\\n            increasingStack.push(index);\\n\\n\\n        }    \\n      \\n        \\n        return result;\\n        \\n        \\n        \\n    }\\n    \\n    private int[] findNextLargestRightIndex(int[] nums){\\n        \\n        int[] result = new int[nums.length];\\n        \\n        Stack<Integer> increasingStack = new Stack<>();\\n            \\n        for(int index = nums.length-1; index>=0; index--){\\n\\n\\n            while(!increasingStack.isEmpty() && nums[increasingStack.peek()] <= nums[index] ){\\n\\n                increasingStack.pop();\\n\\n            }\\n\\n\\n\\n            if(increasingStack.isEmpty()){\\n                result[index] = nums.length;\\n\\n            }\\n            else{\\n\\n                result[index] = increasingStack.peek();\\n            }\\n\\n            increasingStack.push(index);\\n\\n\\n        }\\n        \\n        return result;\\n        \\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        \\n        long result = 0;\\n        \\n        int[] nextSmallestLeft = findNextSmallestLeftIndex(nums);\\n        int[] nextSmallestRight = findNextSmallestRightIndex(nums);\\n      \\n        \\n        int[] nextLargestLeft = findNextLargestLeftIndex(nums);\\n        int[] nextLargestRight = findNextLargestRightIndex(nums);\\n        \\n      \\n        \\n        for(int index = 0; index< nums.length; index++){\\n            \\n            // how much left and right the current ELement can be the minimum\\n            long minleftCount = (index - nextSmallestLeft[index]) -1;\\n            long minrightCount = (nextSmallestRight[index] - index) -1;\\n            \\n            // how much left and right the current ELement can be the maximum\\n            long maxleftCount = (index - nextLargestLeft[index] ) -1;\\n            long maxrightCount = (nextLargestRight[index] - index) -1;\\n            \\n           \\n            // count of subarrays  for which current elemnt is minimum\\n            long totalMinCount = minleftCount + minrightCount + (minleftCount * minrightCount);\\n            // count of subarrays  for which current elemnt is maximum\\n            long totalMaxCount = maxleftCount + maxrightCount + (maxleftCount * maxrightCount);\\n            \\n            result += ( totalMaxCount - totalMinCount) * nums[index];\\n            \\n           \\n        }\\n        \\n        return result;\\n        \\n        \\n    }\\n    \\n   \\n    private int[] findNextSmallestLeftIndex(int[] nums){\\n        \\n        int[] result = new int[nums.length];\\n        \\n        Stack<Integer> decreasingStack = new Stack<>();\\n        \\n        \\n        for(int index = 0; index<nums.length; index++){\\n\\n            while(!decreasingStack.isEmpty() && nums[decreasingStack.peek()] > nums[index] ){\\n\\n                decreasingStack.pop();\\n\\n            }    \\n            \\n\\n            if(decreasingStack.isEmpty()){\\n                result[index] = -1;\\n\\n            }\\n            else{\\n\\n                result[index] = decreasingStack.peek();\\n            }\\n\\n            decreasingStack.push(index);\\n\\n\\n        }    \\n        return result;\\n    }\\n    \\n    private int[] findNextSmallestRightIndex(int[] nums){\\n       int[] result = new int[nums.length];\\n        \\n        Stack<Integer> decreasingStack = new Stack<>();\\n        \\n            \\n        for(int index = nums.length-1; index>=0; index--){\\n\\n\\n            while(!decreasingStack.isEmpty() && nums[decreasingStack.peek()] >= nums[index] ){\\n\\n                decreasingStack.pop();\\n\\n            }    \\n     \\n            if(decreasingStack.isEmpty()){\\n                result[index] = nums.length;\\n\\n            }\\n            else{\\n\\n                result[index] = decreasingStack.peek();\\n            }\\n\\n            decreasingStack.push(index);\\n\\n\\n        }\\n            \\n        \\n        return result;\\n        \\n\\n    }\\n    \\n     private int[] findNextLargestLeftIndex(int[] nums){\\n        \\n        int[] result = new int[nums.length];\\n        \\n        Stack<Integer> increasingStack = new Stack<>();\\n        \\n\\n        for(int index = 0; index<nums.length; index++){\\n\\n            while(!increasingStack.isEmpty() && nums[increasingStack.peek()] < nums[index] ){\\n\\n                increasingStack.pop();\\n\\n            }\\n\\n            if(increasingStack.isEmpty()){\\n                result[index] = -1;\\n\\n            }\\n            else{\\n\\n                result[index] = increasingStack.peek();\\n            }\\n\\n            increasingStack.push(index);\\n\\n\\n        }    \\n      \\n        \\n        return result;\\n        \\n        \\n        \\n    }\\n    \\n    private int[] findNextLargestRightIndex(int[] nums){\\n        \\n        int[] result = new int[nums.length];\\n        \\n        Stack<Integer> increasingStack = new Stack<>();\\n            \\n        for(int index = nums.length-1; index>=0; index--){\\n\\n\\n            while(!increasingStack.isEmpty() && nums[increasingStack.peek()] <= nums[index] ){\\n\\n                increasingStack.pop();\\n\\n            }\\n\\n\\n\\n            if(increasingStack.isEmpty()){\\n                result[index] = nums.length;\\n\\n            }\\n            else{\\n\\n                result[index] = increasingStack.peek();\\n            }\\n\\n            increasingStack.push(index);\\n\\n\\n        }\\n        \\n        return result;\\n        \\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624377,
                "title": "c-brute-force-solution-o-n-2",
                "content": "**Time Complexity: O(n^2) \\nSpace Complexity: O(1)**\\n\\n```\\n\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        \\n        long long int sum = 0;\\n        int n = nums.size();\\n    \\n        for (int i = 0; i < n; i++) {\\n            int mn = nums[i];\\n            int mx = nums[i];\\n        \\n            for (int j = i; j < n; j++) {\\n\\n                if(nums[j]>mx)\\n                {\\n                    mx = nums[j];\\n                }\\n                if(nums[j]<mn)\\n                {\\n                    mn = nums[j];\\n                }\\n                sum = sum + (mx - mn);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn sum; \\n\\t   }\\n   };\\n```\\n\\n**Suggestions are always welcome. HAPPY CODING :)**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        \\n        long long int sum = 0;\\n        int n = nums.size();\\n    \\n        for (int i = 0; i < n; i++) {\\n            int mn = nums[i];\\n            int mx = nums[i];\\n        \\n            for (int j = i; j < n; j++) {\\n\\n                if(nums[j]>mx)\\n                {\\n                    mx = nums[j];\\n                }\\n                if(nums[j]<mn)\\n                {\\n                    mn = nums[j];\\n                }\\n                sum = sum + (mx - mn);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn sum; \\n\\t   }\\n   };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713641,
                "title": "very-easy-java-solution",
                "content": "can you please upvote me \\uD83D\\uDE18\\n\\n# Code\\n```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n\\n        int n = nums.length;\\n        long ans = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            int max = nums[i];\\n            int min = nums[i];\\n            for(int j=i; j<n; j++)\\n            {\\n                max = (max<nums[j]) ? nums[j] : max;\\n                min = (min>nums[j]) ? nums[j] : min;\\n                ans = ans + max - min;\\n            }\\n        }\\n     return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n\\n        int n = nums.length;\\n        long ans = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            int max = nums[i];\\n            int min = nums[i];\\n            for(int j=i; j<n; j++)\\n            {\\n                max = (max<nums[j]) ? nums[j] : max;\\n                min = (min>nums[j]) ? nums[j] : min;\\n                ans = ans + max - min;\\n            }\\n        }\\n     return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892009,
                "title": "cpp-brute-force",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) \\n\\t{\\n\\t\\t  long long ans =0;\\n          for(int i=0;i<nums.size();i++)\\n\\t\\t  {\\n\\t\\t       long long max = INT_MIN;\\n\\t\\t\\t   long long min = INT_MAX;\\n\\t\\t\\t   \\n\\t\\t\\t   for(int j=i;j<nums.size();j++)\\n\\t\\t\\t   {\\n\\t\\t\\t   \\t    if(nums[j] > max)\\n\\t\\t\\t   \\t    {\\n\\t\\t\\t   \\t       max = nums[j];\\t\\n\\t\\t\\t        }\\n\\t\\t\\t        if(nums[j] < min)\\n\\t\\t\\t        {\\n\\t\\t\\t        \\tmin = nums[j];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tans = ans + (max - min);\\n\\t\\t\\t   }\\t\\n\\t\\t  }    \\n\\t\\t  return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) \\n\\t{\\n\\t\\t  long long ans =0;\\n          for(int i=0;i<nums.size();i++)\\n\\t\\t  {\\n\\t\\t       long long max = INT_MIN;\\n\\t\\t\\t   long long min = INT_MAX;\\n\\t\\t\\t   \\n\\t\\t\\t   for(int j=i;j<nums.size();j++)\\n\\t\\t\\t   {\\n\\t\\t\\t   \\t    if(nums[j] > max)\\n\\t\\t\\t   \\t    {\\n\\t\\t\\t   \\t       max = nums[j];\\t\\n\\t\\t\\t        }\\n\\t\\t\\t        if(nums[j] < min)\\n\\t\\t\\t        {\\n\\t\\t\\t        \\tmin = nums[j];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tans = ans + (max - min);\\n\\t\\t\\t   }\\t\\n\\t\\t  }    \\n\\t\\t  return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891026,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        long long int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int a=INT_MIN;\\n            int b=INT_MAX;\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                a=max(a,nums[j]);\\n                b=min(b,nums[j]);\\n                sum=sum+abs(b-a);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        long long int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int a=INT_MIN;\\n            int b=INT_MAX;\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                a=max(a,nums[j]);\\n                b=min(b,nums[j]);\\n                sum=sum+abs(b-a);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696122,
                "title": "java-simple-solution-w-detailed-explanation-using-monotonic-stack",
                "content": "# Intuition\\nJava Solution to Sum Of Subarray Ranges.\\n\\nIncluded detailed explanation in comments in code.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$ where N is the size of input array $$nums$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$ where N is the size of input array $$nums$$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public long subArrayRanges(int[] nums) {\\n        // Null or empty check for input\\n        if (nums == null || nums.length <= 1) return 0L;\\n\\n        int n = nums.length;                                    // Length of nums array\\n        long sum = 0;                                           // Stores the sum of subarray ranges\\n\\n        // Init a Monotonic Stack (Queue) - Stores indices of nums to find max and mins.\\n        // Find all max and mins in all subarrays and the sum of those values will be the result.\\n        // Used ArrayDeque for Stack instead of Stack as ArrayDeque does not require acquiring & releasing thread locks, which is costly in time\\n        Deque<Integer> stack = new ArrayDeque<Integer>();\\n\\n        // Add subarray maximums to the global sum\\n        for (int i = 0; i <= n; i++)\\n        {\\n            while (!stack.isEmpty() && (i == n || nums[stack.peekLast()] < nums[i]))\\n            {\\n                int currMax = stack.removeLast();                       // Remove current max from stack\\n                // Left is the previous maximum or -1 current max has always been the max\\n                int left = stack.isEmpty() ? -1 : stack.peekLast();\\n                int right = i;\\n\\n                // total number of subarrays = (currMax - previous_max) * (right - currMax)\\n                // total number of additions = total number of subarrays * num[currMax] -> add nums[currMax] times\\n                sum += (long) (currMax - left) * (right - currMax) * nums[currMax];\\n            }\\n\\n            // Add index to the stack once all of the previous maximums are found and added to the global sum\\n            stack.add(i);\\n        }\\n\\n        // Clear the stack so we can handle Minimums next\\n        stack.clear();\\n\\n        // Subtract subarray minimums from the global sum.\\n        // Last element in the stack contains the index of the min value from the input.\\n        // At all other positions of the stack with a greater value than the min, we remove\\n        // that element from the stack so we can add the current index to the end of the stack.\\n        // If a value smaller than the current min is found, then we\\'ve reached the end of the\\n        // range for the current min.\\n        for (int i = 0; i <= n; i++)\\n        {\\n            while (!stack.isEmpty() && (i == n || nums[stack.peekLast()] > nums[i]))\\n            {\\n                int currMin = stack.removeLast();                       // Remove current min from stack\\n                // Left is the previous min or -1 if currMin has always been the min\\n                int left = stack.isEmpty() ? -1 : stack.peekLast();\\n                int right = i;\\n                \\n                // total number of subarrays = (currMin - previous_min) * (right - currMin)\\n                // total number of subtractions = total number of subarrays * num[currMin] -> subtract nums[currMin] times\\n                sum -= (long) (currMin - left) * (right - currMin) * nums[currMin];\\n            }\\n\\n            // Add index to the stack once all of the previous mins are found and subtracted from global sum\\n            stack.add(i);\\n        }\\n\\n        // Return the sum of Subarray Ranges = sum of subarray max - sum of subarray min\\n        return sum;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack",
                    "Queue",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long subArrayRanges(int[] nums) {\\n        // Null or empty check for input\\n        if (nums == null || nums.length <= 1) return 0L;\\n\\n        int n = nums.length;                                    // Length of nums array\\n        long sum = 0;                                           // Stores the sum of subarray ranges\\n\\n        // Init a Monotonic Stack (Queue) - Stores indices of nums to find max and mins.\\n        // Find all max and mins in all subarrays and the sum of those values will be the result.\\n        // Used ArrayDeque for Stack instead of Stack as ArrayDeque does not require acquiring & releasing thread locks, which is costly in time\\n        Deque<Integer> stack = new ArrayDeque<Integer>();\\n\\n        // Add subarray maximums to the global sum\\n        for (int i = 0; i <= n; i++)\\n        {\\n            while (!stack.isEmpty() && (i == n || nums[stack.peekLast()] < nums[i]))\\n            {\\n                int currMax = stack.removeLast();                       // Remove current max from stack\\n                // Left is the previous maximum or -1 current max has always been the max\\n                int left = stack.isEmpty() ? -1 : stack.peekLast();\\n                int right = i;\\n\\n                // total number of subarrays = (currMax - previous_max) * (right - currMax)\\n                // total number of additions = total number of subarrays * num[currMax] -> add nums[currMax] times\\n                sum += (long) (currMax - left) * (right - currMax) * nums[currMax];\\n            }\\n\\n            // Add index to the stack once all of the previous maximums are found and added to the global sum\\n            stack.add(i);\\n        }\\n\\n        // Clear the stack so we can handle Minimums next\\n        stack.clear();\\n\\n        // Subtract subarray minimums from the global sum.\\n        // Last element in the stack contains the index of the min value from the input.\\n        // At all other positions of the stack with a greater value than the min, we remove\\n        // that element from the stack so we can add the current index to the end of the stack.\\n        // If a value smaller than the current min is found, then we\\'ve reached the end of the\\n        // range for the current min.\\n        for (int i = 0; i <= n; i++)\\n        {\\n            while (!stack.isEmpty() && (i == n || nums[stack.peekLast()] > nums[i]))\\n            {\\n                int currMin = stack.removeLast();                       // Remove current min from stack\\n                // Left is the previous min or -1 if currMin has always been the min\\n                int left = stack.isEmpty() ? -1 : stack.peekLast();\\n                int right = i;\\n                \\n                // total number of subarrays = (currMin - previous_min) * (right - currMin)\\n                // total number of subtractions = total number of subarrays * num[currMin] -> subtract nums[currMin] times\\n                sum -= (long) (currMin - left) * (right - currMin) * nums[currMin];\\n            }\\n\\n            // Add index to the stack once all of the previous mins are found and subtracted from global sum\\n            stack.add(i);\\n        }\\n\\n        // Return the sum of Subarray Ranges = sum of subarray max - sum of subarray min\\n        return sum;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2380244,
                "title": "python-from-o-n-3-to-o-n-tc",
                "content": "\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        \\n        # brute force O(n^3) O(1)\\n        \"\"\"\\n        result = 0\\n        for i in range(len(nums)):\\n            for j in range(i, len(nums)):\\n                result += max(nums[i:(j + 1)]) - min(nums[i:(j + 1)])\\n        return result        \\n        \"\"\"\\n\\n        # optimize using running min and max O(n^2) O(1)\\n        \"\"\"\\n        result = 0\\n        for i in range(len(nums)):\\n            min_ = max_ = nums[i]\\n            for j in range(i + 1, len(nums)):\\n                min_ = min(min_, nums[j])\\n                max_ = max(max_, nums[j])\\n                result += max_ - min_\\n        return result\\n        \"\"\"\\n    \\n        # monotonic stack version O(n) O(n)\\n        def subSubArrayMaxs(nums, max_=True):\\n            \\n            \"\"\"\\n            Idea: use monotonic stack to find previous greater element and next greater element.\\n            Having both we can compute the number of subarray where current element is the max/min.\\n            -> code is quite condensed, can also just use two seperate loops to find next and previous greater elements.\\n            \"\"\"\\n            res = 0\\n            stack = []\\n            sign = 1 if max_ else -1\\n            for next_greater_element in range(len(nums) + 1):\\n                while stack and (next_greater_element == len(nums) or sign * nums[next_greater_element] >= sign * nums[stack[-1]]):\\n                    i = stack.pop()\\n                    previous_greater_element = stack[-1] if stack else -1\\n                    res += (i - previous_greater_element) * (next_greater_element - i) * nums[i]\\n                stack.append(next_greater_element)\\n            return res\\n            \\n        return subSubArrayMaxs(nums, True) - subSubArrayMaxs(nums, False)",
                "solutionTags": [
                    "Python",
                    "Monotonic Stack"
                ],
                "code": "\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        \\n        # brute force O(n^3) O(1)\\n        \"\"\"\\n        result = 0\\n        for i in range(len(nums)):\\n            for j in range(i, len(nums)):\\n                result += max(nums[i:(j + 1)]) - min(nums[i:(j + 1)])\\n        return result        \\n        \"\"\"\\n\\n        # optimize using running min and max O(n^2) O(1)\\n        \"\"\"\\n        result = 0\\n        for i in range(len(nums)):\\n            min_ = max_ = nums[i]\\n            for j in range(i + 1, len(nums)):\\n                min_ = min(min_, nums[j])\\n                max_ = max(max_, nums[j])\\n                result += max_ - min_\\n        return result\\n        \"\"\"\\n    \\n        # monotonic stack version O(n) O(n)\\n        def subSubArrayMaxs(nums, max_=True):\\n            \\n            \"\"\"\\n            Idea: use monotonic stack to find previous greater element and next greater element.\\n            Having both we can compute the number of subarray where current element is the max/min.\\n            -> code is quite condensed, can also just use two seperate loops to find next and previous greater elements.\\n            \"\"\"\\n            res = 0\\n            stack = []\\n            sign = 1 if max_ else -1\\n            for next_greater_element in range(len(nums) + 1):\\n                while stack and (next_greater_element == len(nums) or sign * nums[next_greater_element] >= sign * nums[stack[-1]]):\\n                    i = stack.pop()\\n                    previous_greater_element = stack[-1] if stack else -1\\n                    res += (i - previous_greater_element) * (next_greater_element - i) * nums[i]\\n                stack.append(next_greater_element)\\n            return res\\n            \\n        return subSubArrayMaxs(nums, True) - subSubArrayMaxs(nums, False)",
                "codeTag": "Python3"
            },
            {
                "id": 2342411,
                "title": "simple-c-solution-with-for-loops",
                "content": "```\\npublic class Solution {\\n    public long SubArrayRanges(int[] nums) {\\n        long sum = 0;\\n        int max = int.MinValue;\\n        int min = int.MaxValue;\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            max = int.MinValue; //reset min and max for the next iteration\\n            min = int.MaxValue;\\n            for(int j = i; j < nums.Length; j++)\\n            {\\n                // take max and min by iterating over all j values for specific i value\\n                max = Math.Max(max, nums[j]);\\n                min = Math.Min(min, nums[j]);\\n                sum += (max - min);\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public long SubArrayRanges(int[] nums) {\\n        long sum = 0;\\n        int max = int.MinValue;\\n        int min = int.MaxValue;\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            max = int.MinValue; //reset min and max for the next iteration\\n            min = int.MaxValue;\\n            for(int j = i; j < nums.Length; j++)\\n            {\\n                // take max and min by iterating over all j values for specific i value\\n                max = Math.Max(max, nums[j]);\\n                min = Math.Min(min, nums[j]);\\n                sum += (max - min);\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321748,
                "title": "simple-java-solution-using-brute-force",
                "content": "```\\npublic long subArrayRanges(int[] nums) {\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int max = nums[i];\\n            int min = nums[i];\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                max=Math.max(nums[j],max);\\n                min = Math.min(nums[j],min);\\n                sum+=Math.abs(max-min);\\n            }\\n        }\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic long subArrayRanges(int[] nums) {\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int max = nums[i];\\n            int min = nums[i];\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                max=Math.max(nums[j],max);\\n                min = Math.min(nums[j],min);\\n                sum+=Math.abs(max-min);\\n            }\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2287869,
                "title": "monotonic-stack",
                "content": "```python\\n\\'\\'\\'\\n4 monotonic stacks, aggregate min/max\\nO(n), O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        next_smaller = [0] * n # index of\\n        prev_smaller = [0] * n # index of\\n        next_larger = [0] * n # index of\\n        prev_larger = [0] * n # index of\\n        \\n        stack = [] # monotonic non-decreasing stack, index of, to find next smaller\\n        stack2 = [] # monotonic increasing stack, index of, to find prev smaller\\n        stack3 = [] # monotonic non-increasing stack, index of, to find next larger\\n        stack4 = [] # monotonic decreasing stack, index of, to find prev larger\\n        \\n        # find next smaller\\n        for i in range(n):\\n            while stack and nums[stack[-1]] > nums[i]:\\n                next_smaller[stack.pop()] = i\\n            stack.append(i)\\n        while stack:\\n            next_smaller[stack.pop()] = n\\n            \\n        # find prev smaller\\n        for i in reversed(range(n)):\\n            while stack2 and nums[stack2[-1]] >= nums[i]:\\n                prev_smaller[stack2.pop()] = i\\n            stack2.append(i)\\n        while stack2:\\n            prev_smaller[stack2.pop()] = -1\\n        \\n        # find next larger\\n        for i in range(n):\\n            while stack3 and nums[stack3[-1]] < nums[i]:\\n                next_larger[stack3.pop()] = i\\n            stack3.append(i)\\n        while stack3:\\n            next_larger[stack3.pop()] = n\\n        \\n        # find prev larger\\n        for i in reversed(range(n)):\\n            while stack4 and nums[stack4[-1]] <= nums[i]:\\n                prev_larger[stack4.pop()] = i\\n            stack4.append(i)\\n        while stack4:\\n            prev_larger[stack4.pop()] = -1\\n        \\n        # aggregate(ranges) = aggregate(max - min) = aggregate(max) - aggregate(min)\\n        aggregate_mins = aggregate_maxes = 0\\n        for i in range(n):\\n            # all subarrays where nums[i] is the min\\n            aggregate_mins += nums[i] * (i - prev_smaller[i]) * (next_smaller[i] - i)\\n            # all subarrays where nums[i] is the max\\n            aggregate_maxes += nums[i] * (i - prev_larger[i]) * (next_larger[i] - i)\\n        return aggregate_maxes - aggregate_mins\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n\\'\\'\\'\\n4 monotonic stacks, aggregate min/max\\nO(n), O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        next_smaller = [0] * n # index of\\n        prev_smaller = [0] * n # index of\\n        next_larger = [0] * n # index of\\n        prev_larger = [0] * n # index of\\n        \\n        stack = [] # monotonic non-decreasing stack, index of, to find next smaller\\n        stack2 = [] # monotonic increasing stack, index of, to find prev smaller\\n        stack3 = [] # monotonic non-increasing stack, index of, to find next larger\\n        stack4 = [] # monotonic decreasing stack, index of, to find prev larger\\n        \\n        # find next smaller\\n        for i in range(n):\\n            while stack and nums[stack[-1]] > nums[i]:\\n                next_smaller[stack.pop()] = i\\n            stack.append(i)\\n        while stack:\\n            next_smaller[stack.pop()] = n\\n            \\n        # find prev smaller\\n        for i in reversed(range(n)):\\n            while stack2 and nums[stack2[-1]] >= nums[i]:\\n                prev_smaller[stack2.pop()] = i\\n            stack2.append(i)\\n        while stack2:\\n            prev_smaller[stack2.pop()] = -1\\n        \\n        # find next larger\\n        for i in range(n):\\n            while stack3 and nums[stack3[-1]] < nums[i]:\\n                next_larger[stack3.pop()] = i\\n            stack3.append(i)\\n        while stack3:\\n            next_larger[stack3.pop()] = n\\n        \\n        # find prev larger\\n        for i in reversed(range(n)):\\n            while stack4 and nums[stack4[-1]] <= nums[i]:\\n                prev_larger[stack4.pop()] = i\\n            stack4.append(i)\\n        while stack4:\\n            prev_larger[stack4.pop()] = -1\\n        \\n        # aggregate(ranges) = aggregate(max - min) = aggregate(max) - aggregate(min)\\n        aggregate_mins = aggregate_maxes = 0\\n        for i in range(n):\\n            # all subarrays where nums[i] is the min\\n            aggregate_mins += nums[i] * (i - prev_smaller[i]) * (next_smaller[i] - i)\\n            # all subarrays where nums[i] is the max\\n            aggregate_maxes += nums[i] * (i - prev_larger[i]) * (next_larger[i] - i)\\n        return aggregate_maxes - aggregate_mins\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276126,
                "title": "c-o-n-comments-clear-simple",
                "content": "```\\nclass Solution {\\n    template<typename Pred>\\n    long long getPredicateSum(vector<int>& nums, Pred pred) {\\n        vector<int> rPred(nums.size(), 0);\\n        stack<int> st;\\n        const int n = nums.size();\\n        // for each Elt get how much elements pred or equal to the right\\n        for (int i = n - 1; i >= 0; --i) {\\n            auto v = nums[i];\\n            while(!st.empty() && !pred(nums[st.top()], v))\\n                st.pop();\\n            rPred[i] = n - i - 1;\\n            if (!st.empty())\\n                rPred[i] = st.top() - i - 1;\\n            st.push(i);\\n        }\\n        while(!st.empty())\\n            st.pop();\\n        long long ans = 0;\\n        // do the same for the left and strictly pred (not to calculate maximums/minimums twice)\\n        for (int i = 0 ; i < n ; ++i) {\\n            auto v = nums[i];\\n            while(!st.empty() && pred(v, nums[st.top()]))\\n                st.pop();\\n            auto lPred = i;\\n            if (!st.empty())\\n                lPred = i - st.top() - 1;\\n            // accumulate the answer, the number of possibilities to put the left bound\\n            // multiplied by the number of possibilities to put the right bound\\n            ans += 1LL * v * ((rPred[i] + 1) * (lPred + 1));\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\npublic:    \\n    long long subArrayRanges(vector<int>& nums) {\\n        // O(n) solution\\n        // Calculate for each number how many subarrays contain it as max, get this sum for all elts\\n        // Do the same for minimum, via less<int> predicate\\n        // return the sums difference\\n        // beautiful stuff :)\\n        return getPredicateSum(nums, greater<int>()) - getPredicateSum(nums, less<int>());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    template<typename Pred>\\n    long long getPredicateSum(vector<int>& nums, Pred pred) {\\n        vector<int> rPred(nums.size(), 0);\\n        stack<int> st;\\n        const int n = nums.size();\\n        // for each Elt get how much elements pred or equal to the right\\n        for (int i = n - 1; i >= 0; --i) {\\n            auto v = nums[i];\\n            while(!st.empty() && !pred(nums[st.top()], v))\\n                st.pop();\\n            rPred[i] = n - i - 1;\\n            if (!st.empty())\\n                rPred[i] = st.top() - i - 1;\\n            st.push(i);\\n        }\\n        while(!st.empty())\\n            st.pop();\\n        long long ans = 0;\\n        // do the same for the left and strictly pred (not to calculate maximums/minimums twice)\\n        for (int i = 0 ; i < n ; ++i) {\\n            auto v = nums[i];\\n            while(!st.empty() && pred(v, nums[st.top()]))\\n                st.pop();\\n            auto lPred = i;\\n            if (!st.empty())\\n                lPred = i - st.top() - 1;\\n            // accumulate the answer, the number of possibilities to put the left bound\\n            // multiplied by the number of possibilities to put the right bound\\n            ans += 1LL * v * ((rPred[i] + 1) * (lPred + 1));\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\npublic:    \\n    long long subArrayRanges(vector<int>& nums) {\\n        // O(n) solution\\n        // Calculate for each number how many subarrays contain it as max, get this sum for all elts\\n        // Do the same for minimum, via less<int> predicate\\n        // return the sums difference\\n        // beautiful stuff :)\\n        return getPredicateSum(nums, greater<int>()) - getPredicateSum(nums, less<int>());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272683,
                "title": "dead-simple-python-accepted",
                "content": "It is this easy, we just maintain max and min for each range\\n```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n\\n        ans = 0\\n\\n        for i in range(len(nums)):\\n            max_ = nums[i]\\n            min_ = nums[i]\\n            for j in range(i, len(nums)):\\n                if nums[j] > max_:\\n                    max_ = nums[j]\\n                if nums[j] < min_:\\n                    min_ = nums[j]\\n                ans += max_ - min_\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n\\n        ans = 0\\n\\n        for i in range(len(nums)):\\n            max_ = nums[i]\\n            min_ = nums[i]\\n            for j in range(i, len(nums)):\\n                if nums[j] > max_:\\n                    max_ = nums[j]\\n                if nums[j] < min_:\\n                    min_ = nums[j]\\n                ans += max_ - min_\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2204928,
                "title": "java-easy-explanation",
                "content": "Prerequisite : https://leetcode.com/problems/sum-of-subarray-minimums/  (First solve this question and then Sum of Subarray Ranges will be a piece of cake)\\n\\nConsidering that you have solved **Sum of Subarray Minimums**, you may have understood that here we need to find **Sum of Subarray Maximums - Sum of Subarray Minimums**\\n\\n```\\nclass Solution {\\n    \\n    public long sumSubarrayMins(int[] A) {\\n        Stack<Integer> stack = new Stack<>();\\n        int n = A.length;\\n        long count = 0;\\n        \\n        for(int i=0;i<=n;i++){\\n            while(!stack.isEmpty() && (i==n || A[stack.peek()]>A[i])){\\n                int mid = stack.pop();\\n                int l = mid - (stack.isEmpty() ? -1 : stack.peek());\\n                int r = i - mid;\\n                \\n                count += (long)A[mid]*(l)*(r);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        return (count);\\n    }\\n    \\n     public long sumSubarrayMaxs(int[] A) {\\n        Stack<Integer> stack = new Stack<>();\\n        int n = A.length;\\n        long count = 0;\\n        \\n        for(int i=0;i<=n;i++){\\n            while(!stack.isEmpty() && (i==n || A[stack.peek()]<A[i])){\\n                int mid = stack.pop();\\n                int l = mid - (stack.isEmpty() ? -1 : stack.peek());\\n                int r = i - mid;\\n                \\n                count += (long)A[mid]*(l)*(r);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        return (count);\\n    }\\n    \\n    public long subArrayRanges(int[] nums) {\\n        return sumSubarrayMaxs(nums) - sumSubarrayMins(nums);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public long sumSubarrayMins(int[] A) {\\n        Stack<Integer> stack = new Stack<>();\\n        int n = A.length;\\n        long count = 0;\\n        \\n        for(int i=0;i<=n;i++){\\n            while(!stack.isEmpty() && (i==n || A[stack.peek()]>A[i])){\\n                int mid = stack.pop();\\n                int l = mid - (stack.isEmpty() ? -1 : stack.peek());\\n                int r = i - mid;\\n                \\n                count += (long)A[mid]*(l)*(r);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        return (count);\\n    }\\n    \\n     public long sumSubarrayMaxs(int[] A) {\\n        Stack<Integer> stack = new Stack<>();\\n        int n = A.length;\\n        long count = 0;\\n        \\n        for(int i=0;i<=n;i++){\\n            while(!stack.isEmpty() && (i==n || A[stack.peek()]<A[i])){\\n                int mid = stack.pop();\\n                int l = mid - (stack.isEmpty() ? -1 : stack.peek());\\n                int r = i - mid;\\n                \\n                count += (long)A[mid]*(l)*(r);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        return (count);\\n    }\\n    \\n    public long subArrayRanges(int[] nums) {\\n        return sumSubarrayMaxs(nums) - sumSubarrayMins(nums);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189240,
                "title": "python-o-n-solution-faster-than-98-easy-to-understand-with-explanation",
                "content": "The idea is using sum of maximums in subarrays to substract sum of minimums in subarrays.\\n\\nExample for sum of subarrays minimum:\\n\\nFind all subarrays ending with arr[i]:\\n\\n```\\n[4]\\n[4,2] [2]\\n[4,2,3] [2,3] [3]\\n[4,2,3,6] [2,3,6] [3,6] [6]\\n[4,2,3,6,5] [2,3,6,5] [3,6,5] [6,5] [5]\\n[4,2,3,6,5,8] [2,3,6,5,8] [3,6,5,8] [6,5,8] [5,8] [8]\\n```\\n\\nThe minimum:\\n```\\n4\\n2 + 2\\n2 + 2 + 3            -- arr[2] = 3\\n2 + 2 + 3 + 6        -- arr[3] = 6 --> arr[3] = arr[2]+arr[3]*(3-2), arr[2] < arr[3], we don\\'t need to look at the stack\\n2 + 2 + 3 + 5 + 5    -- arr[4] = 5 --> res[4] = res[2]+arr[4]*(4-2), \"2\" is the top of the monotinic stack, we use \"2\" because arr[2]=3 is the last element smaller than 5 (arr[4])\\n2 + 2 + 3 + 5 + 5 + 8\\n```\\n\\nSimilarly for finding maximum:\\n\\nFind all subarrays beginning with arr[i]:\\n```\\n[3] [3,1] [3,1,2] [3,1,2,5] [3,1,2,5,4] [3,1,2,5,4,6]\\n[1] [1,2] [1,2,5] [1,2,5,4] [1,2,5,4,6]\\n[2] [2,5] [2,5,4] [2,5,4,6]\\n[5] [5,4] [5,4,6]\\n[4] [4,6]\\n[6]\\n```\\nThe maximum:\\n```\\n3 + 3 + 3 + 5 + 5 + 6 \\n1 + 2 + 5 + 5 + 6\\n2 + 5 + 5 + 6\\n5 + 5 + 6\\n4 + 6\\n6\\n```\\n\\n\\n\\nCode\\n```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        min_nums = [float(\"-inf\")] + nums\\n        min_stack = [0]\\n        min_res = [0] * len(min_nums)\\n        # maintain a monotonicly increasing stack\\n        for i in range(1,len(min_nums)):\\n            while min_nums[min_stack[-1]] > min_nums[i]:\\n                min_stack.pop()\\n            j = min_stack[-1]\\n            min_res[i] = min_res[j] + min_nums[i]*(i-j)\\n            min_stack.append(i)\\n        \\n        # maintain a monotonicaly decreasing stack\\n        max_nums = nums + [float(\"inf\")]\\n        max_stack = [len(max_nums)-1]\\n        max_res = [0] * len(max_nums)\\n        for i in range(len(max_nums)-2, -1, -1):\\n            while max_nums[max_stack[-1]] < max_nums[i]:\\n                max_stack.pop()\\n            j = max_stack[-1]\\n            max_res[i] = max_res[j] + max_nums[i]*(j-i)\\n            max_stack.append(i)\\n        return sum(max_res) - sum(min_res)\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Monotonic Stack"
                ],
                "code": "```\\n[4]\\n[4,2] [2]\\n[4,2,3] [2,3] [3]\\n[4,2,3,6] [2,3,6] [3,6] [6]\\n[4,2,3,6,5] [2,3,6,5] [3,6,5] [6,5] [5]\\n[4,2,3,6,5,8] [2,3,6,5,8] [3,6,5,8] [6,5,8] [5,8] [8]\\n```\n```\\n4\\n2 + 2\\n2 + 2 + 3            -- arr[2] = 3\\n2 + 2 + 3 + 6        -- arr[3] = 6 --> arr[3] = arr[2]+arr[3]*(3-2), arr[2] < arr[3], we don\\'t need to look at the stack\\n2 + 2 + 3 + 5 + 5    -- arr[4] = 5 --> res[4] = res[2]+arr[4]*(4-2), \"2\" is the top of the monotinic stack, we use \"2\" because arr[2]=3 is the last element smaller than 5 (arr[4])\\n2 + 2 + 3 + 5 + 5 + 8\\n```\n```\\n[3] [3,1] [3,1,2] [3,1,2,5] [3,1,2,5,4] [3,1,2,5,4,6]\\n[1] [1,2] [1,2,5] [1,2,5,4] [1,2,5,4,6]\\n[2] [2,5] [2,5,4] [2,5,4,6]\\n[5] [5,4] [5,4,6]\\n[4] [4,6]\\n[6]\\n```\n```\\n3 + 3 + 3 + 5 + 5 + 6 \\n1 + 2 + 5 + 5 + 6\\n2 + 5 + 5 + 6\\n5 + 5 + 6\\n4 + 6\\n6\\n```\n```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        min_nums = [float(\"-inf\")] + nums\\n        min_stack = [0]\\n        min_res = [0] * len(min_nums)\\n        # maintain a monotonicly increasing stack\\n        for i in range(1,len(min_nums)):\\n            while min_nums[min_stack[-1]] > min_nums[i]:\\n                min_stack.pop()\\n            j = min_stack[-1]\\n            min_res[i] = min_res[j] + min_nums[i]*(i-j)\\n            min_stack.append(i)\\n        \\n        # maintain a monotonicaly decreasing stack\\n        max_nums = nums + [float(\"inf\")]\\n        max_stack = [len(max_nums)-1]\\n        max_res = [0] * len(max_nums)\\n        for i in range(len(max_nums)-2, -1, -1):\\n            while max_nums[max_stack[-1]] < max_nums[i]:\\n                max_stack.pop()\\n            j = max_stack[-1]\\n            max_res[i] = max_res[j] + max_nums[i]*(j-i)\\n            max_stack.append(i)\\n        return sum(max_res) - sum(min_res)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2157643,
                "title": "cpp-simple-solution-using-monotonic-function-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        stack<int> ds;\\n        stack<int> is;\\n        long long sum = 0;\\n        for(int i = 0; i<= nums.size(); ++i){\\n            sum += pushtostack(ds, nums, i, 1) - pushtostack(is, nums, i,  2);\\n            \\n        }\\n        return sum;\\n    }\\n    bool compare(int a, int b, int t){\\n        if(t == 1){\\n          if(a<b)   return true;\\n            else return false;\\n        }\\n        else{\\n            if(a>b) return true;\\n            else return false;\\n        }\\n    }\\n    long pushtostack(stack<int>& st, vector<int> nums, int i, int com){\\n        long sum =0;\\n        while(!st.empty() and (i == nums.size() || compare(nums[st.top()], nums[i], com))){\\n            int pop_i = st.top();st.pop();\\n            int prev_i = st.empty()? -1: st.top();\\n            sum += (pop_i - prev_i)*(i-pop_i)*(long long)nums[pop_i]; \\n        }\\n        st.push(i);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        stack<int> ds;\\n        stack<int> is;\\n        long long sum = 0;\\n        for(int i = 0; i<= nums.size(); ++i){\\n            sum += pushtostack(ds, nums, i, 1) - pushtostack(is, nums, i,  2);\\n            \\n        }\\n        return sum;\\n    }\\n    bool compare(int a, int b, int t){\\n        if(t == 1){\\n          if(a<b)   return true;\\n            else return false;\\n        }\\n        else{\\n            if(a>b) return true;\\n            else return false;\\n        }\\n    }\\n    long pushtostack(stack<int>& st, vector<int> nums, int i, int com){\\n        long sum =0;\\n        while(!st.empty() and (i == nums.size() || compare(nums[st.top()], nums[i], com))){\\n            int pop_i = st.top();st.pop();\\n            int prev_i = st.empty()? -1: st.top();\\n            sum += (pop_i - prev_i)*(i-pop_i)*(long long)nums[pop_i]; \\n        }\\n        st.push(i);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144648,
                "title": "python3-o-n-solution-with-idea-and-explanation",
                "content": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : MONOTONIC STACK ##\\n        ## TIME COMPLEXICITY : O(n) ##\\n        ## Similar to Leetcode: 907. Sum of Subarray Minimums ##\\n        \\n        ## LOGIC ##\\n        ## 1. Lets put the problem statement differently, sum of all subarray ranges = sum of subrray maximums - sum of subarray minimums ##\\n        ## 2. Use monotonic (Next Larger Element , Previous Larger Element) stacks to find subarraymaximums ( i.e for nums[i], what is the largest subarray for which nums[i] is maximum) ##\\n        ## 3. Use monotonic (Next Smaller Element, Previous Smaller Element) stacks to find subarrayminimums ( i.e for nums[i], what is the largest subarray for which nums[i] is minimum) ##\\n        ## 4. result = maximums - minimums ##\\n        \\n        n = len(nums)\\n        ple_idx = [-1] * n        # Index of previous larger element\\n        nle_idx = [n] * n         # Index of next larget element\\n        stack = []\\n        for i, num in enumerate(nums):\\n            while(stack and num > stack[-1][0]):\\n                temp = stack.pop()[1]\\n                nle_idx[temp] = i\\n            ple_idx[i] = stack[-1][1] if(stack) else -1\\n            stack.append((num,i))\\n        # print(ple_idx, nle_idx)\\n        \\n        pse_idx = [-1] * n        # Index of previous smaller element\\n        nse_idx = [n] * n         # Index of next smaller element\\n        stack = []\\n        for i, num in enumerate(nums):\\n            while(stack and num < stack[-1][0]):\\n                temp = stack.pop()[1]\\n                nse_idx[temp] = i\\n            pse_idx[i] = stack[-1][1] if(stack) else -1\\n            stack.append((num,i))\\n        # print(pse_idx, nse_idx)\\n        \\n        minimums = 0\\n        maximums = 0\\n        for i in range(n):\\n            minimums += (nums[i] * (i - pse_idx[i]) * (nse_idx[i] - i))  # multiply to get the count of all subarrays\\n            maximums += (nums[i] * (i - ple_idx[i]) * (nle_idx[i] - i))\\n        # print(maximums ,minimums)\\n        return maximums - minimums\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : MONOTONIC STACK ##\\n        ## TIME COMPLEXICITY : O(n) ##\\n        ## Similar to Leetcode: 907. Sum of Subarray Minimums ##\\n        \\n        ## LOGIC ##\\n        ## 1. Lets put the problem statement differently, sum of all subarray ranges = sum of subrray maximums - sum of subarray minimums ##\\n        ## 2. Use monotonic (Next Larger Element , Previous Larger Element) stacks to find subarraymaximums ( i.e for nums[i], what is the largest subarray for which nums[i] is maximum) ##\\n        ## 3. Use monotonic (Next Smaller Element, Previous Smaller Element) stacks to find subarrayminimums ( i.e for nums[i], what is the largest subarray for which nums[i] is minimum) ##\\n        ## 4. result = maximums - minimums ##\\n        \\n        n = len(nums)\\n        ple_idx = [-1] * n        # Index of previous larger element\\n        nle_idx = [n] * n         # Index of next larget element\\n        stack = []\\n        for i, num in enumerate(nums):\\n            while(stack and num > stack[-1][0]):\\n                temp = stack.pop()[1]\\n                nle_idx[temp] = i\\n            ple_idx[i] = stack[-1][1] if(stack) else -1\\n            stack.append((num,i))\\n        # print(ple_idx, nle_idx)\\n        \\n        pse_idx = [-1] * n        # Index of previous smaller element\\n        nse_idx = [n] * n         # Index of next smaller element\\n        stack = []\\n        for i, num in enumerate(nums):\\n            while(stack and num < stack[-1][0]):\\n                temp = stack.pop()[1]\\n                nse_idx[temp] = i\\n            pse_idx[i] = stack[-1][1] if(stack) else -1\\n            stack.append((num,i))\\n        # print(pse_idx, nse_idx)\\n        \\n        minimums = 0\\n        maximums = 0\\n        for i in range(n):\\n            minimums += (nums[i] * (i - pse_idx[i]) * (nse_idx[i] - i))  # multiply to get the count of all subarrays\\n            maximums += (nums[i] * (i - ple_idx[i]) * (nle_idx[i] - i))\\n        # print(maximums ,minimums)\\n        return maximums - minimums\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131802,
                "title": "python-monotone-stack-easy-to-understand",
                "content": "Idea:\\n(1) for each item, check the number of times it serves as the max of subarrays, as well as \\nthe min of subarrays; \\n(2) then iterate all items by adding the max and substracting the min would give the final result;\\n(3) to compute the number of subarrays that an item servers as the max/min, one needs to find the left/right immediate larger or smaller indexes;\\n(4) monotone stack is all you need!\\n\\n```\\n def subArrayRanges(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        leftlarge=[-1]*n\\n        rightlarge=[n]*n\\n        leftsmall=[-1]*n\\n        rightsmall=[n]*n\\n        st=[]\\n        ##monotone decreasing\\n        for i,c in enumerate(nums):\\n            while st and nums[st[-1]]<c:\\n                rightlarge[st[-1]]=i\\n                st.pop()\\n            if st:\\n                leftlarge[i]=st[-1]\\n            st.append(i)\\n        st=[]\\n        ## monotone increasing\\n        for i,c in enumerate(nums):\\n            while st and nums[st[-1]]>c:\\n                rightsmall[st[-1]]=i\\n                st.pop()\\n            if st:\\n                leftsmall[i]=st[-1]\\n            st.append(i)\\n        res=0\\n        for i,c in enumerate(nums):\\n            res-=c*(i-leftsmall[i])*(rightsmall[i]-i)\\n            res+=c*(i-leftlarge[i])*(rightlarge[i]-i)\\n        return res\\n",
                "solutionTags": [],
                "code": "Idea:\\n(1) for each item, check the number of times it serves as the max of subarrays, as well as \\nthe min of subarrays; \\n(2) then iterate all items by adding the max and substracting the min would give the final result;\\n(3) to compute the number of subarrays that an item servers as the max/min, one needs to find the left/right immediate larger or smaller indexes;\\n(4) monotone stack is all you need!\\n\\n```\\n def subArrayRanges(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        leftlarge=[-1]*n\\n        rightlarge=[n]*n\\n        leftsmall=[-1]*n\\n        rightsmall=[n]*n\\n        st=[]\\n        ##monotone decreasing\\n        for i,c in enumerate(nums):\\n            while st and nums[st[-1]]<c:\\n                rightlarge[st[-1]]=i\\n                st.pop()\\n            if st:\\n                leftlarge[i]=st[-1]\\n            st.append(i)\\n        st=[]\\n        ## monotone increasing\\n        for i,c in enumerate(nums):\\n            while st and nums[st[-1]]>c:\\n                rightsmall[st[-1]]=i\\n                st.pop()\\n            if st:\\n                leftsmall[i]=st[-1]\\n            st.append(i)\\n        res=0\\n        for i,c in enumerate(nums):\\n            res-=c*(i-leftsmall[i])*(rightsmall[i]-i)\\n            res+=c*(i-leftlarge[i])*(rightlarge[i]-i)\\n        return res\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2059943,
                "title": "c-easy-solution-short-solution-beginner-friendly",
                "content": "class Solution {\\npublic:\\n\\n    long long subArrayRanges(vector<int>& nums) {\\n        long long int ans=0;\\n        int n=nums.size();\\n        for(int i=0; i<n; i++){\\n            int mx=nums[i];\\n            int mn=nums[i];\\n            for(int j=i; j<n; j++){\\n                mx=max(mx,nums[j]);\\n                mn=min(mn,nums[j]);\\n                ans+=mx-mn;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    long long subArrayRanges(vector<int>& nums) {\\n        long long int ans=0;\\n        int n=nums.size();\\n        for(int i=0; i<n; i++){\\n            int mx=nums[i];\\n            int mn=nums[i];\\n            for(int j=i; j<n; j++){\\n                mx=max(mx,nums[j]);\\n                mn=min(mn,nums[j]);\\n                ans+=mx-mn;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2006388,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution {\\n    public long SubArrayRanges(int[] nums) \\n    {\\n        int n = nums.Length;\\n        long sum = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int max = int.MinValue;\\n            int min = int.MaxValue;\\n            \\n            for(int j=i; j<n; j++)\\n            {\\n                max = Math.Max(max,nums[j]);\\n                min = Math.Min(min,nums[j]);\\n                sum+=max-min;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long SubArrayRanges(int[] nums) \\n    {\\n        int n = nums.Length;\\n        long sum = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int max = int.MinValue;\\n            int min = int.MaxValue;\\n            \\n            for(int j=i; j<n; j++)\\n            {\\n                max = Math.Max(max,nums[j]);\\n                min = Math.Min(min,nums[j]);\\n                sum+=max-min;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945088,
                "title": "easy-c-stack-o-n-time-o-n-space-faster-than-90",
                "content": "```\\nvoid findsmaller(vector<int>& nums,int n,vector<long long>& nse,vector<long long>& psoe,vector<long long>& nle,vector<long long>& ploe){\\n        stack<int>s;\\n        s.push(0);\\n        for(int j=1;j<n;j++){\\n            while(!s.empty() && nums[j]<nums[s.top()]){\\n                nse[s.top()] = j;\\n                s.pop();\\n            }\\n            s.push(j);\\n        }\\n        while(!s.empty()){\\n            nse[s.top()] = n;\\n            s.pop();\\n        }\\n        s.push(n-1);\\n        for(int j=n-2;j>=0;j--){\\n            while(!s.empty() && nums[j]<=nums[s.top()]){\\n                psoe[s.top()] = j;\\n                s.pop();\\n            }\\n            s.push(j);\\n        }\\n        while(!s.empty()){\\n            psoe[s.top()] = -1;\\n            s.pop();\\n        }\\n        s.push(0);\\n        for(int j=1;j<n;j++){\\n            while(!s.empty() && nums[j]>nums[s.top()]){\\n                nle[s.top()] = j;\\n                s.pop();\\n            }\\n            s.push(j);\\n        }\\n        while(!s.empty()){\\n            nle[s.top()] = n;\\n            s.pop();\\n        }\\n        s.push(n-1);\\n        for(int j=n-2;j>=0;j--){\\n            while(!s.empty() && nums[j]>=nums[s.top()]){\\n                ploe[s.top()] = j;\\n                s.pop();\\n            }\\n            s.push(j);\\n        }\\n        while(!s.empty()){\\n            ploe[s.top()] = -1;\\n            s.pop();\\n        }\\n    }\\n    \\n    long long subArrayRanges(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> nse(n,0),psoe(n,0),nle(n,0),ploe(n,0);\\n        findsmaller(nums,n,nse,psoe,nle,ploe);\\n        long long sum = 0;\\n        long long m = 1e9 + 7;\\n        for(int i=0;i<n;i++){\\n            long long contribution = ((i-ploe[i]) * (nle[i]-i) * (nums[i])) - ((i-psoe[i]) * (nse[i]-i) * (nums[i]));\\n            sum = (sum + contribution);\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nvoid findsmaller(vector<int>& nums,int n,vector<long long>& nse,vector<long long>& psoe,vector<long long>& nle,vector<long long>& ploe){\\n        stack<int>s;\\n        s.push(0);\\n        for(int j=1;j<n;j++){\\n            while(!s.empty() && nums[j]<nums[s.top()]){\\n                nse[s.top()] = j;\\n                s.pop();\\n            }\\n            s.push(j);\\n        }\\n        while(!s.empty()){\\n            nse[s.top()] = n;\\n            s.pop();\\n        }\\n        s.push(n-1);\\n        for(int j=n-2;j>=0;j--){\\n            while(!s.empty() && nums[j]<=nums[s.top()]){\\n                psoe[s.top()] = j;\\n                s.pop();\\n            }\\n            s.push(j);\\n        }\\n        while(!s.empty()){\\n            psoe[s.top()] = -1;\\n            s.pop();\\n        }\\n        s.push(0);\\n        for(int j=1;j<n;j++){\\n            while(!s.empty() && nums[j]>nums[s.top()]){\\n                nle[s.top()] = j;\\n                s.pop();\\n            }\\n            s.push(j);\\n        }\\n        while(!s.empty()){\\n            nle[s.top()] = n;\\n            s.pop();\\n        }\\n        s.push(n-1);\\n        for(int j=n-2;j>=0;j--){\\n            while(!s.empty() && nums[j]>=nums[s.top()]){\\n                ploe[s.top()] = j;\\n                s.pop();\\n            }\\n            s.push(j);\\n        }\\n        while(!s.empty()){\\n            ploe[s.top()] = -1;\\n            s.pop();\\n        }\\n    }\\n    \\n    long long subArrayRanges(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> nse(n,0),psoe(n,0),nle(n,0),ploe(n,0);\\n        findsmaller(nums,n,nse,psoe,nle,ploe);\\n        long long sum = 0;\\n        long long m = 1e9 + 7;\\n        for(int i=0;i<n;i++){\\n            long long contribution = ((i-ploe[i]) * (nle[i]-i) * (nums[i])) - ((i-psoe[i]) * (nse[i]-i) * (nums[i]));\\n            sum = (sum + contribution);\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1919273,
                "title": "c-o-n-stack-solution",
                "content": "Runtime: 12 ms, faster than 98.05% of C++ online submissions for Sum of Subarray Ranges.\\nMemory Usage: 11.4 MB, less than 26.67% of C++ online submissions for Sum of Subarray Ranges.\\n\\nProblem is similar to [907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/) and the [Solution](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/1884773/C++-O(N)-Stack-Solution).\\n\\n\\n```\\nSum of subarray ranges = Sum of subarray max - Sum of subarray min\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // returns sum of subarray max or min values depending on findMin\\n    long long sumSubarrayVals(vector<int>& arr, bool findMin) {\\n        \\n        int n = arr.size();        \\n        \\n        vector<int>rightIndexes(n);        \\n        stack<int>leftStak;\\n        stack<int>rightStak;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            // pop greater values from stack in case of finding next min value index\\n            while(findMin && !rightStak.empty() && arr[rightStak.top()]>=arr[i])rightStak.pop();\\n\\n            // pop smaller values from stack in case of finding next max value index\\n            while(!findMin && !rightStak.empty() && arr[rightStak.top()]<=arr[i])rightStak.pop();\\n            \\n            rightIndexes[i] = rightStak.empty() ? n : rightStak.top();\\n            \\n            rightStak.push(i);\\n        }\\n\\n        long long count = 0;\\n        int MOD = 1000000007;\\n        int leftIndex;\\n        long leftSize;\\n        long rightSize;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            // pop greater values from stack in case of finding previous min value index\\n            while(findMin && !leftStak.empty() && arr[leftStak.top()]>arr[i])leftStak.pop();\\n            \\n            // pop smaller values from stack in case of finding previous max value index\\n            while(!findMin && !leftStak.empty() && arr[leftStak.top()]<arr[i])leftStak.pop();                        \\n\\t\\t\\t\\n            leftIndex = leftStak.empty() ? -1 : leftStak.top();\\n    \\n            leftStak.push(i);\\n            \\n            // left subarray and right subarray size where current value is min or max\\n            leftSize = i - leftIndex;\\n            rightSize = rightIndexes[i] - i;\\n            \\n            // total subarray with current value as min or max => (leftSize) * (rightSize)\\n            // total sum => total subarray  * current value\\n            count += ((long long)arr[i] * leftSize * rightSize);\\n        }\\n        \\n        return count;\\n    }\\n        \\n    long long subArrayRanges(vector<int>& nums) {\\n                \\n        // get sum of subarray min values and max values \\n        long long sumSubarrayMax = sumSubarrayVals(nums,false);\\n        long long sumSubarrayMin = sumSubarrayVals(nums,true);\\n        \\n        // sum of subarray ranges = sum of subarray max - sum of subarray min\\n        return sumSubarrayMax - sumSubarrayMin;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nSum of subarray ranges = Sum of subarray max - Sum of subarray min\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    // returns sum of subarray max or min values depending on findMin\\n    long long sumSubarrayVals(vector<int>& arr, bool findMin) {\\n        \\n        int n = arr.size();        \\n        \\n        vector<int>rightIndexes(n);        \\n        stack<int>leftStak;\\n        stack<int>rightStak;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            // pop greater values from stack in case of finding next min value index\\n            while(findMin && !rightStak.empty() && arr[rightStak.top()]>=arr[i])rightStak.pop();\\n\\n            // pop smaller values from stack in case of finding next max value index\\n            while(!findMin && !rightStak.empty() && arr[rightStak.top()]<=arr[i])rightStak.pop();\\n            \\n            rightIndexes[i] = rightStak.empty() ? n : rightStak.top();\\n            \\n            rightStak.push(i);\\n        }\\n\\n        long long count = 0;\\n        int MOD = 1000000007;\\n        int leftIndex;\\n        long leftSize;\\n        long rightSize;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            // pop greater values from stack in case of finding previous min value index\\n            while(findMin && !leftStak.empty() && arr[leftStak.top()]>arr[i])leftStak.pop();\\n            \\n            // pop smaller values from stack in case of finding previous max value index\\n            while(!findMin && !leftStak.empty() && arr[leftStak.top()]<arr[i])leftStak.pop();                        \\n\\t\\t\\t\\n            leftIndex = leftStak.empty() ? -1 : leftStak.top();\\n    \\n            leftStak.push(i);\\n            \\n            // left subarray and right subarray size where current value is min or max\\n            leftSize = i - leftIndex;\\n            rightSize = rightIndexes[i] - i;\\n            \\n            // total subarray with current value as min or max => (leftSize) * (rightSize)\\n            // total sum => total subarray  * current value\\n            count += ((long long)arr[i] * leftSize * rightSize);\\n        }\\n        \\n        return count;\\n    }\\n        \\n    long long subArrayRanges(vector<int>& nums) {\\n                \\n        // get sum of subarray min values and max values \\n        long long sumSubarrayMax = sumSubarrayVals(nums,false);\\n        long long sumSubarrayMin = sumSubarrayVals(nums,true);\\n        \\n        // sum of subarray ranges = sum of subarray max - sum of subarray min\\n        return sumSubarrayMax - sumSubarrayMin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844039,
                "title": "python-3-monotonic-stack-solution-o-n-time-o-n-aux-space",
                "content": "Reference: https://cybergeeksquad.co/2022/02/shipment-imbalance-amazon-oa.html#SOLUTION\\n```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        \\n        # Reference: https://cybergeeksquad.co/2022/02/shipment-imbalance-amazon-oa.html#SOLUTION\\n        # count number of times each number is used as a maximum and minimum\\n        \\n        gl = [None] * len(nums) # greater left\\n        gr = [None] * len(nums) # greater right\\n        ll = [None] * len(nums) # lesser left\\n        lr = [None] * len(nums) # lesser right\\n        \\n        s = [(0, math.inf)]\\n        for i in range(len(nums)):\\n            while len(s) != 0 and s[-1][-1] < nums[i]:\\n                s.pop()\\n            s.append((i+1, nums[i]))\\n            gl[i] = s[-1][0] - s[-2][0]\\n            \\n        s = [(len(nums), math.inf)]\\n        for i in range(len(nums)-1, -1, -1):\\n            while len(s) != 0 and s[-1][-1] <= nums[i]:\\n                s.pop()\\n            s.append((i, nums[i]))\\n            gr[i] = s[-2][0] - s[-1][0]\\n\\n        s = [(0, -math.inf)]\\n        for i in range(len(nums)):\\n            while len(s) != 0 and s[-1][-1] > nums[i]:\\n                s.pop()\\n            s.append((i+1, nums[i]))\\n            ll[i] = s[-1][0] - s[-2][0]\\n            \\n        s = [(len(nums), -math.inf)]\\n        for i in range(len(nums)-1, -1, -1):\\n            while len(s) != 0 and s[-1][-1] >= nums[i]:\\n                s.pop()\\n            s.append((i, nums[i]))\\n            lr[i] = s[-2][0] - s[-1][0]\\n            \\n        g = [gl[i]*gr[i] for i in range(len(nums))] # number of times nums[i] is maximum\\n        l = [ll[i]*lr[i] for i in range(len(nums))] # number of times nums[i] is minimum\\n        \\n        return sum([(g[i]-l[i])*nums[i] for i in range(len(nums))])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        \\n        # Reference: https://cybergeeksquad.co/2022/02/shipment-imbalance-amazon-oa.html#SOLUTION\\n        # count number of times each number is used as a maximum and minimum\\n        \\n        gl = [None] * len(nums) # greater left\\n        gr = [None] * len(nums) # greater right\\n        ll = [None] * len(nums) # lesser left\\n        lr = [None] * len(nums) # lesser right\\n        \\n        s = [(0, math.inf)]\\n        for i in range(len(nums)):\\n            while len(s) != 0 and s[-1][-1] < nums[i]:\\n                s.pop()\\n            s.append((i+1, nums[i]))\\n            gl[i] = s[-1][0] - s[-2][0]\\n            \\n        s = [(len(nums), math.inf)]\\n        for i in range(len(nums)-1, -1, -1):\\n            while len(s) != 0 and s[-1][-1] <= nums[i]:\\n                s.pop()\\n            s.append((i, nums[i]))\\n            gr[i] = s[-2][0] - s[-1][0]\\n\\n        s = [(0, -math.inf)]\\n        for i in range(len(nums)):\\n            while len(s) != 0 and s[-1][-1] > nums[i]:\\n                s.pop()\\n            s.append((i+1, nums[i]))\\n            ll[i] = s[-1][0] - s[-2][0]\\n            \\n        s = [(len(nums), -math.inf)]\\n        for i in range(len(nums)-1, -1, -1):\\n            while len(s) != 0 and s[-1][-1] >= nums[i]:\\n                s.pop()\\n            s.append((i, nums[i]))\\n            lr[i] = s[-2][0] - s[-1][0]\\n            \\n        g = [gl[i]*gr[i] for i in range(len(nums))] # number of times nums[i] is maximum\\n        l = [ll[i]*lr[i] for i in range(len(nums))] # number of times nums[i] is minimum\\n        \\n        return sum([(g[i]-l[i])*nums[i] for i in range(len(nums))])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639147,
                "title": "c-o-n-time-solution-most-concise",
                "content": "Prerequisite: Solve https://leetcode.com/problems/sum-of-subarray-minimums/ before proceeding. \\n```\\n#define ll long long \\nclass Solution {\\npublic:\\n    vector<int> NSE(vector<int>& nums){\\n        int n = nums.size();\\n        vector<int> nse(n,n);\\n            \\n        deque<int> dq;\\n        for(int i=0;i<n;i++){\\n            while(dq.size() && nums[dq.back()] > nums[i]){\\n                nse[dq.back()] = i;\\n                dq.pop_back();\\n            }\\n            dq.push_back(i);\\n        }\\n        return nse;\\n    }\\n    vector<int> PSE(vector<int>& nums){\\n        int n = nums.size();\\n        vector<int> pse(n,-1);\\n            \\n        deque<int> dq;\\n        for(int i=n-1;i>=0;i--){\\n            while(dq.size() && nums[dq.back()] >= nums[i]){\\n                pse[dq.back()] = i;\\n                dq.pop_back();\\n            }\\n            dq.push_back(i);\\n        }\\n        return pse;\\n    }\\n    vector<int> NGE(vector<int>& nums){\\n        int n = nums.size();\\n        vector<int> nge(n,n);\\n            \\n        deque<int> dq;\\n        for(int i=0;i<n;i++){\\n            while(dq.size() && nums[dq.back()] < nums[i]){\\n                nge[dq.back()] = i;\\n                dq.pop_back();\\n            }\\n            dq.push_back(i);\\n        }\\n        return nge;\\n    }\\n    vector<int> PGE(vector<int>& nums){\\n        int n = nums.size();\\n        vector<int> pge(n,-1);\\n            \\n        deque<int> dq;\\n        for(int i=n-1;i>=0;i--){\\n            while(dq.size() && nums[dq.back()] <= nums[i]){\\n                pge[dq.back()] = i;\\n                dq.pop_back();\\n            }\\n            dq.push_back(i);\\n        }\\n        return pge;        \\n    }\\n    long long subArrayRanges(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        //1. find sum of subarray minimums\\n        vector<int> nse = NSE(nums);\\n        vector<int> pse = PSE(nums);\\n        ll miniSum = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            int totalStartPos = i - pse[i];\\n            int totalEndPos = nse[i] - i;\\n            ll totalSubarrays = totalStartPos * totalEndPos;\\n            miniSum += totalSubarrays * nums[i];\\n        }\\n        \\n        \\n        \\n        //2. find sum of subarray maximums\\n        vector<int> nge = NGE(nums);\\n        vector<int> pge = PGE(nums);\\n        ll maxiSum = 0;\\n        for(int i=0;i<n;i++){\\n            int totalStartPos = i - pge[i];\\n            int totalEndPos = nge[i] - i;\\n            ll totalSubarrays = totalStartPos * totalEndPos;\\n            maxiSum += totalSubarrays * nums[i];\\n        }\\n        \\n        return maxiSum - miniSum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    vector<int> NSE(vector<int>& nums){\\n        int n = nums.size();\\n        vector<int> nse(n,n);\\n            \\n        deque<int> dq;\\n        for(int i=0;i<n;i++){\\n            while(dq.size() && nums[dq.back()] > nums[i]){\\n                nse[dq.back()] = i;\\n                dq.pop_back();\\n            }\\n            dq.push_back(i);\\n        }\\n        return nse;\\n    }\\n    vector<int> PSE(vector<int>& nums){\\n        int n = nums.size();\\n        vector<int> pse(n,-1);\\n            \\n        deque<int> dq;\\n        for(int i=n-1;i>=0;i--){\\n            while(dq.size() && nums[dq.back()] >= nums[i]){\\n                pse[dq.back()] = i;\\n                dq.pop_back();\\n            }\\n            dq.push_back(i);\\n        }\\n        return pse;\\n    }\\n    vector<int> NGE(vector<int>& nums){\\n        int n = nums.size();\\n        vector<int> nge(n,n);\\n            \\n        deque<int> dq;\\n        for(int i=0;i<n;i++){\\n            while(dq.size() && nums[dq.back()] < nums[i]){\\n                nge[dq.back()] = i;\\n                dq.pop_back();\\n            }\\n            dq.push_back(i);\\n        }\\n        return nge;\\n    }\\n    vector<int> PGE(vector<int>& nums){\\n        int n = nums.size();\\n        vector<int> pge(n,-1);\\n            \\n        deque<int> dq;\\n        for(int i=n-1;i>=0;i--){\\n            while(dq.size() && nums[dq.back()] <= nums[i]){\\n                pge[dq.back()] = i;\\n                dq.pop_back();\\n            }\\n            dq.push_back(i);\\n        }\\n        return pge;        \\n    }\\n    long long subArrayRanges(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        //1. find sum of subarray minimums\\n        vector<int> nse = NSE(nums);\\n        vector<int> pse = PSE(nums);\\n        ll miniSum = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            int totalStartPos = i - pse[i];\\n            int totalEndPos = nse[i] - i;\\n            ll totalSubarrays = totalStartPos * totalEndPos;\\n            miniSum += totalSubarrays * nums[i];\\n        }\\n        \\n        \\n        \\n        //2. find sum of subarray maximums\\n        vector<int> nge = NGE(nums);\\n        vector<int> pge = PGE(nums);\\n        ll maxiSum = 0;\\n        for(int i=0;i<n;i++){\\n            int totalStartPos = i - pge[i];\\n            int totalEndPos = nge[i] - i;\\n            ll totalSubarrays = totalStartPos * totalEndPos;\\n            maxiSum += totalSubarrays * nums[i];\\n        }\\n        \\n        return maxiSum - miniSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636577,
                "title": "c-o-n-solution",
                "content": "**Intuition**\\n![image](https://assets.leetcode.com/users/images/af37d278-5ce9-4be5-901d-0080e0fd225b_1650926160.9133592.png)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public long SubArrayRanges(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return 0;\\n        \\n        // Sum of subarray ranges = Sum of subarry max - Sum of subarry min\\n        \\n        long res = 0;\\n        Stack<int> stack = new Stack<int>();\\n        for(int i = 0; i <= nums.Length; i++)\\n        {\\n            while(stack.Count > 0 && nums[stack.Peek()] > (i == nums.Length? Int32.MinValue : nums[i]))\\n            {\\n                int midIdx = stack.Pop();\\n                int leftBoundary = stack.Count == 0? -1 : stack.Peek();\\n                int rightBoundary = i;\\n                \\n                res -= (long)nums[midIdx] * (midIdx - leftBoundary) * (rightBoundary - midIdx);\\n            }\\n            \\n            stack.Push(i);\\n        }\\n        \\n        stack.Clear();\\n        for(int i = 0; i <= nums.Length; i++)\\n        {\\n            while(stack.Count > 0 && nums[stack.Peek()] < (i == nums.Length? Int32.MaxValue : nums[i]))\\n            {\\n                int midIdx = stack.Pop();\\n                int leftBoundary = stack.Count == 0? -1 : stack.Peek();\\n                int rightBoundary = i;\\n                \\n                res += (long)nums[midIdx] * (midIdx - leftBoundary) * (rightBoundary - midIdx);\\n            }\\n            \\n            stack.Push(i);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public long SubArrayRanges(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return 0;\\n        \\n        // Sum of subarray ranges = Sum of subarry max - Sum of subarry min\\n        \\n        long res = 0;\\n        Stack<int> stack = new Stack<int>();\\n        for(int i = 0; i <= nums.Length; i++)\\n        {\\n            while(stack.Count > 0 && nums[stack.Peek()] > (i == nums.Length? Int32.MinValue : nums[i]))\\n            {\\n                int midIdx = stack.Pop();\\n                int leftBoundary = stack.Count == 0? -1 : stack.Peek();\\n                int rightBoundary = i;\\n                \\n                res -= (long)nums[midIdx] * (midIdx - leftBoundary) * (rightBoundary - midIdx);\\n            }\\n            \\n            stack.Push(i);\\n        }\\n        \\n        stack.Clear();\\n        for(int i = 0; i <= nums.Length; i++)\\n        {\\n            while(stack.Count > 0 && nums[stack.Peek()] < (i == nums.Length? Int32.MaxValue : nums[i]))\\n            {\\n                int midIdx = stack.Pop();\\n                int leftBoundary = stack.Count == 0? -1 : stack.Peek();\\n                int rightBoundary = i;\\n                \\n                res += (long)nums[midIdx] * (midIdx - leftBoundary) * (rightBoundary - midIdx);\\n            }\\n            \\n            stack.Push(i);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627260,
                "title": "a-few-solutions",
                "content": "For each subarray starting at each `i`<sup>th</sup> index of the input array `A`, track the minimum and maximum as `lo` and `hi` correspondingly to return the accumulated total `t` of `hi - lo` differences.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun subArrayRanges(A: IntArray): Long {\\n        var t = 0.toLong()\\n        var N = A.size\\n        for (i in 0 until N) {\\n            var (lo, hi) = listOf(A[i], A[i])\\n            for (j in i + 1 until N) {\\n                lo = Math.min(lo, A[j])\\n                hi = Math.max(hi, A[j])\\n                t += hi - lo\\n            }\\n        }\\n        return t\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet subArrayRanges = (A, t = 0) => {\\n    let N = A.length;\\n    for (let i = 0; i < N; ++i) {\\n        let [lo, hi] = [A[i], A[i]];\\n        for (let j = i + 1; j < N; ++j) {\\n            lo = Math.min(lo, A[j]);\\n            hi = Math.max(hi, A[j]);\\n            t += hi - lo;\\n        }\\n    }\\n    return t;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def subArrayRanges(self, A: List[int], t = 0) -> int:\\n        N = len(A)\\n        for i in range(N):\\n            lo, hi = A[i], A[i]\\n            for j in range(i + 1, N):\\n                lo = min(lo, A[j])\\n                hi = max(hi, A[j])\\n                t += hi - lo\\n        return t\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    LL subArrayRanges(VI& A, LL t = 0) {\\n        int N = A.size();\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto [lo, hi] = make_tuple(A[i], A[i]);\\n            for (auto j{ i + 1 }; j < N; ++j) {\\n                lo = min(lo, A[j]);\\n                hi = max(hi, A[j]);\\n                t += hi - lo;\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun subArrayRanges(A: IntArray): Long {\\n        var t = 0.toLong()\\n        var N = A.size\\n        for (i in 0 until N) {\\n            var (lo, hi) = listOf(A[i], A[i])\\n            for (j in i + 1 until N) {\\n                lo = Math.min(lo, A[j])\\n                hi = Math.max(hi, A[j])\\n                t += hi - lo\\n            }\\n        }\\n        return t\\n    }\\n}\\n```\n```\\nlet subArrayRanges = (A, t = 0) => {\\n    let N = A.length;\\n    for (let i = 0; i < N; ++i) {\\n        let [lo, hi] = [A[i], A[i]];\\n        for (let j = i + 1; j < N; ++j) {\\n            lo = Math.min(lo, A[j]);\\n            hi = Math.max(hi, A[j]);\\n            t += hi - lo;\\n        }\\n    }\\n    return t;\\n};\\n```\n```\\nclass Solution:\\n    def subArrayRanges(self, A: List[int], t = 0) -> int:\\n        N = len(A)\\n        for i in range(N):\\n            lo, hi = A[i], A[i]\\n            for j in range(i + 1, N):\\n                lo = min(lo, A[j])\\n                hi = max(hi, A[j])\\n                t += hi - lo\\n        return t\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    LL subArrayRanges(VI& A, LL t = 0) {\\n        int N = A.size();\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto [lo, hi] = make_tuple(A[i], A[i]);\\n            for (auto j{ i + 1 }; j < N; ++j) {\\n                lo = min(lo, A[j]);\\n                hi = max(hi, A[j]);\\n                t += hi - lo;\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625329,
                "title": "javascript-100-fast-clean-and-concise-code",
                "content": "```\\nvar subArrayRanges = function(nums) {\\n    if(nums.length==1) return 0;\\n        var n = nums.length;\\n        var ans = 0;\\n        for(var i=0; i<n-1; i++){\\n            var mx = Math.max(nums[i],nums[i+1]);\\n            var mn = Math.min(nums[i],nums[i+1]);\\n            \\n            for(var j=i+1; j<n; j++){\\n                mx = Math.max(mx,nums[j]);\\n                mn = Math.min(mn,nums[j]);\\n                ans+=(mx-mn);\\n            }\\n        }\\n        return ans;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar subArrayRanges = function(nums) {\\n    if(nums.length==1) return 0;\\n        var n = nums.length;\\n        var ans = 0;\\n        for(var i=0; i<n-1; i++){\\n            var mx = Math.max(nums[i],nums[i+1]);\\n            var mn = Math.min(nums[i],nums[i+1]);\\n            \\n            for(var j=i+1; j<n; j++){\\n                mx = Math.max(mx,nums[j]);\\n                mn = Math.min(mn,nums[j]);\\n                ans+=(mx-mn);\\n            }\\n        }\\n        return ans;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1624671,
                "title": "simple-python-solution-o-n2-approach-using-2-loops",
                "content": "\\'\\'\\'\\n\\t******Author : cyberkid05******\\n\\'\\'\\'\\n\\n```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        res = 0\\n        for i in range(len(nums)):\\n            small,big = nums[i],nums[i]\\n            for j in range(i + 1, len(nums)):\\n                if nums[j] < small:\\n                    small = nums[j]\\n                if nums[j] > big:\\n                    big = nums[j]\\n                res += big - small\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        res = 0\\n        for i in range(len(nums)):\\n            small,big = nums[i],nums[i]\\n            for j in range(i + 1, len(nums)):\\n                if nums[j] < small:\\n                    small = nums[j]\\n                if nums[j] > big:\\n                    big = nums[j]\\n                res += big - small\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624578,
                "title": "python-c-c-java-from-o-n-2-to-o-n-beginner-friendly-easy-to-understand",
                "content": "**If you hava any question, feel free to ask. If you like the solution or the explaination, Please UPVOTE!**\\n\\n**Python**\\n```\\nclass Solution(object):\\n    def subArrayRanges(self, nums):\\n        ans = 0\\n        for i in range(len(nums)):\\n            mn = mx = nums[i]\\n            for j in range(i + 1, len(nums)):\\n                mn, mx = min(mn, nums[j]), max(mx, nums[j])\\n                ans += mx - mn\\n        return ans\\n```\\n**O(N) via monotonic stack**\\n```\\nclass Solution(object):\\n    def subArrayRanges(self, nums):\\n        greater_left, less_left, greater_left_stack, less_left_stack = [1] * len(nums), [1] * len(nums), [], []\\n        greater_right, less_right, greater_right_stack, less_right_stack = [1] * len(nums), [1] * len(nums), [], []\\n        \\n        for i in range(len(nums)):\\n            while len(greater_left_stack) > 0 and greater_left_stack[-1][0] >= nums[i]:\\n                greater_left[i] += greater_left_stack.pop()[1]\\n            greater_left_stack.append((nums[i], greater_left[i]))\\n            while len(less_left_stack) > 0 and less_left_stack[-1][0] < nums[i]:\\n                less_left[i] += less_left_stack.pop()[1]\\n            less_left_stack.append((nums[i], less_left[i]))\\n\\n        for i in range(len(nums) - 1, -1, -1):\\n            while len(greater_right_stack) > 0 and greater_right_stack[-1][0] > nums[i]:\\n                greater_right[i] += greater_right_stack.pop()[1]\\n            greater_right_stack.append((nums[i], greater_right[i]))\\n            while len(less_right_stack) > 0 and less_right_stack[-1][0] <= nums[i]:\\n                less_right[i] += less_right_stack.pop()[1]\\n            less_right_stack.append((nums[i], less_right[i]))\\n\\n        return sum([(less_left[i] * less_right[i] - greater_left[i] * greater_right[i]) * nums[i] for i in range(len(nums))])\\n```\\n**C**\\n```\\nlong long subArrayRanges(int* nums, int numsSize){\\n    long long ans = 0;\\n    for (int i = 0; i < numsSize; i ++) {\\n        int mn = nums[i], mx = nums[i];\\n        for (int j = i + 1; j < numsSize; j ++) {\\n            mn = (nums[j] < mn) ? nums[j] : mn;\\n            mx = (nums[j] > mx) ? nums[j] : mx;\\n            ans += mx - mn;\\n        }\\n    }\\n    return ans;\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        long long ans = 0;\\n        for (int i = 0; i < size(nums); i ++) {\\n            int mn = nums[i], mx = nums[i];\\n            for (int j = i + 1; j < size(nums); j ++) {\\n                mn = (nums[j] < mn) ? nums[j] : mn;\\n                mx = (nums[j] > mx) ? nums[j] : mx;\\n                ans += mx - mn;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        long ans = 0;\\n        for (int i = 0; i < nums.length; i ++) {\\n            int mn = nums[i], mx = nums[i];\\n            for (int j = i + 1; j < nums.length; j ++) {\\n                mn = (nums[j] < mn) ? nums[j] : mn;\\n                mx = (nums[j] > mx) ? nums[j] : mx;\\n                ans += mx - mn;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**If you hava any question, feel free to ask. If you like the solution or the explaination, Please UPVOTE!**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def subArrayRanges(self, nums):\\n        ans = 0\\n        for i in range(len(nums)):\\n            mn = mx = nums[i]\\n            for j in range(i + 1, len(nums)):\\n                mn, mx = min(mn, nums[j]), max(mx, nums[j])\\n                ans += mx - mn\\n        return ans\\n```\n```\\nclass Solution(object):\\n    def subArrayRanges(self, nums):\\n        greater_left, less_left, greater_left_stack, less_left_stack = [1] * len(nums), [1] * len(nums), [], []\\n        greater_right, less_right, greater_right_stack, less_right_stack = [1] * len(nums), [1] * len(nums), [], []\\n        \\n        for i in range(len(nums)):\\n            while len(greater_left_stack) > 0 and greater_left_stack[-1][0] >= nums[i]:\\n                greater_left[i] += greater_left_stack.pop()[1]\\n            greater_left_stack.append((nums[i], greater_left[i]))\\n            while len(less_left_stack) > 0 and less_left_stack[-1][0] < nums[i]:\\n                less_left[i] += less_left_stack.pop()[1]\\n            less_left_stack.append((nums[i], less_left[i]))\\n\\n        for i in range(len(nums) - 1, -1, -1):\\n            while len(greater_right_stack) > 0 and greater_right_stack[-1][0] > nums[i]:\\n                greater_right[i] += greater_right_stack.pop()[1]\\n            greater_right_stack.append((nums[i], greater_right[i]))\\n            while len(less_right_stack) > 0 and less_right_stack[-1][0] <= nums[i]:\\n                less_right[i] += less_right_stack.pop()[1]\\n            less_right_stack.append((nums[i], less_right[i]))\\n\\n        return sum([(less_left[i] * less_right[i] - greater_left[i] * greater_right[i]) * nums[i] for i in range(len(nums))])\\n```\n```\\nlong long subArrayRanges(int* nums, int numsSize){\\n    long long ans = 0;\\n    for (int i = 0; i < numsSize; i ++) {\\n        int mn = nums[i], mx = nums[i];\\n        for (int j = i + 1; j < numsSize; j ++) {\\n            mn = (nums[j] < mn) ? nums[j] : mn;\\n            mx = (nums[j] > mx) ? nums[j] : mx;\\n            ans += mx - mn;\\n        }\\n    }\\n    return ans;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        long long ans = 0;\\n        for (int i = 0; i < size(nums); i ++) {\\n            int mn = nums[i], mx = nums[i];\\n            for (int j = i + 1; j < size(nums); j ++) {\\n                mn = (nums[j] < mn) ? nums[j] : mn;\\n                mx = (nums[j] > mx) ? nums[j] : mx;\\n                ans += mx - mn;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        long ans = 0;\\n        for (int i = 0; i < nums.length; i ++) {\\n            int mn = nums[i], mx = nums[i];\\n            for (int j = i + 1; j < nums.length; j ++) {\\n                mn = (nums[j] < mn) ? nums[j] : mn;\\n                mx = (nums[j] > mx) ? nums[j] : mx;\\n                ans += mx - mn;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624392,
                "title": "c-simple-solution",
                "content": "```\\n#define lln long long int\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        \\n      lln ans=0;\\n      \\n      int n=nums.size();\\n    \\n      for(int i=0;i<n;i++){\\n        int mn=nums[i],mx=nums[i];\\n        for(int j=i+1;j<n;j++){\\n          mn=min(mn,nums[j]);\\n          mx=max(mx,nums[j]);\\n          \\n          lln diff=mx-mn;\\n          ans= ans+ diff;\\n        }\\n      }\\n      \\n      return ans;\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define lln long long int\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        \\n      lln ans=0;\\n      \\n      int n=nums.size();\\n    \\n      for(int i=0;i<n;i++){\\n        int mn=nums[i],mx=nums[i];\\n        for(int j=i+1;j<n;j++){\\n          mn=min(mn,nums[j]);\\n          mx=max(mx,nums[j]);\\n          \\n          lln diff=mx-mn;\\n          ans= ans+ diff;\\n        }\\n      }\\n      \\n      return ans;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624287,
                "title": "java-dfs-solution",
                "content": "```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        return dfs(nums, 0);\\n    }\\n    \\n    private long dfs (int[] nums, int start) {\\n        if (start == nums.length) {\\n            return 0;\\n        }\\n        long result = 0;\\n        long min = nums[start];\\n        long max = nums[start];\\n        for (int i = start; i < nums.length; i++) {\\n            min = Math.min(min, nums[i]);\\n            max = Math.max(max, nums[i]);\\n            result += max - min;\\n        }\\n        result += dfs(nums, start + 1);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        return dfs(nums, 0);\\n    }\\n    \\n    private long dfs (int[] nums, int start) {\\n        if (start == nums.length) {\\n            return 0;\\n        }\\n        long result = 0;\\n        long min = nums[start];\\n        long max = nums[start];\\n        for (int i = start; i < nums.length; i++) {\\n            min = Math.min(min, nums[i]);\\n            max = Math.max(max, nums[i]);\\n            result += max - min;\\n        }\\n        result += dfs(nums, start + 1);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027587,
                "title": "stack-c-subarray-of-sum-min-follow-up",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI would recomend doing the Sum of subarray minimum question this is a follow up question to that \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>left(n),right(n);\\n\\n//-------------->TO CALCULATE Subarray of Sum MIN<-------------\\n\\n        stack<pair<int,int>>st1;\\n        for(int i=0;i<n;i++){\\n            int count =1;\\n            while(!st1.empty() && st1.top().first>arr[i]){\\n                count+=st1.top().second;\\n                st1.pop();\\n            }\\n            st1.push({arr[i],count});\\n            left[i]=count;\\n        }\\n      while (!st1.empty())\\n            st1.pop();\\n\\n        for(int i=n-1;i>=0;i--){\\n            int count =1;\\n            while(!st1.empty() && st1.top().first>=arr[i]){\\n                count+=st1.top().second;\\n                st1.pop();\\n            }\\n            st1.push({arr[i],count});\\n            right[i]=count;\\n        }\\n    long long int minres =0;\\n        for(int i=0;i<n;i++){\\n         long long ans=(left[i]*right[i]);\\n            ans=(ans*arr[i]);\\n            minres =(minres+ans);\\n            \\n        }\\n\\n// -------------->TO CALCULATE Subarray of Sum maximum <-------------\\n\\n        stack<pair<int,int>>st2;\\n\\n              for(int i=0;i<n;i++){\\n            int count =1;\\n            while(!st2.empty() && st2.top().first<arr[i]){\\n                count+=st2.top().second;\\n                st2.pop();\\n            }\\n            st2.push({arr[i],count});\\n            left[i]=count;\\n        }\\n      while (!st2.empty())\\n            st2.pop();\\n\\n        for(int i=n-1;i>=0;i--){\\n            int count =1;\\n            while(!st2.empty() && st2.top().first<=arr[i]){\\n                count+=st2.top().second;\\n                st2.pop();\\n            }\\n            st2.push({arr[i],count});\\n            right[i]=count;\\n        }\\n         long long int maxres =0;\\n        for(int i=0;i<n;i++){\\n         long long ans=(left[i]*right[i]);\\n            ans=(ans*arr[i]);\\n            maxres =(maxres+ans);\\n            \\n        }\\n        return maxres-minres;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>left(n),right(n);\\n\\n//-------------->TO CALCULATE Subarray of Sum MIN<-------------\\n\\n        stack<pair<int,int>>st1;\\n        for(int i=0;i<n;i++){\\n            int count =1;\\n            while(!st1.empty() && st1.top().first>arr[i]){\\n                count+=st1.top().second;\\n                st1.pop();\\n            }\\n            st1.push({arr[i],count});\\n            left[i]=count;\\n        }\\n      while (!st1.empty())\\n            st1.pop();\\n\\n        for(int i=n-1;i>=0;i--){\\n            int count =1;\\n            while(!st1.empty() && st1.top().first>=arr[i]){\\n                count+=st1.top().second;\\n                st1.pop();\\n            }\\n            st1.push({arr[i],count});\\n            right[i]=count;\\n        }\\n    long long int minres =0;\\n        for(int i=0;i<n;i++){\\n         long long ans=(left[i]*right[i]);\\n            ans=(ans*arr[i]);\\n            minres =(minres+ans);\\n            \\n        }\\n\\n// -------------->TO CALCULATE Subarray of Sum maximum <-------------\\n\\n        stack<pair<int,int>>st2;\\n\\n              for(int i=0;i<n;i++){\\n            int count =1;\\n            while(!st2.empty() && st2.top().first<arr[i]){\\n                count+=st2.top().second;\\n                st2.pop();\\n            }\\n            st2.push({arr[i],count});\\n            left[i]=count;\\n        }\\n      while (!st2.empty())\\n            st2.pop();\\n\\n        for(int i=n-1;i>=0;i--){\\n            int count =1;\\n            while(!st2.empty() && st2.top().first<=arr[i]){\\n                count+=st2.top().second;\\n                st2.pop();\\n            }\\n            st2.push({arr[i],count});\\n            right[i]=count;\\n        }\\n         long long int maxres =0;\\n        for(int i=0;i<n;i++){\\n         long long ans=(left[i]*right[i]);\\n            ans=(ans*arr[i]);\\n            maxres =(maxres+ans);\\n            \\n        }\\n        return maxres-minres;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941882,
                "title": "c-super-easy-clean-code-o-n-stack-easy-to-grasp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    long long min_sum(vector<int>& arr){\\n        stack<int> st;\\n        int n = arr.size();\\n        long long mini = 0;\\n        for(int i=0; i<=n ;i++){\\n            while(!st.empty() && ( i==n || arr[st.top()] > arr[i])){\\n                int top1 = st.top();\\n                st.pop();\\n\\n                int top2 = -1;\\n                if(!st.empty()) top2 = st.top();\\n\\n                mini += 1LL * arr[top1] * (i - top1) * (top1 - top2);\\n            }\\n            st.push(i);\\n        }\\n        return mini;\\n    }\\n    long long max_sum(vector<int>& arr){\\n        stack<int> st;\\n        int n = arr.size();\\n        long long maxi = 0;\\n        for(int i=0; i<=n; i++){\\n            while(!st.empty() && (i==n || arr[st.top()] < arr[i])){\\n                int top1 = st.top();\\n                st.pop();\\n\\n                int top2 = -1;\\n                if(!st.empty()) top2 = st.top();\\n\\n                maxi += 1LL * arr[top1] * (i - top1) * (top1 - top2);\\n            }\\n            st.push(i);\\n        }\\n        return maxi;\\n    }\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        return max_sum(nums) - min_sum(nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long long min_sum(vector<int>& arr){\\n        stack<int> st;\\n        int n = arr.size();\\n        long long mini = 0;\\n        for(int i=0; i<=n ;i++){\\n            while(!st.empty() && ( i==n || arr[st.top()] > arr[i])){\\n                int top1 = st.top();\\n                st.pop();\\n\\n                int top2 = -1;\\n                if(!st.empty()) top2 = st.top();\\n\\n                mini += 1LL * arr[top1] * (i - top1) * (top1 - top2);\\n            }\\n            st.push(i);\\n        }\\n        return mini;\\n    }\\n    long long max_sum(vector<int>& arr){\\n        stack<int> st;\\n        int n = arr.size();\\n        long long maxi = 0;\\n        for(int i=0; i<=n; i++){\\n            while(!st.empty() && (i==n || arr[st.top()] < arr[i])){\\n                int top1 = st.top();\\n                st.pop();\\n\\n                int top2 = -1;\\n                if(!st.empty()) top2 = st.top();\\n\\n                maxi += 1LL * arr[top1] * (i - top1) * (top1 - top2);\\n            }\\n            st.push(i);\\n        }\\n        return maxi;\\n    }\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        return max_sum(nums) - min_sum(nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909225,
                "title": "long-but-east-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:  \\n\\n    //next small element without strictness.\\n    vector<int>createNSE(vector<int>&nums){\\n        int n = nums.size();\\n        vector<int>nse(n);\\n        stack <int>s;\\n        nse[n-1]=n;\\n        s.push(n-1);\\n        for(int i=n-2 ; i>=0 ; i--){\\n            while(!s.empty() && nums[i] <= nums[s.top()]){\\n                 s.pop();\\n            }\\n            if(s.empty()){\\n               nse[i] = n;\\n            }else{\\n                nse[i] = s.top();\\n            }\\n            s.push(i);\\n\\n        }\\n        return nse;\\n    }\\n     // previous smaller element with strictness.\\n     vector<int>createPSE(vector<int>&nums){\\n        int n = nums.size();\\n        vector<int>pse(n);\\n        stack <int>s;\\n        pse[0]=(-1);\\n        s.push(0);\\n        for(int i=1 ; i<n ; i++){\\n            while(!s.empty() && nums[i] < nums[s.top()]){\\n                 s.pop();\\n            }\\n            if(s.empty()){\\n               pse[i] = -1;\\n            }else{\\n                pse[i] = s.top();\\n            }\\n            s.push(i);\\n\\n        }\\n        return pse;\\n    }\\n\\n    //next greater element without strictness.\\n    vector<int>createNGE(vector<int>&nums){\\n        int n = nums.size();\\n        vector<int>nge(n);\\n        stack <int>s;\\n        nge[n-1]=n;\\n        s.push(n-1);\\n        for(int i=n-2 ; i>=0 ; i--){\\n            while(!s.empty() && nums[i] >= nums[s.top()]){\\n                 s.pop();\\n            }\\n            if(s.empty()){\\n               nge[i] = n;\\n            }else{\\n                nge[i] = s.top();\\n            }\\n            s.push(i);\\n\\n        }\\n        return nge;\\n    }\\n    //previous greater element with strictness.\\n    vector<int>createPGE(vector<int>&nums){\\n        int n = nums.size();\\n        vector<int>pge(n);\\n        stack <int>s;\\n        pge[0]=(-1);\\n        s.push(0);\\n        for(int i=1 ; i<n ; i++){\\n            while(!s.empty() && nums[i] > nums[s.top()]){\\n                 s.pop();\\n            }\\n            if(s.empty()){\\n               pge[i] = -1;\\n            }else{\\n                pge[i] = s.top();\\n            }\\n            s.push(i);\\n\\n        }\\n        return pge;\\n    }\\n    \\n    long long subArrayRanges(vector<int>& nums) {\\n         int n = nums.size();\\n        vector<int>nse = createNSE(nums);\\n        vector<int>pse = createPSE(nums);\\n        vector<int>nge = createNGE(nums);\\n        vector<int>pge = createPGE(nums);\\n        for(int i=0;i<n;i++){\\n           cout<<nge[i]<<\" \";\\n        }\\n        cout<<endl;\\n        for(int i=0;i<n;i++){\\n           cout<<pge[i]<<\" \";\\n        }\\n       cout<<endl;\\n        long long int ans = 0;\\n      \\n        for(int i=0 ; i<n ; i++){\\n            long long int m1 = (i-pse[i])*(nse[i]-i);\\n            long long int m2 = (i-pge[i])*(nge[i]-i);\\n            cout<<m1<<\" \"<<m2<<endl;\\n            ans += ((m2-m1) * nums[i]) ;\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:  \\n\\n    //next small element without strictness.\\n    vector<int>createNSE(vector<int>&nums){\\n        int n = nums.size();\\n        vector<int>nse(n);\\n        stack <int>s;\\n        nse[n-1]=n;\\n        s.push(n-1);\\n        for(int i=n-2 ; i>=0 ; i--){\\n            while(!s.empty() && nums[i] <= nums[s.top()]){\\n                 s.pop();\\n            }\\n            if(s.empty()){\\n               nse[i] = n;\\n            }else{\\n                nse[i] = s.top();\\n            }\\n            s.push(i);\\n\\n        }\\n        return nse;\\n    }\\n     // previous smaller element with strictness.\\n     vector<int>createPSE(vector<int>&nums){\\n        int n = nums.size();\\n        vector<int>pse(n);\\n        stack <int>s;\\n        pse[0]=(-1);\\n        s.push(0);\\n        for(int i=1 ; i<n ; i++){\\n            while(!s.empty() && nums[i] < nums[s.top()]){\\n                 s.pop();\\n            }\\n            if(s.empty()){\\n               pse[i] = -1;\\n            }else{\\n                pse[i] = s.top();\\n            }\\n            s.push(i);\\n\\n        }\\n        return pse;\\n    }\\n\\n    //next greater element without strictness.\\n    vector<int>createNGE(vector<int>&nums){\\n        int n = nums.size();\\n        vector<int>nge(n);\\n        stack <int>s;\\n        nge[n-1]=n;\\n        s.push(n-1);\\n        for(int i=n-2 ; i>=0 ; i--){\\n            while(!s.empty() && nums[i] >= nums[s.top()]){\\n                 s.pop();\\n            }\\n            if(s.empty()){\\n               nge[i] = n;\\n            }else{\\n                nge[i] = s.top();\\n            }\\n            s.push(i);\\n\\n        }\\n        return nge;\\n    }\\n    //previous greater element with strictness.\\n    vector<int>createPGE(vector<int>&nums){\\n        int n = nums.size();\\n        vector<int>pge(n);\\n        stack <int>s;\\n        pge[0]=(-1);\\n        s.push(0);\\n        for(int i=1 ; i<n ; i++){\\n            while(!s.empty() && nums[i] > nums[s.top()]){\\n                 s.pop();\\n            }\\n            if(s.empty()){\\n               pge[i] = -1;\\n            }else{\\n                pge[i] = s.top();\\n            }\\n            s.push(i);\\n\\n        }\\n        return pge;\\n    }\\n    \\n    long long subArrayRanges(vector<int>& nums) {\\n         int n = nums.size();\\n        vector<int>nse = createNSE(nums);\\n        vector<int>pse = createPSE(nums);\\n        vector<int>nge = createNGE(nums);\\n        vector<int>pge = createPGE(nums);\\n        for(int i=0;i<n;i++){\\n           cout<<nge[i]<<\" \";\\n        }\\n        cout<<endl;\\n        for(int i=0;i<n;i++){\\n           cout<<pge[i]<<\" \";\\n        }\\n       cout<<endl;\\n        long long int ans = 0;\\n      \\n        for(int i=0 ; i<n ; i++){\\n            long long int m1 = (i-pse[i])*(nse[i]-i);\\n            long long int m2 = (i-pge[i])*(nge[i]-i);\\n            cout<<m1<<\" \"<<m2<<endl;\\n            ans += ((m2-m1) * nums[i]) ;\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3847897,
                "title": "comprehensive-java-solution-with-explanation",
                "content": "# Intuition\\n1. Find how many times a number can be min in the subarray\\n2. Find how many times a number can be max in the subarray\\n> The above two sub problems can be solved using monotonic stacks\\n3. Once we get to know the number of times a number is appearing as a min and max in the subarray we can solve it using the below expression.\\n$$(maxTimes-minTimes)*arr[i]$$\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // The function to calculate the sum of differences of subarray ranges\\n    public long subArrayRanges(int[] arr) {\\n        int n = arr.length;\\n        \\n        // Arrays to store the indices of the left minimum, left maximum, right minimum, and right maximum elements for each index\\n        int leftMin[] = new int[arr.length];\\n        int leftMax[] = new int[arr.length];\\n        int rightMin[] = new int[arr.length];\\n        int rightMax[] = new int[arr.length];\\n        \\n        // Initializing the arrays with -1 (representing no valid index)\\n        for (int i = 0; i < n; i++) {\\n            leftMin[i] = -1;\\n            leftMax[i] = -1;\\n            rightMin[i] = -1;\\n            rightMax[i] = -1;\\n        }\\n\\n        // Stack to keep track of indices with smaller elements on the left side (used for finding left minimum)\\n        Stack<Integer> lmin = new Stack<>();\\n        // Stack to keep track of indices with larger elements on the left side (used for finding left maximum)\\n        Stack<Integer> lmax = new Stack<>();\\n        // Stack to keep track of indices with smaller elements on the right side (used for finding right minimum)\\n        Stack<Integer> rmin = new Stack<>();\\n        // Stack to keep track of indices with larger elements on the right side (used for finding right maximum)\\n        Stack<Integer> rmax = new Stack<>();\\n\\n        // Finding the indices of the left minimum for each element in the array\\n        for (int i = 0; i < n; i++) {\\n            while (!lmin.isEmpty() && arr[i] < arr[lmin.peek()]) {\\n                lmin.pop();\\n            }\\n            if (!lmin.isEmpty()) {\\n                leftMin[i] = lmin.peek();\\n            }\\n            lmin.push(i);\\n        }\\n        \\n        // Finding the indices of the right minimum for each element in the array\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!rmin.isEmpty() && arr[i] <= arr[rmin.peek()]) {\\n                rmin.pop();\\n            }\\n            if (!rmin.isEmpty()) {\\n                rightMin[i] = rmin.peek();\\n            }\\n            rmin.push(i);\\n        }\\n\\n        // Finding the indices of the left maximum for each element in the array\\n        for (int i = 0; i < n; i++) {\\n            while (!lmax.isEmpty() && arr[i] > arr[lmax.peek()]) {\\n                lmax.pop();\\n            }\\n            if (!lmax.isEmpty()) {\\n                leftMax[i] = lmax.peek();\\n            }\\n            lmax.push(i);\\n        }\\n\\n        // Finding the indices of the right maximum for each element in the array\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!rmax.isEmpty() && arr[i] >= arr[rmax.peek()]) {\\n                rmax.pop();\\n            }\\n            if (!rmax.isEmpty()) {\\n                rightMax[i] = rmax.peek();\\n            }\\n            rmax.push(i);\\n        }\\n        \\n        // Variable to store the final result\\n        long ans = 0;\\n\\n        // Calculating the sum of differences for each element in the array\\n        for (int i = 0; i < n; i++) {\\n            // Getting the distances to the left minimum, right minimum, left maximum, and right maximum elements for the current element\\n            long lmins = leftMin[i] == -1 ? -1 : leftMin[i];\\n            long rmins = rightMin[i] == -1 ? n : rightMin[i];\\n            long lmaxs = leftMax[i] == -1 ? -1 : leftMax[i];\\n            long rmaxs = rightMax[i] == -1 ? n : rightMax[i];\\n            \\n            // Calculating the differences in distances (ranges)\\n            long lminDiff = i - lmins;\\n            long rminDiff = rmins - i;\\n            long lmaxDiff = i - lmaxs;\\n            long rmaxDiff = rmaxs - i;\\n            \\n            // Calculating the contribution of the current element to the final result and adding it to \\'ans\\'\\n            ans = ans + ((lmaxDiff * rmaxDiff - lminDiff * rminDiff) * (arr[i] * 1l));\\n        }\\n        \\n        // Returning the final result\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n\\n    // The function to calculate the sum of differences of subarray ranges\\n    public long subArrayRanges(int[] arr) {\\n        int n = arr.length;\\n        \\n        // Arrays to store the indices of the left minimum, left maximum, right minimum, and right maximum elements for each index\\n        int leftMin[] = new int[arr.length];\\n        int leftMax[] = new int[arr.length];\\n        int rightMin[] = new int[arr.length];\\n        int rightMax[] = new int[arr.length];\\n        \\n        // Initializing the arrays with -1 (representing no valid index)\\n        for (int i = 0; i < n; i++) {\\n            leftMin[i] = -1;\\n            leftMax[i] = -1;\\n            rightMin[i] = -1;\\n            rightMax[i] = -1;\\n        }\\n\\n        // Stack to keep track of indices with smaller elements on the left side (used for finding left minimum)\\n        Stack<Integer> lmin = new Stack<>();\\n        // Stack to keep track of indices with larger elements on the left side (used for finding left maximum)\\n        Stack<Integer> lmax = new Stack<>();\\n        // Stack to keep track of indices with smaller elements on the right side (used for finding right minimum)\\n        Stack<Integer> rmin = new Stack<>();\\n        // Stack to keep track of indices with larger elements on the right side (used for finding right maximum)\\n        Stack<Integer> rmax = new Stack<>();\\n\\n        // Finding the indices of the left minimum for each element in the array\\n        for (int i = 0; i < n; i++) {\\n            while (!lmin.isEmpty() && arr[i] < arr[lmin.peek()]) {\\n                lmin.pop();\\n            }\\n            if (!lmin.isEmpty()) {\\n                leftMin[i] = lmin.peek();\\n            }\\n            lmin.push(i);\\n        }\\n        \\n        // Finding the indices of the right minimum for each element in the array\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!rmin.isEmpty() && arr[i] <= arr[rmin.peek()]) {\\n                rmin.pop();\\n            }\\n            if (!rmin.isEmpty()) {\\n                rightMin[i] = rmin.peek();\\n            }\\n            rmin.push(i);\\n        }\\n\\n        // Finding the indices of the left maximum for each element in the array\\n        for (int i = 0; i < n; i++) {\\n            while (!lmax.isEmpty() && arr[i] > arr[lmax.peek()]) {\\n                lmax.pop();\\n            }\\n            if (!lmax.isEmpty()) {\\n                leftMax[i] = lmax.peek();\\n            }\\n            lmax.push(i);\\n        }\\n\\n        // Finding the indices of the right maximum for each element in the array\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!rmax.isEmpty() && arr[i] >= arr[rmax.peek()]) {\\n                rmax.pop();\\n            }\\n            if (!rmax.isEmpty()) {\\n                rightMax[i] = rmax.peek();\\n            }\\n            rmax.push(i);\\n        }\\n        \\n        // Variable to store the final result\\n        long ans = 0;\\n\\n        // Calculating the sum of differences for each element in the array\\n        for (int i = 0; i < n; i++) {\\n            // Getting the distances to the left minimum, right minimum, left maximum, and right maximum elements for the current element\\n            long lmins = leftMin[i] == -1 ? -1 : leftMin[i];\\n            long rmins = rightMin[i] == -1 ? n : rightMin[i];\\n            long lmaxs = leftMax[i] == -1 ? -1 : leftMax[i];\\n            long rmaxs = rightMax[i] == -1 ? n : rightMax[i];\\n            \\n            // Calculating the differences in distances (ranges)\\n            long lminDiff = i - lmins;\\n            long rminDiff = rmins - i;\\n            long lmaxDiff = i - lmaxs;\\n            long rmaxDiff = rmaxs - i;\\n            \\n            // Calculating the contribution of the current element to the final result and adding it to \\'ans\\'\\n            ans = ans + ((lmaxDiff * rmaxDiff - lminDiff * rminDiff) * (arr[i] * 1l));\\n        }\\n        \\n        // Returning the final result\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621804,
                "title": "java-solution-using-monotonic-stack-time-o-2-n-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you have done question before regarding monotonic stack. Then this question won\\'t be that big of the problem . Just need to understand how to apply that in this question. We need to figure out in how many subarrays does a particular value is smallest or greatest. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo find that we are going to take help of the monotonic stack in increasing order for smallest value and decreasing order for largest value.\\n\\n# Complexity\\n- Time complexity:\\n    O(2*n)\\n\\n- Space complexity:\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n\\n        long tempSmallest=0;\\n        long tempLargest=0;\\n\\n        Stack<Integer>st=new Stack<>();\\n\\n        for(int i=0;i<=nums.length;i=i+1){\\n\\n            while(!st.isEmpty() && (i==nums.length || nums[st.peek()]>=nums[i])){\\n\\n                int temp=st.pop();\\n                int leftEnd= st.isEmpty() ? -1: st.peek();\\n                int rightEnd= i;\\n\\n                tempSmallest+= (long)nums[temp]*(rightEnd-temp)*(temp-leftEnd);\\n\\n            }\\n\\n            st.push(i);\\n\\n        }\\n\\n        while(!st.isEmpty()){\\n            st.pop();\\n        }\\n\\n        for(int i=0;i<=nums.length;i=i+1){\\n\\n            while(!st.isEmpty() && (i==nums.length || nums[st.peek()]<=nums[i])){\\n\\n                int temp=st.pop();\\n                int leftEnd= st.isEmpty() ? -1: st.peek();\\n                int rightEnd= i;\\n\\n                tempLargest+= (long)nums[temp]*(rightEnd-temp)*(temp-leftEnd);\\n\\n            }\\n\\n            st.push(i);\\n\\n        }\\n\\n        return tempLargest-tempSmallest;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n\\n        long tempSmallest=0;\\n        long tempLargest=0;\\n\\n        Stack<Integer>st=new Stack<>();\\n\\n        for(int i=0;i<=nums.length;i=i+1){\\n\\n            while(!st.isEmpty() && (i==nums.length || nums[st.peek()]>=nums[i])){\\n\\n                int temp=st.pop();\\n                int leftEnd= st.isEmpty() ? -1: st.peek();\\n                int rightEnd= i;\\n\\n                tempSmallest+= (long)nums[temp]*(rightEnd-temp)*(temp-leftEnd);\\n\\n            }\\n\\n            st.push(i);\\n\\n        }\\n\\n        while(!st.isEmpty()){\\n            st.pop();\\n        }\\n\\n        for(int i=0;i<=nums.length;i=i+1){\\n\\n            while(!st.isEmpty() && (i==nums.length || nums[st.peek()]<=nums[i])){\\n\\n                int temp=st.pop();\\n                int leftEnd= st.isEmpty() ? -1: st.peek();\\n                int rightEnd= i;\\n\\n                tempLargest+= (long)nums[temp]*(rightEnd-temp)*(temp-leftEnd);\\n\\n            }\\n\\n            st.push(i);\\n\\n        }\\n\\n        return tempLargest-tempSmallest;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238712,
                "title": "c-easy-solution-beginner-s-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong long minsum(vector<int>& num){\\n    int n=num.size();\\n    long long sum=0;\\n    long long left[n],right[n];\\n    stack<pair<int,int>> st1,st2;\\n    for(int  i=0;i<n;i++){\\n        int count=1;\\n        while(!st1.empty() && st1.top().first>=num[i]){\\n            count=count+st1.top().second;\\n            st1.pop();\\n        }\\n        st1.push({num[i],count});\\n        left[i]=count;\\n    }\\n    for(int i=n-1;i>=0;i--){\\n        int count=1;\\n        while(!st2.empty() && st2.top().first>num[i]){\\n            count=count+st2.top().second;\\n            st2.pop();\\n        }\\n        st2.push({num[i],count});\\n        right[i]=count;\\n    }\\n\\n    for(int j=0;j<n;j++){\\n        sum+=num[j]*left[j]*right[j]*1LL ;\\n       // sum=sum%mod;\\n    }\\n    return sum;\\n}\\n\\nlong long maxSum(vector<int>& nums){\\n    int n=nums.size();\\n    long long sum=0;\\n    long long left[n],right[n];\\n    stack<pair<int,int>> st1,st2;\\n    for(int i=0;i<n;i++){\\n        int count=1;\\n        while(!st1.empty() && st1.top().first<=nums[i]){\\n            count+=st1.top().second;\\n            st1.pop();\\n        }\\n          st1.push({nums[i],count});\\n        left[i]=count;\\n    }\\n    for(int i=n-1;i>=0;i--){\\n        int count=1;\\n        while(!st2.empty() && st2.top().first<nums[i]){\\n            count=count+st2.top().second;\\n            st2.pop();\\n        }\\n        st2.push({nums[i],count});\\n        right[i]=count;\\n    }\\n\\n    for(int j=0;j<n;j++){\\n        sum+=nums[j]*left[j]*right[j]*1LL ;\\n       // sum=sum%mod;\\n    }\\n    return sum;\\n}\\n\\n\\n    long long subArrayRanges(vector<int>& nums) {\\n        long long ans1=minsum(nums);\\n        long long ans2=maxSum(nums);\\n        return ans2-ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long minsum(vector<int>& num){\\n    int n=num.size();\\n    long long sum=0;\\n    long long left[n],right[n];\\n    stack<pair<int,int>> st1,st2;\\n    for(int  i=0;i<n;i++){\\n        int count=1;\\n        while(!st1.empty() && st1.top().first>=num[i]){\\n            count=count+st1.top().second;\\n            st1.pop();\\n        }\\n        st1.push({num[i],count});\\n        left[i]=count;\\n    }\\n    for(int i=n-1;i>=0;i--){\\n        int count=1;\\n        while(!st2.empty() && st2.top().first>num[i]){\\n            count=count+st2.top().second;\\n            st2.pop();\\n        }\\n        st2.push({num[i],count});\\n        right[i]=count;\\n    }\\n\\n    for(int j=0;j<n;j++){\\n        sum+=num[j]*left[j]*right[j]*1LL ;\\n       // sum=sum%mod;\\n    }\\n    return sum;\\n}\\n\\nlong long maxSum(vector<int>& nums){\\n    int n=nums.size();\\n    long long sum=0;\\n    long long left[n],right[n];\\n    stack<pair<int,int>> st1,st2;\\n    for(int i=0;i<n;i++){\\n        int count=1;\\n        while(!st1.empty() && st1.top().first<=nums[i]){\\n            count+=st1.top().second;\\n            st1.pop();\\n        }\\n          st1.push({nums[i],count});\\n        left[i]=count;\\n    }\\n    for(int i=n-1;i>=0;i--){\\n        int count=1;\\n        while(!st2.empty() && st2.top().first<nums[i]){\\n            count=count+st2.top().second;\\n            st2.pop();\\n        }\\n        st2.push({nums[i],count});\\n        right[i]=count;\\n    }\\n\\n    for(int j=0;j<n;j++){\\n        sum+=nums[j]*left[j]*right[j]*1LL ;\\n       // sum=sum%mod;\\n    }\\n    return sum;\\n}\\n\\n\\n    long long subArrayRanges(vector<int>& nums) {\\n        long long ans1=minsum(nums);\\n        long long ans2=maxSum(nums);\\n        return ans2-ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212615,
                "title": "best-c-solution-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        \\n        long long int ans=0;\\n        int n=nums.size();\\n        for (int i=0;i<n;i++)\\n        {\\n            int maxi=nums[i];\\n            int mini=nums[i];\\n            // cout<<maxi<<\" \"<<mini<<endl;\\n            for (int j=i+1;j<n;j++)\\n            {\\n                if (nums[j]>maxi)\\n                    maxi=nums[j];\\n                if (nums[j]<mini)\\n                    mini=nums[j];\\n                \\n                // cout<<maxi<<\" \"<<mini<<endl;\\n                ans+=(maxi-mini);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        \\n        long long int ans=0;\\n        int n=nums.size();\\n        for (int i=0;i<n;i++)\\n        {\\n            int maxi=nums[i];\\n            int mini=nums[i];\\n            // cout<<maxi<<\" \"<<mini<<endl;\\n            for (int j=i+1;j<n;j++)\\n            {\\n                if (nums[j]>maxi)\\n                    maxi=nums[j];\\n                if (nums[j]<mini)\\n                    mini=nums[j];\\n                \\n                // cout<<maxi<<\" \"<<mini<<endl;\\n                ans+=(maxi-mini);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2812154,
                "title": "cpp-solution-o-n2-time-complexity-solution",
                "content": "# Approach\\nNotice that the max of the subarray from index i to j is equal to max of (max of the subarray from index i to j-1) and nums[j].\\n\\n# Complexity\\n- Time complexity:O(n2),23.21% better than Cpp Online Submissions\\n\\n- Space complexity:O(n),46.60% better than Cpp Online Submissions\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& n) {\\n        long long int ans=0;\\n        for(int i=0;i<n.size();i++)\\n        {\\n            int mx=n[i],mn=n[i];\\n            for(int j=i+1;j<n.size();j++)\\n            {\\n               mx=max(mx,n[j]);\\n               mn=min(mn,n[j]);\\n               ans+=(mx-mn);\\n            }\\n        }\\n        return ans;;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& n) {\\n        long long int ans=0;\\n        for(int i=0;i<n.size();i++)\\n        {\\n            int mx=n[i],mn=n[i];\\n            for(int j=i+1;j<n.size();j++)\\n            {\\n               mx=max(mx,n[j]);\\n               mn=min(mn,n[j]);\\n               ans+=(mx-mn);\\n            }\\n        }\\n        return ans;;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643811,
                "title": "c-monostack-solution",
                "content": "# Intuition\\nThis problem is based on - 907. Sum of Subarray Minimums.\\nBut here we calculate Maximun and Minimum Sum of Subarray and return difference.\\n \\n# Approach\\n2 Monostacks\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public long SubArrayRanges(int[] nums) {\\n        return sum(nums,(a,b) => { return a < b; }) - sum(nums, (a,b) => { return a > b; });\\n    }\\n    private long sum(int[] nums, Func<int,int,bool> comp){\\n        long sum = 0;\\n        Stack<int> stack = new Stack<int>();\\n        for(int i = 0; i <= nums.Length; i++){\\n            while(stack.Count > 0 && (i == nums.Length || comp(nums[stack.Peek()], nums[i]))){\\n                int mid = stack.Pop(), left = stack.Count > 0 ? stack.Peek() : -1, right = i;\\n                sum += (long)nums[mid]*(mid-left)*(right-mid);\\n            }\\n            stack.Push(i);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Monotonic Stack"
                ],
                "code": "```\\npublic class Solution {\\n    public long SubArrayRanges(int[] nums) {\\n        return sum(nums,(a,b) => { return a < b; }) - sum(nums, (a,b) => { return a > b; });\\n    }\\n    private long sum(int[] nums, Func<int,int,bool> comp){\\n        long sum = 0;\\n        Stack<int> stack = new Stack<int>();\\n        for(int i = 0; i <= nums.Length; i++){\\n            while(stack.Count > 0 && (i == nums.Length || comp(nums[stack.Peek()], nums[i]))){\\n                int mid = stack.Pop(), left = stack.Count > 0 ? stack.Peek() : -1, right = i;\\n                sum += (long)nums[mid]*(mid-left)*(right-mid);\\n            }\\n            stack.Push(i);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583318,
                "title": "straightforward-technicques-o-n2",
                "content": "\\n\\tvar subArrayRanges = function(nums) {\\n\\t\\tvar total =0\\n\\t\\tfor(i=0;i<nums.length;i++){\\n\\t\\t\\t  min = nums[i]\\n\\t\\t\\t  max = nums[i]\\n\\t\\t\\t  for(j=i+1;j<nums.length;j++){\\n\\t\\t\\t\\t   if(min > nums[j])\\n\\t\\t\\t\\t\\t   min = nums[j]\\n\\t\\t\\t\\t   if(max < nums[j])\\n\\t\\t\\t\\t\\t   max = nums[j]\\n\\t\\t\\t\\ttotal = total + max - min\\n\\t\\t\\t}\\n\\t\\t}  \\n    return total\\n};",
                "solutionTags": [],
                "code": "\\n\\tvar subArrayRanges = function(nums) {\\n\\t\\tvar total =0\\n\\t\\tfor(i=0;i<nums.length;i++){\\n\\t\\t\\t  min = nums[i]\\n\\t\\t\\t  max = nums[i]\\n\\t\\t\\t  for(j=i+1;j<nums.length;j++){\\n\\t\\t\\t\\t   if(min > nums[j])\\n\\t\\t\\t\\t\\t   min = nums[j]\\n\\t\\t\\t\\t   if(max < nums[j])\\n\\t\\t\\t\\t\\t   max = nums[j]\\n\\t\\t\\t\\ttotal = total + max - min\\n\\t\\t\\t}\\n\\t\\t}  \\n    return total\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2562514,
                "title": "very-easy-javascript-solution-faster-than-80-less-memory-than-60",
                "content": "```\\n/**\\n * @param {number[]} a\\n * @return {number}\\n */\\nvar subArrayRanges = function (a) {\\n  let sum = 0\\n  for (let i = 0; i < a.length; i++) {\\n    let min = a[i];\\n    let max = a[i];\\n    for (let j = i + 1; j < a.length; j++) {\\n      min = Math.min(min, a[j]);\\n      max = Math.max(max, a[j]);\\n      sum += max - min;\\n    }\\n  }\\n  return sum;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} a\\n * @return {number}\\n */\\nvar subArrayRanges = function (a) {\\n  let sum = 0\\n  for (let i = 0; i < a.length; i++) {\\n    let min = a[i];\\n    let max = a[i];\\n    for (let j = i + 1; j < a.length; j++) {\\n      min = Math.min(min, a[j]);\\n      max = Math.max(max, a[j]);\\n      sum += max - min;\\n    }\\n  }\\n  return sum;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2547802,
                "title": "explained-with-image",
                "content": "![image](https://assets.leetcode.com/users/images/797bb136-0442-4a1a-93ee-c114bb478bf3_1662614423.9274123.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& v) {\\n        long long sum =0 ;\\n        int n = v.size();\\n        \\n        for(int i =0 ;i<n-1;i++){\\n            int maxi = max(v[i],v[i+1]);\\n            int mini = min(v[i],v[i+1]);\\n            \\n            for(int j=i+1;j<n;j++){\\n                maxi = max(maxi ,v[j]);\\n                mini=  min(mini, v[j]);\\n                sum+=(maxi - mini);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& v) {\\n        long long sum =0 ;\\n        int n = v.size();\\n        \\n        for(int i =0 ;i<n-1;i++){\\n            int maxi = max(v[i],v[i+1]);\\n            int mini = min(v[i],v[i+1]);\\n            \\n            for(int j=i+1;j<n;j++){\\n                maxi = max(maxi ,v[j]);\\n                mini=  min(mini, v[j]);\\n                sum+=(maxi - mini);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499782,
                "title": "simple-python-solution",
                "content": "```\\n# we need to find (max-min) in every subarray for a given array.\\n# let array = [4,-2,-3,4,1]\\n# sub array\\'s are = {[4],[-2],[-3],[4],[1],\\n#                    [4,-2],[-2,-3],[-3,4],[4,1],\\n#                    [4,-2,-3],[-2,-3,4],[-3,4,1],\\n#                    [4,-2,-3,4],[-2,-3,4,1],\\n#                    [4,-2,-3,4,1]}\\n# To solve this problem, we will find all the minimum number and maximum number \\n# from each subset and sum them into minSum and maxSum respectively. \\n# Then return maxSum-minSum as a result\\n\\n# Find minSum ?\\n# First we will find minNumber and number of times it appers in all the subarray\\'s.\\n\\n    #         minNumer                        no. of Times     Sub Array\\n    #             4                               2           {[4],[4]}\\n    #            -2                               2           {[-2],[4,-2]}\\n    #            -3                               9           {[-3],[-2,-3],[-3,4],[4,-2,-3],[-2,-3,4],\\n    #                                                          [-3,4,1],[4,-2,-3,4],[-2,-3,4,1],[4,-2,-3,4,1]}\\n    #             1                               2           {[1],[4,1]}\\n\\n# minSum = 4x2 + (-2)x2 + (-3)x9 + 1x2 \\n\\n# But, we need to solve this in O(N) time. So, How can we find minSum without generating all sub array\\'s???\\n# Actually we can, with the help of monotonic stack.\\n# monotonic stack stores data in either increasing or decreasing order.\\n# minSum = 4x2 + (-2)x2 + (-3)x9 + 1x2 = -21\\n# maxSum = 4x5 + (-2)x2 + (-3)x1 + 4x6 + 1x1 = 38\\n\\n# maxSum - minSum = 59\\n          \\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        minSum, maxSum = 0,0\\n        stack,n = [],len(nums)\\n        for nextSmaller in range(n+1):\\n            while len(stack)>0 and (nextSmaller == n or nums[stack[-1]] > nums[nextSmaller]):\\n                i = stack.pop()\\n                prevSmaller = -1 if stack == [] else stack[-1]\\n                minSum += nums[i]*(nextSmaller-i)*(i-prevSmaller)\\n            stack.append(nextSmaller)\\n        stack = []\\n        for nextGreater in range(n+1):\\n            while stack and (nextGreater == n or nums[stack[-1]] < nums[nextGreater]):\\n                i = stack.pop()\\n                prevGreater = -1 if stack == [] else stack[-1]\\n                maxSum += nums[i]*(nextGreater-i)*(i-prevGreater)\\n            stack.append(nextGreater)\\n        return maxSum-minSum\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# we need to find (max-min) in every subarray for a given array.\\n# let array = [4,-2,-3,4,1]\\n# sub array\\'s are = {[4],[-2],[-3],[4],[1],\\n#                    [4,-2],[-2,-3],[-3,4],[4,1],\\n#                    [4,-2,-3],[-2,-3,4],[-3,4,1],\\n#                    [4,-2,-3,4],[-2,-3,4,1],\\n#                    [4,-2,-3,4,1]}\\n# To solve this problem, we will find all the minimum number and maximum number \\n# from each subset and sum them into minSum and maxSum respectively. \\n# Then return maxSum-minSum as a result\\n\\n# Find minSum ?\\n# First we will find minNumber and number of times it appers in all the subarray\\'s.\\n\\n    #         minNumer                        no. of Times     Sub Array\\n    #             4                               2           {[4],[4]}\\n    #            -2                               2           {[-2],[4,-2]}\\n    #            -3                               9           {[-3],[-2,-3],[-3,4],[4,-2,-3],[-2,-3,4],\\n    #                                                          [-3,4,1],[4,-2,-3,4],[-2,-3,4,1],[4,-2,-3,4,1]}\\n    #             1                               2           {[1],[4,1]}\\n\\n# minSum = 4x2 + (-2)x2 + (-3)x9 + 1x2 \\n\\n# But, we need to solve this in O(N) time. So, How can we find minSum without generating all sub array\\'s???\\n# Actually we can, with the help of monotonic stack.\\n# monotonic stack stores data in either increasing or decreasing order.\\n# minSum = 4x2 + (-2)x2 + (-3)x9 + 1x2 = -21\\n# maxSum = 4x5 + (-2)x2 + (-3)x1 + 4x6 + 1x1 = 38\\n\\n# maxSum - minSum = 59\\n          \\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        minSum, maxSum = 0,0\\n        stack,n = [],len(nums)\\n        for nextSmaller in range(n+1):\\n            while len(stack)>0 and (nextSmaller == n or nums[stack[-1]] > nums[nextSmaller]):\\n                i = stack.pop()\\n                prevSmaller = -1 if stack == [] else stack[-1]\\n                minSum += nums[i]*(nextSmaller-i)*(i-prevSmaller)\\n            stack.append(nextSmaller)\\n        stack = []\\n        for nextGreater in range(n+1):\\n            while stack and (nextGreater == n or nums[stack[-1]] < nums[nextGreater]):\\n                i = stack.pop()\\n                prevGreater = -1 if stack == [] else stack[-1]\\n                maxSum += nums[i]*(nextGreater-i)*(i-prevGreater)\\n            stack.append(nextGreater)\\n        return maxSum-minSum\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485421,
                "title": "java-faster-than-75",
                "content": "```class Solution {\\n    public long subArrayRanges(int[] nums) {\\n\\n        long max = Integer.MIN_VALUE;\\n        long min = Integer.MAX_VALUE;\\n        long result = 0;\\n        \\n        //the last value of the array will just be zero anyway\\n        for(int i = 0; i < nums.length -1; i++) {\\n           int startVal = nums[i]; \\n            for(int k = i; k < nums.length; k++) {\\n                int curr = nums[k];\\n                if(curr > max) {\\n                    max = curr;\\n                }\\n                if(curr < min) {\\n                    min = curr;\\n                }\\n                result = result + (max - min);\\n                \\n            }\\n            //reset max and mins\\n            max = nums[i+1];\\n            min = nums[i+1];  \\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long subArrayRanges(int[] nums) {\\n\\n        long max = Integer.MIN_VALUE;\\n        long min = Integer.MAX_VALUE;\\n        long result = 0;\\n        \\n        //the last value of the array will just be zero anyway\\n        for(int i = 0; i < nums.length -1; i++) {\\n           int startVal = nums[i]; \\n            for(int k = i; k < nums.length; k++) {\\n                int curr = nums[k];\\n                if(curr > max) {\\n                    max = curr;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2461771,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        long ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            int max=nums[i],min=nums[i];\\n            for(int j=i;j<nums.length;j++){\\n                max=Math.max(max,nums[j]);\\n                min=Math.min(min,nums[j]);\\n                ans+=max-min;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        long ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            int max=nums[i],min=nums[i];\\n            for(int j=i;j<nums.length;j++){\\n                max=Math.max(max,nums[j]);\\n                min=Math.min(min,nums[j]);\\n                ans+=max-min;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428034,
                "title": "simple-java-o-n2",
                "content": "```\\npublic long subArrayRanges(int[] nums) {\\n        long sum=0;\\n        for(int i=0;i< nums.length-1;i++){\\n            int max=nums[i];\\n            int min=nums[i];\\n            for(int j=i+1;j< nums.length;j++){\\n                max=Math.max(max,nums[j]);\\n                min=Math.min(min,nums[j]);\\n                sum+=(max-min);\\n            }\\n        }\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic long subArrayRanges(int[] nums) {\\n        long sum=0;\\n        for(int i=0;i< nums.length-1;i++){\\n            int max=nums[i];\\n            int min=nums[i];\\n            for(int j=i+1;j< nums.length;j++){\\n                max=Math.max(max,nums[j]);\\n                min=Math.min(min,nums[j]);\\n                sum+=(max-min);\\n            }\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2426572,
                "title": "just-apply-the-idea-of-max-value-from-each-subarray-2-times",
                "content": "```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        \\n        long a  = helper(nums, 1L);\\n        long b  = helper(nums, -1L);\\n        return a + b;\\n    }\\n    \\n    private long helper(int[] nums, long flag) {\\n        int n = nums.length;\\n        Stack<Integer> s = new Stack<>();\\n        long re = 0;\\n        for (int i = 0; i < n; i++) {\\n            while(!s.empty() && nums[s.peek()]*flag < nums[i]*flag) {\\n                int maxIdx = s.pop();\\n                int leftEx = s.empty() ? -1 : s.peek();\\n                re+=nums[maxIdx]*flag*(i - maxIdx) * (maxIdx - leftEx);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()) {\\n            int maxIdx = s.pop();\\n            int leftEx = s.empty() ? -1 : s.peek();\\n            re+=nums[maxIdx]*flag*(n - maxIdx) * (maxIdx - leftEx);\\n        }\\n        return re;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        \\n        long a  = helper(nums, 1L);\\n        long b  = helper(nums, -1L);\\n        return a + b;\\n    }\\n    \\n    private long helper(int[] nums, long flag) {\\n        int n = nums.length;\\n        Stack<Integer> s = new Stack<>();\\n        long re = 0;\\n        for (int i = 0; i < n; i++) {\\n            while(!s.empty() && nums[s.peek()]*flag < nums[i]*flag) {\\n                int maxIdx = s.pop();\\n                int leftEx = s.empty() ? -1 : s.peek();\\n                re+=nums[maxIdx]*flag*(i - maxIdx) * (maxIdx - leftEx);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()) {\\n            int maxIdx = s.pop();\\n            int leftEx = s.empty() ? -1 : s.peek();\\n            re+=nums[maxIdx]*flag*(n - maxIdx) * (maxIdx - leftEx);\\n        }\\n        return re;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390038,
                "title": "python-clean-8-lines-two-pointers-solution",
                "content": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        ans = 0 \\n        \\n        for i in range(len(nums)):\\n            largest, smallest = nums[i], nums[i]\\n            for j in range(i+1, len(nums)):\\n                largest = max(largest, nums[j])\\n                smallest = min(smallest, nums[j])\\n                ans += largest - smallest \\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        ans = 0 \\n        \\n        for i in range(len(nums)):\\n            largest, smallest = nums[i], nums[i]\\n            for j in range(i+1, len(nums)):\\n                largest = max(largest, nums[j])\\n                smallest = min(smallest, nums[j])\\n                ans += largest - smallest \\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2378742,
                "title": "c-monotonic-stack-neat-and-modular-code",
                "content": "```\\nclass Solution {\\n    long long int ans =0;\\n    vector<int> populateNSL(vector<int>&nums)\\n    {\\n        vector<int> NSL(nums.size(),0);\\n        stack<int> st;\\n        st.push(nums.size()-1);\\n        for(int i =nums.size()-2;i>=0;i--)\\n        {\\n            while(st.size()>0 && nums[st.top()]>nums[i])\\n            {\\n                int pos = st.top();\\n                NSL[pos]=i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        while(st.size()>0)\\n        {\\n            NSL[st.top()]=-1;\\n            st.pop();\\n        }\\n        return NSL;\\n    }\\n    vector<int> populateNSR(vector<int>&nums)\\n    {\\n        vector<int> NSR(nums.size(),0);\\n        stack<int> st;\\n        st.push(0);\\n        for(int i =1 ;i<nums.size();i++)\\n        {\\n            while(st.size()>0 && nums[st.top()]>=nums[i])\\n            {\\n                int pos = st.top();\\n                NSR[pos]=i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        while(st.size()>0)\\n        {\\n            NSR[st.top()]=nums.size();\\n            st.pop();\\n        }\\n        return NSR;\\n    }\\n    vector<int> populateNGR(vector<int>&nums)\\n    {\\n        vector<int> NGR(nums.size(),0);\\n        stack<int> st;\\n        st.push(0);\\n        for(int i =1 ;i<nums.size();i++)\\n        {\\n            while(st.size()>0 && nums[st.top()]<nums[i])\\n            {\\n                int pos = st.top();\\n                NGR[pos]=i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        while(st.size()>0)\\n        {\\n            NGR[st.top()]=nums.size();\\n            st.pop();\\n        }\\n        return NGR;\\n    }\\n    vector<int> populateNGL(vector<int>&nums)\\n    {\\n        vector<int> NGL(nums.size(),0);\\n        stack<int> st;\\n        st.push(nums.size()-1);\\n        for(int i =nums.size()-2;i>=0;i--)\\n        {\\n            while(st.size()>0 && nums[st.top()]<=nums[i])\\n            {\\n                int pos = st.top();\\n                NGL[pos]=i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        while(st.size()>0)\\n        {\\n            NGL[st.top()]=-1;\\n            st.pop();\\n        }\\n        return NGL;\\n    }\\n    void addMaxRanges(vector<int>&NGL,vector<int>&NGR, vector<int>&nums)\\n    {\\n        for(int i =0 ;i<nums.size();i++)\\n        {\\n            long long int left = i-NGL[i];\\n            long long int right = NGR[i]-i;\\n            long long contribution = left*right*nums[i];\\n            ans = ans+ contribution;\\n        }\\n    }\\n    void addMinRanges(vector<int>&NSL , vector<int>&NSR,vector<int>&nums)\\n    {\\n         for(int i =0 ;i<nums.size();i++)\\n        {\\n            long long int left = i-NSL[i];\\n            long long int right = NSR[i]-i;\\n            long long contribution = left*right*nums[i];\\n            ans = ans- contribution;\\n        }\\n    }\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        auto NSR = populateNSR(nums);\\n        auto NSL = populateNSL(nums);\\n        auto NGR = populateNGR(nums);\\n        auto NGL = populateNGL(nums);\\n        addMaxRanges(NGL,NGR,nums);\\n        addMinRanges(NSL,NSR,nums);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long long int ans =0;\\n    vector<int> populateNSL(vector<int>&nums)\\n    {\\n        vector<int> NSL(nums.size(),0);\\n        stack<int> st;\\n        st.push(nums.size()-1);\\n        for(int i =nums.size()-2;i>=0;i--)\\n        {\\n            while(st.size()>0 && nums[st.top()]>nums[i])\\n            {\\n                int pos = st.top();\\n                NSL[pos]=i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        while(st.size()>0)\\n        {\\n            NSL[st.top()]=-1;\\n            st.pop();\\n        }\\n        return NSL;\\n    }\\n    vector<int> populateNSR(vector<int>&nums)\\n    {\\n        vector<int> NSR(nums.size(),0);\\n        stack<int> st;\\n        st.push(0);\\n        for(int i =1 ;i<nums.size();i++)\\n        {\\n            while(st.size()>0 && nums[st.top()]>=nums[i])\\n            {\\n                int pos = st.top();\\n                NSR[pos]=i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        while(st.size()>0)\\n        {\\n            NSR[st.top()]=nums.size();\\n            st.pop();\\n        }\\n        return NSR;\\n    }\\n    vector<int> populateNGR(vector<int>&nums)\\n    {\\n        vector<int> NGR(nums.size(),0);\\n        stack<int> st;\\n        st.push(0);\\n        for(int i =1 ;i<nums.size();i++)\\n        {\\n            while(st.size()>0 && nums[st.top()]<nums[i])\\n            {\\n                int pos = st.top();\\n                NGR[pos]=i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        while(st.size()>0)\\n        {\\n            NGR[st.top()]=nums.size();\\n            st.pop();\\n        }\\n        return NGR;\\n    }\\n    vector<int> populateNGL(vector<int>&nums)\\n    {\\n        vector<int> NGL(nums.size(),0);\\n        stack<int> st;\\n        st.push(nums.size()-1);\\n        for(int i =nums.size()-2;i>=0;i--)\\n        {\\n            while(st.size()>0 && nums[st.top()]<=nums[i])\\n            {\\n                int pos = st.top();\\n                NGL[pos]=i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        while(st.size()>0)\\n        {\\n            NGL[st.top()]=-1;\\n            st.pop();\\n        }\\n        return NGL;\\n    }\\n    void addMaxRanges(vector<int>&NGL,vector<int>&NGR, vector<int>&nums)\\n    {\\n        for(int i =0 ;i<nums.size();i++)\\n        {\\n            long long int left = i-NGL[i];\\n            long long int right = NGR[i]-i;\\n            long long contribution = left*right*nums[i];\\n            ans = ans+ contribution;\\n        }\\n    }\\n    void addMinRanges(vector<int>&NSL , vector<int>&NSR,vector<int>&nums)\\n    {\\n         for(int i =0 ;i<nums.size();i++)\\n        {\\n            long long int left = i-NSL[i];\\n            long long int right = NSR[i]-i;\\n            long long contribution = left*right*nums[i];\\n            ans = ans- contribution;\\n        }\\n    }\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        auto NSR = populateNSR(nums);\\n        auto NSL = populateNSL(nums);\\n        auto NGR = populateNGR(nums);\\n        auto NGL = populateNGL(nums);\\n        addMaxRanges(NGL,NGR,nums);\\n        addMinRanges(NSL,NSR,nums);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368623,
                "title": "python-o-n-with-monotonic-stack",
                "content": "\\tclass Solution:\\n\\t\\tdef subArrayRanges(self, nums: List[int]) -> int:\\n\\n\\t\\t\\t### mono inc. stack\\n\\t\\t\\tstinc = []\\n\\n\\t\\t\\t### mono dec. stack\\n\\t\\t\\tstdec = []\\n\\n\\t\\t\\t### prev greatest index for current index i.e curr_index : index of prev greatest\\n\\t\\t\\tprevgre = {}\\n\\n\\t\\t\\t### similarly for prev lesser, next greater and next lesser\\n\\t\\t\\tprevles = {}\\n\\t\\t\\tnextgre = {}\\n\\t\\t\\tnextles = {}\\n\\n\\t\\t\\t### return num of subarrays that includes index i with boundaries l (left) and r (right) \\n\\t\\t\\tdef getsub(l,i,r):\\n\\n\\t\\t\\t\\treturn (i-l+1)*(r-i+1)\\n\\n\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tcurr = nums[i]\\n\\t\\t\\t\\twhile(stdec and stdec[-1][0]<=curr):\\n\\t\\t\\t\\t\\tele,idx = stdec.pop()\\n\\t\\t\\t\\t\\tnextgre[idx] = i\\n\\t\\t\\t\\tif stdec:\\n\\t\\t\\t\\t\\tprevgre[i] = stdec[-1][1]\\n\\t\\t\\t\\tstdec.append([curr,i])\\n\\n\\t\\t\\t\\twhile(stinc and stinc[-1][0]>=curr):\\n\\t\\t\\t\\t\\tele,idx = stinc.pop()\\n\\t\\t\\t\\t\\tnextles[idx] = i\\n\\t\\t\\t\\tif stinc:\\n\\t\\t\\t\\t\\tprevles[i] = stinc[-1][1]\\n\\t\\t\\t\\tstinc.append([curr,i])\\n\\n\\t\\t\\tans = 0\\n\\n\\n\\t\\t\\tfor i in range(len(nums)):\\n\\n\\t\\t\\t\\t### lg and rg such that num[i] is the greatest elemnent within lg and rg boundaries\\n\\t\\t\\t\\tlg = prevgre[i]+1 if i in prevgre else 0\\n\\t\\t\\t\\trg = nextgre[i]-1 if i in nextgre else len(nums)-1 \\n\\n\\t\\t\\t\\t### ls and rs such that num[i] is the smallest elemnent within ls and rs boundaries\\n\\t\\t\\t\\tls = prevles[i]+1 if i in prevles else 0\\n\\t\\t\\t\\trs = nextles[i]-1 if i in nextles else len(nums)-1 \\n\\n\\n\\t\\t\\t\\t### plus is added to total sum where num[i] is greatest between lg and rg\\n\\t\\t\\t\\tplus = nums[i]*getsub(lg,i,rg)\\n\\n\\t\\t\\t\\t### minus is subtracted from total sum where num[i] is smallest between ls and rs\\n\\t\\t\\t\\tminus = nums[i]*getsub(ls,i,rs)\\n\\n\\t\\t\\t\\tans+= plus\\n\\t\\t\\t\\tans-= minus\\n\\n\\t\\t\\treturn ans",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef subArrayRanges(self, nums: List[int]) -> int:\\n\\n\\t\\t\\t### mono inc. stack\\n\\t\\t\\tstinc = []\\n\\n\\t\\t\\t### mono dec. stack\\n\\t\\t\\tstdec = []\\n\\n\\t\\t\\t### prev greatest index for current index i.e curr_index : index of prev greatest\\n\\t\\t\\tprevgre = {}",
                "codeTag": "Java"
            },
            {
                "id": 2347626,
                "title": "javascript-95-faster",
                "content": "```\\nvar subArrayRanges = function(nums) {\\nconst len=nums.length;\\nlet subRangeSum=0;\\nfor(let i=0;i<len;i++){\\n    let min=nums[i];\\n    let max=nums[i];\\nfor(let j=i+1;j<len;j++){\\n    if(nums[j]<min){\\n        min=nums[j];\\n    }\\n      if(nums[j]>max){\\n        max=nums[j];\\n    }\\nconst diff=max-min;\\nsubRangeSum+=diff;\\n}\\n}\\nreturn subRangeSum;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar subArrayRanges = function(nums) {\\nconst len=nums.length;\\nlet subRangeSum=0;\\nfor(let i=0;i<len;i++){\\n    let min=nums[i];\\n    let max=nums[i];\\nfor(let j=i+1;j<len;j++){\\n    if(nums[j]<min){\\n        min=nums[j];\\n    }\\n      if(nums[j]>max){\\n        max=nums[j];\\n    }\\nconst diff=max-min;\\nsubRangeSum+=diff;\\n}\\n}\\nreturn subRangeSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2346368,
                "title": "java-simple-solution-for-loops",
                "content": "```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        long res = 0;\\n        for (int i=0; i<nums.length; i++) {\\n            long minVal = nums[i];\\n            long maxVal = nums[i];\\n            for (int j=i; j<nums.length; j++) {\\n                minVal = Math.min(minVal, nums[j]);\\n                maxVal = Math.max(maxVal, nums[j]);\\n                res += maxVal - minVal;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        long res = 0;\\n        for (int i=0; i<nums.length; i++) {\\n            long minVal = nums[i];\\n            long maxVal = nums[i];\\n            for (int j=i; j<nums.length; j++) {\\n                minVal = Math.min(minVal, nums[j]);\\n                maxVal = Math.max(maxVal, nums[j]);\\n                res += maxVal - minVal;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346349,
                "title": "python3-brute-force-simple-solution",
                "content": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        res = 0\\n        for i in range(len(nums)):\\n            minVal = nums[i]\\n            maxVal = nums[i]\\n            for j in range(i, len(nums)):\\n                minVal = min(minVal, nums[j])\\n                maxVal = max(maxVal, nums[j])\\n                res += maxVal - minVal\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        res = 0\\n        for i in range(len(nums)):\\n            minVal = nums[i]\\n            maxVal = nums[i]\\n            for j in range(i, len(nums)):\\n                minVal = min(minVal, nums[j])\\n                maxVal = max(maxVal, nums[j])\\n                res += maxVal - minVal\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2343727,
                "title": "python-3-one-line-with-accumulate",
                "content": "```python\\nclass Solution:\\n  def subArrayRanges(self, A: List[int]) -> int:\\n    return sum(sum(map(sub, accumulate(A[i:], max), accumulate(A[i:], min))) for i in range(len(A)))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n  def subArrayRanges(self, A: List[int]) -> int:\\n    return sum(sum(map(sub, accumulate(A[i:], max), accumulate(A[i:], min))) for i in range(len(A)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333927,
                "title": "c-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        \\n        long sum=0;\\n        \\n        for(int l=0; l<nums.size(); l++){\\n            int minnum = nums[l];\\n            int maxnum = nums[l];\\n            for(int r=l; r<nums.size(); r++){\\n                // key: min and max can be reuse!\\n                maxnum = max(maxnum, nums[r]);\\n                minnum = min(minnum, nums[r]);\\n                sum += maxnum - minnum;\\n            }\\n        }\\n        return sum;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        \\n        long sum=0;\\n        \\n        for(int l=0; l<nums.size(); l++){\\n            int minnum = nums[l];\\n            int maxnum = nums[l];\\n            for(int r=l; r<nums.size(); r++){\\n                // key: min and max can be reuse!\\n                maxnum = max(maxnum, nums[r]);\\n                minnum = min(minnum, nums[r]);\\n                sum += maxnum - minnum;\\n            }\\n        }\\n        return sum;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214556,
                "title": "easiest-c-o-n",
                "content": "```\\n\\nclass Solution\\n{\\npublic:\\n    typedef long long ll;\\n    ll get(vector<ll> &arr, int idx)\\n    {\\n        if (idx == -1)\\n            return 0;\\n\\n        return arr[idx];\\n    }\\n    long long subArrayRanges(vector<int> &nums)\\n    {\\n\\n        stack<int> inc;\\n        stack<int> dec;\\n\\n        vector<int> nextgreater(nums.size(), -1);\\n        vector<int> nextsmaller(nums.size(), -1);\\n\\n        for (int i = nums.size() - 1; i >= 0; i--)\\n        {\\n\\n            while (!dec.empty() && nums[i] > nums[dec.top()])\\n            {\\n                nextgreater[dec.top()] = i;\\n                dec.pop();\\n            }\\n\\n            dec.push(i);\\n\\n            while (!inc.empty() && nums[i] < nums[inc.top()])\\n            {\\n                nextsmaller[inc.top()] = i;\\n                inc.pop();\\n            }\\n\\n            inc.push(i);\\n        }\\n\\n        vector<ll> sumofmax(nums.size(), 0);\\n        vector<ll> sumofmin(nums.size(), 0);\\n\\n        long long res = 0;\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            int ng = nextgreater[i];\\n            int ns = nextsmaller[i];\\n\\n            sumofmax[i] = get(sumofmax, ng) + (ll)(i - ng) * (ll)nums[i];\\n            sumofmin[i] = get(sumofmin, ns) + (ll)(i - ns) * (ll)nums[i];\\n\\n            //cout<<sumofmax[i]<<\" \"<<sumofmin[i]<<endl;\\n\\n            res += sumofmax[i] - sumofmin[i];\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n    typedef long long ll;\\n    ll get(vector<ll> &arr, int idx)\\n    {\\n        if (idx == -1)\\n            return 0;\\n\\n        return arr[idx];\\n    }\\n    long long subArrayRanges(vector<int> &nums)\\n    {\\n\\n        stack<int> inc;\\n        stack<int> dec;\\n\\n        vector<int> nextgreater(nums.size(), -1);\\n        vector<int> nextsmaller(nums.size(), -1);\\n\\n        for (int i = nums.size() - 1; i >= 0; i--)\\n        {\\n\\n            while (!dec.empty() && nums[i] > nums[dec.top()])\\n            {\\n                nextgreater[dec.top()] = i;\\n                dec.pop();\\n            }\\n\\n            dec.push(i);\\n\\n            while (!inc.empty() && nums[i] < nums[inc.top()])\\n            {\\n                nextsmaller[inc.top()] = i;\\n                inc.pop();\\n            }\\n\\n            inc.push(i);\\n        }\\n\\n        vector<ll> sumofmax(nums.size(), 0);\\n        vector<ll> sumofmin(nums.size(), 0);\\n\\n        long long res = 0;\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            int ng = nextgreater[i];\\n            int ns = nextsmaller[i];\\n\\n            sumofmax[i] = get(sumofmax, ng) + (ll)(i - ng) * (ll)nums[i];\\n            sumofmin[i] = get(sumofmin, ns) + (ll)(i - ns) * (ll)nums[i];\\n\\n            //cout<<sumofmax[i]<<\" \"<<sumofmin[i]<<endl;\\n\\n            res += sumofmax[i] - sumofmin[i];\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2194637,
                "title": "linear-time-and-space-complexity-extented-minimum-subarray-sum",
                "content": "**Using the similar idea of sum of subarray minimums https://leetcode.com/problems/sum-of-subarray-minimums/, getting sum of subarray maximums by multiplying -1 to every element of nums**\\n\\n**Upvote if found useful! \\uD83D\\uDE4F**\\n```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        long mins=sumSubarrayMins(nums);\\n        for(int i=0;i<nums.length;i++) nums[i]=-nums[i];\\n        long maxs=sumSubarrayMins(nums);\\n        \\n        return -maxs-mins;\\n    }\\n    \\n    public long sumSubarrayMins(int[] arr) {\\n        \\n        Stack<Integer> stack=new Stack<>();\\n        long res=0;\\n \\n        for(int i=0;i<arr.length;i++){\\n            while(stack.isEmpty()==false && arr[stack.peek()]>=arr[i]){\\n                int index=stack.pop();\\n                int right=i-index-1;\\n                int left=(stack.isEmpty()?index:index-stack.peek()-1);\\n                long subarrays=(long)((right+1)*(left+1));\\n                res+=(long)(arr[index]*subarrays);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        while(stack.isEmpty()==false){\\n            int index=stack.pop();\\n            int right=arr.length-index-1;\\n            int left=(stack.isEmpty()?index:index-stack.peek()-1);\\n            long subarrays=(long)((right+1)*(left+1));\\n            res+=(long)(arr[index]*subarrays);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        long mins=sumSubarrayMins(nums);\\n        for(int i=0;i<nums.length;i++) nums[i]=-nums[i];\\n        long maxs=sumSubarrayMins(nums);\\n        \\n        return -maxs-mins;\\n    }\\n    \\n    public long sumSubarrayMins(int[] arr) {\\n        \\n        Stack<Integer> stack=new Stack<>();\\n        long res=0;\\n \\n        for(int i=0;i<arr.length;i++){\\n            while(stack.isEmpty()==false && arr[stack.peek()]>=arr[i]){\\n                int index=stack.pop();\\n                int right=i-index-1;\\n                int left=(stack.isEmpty()?index:index-stack.peek()-1);\\n                long subarrays=(long)((right+1)*(left+1));\\n                res+=(long)(arr[index]*subarrays);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        while(stack.isEmpty()==false){\\n            int index=stack.pop();\\n            int right=arr.length-index-1;\\n            int left=(stack.isEmpty()?index:index-stack.peek()-1);\\n            long subarrays=(long)((right+1)*(left+1));\\n            res+=(long)(arr[index]*subarrays);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192576,
                "title": "python-simple-o-n-2",
                "content": "```\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        summ = 0        \\n        for i in range(len(nums)):\\n            maxx = nums[i]\\n            minn = nums[i]\\n            for j in range(i,len(nums)):\\n                maxx = max(maxx, nums[j])\\n                minn = min(minn, nums[j])\\n                summ+=maxx-minn\\n        return summ\\n```",
                "solutionTags": [],
                "code": "```\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        summ = 0        \\n        for i in range(len(nums)):\\n            maxx = nums[i]\\n            minn = nums[i]\\n            for j in range(i,len(nums)):\\n                maxx = max(maxx, nums[j])\\n                minn = min(minn, nums[j])\\n                summ+=maxx-minn\\n        return summ\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2183042,
                "title": "very-easy-c-solution-without-stack",
                "content": "```\\nlong long subArrayRanges(vector<int>& nums) {\\n        long long int sum = 0;\\n        int count = INT_MIN;\\n        int cou = INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            count = nums[i];\\n            cou = nums[i];\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                count =  max(count,nums[j]);\\n                cou = min(cou,nums[j]);\\n                sum = sum +count - cou;\\n            }\\n        }\\n        return sum;\\n    }\\n\\tIf you like the solution, do upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long subArrayRanges(vector<int>& nums) {\\n        long long int sum = 0;\\n        int count = INT_MIN;\\n        int cou = INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            count = nums[i];\\n            cou = nums[i];\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                count =  max(count,nums[j]);\\n                cou = min(cou,nums[j]);\\n                sum = sum +count - cou;\\n            }\\n        }\\n        return sum;\\n    }\\n\\tIf you like the solution, do upvote.",
                "codeTag": "Unknown"
            },
            {
                "id": 2165366,
                "title": "python3-solution-o-n-time",
                "content": "```\\nclass Solution:\\n    def subArrayRanges(self, A):\\n        A.append(0)\\n        ans, n = 0, len(A)\\n        stack_max, stack_min = [], []\\n        for i in range(n):\\n            while stack_max and (i == n-1 or A[stack_max[-1]] < A[i]):\\n                w = stack_max.pop()\\n                k = stack_max[-1] if stack_max else -1\\n                ans += A[w] * (i - w) * (w - k)\\n            stack_max.append(i)\\n            while stack_min and (i == n-1 or A[stack_min[-1]] > A[i]):\\n                w = stack_min.pop()\\n                k = stack_min[-1] if stack_min else -1\\n                ans -= A[w] * (i - w) * (w - k)\\n            stack_min.append(i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def subArrayRanges(self, A):\\n        A.append(0)\\n        ans, n = 0, len(A)\\n        stack_max, stack_min = [], []\\n        for i in range(n):\\n            while stack_max and (i == n-1 or A[stack_max[-1]] < A[i]):\\n                w = stack_max.pop()\\n                k = stack_max[-1] if stack_max else -1\\n                ans += A[w] * (i - w) * (w - k)\\n            stack_max.append(i)\\n            while stack_min and (i == n-1 or A[stack_min[-1]] > A[i]):\\n                w = stack_min.pop()\\n                k = stack_min[-1] if stack_min else -1\\n                ans -= A[w] * (i - w) * (w - k)\\n            stack_min.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162655,
                "title": "my-java-solution",
                "content": "```\\nclass Solution {\\n    \\n    //Time Complexity O(N^2)\\n    //Space Complexity O(1)\\n    public long subArrayRanges(int[] nums) {\\n        //corner cases: can nums be null or empty? No\\n        long result = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int smallest = nums[i];\\n            int largest = nums[i];\\n            \\n            for (int j = i + 1; j < nums.length; j++) {\\n                smallest = Math.min(smallest, nums[j]);\\n                largest = Math.max(largest, nums[j]);                \\n                \\n                result += largest - smallest;\\n                \\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //Time Complexity O(N^2)\\n    //Space Complexity O(1)\\n    public long subArrayRanges(int[] nums) {\\n        //corner cases: can nums be null or empty? No\\n        long result = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int smallest = nums[i];\\n            int largest = nums[i];\\n            \\n            for (int j = i + 1; j < nums.length; j++) {\\n                smallest = Math.min(smallest, nums[j]);\\n                largest = Math.max(largest, nums[j]);                \\n                \\n                result += largest - smallest;\\n                \\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152938,
                "title": "java-easy-to-understand-0-n",
                "content": "This question is a modified version of Sum of sub-array minimums. https://leetcode.com/problems/sum-of-subarray-minimums/\\n\\nSimilar to the above question, we find maximum values as well. The trick is that for every number in the input array, we find no. of values which are:\\n*  smaller on the left side\\n*  smaller on the right rside\\n*  greater on the left side\\n*  greater on the right side\\n\\n\\nNumber of subarrays for an n length array : (n * n+1 )/ 2\\nMathametically, if we compute number of subarrays which have a particular min value. We will get,\\nnumber of elements on the left side (n) * number of elements on the right side (m). If we multiply this with the number itself we get the sum of subarray minimum: n * m * arr[i];\\n\\nWe do the same to find out sum of subarray maximums. In the end if we subtract these two values we, will get the sum of subarray range. \\nWe start by taking 4 arrays which store these min and max values for left and right side. I have used ArrayDeque to make it o(n) complexity and help us compare the values. \\n\\n\\n\\n```\\nclass pair{\\n    int num;\\n    int count;\\n    pair(int n, int c){\\n        num = n;\\n        count = c;\\n    }\\n}\\n\\nclass Solution {\\n    public long subArrayRanges(int[] arr) {\\n          \\n        int n = arr.length;\\n        long[] minLeft = new long[n];\\n        long[] minRight = new long[n];\\n        long[] maxLeft = new long[n];\\n        long[] maxRight = new long[n];\\n        \\n        ArrayDeque<pair> q = new ArrayDeque<>();\\n        \\n        for(int i = 0 ; i < n; i++){\\n            int cur = arr[i];\\n            int cnt = 1;\\n            \\n            while(q.size() != 0 && q.peek().num > cur){\\n                cnt += q.pop().count;\\n            }\\n            q.push(new pair(cur,cnt));\\n            minLeft[i] = cnt;\\n        }\\n        \\n        q.clear();\\n        \\n        for(int i = n-1; i >= 0 ; i--){\\n            int cur = arr[i];\\n            int cnt=1;\\n            \\n            while(q.size() != 0 && q.peek().num >= cur){\\n                cnt += q.pop().count;\\n            }\\n            q.push(new pair(cur,cnt));\\n            minRight[i] = cnt;\\n        }\\n        \\n        q.clear();\\n       for(int i = 0 ; i < n; i++){\\n            int cur = arr[i];\\n            int cnt = 1;\\n            \\n            while(q.size() != 0 && q.peek().num < cur){\\n                cnt += q.pop().count;\\n            }\\n            q.push(new pair(cur,cnt));\\n            maxLeft[i] = cnt;\\n        }\\n        \\n        q.clear();\\n        \\n        for(int i = n-1; i >= 0 ; i--){\\n            int cur = arr[i];\\n            int cnt=1;\\n            \\n            while(q.size() != 0 && q.peek().num <= cur){\\n                cnt += q.pop().count;\\n            }\\n            q.push(new pair(cur,cnt));\\n            maxRight[i] = cnt;\\n        }\\n        \\n        \\n        long res = 0; \\n        for (int i = 0; i < n; i++)\\n            res += arr[i] * ((maxLeft[i]*maxRight[i]) - (minLeft[i]*minRight[i]));\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass pair{\\n    int num;\\n    int count;\\n    pair(int n, int c){\\n        num = n;\\n        count = c;\\n    }\\n}\\n\\nclass Solution {\\n    public long subArrayRanges(int[] arr) {\\n          \\n        int n = arr.length;\\n        long[] minLeft = new long[n];\\n        long[] minRight = new long[n];\\n        long[] maxLeft = new long[n];\\n        long[] maxRight = new long[n];\\n        \\n        ArrayDeque<pair> q = new ArrayDeque<>();\\n        \\n        for(int i = 0 ; i < n; i++){\\n            int cur = arr[i];\\n            int cnt = 1;\\n            \\n            while(q.size() != 0 && q.peek().num > cur){\\n                cnt += q.pop().count;\\n            }\\n            q.push(new pair(cur,cnt));\\n            minLeft[i] = cnt;\\n        }\\n        \\n        q.clear();\\n        \\n        for(int i = n-1; i >= 0 ; i--){\\n            int cur = arr[i];\\n            int cnt=1;\\n            \\n            while(q.size() != 0 && q.peek().num >= cur){\\n                cnt += q.pop().count;\\n            }\\n            q.push(new pair(cur,cnt));\\n            minRight[i] = cnt;\\n        }\\n        \\n        q.clear();\\n       for(int i = 0 ; i < n; i++){\\n            int cur = arr[i];\\n            int cnt = 1;\\n            \\n            while(q.size() != 0 && q.peek().num < cur){\\n                cnt += q.pop().count;\\n            }\\n            q.push(new pair(cur,cnt));\\n            maxLeft[i] = cnt;\\n        }\\n        \\n        q.clear();\\n        \\n        for(int i = n-1; i >= 0 ; i--){\\n            int cur = arr[i];\\n            int cnt=1;\\n            \\n            while(q.size() != 0 && q.peek().num <= cur){\\n                cnt += q.pop().count;\\n            }\\n            q.push(new pair(cur,cnt));\\n            maxRight[i] = cnt;\\n        }\\n        \\n        \\n        long res = 0; \\n        for (int i = 0; i < n; i++)\\n            res += arr[i] * ((maxLeft[i]*maxRight[i]) - (minLeft[i]*minRight[i]));\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2149253,
                "title": "c-o-n-time-2-stacks-solution",
                "content": "similiar idea to 907. Sum of Subarray Minimums\\na more detailed explaination can be found here:\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/discuss/2145071/c-on-time-o1-space-monotonic-stack-step-by-step-explanation\\n```\\nlong long subArrayRanges(vector<int>& arr) {\\n        stack<int> smin;\\n        stack<int> smax;\\n        smin.push(-1);\\n        smax.push(-1);\\n        smin.push(0);\\n        smax.push(0);\\n        int top;\\n        long long resmin = 0, resmax = 0;\\n        int w,h,cur;\\n        long long val;\\n        for(int i=1; i<=arr.size(); i++){\\n            cur = i==arr.size() ? INT_MIN:arr[i];\\n            while(smin.top()!=-1&&cur<arr[smin.top()]){\\n                top = smin.top();\\n                smin.pop();\\n                w = i-top;\\n                h = top-smin.top();\\n                val = w*h;\\n                val = val*arr[top];\\n                resmin = resmin+val;\\n            }\\n            smin.push(i);\\n            cur = i==arr.size() ? INT_MAX:arr[i];\\n            while(smax.top()!=-1&&cur>arr[smax.top()]){\\n                top = smax.top();\\n                smax.pop();\\n                w = i-top;\\n                h = top-smax.top();\\n                val = w*h;\\n                val = val*arr[top];\\n                resmax = resmax+val;\\n            }\\n            smax.push(i);\\n        }\\n        return resmax-resmin;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\nlong long subArrayRanges(vector<int>& arr) {\\n        stack<int> smin;\\n        stack<int> smax;\\n        smin.push(-1);\\n        smax.push(-1);\\n        smin.push(0);\\n        smax.push(0);\\n        int top;\\n        long long resmin = 0, resmax = 0;\\n        int w,h,cur;\\n        long long val;\\n        for(int i=1; i<=arr.size(); i++){\\n            cur = i==arr.size() ? INT_MIN:arr[i];\\n            while(smin.top()!=-1&&cur<arr[smin.top()]){\\n                top = smin.top();\\n                smin.pop();\\n                w = i-top;\\n                h = top-smin.top();\\n                val = w*h;\\n                val = val*arr[top];\\n                resmin = resmin+val;\\n            }\\n            smin.push(i);\\n            cur = i==arr.size() ? INT_MAX:arr[i];\\n            while(smax.top()!=-1&&cur>arr[smax.top()]){\\n                top = smax.top();\\n                smax.pop();\\n                w = i-top;\\n                h = top-smax.top();\\n                val = w*h;\\n                val = val*arr[top];\\n                resmax = resmax+val;\\n            }\\n            smax.push(i);\\n        }\\n        return resmax-resmin;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2140156,
                "title": "c-monotonic-stack-o-n-and-o-n-2",
                "content": "**Approach 1 : O(n^2)**\\n\\n\\n```\\nlong long subArrayRanges(vector<int>& nums) {\\n\\t long long ans=0;\\n\\tint mina,maxa;\\n\\tfor(int i=0;i<nums.size();i++){\\n\\t\\tmina=INT_MAX,maxa=INT_MIN;\\n\\t\\tfor(int j=i;j<nums.size();j++){\\n\\t\\t\\tmina=min(mina,nums[j]);\\n\\t\\t\\tmaxa=max(maxa,nums[j]);\\n\\t\\t\\tans+=(maxa-mina);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\n\\n**Approach 2 : O(n)**\\n\\nExplanation : \\n\\n![image](https://assets.leetcode.com/users/images/e9bfec49-9711-4125-8b78-a7f31cbb0bc1_1654979266.7611704.gif)\\n\\n![image](https://assets.leetcode.com/users/images/9a7e59fe-d723-47da-82bf-41811f5f2226_1654979279.0576549.gif)\\n![image](https://assets.leetcode.com/users/images/9b8dd9ba-ba26-4f81-8f57-d6d3621b7538_1654979293.7122781.gif)\\n\\nReference : [solution](https://leetcode.com/problems/sum-of-subarray-ranges/discuss/1624222/JavaC++Python-O(n)-solution-detailed-explanation)\\n\\nFind the sum of subarray minimum [here](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/2140098/c++-or-Monotonic-Stack-O(n))\\n\\nSimilary find the  sum of subarray maximum and take the difference.  \\n```\\n```\\n\\n\\n\\n     long long sumSubarrayMins(vector<int>& arr) {\\n        stack<int> s;\\n        long long  ans=0;\\n        vector<int> left(arr.size()), right(arr.size());\\n        s.push(-1);\\n        for(int i=0;i<arr.size();i++){\\n            while(!s.empty()&&s.top()!=-1&&arr[s.top()]>=arr[i])\\n                s.pop();\\n            if(!s.empty())\\n                left[i]=i-s.top();\\n            s.push(i);\\n        }\\n        while(!s.empty()) s.pop();\\n        s.push(arr.size());\\n         for(int i=arr.size()-1;i>=0;i--){\\n            while(!s.empty()&&s.top()!=arr.size()&&arr[s.top()]>arr[i])\\n                s.pop();\\n            if(!s.empty())\\n                right[i]=s.top()-i;\\n            s.push(i);\\n        }\\n        \\n        for(int i=0;i<arr.size();i++){\\n            ans+=((long long)arr[i]*left[i]*right[i]);\\n        }   \\n        return ans;\\n    }\\n    \\n       long long  sumSubarrayMax(vector<int>& arr) {\\n        stack<int> s;\\n        long long ans=0;\\n        vector<int> left(arr.size()), right(arr.size());\\n        s.push(-1);\\n        for(int i=0;i<arr.size();i++){\\n            while(!s.empty()&&s.top()!=-1&&arr[s.top()]<=arr[i])\\n                s.pop();\\n            if(!s.empty())\\n                left[i]=i-s.top();\\n            s.push(i);\\n        }\\n        while(!s.empty()) s.pop();\\n        s.push(arr.size());\\n         for(int i=arr.size()-1;i>=0;i--){\\n            while(!s.empty()&&s.top()!=arr.size()&&arr[s.top()]<arr[i])\\n                s.pop();\\n            if(!s.empty())\\n                right[i]=s.top()-i;\\n            s.push(i);\\n        }\\n        \\n        for(int i=0;i<arr.size();i++){\\n            ans+=((long long)arr[i]*left[i]*right[i]);\\n        }   \\n        return ans;\\n    }\\n    \\n    long long subArrayRanges(vector<int>& nums) {\\n        \\n        return (long long )(sumSubarrayMax(nums) - sumSubarrayMins(nums));\\n    }\\n```\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nlong long subArrayRanges(vector<int>& nums) {\\n\\t long long ans=0;\\n\\tint mina,maxa;\\n\\tfor(int i=0;i<nums.size();i++){\\n\\t\\tmina=INT_MAX,maxa=INT_MIN;\\n\\t\\tfor(int j=i;j<nums.size();j++){\\n\\t\\t\\tmina=min(mina,nums[j]);\\n\\t\\t\\tmaxa=max(maxa,nums[j]);\\n\\t\\t\\tans+=(maxa-mina);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2136554,
                "title": "java-solution-using-2-stacks",
                "content": "```\\n    public long subArrayRanges(int[] nums) {\\n        long result = 0l;\\n        Stack<Integer> maxStack = new Stack<>();\\n        Stack<Integer> minStack = new Stack<>();\\n        int n = nums.length;\\n        for (int i = 0; i <= n; i++) {\\n            while (!maxStack.isEmpty() && (i == n || nums[i] > nums[maxStack.peek()])) {\\n                int j = maxStack.pop();\\n                long count = (i - j) * (j - (maxStack.isEmpty() ? -1 : maxStack.peek()));\\n                result += count * nums[j];\\n            }\\n            maxStack.push(i);\\n            \\n            while (!minStack.isEmpty() && (i == n || nums[i] < nums[minStack.peek()])) {\\n                int j = minStack.pop();\\n                long count = (i - j) * (j - (minStack.isEmpty() ? -1 : minStack.peek()));\\n                result -= count * nums[j];\\n            }\\n            minStack.push(i);\\n        }\\n        \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public long subArrayRanges(int[] nums) {\\n        long result = 0l;\\n        Stack<Integer> maxStack = new Stack<>();\\n        Stack<Integer> minStack = new Stack<>();\\n        int n = nums.length;\\n        for (int i = 0; i <= n; i++) {\\n            while (!maxStack.isEmpty() && (i == n || nums[i] > nums[maxStack.peek()])) {\\n                int j = maxStack.pop();\\n                long count = (i - j) * (j - (maxStack.isEmpty() ? -1 : maxStack.peek()));\\n                result += count * nums[j];\\n            }\\n            maxStack.push(i);\\n            \\n            while (!minStack.isEmpty() && (i == n || nums[i] < nums[minStack.peek()])) {\\n                int j = minStack.pop();\\n                long count = (i - j) * (j - (minStack.isEmpty() ? -1 : minStack.peek()));\\n                result -= count * nums[j];\\n            }\\n            minStack.push(i);\\n        }\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2129647,
                "title": "c-monotonic-stack-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> ngr(vector<int>& nums){//decreasng stack\\n        int n = nums.size();\\n        stack<int> st;\\n        vector<int> ans(n,n);\\n        for(int i=0;i<n;i++){\\n            while(!st.empty() and  nums[st.top()] < nums[i]){\\n                ans[st.top()] = i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        for(int i=0;i<n;i++){\\n            ans[i] = (ans[i]-i);\\n        }\\n        return ans; \\n    }\\n    \\n    \\n    vector<int> ngl(vector<int>& nums){//decreasng stack\\n        int n = nums.size();\\n        stack<int> st;\\n        vector<int> ans(n,-1);\\n        for(int i=n-1;i>=0;i--){\\n            while(!st.empty() and  nums[st.top()] <= nums[i]){\\n                ans[st.top()] = i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n\\n        for(int i=n-1;i>=0;i--){\\n            ans[i] = (i-ans[i]);\\n        }\\n        return ans; \\n        \\n    }\\n    \\n    \\n    vector<int> nsr(vector<int>& nums){\\n        int n = nums.size();\\n        stack<int> st;\\n        vector<int> ans(n,n);\\n        for(int i=0;i<n;i++){\\n            while(!st.empty() and  nums[st.top()] > nums[i]){\\n                ans[st.top()] = i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        for(int i=0;i<n;i++){\\n            ans[i] = (ans[i]-i);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> nsl(vector<int>& nums){\\n        int n = nums.size();\\n        stack<int> st;\\n        vector<int> ans(n,-1);\\n        for(int i=n-1;i>=0;i--){\\n            while(!st.empty() and  nums[st.top()] >= nums[i]){\\n                ans[st.top()] = i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n\\n        for(int i=n-1;i>=0;i--){\\n            ans[i] = (i-ans[i]);\\n        }\\n        return ans;\\n    }\\n    \\n    long long subArrayRanges(vector<int>& nums) {\\n        int n = nums.size();\\n        long long sum = 0;\\n        vector<int> v1 = ngr(nums);\\n        vector<int> v2 = ngl(nums);\\n        vector<int> v3 = nsr(nums);\\n        vector<int> v4 = nsl(nums);\\n        for(int i=0;i<n;i++){\\n            long long t1 = (long long)v1[i]*v2[i]*nums[i];\\n            long long t2 = (long long)v3[i]*v4[i]*nums[i];\\n            sum+= (t1-t2);\\n        }\\n        return sum;\\n        \\n    }\\n};\\n\\n\\n/*\\nMonotonic stack\\n\\ndecreasing stack => ngr and ngl\\n\\n\\n\\nidx = 0 1 2  3 4 5 6 7\\narr = 9 2 10 8 5 7 4 1\\nans =-1 0 -1 2 3 3 5 6\\nans = 0 1  3 1 1 2 1 1\\n\\nincreasing stack -=> previous smaller and next smaller elements\\n\\n\\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> ngr(vector<int>& nums){//decreasng stack\\n        int n = nums.size();\\n        stack<int> st;\\n        vector<int> ans(n,n);\\n        for(int i=0;i<n;i++){\\n            while(!st.empty() and  nums[st.top()] < nums[i]){\\n                ans[st.top()] = i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        for(int i=0;i<n;i++){\\n            ans[i] = (ans[i]-i);\\n        }\\n        return ans; \\n    }\\n    \\n    \\n    vector<int> ngl(vector<int>& nums){//decreasng stack\\n        int n = nums.size();\\n        stack<int> st;\\n        vector<int> ans(n,-1);\\n        for(int i=n-1;i>=0;i--){\\n            while(!st.empty() and  nums[st.top()] <= nums[i]){\\n                ans[st.top()] = i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n\\n        for(int i=n-1;i>=0;i--){\\n            ans[i] = (i-ans[i]);\\n        }\\n        return ans; \\n        \\n    }\\n    \\n    \\n    vector<int> nsr(vector<int>& nums){\\n        int n = nums.size();\\n        stack<int> st;\\n        vector<int> ans(n,n);\\n        for(int i=0;i<n;i++){\\n            while(!st.empty() and  nums[st.top()] > nums[i]){\\n                ans[st.top()] = i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        for(int i=0;i<n;i++){\\n            ans[i] = (ans[i]-i);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> nsl(vector<int>& nums){\\n        int n = nums.size();\\n        stack<int> st;\\n        vector<int> ans(n,-1);\\n        for(int i=n-1;i>=0;i--){\\n            while(!st.empty() and  nums[st.top()] >= nums[i]){\\n                ans[st.top()] = i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n\\n        for(int i=n-1;i>=0;i--){\\n            ans[i] = (i-ans[i]);\\n        }\\n        return ans;\\n    }\\n    \\n    long long subArrayRanges(vector<int>& nums) {\\n        int n = nums.size();\\n        long long sum = 0;\\n        vector<int> v1 = ngr(nums);\\n        vector<int> v2 = ngl(nums);\\n        vector<int> v3 = nsr(nums);\\n        vector<int> v4 = nsl(nums);\\n        for(int i=0;i<n;i++){\\n            long long t1 = (long long)v1[i]*v2[i]*nums[i];\\n            long long t2 = (long long)v3[i]*v4[i]*nums[i];\\n            sum+= (t1-t2);\\n        }\\n        return sum;\\n        \\n    }\\n};\\n\\n\\n/*\\nMonotonic stack\\n\\ndecreasing stack => ngr and ngl\\n\\n\\n\\nidx = 0 1 2  3 4 5 6 7\\narr = 9 2 10 8 5 7 4 1\\nans =-1 0 -1 2 3 3 5 6\\nans = 0 1  3 1 1 2 1 1\\n\\nincreasing stack -=> previous smaller and next smaller elements\\n\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121270,
                "title": "python3-min-max-stack-super-easy-implementation",
                "content": "```python\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        res = 0\\n        max_stack = []\\n        min_stack = []\\n        \\n        res = 0\\n        for i, v in enumerate(nums):\\n            while max_stack and v > max_stack[-1][1]:\\n                j, u, l = max_stack.pop()\\n                r = i - j\\n                res += l * r * u\\n            \\n            if max_stack:\\n                l = i - max_stack[-1][0]\\n            else:\\n                l = i + 1\\n            max_stack.append((i, v, l))\\n        \\n            while min_stack and v < min_stack[-1][1]:\\n                j, u, l = min_stack.pop()\\n                r = i - j\\n                res -= l * r * u\\n            \\n            if min_stack:\\n                l = i - min_stack[-1][0]\\n            else:\\n                l = i + 1\\n            min_stack.append((i, v, l))\\n            \\n        while max_stack:\\n            j, v, l = max_stack.pop()\\n            r = len(nums) - j\\n            res += l * r * v\\n        while min_stack:\\n            j, v, l = min_stack.pop()\\n            r = len(nums) - j\\n            res -= l * r * v\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```python\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        res = 0\\n        max_stack = []\\n        min_stack = []\\n        \\n        res = 0\\n        for i, v in enumerate(nums):\\n            while max_stack and v > max_stack[-1][1]:\\n                j, u, l = max_stack.pop()\\n                r = i - j\\n                res += l * r * u\\n            \\n            if max_stack:\\n                l = i - max_stack[-1][0]\\n            else:\\n                l = i + 1\\n            max_stack.append((i, v, l))\\n        \\n            while min_stack and v < min_stack[-1][1]:\\n                j, u, l = min_stack.pop()\\n                r = i - j\\n                res -= l * r * u\\n            \\n            if min_stack:\\n                l = i - min_stack[-1][0]\\n            else:\\n                l = i + 1\\n            min_stack.append((i, v, l))\\n            \\n        while max_stack:\\n            j, v, l = max_stack.pop()\\n            r = len(nums) - j\\n            res += l * r * v\\n        while min_stack:\\n            j, v, l = min_stack.pop()\\n            r = len(nums) - j\\n            res -= l * r * v\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115243,
                "title": "the-best-and-only-explanation-you-need-for-the-monotonic-stack-thing",
                "content": "Before you read this, read first the beginning of the solution of @spandanx (it gets bit weird towards the middle).\\nhttps://leetcode.com/problems/sum-of-subarray-ranges/discuss/1696344/Java-or-Well-explained-with-examples-or-O(n)\\nI think, I could really describe what the max/min stacks are fore.\\n```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        \\n        Stack<Integer> maxStack = new Stack<>(); // Decreasig, Peek is Max, each value has a claim to be the max towards the right -> so it mus be decreasing\\n        Stack<Integer> minStack = new Stack<>(); // Increasing, Peek is Min, each value has a claim to be the min towards the right -> so it mus be increasing\\n        \\n        long totalMaxSum = 0;\\n        long totalMinSum = 0;\\n        int n = nums.length;\\n\\n        long sum = 0;\\n        long maxSum = 0;\\n        long minSum = 0;\\n        for(int i = 0; i <= n; i++){\\n            // The values in the increasing stack are claiming -> \"We have MAXIMABILITY potential\"\\n                // Unless the next value which is coming is larger, I can be the MAXIMUM for the rest of the stack (to the right)\\n                // If a value is coming, which is larger than me, I cannot be the maximum towards the right\\n                    // Calculate, how many times I can be the maximum (to the left)\\n                        // This is till the previous index of it!\\n            // Method will be called -> push_to_max stack -> \\n                // we return the possible number of occurrences, where the existing values can be max\\n            maxSum += pushToMaxStack(maxStack, nums, i);\\n        }\\n        \\n        for(int i = 0; i <= n; i++){\\n            // The values in the decreasing stack are claiming -> \"We have MINIMABILITY potential\"\\n                // Unless the next value which is coming is smaller, I can be the MINIMUM for the rest of the stack (to the right)\\n                // If a value is coming, which is smaller than me, I cannot be the minumum towards the right\\n                    // Calculate, how many times I can be the minimum (to the left)\\n                        // This is till the previous index of it!\\n            // Method will be called -> push_to_min stack\\n                // we return the possible number of occurrences, where the existing values can be min\\n            //middleSum -= pushToMinStack(minStack, nums, i);       \\n            minSum += pushToMinStack(minStack, nums, i);\\n        }\\n        sum = maxSum - minSum;        \\n        return sum;\\n    }\\n    \\n    long pushToMaxStack(Stack<Integer> maxStack, int[] nums, int i){\\n        long maxSum = 0;\\n        while(!maxStack.isEmpty() && (i==nums.length || nums[maxStack.peek()] < nums[i])){\\n            int popped_i = maxStack.pop();\\n            int prev_i = maxStack.isEmpty() ? -1 : maxStack.peek();\\n            maxSum += (long)((i - popped_i) * (popped_i -prev_i) * (long)nums[popped_i]);\\n        }\\n        maxStack.push(i);\\n        return maxSum;\\n    }\\n    \\n    long pushToMinStack(Stack<Integer> minStack, int[] nums, int i){\\n        long minSum = 0;\\n        while(!minStack.isEmpty() && (i==nums.length || nums[minStack.peek()] > nums[i])){\\n            int popped_i = minStack.pop();\\n            int prev_i = minStack.isEmpty() ? -1 : minStack.peek();\\n            minSum += (long)((i - popped_i) * (popped_i -prev_i) * (long)nums[popped_i]);\\n        }\\n        minStack.push(i);\\n        return minSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        \\n        Stack<Integer> maxStack = new Stack<>(); // Decreasig, Peek is Max, each value has a claim to be the max towards the right -> so it mus be decreasing\\n        Stack<Integer> minStack = new Stack<>(); // Increasing, Peek is Min, each value has a claim to be the min towards the right -> so it mus be increasing\\n        \\n        long totalMaxSum = 0;\\n        long totalMinSum = 0;\\n        int n = nums.length;\\n\\n        long sum = 0;\\n        long maxSum = 0;\\n        long minSum = 0;\\n        for(int i = 0; i <= n; i++){\\n            // The values in the increasing stack are claiming -> \"We have MAXIMABILITY potential\"\\n                // Unless the next value which is coming is larger, I can be the MAXIMUM for the rest of the stack (to the right)\\n                // If a value is coming, which is larger than me, I cannot be the maximum towards the right\\n                    // Calculate, how many times I can be the maximum (to the left)\\n                        // This is till the previous index of it!\\n            // Method will be called -> push_to_max stack -> \\n                // we return the possible number of occurrences, where the existing values can be max\\n            maxSum += pushToMaxStack(maxStack, nums, i);\\n        }\\n        \\n        for(int i = 0; i <= n; i++){\\n            // The values in the decreasing stack are claiming -> \"We have MINIMABILITY potential\"\\n                // Unless the next value which is coming is smaller, I can be the MINIMUM for the rest of the stack (to the right)\\n                // If a value is coming, which is smaller than me, I cannot be the minumum towards the right\\n                    // Calculate, how many times I can be the minimum (to the left)\\n                        // This is till the previous index of it!\\n            // Method will be called -> push_to_min stack\\n                // we return the possible number of occurrences, where the existing values can be min\\n            //middleSum -= pushToMinStack(minStack, nums, i);       \\n            minSum += pushToMinStack(minStack, nums, i);\\n        }\\n        sum = maxSum - minSum;        \\n        return sum;\\n    }\\n    \\n    long pushToMaxStack(Stack<Integer> maxStack, int[] nums, int i){\\n        long maxSum = 0;\\n        while(!maxStack.isEmpty() && (i==nums.length || nums[maxStack.peek()] < nums[i])){\\n            int popped_i = maxStack.pop();\\n            int prev_i = maxStack.isEmpty() ? -1 : maxStack.peek();\\n            maxSum += (long)((i - popped_i) * (popped_i -prev_i) * (long)nums[popped_i]);\\n        }\\n        maxStack.push(i);\\n        return maxSum;\\n    }\\n    \\n    long pushToMinStack(Stack<Integer> minStack, int[] nums, int i){\\n        long minSum = 0;\\n        while(!minStack.isEmpty() && (i==nums.length || nums[minStack.peek()] > nums[i])){\\n            int popped_i = minStack.pop();\\n            int prev_i = minStack.isEmpty() ? -1 : minStack.peek();\\n            minSum += (long)((i - popped_i) * (popped_i -prev_i) * (long)nums[popped_i]);\\n        }\\n        minStack.push(i);\\n        return minSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085009,
                "title": "c-short-solution",
                "content": "This should be in easy category. Unless there is a smarter way to beat n\\\\*n double loop and get to the result faster. I didn\\'t see one.\\n\\n```\\n  long long subArrayRanges(vector<int>& nums) {\\n    long long ret = 0;\\n    int ct = nums.size();\\n    for (int i=0; i<ct; ++i) {\\n      int maxVal = nums[i];\\n      int minVal = nums[i];\\n      for (int j=i+1; j<ct; ++j) {\\n        maxVal = max(maxVal, nums[j]);\\n        minVal = min(minVal, nums[j]);\\n        ret += maxVal;\\n        ret -= minVal;\\n      }\\n    }\\n    return ret;\\n  }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  long long subArrayRanges(vector<int>& nums) {\\n    long long ret = 0;\\n    int ct = nums.size();\\n    for (int i=0; i<ct; ++i) {\\n      int maxVal = nums[i];\\n      int minVal = nums[i];\\n      for (int j=i+1; j<ct; ++j) {\\n        maxVal = max(maxVal, nums[j]);\\n        minVal = min(minVal, nums[j]);\\n        ret += maxVal;\\n        ret -= minVal;\\n      }\\n    }\\n    return ret;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2065515,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++)\\n           sum+=calc(nums,i);\\n        \\n        return sum;\\n    }\\n    \\n    private long calc(int[] nums,int start)\\n    {\\n        long sum=0;\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            if(nums[i]>max)\\n                max=nums[i];\\n            if(nums[i]<min)\\n                min=nums[i];\\n            sum+=max-min;\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long subArrayRanges(int[] nums) {\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++)\\n           sum+=calc(nums,i);\\n        \\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2055254,
                "title": "min-max-stack-explanations-python",
                "content": "1.brute force recursion\\n```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        # brute force \\n        res = 0\\n        for i in range(len(nums)):\\n            res += self.search(nums[i:])\\n        return res\\n    \\n    def search(self, nums):\\n        sum_range = 0\\n        min_value = nums[0]\\n        max_value = nums[0]\\n        for i in range(1,len(nums)):\\n            if nums[i] > max_value:\\n                max_value = nums[i]\\n            elif nums[i] < min_value:\\n                min_value = nums[i]\\n            sum_range += (max_value - min_value)\\n        return sum_range\\n```\\n2.min and max stack\\n```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        #We can set two stack, one for min_value other for max_value \\n        min_stack , max_stack = [], []\\n        res = 0\\n        n = len(nums)\\n        # <n+1) here make sure we can calculate the number of subarray that the largest or smallest element is the last number\\n        # because for each current element we would compare to previous one, and find how many subarrary that the largest or \\n        # smallest element is previous one\\n        for i in range(n+1):\\n            # min_stack\\n            while min_stack and (i == n or nums[i]< nums[min_stack[-1]]):\\n                prev_min_index = min_stack.pop()\\n                #[*,3,*,*] =[2*3] = 6 which include [*,3] [3] [*,3,*] [*,3,*,*] [3,*] [3,*,*]\\n                left_length = prev_min_index - min_stack[-1] if min_stack else prev_min_index + 1\\n                right_length = i - prev_min_index\\n                res -= nums[prev_min_index]*left_length*right_length\\n            # min_stack append the current index\\n            min_stack.append(i)\\n            while max_stack and (i == n or nums[i] > nums[max_stack[-1]]):\\n                prev_max_index = max_stack.pop()\\n                left_length = prev_max_index - max_stack[-1] if max_stack else prev_max_index + 1\\n                right_length = i - prev_max_index\\n                res += nums[prev_max_index]*left_length*right_length\\n            # min_stack append the current index\\n            max_stack.append(i)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        # brute force \\n        res = 0\\n        for i in range(len(nums)):\\n            res += self.search(nums[i:])\\n        return res\\n    \\n    def search(self, nums):\\n        sum_range = 0\\n        min_value = nums[0]\\n        max_value = nums[0]\\n        for i in range(1,len(nums)):\\n            if nums[i] > max_value:\\n                max_value = nums[i]\\n            elif nums[i] < min_value:\\n                min_value = nums[i]\\n            sum_range += (max_value - min_value)\\n        return sum_range\\n```\n```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        #We can set two stack, one for min_value other for max_value \\n        min_stack , max_stack = [], []\\n        res = 0\\n        n = len(nums)\\n        # <n+1) here make sure we can calculate the number of subarray that the largest or smallest element is the last number\\n        # because for each current element we would compare to previous one, and find how many subarrary that the largest or \\n        # smallest element is previous one\\n        for i in range(n+1):\\n            # min_stack\\n            while min_stack and (i == n or nums[i]< nums[min_stack[-1]]):\\n                prev_min_index = min_stack.pop()\\n                #[*,3,*,*] =[2*3] = 6 which include [*,3] [3] [*,3,*] [*,3,*,*] [3,*] [3,*,*]\\n                left_length = prev_min_index - min_stack[-1] if min_stack else prev_min_index + 1\\n                right_length = i - prev_min_index\\n                res -= nums[prev_min_index]*left_length*right_length\\n            # min_stack append the current index\\n            min_stack.append(i)\\n            while max_stack and (i == n or nums[i] > nums[max_stack[-1]]):\\n                prev_max_index = max_stack.pop()\\n                left_length = prev_max_index - max_stack[-1] if max_stack else prev_max_index + 1\\n                right_length = i - prev_max_index\\n                res += nums[prev_max_index]*left_length*right_length\\n            # min_stack append the current index\\n            max_stack.append(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027136,
                "title": "python-monotonic-stack-solution",
                "content": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        arr = nums\\n        n = len(arr)\\n        \\n        left = [-1 for _ in range(n)]\\n        right = [n for _ in range(n)]\\n        \\n        stack = list()\\n        for i in range(n):\\n            while stack and arr[stack[-1]] > arr[i]:\\n                stack.pop()\\n            if stack:\\n                left[i] = stack[-1]\\n            stack.append(i)\\n\\n        stack = list()\\n        for i in range(n-1,-1,-1):\\n            while stack and arr[stack[-1]] >= arr[i]:\\n                stack.pop()\\n            if stack:\\n                right[i] = stack[-1]\\n            stack.append(i)\\n                        \\n        res = 0\\n        for i in range(n):\\n            res -= (i-left[i])*(right[i]-i)*arr[i]\\n            \\n        left = [-1 for _ in range(n)]\\n        right = [n for _ in range(n)]\\n        \\n        stack = list()\\n        for i in range(n):\\n            while stack and arr[stack[-1]] <= arr[i]:\\n                stack.pop()\\n            if stack:\\n                left[i] = stack[-1]\\n            stack.append(i)\\n\\n        stack = list()\\n        for i in range(n-1,-1,-1):\\n            while stack and arr[stack[-1]] < arr[i]:\\n                stack.pop()\\n            if stack:\\n                right[i] = stack[-1]\\n            stack.append(i)\\n                        \\n        for i in range(n):\\n            res += (i-left[i])*(right[i]-i)*arr[i]\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        arr = nums\\n        n = len(arr)\\n        \\n        left = [-1 for _ in range(n)]\\n        right = [n for _ in range(n)]\\n        \\n        stack = list()\\n        for i in range(n):\\n            while stack and arr[stack[-1]] > arr[i]:\\n                stack.pop()\\n            if stack:\\n                left[i] = stack[-1]\\n            stack.append(i)\\n\\n        stack = list()\\n        for i in range(n-1,-1,-1):\\n            while stack and arr[stack[-1]] >= arr[i]:\\n                stack.pop()\\n            if stack:\\n                right[i] = stack[-1]\\n            stack.append(i)\\n                        \\n        res = 0\\n        for i in range(n):\\n            res -= (i-left[i])*(right[i]-i)*arr[i]\\n            \\n        left = [-1 for _ in range(n)]\\n        right = [n for _ in range(n)]\\n        \\n        stack = list()\\n        for i in range(n):\\n            while stack and arr[stack[-1]] <= arr[i]:\\n                stack.pop()\\n            if stack:\\n                left[i] = stack[-1]\\n            stack.append(i)\\n\\n        stack = list()\\n        for i in range(n-1,-1,-1):\\n            while stack and arr[stack[-1]] < arr[i]:\\n                stack.pop()\\n            if stack:\\n                right[i] = stack[-1]\\n            stack.append(i)\\n                        \\n        for i in range(n):\\n            res += (i-left[i])*(right[i]-i)*arr[i]\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979772,
                "title": "swift-o-n-stack-solution",
                "content": "```\\nclass Solution {\\n\\n    // O(n^2)\\n    func subArrayRanges(_ nums: [Int]) -> Int {\\n        var res = 0\\n        for i in 0..<nums.count {\\n            var maxVal = nums[i]\\n            var minVal = nums[i]\\n            for j in i..<nums.count {\\n                maxVal = max(maxVal, nums[j])\\n                minVal = min(minVal, nums[j])\\n                res += maxVal - minVal\\n            }\\n        }\\n        return res\\n    }\\n    \\n    // O(n)\\n    func subArrayRanges(_ nums: [Int]) -> Int {\\n        var res = 0\\n        let n = nums.count\\n        var j = 0\\n        var k = 0\\n        \\n        var stack = [Int]()\\n        for i in 0...n {\\n            while !stack.isEmpty && nums[stack.first!] > (i == n ? Int.min : nums[i]) {\\n                j = stack.removeFirst()\\n                k = stack.first ?? -1\\n                res -= nums[j] * (i - j) * (j - k)\\n            }\\n            stack.insert(i, at: 0)\\n        }\\n        \\n        stack.removeAll()\\n        for i in 0...n {\\n            while !stack.isEmpty && nums[stack.first!] < (i == n ? Int.max : nums[i]) {\\n                j = stack.removeFirst()\\n                k = stack.first ?? -1\\n                res += nums[j] * (i - j) * (j - k)\\n            }\\n            stack.insert(i, at: 0)\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n\\n    // O(n^2)\\n    func subArrayRanges(_ nums: [Int]) -> Int {\\n        var res = 0\\n        for i in 0..<nums.count {\\n            var maxVal = nums[i]\\n            var minVal = nums[i]\\n            for j in i..<nums.count {\\n                maxVal = max(maxVal, nums[j])\\n                minVal = min(minVal, nums[j])\\n                res += maxVal - minVal\\n            }\\n        }\\n        return res\\n    }\\n    \\n    // O(n)\\n    func subArrayRanges(_ nums: [Int]) -> Int {\\n        var res = 0\\n        let n = nums.count\\n        var j = 0\\n        var k = 0\\n        \\n        var stack = [Int]()\\n        for i in 0...n {\\n            while !stack.isEmpty && nums[stack.first!] > (i == n ? Int.min : nums[i]) {\\n                j = stack.removeFirst()\\n                k = stack.first ?? -1\\n                res -= nums[j] * (i - j) * (j - k)\\n            }\\n            stack.insert(i, at: 0)\\n        }\\n        \\n        stack.removeAll()\\n        for i in 0...n {\\n            while !stack.isEmpty && nums[stack.first!] < (i == n ? Int.max : nums[i]) {\\n                j = stack.removeFirst()\\n                k = stack.first ?? -1\\n                res += nums[j] * (i - j) * (j - k)\\n            }\\n            stack.insert(i, at: 0)\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974135,
                "title": "c-o-n-monotonic-stack",
                "content": "The concept is the same as the one used in [907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/)\\n```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        stack<pair<int, int>> st;\\n        int n = nums.size();\\n        \\n        // for min \\n        vector<int> minLeft(n, 0);\\n        vector<int> minRight(n, 0);\\n        for (int i = 0; i < nums.size(); i++) {\\n            int len = 1;\\n            while (!st.empty() && st.top().first > nums[i]) {\\n                len += st.top().second;\\n                st.pop();\\n            }\\n            minLeft[i] = len;\\n            st.push(make_pair(nums[i], len));\\n        }\\n        while (!st.empty()) st.pop();\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            int len = 1;\\n            while (!st.empty() && st.top().first >= nums[i]) {\\n                len += st.top().second;\\n                st.pop();\\n            }\\n            minRight[i] = len;\\n            st.push(make_pair(nums[i], len));\\n        }\\n        \\n        while (!st.empty()) st.pop();\\n        \\n        // for max \\n        vector<int> maxLeft(n, 0);\\n        vector<int> maxRight(n, 0);\\n        for (int i = 0; i < nums.size(); i++) {\\n            int len = 1;\\n            while (!st.empty() && st.top().first < nums[i]) {\\n                len += st.top().second;\\n                st.pop();\\n            }\\n            maxLeft[i] = len;\\n            st.push(make_pair(nums[i], len));\\n        }\\n        \\n        while (!st.empty()) st.pop();\\n        for (int i = n - 1; i >= 0; i--) {\\n            int len = 1;\\n            while (!st.empty() && st.top().first <= nums[i]) {\\n                len += st.top().second;\\n                st.pop();\\n            }\\n            maxRight[i] = len;\\n            st.push(make_pair(nums[i], len));\\n        }\\n        \\n        long long ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            ans += ((long long)maxLeft[i] * maxRight[i] - minLeft[i] * minRight[i]) *  (long long)nums[i] ;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        stack<pair<int, int>> st;\\n        int n = nums.size();\\n        \\n        // for min \\n        vector<int> minLeft(n, 0);\\n        vector<int> minRight(n, 0);\\n        for (int i = 0; i < nums.size(); i++) {\\n            int len = 1;\\n            while (!st.empty() && st.top().first > nums[i]) {\\n                len += st.top().second;\\n                st.pop();\\n            }\\n            minLeft[i] = len;\\n            st.push(make_pair(nums[i], len));\\n        }\\n        while (!st.empty()) st.pop();\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            int len = 1;\\n            while (!st.empty() && st.top().first >= nums[i]) {\\n                len += st.top().second;\\n                st.pop();\\n            }\\n            minRight[i] = len;\\n            st.push(make_pair(nums[i], len));\\n        }\\n        \\n        while (!st.empty()) st.pop();\\n        \\n        // for max \\n        vector<int> maxLeft(n, 0);\\n        vector<int> maxRight(n, 0);\\n        for (int i = 0; i < nums.size(); i++) {\\n            int len = 1;\\n            while (!st.empty() && st.top().first < nums[i]) {\\n                len += st.top().second;\\n                st.pop();\\n            }\\n            maxLeft[i] = len;\\n            st.push(make_pair(nums[i], len));\\n        }\\n        \\n        while (!st.empty()) st.pop();\\n        for (int i = n - 1; i >= 0; i--) {\\n            int len = 1;\\n            while (!st.empty() && st.top().first <= nums[i]) {\\n                len += st.top().second;\\n                st.pop();\\n            }\\n            maxRight[i] = len;\\n            st.push(make_pair(nums[i], len));\\n        }\\n        \\n        long long ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            ans += ((long long)maxLeft[i] * maxRight[i] - minLeft[i] * minRight[i]) *  (long long)nums[i] ;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967905,
                "title": "java-solution",
                "content": "We can avoid calculating the sum between the max and min for each subarray by instead taking the difference of the **sum of subarray maximums** and **[sum of subarray minimums](https://leetcode.com/problems/sum-of-subarray-minimums/)**.\\n```\\nclass Solution {\\n  public long subArrayRanges(int[] nums) {\\n    Deque<Integer> stack = new ArrayDeque<>();\\n    long res = 0;\\n    long[] dp = new long[nums.length];\\n    for (int i = 0; i < nums.length; i++) {\\n      while (!stack.isEmpty() && nums[stack.getLast()] > nums[i])\\n        stack.removeLast(); // non-decreasing\\n      int j = stack.isEmpty() ? -1 : stack.getLast();\\n      long lastElementMinSum = j < 0 ? 0 : dp[j];\\n      dp[i] = lastElementMinSum + (long) (i - j) * nums[i];\\n      res -= dp[i]; // minimum\\n      stack.addLast(i);\\n    }\\n\\n    stack.clear();\\n    dp = new long[nums.length];\\n    for (int i = 0; i < nums.length; i++) {\\n      while (!stack.isEmpty() && nums[stack.getLast()] < nums[i])\\n        stack.removeLast(); // non-increasing\\n      int j = stack.isEmpty() ? -1 : stack.getLast();\\n      long lastElementMaxSum = j < 0 ? 0 : dp[j];\\n      dp[i] = lastElementMaxSum + (long) (i - j) * nums[i];\\n      res += dp[i]; // maximum\\n      stack.addLast(i);\\n    }\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public long subArrayRanges(int[] nums) {\\n    Deque<Integer> stack = new ArrayDeque<>();\\n    long res = 0;\\n    long[] dp = new long[nums.length];\\n    for (int i = 0; i < nums.length; i++) {\\n      while (!stack.isEmpty() && nums[stack.getLast()] > nums[i])\\n        stack.removeLast(); // non-decreasing\\n      int j = stack.isEmpty() ? -1 : stack.getLast();\\n      long lastElementMinSum = j < 0 ? 0 : dp[j];\\n      dp[i] = lastElementMinSum + (long) (i - j) * nums[i];\\n      res -= dp[i]; // minimum\\n      stack.addLast(i);\\n    }\\n\\n    stack.clear();\\n    dp = new long[nums.length];\\n    for (int i = 0; i < nums.length; i++) {\\n      while (!stack.isEmpty() && nums[stack.getLast()] < nums[i])\\n        stack.removeLast(); // non-increasing\\n      int j = stack.isEmpty() ? -1 : stack.getLast();\\n      long lastElementMaxSum = j < 0 ? 0 : dp[j];\\n      dp[i] = lastElementMaxSum + (long) (i - j) * nums[i];\\n      res += dp[i]; // maximum\\n      stack.addLast(i);\\n    }\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955804,
                "title": "c-easy-solution-using-stack-95-faster-reverse-lookup",
                "content": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        int n=nums.size();\\n        stack<int> stk1,stk2;\\n        vector<int> nse(n),pse(n),nge(n),pge(n);\\n        stk1.push(0);\\n        stk2.push(0);\\n        for(int i=1;i<n;i++){\\n            while(!stk1.empty() && nums[i]<nums[stk1.top()]){\\n                nse[stk1.top()]=i;\\n                stk1.pop();\\n            }\\n            while(!stk2.empty() && nums[i]>nums[stk2.top()]){\\n                nge[stk2.top()]=i;\\n                stk2.pop();\\n            }\\n            stk1.push(i);\\n            stk2.push(i);\\n        }\\n        while(!stk1.empty())\\n        {\\n            nse[stk1.top()]=n;\\n            stk1.pop();\\n        }\\n        while(!stk2.empty())\\n        {\\n            nge[stk2.top()]=n;\\n            stk2.pop();\\n        }\\n        stk1.push(n-1);\\n        stk2.push(n-1);\\n        for(int i=n-2;i>=0;i--){\\n             while(!stk1.empty() && nums[i]<=nums[stk1.top()]){\\n                pse[stk1.top()]=i;\\n                stk1.pop();\\n            }\\n            while(!stk2.empty() && nums[i]>=nums[stk2.top()]){\\n                pge[stk2.top()]=i;\\n                stk2.pop();\\n            }\\n            stk1.push(i);\\n            stk2.push(i);\\n        }\\n         while(!stk1.empty())\\n            {\\n                pse[stk1.top()]=-1;\\n                stk1.pop();\\n            }\\n            while(!stk2.empty())\\n            {\\n                pge[stk2.top()]=-1;\\n                stk2.pop();\\n            }\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            long long x1=(long long)((nge[i]-i) * (i-pge[i]))*nums[i];\\n            long long x2=(long long)((nse[i]-i) * (i-pse[i]))*nums[i];\\n            ans+=(x1-x2);\\n        }\\n      return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        int n=nums.size();\\n        stack<int> stk1,stk2;\\n        vector<int> nse(n),pse(n),nge(n),pge(n);\\n        stk1.push(0);\\n        stk2.push(0);\\n        for(int i=1;i<n;i++){\\n            while(!stk1.empty() && nums[i]<nums[stk1.top()]){\\n                nse[stk1.top()]=i;\\n                stk1.pop();\\n            }\\n            while(!stk2.empty() && nums[i]>nums[stk2.top()]){\\n                nge[stk2.top()]=i;\\n                stk2.pop();\\n            }\\n            stk1.push(i);\\n            stk2.push(i);\\n        }\\n        while(!stk1.empty())\\n        {\\n            nse[stk1.top()]=n;\\n            stk1.pop();\\n        }\\n        while(!stk2.empty())\\n        {\\n            nge[stk2.top()]=n;\\n            stk2.pop();\\n        }\\n        stk1.push(n-1);\\n        stk2.push(n-1);\\n        for(int i=n-2;i>=0;i--){\\n             while(!stk1.empty() && nums[i]<=nums[stk1.top()]){\\n                pse[stk1.top()]=i;\\n                stk1.pop();\\n            }\\n            while(!stk2.empty() && nums[i]>=nums[stk2.top()]){\\n                pge[stk2.top()]=i;\\n                stk2.pop();\\n            }\\n            stk1.push(i);\\n            stk2.push(i);\\n        }\\n         while(!stk1.empty())\\n            {\\n                pse[stk1.top()]=-1;\\n                stk1.pop();\\n            }\\n            while(!stk2.empty())\\n            {\\n                pge[stk2.top()]=-1;\\n                stk2.pop();\\n            }\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            long long x1=(long long)((nge[i]-i) * (i-pge[i]))*nums[i];\\n            long long x2=(long long)((nse[i]-i) * (i-pse[i]))*nums[i];\\n            ans+=(x1-x2);\\n        }\\n      return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937423,
                "title": "c-o-n-with-monotonic-stack",
                "content": "```\\ntemplate<typename Comp>\\nlong long minmaxstack(vector<int>const & nums, Comp comp = Comp{})\\n{\\n    vector<int> mystack;\\n    long long res = 0;\\n    auto calculate = [&](int currentIndex){\\n        // pop and calculate the contribution\\n        long long len = mystack.size() >= 2 ? (mystack.back()-mystack[mystack.size()-2]) : (mystack.back()+1);\\n        res+=(len* (currentIndex-mystack.back())) *nums[mystack.back()];\\n        mystack.pop_back();\\n    };\\n    for (int i = 0; i < nums.size(); ++i)\\n    {\\n        while (!mystack.empty() && comp(nums[mystack.back()], nums[i]))\\n        {\\n            calculate(i); \\n        } \\n        mystack.push_back(i);\\n    }\\n    while (!mystack.empty())\\n    {\\n        calculate(nums.size());\\n    }\\n    return res;\\n}\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        return minmaxstack<std::less<int>>(nums) - minmaxstack<std::greater<int>>(nums);\\n    }\\n};\\n```\\n\\n**ans =sum_of(max_element_of_all_subarrays)-sum_of(min_element_of_all_subarrays)**\\nSuppose we have an array **3, 1, 6, 5, 4** and we want to find max_element for each subarray. \\nFrom left to right, everytime the current index sees a larger number, the last maximum number is no longer the largest after the current index. \\n3, (1)  ==> 3, 1\\n3, 1, (6) ==> 6   (popping 1, and 3)\\n6, (5) ==> 6, 5\\n6, 5, (4) ==> 6, 5, 4  \\n(popping 4, 5, 6 at last)\\n\\nIf we make sure that our stack **Monotone Decreasing**,  we can easily find how many possible ways the last maximum number serves as the largest element:\\nTake 3, 1, (6) as an example:\\n3 -> previous largest number\\n1 -> largest number since 3 \\n6 -> current number, greater than 1\\n\\n1 is the largest number between 3 -> 1 and 1 -> 6, there are (indexOf(1) - indexOf(3)) * ((indexOf(6) - indexOf(1)) possible subarrays in between them.\\nSo \"1\" contributes  1 * (1-0) * (2-1) = 1 to the **sum_of(max_element_of_all_subarrays).**\\nIn sequence, 6 is still greater than 3:\\n \"3\" contributes  3 * (0-(-1) * (2-0) = 6 to the **sum_of(max_element_of_all_subarrays).**\\n\\nWhenever an element gets popped out, we can calculate how much it contributes to the **sum_of(max_element_of_all_subarrays).**\\n\\nSame idea goes to finding the minimum element of subarrays by flipping the Monotone Decreasing stack to Monotone Increasing.\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```\\ntemplate<typename Comp>\\nlong long minmaxstack(vector<int>const & nums, Comp comp = Comp{})\\n{\\n    vector<int> mystack;\\n    long long res = 0;\\n    auto calculate = [&](int currentIndex){\\n        // pop and calculate the contribution\\n        long long len = mystack.size() >= 2 ? (mystack.back()-mystack[mystack.size()-2]) : (mystack.back()+1);\\n        res+=(len* (currentIndex-mystack.back())) *nums[mystack.back()];\\n        mystack.pop_back();\\n    };\\n    for (int i = 0; i < nums.size(); ++i)\\n    {\\n        while (!mystack.empty() && comp(nums[mystack.back()], nums[i]))\\n        {\\n            calculate(i); \\n        } \\n        mystack.push_back(i);\\n    }\\n    while (!mystack.empty())\\n    {\\n        calculate(nums.size());\\n    }\\n    return res;\\n}\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        return minmaxstack<std::less<int>>(nums) - minmaxstack<std::greater<int>>(nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1917612,
                "title": "simple-c-brute-force-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        long long ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int maxi = nums[i], mini = nums[i];\\n            for (int j = i - 1; j >= 0; j--) {\\n                maxi = max(maxi, nums[j]);\\n                mini = min(mini, nums[j]);\\n                ans += (maxi - mini);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        long long ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int maxi = nums[i], mini = nums[i];\\n            for (int j = i - 1; j >= 0; j--) {\\n                maxi = max(maxi, nums[j]);\\n                mini = min(mini, nums[j]);\\n                ans += (maxi - mini);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911895,
                "title": "simple-clean-solution",
                "content": "Logic: Find the minimum and maximum of sub-array incrementally.\\n\\n\\t\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\n\\t\\t\\t\\tlong long subArrayRanges(vector<int>& nums) {\\n\\t\\t\\t\\tlong long sum =0;\\n\\t\\t\\t\\tint start=0;\\n\\t\\t\\t\\tint end=nums.size()-1;\\n\\n\\t\\t\\t\\twhile(start<end)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint minElmnt=nums[start];\\n\\t\\t\\t\\t\\tint maxElmnt=nums[start];\\n\\t\\t\\t\\t\\tfor(int i=start+1;i<nums.size();i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tminElmnt=min(minElmnt,nums[i]);\\n\\t\\t\\t\\t\\t\\tmaxElmnt=max(maxElmnt,nums[i]);\\n\\t\\t\\t\\t\\t\\tsum=sum+(maxElmnt-minElmnt);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tstart++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn sum;\\n\\t\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic:\\n\\n\\t\\t\\t\\tlong long subArrayRanges(vector<int>& nums) {\\n\\t\\t\\t\\tlong long sum =0;\\n\\t\\t\\t\\tint start=0;\\n\\t\\t\\t\\tint end=nums.size()-1;\\n\\n\\t\\t\\t\\twhile(start<end)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint minElmnt=nums[start];\\n\\t\\t\\t\\t\\tint maxElmnt=nums[start];\\n\\t\\t\\t\\t\\tfor(int i=start+1;i<nums.size();i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tminElmnt=min(minElmnt,nums[i]);\\n\\t\\t\\t\\t\\t\\tmaxElmnt=max(maxElmnt,nums[i]);\\n\\t\\t\\t\\t\\t\\tsum=sum+(maxElmnt-minElmnt);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1908223,
                "title": "java-two-heaps-priorityqueue-min-and-max",
                "content": "```\\n    public long subArrayRanges(int[] nums) {\\n        long total = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            PriorityQueue<Integer> min = new PriorityQueue<>();\\n            PriorityQueue<Integer> max = new PriorityQueue<>((a, b) -> b - a);\\n            for (int j = i; j < nums.length; j++) {\\n                min.add(nums[j]);\\n                max.add(nums[j]);\\n                total += (max.peek() - min.peek());\\n            }\\n        }\\n        return total;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public long subArrayRanges(int[] nums) {\\n        long total = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            PriorityQueue<Integer> min = new PriorityQueue<>();\\n            PriorityQueue<Integer> max = new PriorityQueue<>((a, b) -> b - a);\\n            for (int j = i; j < nums.length; j++) {\\n                min.add(nums[j]);\\n                max.add(nums[j]);\\n                total += (max.peek() - min.peek());\\n            }\\n        }\\n        return total;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1904622,
                "title": "clean-python-o-n-mono-increasing-and-decreasing-stack-detailed-comments",
                "content": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        \\n        # Find subarray min sum\\n        st = [(-1,float(\\'-inf\\'),0)] # (index,num,cur_ans)\\n        min_sum = 0\\n        for i,num in enumerate(nums):\\n            # Maintain a monotonically increasing stack\\n            while st[-1][1] >= num:\\n                st.pop()\\n            # Current element is the minimum from i till prev element index.\\n            # Before that we have already calculated the answer\\n            # cur_ans = prev_ans + multiply current num (i-j) times where j is prev element index\\n            cur_ans = st[-1][2] + (i-st[-1][0])*num\\n            min_sum+=cur_ans\\n            st.append((i,num,cur_ans))\\n            \\n        # Find subarray max sum\\n        st.clear()\\n        st.append((-1,float(\\'inf\\'),0)) # (index,num,cur_ans)\\n        max_sum = 0\\n        for i,num in enumerate(nums):\\n            # Maintain a monotonically decreasing stack\\n            while st[-1][1] <= num:\\n                st.pop()\\n            # Current element is the maximum from i till prev element index\\n            # Before that we have alread calculated the answer\\n            # cur_ans = prev_ans + multiple current num (i-j) times where j is prev element index\\n            cur_ans = st[-1][2] + (i-st[-1][0])*num\\n            max_sum+=cur_ans\\n            st.append((i,num,cur_ans))\\n            \\n        # Return difference\\n        return max_sum - min_sum",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        \\n        # Find subarray min sum\\n        st = [(-1,float(\\'-inf\\'),0)] # (index,num,cur_ans)\\n        min_sum = 0\\n        for i,num in enumerate(nums):\\n            # Maintain a monotonically increasing stack\\n            while st[-1][1] >= num:\\n                st.pop()\\n            # Current element is the minimum from i till prev element index.\\n            # Before that we have already calculated the answer\\n            # cur_ans = prev_ans + multiply current num (i-j) times where j is prev element index\\n            cur_ans = st[-1][2] + (i-st[-1][0])*num\\n            min_sum+=cur_ans\\n            st.append((i,num,cur_ans))\\n            \\n        # Find subarray max sum\\n        st.clear()\\n        st.append((-1,float(\\'inf\\'),0)) # (index,num,cur_ans)\\n        max_sum = 0\\n        for i,num in enumerate(nums):\\n            # Maintain a monotonically decreasing stack\\n            while st[-1][1] <= num:\\n                st.pop()\\n            # Current element is the maximum from i till prev element index\\n            # Before that we have alread calculated the answer\\n            # cur_ans = prev_ans + multiple current num (i-j) times where j is prev element index\\n            cur_ans = st[-1][2] + (i-st[-1][0])*num\\n            max_sum+=cur_ans\\n            st.append((i,num,cur_ans))\\n            \\n        # Return difference\\n        return max_sum - min_sum",
                "codeTag": "Java"
            },
            {
                "id": 1891629,
                "title": "c-brute-force-o-n-2-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        long int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int mini,maxi;\\n            mini=maxi=nums[i];\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                mini=min(mini,nums[j]);\\n                maxi=max(maxi,nums[j]);\\n                ans=ans+maxi-mini;\\n            }\\n        }\\n        return ans;\\n    }\\n};****\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        long int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int mini,maxi;\\n            mini=maxi=nums[i];\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                mini=min(mini,nums[j]);\\n                maxi=max(maxi,nums[j]);\\n                ans=ans+maxi-mini;\\n            }\\n        }\\n        return ans;\\n    }\\n};****\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880908,
                "title": "javascipt-n-2",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar subArrayRanges = function(nums) {\\n    let sum = 0\\n    for (let i = 0; i < nums.length; i++){\\n        let smallest = Math.min(nums[i]);\\n        let largest = Math.max(nums[i]);\\n        for (let j = i; j < nums.length; j++){\\n            \\n            smallest = Math.min(nums[j], smallest);\\n            largest = Math.max(nums[j], largest);\\n            \\n            \\n            sum += (largest - smallest)\\n        }\\n    }\\n    return sum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar subArrayRanges = function(nums) {\\n    let sum = 0\\n    for (let i = 0; i < nums.length; i++){\\n        let smallest = Math.min(nums[i]);\\n        let largest = Math.max(nums[i]);\\n        for (let j = i; j < nums.length; j++){\\n            \\n            smallest = Math.min(nums[j], smallest);\\n            largest = Math.max(nums[j], largest);\\n            \\n            \\n            sum += (largest - smallest)\\n        }\\n    }\\n    return sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1835438,
                "title": "monotonic-stack-o-n-clean-c-solution",
                "content": "Instead of iterate over all the suarrays, we can calculate the contribution of each number as a maximum and minimum.\\nThen the results are **sum(nums[i] * (count_as_max - count_as_min))**.\\nSo we can calculate the contribution as max and min seperately. With the feature of monotonic stack, the preceding one to current is the count of subarray left, the succeeding one to current is the count of subarray right.\\nSo we have **contribution = left * right * current_num** , and take negative when it is minimum.\\nTime and space complexity O(N).\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long subArrayRanges(vector<int>& nums) {\\n\\t\\t\\tint64_t ans = 0;      \\n\\t\\t\\tstack<int> dec_stk;\\n\\t\\t\\tnums.push_back(INT_MAX);\\n\\t\\t\\tfor(int i = 0; i < nums.size(); i++) {\\n\\t\\t\\t\\twhile(!dec_stk.empty() && nums[i] >= nums[dec_stk.top()]){\\n\\t\\t\\t\\t\\t// nums[dec_stk.top()] as a maximum\\n\\t\\t\\t\\t\\tint mid = dec_stk.top();\\n\\t\\t\\t\\t\\tint64_t right = i - mid;\\n\\t\\t\\t\\t\\tdec_stk.pop();\\n\\t\\t\\t\\t\\tint64_t left = mid - (dec_stk.empty()? -1 : dec_stk.top());\\n\\t\\t\\t\\t\\tans += right * left * nums[mid];   \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdec_stk.push(i);\\n\\t\\t\\t}\\n\\t\\t\\tnums.back() = INT_MIN;\\n\\t\\t\\tstack<int> inc_stk;\\n\\t\\t\\tfor(int i = 0; i < nums.size(); i++) {\\n\\t\\t\\t\\twhile(!inc_stk.empty() && nums[i] <= nums[inc_stk.top()]){\\n\\t\\t\\t\\t\\t// nums[inc_stk.top()] as a minimum\\n\\t\\t\\t\\t\\tint mid = inc_stk.top();\\n\\t\\t\\t\\t\\tint64_t right = i - mid;\\n\\t\\t\\t\\t\\tinc_stk.pop();\\n\\t\\t\\t\\t\\tint64_t left = mid - (inc_stk.empty()? -1 : inc_stk.top());\\n\\t\\t\\t\\t\\tans -= right * left * nums[mid];   \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tinc_stk.push(i);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long subArrayRanges(vector<int>& nums) {\\n\\t\\t\\tint64_t ans = 0;      \\n\\t\\t\\tstack<int> dec_stk;\\n\\t\\t\\tnums.push_back(INT_MAX);\\n\\t\\t\\tfor(int i = 0; i < nums.size(); i++) {\\n\\t\\t\\t\\twhile(!dec_stk.empty() && nums[i] >= nums[dec_stk.top()]){\\n\\t\\t\\t\\t\\t// nums[dec_stk.top()] as a maximum\\n\\t\\t\\t\\t\\tint mid = dec_stk.top();\\n\\t\\t\\t\\t\\tint64_t right = i - mid;\\n\\t\\t\\t\\t\\tdec_stk.pop();\\n\\t\\t\\t\\t\\tint64_t left = mid - (dec_stk.empty()? -1 : dec_stk.top());\\n\\t\\t\\t\\t\\tans += right * left * nums[mid];   \\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1810417,
                "title": "brute-force-o-n-2-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        long ans = 0;\\n        int n = nums.size();\\n        for (int i=0; i<n; i++)\\n        {\\n            int maxi = nums[i], mini = nums[i];\\n            for (int j=i+1;j<n;j++)\\n            {\\n                maxi = max(maxi, nums[j]);\\n                mini = min(mini, nums[j]);\\n\\n                ans += (maxi - mini);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        long ans = 0;\\n        int n = nums.size();\\n        for (int i=0; i<n; i++)\\n        {\\n            int maxi = nums[i], mini = nums[i];\\n            for (int j=i+1;j<n;j++)\\n            {\\n                maxi = max(maxi, nums[j]);\\n                mini = min(mini, nums[j]);\\n\\n                ans += (maxi - mini);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1794512,
                "title": "golang-stack",
                "content": "no idea if it\\'s O(n)\\n```\\nfunc subArrayRanges(nums []int) int64 {\\n    f1 := func(a int, b int)bool {\\n        return a < b\\n    }\\n    f2 := func(a int, b int)bool {\\n        return a > b\\n    }\\n    return int64(sumSub(nums, f2) - sumSub(nums, f1))\\n}\\n\\nfunc sumSub(nums []int, f func(int, int)bool) int {\\n    res := 0\\n    var stack [][3]int //{index, value, result}\\n    for i := 0; i < len(nums); i++ {\\n        index := sort.Search(len(stack), func(j int) bool {\\n            return !f(stack[j][1], nums[i])\\n        })\\n        start := 0\\n        last_res := 0\\n        this_res := 0\\n        if index != 0 {\\n            start = stack[index - 1][0] + 1\\n            last_res = stack[index - 1][2]\\n        }\\n        this_res += (i - start + 1) * nums[i]\\n        this_res += last_res\\n        stack = stack[:index]\\n        stack = append(stack, [3]int{i, nums[i], this_res})\\n        res += this_res\\n    }\\n    return res\\n}\\n```\\nO(n)\\n```\\nfunc subArrayRanges(nums []int) int64 {\\n    f1 := func(a int, b int)bool {\\n        return a <= b\\n    }\\n    f2 := func(a int, b int)bool {\\n        return a >= b\\n    }\\n    return int64(sumSub(nums, f2) - sumSub(nums, f1))\\n}\\n\\nfunc sumSub(nums []int, f func(int, int)bool) int {\\n    stack := [][2]int{[2]int{nums[0], 1}}\\n    res := nums[0]\\n    sum := nums[0]\\n    for i := 1; i < len(nums); i++ {\\n        v0 := nums[i]\\n        v1 := 1\\n        for len(stack) > 0 && f(v0, stack[len(stack) - 1][0]) {\\n            v1 += stack[len(stack) - 1][1]\\n            sum -= stack[len(stack) - 1][0] * stack[len(stack) - 1][1]\\n            stack = stack[:len(stack) - 1]\\n        }\\n        stack = append(stack, [2]int{v0, v1})\\n        sum += v0 * v1\\n        res += sum\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc subArrayRanges(nums []int) int64 {\\n    f1 := func(a int, b int)bool {\\n        return a < b\\n    }\\n    f2 := func(a int, b int)bool {\\n        return a > b\\n    }\\n    return int64(sumSub(nums, f2) - sumSub(nums, f1))\\n}\\n\\nfunc sumSub(nums []int, f func(int, int)bool) int {\\n    res := 0\\n    var stack [][3]int //{index, value, result}\\n    for i := 0; i < len(nums); i++ {\\n        index := sort.Search(len(stack), func(j int) bool {\\n            return !f(stack[j][1], nums[i])\\n        })\\n        start := 0\\n        last_res := 0\\n        this_res := 0\\n        if index != 0 {\\n            start = stack[index - 1][0] + 1\\n            last_res = stack[index - 1][2]\\n        }\\n        this_res += (i - start + 1) * nums[i]\\n        this_res += last_res\\n        stack = stack[:index]\\n        stack = append(stack, [3]int{i, nums[i], this_res})\\n        res += this_res\\n    }\\n    return res\\n}\\n```\n```\\nfunc subArrayRanges(nums []int) int64 {\\n    f1 := func(a int, b int)bool {\\n        return a <= b\\n    }\\n    f2 := func(a int, b int)bool {\\n        return a >= b\\n    }\\n    return int64(sumSub(nums, f2) - sumSub(nums, f1))\\n}\\n\\nfunc sumSub(nums []int, f func(int, int)bool) int {\\n    stack := [][2]int{[2]int{nums[0], 1}}\\n    res := nums[0]\\n    sum := nums[0]\\n    for i := 1; i < len(nums); i++ {\\n        v0 := nums[i]\\n        v1 := 1\\n        for len(stack) > 0 && f(v0, stack[len(stack) - 1][0]) {\\n            v1 += stack[len(stack) - 1][1]\\n            sum -= stack[len(stack) - 1][0] * stack[len(stack) - 1][1]\\n            stack = stack[:len(stack) - 1]\\n        }\\n        stack = append(stack, [2]int{v0, v1})\\n        sum += v0 * v1\\n        res += sum\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1776481,
                "title": "two-monotonic-stack-time-o-n-space-o-n",
                "content": "Below is solution I tried. In first attempt I was not able to solve. I had idea to use two stacks max and min but calculation was not correct. I got help from hint and online then solve it. Took 1 hour. (So reader can have realistic Expectation). hope it will help.\\n\\n```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n       \\n        Deque<Integer> minStack = new ArrayDeque<>();\\n        Deque<Integer> maxStack = new ArrayDeque<>();\\n        long result = 0;\\n        minStack.offerFirst(-1);\\n        maxStack.offerFirst(-1);\\n        for(int i=0; i<=nums.length; i++) {\\n            while(minStack.peekFirst() != -1 && (i == nums.length || nums[i] < nums[minStack.peekFirst()])) {\\n                result -= calcRange(minStack, i, nums);\\n            }\\n            minStack.offerFirst(i);\\n            while (maxStack.peekFirst() != -1  && (i == nums.length || nums[i] > nums[maxStack.peekFirst()])) {\\n                result += calcRange(maxStack, i, nums);\\n            }\\n            maxStack.offerFirst(i);\\n        }\\n        return result;\\n    }\\n    private long calcRange(Deque<Integer> stack , int i, int[] nums) {\\n        int index = stack.pollFirst();\\n        int left = index - stack.peekFirst();\\n        int right = i - index;\\n        return ((left * right) * (long)nums[index]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n       \\n        Deque<Integer> minStack = new ArrayDeque<>();\\n        Deque<Integer> maxStack = new ArrayDeque<>();\\n        long result = 0;\\n        minStack.offerFirst(-1);\\n        maxStack.offerFirst(-1);\\n        for(int i=0; i<=nums.length; i++) {\\n            while(minStack.peekFirst() != -1 && (i == nums.length || nums[i] < nums[minStack.peekFirst()])) {\\n                result -= calcRange(minStack, i, nums);\\n            }\\n            minStack.offerFirst(i);\\n            while (maxStack.peekFirst() != -1  && (i == nums.length || nums[i] > nums[maxStack.peekFirst()])) {\\n                result += calcRange(maxStack, i, nums);\\n            }\\n            maxStack.offerFirst(i);\\n        }\\n        return result;\\n    }\\n    private long calcRange(Deque<Integer> stack , int i, int[] nums) {\\n        int index = stack.pollFirst();\\n        int left = index - stack.peekFirst();\\n        int right = i - index;\\n        return ((left * right) * (long)nums[index]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747956,
                "title": "python-using-stack-simple-85-cpu-and-90-memory",
                "content": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        nums.append(-inf)\\n        stk = [-1]\\n        minSums = 0\\n        for i in range(len(nums)):\\n            while stk[-1] != -1 and nums[i] < nums[stk[-1]]:\\n                #print((nums[i], nums[stk[-1]]))\\n                idx = stk.pop()\\n                minSums+= (nums[idx] * (i-idx) * (idx-stk[-1]))\\n            \\n            stk.append(i)\\n        \\n        nums.remove(-inf)\\n        nums.append(inf)\\n        stk = [-1]\\n        maxSums = 0\\n        for i in range(len(nums)):\\n            while stk[-1] != -1 and nums[i] > nums[stk[-1]]:\\n                idx = stk.pop()\\n                maxSums+= (nums[idx] * (i-idx) * (idx-stk[-1]))\\n            \\n            stk.append(i)\\n        \\n        return maxSums - minSums\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        nums.append(-inf)\\n        stk = [-1]\\n        minSums = 0\\n        for i in range(len(nums)):\\n            while stk[-1] != -1 and nums[i] < nums[stk[-1]]:\\n                #print((nums[i], nums[stk[-1]]))\\n                idx = stk.pop()\\n                minSums+= (nums[idx] * (i-idx) * (idx-stk[-1]))\\n            \\n            stk.append(i)\\n        \\n        nums.remove(-inf)\\n        nums.append(inf)\\n        stk = [-1]\\n        maxSums = 0\\n        for i in range(len(nums)):\\n            while stk[-1] != -1 and nums[i] > nums[stk[-1]]:\\n                idx = stk.pop()\\n                maxSums+= (nums[idx] * (i-idx) * (idx-stk[-1]))\\n            \\n            stk.append(i)\\n        \\n        return maxSums - minSums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1695820,
                "title": "c-using-heap",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    long long subArrayRanges(vector<int>& nums) {\\n         typedef long long ll;\\n        ll ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            priority_queue<ll>maxh;//max element will on top\\n            priority_queue<ll,vector<ll>,greater<ll>>minh;//min element will on top\\n            for(int j=i;j<nums.size();j++){\\n                maxh.push(nums[j]);\\n                minh.push(nums[j]);\\n                ans+=maxh.top()-minh.top();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    long long subArrayRanges(vector<int>& nums) {\\n         typedef long long ll;\\n        ll ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            priority_queue<ll>maxh;//max element will on top\\n            priority_queue<ll,vector<ll>,greater<ll>>minh;//min element will on top\\n            for(int j=i;j<nums.size();j++){\\n                maxh.push(nums[j]);\\n                minh.push(nums[j]);\\n                ans+=maxh.top()-minh.top();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663402,
                "title": "c-solution",
                "content": "```\\n    long long subArrayRanges(vector<int>& nums) {\\n        // the method is to find each nums[i] contributes to the maximum value and minimum value to the final result\\n        // for nums[i], if nums[i] < nums[k] where k < i && nums[i] < nums[j] where j > i\\n        // then nums[i] contributes -nums[i] * (i - k) * (j - i) to the final result\\n        // likewise if nums[i] > nums[u] where u < i and nums[i] > nums[v] where v > i then nums[i] contributes nums[i] * (i - u) * (v - i) to the final result\\n        int size = nums.size();\\n        stack<int> indexStack;\\n        long long result = 0;\\n        // we can use monotonic stack to find the range of minimum and maximum for every item in nums\\n        // for j = indexStack.top() if it\\'s larger than nums[i], then it means that in the range of [j, i), nums[j] is the smallest number, \\n        // and the next item under the indexStack top, that\\'s indexStack.pop(), k = indexStack.top(). k is in front of j in the stack, \\n        // which means nums[k] < nums[j], so in the range of (k, j], nums[j] is the smallest. \\n        // So nums[j] contributes -nums[j] * (j - k) * (i - j) to the final result\\n        \\n        // after interating over the nums, we need to calculation how many the items left in the indexStack\\n        // contribute to the final result, since the items left in the stack are storing in decreasing order from top to bottom in the stack\\n        // so the right boundary of the range is always nums.size()\\n        for (int i = 0; i <= size; i++) {\\n            while (indexStack.size() > 0 && (i == size || nums[indexStack.top()] > nums[i])) {\\n                int index = indexStack.top();\\n                indexStack.pop();\\n                int leftIndex = indexStack.size() > 0 ? indexStack.top() : -1;\\n                result -= (long long)nums[index] * (index - leftIndex) * (i - index);\\n            }\\n            indexStack.push(i);\\n        }\\n        indexStack = stack<int>();\\n        // we compute the maximum contribution of each nums[i] to the final result in a similar way\\n        for (int i = 0; i <= size; i++) {\\n            while (indexStack.size() > 0 && (i == size || nums[indexStack.top()] < nums[i])) {\\n                int index = indexStack.top();\\n                indexStack.pop();\\n                int leftIndex = indexStack.size() > 0 ? indexStack.top() : -1;\\n                result += (long long)nums[index] * (index - leftIndex) * (i - index);\\n            }\\n            indexStack.push(i);\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    long long subArrayRanges(vector<int>& nums) {\\n        // the method is to find each nums[i] contributes to the maximum value and minimum value to the final result\\n        // for nums[i], if nums[i] < nums[k] where k < i && nums[i] < nums[j] where j > i\\n        // then nums[i] contributes -nums[i] * (i - k) * (j - i) to the final result\\n        // likewise if nums[i] > nums[u] where u < i and nums[i] > nums[v] where v > i then nums[i] contributes nums[i] * (i - u) * (v - i) to the final result\\n        int size = nums.size();\\n        stack<int> indexStack;\\n        long long result = 0;\\n        // we can use monotonic stack to find the range of minimum and maximum for every item in nums\\n        // for j = indexStack.top() if it\\'s larger than nums[i], then it means that in the range of [j, i), nums[j] is the smallest number, \\n        // and the next item under the indexStack top, that\\'s indexStack.pop(), k = indexStack.top(). k is in front of j in the stack, \\n        // which means nums[k] < nums[j], so in the range of (k, j], nums[j] is the smallest. \\n        // So nums[j] contributes -nums[j] * (j - k) * (i - j) to the final result\\n        \\n        // after interating over the nums, we need to calculation how many the items left in the indexStack\\n        // contribute to the final result, since the items left in the stack are storing in decreasing order from top to bottom in the stack\\n        // so the right boundary of the range is always nums.size()\\n        for (int i = 0; i <= size; i++) {\\n            while (indexStack.size() > 0 && (i == size || nums[indexStack.top()] > nums[i])) {\\n                int index = indexStack.top();\\n                indexStack.pop();\\n                int leftIndex = indexStack.size() > 0 ? indexStack.top() : -1;\\n                result -= (long long)nums[index] * (index - leftIndex) * (i - index);\\n            }\\n            indexStack.push(i);\\n        }\\n        indexStack = stack<int>();\\n        // we compute the maximum contribution of each nums[i] to the final result in a similar way\\n        for (int i = 0; i <= size; i++) {\\n            while (indexStack.size() > 0 && (i == size || nums[indexStack.top()] < nums[i])) {\\n                int index = indexStack.top();\\n                indexStack.pop();\\n                int leftIndex = indexStack.size() > 0 ? indexStack.top() : -1;\\n                result += (long long)nums[index] * (index - leftIndex) * (i - index);\\n            }\\n            indexStack.push(i);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1641024,
                "title": "using-loop-o-n-2",
                "content": "```\\n long long sum=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n           int maxi=nums[i];\\n           int mini=nums[i];\\n        for(int j=i+1;j<nums.size();j++){\\n           if(nums[j]>maxi){\\n               maxi=nums[j];\\n           }\\n            if(nums[j]<mini){\\n                mini=nums[j];\\n            }\\n            sum+=maxi-mini;\\n        }\\n        }\\n        \\n        cout<<sum;\\n        return sum;\\n```",
                "solutionTags": [],
                "code": "```\\n long long sum=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n           int maxi=nums[i];\\n           int mini=nums[i];\\n        for(int j=i+1;j<nums.size();j++){\\n           if(nums[j]>maxi){\\n               maxi=nums[j];\\n           }\\n            if(nums[j]<mini){\\n                mini=nums[j];\\n            }\\n            sum+=maxi-mini;\\n        }\\n        }\\n        \\n        cout<<sum;\\n        return sum;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1632817,
                "title": "java-monostack-linear-time-with-comments",
                "content": "```\\nclass MonoStack{\\n    Deque<Integer> deque;\\n    int[] left, right, data;\\n    int size;\\n    boolean isIncreasing = false;\\n    public MonoStack(int n, int[] data, boolean isIncreasing){\\n        this.size = n;\\n        this.left = new int[n];\\n        this.right = new int[n];\\n        \\n        Arrays.fill(left, -1);\\n        Arrays.fill(right, n);\\n\\n        \\n        this.data = data;\\n        this.isIncreasing = isIncreasing;\\n        this.deque = new ArrayDeque<>();\\n    }\\n    \\n    private boolean canPush(int index){\\n        return this.isIncreasing ? (data[deque.peekLast()] < data[index]) : (data[deque.peekLast()] > data[index]);\\n    }\\n    \\n    public void push(int index){\\n        while(!deque.isEmpty() && !canPush(index)){\\n            int topIndex = deque.pollLast();\\n            this.right[topIndex] = index;\\n        }\\n        if(!deque.isEmpty()) {\\n            this.left[index] = deque.peekLast();\\n        }\\n        deque.offer(index);\\n    }\\n    \\n    public int leftCount(int index){\\n        return index - (this.left[index] + 1);\\n    }\\n    \\n    public int rightCount(int index){\\n        return this.right[index] - (index+1);\\n    }\\n}\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        MonoStack increasing = new MonoStack(nums.length, nums, true);\\n        MonoStack decreasing = new MonoStack(nums.length, nums, false);\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            increasing.push(i);\\n            decreasing.push(i);\\n        }\\n        \\n        long total = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            /*\\n            how many numbers/subarrays on the left and right side of the current element, where current is min ?\\n                use increasing stack to find next smaller number on left and right\\n                 small1.....current.....small2\\n                 combination of left and right interval is the total contribution of current element being min.\\n\\t\\t\\t\\t If we have 3 nums on left and 4 nums on right, with current being - 9, which makes 9 smaller for 3 elements on the left and smaller for 4 elements on the right. So total times 9 is smaller = 4 + 3 + (4*3)\\n            */\\n            int minLeft = increasing.leftCount(i);\\n            int minRight = increasing.rightCount(i);\\n            \\n            /*\\n            how many numbers/subarrays on the left and right of the current element, where current is max ?\\n                use decreasing stack to find next bigger number on left and right\\n                big1.....current.....big2\\n                combination of left and right interval is the total contribution of current element being max \\n            */\\n            int maxLeft = decreasing.leftCount(i);\\n            int maxRight = decreasing.rightCount(i);\\n            \\n            /*\\n                minLeft = subarrays ending with current\\n                minRight = subarrays starting with current\\n                minLeft * minRight = cross product of all the subarrays where current appears in between.\\n            */\\n            long totalMinFor = minLeft + minRight + (long)(minLeft * minRight);\\n            long totalMaxFor = maxLeft + maxRight + (long)(maxLeft * maxRight);\\n            \\n            total += (nums[i] * totalMaxFor);\\n            total -= (nums[i] * totalMinFor);\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass MonoStack{\\n    Deque<Integer> deque;\\n    int[] left, right, data;\\n    int size;\\n    boolean isIncreasing = false;\\n    public MonoStack(int n, int[] data, boolean isIncreasing){\\n        this.size = n;\\n        this.left = new int[n];\\n        this.right = new int[n];\\n        \\n        Arrays.fill(left, -1);\\n        Arrays.fill(right, n);\\n\\n        \\n        this.data = data;\\n        this.isIncreasing = isIncreasing;\\n        this.deque = new ArrayDeque<>();\\n    }\\n    \\n    private boolean canPush(int index){\\n        return this.isIncreasing ? (data[deque.peekLast()] < data[index]) : (data[deque.peekLast()] > data[index]);\\n    }\\n    \\n    public void push(int index){\\n        while(!deque.isEmpty() && !canPush(index)){\\n            int topIndex = deque.pollLast();\\n            this.right[topIndex] = index;\\n        }\\n        if(!deque.isEmpty()) {\\n            this.left[index] = deque.peekLast();\\n        }\\n        deque.offer(index);\\n    }\\n    \\n    public int leftCount(int index){\\n        return index - (this.left[index] + 1);\\n    }\\n    \\n    public int rightCount(int index){\\n        return this.right[index] - (index+1);\\n    }\\n}\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        MonoStack increasing = new MonoStack(nums.length, nums, true);\\n        MonoStack decreasing = new MonoStack(nums.length, nums, false);\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            increasing.push(i);\\n            decreasing.push(i);\\n        }\\n        \\n        long total = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            /*\\n            how many numbers/subarrays on the left and right side of the current element, where current is min ?\\n                use increasing stack to find next smaller number on left and right\\n                 small1.....current.....small2\\n                 combination of left and right interval is the total contribution of current element being min.\\n\\t\\t\\t\\t If we have 3 nums on left and 4 nums on right, with current being - 9, which makes 9 smaller for 3 elements on the left and smaller for 4 elements on the right. So total times 9 is smaller = 4 + 3 + (4*3)\\n            */\\n            int minLeft = increasing.leftCount(i);\\n            int minRight = increasing.rightCount(i);\\n            \\n            /*\\n            how many numbers/subarrays on the left and right of the current element, where current is max ?\\n                use decreasing stack to find next bigger number on left and right\\n                big1.....current.....big2\\n                combination of left and right interval is the total contribution of current element being max \\n            */\\n            int maxLeft = decreasing.leftCount(i);\\n            int maxRight = decreasing.rightCount(i);\\n            \\n            /*\\n                minLeft = subarrays ending with current\\n                minRight = subarrays starting with current\\n                minLeft * minRight = cross product of all the subarrays where current appears in between.\\n            */\\n            long totalMinFor = minLeft + minRight + (long)(minLeft * minRight);\\n            long totalMaxFor = maxLeft + maxRight + (long)(maxLeft * maxRight);\\n            \\n            total += (nums[i] * totalMaxFor);\\n            total -= (nums[i] * totalMinFor);\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630143,
                "title": "c-array-brute-force-o-n-2-simple-and-clean-code",
                "content": "**C++ Approach :**\\n```\\n\\tlong long subArrayRanges(vector<int>& nums) \\n    {\\n        long long sum=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int min=nums[i];\\n            int max=nums[i];\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                if(nums[j]>max)\\n                    max=nums[j];\\n                if(nums[j]<min)\\n                    min=nums[j];\\n                \\n                sum+=(max-min);\\n            }\\n        }\\n        return sum;\\n    }\\n```\\n**Complexity Analysis :**\\nTime : O(n^2)",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n\\tlong long subArrayRanges(vector<int>& nums) \\n    {\\n        long long sum=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int min=nums[i];\\n            int max=nums[i];\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                if(nums[j]>max)\\n                    max=nums[j];\\n                if(nums[j]<min)\\n                    min=nums[j];\\n                \\n                sum+=(max-min);\\n            }\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1629519,
                "title": "easy-solution-in-c",
                "content": "//smjh\\n\\n```\\nlong long subArrayRanges(vector<int>& nums) {\\n        \\n        if(nums.size() ==0) return 0;\\n        \\n        int n = nums.size();\\n        \\n        long long sum = 0;\\n        for(int i  = 0;i<n;i++){\\n            int mini = INT_MAX;\\n            int maxi = INT_MIN;\\n            for(int j = i;j<n;j++){\\n                mini = min(mini,nums[j]);\\n                maxi = max(maxi,nums[j]);\\n                sum += maxi - mini;\\n            }\\n        }\\n        return sum;\\n    }\\n\\t\\n\\t// Do upvote if you find it helpful",
                "solutionTags": [
                    "C"
                ],
                "code": "//smjh\\n\\n```\\nlong long subArrayRanges(vector<int>& nums) {\\n        \\n        if(nums.size() ==0) return 0;\\n        \\n        int n = nums.size();\\n        \\n        long long sum = 0;\\n        for(int i  = 0;i<n;i++){\\n            int mini = INT_MAX;\\n            int maxi = INT_MIN;\\n            for(int j = i;j<n;j++){\\n                mini = min(mini,nums[j]);\\n                maxi = max(maxi,nums[j]);\\n                sum += maxi - mini;\\n            }\\n        }\\n        return sum;\\n    }\\n\\t\\n\\t// Do upvote if you find it helpful",
                "codeTag": "Unknown"
            },
            {
                "id": 1628725,
                "title": "2-pointer-soln-in-python",
                "content": "the solution is\\n\"\"\"\\n\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        \\n        add = 0\\n        len_n = len(nums)\\n        large = 0\\n        small = 0\\n        for i in range(len_n):\\n            large = nums[i]\\n            small = nums[i]\\n            \\n            for j in range(i+2,len_n):\\n                \\n                if nums[j] < small:\\n                    small = nums[j]\\n                elif nums[j] > large:\\n                    large = nums[j]\\n                \\n                \\n                add += (large - small)\\n                \\n                \\n                \\n        return add\\n\\t\\t\\n\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "the solution is\\n\"\"\"\\n\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        \\n        add = 0\\n        len_n = len(nums)\\n        large = 0\\n        small = 0\\n        for i in range(len_n):\\n            large = nums[i]\\n            small = nums[i]\\n            \\n            for j in range(i+2,len_n):\\n                \\n                if nums[j] < small:\\n                    small = nums[j]\\n                elif nums[j] > large:\\n                    large = nums[j]\\n                \\n                \\n                add += (large - small)\\n                \\n                \\n                \\n        return add\\n\\t\\t\\n\\t\\t\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1625602,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n     long long subArrayRanges(vector<int>& nums) {\\n        long res = 0;\\n        auto doit = [&nums, n = nums.size()] () {\\n            vector<int> left_ge(n), right_gt(n);\\n            long res = 0;\\n            for (int i = 0; i < n; i++) {\\n                left_ge[i] = i - 1;\\n                for (; left_ge[i] != -1 && nums[left_ge[i]] < nums[i];)\\n                    left_ge[i] = left_ge[left_ge[i]];\\n            }\\n            for (int i = n - 1; i >= 0; i--) {\\n                right_gt[i] = i + 1;\\n                for (; right_gt[i] != n && nums[right_gt[i]] <= nums[i];)\\n                    right_gt[i] = right_gt[right_gt[i]];\\n                res += (long) nums[i] * (right_gt[i] - i) * (i - left_ge[i]);\\n            }\\n            \\n            return res;\\n        };\\n        res = doit();\\n        for_each(nums.begin(), nums.end(), [] (int &a) { a = -a; });\\n        res += doit();\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     long long subArrayRanges(vector<int>& nums) {\\n        long res = 0;\\n        auto doit = [&nums, n = nums.size()] () {\\n            vector<int> left_ge(n), right_gt(n);\\n            long res = 0;\\n            for (int i = 0; i < n; i++) {\\n                left_ge[i] = i - 1;\\n                for (; left_ge[i] != -1 && nums[left_ge[i]] < nums[i];)\\n                    left_ge[i] = left_ge[left_ge[i]];\\n            }\\n            for (int i = n - 1; i >= 0; i--) {\\n                right_gt[i] = i + 1;\\n                for (; right_gt[i] != n && nums[right_gt[i]] <= nums[i];)\\n                    right_gt[i] = right_gt[right_gt[i]];\\n                res += (long) nums[i] * (right_gt[i] - i) * (i - left_ge[i]);\\n            }\\n            \\n            return res;\\n        };\\n        res = doit();\\n        for_each(nums.begin(), nums.end(), [] (int &a) { a = -a; });\\n        res += doit();\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625013,
                "title": "kotlin-o-n-solution",
                "content": "```\\nclass Solution {\\n    fun subArrayRanges(nums: IntArray): Long = sumOf(nums, Target.LARGEST) - sumOf(nums, Target.SMALLEST)\\n\\n    private fun sumOf(nums: IntArray, target: Target): Long {\\n        var res = 0L\\n        val stack = Stack<Pair<Int, Int>>().apply { push(target.extremeValue to -1) } //num, index\\n        fun popAt(index: Int) = stack.pop().let { (popNum, popIndex) ->\\n            res += popNum.toLong() * (popIndex - stack.peek().second) * (index - popIndex)\\n        }\\n        nums.forEachIndexed { index, num ->\\n            while (target.moreExtremeOf(num, stack.peek().first) == num) {\\n                popAt(index)\\n            }\\n            stack.push(num to index)\\n        }\\n        while (stack.size > 1) {\\n            popAt(nums.size)\\n        }\\n        return res\\n    }\\n\\n    private enum class Target(val extremeValue: Int) {\\n        LARGEST(Int.MAX_VALUE) {\\n            override fun moreExtremeOf(a: Int, b: Int): Int {\\n                return maxOf(a, b)\\n            }\\n        },\\n        SMALLEST(Int.MIN_VALUE) {\\n            override fun moreExtremeOf(a: Int, b: Int): Int {\\n                return minOf(a, b)\\n            }\\n        };\\n\\n        abstract fun moreExtremeOf(a: Int, b: Int): Int\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    fun subArrayRanges(nums: IntArray): Long = sumOf(nums, Target.LARGEST) - sumOf(nums, Target.SMALLEST)\\n\\n    private fun sumOf(nums: IntArray, target: Target): Long {\\n        var res = 0L\\n        val stack = Stack<Pair<Int, Int>>().apply { push(target.extremeValue to -1) } //num, index\\n        fun popAt(index: Int) = stack.pop().let { (popNum, popIndex) ->\\n            res += popNum.toLong() * (popIndex - stack.peek().second) * (index - popIndex)\\n        }\\n        nums.forEachIndexed { index, num ->\\n            while (target.moreExtremeOf(num, stack.peek().first) == num) {\\n                popAt(index)\\n            }\\n            stack.push(num to index)\\n        }\\n        while (stack.size > 1) {\\n            popAt(nums.size)\\n        }\\n        return res\\n    }\\n\\n    private enum class Target(val extremeValue: Int) {\\n        LARGEST(Int.MAX_VALUE) {\\n            override fun moreExtremeOf(a: Int, b: Int): Int {\\n                return maxOf(a, b)\\n            }\\n        },\\n        SMALLEST(Int.MIN_VALUE) {\\n            override fun moreExtremeOf(a: Int, b: Int): Int {\\n                return minOf(a, b)\\n            }\\n        };\\n\\n        abstract fun moreExtremeOf(a: Int, b: Int): Int\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624596,
                "title": "c-o-n-2-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        vector<pair<int,int>> dp(nums.size());\\n        long long res=0;\\n        for(int i=0;i<nums.size();++i){\\n            for(int j=0;j<dp.size();++j){\\n                if(j<i)continue;\\n                if(j==i)\\n                    dp[j]={nums[i],nums[i]};\\n                else{\\n                    int mini=min(dp[j-1].first,nums[j]);\\n                    int maxi=max(dp[j-1].second,nums[j]);\\n                    res+=(maxi-mini);\\n                    dp[j]={mini,maxi};\\n                }\\n                \\n            }\\n        }\\n        return res;\\n        \\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        vector<pair<int,int>> dp(nums.size());\\n        long long res=0;\\n        for(int i=0;i<nums.size();++i){\\n            for(int j=0;j<dp.size();++j){\\n                if(j<i)continue;\\n                if(j==i)\\n                    dp[j]={nums[i],nums[i]}",
                "codeTag": "Java"
            },
            {
                "id": 1624441,
                "title": "simple-python3-solution-accepted",
                "content": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:           \\n        sump=0\\n        rangep=0\\n        \\n        for p1 in range(len(nums)):\\n            minp=nums[p1]\\n            maxp=nums[p1]\\n            for p2 in range(p1, len(nums)):\\n                maxp = max(nums[p2], maxp)\\n                minp = min(nums[p2], minp)\\n                rangep = maxp - minp\\n                sump = sump + rangep\\n                  \\n        return sump\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:           \\n        sump=0\\n        rangep=0\\n        \\n        for p1 in range(len(nums)):\\n            minp=nums[p1]\\n            maxp=nums[p1]\\n            for p2 in range(p1, len(nums)):\\n                maxp = max(nums[p2], maxp)\\n                minp = min(nums[p2], minp)\\n                rangep = maxp - minp\\n                sump = sump + rangep\\n                  \\n        return sump\\n",
                "codeTag": "Java"
            },
            {
                "id": 1624359,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        long long cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            int mi=nums[i];\\n            int mx=nums[i];\\n            int j;\\n            for(j=i;j<nums.size();j++){\\n                mi=min(mi,nums[j]);\\n                mx=max(mx,nums[j]);\\n                cnt+=(mx-mi);\\n            }\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        long long cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            int mi=nums[i];\\n            int mx=nums[i];\\n            int j;\\n            for(j=i;j<nums.size();j++){\\n                mi=min(mi,nums[j]);\\n                mx=max(mx,nums[j]);\\n                cnt+=(mx-mi);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1624350,
                "title": "c-o-n-2-solution",
                "content": "A very simple approach for the given constraints can be taking each element as the key and sliding the window to the right to see whether we have a maximum or a minimum. If we have, then we update, otherwise we add the \\'range till now\\' to the solution.\\n```\\n long long subArrayRanges(vector<int>& nums) {\\n        long long int ans = 0;\\n        for(int i = 0 ; i < nums.size(); i++){\\n\\t\\t//fix the key and initialize it to the min as well as max\\n\\t\\t//handles the case of single sized window\\n            long long int key = nums[i];\\n            long long int minElement = key;\\n            long long int maxElement = key;\\n            for(int j = i + 1 ; j < nums.size(); j++){\\n\\t\\t\\t//expand the window and perform max ands min checks\\n                if(nums[j] >= maxElement){\\n                    maxElement = nums[j];\\n                }\\n                else if(nums[j] <= minElement){\\n                    minElement = nums[j];\\n                }\\n\\t\\t\\t\\t//add range to the answer\\n                ans += maxElement - minElement;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n long long subArrayRanges(vector<int>& nums) {\\n        long long int ans = 0;\\n        for(int i = 0 ; i < nums.size(); i++){\\n\\t\\t//fix the key and initialize it to the min as well as max\\n\\t\\t//handles the case of single sized window\\n            long long int key = nums[i];\\n            long long int minElement = key;\\n            long long int maxElement = key;\\n            for(int j = i + 1 ; j < nums.size(); j++){\\n\\t\\t\\t//expand the window and perform max ands min checks\\n                if(nums[j] >= maxElement){\\n                    maxElement = nums[j];\\n                }\\n                else if(nums[j] <= minElement){\\n                    minElement = nums[j];\\n                }\\n\\t\\t\\t\\t//add range to the answer\\n                ans += maxElement - minElement;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1624323,
                "title": "easy-to-understand-c-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        int n=nums.size();\\n        long long ans=0;\\n        for(int i=0;i<n;++i)\\n        {\\n            int big=nums[i];\\n            int small=nums[i];\\n            for(int j=i;j<n;++j)\\n            {\\n                big=max(nums[j],big);\\n                small=min(nums[j],small);\\n                ans+=(big-small);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        int n=nums.size();\\n        long long ans=0;\\n        for(int i=0;i<n;++i)\\n        {\\n            int big=nums[i];\\n            int small=nums[i];\\n            for(int j=i;j<n;++j)\\n            {\\n                big=max(nums[j],big);\\n                small=min(nums[j],small);\\n                ans+=(big-small);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624316,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) \\n    {\\n        long long  ans=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            priority_queue<long long>pq1;\\n            priority_queue<long long,vector<long long>,greater<long long>>pq2;\\n            for(int j=i;j<n;j++)\\n            {\\n                pq1.push(nums[j]);\\n                pq2.push(nums[j]);\\n                ans+=(pq1.top()-pq2.top());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) \\n    {\\n        long long  ans=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            priority_queue<long long>pq1;\\n            priority_queue<long long,vector<long long>,greater<long long>>pq2;\\n            for(int j=i;j<n;j++)\\n            {\\n                pq1.push(nums[j]);\\n                pq2.push(nums[j]);\\n                ans+=(pq1.top()-pq2.top());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624305,
                "title": "python-dp-solution",
                "content": "```\\ndef subArrayRanges(self, nums: List[int]) -> int:\\n        dp = [[(None, None) for i in range(len(nums))] for j in range(len(nums))]\\n        dp[len(nums) -1][len(nums) -1] = (nums[len(nums) -1], nums[len(nums) -1])\\n\\n        res = 0\\n        for i in range(len(nums) -2, -1, -1):\\n            for j in range(i, len(nums)):\\n                if dp[i][j-1] != (None, None):\\n                    dp[i][j] = (max(dp[i][j-1][0], nums[j]), min(dp[i][j-1][1], nums[j]))\\n     \\n                elif dp[i + 1][j] != (None, None):\\n                    dp[i][j] = (max(dp[i + 1][j][0], nums[i]), min(dp[i + 1][j][1], nums[i]))\\n                else:\\n                    dp[i][j] = (nums[i], nums[j])\\n                    \\n                res += dp[i][j][0] - dp[i][j][1]\\n        return res\\n\\t```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\ndef subArrayRanges(self, nums: List[int]) -> int:\\n        dp = [[(None, None) for i in range(len(nums))] for j in range(len(nums))]\\n        dp[len(nums) -1][len(nums) -1] = (nums[len(nums) -1], nums[len(nums) -1])\\n\\n        res = 0\\n        for i in range(len(nums) -2, -1, -1):\\n            for j in range(i, len(nums)):\\n                if dp[i][j-1] != (None, None):\\n                    dp[i][j] = (max(dp[i][j-1][0], nums[j]), min(dp[i][j-1][1], nums[j]))\\n     \\n                elif dp[i + 1][j] != (None, None):\\n                    dp[i][j] = (max(dp[i + 1][j][0], nums[i]), min(dp[i + 1][j][1], nums[i]))\\n                else:\\n                    dp[i][j] = (nums[i], nums[j])\\n                    \\n                res += dp[i][j][0] - dp[i][j][1]\\n        return res\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1624258,
                "title": "c-monotonic-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        int n = nums.size();\\n        long long maxsum = 0, minsum = 0;\\n        vector<int> maxr(n, n), minr(n, n);\\n        stack<int> maxs, mins;\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            while (!maxs.empty() && nums[maxs.top()] < nums[i])\\n                maxs.pop();\\n            while (!mins.empty() && nums[mins.top()] > nums[i])\\n                mins.pop();\\n            if (maxs.empty())\\n                maxr[i] = n - i;\\n            else\\n                maxr[i] = maxs.top() - i;\\n            if (mins.empty())\\n                minr[i] = n - i;\\n            else\\n                minr[i] = mins.top() - i;\\n            maxs.push(i);\\n            mins.push(i);\\n        }\\n        while (!maxs.empty())\\n            maxs.pop();\\n        while (!mins.empty())\\n            mins.pop();\\n        for (int i = 0; i < n; i++)\\n        {\\n            while (!maxs.empty() && nums[maxs.top()] <= nums[i])\\n                maxs.pop();\\n            while (!mins.empty() && nums[mins.top()] >= nums[i])\\n                mins.pop();\\n            if (maxs.empty())\\n                maxsum += (long long)nums[i] * (maxr[i] * (i + 1));\\n            else\\n                maxsum += (long long)nums[i] * (maxr[i] * (i - maxs.top()));\\n            if (mins.empty())\\n                minsum += (long long)nums[i] * (minr[i] * (i + 1));\\n            else\\n                minsum += (long long)nums[i] * (minr[i] * (i - mins.top()));\\n            maxs.push(i);\\n            mins.push(i);\\n        }\\n        return (maxsum - minsum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        int n = nums.size();\\n        long long maxsum = 0, minsum = 0;\\n        vector<int> maxr(n, n), minr(n, n);\\n        stack<int> maxs, mins;\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            while (!maxs.empty() && nums[maxs.top()] < nums[i])\\n                maxs.pop();\\n            while (!mins.empty() && nums[mins.top()] > nums[i])\\n                mins.pop();\\n            if (maxs.empty())\\n                maxr[i] = n - i;\\n            else\\n                maxr[i] = maxs.top() - i;\\n            if (mins.empty())\\n                minr[i] = n - i;\\n            else\\n                minr[i] = mins.top() - i;\\n            maxs.push(i);\\n            mins.push(i);\\n        }\\n        while (!maxs.empty())\\n            maxs.pop();\\n        while (!mins.empty())\\n            mins.pop();\\n        for (int i = 0; i < n; i++)\\n        {\\n            while (!maxs.empty() && nums[maxs.top()] <= nums[i])\\n                maxs.pop();\\n            while (!mins.empty() && nums[mins.top()] >= nums[i])\\n                mins.pop();\\n            if (maxs.empty())\\n                maxsum += (long long)nums[i] * (maxr[i] * (i + 1));\\n            else\\n                maxsum += (long long)nums[i] * (maxr[i] * (i - maxs.top()));\\n            if (mins.empty())\\n                minsum += (long long)nums[i] * (minr[i] * (i + 1));\\n            else\\n                minsum += (long long)nums[i] * (minr[i] * (i - mins.top()));\\n            maxs.push(i);\\n            mins.push(i);\\n        }\\n        return (maxsum - minsum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624225,
                "title": "c-check-all-subarrays",
                "content": "Iterate over all the subarrays starting from the``` ith index``` and maintain ```max and min.```\\n**Time Complexity:-** O(n^2)\\n**Space Complexity:-** O(1)\\n```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            long long mx=nums[i],mn=nums[i];\\n            for(int j=i;j<nums.size();j++){\\n                if(nums[j]>mx){\\n                    mx=nums[j];\\n                }\\n                else if(nums[j]<mn)\\n                    mn=nums[j];\\n                ans+=mx-mn;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "``` ith index```\n```max and min.```\n```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            long long mx=nums[i],mn=nums[i];\\n            for(int j=i;j<nums.size();j++){\\n                if(nums[j]>mx){\\n                    mx=nums[j];\\n                }\\n                else if(nums[j]<mn)\\n                    mn=nums[j];\\n                ans+=mx-mn;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081328,
                "title": "python-clean-solution-using-monotonic-stacks",
                "content": "```python\\nfrom collections import deque\\nfrom math import inf\\n\\n\\nclass Solution:\\n    def subArrayRanges(self, A: list[int]) -> int:\\n        return self.max_of_subarrays(A) - self.min_of_subarrays(A)\\n\\n    @staticmethod\\n    def max_of_subarrays(A: list[int]) -> int:\\n        A = A + [inf]  # creating copy of A as well\\n\\n        push, pop = (stk := deque()).append, stk.pop\\n\\n        def top():\\n            return A[stk[-1]] if stk else inf\\n\\n        output = 0\\n\\n        for i, a in enumerate(A):\\n            while top() < a:\\n                j = pop()\\n\\n                right = i - j\\n                left = j - (stk[-1] if stk else -1)\\n\\n                output += A[j] * left * right\\n\\n            push(i)\\n\\n        return output\\n\\n    @staticmethod\\n    def min_of_subarrays(A: list[int]) -> int:\\n        A = A + [-inf]\\n\\n        push, pop = (stk := deque()).append, stk.pop\\n\\n        def top():\\n            return A[stk[-1]] if stk else -inf\\n\\n        output = 0\\n\\n        for i, a in enumerate(A):\\n            while top() > a:\\n                j = pop()\\n                right = i - j\\n\\n                left = j - (stk[-1] if stk else -1)\\n\\n                output += A[j] * left * right\\n\\n            push(i)\\n\\n        return output\\n```",
                "solutionTags": [
                    "Python3",
                    "Monotonic Stack"
                ],
                "code": "```python\\nfrom collections import deque\\nfrom math import inf\\n\\n\\nclass Solution:\\n    def subArrayRanges(self, A: list[int]) -> int:\\n        return self.max_of_subarrays(A) - self.min_of_subarrays(A)\\n\\n    @staticmethod\\n    def max_of_subarrays(A: list[int]) -> int:\\n        A = A + [inf]  # creating copy of A as well\\n\\n        push, pop = (stk := deque()).append, stk.pop\\n\\n        def top():\\n            return A[stk[-1]] if stk else inf\\n\\n        output = 0\\n\\n        for i, a in enumerate(A):\\n            while top() < a:\\n                j = pop()\\n\\n                right = i - j\\n                left = j - (stk[-1] if stk else -1)\\n\\n                output += A[j] * left * right\\n\\n            push(i)\\n\\n        return output\\n\\n    @staticmethod\\n    def min_of_subarrays(A: list[int]) -> int:\\n        A = A + [-inf]\\n\\n        push, pop = (stk := deque()).append, stk.pop\\n\\n        def top():\\n            return A[stk[-1]] if stk else -inf\\n\\n        output = 0\\n\\n        for i, a in enumerate(A):\\n            while top() > a:\\n                j = pop()\\n                right = i - j\\n\\n                left = j - (stk[-1] if stk else -1)\\n\\n                output += A[j] * left * right\\n\\n            push(i)\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060271,
                "title": "bruteforce-nive-solution-just-85-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {/*\\n        long max = Integer.MIN_VALUE;\\n        long min = Integer.MAX_VALUE;\\n\\n        int sum_max=0, sum_min=0;\\n        for(int i=0; i<nums.length; i++){\\n            max = Math.max(max, nums[i]);\\n            min = Math.min(min, nums[i]);\\n\\n            sum_max +=max;\\n            sum_min +=min;\\n        }\\n\\n        return sum_max-sum_min;\\n*/\\n        long res=0;\\n        for(int i=0; i<nums.length; i++){\\n            int smallest = nums[i];\\n            int largest = nums[i];\\n            for(int j=i+1; j<nums.length; j++){\\n                smallest = Math.min(smallest, nums[j]);\\n                largest = Math.max(largest, nums[j]);\\n\\n                res += (largest-smallest);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {/*\\n        long max = Integer.MIN_VALUE;\\n        long min = Integer.MAX_VALUE;\\n\\n        int sum_max=0, sum_min=0;\\n        for(int i=0; i<nums.length; i++){\\n            max = Math.max(max, nums[i]);\\n            min = Math.min(min, nums[i]);\\n\\n            sum_max +=max;\\n            sum_min +=min;\\n        }\\n\\n        return sum_max-sum_min;\\n*/\\n        long res=0;\\n        for(int i=0; i<nums.length; i++){\\n            int smallest = nums[i];\\n            int largest = nums[i];\\n            for(int j=i+1; j<nums.length; j++){\\n                smallest = Math.min(smallest, nums[j]);\\n                largest = Math.max(largest, nums[j]);\\n\\n                res += (largest-smallest);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058827,
                "title": "stack-solution-o-n",
                "content": "\\n```\\nclass Solution {\\n    vector<int> nextSmaller(vector<int> &nums)\\n    {\\n        vector<int> result(nums.size());\\n        stack<int> st;\\n        \\n        for(int i = nums.size() - 1; i >= 0; i--)\\n        {\\n            int currElement = nums[i];\\n\\n            while(!st.empty() && nums[st.top()] >= currElement)\\n            {\\n                st.pop();\\n            }\\n\\n            if(st.empty())\\n            {\\n                result[i] = -1;\\n            }\\n            else{\\n                result[i] = st.top();\\n            }\\n\\n            st.push(i);\\n        }\\n\\n        return result;\\n    }\\n\\n    vector<int> prevSmaller(vector<int> &nums)\\n    {\\n        vector<int> result(nums.size());\\n        stack<int> st;\\n        \\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            int currElement = nums[i];\\n\\n            while(!st.empty() && nums[st.top()] > currElement)\\n            {\\n                st.pop();\\n            }\\n\\n            if(st.empty())\\n            {\\n                result[i] = -1;\\n            }\\n            else{\\n                result[i] = st.top();\\n            }\\n\\n            st.push(i);\\n        }\\n\\n        return result;\\n    }\\n\\n    vector<int> nextGreater(vector<int> &nums)\\n    {\\n        vector<int> result(nums.size());\\n        stack<int> st;\\n        \\n        for(int i = nums.size() - 1; i >= 0; i--)\\n        {\\n            int currElement = nums[i];\\n\\n            while(!st.empty() && nums[st.top()] <= currElement)\\n            {\\n                st.pop();\\n            }\\n\\n            if(st.empty())\\n            {\\n                result[i] = -1;\\n            }\\n            else{\\n                result[i] = st.top();\\n            }\\n\\n            st.push(i);\\n        }\\n\\n        return result;\\n    }\\n\\n    vector<int> prevGreater(vector<int> &nums)\\n    {\\n        vector<int> result(nums.size());\\n        stack<int> st;\\n        \\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            int currElement = nums[i];\\n\\n            while(!st.empty() && nums[st.top()] < currElement)\\n            {\\n                st.pop();\\n            }\\n\\n            if(st.empty())\\n            {\\n                result[i] = -1;\\n            }\\n            else{\\n                result[i] = st.top();\\n            }\\n\\n            st.push(i);\\n        }\\n\\n        return result;\\n    }\\n\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        \\n        vector<int> nextS = nextSmaller(nums);\\n        vector<int> prevS = prevSmaller(nums);\\n\\n        vector<int> nextG = nextGreater(nums);\\n        vector<int> prevG = prevGreater(nums);\\n\\n        long long int rangeSum = 0;\\n\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            int currElement = nums[i];\\n\\n            // Calculating count of subarray in which \"nums[i]\" is a minimum element. \\n            long long int nextSmallerIdx, prevSmallerIdx;\\n            if(nextS[i] == -1)\\n            {\\n                nextSmallerIdx = nums.size() - i - 1;\\n            }\\n            else{\\n                nextSmallerIdx = nextS[i] - i - 1;\\n            }\\n\\n            if(prevS[i] == -1)\\n            {\\n                prevSmallerIdx = i;\\n            }\\n            else{\\n                prevSmallerIdx = i - prevS[i] - 1;\\n            }\\n\\n            long long int totalSubarrays_Min = (prevSmallerIdx + 1) * (nextSmallerIdx + 1);\\n\\n            // Calculating count of subarray in which \"nums[i]\" is a maximum element. \\n            long long int nextGreaterIdx, prevGreaterIdx;\\n            if(nextG[i] == -1)\\n            {\\n                nextGreaterIdx = nums.size() - i - 1;\\n            }\\n            else{\\n                nextGreaterIdx = nextG[i] - i - 1;\\n            }\\n\\n            if(prevG[i] == -1)\\n            {\\n                prevGreaterIdx = i;\\n            }\\n            else{\\n                prevGreaterIdx = i - prevG[i] - 1;\\n            }\\n\\n            long long int totalSubarrays_Max = (prevGreaterIdx + 1) * (nextGreaterIdx + 1);\\n\\n            // Calculating sum of ranges.\\n            rangeSum += (currElement * totalSubarrays_Max) - (currElement * totalSubarrays_Min);\\n\\n        }\\n\\n        return rangeSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> nextSmaller(vector<int> &nums)\\n    {\\n        vector<int> result(nums.size());\\n        stack<int> st;\\n        \\n        for(int i = nums.size() - 1; i >= 0; i--)\\n        {\\n            int currElement = nums[i];\\n\\n            while(!st.empty() && nums[st.top()] >= currElement)\\n            {\\n                st.pop();\\n            }\\n\\n            if(st.empty())\\n            {\\n                result[i] = -1;\\n            }\\n            else{\\n                result[i] = st.top();\\n            }\\n\\n            st.push(i);\\n        }\\n\\n        return result;\\n    }\\n\\n    vector<int> prevSmaller(vector<int> &nums)\\n    {\\n        vector<int> result(nums.size());\\n        stack<int> st;\\n        \\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            int currElement = nums[i];\\n\\n            while(!st.empty() && nums[st.top()] > currElement)\\n            {\\n                st.pop();\\n            }\\n\\n            if(st.empty())\\n            {\\n                result[i] = -1;\\n            }\\n            else{\\n                result[i] = st.top();\\n            }\\n\\n            st.push(i);\\n        }\\n\\n        return result;\\n    }\\n\\n    vector<int> nextGreater(vector<int> &nums)\\n    {\\n        vector<int> result(nums.size());\\n        stack<int> st;\\n        \\n        for(int i = nums.size() - 1; i >= 0; i--)\\n        {\\n            int currElement = nums[i];\\n\\n            while(!st.empty() && nums[st.top()] <= currElement)\\n            {\\n                st.pop();\\n            }\\n\\n            if(st.empty())\\n            {\\n                result[i] = -1;\\n            }\\n            else{\\n                result[i] = st.top();\\n            }\\n\\n            st.push(i);\\n        }\\n\\n        return result;\\n    }\\n\\n    vector<int> prevGreater(vector<int> &nums)\\n    {\\n        vector<int> result(nums.size());\\n        stack<int> st;\\n        \\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            int currElement = nums[i];\\n\\n            while(!st.empty() && nums[st.top()] < currElement)\\n            {\\n                st.pop();\\n            }\\n\\n            if(st.empty())\\n            {\\n                result[i] = -1;\\n            }\\n            else{\\n                result[i] = st.top();\\n            }\\n\\n            st.push(i);\\n        }\\n\\n        return result;\\n    }\\n\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        \\n        vector<int> nextS = nextSmaller(nums);\\n        vector<int> prevS = prevSmaller(nums);\\n\\n        vector<int> nextG = nextGreater(nums);\\n        vector<int> prevG = prevGreater(nums);\\n\\n        long long int rangeSum = 0;\\n\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            int currElement = nums[i];\\n\\n            // Calculating count of subarray in which \"nums[i]\" is a minimum element. \\n            long long int nextSmallerIdx, prevSmallerIdx;\\n            if(nextS[i] == -1)\\n            {\\n                nextSmallerIdx = nums.size() - i - 1;\\n            }\\n            else{\\n                nextSmallerIdx = nextS[i] - i - 1;\\n            }\\n\\n            if(prevS[i] == -1)\\n            {\\n                prevSmallerIdx = i;\\n            }\\n            else{\\n                prevSmallerIdx = i - prevS[i] - 1;\\n            }\\n\\n            long long int totalSubarrays_Min = (prevSmallerIdx + 1) * (nextSmallerIdx + 1);\\n\\n            // Calculating count of subarray in which \"nums[i]\" is a maximum element. \\n            long long int nextGreaterIdx, prevGreaterIdx;\\n            if(nextG[i] == -1)\\n            {\\n                nextGreaterIdx = nums.size() - i - 1;\\n            }\\n            else{\\n                nextGreaterIdx = nextG[i] - i - 1;\\n            }\\n\\n            if(prevG[i] == -1)\\n            {\\n                prevGreaterIdx = i;\\n            }\\n            else{\\n                prevGreaterIdx = i - prevG[i] - 1;\\n            }\\n\\n            long long int totalSubarrays_Max = (prevGreaterIdx + 1) * (nextGreaterIdx + 1);\\n\\n            // Calculating sum of ranges.\\n            rangeSum += (currElement * totalSubarrays_Max) - (currElement * totalSubarrays_Min);\\n\\n        }\\n\\n        return rangeSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041350,
                "title": "stack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        long long sum=0;\\n        stack<int>st;\\n        int n=nums.size();\\n        vector<int> l(n,-1);\\n        vector<int>r(n,n);\\n        for(int i=0;i<n;i++){\\n            while(!st.empty()&&nums[st.top()]>=nums[i]){\\n                st.pop();\\n            }\\n\\n           if(!st.empty()){\\n               l[i]=st.top();\\n           }\\n           st.push(i);\\n        }\\n        while(!st.empty()){\\n            st.pop();\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            while(!st.empty()&&nums[st.top()]>nums[i]){\\n                st.pop();\\n            }\\n           if(!st.empty()){\\n               r[i]=st.top();\\n           }\\n           st.push(i);\\n        }\\n vector<int> lm(n,-1);\\n        vector<int>rm(n,n);\\n        for(int i=0;i<n;i++){\\n            while(!st.empty()&&nums[st.top()]<=nums[i]){\\n                st.pop();\\n            }\\n\\n           if(!st.empty()){\\n               lm[i]=st.top();\\n           }\\n           st.push(i);\\n        }\\n        while(!st.empty()){\\n            st.pop();\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            while(!st.empty()&&nums[st.top()]<nums[i]){\\n                st.pop();\\n            }\\n           if(!st.empty()){\\n               rm[i]=st.top();\\n           }\\n           st.push(i);\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            long long lmin=i-l[i],rmin=r[i]-i;\\n             long long lmax=i-lm[i],rmax=rm[i]-i;\\n             sum+=(lmax*rmax-lmin*rmin)*nums[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long subArrayRanges(vector<int>& nums) {\\n        long long sum=0;\\n        stack<int>st;\\n        int n=nums.size();\\n        vector<int> l(n,-1);\\n        vector<int>r(n,n);\\n        for(int i=0;i<n;i++){\\n            while(!st.empty()&&nums[st.top()]>=nums[i]){\\n                st.pop();\\n            }\\n\\n           if(!st.empty()){\\n               l[i]=st.top();\\n           }\\n           st.push(i);\\n        }\\n        while(!st.empty()){\\n            st.pop();\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            while(!st.empty()&&nums[st.top()]>nums[i]){\\n                st.pop();\\n            }\\n           if(!st.empty()){\\n               r[i]=st.top();\\n           }\\n           st.push(i);\\n        }\\n vector<int> lm(n,-1);\\n        vector<int>rm(n,n);\\n        for(int i=0;i<n;i++){\\n            while(!st.empty()&&nums[st.top()]<=nums[i]){\\n                st.pop();\\n            }\\n\\n           if(!st.empty()){\\n               lm[i]=st.top();\\n           }\\n           st.push(i);\\n        }\\n        while(!st.empty()){\\n            st.pop();\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            while(!st.empty()&&nums[st.top()]<nums[i]){\\n                st.pop();\\n            }\\n           if(!st.empty()){\\n               rm[i]=st.top();\\n           }\\n           st.push(i);\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            long long lmin=i-l[i],rmin=r[i]-i;\\n             long long lmax=i-lm[i],rmax=rm[i]-i;\\n             sum+=(lmax*rmax-lmin*rmin)*nums[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037184,
                "title": "java-15ms-90-and-clean-code",
                "content": "# Approach\\n1. Due to size constraints, (1000 elements) we could try an n * n / 2 time complexity.\\n2. Using two nested for i [0,n-2] and j [i+1, n-1], determine the min/max of the expanding segment [i,j]\\n3. Calculate their sum and add it to a global variable\\n4. Return the sum.\\n\\n# Complexity\\n- Time complexity:$$O(n^2 / 2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        long sum = 0;\\n        int min, max, i, j;\\n        for (i = 0; i < nums.length - 1; i++) {\\n            min = nums[i];\\n            max = nums[i];\\n            for (j = i + 1; j < nums.length; j++) {\\n                min = Math.min(min, nums[j]);\\n                max = Math.max(max, nums[j]);\\n                sum += (max - min);\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long subArrayRanges(int[] nums) {\\n        long sum = 0;\\n        int min, max, i, j;\\n        for (i = 0; i < nums.length - 1; i++) {\\n            min = nums[i];\\n            max = nums[i];\\n            for (j = i + 1; j < nums.length; j++) {\\n                min = Math.min(min, nums[j]);\\n                max = Math.max(max, nums[j]);\\n                sum += (max - min);\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032284,
                "title": "monotonic-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long pushToStack(stack<int>& stack, int i, vector<int> nums, auto comp) {\\n        long sum = 0;\\n        while (!stack.empty() && (i == nums.size() || comp(nums[stack.top()], nums[i]))) {\\n            int pop_e = stack.top(); stack.pop();\\n            int prev_e = stack.empty() ? -1 : stack.top();\\n            sum += (pop_e - prev_e) * (i - pop_e) * (long) nums[pop_e];\\n        }\\n        stack.push(i);\\n        return sum;\\n    }\\n\\n    long long subArrayRanges(vector<int>& nums) {\\n        stack<int> inc_stack;\\n        stack<int> dec_stack;\\n        long sum = 0;\\n        int n = nums.size();\\n        for (int i = 0; i <= n; ++i) {\\n            sum += pushToStack(dec_stack, i, nums, [](int a, int b) -> bool {return a < b;}) \\n                 - pushToStack(inc_stack, i, nums, [](int a, int b) -> bool {return a > b;});\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long pushToStack(stack<int>& stack, int i, vector<int> nums, auto comp) {\\n        long sum = 0;\\n        while (!stack.empty() && (i == nums.size() || comp(nums[stack.top()], nums[i]))) {\\n            int pop_e = stack.top(); stack.pop();\\n            int prev_e = stack.empty() ? -1 : stack.top();\\n            sum += (pop_e - prev_e) * (i - pop_e) * (long) nums[pop_e];\\n        }\\n        stack.push(i);\\n        return sum;\\n    }\\n\\n    long long subArrayRanges(vector<int>& nums) {\\n        stack<int> inc_stack;\\n        stack<int> dec_stack;\\n        long sum = 0;\\n        int n = nums.size();\\n        for (int i = 0; i <= n; ++i) {\\n            sum += pushToStack(dec_stack, i, nums, [](int a, int b) -> bool {return a < b;}) \\n                 - pushToStack(inc_stack, i, nums, [](int a, int b) -> bool {return a > b;});\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1710336,
                "content": [
                    {
                        "username": "HaoTLee",
                        "content": "Must do this first\n907. Sum of Subarray Minimums"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Thanks! I wasn\\'t able to do this question before but after doing these two first, I was able to do all three without help."
                    },
                    {
                        "username": "kevinrawal",
                        "content": "thank you it helps"
                    },
                    {
                        "username": "anthonyche",
                        "content": "I think this one is a hard"
                    },
                    {
                        "username": "Demonnnn3",
                        "content": "Hard..."
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" to get idea of the stack approach used in this problem\\ntry \"sum of subarray minimums\" for a easier version of this problem"
                    },
                    {
                        "username": "Vivek_Parsana",
                        "content": "How is this question rated as a medium?"
                    },
                    {
                        "username": "arijit__12",
                        "content": "How the intuation is coming I\\'m not understanding can anyone help? "
                    },
                    {
                        "username": "Revathy_1995",
                        "content": "In [1,2,3] why [3,1] is not a sub array ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "\"contiguous non-empty sequence\" "
                    },
                    {
                        "username": "culer2024",
                        "content": "If this is genuine question then answer is : because subarrays are contiguous(As you can\\'t leave any element from a range which is { min index of elements present in the set and max index of elements present in the set} , also {3,1} is just a subset. There is difference between subset and subarray. "
                    },
                    {
                        "username": "Ramkaran_Mahato",
                        "content": " Where am i going wrong?\\n\\n    static long subArraySum(int[] nums,long totSum,int start, int end){\\n        if(end == nums.length){\\n            return totSum;\\n        }else if(start > end){\\n            return subArraySum(nums,totSum,0,end+1);\\n        }else{\\n            int i = start;\\n            int smallest = Integer.MAX_VALUE,greatest = Integer.MIN_VALUE;\\n            while(i <= end){\\n                smallest = Math.min(smallest,nums[i]);\\n                greatest = Math.max(greatest,nums[i]);\\n                i++;\\n            }\\n            totSum += greatest-smallest;\\n            return subArraySum(nums,totSum,start+1,end);\\n        }\\n    }\\nIt passes all the testcases, still getting TLE...\\n\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Your complexity is n^3 / 2. Which is (1000 ^3)  / 2.\nHint: if you know the min/max of interval [a,b] then when you move to next index (b+1), just set min/max to be the min/max of min/max and nums[b+1]. You don't need to start from nums[a] to determine the min/max of interval [a..b+1]."
                    },
                    {
                        "username": "roshshub",
                        "content": "because the order is not O(n)"
                    }
                ]
            },
            {
                "id": 1872125,
                "content": [
                    {
                        "username": "HaoTLee",
                        "content": "Must do this first\n907. Sum of Subarray Minimums"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Thanks! I wasn\\'t able to do this question before but after doing these two first, I was able to do all three without help."
                    },
                    {
                        "username": "kevinrawal",
                        "content": "thank you it helps"
                    },
                    {
                        "username": "anthonyche",
                        "content": "I think this one is a hard"
                    },
                    {
                        "username": "Demonnnn3",
                        "content": "Hard..."
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" to get idea of the stack approach used in this problem\\ntry \"sum of subarray minimums\" for a easier version of this problem"
                    },
                    {
                        "username": "Vivek_Parsana",
                        "content": "How is this question rated as a medium?"
                    },
                    {
                        "username": "arijit__12",
                        "content": "How the intuation is coming I\\'m not understanding can anyone help? "
                    },
                    {
                        "username": "Revathy_1995",
                        "content": "In [1,2,3] why [3,1] is not a sub array ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "\"contiguous non-empty sequence\" "
                    },
                    {
                        "username": "culer2024",
                        "content": "If this is genuine question then answer is : because subarrays are contiguous(As you can\\'t leave any element from a range which is { min index of elements present in the set and max index of elements present in the set} , also {3,1} is just a subset. There is difference between subset and subarray. "
                    },
                    {
                        "username": "Ramkaran_Mahato",
                        "content": " Where am i going wrong?\\n\\n    static long subArraySum(int[] nums,long totSum,int start, int end){\\n        if(end == nums.length){\\n            return totSum;\\n        }else if(start > end){\\n            return subArraySum(nums,totSum,0,end+1);\\n        }else{\\n            int i = start;\\n            int smallest = Integer.MAX_VALUE,greatest = Integer.MIN_VALUE;\\n            while(i <= end){\\n                smallest = Math.min(smallest,nums[i]);\\n                greatest = Math.max(greatest,nums[i]);\\n                i++;\\n            }\\n            totSum += greatest-smallest;\\n            return subArraySum(nums,totSum,start+1,end);\\n        }\\n    }\\nIt passes all the testcases, still getting TLE...\\n\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Your complexity is n^3 / 2. Which is (1000 ^3)  / 2.\nHint: if you know the min/max of interval [a,b] then when you move to next index (b+1), just set min/max to be the min/max of min/max and nums[b+1]. You don't need to start from nums[a] to determine the min/max of interval [a..b+1]."
                    },
                    {
                        "username": "roshshub",
                        "content": "because the order is not O(n)"
                    }
                ]
            },
            {
                "id": 1847644,
                "content": [
                    {
                        "username": "HaoTLee",
                        "content": "Must do this first\n907. Sum of Subarray Minimums"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Thanks! I wasn\\'t able to do this question before but after doing these two first, I was able to do all three without help."
                    },
                    {
                        "username": "kevinrawal",
                        "content": "thank you it helps"
                    },
                    {
                        "username": "anthonyche",
                        "content": "I think this one is a hard"
                    },
                    {
                        "username": "Demonnnn3",
                        "content": "Hard..."
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" to get idea of the stack approach used in this problem\\ntry \"sum of subarray minimums\" for a easier version of this problem"
                    },
                    {
                        "username": "Vivek_Parsana",
                        "content": "How is this question rated as a medium?"
                    },
                    {
                        "username": "arijit__12",
                        "content": "How the intuation is coming I\\'m not understanding can anyone help? "
                    },
                    {
                        "username": "Revathy_1995",
                        "content": "In [1,2,3] why [3,1] is not a sub array ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "\"contiguous non-empty sequence\" "
                    },
                    {
                        "username": "culer2024",
                        "content": "If this is genuine question then answer is : because subarrays are contiguous(As you can\\'t leave any element from a range which is { min index of elements present in the set and max index of elements present in the set} , also {3,1} is just a subset. There is difference between subset and subarray. "
                    },
                    {
                        "username": "Ramkaran_Mahato",
                        "content": " Where am i going wrong?\\n\\n    static long subArraySum(int[] nums,long totSum,int start, int end){\\n        if(end == nums.length){\\n            return totSum;\\n        }else if(start > end){\\n            return subArraySum(nums,totSum,0,end+1);\\n        }else{\\n            int i = start;\\n            int smallest = Integer.MAX_VALUE,greatest = Integer.MIN_VALUE;\\n            while(i <= end){\\n                smallest = Math.min(smallest,nums[i]);\\n                greatest = Math.max(greatest,nums[i]);\\n                i++;\\n            }\\n            totSum += greatest-smallest;\\n            return subArraySum(nums,totSum,start+1,end);\\n        }\\n    }\\nIt passes all the testcases, still getting TLE...\\n\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Your complexity is n^3 / 2. Which is (1000 ^3)  / 2.\nHint: if you know the min/max of interval [a,b] then when you move to next index (b+1), just set min/max to be the min/max of min/max and nums[b+1]. You don't need to start from nums[a] to determine the min/max of interval [a..b+1]."
                    },
                    {
                        "username": "roshshub",
                        "content": "because the order is not O(n)"
                    }
                ]
            },
            {
                "id": 1894939,
                "content": [
                    {
                        "username": "HaoTLee",
                        "content": "Must do this first\n907. Sum of Subarray Minimums"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Thanks! I wasn\\'t able to do this question before but after doing these two first, I was able to do all three without help."
                    },
                    {
                        "username": "kevinrawal",
                        "content": "thank you it helps"
                    },
                    {
                        "username": "anthonyche",
                        "content": "I think this one is a hard"
                    },
                    {
                        "username": "Demonnnn3",
                        "content": "Hard..."
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" to get idea of the stack approach used in this problem\\ntry \"sum of subarray minimums\" for a easier version of this problem"
                    },
                    {
                        "username": "Vivek_Parsana",
                        "content": "How is this question rated as a medium?"
                    },
                    {
                        "username": "arijit__12",
                        "content": "How the intuation is coming I\\'m not understanding can anyone help? "
                    },
                    {
                        "username": "Revathy_1995",
                        "content": "In [1,2,3] why [3,1] is not a sub array ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "\"contiguous non-empty sequence\" "
                    },
                    {
                        "username": "culer2024",
                        "content": "If this is genuine question then answer is : because subarrays are contiguous(As you can\\'t leave any element from a range which is { min index of elements present in the set and max index of elements present in the set} , also {3,1} is just a subset. There is difference between subset and subarray. "
                    },
                    {
                        "username": "Ramkaran_Mahato",
                        "content": " Where am i going wrong?\\n\\n    static long subArraySum(int[] nums,long totSum,int start, int end){\\n        if(end == nums.length){\\n            return totSum;\\n        }else if(start > end){\\n            return subArraySum(nums,totSum,0,end+1);\\n        }else{\\n            int i = start;\\n            int smallest = Integer.MAX_VALUE,greatest = Integer.MIN_VALUE;\\n            while(i <= end){\\n                smallest = Math.min(smallest,nums[i]);\\n                greatest = Math.max(greatest,nums[i]);\\n                i++;\\n            }\\n            totSum += greatest-smallest;\\n            return subArraySum(nums,totSum,start+1,end);\\n        }\\n    }\\nIt passes all the testcases, still getting TLE...\\n\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Your complexity is n^3 / 2. Which is (1000 ^3)  / 2.\nHint: if you know the min/max of interval [a,b] then when you move to next index (b+1), just set min/max to be the min/max of min/max and nums[b+1]. You don't need to start from nums[a] to determine the min/max of interval [a..b+1]."
                    },
                    {
                        "username": "roshshub",
                        "content": "because the order is not O(n)"
                    }
                ]
            },
            {
                "id": 1999964,
                "content": [
                    {
                        "username": "HaoTLee",
                        "content": "Must do this first\n907. Sum of Subarray Minimums"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Thanks! I wasn\\'t able to do this question before but after doing these two first, I was able to do all three without help."
                    },
                    {
                        "username": "kevinrawal",
                        "content": "thank you it helps"
                    },
                    {
                        "username": "anthonyche",
                        "content": "I think this one is a hard"
                    },
                    {
                        "username": "Demonnnn3",
                        "content": "Hard..."
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" to get idea of the stack approach used in this problem\\ntry \"sum of subarray minimums\" for a easier version of this problem"
                    },
                    {
                        "username": "Vivek_Parsana",
                        "content": "How is this question rated as a medium?"
                    },
                    {
                        "username": "arijit__12",
                        "content": "How the intuation is coming I\\'m not understanding can anyone help? "
                    },
                    {
                        "username": "Revathy_1995",
                        "content": "In [1,2,3] why [3,1] is not a sub array ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "\"contiguous non-empty sequence\" "
                    },
                    {
                        "username": "culer2024",
                        "content": "If this is genuine question then answer is : because subarrays are contiguous(As you can\\'t leave any element from a range which is { min index of elements present in the set and max index of elements present in the set} , also {3,1} is just a subset. There is difference between subset and subarray. "
                    },
                    {
                        "username": "Ramkaran_Mahato",
                        "content": " Where am i going wrong?\\n\\n    static long subArraySum(int[] nums,long totSum,int start, int end){\\n        if(end == nums.length){\\n            return totSum;\\n        }else if(start > end){\\n            return subArraySum(nums,totSum,0,end+1);\\n        }else{\\n            int i = start;\\n            int smallest = Integer.MAX_VALUE,greatest = Integer.MIN_VALUE;\\n            while(i <= end){\\n                smallest = Math.min(smallest,nums[i]);\\n                greatest = Math.max(greatest,nums[i]);\\n                i++;\\n            }\\n            totSum += greatest-smallest;\\n            return subArraySum(nums,totSum,start+1,end);\\n        }\\n    }\\nIt passes all the testcases, still getting TLE...\\n\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Your complexity is n^3 / 2. Which is (1000 ^3)  / 2.\nHint: if you know the min/max of interval [a,b] then when you move to next index (b+1), just set min/max to be the min/max of min/max and nums[b+1]. You don't need to start from nums[a] to determine the min/max of interval [a..b+1]."
                    },
                    {
                        "username": "roshshub",
                        "content": "because the order is not O(n)"
                    }
                ]
            },
            {
                "id": 2068477,
                "content": [
                    {
                        "username": "HaoTLee",
                        "content": "Must do this first\n907. Sum of Subarray Minimums"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Thanks! I wasn\\'t able to do this question before but after doing these two first, I was able to do all three without help."
                    },
                    {
                        "username": "kevinrawal",
                        "content": "thank you it helps"
                    },
                    {
                        "username": "anthonyche",
                        "content": "I think this one is a hard"
                    },
                    {
                        "username": "Demonnnn3",
                        "content": "Hard..."
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" to get idea of the stack approach used in this problem\\ntry \"sum of subarray minimums\" for a easier version of this problem"
                    },
                    {
                        "username": "Vivek_Parsana",
                        "content": "How is this question rated as a medium?"
                    },
                    {
                        "username": "arijit__12",
                        "content": "How the intuation is coming I\\'m not understanding can anyone help? "
                    },
                    {
                        "username": "Revathy_1995",
                        "content": "In [1,2,3] why [3,1] is not a sub array ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "\"contiguous non-empty sequence\" "
                    },
                    {
                        "username": "culer2024",
                        "content": "If this is genuine question then answer is : because subarrays are contiguous(As you can\\'t leave any element from a range which is { min index of elements present in the set and max index of elements present in the set} , also {3,1} is just a subset. There is difference between subset and subarray. "
                    },
                    {
                        "username": "Ramkaran_Mahato",
                        "content": " Where am i going wrong?\\n\\n    static long subArraySum(int[] nums,long totSum,int start, int end){\\n        if(end == nums.length){\\n            return totSum;\\n        }else if(start > end){\\n            return subArraySum(nums,totSum,0,end+1);\\n        }else{\\n            int i = start;\\n            int smallest = Integer.MAX_VALUE,greatest = Integer.MIN_VALUE;\\n            while(i <= end){\\n                smallest = Math.min(smallest,nums[i]);\\n                greatest = Math.max(greatest,nums[i]);\\n                i++;\\n            }\\n            totSum += greatest-smallest;\\n            return subArraySum(nums,totSum,start+1,end);\\n        }\\n    }\\nIt passes all the testcases, still getting TLE...\\n\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Your complexity is n^3 / 2. Which is (1000 ^3)  / 2.\nHint: if you know the min/max of interval [a,b] then when you move to next index (b+1), just set min/max to be the min/max of min/max and nums[b+1]. You don't need to start from nums[a] to determine the min/max of interval [a..b+1]."
                    },
                    {
                        "username": "roshshub",
                        "content": "because the order is not O(n)"
                    }
                ]
            },
            {
                "id": 2041272,
                "content": [
                    {
                        "username": "HaoTLee",
                        "content": "Must do this first\n907. Sum of Subarray Minimums"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Thanks! I wasn\\'t able to do this question before but after doing these two first, I was able to do all three without help."
                    },
                    {
                        "username": "kevinrawal",
                        "content": "thank you it helps"
                    },
                    {
                        "username": "anthonyche",
                        "content": "I think this one is a hard"
                    },
                    {
                        "username": "Demonnnn3",
                        "content": "Hard..."
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" to get idea of the stack approach used in this problem\\ntry \"sum of subarray minimums\" for a easier version of this problem"
                    },
                    {
                        "username": "Vivek_Parsana",
                        "content": "How is this question rated as a medium?"
                    },
                    {
                        "username": "arijit__12",
                        "content": "How the intuation is coming I\\'m not understanding can anyone help? "
                    },
                    {
                        "username": "Revathy_1995",
                        "content": "In [1,2,3] why [3,1] is not a sub array ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "\"contiguous non-empty sequence\" "
                    },
                    {
                        "username": "culer2024",
                        "content": "If this is genuine question then answer is : because subarrays are contiguous(As you can\\'t leave any element from a range which is { min index of elements present in the set and max index of elements present in the set} , also {3,1} is just a subset. There is difference between subset and subarray. "
                    },
                    {
                        "username": "Ramkaran_Mahato",
                        "content": " Where am i going wrong?\\n\\n    static long subArraySum(int[] nums,long totSum,int start, int end){\\n        if(end == nums.length){\\n            return totSum;\\n        }else if(start > end){\\n            return subArraySum(nums,totSum,0,end+1);\\n        }else{\\n            int i = start;\\n            int smallest = Integer.MAX_VALUE,greatest = Integer.MIN_VALUE;\\n            while(i <= end){\\n                smallest = Math.min(smallest,nums[i]);\\n                greatest = Math.max(greatest,nums[i]);\\n                i++;\\n            }\\n            totSum += greatest-smallest;\\n            return subArraySum(nums,totSum,start+1,end);\\n        }\\n    }\\nIt passes all the testcases, still getting TLE...\\n\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Your complexity is n^3 / 2. Which is (1000 ^3)  / 2.\nHint: if you know the min/max of interval [a,b] then when you move to next index (b+1), just set min/max to be the min/max of min/max and nums[b+1]. You don't need to start from nums[a] to determine the min/max of interval [a..b+1]."
                    },
                    {
                        "username": "roshshub",
                        "content": "because the order is not O(n)"
                    }
                ]
            },
            {
                "id": 1760013,
                "content": [
                    {
                        "username": "HaoTLee",
                        "content": "Must do this first\n907. Sum of Subarray Minimums"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Thanks! I wasn\\'t able to do this question before but after doing these two first, I was able to do all three without help."
                    },
                    {
                        "username": "kevinrawal",
                        "content": "thank you it helps"
                    },
                    {
                        "username": "anthonyche",
                        "content": "I think this one is a hard"
                    },
                    {
                        "username": "Demonnnn3",
                        "content": "Hard..."
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" to get idea of the stack approach used in this problem\\ntry \"sum of subarray minimums\" for a easier version of this problem"
                    },
                    {
                        "username": "Vivek_Parsana",
                        "content": "How is this question rated as a medium?"
                    },
                    {
                        "username": "arijit__12",
                        "content": "How the intuation is coming I\\'m not understanding can anyone help? "
                    },
                    {
                        "username": "Revathy_1995",
                        "content": "In [1,2,3] why [3,1] is not a sub array ?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "\"contiguous non-empty sequence\" "
                    },
                    {
                        "username": "culer2024",
                        "content": "If this is genuine question then answer is : because subarrays are contiguous(As you can\\'t leave any element from a range which is { min index of elements present in the set and max index of elements present in the set} , also {3,1} is just a subset. There is difference between subset and subarray. "
                    },
                    {
                        "username": "Ramkaran_Mahato",
                        "content": " Where am i going wrong?\\n\\n    static long subArraySum(int[] nums,long totSum,int start, int end){\\n        if(end == nums.length){\\n            return totSum;\\n        }else if(start > end){\\n            return subArraySum(nums,totSum,0,end+1);\\n        }else{\\n            int i = start;\\n            int smallest = Integer.MAX_VALUE,greatest = Integer.MIN_VALUE;\\n            while(i <= end){\\n                smallest = Math.min(smallest,nums[i]);\\n                greatest = Math.max(greatest,nums[i]);\\n                i++;\\n            }\\n            totSum += greatest-smallest;\\n            return subArraySum(nums,totSum,start+1,end);\\n        }\\n    }\\nIt passes all the testcases, still getting TLE...\\n\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Your complexity is n^3 / 2. Which is (1000 ^3)  / 2.\nHint: if you know the min/max of interval [a,b] then when you move to next index (b+1), just set min/max to be the min/max of min/max and nums[b+1]. You don't need to start from nums[a] to determine the min/max of interval [a..b+1]."
                    },
                    {
                        "username": "roshshub",
                        "content": "because the order is not O(n)"
                    }
                ]
            }
        ]
    }
]