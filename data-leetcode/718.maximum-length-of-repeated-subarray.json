[
    {
        "title": "Ugly Number",
        "question_content": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\nGiven an integer n, return true if n is an ugly number.\n&nbsp;\nExample 1:\n\nInput: n = 6\nOutput: true\nExplanation: 6 = 2 &times; 3\n\nExample 2:\n\nInput: n = 1\nOutput: true\nExplanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n\nExample 3:\n\nInput: n = 14\nOutput: false\nExplanation: 14 is not ugly since it includes the prime factor 7.\n\n&nbsp;\nConstraints:\n\n\t-231 <= n <= 231 - 1",
        "solutions": [
            {
                "id": 69214,
                "title": "2-4-lines-every-language",
                "content": "Just divide by 2, 3 and 5 as often as possible and then check whether we arrived at 1. Also try divisor 4 if that makes the code simpler / less repetitive.\\n\\n**C++ / C**\\n\\n    for (int i=2; i<6 && num; i++)\\n        while (num % i == 0)\\n            num /= i;\\n    return num == 1;\\n\\n**Ruby**\\n\\n    (2..5).each { |i| num /= i while num % i == 0 } if num > 0\\n    num == 1\\n\\nOr:\\n\\n    require 'prime'\\n    num > 0 && num.prime_division.all? { |p, _| p < 6 }\\n\\n**Python**\\n\\n    for p in 2, 3, 5:\\n        while num % p == 0 < num:\\n            num /= p\\n    return num == 1\\n\\n**Java / C#**\\n\\n    for (int i=2; i<6 && num>0; i++)\\n        while (num % i == 0)\\n            num /= i;\\n    return num == 1;\\n\\n**Javascript**\\n\\n    for (var p of [2, 3, 5])\\n        while (num && num % p == 0)\\n            num /= p;\\n    return num == 1;\\n\\n---\\n\\n**General**\\n\\nWould be a bit cleaner if I did the zero-test outside, and discarding negative numbers right away can speed things up a little, but meh... I don't want to add another line and indentation level :-)\\n\\n    if (num > 0)\\n        for (int i=2; i<6; i++)\\n            while (num % i == 0)\\n                num /= i;\\n    return num == 1;",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "Just divide by 2, 3 and 5 as often as possible and then check whether we arrived at 1. Also try divisor 4 if that makes the code simpler / less repetitive.\\n\\n**C++ / C**\\n\\n    for (int i=2; i<6 && num; i++)\\n        while (num % i == 0)\\n            num /= i;\\n    return num == 1;\\n\\n**Ruby**\\n\\n    (2..5).each { |i| num /= i while num % i == 0 } if num > 0\\n    num == 1\\n\\nOr:\\n\\n    require 'prime'\\n    num > 0 && num.prime_division.all? { |p, _| p < 6 }\\n\\n**Python**\\n\\n    for p in 2, 3, 5:\\n        while num % p == 0 < num:\\n            num /= p\\n    return num == 1\\n\\n**Java / C#**\\n\\n    for (int i=2; i<6 && num>0; i++)\\n        while (num % i == 0)\\n            num /= i;\\n    return num == 1;\\n\\n**Javascript**\\n\\n    for (var p of [2, 3, 5])\\n        while (num && num % p == 0)\\n            num /= p;\\n    return num == 1;\\n\\n---\\n\\n**General**\\n\\nWould be a bit cleaner if I did the zero-test outside, and discarding negative numbers right away can speed things up a little, but meh... I don't want to add another line and indentation level :-)\\n\\n    if (num > 0)\\n        for (int i=2; i<6; i++)\\n            while (num % i == 0)\\n                num /= i;\\n    return num == 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 69225,
                "title": "my-2ms-java-solution",
                "content": "    public boolean isUgly(int num) {\\n        if(num==1) return true;\\n        if(num==0) return false;\\n    \\twhile(num%2==0) num=num>>1;\\n    \\twhile(num%3==0) num=num/3;\\n    \\twhile(num%5==0) num=num/5;\\n        return num==1;\\n    }",
                "solutionTags": [],
                "code": "    public boolean isUgly(int num) {\\n        if(num==1) return true;\\n        if(num==0) return false;\\n    \\twhile(num%2==0) num=num>>1;\\n    \\twhile(num%3==0) num=num/3;\\n    \\twhile(num%5==0) num=num/5;\\n        return num==1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2825504,
                "title": "python3-one-liner-o-1",
                "content": "**Supper cool O(1) one-liner** from [chuilinux](https://leetcode.com/problems/ugly-number/discuss/69232/Python%3A-1-line-solution)\\n```python\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        return False if n<=0 else (2*3*5)**32 % n == 0\\n```\\n\\n**A normal O(log N) algorithm:**\\n(1) ```n``` needs to be a positive integer, so return False ```if n<=0```.\\n(2) divide ```n``` by ```2,3,5``` as much as possible to see if there are any other prime factor left.\\n**Time complexity:** O (log n) since there are at most log n divisions.\\n\\n```python\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n<=0: return False\\n        while n%2==0: n/=2\\n        while n%3==0: n/=3\\n        while n%5==0: n/=5\\n        return n==1\\n```\\n\\n**Skip the iteration for 2**, and check if ```n``` is the power of 2 at the end.\\n```python\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n<=0: return False\\n        while n%3==0: n//=3\\n        while n%5==0: n//=5\\n        return ( n & (n-1) ) == 0\\n```\\n\\n**O(logN\\\\*logN\\\\*logN)** To make it more inefficient and longer.\\n```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n<=0: return False\\n        @cache\\n        def dfs(cur):\\n            if cur==n: return True\\n            if cur>n: return False\\n            for k in (5,3,2):\\n                if dfs(cur*k): return True\\n        return dfs(1)\\n```\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        return False if n<=0 else (2*3*5)**32 % n == 0\\n```\n```n```\n```if n<=0```\n```n```\n```2,3,5```\n```python\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n<=0: return False\\n        while n%2==0: n/=2\\n        while n%3==0: n/=3\\n        while n%5==0: n/=5\\n        return n==1\\n```\n```n```\n```python\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n<=0: return False\\n        while n%3==0: n//=3\\n        while n%5==0: n//=5\\n        return ( n & (n-1) ) == 0\\n```\n```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n<=0: return False\\n        @cache\\n        def dfs(cur):\\n            if cur==n: return True\\n            if cur>n: return False\\n            for k in (5,3,2):\\n                if dfs(cur*k): return True\\n        return dfs(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825523,
                "title": "c-easy-to-understand-explained",
                "content": "![image](https://assets.leetcode.com/users/images/05372639-7b10-4a4b-adb9-d37e8dd7d302_1668731694.9255648.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) \\n    {\\n        if (n <= 0) return false;\\n        while(n > 1)\\n        {\\n            if (n % 2 == 0) n = n / 2;\\n            else if (n % 3 == 0) n = n / 3;\\n            else if (n % 5 == 0) n = n / 5;\\n            else break;\\n        }\\n        return (n == 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) \\n    {\\n        if (n <= 0) return false;\\n        while(n > 1)\\n        {\\n            if (n % 2 == 0) n = n / 2;\\n            else if (n % 3 == 0) n = n / 3;\\n            else if (n % 5 == 0) n = n / 5;\\n            else break;\\n        }\\n        return (n == 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 69305,
                "title": "my-python-solution",
                "content": "\\n    def isUgly(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: bool\\n        \"\"\"\\n        if num <= 0:\\n            return False\\n        for x in [2, 3, 5]:\\n            while num % x == 0:\\n                num = num / x\\n        return num == 1",
                "solutionTags": [],
                "code": "\\n    def isUgly(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: bool\\n        \"\"\"\\n        if num <= 0:\\n            return False\\n        for x in [2, 3, 5]:\\n            while num % x == 0:\\n                num = num / x\\n        return num == 1",
                "codeTag": "Python3"
            },
            {
                "id": 69332,
                "title": "simple-java-solution-with-explanation",
                "content": "    public boolean isUgly(int num) {\\n        if (num <= 0) {return false;}\\n        if (num == 1) {return true;}\\n        if (num % 2 == 0) {\\n            return isUgly(num/2);\\n        }\\n        if (num % 3 == 0) {\\n            return isUgly(num/3);\\n        }\\n        if (num % 5 == 0) {\\n            return isUgly(num/5);\\n        }\\n        return false;\\n    }\\n\\n\\n----------\\nidea: \\n\\n - (1) basic cases: <= 0 and == 1\\n - (2) other cases: since the number can contain the factors of 2, 3, 5, I just remove those factors. So now, I have a number without any factors of 2, 3, 5. \\n - (3) after the removing, the number (new number) can contain a) the factor that is prime and meanwhile it is >= 7, or b) the factor that is not the prime and the factor is not comprised of 2, 3 or 5. In both cases, it is false (not ugly number). \\n\\nFor example, new number can be 11, 23 --> not ugly number (case a)). new number also can be 49, 121 --> not ugly number (case b))",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean isUgly(int num) {\\n        if (num <= 0) {return false;}\\n        if (num == 1) {return true;}\\n        if (num % 2 == 0) {\\n            return isUgly(num/2);\\n        }\\n        if (num % 3 == 0) {\\n            return isUgly(num/3);\\n        }\\n        if (num % 5 == 0) {\\n            return isUgly(num/5);\\n        }\\n        return false;\\n    }\\n\\n\\n----------\\nidea: \\n\\n - (1) basic cases: <= 0 and == 1\\n - (2) other cases: since the number can contain the factors of 2, 3, 5, I just remove those factors. So now, I have a number without any factors of 2, 3, 5. \\n - (3) after the removing, the number (new number) can contain a) the factor that is prime and meanwhile it is >= 7, or b) the factor that is not the prime and the factor is not comprised of 2, 3 or 5. In both cases, it is false (not ugly number). \\n\\nFor example, new number can be 11, 23 --> not ugly number (case a)). new number also can be 49, 121 --> not ugly number (case b))",
                "codeTag": "Unknown"
            },
            {
                "id": 69308,
                "title": "java-solution-greatest-divide-by-2-3-5",
                "content": "clean solution to greatest divide the num using 2, 3, and 5.\\n\\n    public class Solution {\\n        public static boolean isUgly(int num) {\\n            if (num <= 0) {\\n                return false;\\n            }\\n            \\n            int[] divisors = {2, 3, 5};\\n            \\n            for(int d : divisors) {\\n                while (num % d == 0) {\\n                    num /= d;\\n                }\\n            }\\n            return num == 1;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public static boolean isUgly(int num) {\\n            if (num <= 0) {\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 69353,
                "title": "simple-c-solution",
                "content": "    bool isUgly(int num) {\\n        if(num == 0) return false;\\n        \\n        while(num%2 == 0) num/=2;\\n        while(num%3 == 0) num/=3;\\n        while(num%5 == 0) num/=5;\\n        \\n        return num == 1;\\n    }",
                "solutionTags": [],
                "code": "    bool isUgly(int num) {\\n        if(num == 0) return false;\\n        \\n        while(num%2 == 0) num/=2;\\n        while(num%3 == 0) num/=3;\\n        while(num%5 == 0) num/=5;\\n        \\n        return num == 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2825480,
                "title": "python-c-java-rust-apply-2nd-3rd-5th-grades-school-arithmetics-bonus-one-liner-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs simple school arithmetics. Time complexity is logarithmic: **O(logN)**. Space complexity is constant: **O(1)**.\\n****\\n\\n**Comment.** Numbers we\\'re looking for are precisely those of the form `n = 2**i * 3**j * 5**k` (where `**` is Python\\'s power operator), i.e., `2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, ...` . To detect such a number, we should (completely) divide out each of it\\'s prime divisors (i.e., `2`, `3` and `5`) and see what remains. If it\\'s `1` then it\\'s ugly :) \\n\\n**Proof of complexity.** When dividing out factors `2`, `3` and `5`, the amount of operations performed is equal to the sum `i + j + k` where `i`,`j` and `k` are the respective powers in the prime number decomposition of `n`. The following is true: `n = 2**i * 3**j * 5**k <= 5**(i+j+k)`, thus, we conclude that the time complexity is logarithmic **O(logN)**, because it\\'ll take at most `i+j+k` steps (i.e. the logarithm of `n`) for the algorithm to terminate.\\n\\n**Python #1.** Dividing out each of primes.\\n```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n\\t\\tif n == 0 : return False\\n        for p in 2, 3, 5:\\n            while n % p == 0:     # if divisible by a prime...\\n                n /= p            # ...then divide it out\\n        return n == 1             # non-ugly numbers will have it != 1\\n```\\n\\n**Python #2.** Using the walrus operator with `pass` instead of the cycle body. Compare this to the C++ solution below.\\n```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n\\n        for p in 2, 3, 5: \\n            while n % p == 0 and (n := n / p):\\n                pass\\n        return n == 1\\n```\\n\\n<iframe src=\"https://leetcode.com/playground/fwk2ULog/shared\" frameBorder=\"0\" width=\"800\" height=\"260\"></iframe>\\n\\n**\\u2705 YOU MADE IT TILL THE BONUS SECTION... YOUR GREAT EFFORT DESERVES UPVOTING THIS POST!**\\n\\n**Python.** If `n` is of the form `2**i * 3**j * 5**k` then, given a constraint `n < 2**31 - 1`, it should be a divisor of this enormous number. Thanks Python, large-number arithmetics is here by default.\\n```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        return n > 0 and (2**30)*(3**20)*(5**13) % n == 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n\\t\\tif n == 0 : return False\\n        for p in 2, 3, 5:\\n            while n % p == 0:     # if divisible by a prime...\\n                n /= p            # ...then divide it out\\n        return n == 1             # non-ugly numbers will have it != 1\\n```\n```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n\\n        for p in 2, 3, 5: \\n            while n % p == 0 and (n := n / p):\\n                pass\\n        return n == 1\\n```\n```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        return n > 0 and (2**30)*(3**20)*(5**13) % n == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698739,
                "title": "c-100-time-easy-and-explained-solution",
                "content": "The idea is simple; you have a base of 3 prime numbers conveniently stored in `primes`, you loop through them, progressively reducing the initially provided number, if and only as long each of the primes is a divisor of it.\\n\\nAt the end of the run, if what you are left with is `== 1`, then you had an ugly number, `false` otherwise (and note that it would also rule out non-positive numbers, but I prefer to just save computation and check initially for it).\\n\\nIncidentally, the order by which the algorithm checks the primes is irrelevant, but I preferred to keep them in increasing order.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> primes = {2, 3, 5};\\n    bool isUgly(int n) {\\n        if (n < 1) return false;\\n        for (int p: primes) while (n % p == 0) n /=p;\\n        return n == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> primes = {2, 3, 5};\\n    bool isUgly(int n) {\\n        if (n < 1) return false;\\n        for (int p: primes) while (n % p == 0) n /=p;\\n        return n == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 69232,
                "title": "python-1-line-solution",
                "content": "    class Solution(object):\\n        def isUgly(self, num):\\n            \"\"\"\\n            :type num: int\\n            :rtype: bool\\n            \"\"\"\\n            #n = (2**30)*(3**20)*(5**13) = 4570198050078720000000000000L\\n            return False if num < 1 or (4570198050078720000000000000L)%num != 0 else True\\n\\n\\nbut my runtime is 60 ms.How should i improve it?",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def isUgly(self, num):\\n            \"\"\"\\n            :type num: int\\n            :rtype: bool\\n            \"\"\"\\n            #n = (2**30)*(3**20)*(5**13) = 4570198050078720000000000000L\\n            return False if num < 1 or (4570198050078720000000000000L)%num != 0 else True\\n\\n\\nbut my runtime is 60 ms.How should i improve it?",
                "codeTag": "Java"
            },
            {
                "id": 2825785,
                "title": "java-ugly-solution-recursive-approach-80-100-faster",
                "content": "Recursively divide with either 2 , 3 or 5 ,if at any stage not possible to divide by any of these three numbers then its not Ugly number(return false) . If we end up with 1 at the end than its Ugly Number(return true). 0 is not divisible & hence its NotUgly by default.!\\n\\n\\n```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n==0)return false;\\n        if(n==1)return true;\\n        if(n%2==0) return isUgly(n/2);\\n        else if(n%3==0) return isUgly(n/3);\\n        else   if(n%5==0) return isUgly(n/5);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n==0)return false;\\n        if(n==1)return true;\\n        if(n%2==0) return isUgly(n/2);\\n        else if(n%3==0) return isUgly(n/3);\\n        else   if(n%5==0) return isUgly(n/5);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279296,
                "title": "short-javascript-solution",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nvar isUgly = function (n) {\\n    if(n <= 0) return false\\n\\n    while (n != 1) {\\n        if (n % 2 === 0) {\\n            n /= 2\\n        } else if (n % 3 === 0) {\\n            n /= 3\\n        } else if (n % 5 === 0) {\\n            n /= 5\\n        } else {\\n            return false\\n        }\\n    }\\n\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isUgly = function (n) {\\n    if(n <= 0) return false\\n\\n    while (n != 1) {\\n        if (n % 2 === 0) {\\n            n /= 2\\n        } else if (n % 3 === 0) {\\n            n /= 3\\n        } else if (n % 5 === 0) {\\n            n /= 5\\n        } else {\\n            return false\\n        }\\n    }\\n\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1442337,
                "title": "clean-c-solution-and-easy-understanding-100-time-and-space",
                "content": "**Do upvote me so that I can ulpoad more solutions**\\n```\\nbool isUgly(int n) {\\n        if(n==0){\\n            return false;\\n        }\\n        if(n==1){\\n            return true;\\n        }\\n        if(n%2==0){\\n            return isUgly(n/2);\\n        }\\n        if(n%3==0){\\n            return isUgly(n/3);\\n        }\\n        if(n%5==0){\\n            return isUgly(n/5);\\n        }\\n        return false;\\n    }\\n\\t",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "**Do upvote me so that I can ulpoad more solutions**\\n```\\nbool isUgly(int n) {\\n        if(n==0){\\n            return false;\\n        }\\n        if(n==1){\\n            return true;\\n        }\\n        if(n%2==0){\\n            return isUgly(n/2);\\n        }\\n        if(n%3==0){\\n            return isUgly(n/3);\\n        }\\n        if(n%5==0){\\n            return isUgly(n/5);\\n        }\\n        return false;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 336227,
                "title": "solution-in-python-3-beats-99-five-lines",
                "content": "```\\nclass Solution:\\n    def isUgly(self, num: int) -> bool:\\n        if num == 0: return False\\n        while num % 5 == 0: num /= 5\\n        while num % 3 == 0: num /= 3\\n        while num % 2 == 0: num /= 2\\n        return num == 1\\n\\t\\t\\n\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isUgly(self, num: int) -> bool:\\n        if num == 0: return False\\n        while num % 5 == 0: num /= 5\\n        while num % 3 == 0: num /= 3\\n        while num % 2 == 0: num /= 2\\n        return num == 1\\n\\t\\t\\n\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 1764482,
                "title": "python3-faster-solution-basic-logic-with-maths",
                "content": "```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n<=0: \\n            return False\\n        for i in [2,3,5]:\\n            while n%i==0:\\n                n=n//i\\n        return n==1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n<=0: \\n            return False\\n        for i in [2,3,5]:\\n            while n%i==0:\\n                n=n//i\\n        return n==1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 69235,
                "title": "share-my-simple-java-solution",
                "content": "Continually divide the number by 2,3,5. If it's ugly, the result must be 1.\\n\\n    public class Solution {\\n        public boolean isUgly(int num) {\\n            if(num <= 0) return false;\\n            while((num % 2) == 0) num /= 2;\\n            while((num % 3) == 0) num /= 3;\\n            while((num % 5) == 0) num /= 5;\\n            return num == 1;\\n        }\\n    }\\n\\nThanks to braydenCN's advice. Revised some code.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isUgly(int num) {\\n            if(num <= 0) return false;\\n            while((num % 2) == 0) num /= 2;\\n            while((num % 3) == 0) num /= 3;\\n            while((num % 5) == 0) num /= 5;\\n            return num == 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2826123,
                "title": "java-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndivide a number continuously by 2,3,5 till it\\'s greater than 0, then if number is 1 return true, else false;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n<=0){\\n            return false;\\n        }\\n        while(n>0 && n%5==0){\\n            n=n/5;\\n        }\\n        while(n>0 && n%3==0){\\n            n=n/3;\\n        }\\n        while(n>0 && n%2==0){\\n            n=n/2;\\n        }\\n        return n==1;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n<=0){\\n            return false;\\n        }\\n        while(n>0 && n%5==0){\\n            n=n/5;\\n        }\\n        while(n>0 && n%3==0){\\n            n=n/3;\\n        }\\n        while(n>0 && n%2==0){\\n            n=n/2;\\n        }\\n        return n==1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 69279,
                "title": "java-clean-solution-is-this-o-logn-time",
                "content": "    public class Solution {\\n        public boolean isUgly(int num) {\\n            if (num == 0) {\\n                return false;\\n            }\\n            int[] divisors = {2, 3, 5};\\n            for (int divisor : divisors) {\\n                while(num % divisor == 0) {\\n                    num /= divisor;\\n                }\\n            }\\n            return num == 1;\\n        }\\n    }\\n\\nif the num == 2^30, then we divide it by 2, 30 times which is log2(n). but what if it has all 2,3,5 factors.\\nStill log(n) ?",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isUgly(int num) {\\n            if (num == 0) {\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 69327,
                "title": "4ms-short-c-solution",
                "content": "    class Solution {\\n    public:\\n        bool isUgly(int num) {\\n            if (num == 1) return true;\\n            if (num <= 0) return false;\\n            while (num % 2 == 0) num /= 2;\\n            while (num % 3 == 0) num /= 3;\\n            while (num % 5 == 0) num /= 5;\\n            return num == 1;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool isUgly(int num) {\\n            if (num == 1) return true;\\n            if (num <= 0) return false;\\n            while (num % 2 == 0) num /= 2;\\n            while (num % 3 == 0) num /= 3;\\n            while (num % 5 == 0) num /= 5;\\n            return num == 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 69342,
                "title": "simplest-java-solution",
                "content": "    public boolean isUgly(int num) {\\n        if (num == 0) return false;\\n        while (num % 2 == 0) num /= 2;\\n        while (num % 3 == 0) num /= 3;\\n        while (num % 5 == 0) num /= 5;\\n        return num == 1;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean isUgly(int num) {\\n        if (num == 0) return false;\\n        while (num % 2 == 0) num /= 2;\\n        while (num % 3 == 0) num /= 3;\\n        while (num % 5 == 0) num /= 5;\\n        return num == 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2826707,
                "title": "c-non-ugly-code",
                "content": "# Approach 1: math, just divide as long as possible\\nWe just divide with each factor as long as this is possible and if only one remains the number is ugly.\\n\\n```cpp\\n    static bool isUgly(int n) {\\n        if (n <= 0) return false;\\n\\n        while (n % 2 == 0) n /= 2;\\n        while (n % 3 == 0) n /= 3;\\n        while (n % 5 == 0) n /= 5;\\n        return n == 1;\\n    }\\n```\\n\\nIf we want to do something slighlty more generic, we could do something like this:\\n\\n```cpp\\n    static bool isUgly(int n) {\\n        if (n <= 0) return false;\\n\\n        for (const int d : {2, 3, 5})\\n            while (n % d == 0) n /= d;\\n\\n        return n == 1;\\n    }\\n```\\n\\nIn case you are wondering if you should be using bit masking and shifting for the \"divisible by 2\" test and write code like this:\\n\\n```cpp\\n    static bool isUgly(int n) {\\n        if (n <= 0) return false;\\n\\n        while ((n & 1) == 0) n >>=1;\\n        while (n % 3 == 0) n /= 3;\\n        while (n % 5 == 0) n /= 5;\\n        return n == 1;\\n    }\\n```\\n\\nLooks like clang is smart enough to see through this and generate the same code: https://godbolt.org/z/YhTEYeMre -- and FWIW the generated assemble doesn\\'t look like at all to what I expected, e.g. the generated code doesn\\'t have a single \"div\" instruction.\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(\\\\log n)$$\\n  * Space Complexity: $$O(1)$$\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    static bool isUgly(int n) {\\n        if (n <= 0) return false;\\n\\n        while (n % 2 == 0) n /= 2;\\n        while (n % 3 == 0) n /= 3;\\n        while (n % 5 == 0) n /= 5;\\n        return n == 1;\\n    }\\n```\n```cpp\\n    static bool isUgly(int n) {\\n        if (n <= 0) return false;\\n\\n        for (const int d : {2, 3, 5})\\n            while (n % d == 0) n /= d;\\n\\n        return n == 1;\\n    }\\n```\n```cpp\\n    static bool isUgly(int n) {\\n        if (n <= 0) return false;\\n\\n        while ((n & 1) == 0) n >>=1;\\n        while (n % 3 == 0) n /= 3;\\n        while (n % 5 == 0) n /= 5;\\n        return n == 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1804787,
                "title": "c-solution",
                "content": "\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t** upvote if it helped**\\n\\t\\t\\t\\t\\t\\t\\t\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(!n) return false ;\\n        while (n%5 == 0 ) n/=5;\\n        while (n%3 == 0 ) n/=3;\\n        while (n%2 == 0 ) n/=2;\\n        return n == 1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(!n) return false ;\\n        while (n%5 == 0 ) n/=5;\\n        while (n%3 == 0 ) n/=3;\\n        while (n%2 == 0 ) n/=2;\\n        return n == 1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1638899,
                "title": "c-easyto-understand-2-solutions",
                "content": "**Approach 1**\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        int prev=n;\\n        if(n==1)\\n         return true; \\n        if(n<0||n==0)\\n           return false; \\n       while(n!=1)\\n       {\\n           prev=n;\\n           if(n%2==0)\\n           {\\n            n=n/2;   \\n           }\\n           if(n%3==0)\\n           {\\n               n=n/3;\\n           }\\n           if(n%5==0)\\n           {\\n               n=n/5;\\n           }\\n           if(prev==n)\\n             return false;  \\n       } \\n        return true;\\n    }\\n};\\n```\\n**Approach 2**\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n==0)\\n        return false;\\n        while(n%2==0)\\n        n/=2;\\n        while(n%3==0)\\n        n/=3;\\n        while(n%5==0)\\n        n/=5;\\n        return n==1;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        int prev=n;\\n        if(n==1)\\n         return true; \\n        if(n<0||n==0)\\n           return false; \\n       while(n!=1)\\n       {\\n           prev=n;\\n           if(n%2==0)\\n           {\\n            n=n/2;   \\n           }\\n           if(n%3==0)\\n           {\\n               n=n/3;\\n           }\\n           if(n%5==0)\\n           {\\n               n=n/5;\\n           }\\n           if(prev==n)\\n             return false;  \\n       } \\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n==0)\\n        return false;\\n        while(n%2==0)\\n        n/=2;\\n        while(n%3==0)\\n        n/=3;\\n        while(n%5==0)\\n        n/=5;\\n        return n==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541479,
                "title": "easy-js-solution",
                "content": "```\\nvar isUgly = function(num) {\\n    if (!num) return false;\\n    while (num > 1) {\\n        if (num % 2 == 0) num /= 2;\\n        else if (num % 3 == 0) num /= 3;\\n        else if (num % 5 == 0) num /= 5;\\n        else return false;\\n    }\\n    return num == 1;\\n    // To check if a number is ugly, we keep dividing it by either 2,3 or 5\\n    // until it becomes 1. If it cannot become 1 (no more divisible by 2,3 or 5),\\n    // then return false;\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isUgly = function(num) {\\n    if (!num) return false;\\n    while (num > 1) {\\n        if (num % 2 == 0) num /= 2;\\n        else if (num % 3 == 0) num /= 3;\\n        else if (num % 5 == 0) num /= 5;\\n        else return false;\\n    }\\n    return num == 1;\\n    // To check if a number is ugly, we keep dividing it by either 2,3 or 5\\n    // until it becomes 1. If it cannot become 1 (no more divisible by 2,3 or 5),\\n    // then return false;\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3424256,
                "title": "logarithmic-solution-best-approach-in-python-python3",
                "content": "\\n\\n# Approach\\nThe solution can be done by dividing the given number by 2, 3, or 5 as long as it is divisible, and then checking if the resulting number is 1 (which means it is an ugly number) or not.\\n\\nThe time complexity of this algorithm is O(log n), since we divide the input number by 2, 3, or 5 repeatedly until we get a result, which takes logarithmic time. The space complexity is O(1), since we are not using any additional data structures.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n==0:\\n            return 0\\n        for i in 2,3,5:\\n            while n%i==0:\\n                n//=i\\n        return n==1\\n```\\n\\n# Upvote if you like the solution or ask if there is any query",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n==0:\\n            return 0\\n        for i in 2,3,5:\\n            while n%i==0:\\n                n//=i\\n        return n==1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825633,
                "title": "in-log-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:log(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:1\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        while(n%2==0 and n!=0):\\n            n=n//2\\n        while(n%3==0 and n!=0):\\n            n=n//3\\n        while(n%5==0 and n!=0):\\n            n=n//5\\n        return(n==1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        while(n%2==0 and n!=0):\\n            n=n//2\\n        while(n%3==0 and n!=0):\\n            n=n//3\\n        while(n%5==0 and n!=0):\\n            n=n//5\\n        return(n==1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825554,
                "title": "4-lines-of-code",
                "content": "\\njust keep dividing by 2,3 5\\n\\n\\n```\\n\\n    public boolean isUgly(int n) {\\n\\n        if(n==0) return false;\\n        \\n        while( n%2==0) n=n/2;\\n\\n        while( n%3==0) n=n/3;\\n\\n        while( n%5==0) n=n/5;\\n\\n        return n==1 ;\\n\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    public boolean isUgly(int n) {\\n\\n        if(n==0) return false;\\n        \\n        while( n%2==0) n=n/2;\\n\\n        while( n%3==0) n=n/3;\\n\\n        while( n%5==0) n=n/5;\\n\\n        return n==1 ;\\n\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 593940,
                "title": "c-solution-beats-100",
                "content": "The intuition that first comes to our minds is that if(num%2==0||num%3==0||num%5==0)return true\\nWell this might pass some test cases but it is absolutely wrong.\\nlet me demonstrate:\\nLet num=14;\\nits prime factors are:1,2,7,14\\nbut the questions says apart from 1 and the number itself only 2,3,5 are allowed\\nSo how do we tackle this problem?\\nWe try to keep dividing the by 2 as long as the number is divisble by 2\\nThen with the current number we keep dividing by 3 as long as its divisble by 3\\nsimilarly for 5.\\nIf the final number that we get is 1 then we have got the result.\\nLet me demonstrate:\\nLet us take the same number\\nnum=14<-----divisible by 2 so keep dividing\\n14/2=7<-----not divisible by 2 so stop\\n7<----------not divisble by 3 so stop\\n7<----------not divisble by 5 so stop\\nthe final answer we got is 7 which is not equal to 1 so return false.\\nLets take another example\\nnum=30<-----divisble by 2 so keep dividing by 2\\nnum=15<-----not divisible by 2 so stop\\nnum=15<-----divisble by 3 so keep dividing by 3\\nnum=5<------not divisible by 3 so stop\\nnum=5<------divisble by 5 so keep dividing by 5\\nnum=1<------not divisible by 5 so stop\\nas 1==1 return true\\n```\\nbool isUgly(int num) {\\n        if(num==0)return false;//<-----0 is neither divisble by 2,3 nor 5\\n        while(num%2==0)num/=2;\\n        while(num%3==0)num/=3;\\n        while(num%5==0)num/=5;\\n        return num==1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool isUgly(int num) {\\n        if(num==0)return false;//<-----0 is neither divisble by 2,3 nor 5\\n        while(num%2==0)num/=2;\\n        while(num%3==0)num/=3;\\n        while(num%5==0)num/=5;\\n        return num==1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 69298,
                "title": "javascript-solution-5-lines-clean-short",
                "content": "    var isUgly = function(num) {\\n        if(num<=0) return false; \\n        while(parseInt(num/2)===num/2) { num/=2; }  // using the fact that \\n        while(parseInt(num/3)===num/3) { num/=3; }  // multiplication is commutative, \\n        while(parseInt(num/5)===num/5) { num/=5; }  // hence the order doesn't matter\\n        return num===1;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var isUgly = function(num) {\\n        if(num<=0) return false; \\n        while(parseInt(num/2)===num/2) { num/=2; }  // using the fact that \\n        while(parseInt(num/3)===num/3) { num/=3; }  // multiplication is commutative, \\n        while(parseInt(num/5)===num/5) { num/=5; }  // hence the order doesn't matter\\n        return num===1;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 69289,
                "title": "2ms-solution-in-java",
                "content": "public class Solution {\\n    \\n    public boolean isUgly(int num) {\\n        if(num == 0) {\\n            return false;\\n        }\\n        while(num % 5 == 0) {\\n            num /= 5;\\n        }\\n        while(num % 3 == 0) {\\n            num /= 3;\\n        }\\n        while(num % 2 == 0) {\\n            num /= 2;\\n        }\\n        if(num == 1) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public boolean isUgly(int num) {\\n        if(num == 0) {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 69282,
                "title": "5-line-java-solution-2ms",
                "content": "    public boolean isUgly(int num) {\\n        if(num <= 0) return false;\\n        while(num % 2 == 0) num /= 2;\\n        while(num % 3 == 0) num /= 3;\\n        while(num % 5 == 0) num /= 5;\\n        return num == 1;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean isUgly(int num) {\\n        if(num <= 0) return false;\\n        while(num % 2 == 0) num /= 2;\\n        while(num % 3 == 0) num /= 3;\\n        while(num % 5 == 0) num /= 5;\\n        return num == 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3119297,
                "title": "c-c-java-python-code-with-explanation",
                "content": "Given: the number must be divisible only by 2, 3, 5 ( 1 and itself) not more than this number.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing modulo operator, check whether the given number is divisible by 2 if yes, divide untill it becomes not divisible by 2.\\n\\ncheck whether the given number is divisible by 3 if yes, divide untill it becomes not divisible by 3.\\n\\ncheck whether the given number is divisible by 5 if yes, divide untill it becomes not divisible by 5.\\n\\nFor example : given number : 14 \\n    STEP 1 : if 14 modulo 2 is 0.\\n    STEP 2 : then divide it by 2, (then n becomes 7.)\\n    STEP 3 : if 7 modulo 2 is 0, go to STEP 2, \\n    STEP 4 : if 7 modulo 3 is 0, then divide it by 3. (n is still 7)\\n    STEP 5 : if 7 modulo 5 is 0. then divide it by 5. (n is still 7)\\n    STEP 6 : if n == 1, return true.\\n    STEP 7 : else, return false.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n**C**\\n\\nbool isUgly(int n){\\n    \\n    while(n % 2 == 0 && (n = n / 2));\\n    while(n % 3 == 0 && (n = n / 3));\\n    while(n % 5 == 0 && (n = n / 5));\\n\\n    return n==1;\\n\\n}\\n\\n**C++**\\n\\nbool isUgly(int n) {\\n        \\n        while(n % 2 == 0 && (n = n / 2));\\n        while(n % 3 == 0 && (n = n / 3));\\n        while(n % 5 == 0 && (n = n / 5));\\n\\n        return n==1;\\n    }\\n\\n**JAVA**\\n\\n public boolean isUgly(int n) {\\n        if(n <= 0) return false;\\n\\n        while(n % 2 == 0) \\n            n = n / 2;\\n        while(n % 3 == 0)\\n            n = n / 3;\\n        while(n % 5 == 0)\\n            n = n / 5;\\n\\n        return n==1;\\n    }\\n\\n**Python**\\n\\ndef isUgly(self, n):\\n        if n <= 0 :\\n            return 0\\n        while n % 2 == 0:\\n            n = n / 2\\n        while n % 3 == 0:\\n            n = n / 3\\n        while n % 5 == 0:\\n            n = n / 5\\n\\n        return n==1\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n**C**\\n\\nbool isUgly(int n){\\n    \\n    while(n % 2 == 0 && (n = n / 2));\\n    while(n % 3 == 0 && (n = n / 3));\\n    while(n % 5 == 0 && (n = n / 5));\\n\\n    return n==1;\\n\\n}\\n\\n**C++**\\n\\nbool isUgly(int n) {\\n        \\n        while(n % 2 == 0 && (n = n / 2));\\n        while(n % 3 == 0 && (n = n / 3));\\n        while(n % 5 == 0 && (n = n / 5));\\n\\n        return n==1;\\n    }\\n\\n**JAVA**\\n\\n public boolean isUgly(int n) {\\n        if(n <= 0) return false;\\n\\n        while(n % 2 == 0) \\n            n = n / 2;\\n        while(n % 3 == 0)\\n            n = n / 3;\\n        while(n % 5 == 0)\\n            n = n / 5;\\n\\n        return n==1;\\n    }\\n\\n**Python**\\n\\ndef isUgly(self, n):\\n        if n <= 0 :\\n            return 0\\n        while n % 2 == 0:\\n            n = n / 2\\n        while n % 3 == 0:\\n            n = n / 3\\n        while n % 5 == 0:\\n            n = n / 5\\n\\n        return n==1\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3318657,
                "title": "2-lines-of-code-awesome-approach",
                "content": "# Math formula Approach\\n```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n<1:\\n            return False\\n        multiple=2*3*5\\n        return (multiple**20)%n==0\\n\\n    //please upvote me it would encourage me alot\\n\\n\\n```\\n# Chack with each ugly factor\\n```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n<1: return False\\n        for num in [2,3,5]:\\n            while n%num==0:\\n                n=n//num\\n        return n==1\\n\\n    //please upvote me it would encourage me alot\\n\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n<1:\\n            return False\\n        multiple=2*3*5\\n        return (multiple**20)%n==0\\n\\n    //please upvote me it would encourage me alot\\n\\n\\n```\n```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n<1: return False\\n        for num in [2,3,5]:\\n            while n%num==0:\\n                n=n//num\\n        return n==1\\n\\n    //please upvote me it would encourage me alot\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216194,
                "title": "best-c-solution-ever-100-faster-math-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Math.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complecity : O(logN), We are dividing the integer by 2, 3, and 5 and terminating when it is not divisible by any of them. Where N is the number n.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(1), Constant Space.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complecity : O(logN), We are dividing the integer by 2, 3, and 5 and terminating when it is not divisible\\n    by any of them. Where N is the number n.\\n\\n    Space Complexity : O(1), Constant Space.\\n\\n    Solved using Math.\\n\\n*/\\n\\nclass Solution {\\nprivate:\\n    int keepsOndividingUntilPossible(int dividend, int divisor){\\n        while(dividend % divisor == 0){\\n            dividend /= divisor;\\n        }\\n        return dividend;\\n    }\\npublic:\\n    bool isUgly(int n) {\\n        if(n<=0) return false;\\n        for(auto factor : {2,3,5}){\\n            n = keepsOndividingUntilPossible(n, factor);\\n        }\\n        return n == 1;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\n/*\\n\\n    Time Complecity : O(logN), We are dividing the integer by 2, 3, and 5 and terminating when it is not divisible\\n    by any of them. Where N is the number n.\\n\\n    Space Complexity : O(1), Constant Space.\\n\\n    Solved using Math.\\n\\n*/\\n\\nclass Solution {\\nprivate:\\n    int keepsOndividingUntilPossible(int dividend, int divisor){\\n        while(dividend % divisor == 0){\\n            dividend /= divisor;\\n        }\\n        return dividend;\\n    }\\npublic:\\n    bool isUgly(int n) {\\n        if(n<=0) return false;\\n        for(auto factor : {2,3,5}){\\n            n = keepsOndividingUntilPossible(n, factor);\\n        }\\n        return n == 1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827599,
                "title": "beats-100-upvote-if-you-like",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) \\n    {\\n        if (n <= 0) return false;\\n        while(n > 1)\\n        {\\n            if (n % 2 == 0) n = n / 2;\\n            else if (n % 3 == 0) n = n / 3;\\n            else if (n % 5 == 0) n = n / 5;\\n            else break;\\n        }\\n        return (n == 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) \\n    {\\n        if (n <= 0) return false;\\n        while(n > 1)\\n        {\\n            if (n % 2 == 0) n = n / 2;\\n            else if (n % 3 == 0) n = n / 3;\\n            else if (n % 5 == 0) n = n / 5;\\n            else break;\\n        }\\n        return (n == 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826338,
                "title": "short-c-explained-solution-beginner-friendly-by-mr-coder",
                "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=5bM0BHgetEs\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n \\n    bool isUgly(int n) {\\n         if (n <= 0) return false;\\n        while(1){\\n            if(n==1)return true;\\n      if(n%2==0)while(n%2==0){n= n/2; }  \\n         else if(n%3==0) while(n%3==0) n= n/3;\\n          else if(n%5==0) while(n%5==0) n= n/5;\\n            else return false;\\n        } \\n    }\\n};\\n\\n\\n```\\n**If you find my solution helpful please upvote it.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n    bool isUgly(int n) {\\n         if (n <= 0) return false;\\n        while(1){\\n            if(n==1)return true;\\n      if(n%2==0)while(n%2==0){n= n/2; }  \\n         else if(n%3==0) while(n%3==0) n= n/3;\\n          else if(n%5==0) while(n%5==0) n= n/5;\\n            else return false;\\n        } \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666411,
                "title": "100-runtime-0-ms-c-through-recursion-easy-as-hell-6-liner-3",
                "content": "Hi Future Developers && Beginners,\\nWould appreciate it if you could share & upvote <3\\n\\n\"\"\"\\nbool isUgly(int n) {\\n        \\n        if (n < 1) return false; //If provided n 0 or negative\\n        else if (n == 1) return true; //If provided n equals 1 -> positive case\\n        else if (n % 2 == 0) return isUgly(n/2); //meaning provided n can be divided by 2 with no rest\\n        else if (n % 3 == 0) return isUgly(n/3); //meaning provided n can be divided by 3 with no rest\\n        else if (n % 5 == 0) return isUgly(n/5); //meaning provided n can be divided by 5 with no rest\\n        else return false; // if provided n is neither negative, 0, nor it can be divided by 2/3/5 with no rest\\n\"\"\"\\n    }\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "Hi Future Developers && Beginners,\\nWould appreciate it if you could share & upvote <3\\n\\n\"\"\"\\nbool isUgly(int n) {\\n        \\n        if (n < 1) return false; //If provided n 0 or negative\\n        else if (n == 1) return true; //If provided n equals 1 -> positive case\\n        else if (n % 2 == 0) return isUgly(n/2); //meaning provided n can be divided by 2 with no rest\\n        else if (n % 3 == 0) return isUgly(n/3); //meaning provided n can be divided by 3 with no rest\\n        else if (n % 5 == 0) return isUgly(n/5); //meaning provided n can be divided by 5 with no rest\\n        else return false; // if provided n is neither negative, 0, nor it can be divided by 2/3/5 with no rest\\n\"\"\"\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1758971,
                "title": "javascript-easy-understanding",
                "content": "\\n```\\n// Please upvote if you like the solution  . Thanks\\n\\nvar isUgly = function(n) {\\n    while(n>1){\\n        if(n%2==0){\\n            n=n/2\\n        }\\n         else if(n%3==0){\\n             n=n/3\\n         }\\n        else if(n%5==0){\\n             n=n/5\\n         }\\n        else{\\n            return false\\n        }\\n    }\\n    if(n==1){\\n        return true\\n    }\\n    else\\n        {\\n        return false\\n    } \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Please upvote if you like the solution  . Thanks\\n\\nvar isUgly = function(n) {\\n    while(n>1){\\n        if(n%2==0){\\n            n=n/2\\n        }\\n         else if(n%3==0){\\n             n=n/3\\n         }\\n        else if(n%5==0){\\n             n=n/5\\n         }\\n        else{\\n            return false\\n        }\\n    }\\n    if(n==1){\\n        return true\\n    }\\n    else\\n        {\\n        return false\\n    } \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1601360,
                "title": "my-0ms-most-optimized-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n < 1) return 0;\\n        if(n < 7) return 1;\\n        if((n & 1) == 0) return isUgly(n / 2);\\n        if((n % 3) == 0) return isUgly(n / 3);\\n        if((n % 5) == 0) return isUgly(n / 5);\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n < 1) return 0;\\n        if(n < 7) return 1;\\n        if((n & 1) == 0) return isUgly(n / 2);\\n        if((n % 3) == 0) return isUgly(n / 3);\\n        if((n % 5) == 0) return isUgly(n / 5);\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363472,
                "title": "java-math-1ms-beats-100-t-c-o-logn-s-c-o-1",
                "content": "\\n\\n\\t// O(log2(n)) O(1)\\n\\tpublic boolean isUgly(int n) {\\n\\n\\t\\tif (n == 0 || n < 0)\\n\\t\\t\\treturn false;\\n\\n\\t\\tn = divisible(n, 2); // log2(n)\\n\\t\\tn = divisible(n, 3); // log3(n)\\n\\t\\tn = divisible(n, 5); // log5(n)\\n\\n\\t\\treturn n == 1;\\n\\t}\\n\\n\\t// O(logb(n)) O(1)\\n\\tpublic int divisible(int n, int div) {\\n\\t\\twhile (n % div == 0)\\n\\t\\t\\tn = n / div;\\n\\t\\treturn n;\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\n\\t// O(log2(n)) O(1)\\n\\tpublic boolean isUgly(int n) {\\n\\n\\t\\tif (n == 0 || n < 0)\\n\\t\\t\\treturn false;\\n\\n\\t\\tn = divisible(n, 2); // log2(n)\\n\\t\\tn = divisible(n, 3); // log3(n)\\n\\t\\tn = divisible(n, 5); // log5(n)\\n\\n\\t\\treturn n == 1;\\n\\t}\\n\\n\\t// O(logb(n)) O(1)\\n\\tpublic int divisible(int n, int div) {\\n\\t\\twhile (n % div == 0)\\n\\t\\t\\tn = n / div;\\n\\t\\treturn n;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1328164,
                "title": "recursive-approach-to-a-simple-question-beginner-friendly-c",
                "content": "Simple Recursive approach,\\nNot an efficient runtime approach, but a beginner can observe the beauty of recursion ;)\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if (n == 1) return true;\\n        if (n < 1) return false;\\n        if (n % 2 == 0)\\n            return isUgly(n/2);\\n        if (n % 3 == 0)\\n            return isUgly(n/3);\\n        if (n % 5 == 0)\\n            return isUgly(n/5);\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if (n == 1) return true;\\n        if (n < 1) return false;\\n        if (n % 2 == 0)\\n            return isUgly(n/2);\\n        if (n % 3 == 0)\\n            return isUgly(n/3);\\n        if (n % 5 == 0)\\n            return isUgly(n/5);\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1293434,
                "title": "js-faster-than-100-easy-solution",
                "content": "```\\nvar isUgly = function(n) {\\n  if(n<=0) return false\\n    \\n  while(1<n){\\n    if(n%2===0){\\n      n=n/2\\n    }\\n     else if(n%3===0){\\n      n =  n/3\\n    } \\n      else if(n%5===0){\\n      n=n/5\\n    }else {\\n      return false\\n    }\\n  }\\n  \\n return  true\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isUgly = function(n) {\\n  if(n<=0) return false\\n    \\n  while(1<n){\\n    if(n%2===0){\\n      n=n/2\\n    }\\n     else if(n%3===0){\\n      n =  n/3\\n    } \\n      else if(n%5===0){\\n      n=n/5\\n    }else {\\n      return false\\n    }\\n  }\\n  \\n return  true\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 846790,
                "title": "99-pyhton-solution",
                "content": "```\\n        if n == 0:\\n            return False\\n        \\n        while n%2 == 0:\\n            n = n/2\\n        \\n        while n%3 == 0:\\n            n = n/3\\n        \\n        while n%5 == 0:\\n            n = n/5\\n\\n        if n == 1:\\n            return True\\n\\t\\t\\t\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n        if n == 0:\\n            return False\\n        \\n        while n%2 == 0:\\n            n = n/2\\n        \\n        while n%3 == 0:\\n            n = n/3\\n        \\n        while n%5 == 0:\\n            n = n/5\\n\\n        if n == 1:\\n            return True\\n\\t\\t\\t\\n        return False\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 511887,
                "title": "python-o-log-n-sol-by-integer-division-93-with-hint-comment",
                "content": "Python O( log n ) sol by integer division.\\n\\n---\\n\\nHint:\\nThink of **prime factor decomposition** of number = (**2**^i) * (**3**^j) * (**5**^k),\\nand use **integer division** ( the **//** operator in python) to decompose input number for judgement.\\n\\n---\\nAlgorithm:\\n\\nStep_#1:\\nUse integer division to decompose input number.\\n\\nStep_#2:\\nAfter factor decomposition of 2, 3, 5.\\nif there are any prime factor other than 2, 3, 5, then reject and return False.\\nOtherwise, accept and return True.\\n\\n\\n---\\n\\n```\\nclass Solution:\\n    def isUgly(self, num: int) -> bool:\\n        \\n        if num == 0:\\n            # Corner case handle for input 0\\n            return False\\n        \\n        \\n        given_prime = [2, 3, 5]\\n        \\n        for p in given_prime:\\n        \\n            while num % p == 0:\\n                num //= p\\n\\n\\n        return num == 1\\n```\\n\\n---\\n\\nReference:\\n[1] [Wiki: Prime factor decomposition](https://en.wikipedia.org/wiki/Integer_factorization)\\n\\n[2] [Python official docs about integer division operation, \"//\"](https://docs.python.org/3/library/stdtypes.html?highlight=integer%20division#numeric-types-int-float-complex)\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #264 Ugly Number II](https://leetcode.com/problems/ugly-number-ii/)",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def isUgly(self, num: int) -> bool:\\n        \\n        if num == 0:\\n            # Corner case handle for input 0\\n            return False\\n        \\n        \\n        given_prime = [2, 3, 5]\\n        \\n        for p in given_prime:\\n        \\n            while num % p == 0:\\n                num //= p\\n\\n\\n        return num == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 475123,
                "title": "c",
                "content": "```\\npublic bool IsUgly(int num) {\\n\\tif (num < 1)\\n\\t\\treturn false;\\n\\n\\twhile (num > 1)\\n\\t\\tif (num % 2 == 0)\\n\\t\\t\\tnum /= 2;\\n\\t\\telse if (num % 3 == 0)\\n\\t\\t\\tnum /= 3;\\n\\t\\telse if (num % 5 == 0)\\n\\t\\t\\tnum /= 5;\\n\\t\\telse\\n\\t\\t\\treturn false;\\n\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic bool IsUgly(int num) {\\n\\tif (num < 1)\\n\\t\\treturn false;\\n\\n\\twhile (num > 1)\\n\\t\\tif (num % 2 == 0)\\n\\t\\t\\tnum /= 2;\\n\\t\\telse if (num % 3 == 0)\\n\\t\\t\\tnum /= 3;\\n\\t\\telse if (num % 5 == 0)\\n\\t\\t\\tnum /= 5;\\n\\t\\telse\\n\\t\\t\\treturn false;\\n\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 69265,
                "title": "simple-c-solution-4ms",
                "content": "    bool isUgly(int num) {\\n            if(num == 1){\\n                return true;\\n            }\\n            if(num <=0){\\n                return false;\\n            }\\n            while(num % 2 == 0){\\n                num /= 2;\\n            }\\n            while(num % 3 == 0){\\n                num /= 3;\\n            }\\n            while(num % 5 == 0){\\n                num /= 5;\\n            }\\n        return num == 1;\\n    }",
                "solutionTags": [],
                "code": "    bool isUgly(int num) {\\n            if(num == 1){\\n                return true;\\n            }\\n            if(num <=0){\\n                return false;\\n            }\\n            while(num % 2 == 0){\\n                num /= 2;\\n            }\\n            while(num % 3 == 0){\\n                num /= 3;\\n            }\\n            while(num % 5 == 0){\\n                num /= 5;\\n            }\\n        return num == 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3892044,
                "title": "beats-100-clean-code-c",
                "content": "\\n# Complexity\\n- Time complexity: O(logN) : O(log\\u2082N) + O(log\\u2083N) + O(log\\u2085N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if (n < 1)\\n        {\\n            return false;\\n        }\\n        std::array<int, 3> uglyPrimes = { 2, 3, 5 };\\n        for (int prime : uglyPrimes)\\n        {\\n            while (n % prime == 0)\\n            {\\n                n /= prime;\\n            }\\n        }\\n        return n == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if (n < 1)\\n        {\\n            return false;\\n        }\\n        std::array<int, 3> uglyPrimes = { 2, 3, 5 };\\n        for (int prime : uglyPrimes)\\n        {\\n            while (n % prime == 0)\\n            {\\n                n /= prime;\\n            }\\n        }\\n        return n == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689534,
                "title": "easy-cpp-solution-using-loops-with-detailed-stepwise-explanation-beginner-friendly",
                "content": "# Intuition\\nTo make a function to check if the number is divisible by 2,3,5 or not.\\n\\n# Approach\\n1. The `checkPrime` function takes an integer `n` as input and checks if it is a prime number or not.\\n\\n2. The function initializes a while loop that continues as long as `n` is greater than 0.\\n\\n3. Inside the loop, it checks if `n` is divisible by 2, 3, or 5 using the modulo operator (`%`).\\n\\n4. If `n` is divisible by 2, it updates the value of `n` by dividing it by 2 (`n = n / 2`).\\n\\n5. If `n` is divisible by 3, it updates the value of `n` by dividing it by 3 (`n = n / 3`).\\n\\n6. If `n` is divisible by 5, it updates the value of `n` by dividing it by 5 (`n = n / 5`).\\n\\n7. If none of the above conditions are satisfied, it breaks out of the loop using the `break` statement.\\n\\n8. After the loop, the function checks if `n` is equal to 1. If it is, it means that all the prime factors of the original number have been divided out, and hence, it is a prime number. The function returns `true` in this case. Otherwise, it returns `false`.\\n\\n9. The `isUgly` function takes an integer `n` as input and checks if it is an \"ugly\" number.\\n\\n10. Inside the function, it calls the `checkPrime` function with `n` as an argument to check if `n` is a prime number.\\n\\n11. If `n` is determined to be a prime number by the `checkPrime` function, the `isUgly` function returns `true`, indicating that `n` is an ugly number.\\n\\n12. If `n` is not determined to be a prime number, the `isUgly` function returns `false`, indicating that `n` is not an ugly number.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkPrime(int n)  \\n        {\\n            while(n>0)\\n            {\\n                if(n%2==0) n=n/2;\\n                else if(n%3==0) n=n/3;\\n                else if(n%5==0) n=n/5;\\n                else{break;}\\n            }\\n            return (n==1);\\n        }\\n\\n    bool isUgly(int n) {\\n            if(checkPrime(n))\\n            {\\n                return true;\\n            }\\n            return false;\\n    }\\n};\\n```\\n# Please upvote :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkPrime(int n)  \\n        {\\n            while(n>0)\\n            {\\n                if(n%2==0) n=n/2;\\n                else if(n%3==0) n=n/3;\\n                else if(n%5==0) n=n/5;\\n                else{break;}\\n            }\\n            return (n==1);\\n        }\\n\\n    bool isUgly(int n) {\\n            if(checkPrime(n))\\n            {\\n                return true;\\n            }\\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235170,
                "title": "263-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe solution can be done by dividing the given number by 2, 3, or 5 as long as it is divisible, and then checking if the resulting number is 1 (which means it is an ugly number) or not.\\n\\nThe time complexity of this algorithm is O(log n), since we divide the input number by 2, 3, or 5 repeatedly until we get a result, which takes logarithmic time. The space complexity is O(1), since we are not using any additional data structures.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n <= 0: # Non-positive numbers are not ugly\\n            return False\\n        while n % 2 == 0: # Check if n is divisible by 2, keep dividing until it\\'s not\\n            n /= 2\\n        while n % 3 == 0: # Check if n is divisible by 3, keep dividing until it\\'s not\\n            n /= 3\\n        while n % 5 == 0: # Check if n is divisible by 5, keep dividing until it\\'s not\\n            n /= 5\\n        return n == 1 # If n is not 1, then it\\'s not an ugly number\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n <= 0: # Non-positive numbers are not ugly\\n            return False\\n        while n % 2 == 0: # Check if n is divisible by 2, keep dividing until it\\'s not\\n            n /= 2\\n        while n % 3 == 0: # Check if n is divisible by 3, keep dividing until it\\'s not\\n            n /= 3\\n        while n % 5 == 0: # Check if n is divisible by 5, keep dividing until it\\'s not\\n            n /= 5\\n        return n == 1 # If n is not 1, then it\\'s not an ugly number\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826294,
                "title": "c-o-logn",
                "content": "Approach is to remove all the factors of 2,3,5 from the number \\nIf result not equal to one then the number has prime factors other than 2,3,5 then return false \\nelse if return equal to 1 return true\\t\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isUgly(int n) {\\n\\t\\t\\tif(n==0) return false;\\n\\t\\t\\twhile(n%2==0) n/=2;\\n\\t\\t\\twhile(n%3==0) n/=3;\\n\\t\\t\\twhile(n%5==0) n/=5;\\n\\t\\t\\treturn n==1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isUgly(int n) {\\n\\t\\t\\tif(n==0) return false;\\n\\t\\t\\twhile(n%2==0) n/=2;\\n\\t\\t\\twhile(n%3==0) n/=3;\\n\\t\\t\\twhile(n%5==0) n/=5;\\n\\t\\t\\treturn n==1;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2825750,
                "title": "js-multiple-approaches-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/11/ugly-number.html\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\nNote: You can bookmark it as a resource, and approach. Other approaches are in above blog\\n<br>\\n\\n```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nconst isUgly = (n) => {\\n    // Handle all non positive nos\\n    if(n <= 0) return false;\\n    // Anything below 5 is ugly\\n    if(n <= 5) return true;\\n    \\n    // Start dividing recursively\\n    for(const divider of [2, 3, 5]) {\\n        if(n % divider === 0) {\\n            return isUgly(n / divider);\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nconst isUgly = (n) => {\\n    // Handle all non positive nos\\n    if(n <= 0) return false;\\n    // Anything below 5 is ugly\\n    if(n <= 5) return true;\\n    \\n    // Start dividing recursively\\n    for(const divider of [2, 3, 5]) {\\n        if(n % divider === 0) {\\n            return isUgly(n / divider);\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2825551,
                "title": "python-3-4-lines-iteration-t-m-99-9-61",
                "content": "```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n\\n        if n<=0: return False\\n\\n        for k in (2,3,5):\\n            while n%k==0: n//=k\\n        \\n        return n==1 \\n```\\n    \\n [https://leetcode.com/submissions/detail/845508280/](http://)\\n \\n I could be wrong, but now I think it\\'s *O*(log*N*) / *O*(1).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n\\n        if n<=0: return False\\n\\n        for k in (2,3,5):\\n            while n%k==0: n//=k\\n        \\n        return n==1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325596,
                "title": "python-simple",
                "content": "```python\\ndef isUgly(self, n: int) -> bool:\\n        if not n:\\n            return False\\n        \\n        for k in [2,3,5]:\\n            while not n%k:\\n                n //= k\\n            if n == 1:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef isUgly(self, n: int) -> bool:\\n        if not n:\\n            return False\\n        \\n        for k in [2,3,5]:\\n            while not n%k:\\n                n //= k\\n            if n == 1:\\n                return True\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 69286,
                "title": "simple-java-solution-using-factors-method",
                "content": "    public class Solution {\\n    public boolean isUgly(int num) {\\n        if (num <= 0) return false;\\n       \\n        int[] primes = {2, 3, 5};\\n        for(int prime : primes) {\\n            while(num % prime == 0) {\\n                num = num / prime;\\n            }\\n            if(num == 1) return true;\\n        }\\n        \\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isUgly(int num) {\\n        if (num <= 0) return false;\\n       \\n        int[] primes = {2, 3, 5}",
                "codeTag": "Java"
            },
            {
                "id": 69297,
                "title": "4ms-solution-in-c",
                "content": "    class Solution {\\n    public:\\n        bool isUgly(int num) {\\n            if(num < 1)\\n                return false;\\n            \\n            for(int i = 2; i <= 5; i++)\\n            {\\n                while(num%i == 0)\\n                    num /= i;\\n            }\\n            \\n            if(num != 1)\\n                return false;\\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isUgly(int num) {\\n            if(num < 1)\\n                return false;\\n            \\n            for(int i = 2; i <= 5; i++)\\n            {\\n                while(num%i == 0)\\n                    num /= i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 69329,
                "title": "simple-java-solution-for-ugly-number-problem",
                "content": "    public class Solution {\\n        public boolean isUgly(int num) {\\n            if (num == 0)\\n                return false;\\n                \\n            if (num == 1)\\n                return true;\\n            \\n            while (num % 5 == 0)\\n                num /= 5;\\n            \\n            while (num % 3 == 0)\\n                num /= 3;\\n                \\n            while (num % 2 == 0)\\n                num /= 2;\\n            \\n            return num == 1;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n        public boolean isUgly(int num) {\\n            if (num == 0)\\n                return false;\\n                \\n            if (num == 1)\\n                return true;\\n            \\n            while (num % 5 == 0)\\n                num /= 5;\\n            \\n            while (num % 3 == 0)\\n                num /= 3;\\n                \\n            while (num % 2 == 0)\\n                num /= 2;\\n            \\n            return num == 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 69316,
                "title": "java-python-c-solutions-for-you-guyz",
                "content": "JAVA \\n\\n    public class Solution {\\n        public boolean isUgly(int num) {\\n              if (num==0)\\n            return false;\\n            else {\\n                while(num!=1)\\n                {\\n                    if(num%2==0)\\n                    num/=2;\\n                    else if(num%3==0)\\n                    num/=3;\\n                    else if(num%5==0)\\n                    num/=5;\\n                    else break;\\n                }\\n                \\n                if(num==1)\\n                return true;\\n                else return false;\\n            }\\n        }\\n    }\\n\\nC++ \\n\\n    class Solution {\\n    public:\\n        bool isUgly(int num) {\\n            if (num==0)\\n            return false;\\n            else {\\n                while(num!=1)\\n                {\\n                    if(num%2==0)\\n                    num/=2;\\n                    else if(num%3==0)\\n                    num/=3;\\n                    else if(num%5==0)\\n                    num/=5;\\n                    else break;\\n                }\\n                \\n                if(num==1)\\n                return true;\\n                else return false;\\n            }\\n        }\\n    };\\n\\nPython\\n\\n    class Solution(object):\\n        def isUgly(self, num):\\n             if num==0:\\n                 return False\\n             else :\\n                 while(num!=1 and (num%2==0 or num%3==0 or num%5==0)):\\n                     if num%2==0:\\n                         num/=2\\n                     elif num%3==0:\\n                         num/=3\\n                     else:\\n                         num/=5\\n             if num==1:\\n                 return True\\n             else:\\n                 return False",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isUgly(int num) {\\n              if (num==0)\\n            return false;\\n            else {\\n                while(num!=1)\\n                {\\n                    if(num%2==0)\\n                    num/=2;\\n                    else if(num%3==0)\\n                    num/=3;\\n                    else if(num%5==0)\\n                    num/=5;\\n                    else break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3834432,
                "title": "java-easy-solution-100",
                "content": "\\n#### Just divide by 2, 3 and 5 as often as possible and then check whether we arrived at 1.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n      if(n <= 0) return false;\\n      while(n % 2 == 0) n /= 2;\\n      while(n % 3 == 0) n /= 3;\\n      while(n % 5 == 0) n /= 5;\\n      return n == 1; \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n      if(n <= 0) return false;\\n      while(n % 2 == 0) n /= 2;\\n      while(n % 3 == 0) n /= 3;\\n      while(n % 5 == 0) n /= 5;\\n      return n == 1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838245,
                "title": "easy-c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n<1) return false;\\n        if(n==1) return true;\\n        if(n%2 == 0) return isUgly(n/2);\\n        if(n%3 == 0) return isUgly(n/3);\\n        if(n%5 == 0) return isUgly(n/5);\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n<1) return false;\\n        if(n==1) return true;\\n        if(n%2 == 0) return isUgly(n/2);\\n        if(n%3 == 0) return isUgly(n/3);\\n        if(n%5 == 0) return isUgly(n/5);\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827328,
                "title": "c-solution",
                "content": "``` C++ []\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n\\n        if (n==0) return 0;\\n\\n        for (int i: {2,3,5}) {\\n            while (n%i==0) n/=i;\\n        }\\n\\n        return n==1;\\n    }\\n};\\n```\\n\\n*Upvote solution if it helped you*",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n\\n        if (n==0) return 0;\\n\\n        for (int i: {2,3,5}) {\\n            while (n%i==0) n/=i;\\n        }\\n\\n        return n==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826354,
                "title": "java-one-liner-ternary-operator",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        return n!=0?((n%2==0)?isUgly(n/2):((n%3==0)?isUgly(n/3):((n%5==0)?isUgly(n/5):n==1))):false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        return n!=0?((n%2==0)?isUgly(n/2):((n%3==0)?isUgly(n/3):((n%5==0)?isUgly(n/5):n==1))):false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826068,
                "title": "c-easy-understanding-log-n-video-solution",
                "content": "**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/UBebk6YTOh4\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n\\n        if( n == 0) return 0;\\n\\n        while(n%2 == 0) n = n/2;\\n        while(n%3 == 0) n =n/3;\\n        while(n%5 == 0) n = n/5;\\n\\n        return n == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n\\n        if( n == 0) return 0;\\n\\n        while(n%2 == 0) n = n/2;\\n        while(n%3 == 0) n =n/3;\\n        while(n%5 == 0) n = n/5;\\n\\n        return n == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825861,
                "title": "simple-and-easy-to-understand-c-approach-0ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly, we need to check that number is positive and greater than 0,\\nand the number should be divisible by 2,3 & 5 only or any one of them.\\nIf the number is divisible by another prime then the given number is not ugly number!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly we check if the number is less than 1 even negative then we return false, else we check if number is divisible by 2,3 & 5.\\nFirstly if number is 1 then we return true, else we follow next step.\\n\\nFor this we check if number is divisible by 2,3 or 5 if it is divisible by any one of them ..(Let\\'s say if number is divisible by 2 then we divide the number by 2 and check if it is still divisible by 3 or 5 till number becomes 1) . \\n\\nIf number finally becomes 1 the answer will return true and loop will end , else if number is divisible by any other prime and the  number is not equal to 1 then answer will return false.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n<=0)return false;\\n        while(n>0)\\n        {\\n            if(n==1)\\n            return true;\\n            if(n%2==0)\\n            n/=2;\\n            else if(n%3==0)\\n            n/=3;\\n            else if(n%5==0)\\n            n/=5;\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n<=0)return false;\\n        while(n>0)\\n        {\\n            if(n==1)\\n            return true;\\n            if(n%2==0)\\n            n/=2;\\n            else if(n%3==0)\\n            n/=3;\\n            else if(n%5==0)\\n            n/=5;\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825671,
                "title": "most-easy-and-intuitive-c-solution-beginner-friendly-fully-explained",
                "content": "**Please Upvote if you like the Solution and explanation**\\n\\nwe have to check weather the prime factor of \\'n\\' are limited to 2,3 and 5 if yes then it is a ugly number else its not\\n    \\n* To do this we have 3 prime numbers to check 2,3 and 5 stored in \\'primeNumbers\\'. \\n* we loop through primeNumbers and inside this loop initiate a while loop as long as a particular primeNumber is a divisor of n.\\n* after ending of both loop if \\'n\\' == 1 return true [because no other prime number is factor of \\'n\\' ] else return false [there is a prime number which is factor of \\'n\\']\\n\\nclass Solution {\\npublic:\\n\\n    bool isUgly(int n) {\\n        if(n <= 0) {\\n            return false;\\n        }\\n        vector<int>primeNumbers = {2,3,5};\\n        for(int i=0;i<primeNumbers.size();i++) {\\n            while(n % primeNumbers[i] == 0) {\\n                n = n/primeNumbers[i];\\n            }\\n        }\\n        if(n == 1) {\\n            return true;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool isUgly(int n) {\\n        if(n <= 0) {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2825477,
                "title": "daily-leetcoding-challenge-november-day-18",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/ugly-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/ugly-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2746310,
                "title": "java-faster-easy-and-elegant-solution",
                "content": "**1st Solution--> Efficient**\\n\\n```\\nif (n < 1) return false;\\nwhile (n % 2 == 0) n = n / 2;\\nwhile (n % 3 == 0) n = n / 3;\\nwhile (n % 5 == 0) n = n / 5;\\nreturn n == 1;\\n```\\n**2nd Solution**\\n```\\nif (n < 1) return false;\\nwhile (n != 1) {\\n\\tif (n % 2 == 0 || n % 3 == 0 || n % 5 == 0) {\\n\\t\\tif (n % 2 == 0) n = n / 2;\\n\\t\\telse if (n % 3 == 0) n = n / 3;\\n\\t\\telse if (n % 5 == 0) n = n / 5;\\n\\t} else return false;\\n}\\nreturn true;\\n```\\n\\n# Please UPVOTE if you like the solution or the explanation, If you have any question, feel free to ask",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nif (n < 1) return false;\\nwhile (n % 2 == 0) n = n / 2;\\nwhile (n % 3 == 0) n = n / 3;\\nwhile (n % 5 == 0) n = n / 5;\\nreturn n == 1;\\n```\n```\\nif (n < 1) return false;\\nwhile (n != 1) {\\n\\tif (n % 2 == 0 || n % 3 == 0 || n % 5 == 0) {\\n\\t\\tif (n % 2 == 0) n = n / 2;\\n\\t\\telse if (n % 3 == 0) n = n / 3;\\n\\t\\telse if (n % 5 == 0) n = n / 5;\\n\\t} else return false;\\n}\\nreturn true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2443054,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n<=0:\\n                return False\\n        while n>1:\\n            \\n            if n%2 == 0:\\n                n //= 2\\n            elif n%3 == 0:\\n                n //= 3\\n            elif n%5 ==0 :\\n                n //=5\\n            else:return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n<=0:\\n                return False\\n        while n>1:\\n            \\n            if n%2 == 0:\\n                n //= 2\\n            elif n%3 == 0:\\n                n //= 3\\n            elif n%5 ==0 :\\n                n //=5\\n            else:return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791985,
                "title": "c-0ms-solution",
                "content": "class Solution {\\npublic:\\n\\n    bool isUgly(int n) {\\n        if(n<=0) return false;\\n        while(n>1){\\n            if(n%2==0)\\n                n=n/2;\\n            else if(n%3==0)\\n                n=n/3;\\n            else if(n%5==0)\\n                n=n/5;\\n            else return false;\\n        \\n        }\\n        return true;   \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool isUgly(int n) {\\n        if(n<=0) return false;\\n        while(n>1){\\n            if(n%2==0)\\n                n=n/2;\\n            else if(n%3==0)\\n                n=n/3;\\n            else if(n%5==0)\\n                n=n/5;\\n            else return false;\\n        \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1785332,
                "title": "java-most-easy-solution",
                "content": "\\n\\tclass Solution {\\n    public boolean isUgly(int n) {\\n       if(n==0){\\n           return false;\\n       }\\n        if(n==1){\\n            return true;\\n        }\\n      return (n%2==0 && isUgly(n/2) ||\\n         n%3==0 && isUgly(n/3) ||\\n         n%5==0 && isUgly(n/5));\\n            \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public boolean isUgly(int n) {\\n       if(n==0){\\n           return false;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 1710593,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n <= 0)\\n            return false;\\n        if(n == 1)\\n            return true;\\n        while(n % 2 == 0) n = n / 2;\\n        while(n % 3 == 0) n = n / 3;\\n        while(n % 5 == 0) n = n / 5;\\n        return n == 1;\\n    }\\n}\\n```\\nGuy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE.\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n <= 0)\\n            return false;\\n        if(n == 1)\\n            return true;\\n        while(n % 2 == 0) n = n / 2;\\n        while(n % 3 == 0) n = n / 3;\\n        while(n % 5 == 0) n = n / 5;\\n        return n == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452790,
                "title": "olog-n-javascript-solution",
                "content": "```\\nvar isUgly = function(n) {\\n    //all negatvies and zero are not ugly\\n    if(n<=0) return false\\n    //remove prime factors\\n    while(n%2===0 || n%3===0 || n%5===0){\\n        if(n%2===0) n = n/2\\n        if(n%3===0) n = n/3\\n        if(n%5===0) n = n/5\\n    }\\n\\t//if all prime factors have been removed and there exists no other\\n\\t//it should be 1. If not, then it is false\\n    return n===1 \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isUgly = function(n) {\\n    //all negatvies and zero are not ugly\\n    if(n<=0) return false\\n    //remove prime factors\\n    while(n%2===0 || n%3===0 || n%5===0){\\n        if(n%2===0) n = n/2\\n        if(n%3===0) n = n/3\\n        if(n%5===0) n = n/5\\n    }\\n\\t//if all prime factors have been removed and there exists no other\\n\\t//it should be 1. If not, then it is false\\n    return n===1 \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1230134,
                "title": "java-solution-100",
                "content": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n == 0){\\n            return false;\\n        }\\n        for(int i = 2; i < 6; i++){\\n            while(n % i == 0){\\n                n /= i;\\n            }\\n        }\\n        return n == 1;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isUgly(int n) {\\n        if(n == 0){\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1194440,
                "title": "100-faster-code-super-easy",
                "content": "***Do upvote if you like it to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n <= 0)\\n          return false;\\n        while(n>1)\\n        {\\n            if(n%2 == 0)\\n                n/=2;\\n            else if(n%3 == 0)\\n                n/=3;\\n            else if(n%5 == 0)\\n                n/=5;\\n            else \\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n <= 0)\\n          return false;\\n        while(n>1)\\n        {\\n            if(n%2 == 0)\\n                n/=2;\\n            else if(n%3 == 0)\\n                n/=3;\\n            else if(n%5 == 0)\\n                n/=5;\\n            else \\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229012,
                "title": "javascript",
                "content": "**\\u89E3\\u9898\\u601D\\u8DEF:**\\n1. \\u5BF9[2, 3, 5]\\u6765\\u8BF4, num\\u4E0D\\u65AD\\u8FDB\\u884C\\u76F8\\u9664, \\u76F4\\u5230\\u65E0\\u6CD5\\u9664.\\n\\n**\\u4EE3\\u7801:**\\n```\\nvar isUgly = function(num) {\\n  const v = [5, 3, 2];\\n  for (let i = 0; i < v.length && num > 1; i++) {\\n    while (num % v[i] === 0) num /= v[i];\\n  }\\n  return num === 1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isUgly = function(num) {\\n  const v = [5, 3, 2];\\n  for (let i = 0; i < v.length && num > 1; i++) {\\n    while (num % v[i] === 0) num /= v[i];\\n  }\\n  return num === 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 69283,
                "title": "easy-to-understand-python-solution-beat-90-python-submissions",
                "content": "    class Solution(object):\\n    def isUgly(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: bool\\n        \"\"\"\\n        if num == 0:\\n            return False\\n            \\n        while num%2 == 0:\\n            num = num/2\\n        while num%3 == 0:\\n            num = num/3\\n        while num%5 == 0:\\n            num = num/5\\n        \\n        if num == 1:\\n            return True\\n        else:\\n            return False",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def isUgly(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: bool\\n        \"\"\"\\n        if num == 0:\\n            return False\\n            \\n        while num%2 == 0:\\n            num = num/2\\n        while num%3 == 0:\\n            num = num/3\\n        while num%5 == 0:\\n            num = num/5\\n        \\n        if num == 1:\\n            return True\\n        else:\\n            return False",
                "codeTag": "Java"
            },
            {
                "id": 69296,
                "title": "java-solution-with-explanation-in-code",
                "content": "    public class Solution {\\n        public boolean isUgly(int num) {\\n            if(num<=0){\\n                return false;\\n            }\\n            while((num&1)==0){\\n                //number is divisible by 2\\n                num = num/2;\\n            }\\n            while(num%5==0){\\n                //number is divisible by 5\\n                num = num/5;\\n            }\\n            while(num%3==0){\\n                //number is divisible by 5\\n                num = num/3;\\n            }\\n            return num==1;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isUgly(int num) {\\n            if(num<=0){\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3923595,
                "title": "java-easy-solution-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere i have used basic concept \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(sqrt(n))\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n<=0) return false;\\n       for(int i=2;i<6 && n>0 ;i++){\\n           while(n%i==0){\\n               n/=i;\\n           }\\n       }\\n       return n==1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n<=0) return false;\\n       for(int i=2;i<6 && n>0 ;i++){\\n           while(n%i==0){\\n               n/=i;\\n           }\\n       }\\n       return n==1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206016,
                "title": "check-if-a-number-is-an-ugly-number-o-log-n-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to check whether a given number is an ugly number or not. An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. So we can check whether a number is an ugly number by dividing the number by 2, 3, and 5, and if we can obtain 1 as the result after the division, then the given number is an ugly number, else it is not\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use the above intuition to solve the problem. We first check whether the given number is less than or equal to 0, in which case it cannot be an ugly number. Then we divide the number by 2, 3, and 5 as long as it is divisible by these numbers. Finally, we check if the resulting number is 1, in which case the original number is an ugly number, or not, in which case it is not an ugly number.\\n# Complexity\\n- Time complexity:  The time complexity of this approach is $$O(logn)$$, where $$n$$ is the given number. This is because we are dividing the number by 2, 3, and 5 repeatedly until we cannot divide it any further. Since the maximum number of times we can divide a number by 2, 3, or 5 is $$log(n)$$, the time complexity is $$O(log n)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of this approach is $$O(1)$$, as we are not using any extra space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n <= 0:\\n            return False\\n        while n % 2 == 0:\\n            n //= 2\\n        while n % 3 == 0:\\n            n //= 3\\n        while n % 5 == 0:\\n            n //= 5\\n        return n == 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n <= 0:\\n            return False\\n        while n % 2 == 0:\\n            n //= 2\\n        while n % 3 == 0:\\n            n //= 3\\n        while n % 5 == 0:\\n            n //= 5\\n        return n == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091174,
                "title": "most-optimal-code-in-c-and-easiest-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n==0)return false;\\n\\n\\n        while(n%2==0)n/=2;\\n        while(n%3==0)n/=3;\\n        while(n%5==0)n/=5;\\n        return n==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n==0)return false;\\n\\n\\n        while(n%2==0)n/=2;\\n        while(n%3==0)n/=3;\\n        while(n%5==0)n/=5;\\n        return n==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074168,
                "title": "easy-to-understand-solution-in-java",
                "content": "\\n# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n==0) return false;\\n        while(n%2==0)\\n        n=n/2;\\n        while(n%3==0)\\n        n=n/3;\\n        while(n%5==0)\\n        n=n/5;\\n\\n        if(n==1) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n==0) return false;\\n        while(n%2==0)\\n        n=n/2;\\n        while(n%3==0)\\n        n=n/3;\\n        while(n%5==0)\\n        n=n/5;\\n\\n        if(n==1) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832777,
                "title": "js-o-log-n-o-1-97-with-explanation",
                "content": "# Intuition\\nThe first thought for solving this problem is to simply divide the value without a remainder by 2 or 3 or 5 until we get 1, otherwise - **false**.\\n\\n# Approach\\nIn the process, the solution was slightly improved, as a result, we have the following solution steps:\\n1. Let\\'s do a default check for 1, 2, 3 and 5;\\n2. n needs to be a positive integer, so return false if n <= 0;\\n3. create an array with our main multipliers - [2, 3, 5];\\n4. divide n by 2, 3, 5 as much as possible to see if there are any other prime factor left.\\n\\n# Complexity\\n- Time complexity: O(log(n)).\\n\\n- Space complexity: O(1).\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar isUgly = function(n) {\\n    if (n < 1) return false;\\n    if (n === 1 || n === 2 || n === 3 || n === 4 || n === 5) return true;\\n\\n  var divisor = [2, 3, 5];\\n\\n  for (var i = 0; i < divisor.length; i++) {\\n    while (n && n % divisor[i] === 0) {\\n      n = Math.floor(n / divisor[i]);\\n    }\\n  }\\n\\n  return n === 1;\\n};\\n```\\n\\nI hope I was able to explain clearly.\\n**Happy coding!** \\uD83D\\uDE43",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar isUgly = function(n) {\\n    if (n < 1) return false;\\n    if (n === 1 || n === 2 || n === 3 || n === 4 || n === 5) return true;\\n\\n  var divisor = [2, 3, 5];\\n\\n  for (var i = 0; i < divisor.length; i++) {\\n    while (n && n % divisor[i] === 0) {\\n      n = Math.floor(n / divisor[i]);\\n    }\\n  }\\n\\n  return n === 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2827940,
                "title": "263-ugly-number-just-4-lines-of-code",
                "content": "If you like the solution then an upvote would really be a O(n) decision :)\\n```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        int num=n;\\n        for (int i=2; i<6 && num>0; i++)\\n    while (num % i == 0)\\n        num /= i;\\nreturn num == 1;\\n\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isUgly(int n) {\\n        int num=n;\\n        for (int i=2; i<6 && num>0; i++)\\n    while (num % i == 0)\\n        num /= i;\\nreturn num == 1;\\n\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2826991,
                "title": "java-most-easiest-solution",
                "content": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if (n < 1) return false;\\n        while (n % 2 == 0) {\\n            n /= 2;\\n        }\\n        while (n % 3 == 0) {\\n            n /= 3;\\n        }\\n        while (n % 5 == 0) {\\n            n /= 5;\\n        }\\n        return n == 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if (n < 1) return false;\\n        while (n % 2 == 0) {\\n            n /= 2;\\n        }\\n        while (n % 3 == 0) {\\n            n /= 3;\\n        }\\n        while (n % 5 == 0) {\\n            n /= 5;\\n        }\\n        return n == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826238,
                "title": "simple-python-solution",
                "content": "# Intuition\\nNeed to divide number on 5, 3, 2 respectively and compare result with 1.\\nIf number <= 0 it can not be ugly because 100% it has some negative factor not in [2,3,5]\\n\\n# Approach\\n1. If n <= 0 return False\\n2. For each factor: Devide in loop n on factor while remainder of division == 0\\n3. Compare result of n with 1. If it is 1 n is an ugly number\\n\\n# Complexity\\n- Time complexity:\\n$$O(log(N))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n <= 0:\\n            return False\\n        factors = [5, 3, 2]\\n        for factor in factors:\\n            while n % factor == 0:\\n                n //= factor\\n        return n == 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n <= 0:\\n            return False\\n        factors = [5, 3, 2]\\n        for factor in factors:\\n            while n % factor == 0:\\n                n //= factor\\n        return n == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826171,
                "title": "java-easy-solution-100-faster-o-logn",
                "content": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n <= 0){\\n            return false;\\n        }\\n        \\n        int[] arr = {2 , 3 , 5};\\n        \\n        for(int i = 0 ; i < arr.length ; i++){\\n            while(n % arr[i] == 0){\\n                n = n / arr[i];\\n            }\\n        }\\n        return n==1;\\n    }\\n}\\n```\\n\\n**Please  Upvote**",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n <= 0){\\n            return false;\\n        }\\n        \\n        int[] arr = {2 , 3 , 5};\\n        \\n        for(int i = 0 ; i < arr.length ; i++){\\n            while(n % arr[i] == 0){\\n                n = n / arr[i];\\n            }\\n        }\\n        return n==1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826092,
                "title": "python-log-n-simple-solution",
                "content": "# Intuition\\n- **Factorization** is a process of calculating prime factors for a given number.\\n- **Prime numbers** are numbers that can be divided on themselves and 1 with `mod=0`.\\n- **Factors** are multiplicators of a given number.\\n\\nThere is an algorithm to find prime factors for not big numbers and small prime factors \\u2013 https://en.wikipedia.org/wiki/Quadratic_sieve\\n\\n# Approach\\n\\n- In our case the sieve is known \\u2013 `(2, 3, 5)`\\n- Until `n == 1` (see the definition of prime numbers)\\n  - Try to divide `n` on numbers in `sieve` with `mod=0`\\n  - If can, then divide `n` on this number and continue\\n  - If cannot, return `false`\\n\\n# Complexity\\n- Time complexity: log(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        \\n        if n == 0: return False\\n\\n        sieve = (2, 3, 5)\\n\\n        while n != 1:\\n            for f in sieve:\\n               if n % f == 0:\\n                   n = n // f\\n                   break\\n            else:\\n                return False\\n\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        \\n        if n == 0: return False\\n\\n        sieve = (2, 3, 5)\\n\\n        while n != 1:\\n            for f in sieve:\\n               if n % f == 0:\\n                   n = n // f\\n                   break\\n            else:\\n                return False\\n\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815420,
                "title": "easy-c-solution-n-complexity",
                "content": "# Complexity\\n- Time complexity:\\n    O(logn)\\n\\n- Space complexity:\\n    O(1)\\n\\n# Solution ->\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n==0) return false;\\n        while(n%2==0){\\n            n=n/2;\\n        }\\n        while(n%3==0){\\n            n=n/3;\\n        }\\n        while(n%5==0){\\n            n=n/5;\\n        }\\n        if(n==1) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n==0) return false;\\n        while(n%2==0){\\n            n=n/2;\\n        }\\n        while(n%3==0){\\n            n=n/3;\\n        }\\n        while(n%5==0){\\n            n=n/5;\\n        }\\n        if(n==1) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685757,
                "title": "c-basic-concept",
                "content": "# PLease Upvote if Usefull\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        \\n        if( n==0) return false;\\n        \\n        while( n%2==0){\\n            n=n/2;\\n        }\\n        \\n        while( n%3==0){\\n            n=n/3;\\n        }\\n        while( n%5==0){\\n            n=n/5;\\n        }\\n        return (n==1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        \\n        if( n==0) return false;\\n        \\n        while( n%2==0){\\n            n=n/2;\\n        }\\n        \\n        while( n%3==0){\\n            n=n/3;\\n        }\\n        while( n%5==0){\\n            n=n/5;\\n        }\\n        return (n==1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629644,
                "title": "python-easy-to-understand-clean",
                "content": "```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n <= 0: return False\\n        for i in [2,3,5] :\\n            while n % i==0 :\\n                n = n//i\\n        return n==1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n <= 0: return False\\n        for i in [2,3,5] :\\n            while n % i==0 :\\n                n = n//i\\n        return n==1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494758,
                "title": "java-o-logn-1ms-100",
                "content": "Please Upvote if Helpful\\n\\nDivide the Number by 2, 3 and 5 unless the remainder is not 0. Check the resultant number is 1 or not.\\n\\n***\\n\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        \\n        if(n < 1) { return false; }\\n        if(n < 7) { return true; }\\n        \\n        while(n % 2 == 0) {\\n            n /= 2;\\n        }\\n        \\n        while(n % 3 == 0) {\\n            n /= 3;\\n        }\\n        \\n        while(n % 5 == 0) {\\n            n /= 5;\\n        }\\n        \\n        return n == 1 ? true : false;        \\n    }\\n}\\n\\n***",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isUgly(int n) {\\n        \\n        if(n < 1) { return false; }",
                "codeTag": "Java"
            },
            {
                "id": 2345474,
                "title": "python-93-76-faster-simplest-solution-with-explanation-beg-to-adv-math",
                "content": "```python\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        \\n        prime = [2, 3, 5] # prime factors list provided in question againt which we have to check the provided number. \\n        \\n        if n == 0: # as we dont have factors for 0\\n            return False \\n        \\n        for p in prime: # traversing prime numbers from given prime number list.\\n            while n % p == 0: # here we`ll check if the number is having the factor or not. For instance 6%2==0 is true implies 2 is a factor of 6.\\n                n //= p # num = num//p # in this we`ll be having 3(6/2), 1(3/3). Doing this division to update our number\\n        return n == 1 # at last we`ll always have 1, if the number would have factors from the provided list \\n```\\n\\nTo understand it in better way, following is the expansion way it works too:- \\n```python\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n == 0: return False;\\n        while n%2 == 0:\\n            n /= 2\\n        while n%3 == 0:\\n            n /= 3\\n        while n%5 == 0:\\n            n /= 5\\n        return n == 1\\n```\\n![image](https://assets.leetcode.com/users/images/4d0c3e30-765e-46e9-9aea-23bd3b5c4ad7_1659005579.1274734.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        \\n        prime = [2, 3, 5] # prime factors list provided in question againt which we have to check the provided number. \\n        \\n        if n == 0: # as we dont have factors for 0\\n            return False \\n        \\n        for p in prime: # traversing prime numbers from given prime number list.\\n            while n % p == 0: # here we`ll check if the number is having the factor or not. For instance 6%2==0 is true implies 2 is a factor of 6.\\n                n //= p # num = num//p # in this we`ll be having 3(6/2), 1(3/3). Doing this division to update our number\\n        return n == 1 # at last we`ll always have 1, if the number would have factors from the provided list \\n```\n```python\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n == 0: return False;\\n        while n%2 == 0:\\n            n /= 2\\n        while n%3 == 0:\\n            n /= 3\\n        while n%5 == 0:\\n            n /= 5\\n        return n == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299141,
                "title": "c-0-ms-recursive-iterative-soln",
                "content": "itrative\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        int i=2;\\n        if(n<=0) return false;\\n        while(n!=1){\\n            while(n%i==0) n/=i;\\n            if(i>5) return false;\\n            i++;\\n        }return true;\\n    }\\n};\\n```\\nrecursive\\n```\\nclass Solution\\n{\\npublic:\\n    bool isUgly(int n)\\n    {\\n        if (n == 1)return true;\\n        if (n <= 0)return false;\\n        if (n % 2 == 0)return isUgly(n / 2);\\n        if (n % 3 == 0)return isUgly(n / 3);\\n        if (n % 5 == 0)return isUgly(n / 5);\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        int i=2;\\n        if(n<=0) return false;\\n        while(n!=1){\\n            while(n%i==0) n/=i;\\n            if(i>5) return false;\\n            i++;\\n        }return true;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    bool isUgly(int n)\\n    {\\n        if (n == 1)return true;\\n        if (n <= 0)return false;\\n        if (n % 2 == 0)return isUgly(n / 2);\\n        if (n % 3 == 0)return isUgly(n / 3);\\n        if (n % 5 == 0)return isUgly(n / 5);\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283690,
                "title": "python-simple-solution",
                "content": "```\\ndef isUgly(self, n: int) -> bool:\\n        \\n        if n<=0:\\n            return False\\n        \\n        if n==2 or n==3 or n==5 or n==1:\\n            return True\\n        \\n        for idx in range(0,n//2):\\n            if(n%2==0):\\n                n=n/2\\n            elif(n%3==0):\\n                n=n/3\\n            elif(n%5==0):\\n                n=n/5\\n            elif n==1:\\n                return True\\n            else:\\n                return False\\n        \\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\ndef isUgly(self, n: int) -> bool:\\n        \\n        if n<=0:\\n            return False\\n        \\n        if n==2 or n==3 or n==5 or n==1:\\n            return True\\n        \\n        for idx in range(0,n//2):\\n            if(n%2==0):\\n                n=n/2\\n            elif(n%3==0):\\n                n=n/3\\n            elif(n%5==0):\\n                n=n/5\\n            elif n==1:\\n                return True\\n            else:\\n                return False\\n        \\n        \\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2149946,
                "title": "0-ms-100-faster-c-clean-easy",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isUgly(int n) {\\n\\t\\t\\tif(n==0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\twhile(n%2==0)\\n\\t\\t\\t\\tn/=2;\\n\\t\\t\\twhile(n%3==0)\\n\\t\\t\\t\\tn/=3;\\n\\t\\t\\twhile(n%5==0)\\n\\t\\t\\t\\tn/=5;\\n\\t\\t\\treturn n==1;\\n\\t\\t}\\n\\t};\\n\\n\\tpls upvote if it was helpful :)",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isUgly(int n) {\\n\\t\\t\\tif(n==0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\twhile(n%2==0)\\n\\t\\t\\t\\tn/=2;\\n\\t\\t\\twhile(n%3==0)\\n\\t\\t\\t\\tn/=3;\\n\\t\\t\\twhile(n%5==0)\\n\\t\\t\\t\\tn/=5;\\n\\t\\t\\treturn n==1;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2070885,
                "title": "java-1ms-3-lines-easy-solution",
                "content": "**Read the comments on return statement first fo better understanding**\\n```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n\\t\\n\\t\\t//we will try to calcute for factors from 2 to 5 i.e. if the number gets 1 by any set of factorials, from 2 to 5\\n        for(int i=2; i<6 && n!=0; i++){\\n\\t\\t\\n\\t\\t// run the loop untill n is completely divisible by the factor i.e. current iteration of for loop, we will here decrease the number by dividing to iteration, i.e. by the factor for which we are currently calculating\\n\\t\\t//if this loop breaks, i value will get incremented because of for loop, which will help us checking for another factor\\n            while(n%i == 0) n/=i;\\n        }\\n\\t\\t\\n\\t\\t// return true if the number is 1, i.e it broke down for any set of factors ranging from 2 to 5,\\n\\t\\t// if the number is anything than 1, it simply means, any set of factors from 2 to 5 was not able to break down the number, hence its one of the prime factor is greater than 5.\\n        return n==1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n\\t\\n\\t\\t//we will try to calcute for factors from 2 to 5 i.e. if the number gets 1 by any set of factorials, from 2 to 5\\n        for(int i=2; i<6 && n!=0; i++){\\n\\t\\t\\n\\t\\t// run the loop untill n is completely divisible by the factor i.e. current iteration of for loop, we will here decrease the number by dividing to iteration, i.e. by the factor for which we are currently calculating\\n\\t\\t//if this loop breaks, i value will get incremented because of for loop, which will help us checking for another factor\\n            while(n%i == 0) n/=i;\\n        }\\n\\t\\t\\n\\t\\t// return true if the number is 1, i.e it broke down for any set of factors ranging from 2 to 5,\\n\\t\\t// if the number is anything than 1, it simply means, any set of factors from 2 to 5 was not able to break down the number, hence its one of the prime factor is greater than 5.\\n        return n==1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023547,
                "title": "0ms-c-solution-with-one-while-loop-only",
                "content": "**Algorithm**\\n* Just divide by 2, 3 and 5 as often as possible and then check whether we arrived at 1. \\n* If n is less than 1, simply reverse false.\\n\\n```\\nbool isUgly(int n){\\n    if(n < 1) return false;\\n    for(int i=2; i<6  ; i++)\\n        while(n %i == 0)\\n            n/=i;\\n    return n==1;\\n}\\n```\\n**If found helpful please upvote**\\n*Feel free to ask if there\\'s any query in comment.*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isUgly(int n){\\n    if(n < 1) return false;\\n    for(int i=2; i<6  ; i++)\\n        while(n %i == 0)\\n            n/=i;\\n    return n==1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1830307,
                "title": "java-solution-ugly-number",
                "content": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n==1||n==2||n==3||n==5)return true;\\n        if(n==0)return false;\\n        while(n%2==0){\\n            n = n/2;\\n        }\\n        while(n%3==0){\\n            n = n/3;\\n        }\\n        while(n%5==0){\\n            n = n/5;\\n        }\\n        return n==1;\\n    }\\n}\\n```\\n\\nHappy Coding!!!\\nDo upvote if you like the Solution.\\nAny queries or suggestions? Sure!! Ping me :\\n* [[LinkedIn](https://www.linkedin.com/in/rohitm17/)]  \\n* [[Twitter](https://twitter.com/rohit_mittal17)]\\n* [[GitHub](https://github.com/rohitm17)]\\n* [[Medium](https://medium.com/@rohitm17)]",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n==1||n==2||n==3||n==5)return true;\\n        if(n==0)return false;\\n        while(n%2==0){\\n            n = n/2;\\n        }\\n        while(n%3==0){\\n            n = n/3;\\n        }\\n        while(n%5==0){\\n            n = n/5;\\n        }\\n        return n==1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1754482,
                "title": "python-o-1-space-complexity-beats-100-when-i-submitted",
                "content": "```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n == 0: return False;\\n        while n%2 == 0:\\n            n /= 2\\n        while n%3 == 0:\\n            n /= 3\\n        while n%5 == 0:\\n            n /= 5\\n        return n == 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n == 0: return False;\\n        while n%2 == 0:\\n            n /= 2\\n        while n%3 == 0:\\n            n /= 3\\n        while n%5 == 0:\\n            n /= 5\\n        return n == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623760,
                "title": "short-and-sweet-c-solution-100-faster",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        for (auto& e : {2, 3, 5}){\\n            while (n && n%e == 0){\\n                n /= e;\\n            }\\n        }\\n        return n == 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        for (auto& e : {2, 3, 5}){\\n            while (n && n%e == 0){\\n                n /= e;\\n            }\\n        }\\n        return n == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622569,
                "title": "while-loop-in-python-beats-89-09",
                "content": "```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        def divide_all(divisor):\\n            nonlocal n\\n            while n > 1 and n % divisor == 0:\\n                n //= divisor\\n        \\n        #if n <= 0, always False\\n        if n < 1: return False\\n        \\n        #divide by 2 and 3 and 5 while you can divide\\n        divide_all(2); divide_all(3); divide_all(5)\\n        \\n        return n == 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        def divide_all(divisor):\\n            nonlocal n\\n            while n > 1 and n % divisor == 0:\\n                n //= divisor\\n        \\n        #if n <= 0, always False\\n        if n < 1: return False\\n        \\n        #divide by 2 and 3 and 5 while you can divide\\n        divide_all(2); divide_all(3); divide_all(5)\\n        \\n        return n == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601997,
                "title": "easy-python-solution",
                "content": "```\\ndef isUgly(self, n: int) -> bool:\\n        if n==0: return False\\n        for i in range(2,6):\\n            while(n%i==0):\\n                n//=i\\n        return n==1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef isUgly(self, n: int) -> bool:\\n        if n==0: return False\\n        for i in range(2,6):\\n            while(n%i==0):\\n                n//=i\\n        return n==1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1567335,
                "title": "simple-java-solution-with-explanation",
                "content": "It simply means that a number should be either divided bye 2 or 3 or 5 (Whereas 1 is considered as default ugly number). \\n\\n1:-  if a number is not Divisible by 2,3 or 5 then the number is not ugly number.\\n\\neg : let n = 14, at first pass 14 can be Completely Divisible by 2, so we make 14/2=7.\\n        in the second pass 7 is not Divisible by 2, 3, or 5 so we return false. \\n\\t\\tand we will stop the loop when n Becomes 1. \\n```\\npublic boolean isUgly(int n) {\\n        if(n == 0) return false;\\n        if(n == 1) return true;\\n        \\n        while(n != 1) {\\n            if(n % 2 == 0) {\\n                n = n/2;\\n            }\\n            else if(n % 3 == 0) {\\n                n = n/3;\\n            }\\n            else if( n % 5 == 0) {\\n                n = n/5;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\\nPlease upvote if you feel above Explanation was useful :)",
                "solutionTags": [],
                "code": "```\\npublic boolean isUgly(int n) {\\n        if(n == 0) return false;\\n        if(n == 1) return true;\\n        \\n        while(n != 1) {\\n            if(n % 2 == 0) {\\n                n = n/2;\\n            }\\n            else if(n % 3 == 0) {\\n                n = n/3;\\n            }\\n            else if( n % 5 == 0) {\\n                n = n/5;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1423874,
                "title": "simple-c-solution-100-faster-simple-math-logic-with-explanation",
                "content": "class Solution {\\npublic:\\n    bool isUgly(int n) {\\n        // edge case\\n        if(n==0) {\\n            return false;\\n        }\\n        // remove all 2\\'s factors\\n        while(n%2==0) {\\n            n = n/2;\\n        }\\n        \\n        // remove all 3\\'s factors\\n        while(n%3==0) {\\n            n = n/3;\\n        }\\n        \\n        // remove all 5\\'s factors\\n        while(n%5==0) {\\n            n = n/5;\\n        }\\n        \\n // now if n became 1 means all factors were only combinations of 2,3,5 which have been remove by above process\\n        if(n==1) {\\n            return true;\\n        }\\n        // else return false because it has other factors than 2 ,3 and 5\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isUgly(int n) {\\n        // edge case\\n        if(n==0) {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1236389,
                "title": "python3-simple-solution-beats-99-users",
                "content": "![image](https://assets.leetcode.com/users/images/d405b80e-571a-466c-a60f-6f2f999cce39_1622213154.4216669.png)\\n```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n <= 0:\\n            return False\\n        if n == 1:\\n            return True\\n        while n != 1:\\n            if n % 2 == 0:\\n                n //= 2\\n            elif n % 3 == 0:\\n                n //= 3\\n            elif n % 5 == 0:\\n                n //= 5\\n            else:\\n                return False\\n        return True\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n <= 0:\\n            return False\\n        if n == 1:\\n            return True\\n        while n != 1:\\n            if n % 2 == 0:\\n                n //= 2\\n            elif n % 3 == 0:\\n                n //= 3\\n            elif n % 5 == 0:\\n                n //= 5\\n            else:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119401,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if (n < 1) return false;\\n        if (n == 1) return true;\\n        if (n % 2 == 0) return isUgly(n/2);\\n        if (n % 3 == 0) return isUgly(n/3);\\n        if (n % 5 == 0) return isUgly(n/5);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if (n < 1) return false;\\n        if (n == 1) return true;\\n        if (n % 2 == 0) return isUgly(n/2);\\n        if (n % 3 == 0) return isUgly(n/3);\\n        if (n % 5 == 0) return isUgly(n/5);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103723,
                "title": "faster-than-99-34-python-solution-depends-on-test-cases-it-will-vary",
                "content": "\\tclass Solution:\\n\\t\\tdef isUgly(self, n: int) -> bool:\\n\\n\\t\\t\\twhile n>0:\\n\\t\\t\\t\\tif n==1:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tif n%2==0:\\n\\t\\t\\t\\t\\tn=n//2\\n\\t\\t\\t\\telif n%3==0:\\n\\t\\t\\t\\t\\tn=n//3\\n\\t\\t\\t\\telif n%5==0:\\n\\t\\t\\t\\t\\tn=n//5\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn False\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef isUgly(self, n: int) -> bool:\\n\\n\\t\\t\\twhile n>0:\\n\\t\\t\\t\\tif n==1:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tif n%2==0:\\n\\t\\t\\t\\t\\tn=n//2\\n\\t\\t\\t\\telif n%3==0:\\n\\t\\t\\t\\t\\tn=n//3\\n\\t\\t\\t\\telif n%5==0:\\n\\t\\t\\t\\t\\tn=n//5\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn False\\n",
                "codeTag": "Java"
            },
            {
                "id": 1001937,
                "title": "python-solution",
                "content": "\\tif num == 0:\\n\\t\\treturn False\\n\\twhile num % 2 == 0:\\n\\t\\tnum /= 2\\n\\twhile num % 3 == 0:\\n\\t\\tnum /= 3\\n\\twhile num % 5 == 0:\\n\\t\\tnum /= 5\\n\\treturn num == 1",
                "solutionTags": [],
                "code": "\\tif num == 0:\\n\\t\\treturn False\\n\\twhile num % 2 == 0:\\n\\t\\tnum /= 2\\n\\twhile num % 3 == 0:\\n\\t\\tnum /= 3\\n\\twhile num % 5 == 0:\\n\\t\\tnum /= 5\\n\\treturn num == 1",
                "codeTag": "Unknown"
            },
            {
                "id": 921274,
                "title": "100-java-plain-and-simple",
                "content": "```\\nclass Solution {\\n    public boolean isUgly(int num) {\\n        if (num == 0) return false;\\n            \\n        while (num % 2 == 0) { num /= 2; }\\n        while (num % 3 == 0) { num /= 3; }\\n        while (num % 5 == 0) { num /= 5; }\\n        \\n        return num == 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isUgly(int num) {\\n        if (num == 0) return false;\\n            \\n        while (num % 2 == 0) { num /= 2; }\\n        while (num % 3 == 0) { num /= 3; }\\n        while (num % 5 == 0) { num /= 5; }\\n        \\n        return num == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723468,
                "title": "java-1ms-beats-100-three-while-loops-to-perform-2-3-5",
                "content": "```\\nclass Solution {\\n  public boolean isUgly(int num) {\\n    \\n    /*\\n    Runtime: 1 ms, faster than 100.00% of Java online submissions for Ugly Number.\\n    Memory Usage: 36.6 MB, less than 70.69% of Java online submissions for Ugly Number.\\n    */\\n    \\n    if (num <= 0) {\\n      return false;\\n    }\\n\\n    while (num % 2 == 0) {\\n      num /= 2;\\n    }\\n    \\n    while (num % 3 == 0) {\\n      num /= 3;\\n    }\\n    \\n    while (num % 5 == 0) {\\n      num /= 5;\\n    }\\n    \\n    return (num == 1);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public boolean isUgly(int num) {\\n    \\n    /*\\n    Runtime: 1 ms, faster than 100.00% of Java online submissions for Ugly Number.\\n    Memory Usage: 36.6 MB, less than 70.69% of Java online submissions for Ugly Number.\\n    */\\n    \\n    if (num <= 0) {\\n      return false;\\n    }\\n\\n    while (num % 2 == 0) {\\n      num /= 2;\\n    }\\n    \\n    while (num % 3 == 0) {\\n      num /= 3;\\n    }\\n    \\n    while (num % 5 == 0) {\\n      num /= 5;\\n    }\\n    \\n    return (num == 1);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688967,
                "title": "c-easy-solution-100-00",
                "content": "```\\nbool isUgly(int num) {\\n\\tif (num <= 0)\\n\\t\\treturn false;\\n\\n\\tif (num % 5 == 0)\\n\\t   return isUgly(num / 5);\\n\\telse if (num % 3 == 0)\\n\\t   return isUgly(num / 3);\\n\\telse if (num % 2 == 0)\\n\\t   return isUgly(num / 2);\\n\\n\\tif (num == 1)\\n\\t\\treturn true;\\n\\treturn false;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool isUgly(int num) {\\n\\tif (num <= 0)\\n\\t\\treturn false;\\n\\n\\tif (num % 5 == 0)\\n\\t   return isUgly(num / 5);\\n\\telse if (num % 3 == 0)\\n\\t   return isUgly(num / 3);\\n\\telse if (num % 2 == 0)\\n\\t   return isUgly(num / 2);\\n\\n\\tif (num == 1)\\n\\t\\treturn true;\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 516634,
                "title": "ugly-not-only-number-but-also-my-code",
                "content": "```\\n    public boolean isUgly(int num) {\\n        if (num == 0) return false;\\n        while(num % 2 == 0) num /= 2;\\n        while(num % 3 == 0) num /= 3;\\n        while(num % 5 == 0) num /= 5;\\n        return num == 1;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    public boolean isUgly(int num) {\\n        if (num == 0) return false;\\n        while(num % 2 == 0) num /= 2;\\n        while(num % 3 == 0) num /= 3;\\n        while(num % 5 == 0) num /= 5;\\n        return num == 1;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 352587,
                "title": "c-solution-0ms-100-faster-and-8mb-100-less",
                "content": "https://leetcode.com/submissions/detail/249419983/\\n\\'\\'\\'\\n\\n    bool isUgly(int no) \\n    { \\n\\t\\tif(no<=0) return 0;\\n        if(no%2==0) no /= no & (~(no-1));  // Dividing no by the highest number (that\\'s a power of 2) that is divisible.\\n        while(no%3==0) // For divisiblity by 3.\\n            no/=3;\\n        while(no%5==0) // For divisiblity by 5.\\n            no/=5;\\n        return no==1;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "https://leetcode.com/submissions/detail/249419983/\\n\\'\\'\\'\\n\\n    bool isUgly(int no) \\n    { \\n\\t\\tif(no<=0) return 0;\\n        if(no%2==0) no /= no & (~(no-1));  // Dividing no by the highest number (that\\'s a power of 2) that is divisible.\\n        while(no%3==0) // For divisiblity by 3.\\n            no/=3;\\n        while(no%5==0) // For divisiblity by 5.\\n            no/=5;\\n        return no==1;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 69293,
                "title": "my-swift-solution",
                "content": "    func isUgly(num: Int) -> Bool {\\n            if num <= 0 {\\n                return false\\n            }\\n    \\n            var inputNum = num\\n            while inputNum > 1 {\\n                if inputNum % 2 == 0 {\\n                    inputNum /= 2\\n                } else if inputNum % 3 == 0 {\\n                    inputNum /= 3\\n                } else if inputNum % 5 == 0 {\\n                    inputNum /= 5\\n                } else {\\n                    break\\n                }\\n            }\\n    \\n            return inputNum == 1\\n        }",
                "solutionTags": [
                    "Swift"
                ],
                "code": "    func isUgly(num: Int) -> Bool {\\n            if num <= 0 {\\n                return false\\n            }\\n    \\n            var inputNum = num\\n            while inputNum > 1 {\\n                if inputNum % 2 == 0 {\\n                    inputNum /= 2\\n                } else if inputNum % 3 == 0 {\\n                    inputNum /= 3\\n                } else if inputNum % 5 == 0 {\\n                    inputNum /= 5\\n                } else {\\n                    break\\n                }\\n            }\\n    \\n            return inputNum == 1\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 69302,
                "title": "recursive-solution-is-faster-than-iterative-solution",
                "content": "Recursive solution in c++ is faster\\n \\n\\nbool isUgly(int num) {\\n\\n        if(num<1)return false;\\n        if(num==1) return true;\\n        if(num%2==0) return isUgly(num/2);\\n        else if(num%3==0) return isUgly(num/3);\\n        else if(num%5==0) return isUgly(num/5);\\n        else return false;\\n}",
                "solutionTags": [],
                "code": "Recursive solution in c++ is faster\\n \\n\\nbool isUgly(int num) {\\n\\n        if(num<1)return false;\\n        if(num==1) return true;\\n        if(num%2==0) return isUgly(num/2);\\n        else if(num%3==0) return isUgly(num/3);\\n        else if(num%5==0) return isUgly(num/5);\\n        else return false;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 69309,
                "title": "4ms-recursive-solution-in-c",
                "content": "\\n\\n    class Solution {\\n    public:\\n        bool isUgly(int num) {\\n            if (num == 1) return true;\\n            if (num == 0) return false;\\n            else if (num % 2 == 0) return isUgly(num / 2);\\n            else if (num % 3 == 0) return isUgly(num / 3);\\n            else if (num % 5 == 0) return isUgly(num / 5);\\n            else return false; \\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool isUgly(int num) {\\n            if (num == 1) return true;\\n            if (num == 0) return false;\\n            else if (num % 2 == 0) return isUgly(num / 2);\\n            else if (num % 3 == 0) return isUgly(num / 3);\\n            else if (num % 5 == 0) return isUgly(num / 5);\\n            else return false; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3822642,
                "title": "simple-c-solution-beats-100-00-of-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(!n) return false;\\n        \\n        while(!(n%2))\\n            n/=2;\\n\\n        while(!(n%3))\\n            n/=3;\\n\\n        while(!(n%5))\\n            n/=5;\\n        \\n        if(n==1) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(!n) return false;\\n        \\n        while(!(n%2))\\n            n/=2;\\n\\n        while(!(n%3))\\n            n/=3;\\n\\n        while(!(n%5))\\n            n/=5;\\n        \\n        if(n==1) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805112,
                "title": "recursion-easy-math-approach",
                "content": "# Intuition\\nStep 1: Firstly divide by 2 recursively.\\nStep 2: Then divide by 3 recursively.\\nStep 3: Then again divide by 5 recursively.\\nStep 4: If the quotient is q then return true else false.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n) --> Auxillary space\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n <= 0) return false;\\n        n = divi(n,2);\\n        n = divi(n,3);\\n        n = divi(n,5);\\n        return n == 1;\\n    }\\n    public int divi(int n, int dv){\\n        while(n % dv == 0) n/= dv;\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n <= 0) return false;\\n        n = divi(n,2);\\n        n = divi(n,3);\\n        n = divi(n,5);\\n        return n == 1;\\n    }\\n    public int divi(int n, int dv){\\n        while(n % dv == 0) n/= dv;\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497748,
                "title": "c-very-easy-to-understand-simple-code-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![cat.jpg](https://assets.leetcode.com/users/images/26f1f2cc-828c-44fe-9891-9a722c2f341e_1683485463.7127638.jpeg)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n==0) return false;\\n        while(n!=1)\\n        {\\n            cout<<n<<endl;\\n            if(n%2==0)      n=n/2;\\n            else if(n%3==0) n=n/3;\\n            else if(n%5==0) n=n/5;\\n            else return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n==0) return false;\\n        while(n!=1)\\n        {\\n            cout<<n<<endl;\\n            if(n%2==0)      n=n/2;\\n            else if(n%3==0) n=n/3;\\n            else if(n%5==0) n=n/5;\\n            else return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3488623,
                "title": "java-solution-beating-100-runtime",
                "content": "Runtime: 0ms\\n# Code\\n```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if (n==1) {\\n            return true;\\n        }\\n        if(n==0){\\n            return false;\\n        }\\n        if(n % 2 == 0){\\n            return isUgly (n/2);\\n        }\\n        else if(n % 3 == 0){\\n            return isUgly(n/3);\\n        }\\n        else if(n % 5 == 0){\\n            return isUgly(n/5);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if (n==1) {\\n            return true;\\n        }\\n        if(n==0){\\n            return false;\\n        }\\n        if(n % 2 == 0){\\n            return isUgly (n/2);\\n        }\\n        else if(n % 3 == 0){\\n            return isUgly(n/3);\\n        }\\n        else if(n % 5 == 0){\\n            return isUgly(n/5);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459362,
                "title": "go-recursive",
                "content": "# Intuition\\nAttention **n <= 0**\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nfunc isUgly(n int) bool {\\n    if n <= 0 {\\n\\t\\treturn false\\n\\t}\\n\\n\\tif n == 1 || n == 2 || n == 3 || n == 5 {\\n\\t\\treturn true\\n\\t}\\n\\n\\tif n%2 == 0 {\\n\\t\\treturn isUgly(n / 2)\\n\\t}\\n\\n\\tif n%3 == 0 {\\n\\t\\treturn isUgly(n / 3)\\n\\t}\\n\\n\\tif n%5 == 0 {\\n\\t\\treturn isUgly(n / 5)\\n\\t}\\n\\treturn false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isUgly(n int) bool {\\n    if n <= 0 {\\n\\t\\treturn false\\n\\t}\\n\\n\\tif n == 1 || n == 2 || n == 3 || n == 5 {\\n\\t\\treturn true\\n\\t}\\n\\n\\tif n%2 == 0 {\\n\\t\\treturn isUgly(n / 2)\\n\\t}\\n\\n\\tif n%3 == 0 {\\n\\t\\treturn isUgly(n / 3)\\n\\t}\\n\\n\\tif n%5 == 0 {\\n\\t\\treturn isUgly(n / 5)\\n\\t}\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3444715,
                "title": "super-easy-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n==0){\\n            return false;\\n        }\\n      while(n != 1){\\n          if(n%2==0){\\n              n/=2;\\n          }\\n          else if(n%3==0){\\n              n/=3;\\n          }\\n          else if(n%5==0){\\n              n/=5;\\n          }\\n          else{\\n              return false;\\n          }\\n      }\\n      return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n==0){\\n            return false;\\n        }\\n      while(n != 1){\\n          if(n%2==0){\\n              n/=2;\\n          }\\n          else if(n%3==0){\\n              n/=3;\\n          }\\n          else if(n%5==0){\\n              n/=5;\\n          }\\n          else{\\n              return false;\\n          }\\n      }\\n      return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356804,
                "title": "easy-c-sol",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n==0)return false;\\n        while(n%2==0)n/=2;\\n        while(n%3==0)n/=3;\\n        while(n%5==0)n/=5;\\n        return n==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n==0)return false;\\n        while(n%2==0)n/=2;\\n        while(n%3==0)n/=3;\\n        while(n%5==0)n/=5;\\n        return n==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184641,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public bool IsUgly(int n) {\\n        if(n==1) return true;\\n        if(n<=0) return false;\\n        while(n%2==0) n=n>>1;\\n        while(n%3==0) n/=3;\\n        while(n%5==0) n/=5;\\n\\n        return n==1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsUgly(int n) {\\n        if(n==1) return true;\\n        if(n<=0) return false;\\n        while(n%2==0) n=n>>1;\\n        while(n%3==0) n/=3;\\n        while(n%5==0) n/=5;\\n\\n        return n==1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056612,
                "title": "c-short-crisp-code",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust divide by 2, 3 and 5 as often as possible and then check whether we arrived at 1. Also try divisor 4 if that makes the code simpler / less repetitive.\\n\\n\\n# Code\\n```\\nfor (int i=2; i<6 && num; i++)\\n    while (num % i == 0)\\n        num /= i;\\nreturn num == 1;\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nfor (int i=2; i<6 && num; i++)\\n    while (num % i == 0)\\n        num /= i;\\nreturn num == 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3055486,
                "title": "4-diffrent-logic-1ms-only",
                "content": "# logic 1\\n```java\\n\\n// To Code : 10 min\\n// Execution : 1 ms\\n\\n// Time complexity: O(log(n))\\n// Space complexity: O(1)\\n\\nclass xyz {\\n\\tpublic static void main(String[] args) {\\n\\t\\tSolution s = new Solution();\\n\\n\\t\\tSystem.out.println(\"\\\\nAns:- \" + s.isUgly(14)); // false\\n\\t\\tSystem.out.println(\"\\\\nAns:- \" + s.isUgly(-12)); // false\\n\\t\\tSystem.out.println(\"\\\\nAns:- \" + s.isUgly(0)); // false\\n\\n\\t\\tSystem.out.println(\"\\\\nAns:- \" + s.isUgly(6)); // true\\n\\t\\tSystem.out.println(\"\\\\nAns:- \" + s.isUgly(1)); // true\\n\\t\\tSystem.out.println(\"\\\\nAns:- \" + s.isUgly(900)); // true\\n\\n\\t}\\n}\\n\\nclass Solution {\\n\\tpublic boolean isUgly(int n) {\\n\\t\\tSystem.out.println(\"\\\\nn: \" + n);\\n\\n\\t\\t// if -ve or zero\\n\\t\\t// for -ve no. also loop can handle\\n\\t\\t// but added here to same time ... y need to run loop for no reason\\n\\t\\tif (n <= 0)\\n\\t\\t\\treturn false;\\n\\n\\t\\t// // special case ... but loop will handle automatically\\n\\t\\t// if (n == 1)\\n\\t\\t// return true;\\n\\n\\t\\twhile (n != 1) { // n>1\\n\\t\\t\\tif (n % 2 == 0)\\n\\t\\t\\t\\tn /= 2;\\n\\t\\t\\telse if (n % 3 == 0)\\n\\t\\t\\t\\tn /= 3;\\n\\t\\t\\telse if (n % 5 == 0)\\n\\t\\t\\t\\tn /= 5;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tSystem.out.println(n);\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n}\\n\\n```\\n\\n# logic 2\\n\\n```java\\nclass Solution {\\n\\tpublic boolean isUgly(int n) {\\n\\t\\tif (n <= 0)\\n\\t\\t\\treturn false;\\n\\n\\t\\twhile (n % 5 == 0)\\n\\t\\t\\tn /= 5;\\n\\t\\twhile (n % 3 == 0)\\n\\t\\t\\tn /= 3;\\n\\t\\twhile (n % 2 == 0)\\n\\t\\t\\tn /= 2;\\n\\n\\t\\treturn n == 1;\\n\\t}\\n}\\n```\\n\\n# logic 3\\n- ... same as 1\\n- but little diff\\n\\n```java\\nclass Solution {\\n\\tpublic boolean isUgly(int n) {\\n\\n\\t\\tif (n <= 0)\\n\\t\\t\\treturn false;\\n\\n\\t\\twhile (true) {\\n\\t\\t\\tif (n % 2 == 0)\\n\\t\\t\\t\\tn /= 2;\\n\\t\\t\\telse if (n % 3 == 0)\\n\\t\\t\\t\\tn /= 3;\\n\\t\\t\\telse if (n % 5 == 0)\\n\\t\\t\\t\\tn /= 5;\\n\\t\\t\\telse\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\treturn n == 1;\\n\\t}\\n}\\n```\\n\\n# logic 4\\n\\n```java\\n// using \"factors list\"\\n// .... futuristic \\n// ... if more number get added/want to add\\n\\nclass Solution {\\n\\tpublic boolean isUgly(int n) {\\n\\t\\t// A non-positive integer cannot be ugly\\n\\t\\tif (n <= 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// Factorize by dividing with permitted factors\\n\\t\\tfor (int factor : new int[] { 2, 3, 5 }) {\\n\\t\\t\\tn = keepDividingWhenDivisible(n, factor);\\n\\t\\t}\\n\\n\\t\\t// Check if the integer is reduced to 1 or not.\\n\\t\\treturn n == 1;\\n\\t}\\n\\n\\t// Keep dividing dividend by divisor when division is possible.\\n\\tprivate int keepDividingWhenDivisible(int dividend, int divisor) {\\n\\t\\twhile (dividend % divisor == 0) {\\n\\t\\t\\tdividend /= divisor;\\n\\t\\t}\\n\\t\\treturn dividend;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```java\\n\\n// To Code : 10 min\\n// Execution : 1 ms\\n\\n// Time complexity: O(log(n))\\n// Space complexity: O(1)\\n\\nclass xyz {\\n\\tpublic static void main(String[] args) {\\n\\t\\tSolution s = new Solution();\\n\\n\\t\\tSystem.out.println(\"\\\\nAns:- \" + s.isUgly(14)); // false\\n\\t\\tSystem.out.println(\"\\\\nAns:- \" + s.isUgly(-12)); // false\\n\\t\\tSystem.out.println(\"\\\\nAns:- \" + s.isUgly(0)); // false\\n\\n\\t\\tSystem.out.println(\"\\\\nAns:- \" + s.isUgly(6)); // true\\n\\t\\tSystem.out.println(\"\\\\nAns:- \" + s.isUgly(1)); // true\\n\\t\\tSystem.out.println(\"\\\\nAns:- \" + s.isUgly(900)); // true\\n\\n\\t}\\n}\\n\\nclass Solution {\\n\\tpublic boolean isUgly(int n) {\\n\\t\\tSystem.out.println(\"\\\\nn: \" + n);\\n\\n\\t\\t// if -ve or zero\\n\\t\\t// for -ve no. also loop can handle\\n\\t\\t// but added here to same time ... y need to run loop for no reason\\n\\t\\tif (n <= 0)\\n\\t\\t\\treturn false;\\n\\n\\t\\t// // special case ... but loop will handle automatically\\n\\t\\t// if (n == 1)\\n\\t\\t// return true;\\n\\n\\t\\twhile (n != 1) { // n>1\\n\\t\\t\\tif (n % 2 == 0)\\n\\t\\t\\t\\tn /= 2;\\n\\t\\t\\telse if (n % 3 == 0)\\n\\t\\t\\t\\tn /= 3;\\n\\t\\t\\telse if (n % 5 == 0)\\n\\t\\t\\t\\tn /= 5;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tSystem.out.println(n);\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n}\\n\\n```\n```java\\nclass Solution {\\n\\tpublic boolean isUgly(int n) {\\n\\t\\tif (n <= 0)\\n\\t\\t\\treturn false;\\n\\n\\t\\twhile (n % 5 == 0)\\n\\t\\t\\tn /= 5;\\n\\t\\twhile (n % 3 == 0)\\n\\t\\t\\tn /= 3;\\n\\t\\twhile (n % 2 == 0)\\n\\t\\t\\tn /= 2;\\n\\n\\t\\treturn n == 1;\\n\\t}\\n}\\n```\n```java\\nclass Solution {\\n\\tpublic boolean isUgly(int n) {\\n\\n\\t\\tif (n <= 0)\\n\\t\\t\\treturn false;\\n\\n\\t\\twhile (true) {\\n\\t\\t\\tif (n % 2 == 0)\\n\\t\\t\\t\\tn /= 2;\\n\\t\\t\\telse if (n % 3 == 0)\\n\\t\\t\\t\\tn /= 3;\\n\\t\\t\\telse if (n % 5 == 0)\\n\\t\\t\\t\\tn /= 5;\\n\\t\\t\\telse\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\treturn n == 1;\\n\\t}\\n}\\n```\n```java\\n// using \"factors list\"\\n// .... futuristic \\n// ... if more number get added/want to add\\n\\nclass Solution {\\n\\tpublic boolean isUgly(int n) {\\n\\t\\t// A non-positive integer cannot be ugly\\n\\t\\tif (n <= 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// Factorize by dividing with permitted factors\\n\\t\\tfor (int factor : new int[] { 2, 3, 5 }) {\\n\\t\\t\\tn = keepDividingWhenDivisible(n, factor);\\n\\t\\t}\\n\\n\\t\\t// Check if the integer is reduced to 1 or not.\\n\\t\\treturn n == 1;\\n\\t}\\n\\n\\t// Keep dividing dividend by divisor when division is possible.\\n\\tprivate int keepDividingWhenDivisible(int dividend, int divisor) {\\n\\t\\twhile (dividend % divisor == 0) {\\n\\t\\t\\tdividend /= divisor;\\n\\t\\t}\\n\\t\\treturn dividend;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039271,
                "title": "ugly-number-beautiful-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n<=0) return false;\\n        if(check(n)==0) return false;\\n        else return true;\\n    }\\n    int check(int n){\\n        if(n==1) return 1;\\n        if(n%2==0) return check(n/2);\\n        if(n%3==0) return check(n/3);\\n        if(n%5==0) return check(n/5);\\n        else return 0;\\n    }\\n};\\n```\\n# Upvote if this hepled!\\n![upvote.jpeg](https://assets.leetcode.com/users/images/bf653ea3-2197-4e5f-ab87-d476c6033241_1673508828.0963988.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n<=0) return false;\\n        if(check(n)==0) return false;\\n        else return true;\\n    }\\n    int check(int n){\\n        if(n==1) return 1;\\n        if(n%2==0) return check(n/2);\\n        if(n%3==0) return check(n/3);\\n        if(n%5==0) return check(n/5);\\n        else return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830300,
                "title": "easy-and-simple-solution-easy-to-understand",
                "content": "```class Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n ==  0)\\n        {\\n            return false;\\n        }\\n        while (n > 0)\\n        {\\n            if( n == 1)\\n            {\\n                return true;\\n            }\\n            else if( n % 2 == 0)\\n            {\\n                n = n/2;\\n            }\\n            else if( n % 3 == 0)\\n            {\\n                n = n / 3;\\n            }\\n            else if(n % 5 == 0)\\n            {\\n                n = n / 5;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n             \\n            return true;    \\n        }\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n ==  0)\\n        {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2829439,
                "title": "java-iterative-solution-recursive-solution-clean-code",
                "content": "# Iterative Solution\\n```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n<=0){\\n            return false;\\n        }\\n        while(n>0 && n%5==0){\\n            n=n/5;\\n        }\\n        while(n>0 && n%3==0){\\n            n=n/3;\\n        }\\n        while(n>0 && n%2==0){\\n            n=n/2;\\n        }\\n        return n==1;\\n    }\\n}\\n```\\n\\n# Recursive Solution\\n```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n==0) return false;\\n        if(n==1) return true;\\n        if(n%2==0) return isUgly(n/2);\\n        if(n%3==0) return isUgly(n/3);\\n        if(n%5==0) return isUgly(n/5);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n<=0){\\n            return false;\\n        }\\n        while(n>0 && n%5==0){\\n            n=n/5;\\n        }\\n        while(n>0 && n%3==0){\\n            n=n/3;\\n        }\\n        while(n>0 && n%2==0){\\n            n=n/2;\\n        }\\n        return n==1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n==0) return false;\\n        if(n==1) return true;\\n        if(n%2==0) return isUgly(n/2);\\n        if(n%3==0) return isUgly(n/3);\\n        if(n%5==0) return isUgly(n/5);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828663,
                "title": "python-easy-96-74-faster-o-log-n-solution",
                "content": "```\\nfrom math import sqrt\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n<=0:\\n            return False\\n        while n%2==0 or n%3==0 or n%5==0:\\n            if n%2==0:\\n                n//=2\\n            elif n%3==0:\\n                n//=3\\n            elif n%5==0:\\n                n//=5\\n        if n==1:\\n            return True\\n        return False\\n```\\n\\n**Upvote if you like the solution or ask if there is any query**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nfrom math import sqrt\\nclass Solution:\\n    def isUgly(self, n: int) -> bool:\\n        if n<=0:\\n            return False\\n        while n%2==0 or n%3==0 or n%5==0:\\n            if n%2==0:\\n                n//=2\\n            elif n%3==0:\\n                n//=3\\n            elif n%5==0:\\n                n//=5\\n        if n==1:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827956,
                "title": "by-c-only-if-else-conditions",
                "content": "class Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n==1)\\n            return true;\\n        else if(n<=0)\\n            return false;\\n        if(n%2==0) return isUgly(n/2);\\n        if(n%3==0) return isUgly(n/3);\\n        if(n%5==0) return isUgly(n/5);\\n            return false;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n==1)\\n            return true;\\n        else if(n<=0)\\n            return false;\\n        if(n%2==0) return isUgly(n/2);\\n        if(n%3==0) return isUgly(n/3);\\n        if(n%5==0) return isUgly(n/5);\\n            return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2827595,
                "title": "very-easy-solution",
                "content": "class Solution {\\npublic:\\n    bool isUgly(int n) {\\n        \\n        if(n == 0)\\n        {\\n            return false;\\n        }\\n        while (n > 0)\\n        {\\n            if( n == 1)\\n            {\\n                return true;\\n            }\\n            else if( n % 2 == 0)\\n            {\\n                n = n/2;\\n            }\\n            else if( n % 3 == 0)\\n            {\\n                n = n / 3;\\n            }\\n            else if(n % 5 == 0)\\n            {\\n                n = n / 5;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n               \\n        }\\n       return false;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isUgly(int n) {\\n        \\n        if(n == 0)\\n        {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2827574,
                "title": "easy-and-beginner-friendly-solution-in-c",
                "content": "\\n\\n# Complexity\\n- Time complexity: \\n $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n $$O(1)$$\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        \\n        while(n>1){\\n            if(n%2 == 0)\\n                n = n/2;\\n            else if(n%3 == 0)\\n                n = n/3;\\n            else if(n%5 == 0)\\n                n = n/5;\\n            \\n            else\\n                break;\\n        }\\n\\n        if(n == 1)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        \\n        while(n>1){\\n            if(n%2 == 0)\\n                n = n/2;\\n            else if(n%3 == 0)\\n                n = n/3;\\n            else if(n%5 == 0)\\n                n = n/5;\\n            \\n            else\\n                break;\\n        }\\n\\n        if(n == 1)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827431,
                "title": "easy-c-solution-must-check",
                "content": "\\n\\n**Solution:**\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        while(n>1)\\n        {\\n            if(n%2==0)\\n            {\\n                n=n/2;\\n            }\\n            else if(n%3==0)\\n            {\\n                n=n/3;\\n            }\\n            else if(n%5==0)\\n            {\\n                n=n/5;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return n==1;\\n    }\\n};\\n```\\n\\n---\\n\\n\\n**Analysis:**\\n- Time complexity: ```O(n)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n----\\n- Space complexity:```O(1)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n-----\\n\\nIf this solution help you, then please ```UPVOTE```.\\n**Till then keep learning, Keep Growing!!!**\\n\\n\\n\\n\\n---\\n\\n\\n**Thank You !!!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        while(n>1)\\n        {\\n            if(n%2==0)\\n            {\\n                n=n/2;\\n            }\\n            else if(n%3==0)\\n            {\\n                n=n/3;\\n            }\\n            else if(n%5==0)\\n            {\\n                n=n/5;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return n==1;\\n    }\\n};\\n```\n```O(n)```\n```O(1)```\n```UPVOTE```",
                "codeTag": "Java"
            },
            {
                "id": 2827428,
                "title": "factorization-based-solution-c-single-pass-tc-o-1-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEvery ugly number can be expressed in the form of 2, 3 and 5 in varying powers. Hence, if a number can be expressed using only by 2, 3 and 5, we can call it an ugly number.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, we check if a given number is divisible by 2 and then continue dividing it by 2 till its no longer divisible by it. Then, we repeat the process for 3 and 5.\\n\\nLastly, if we are left with 1, then the given number is an ugly number.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**NOTE:** Time complexity would be constant as the greatest possible input that can be given is 2^31-1 and this number will iterate only the first loop and that too just 31 times.\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(!n) return false;\\n        \\n        while(!(n%2))\\n            n/=2;\\n\\n        while(!(n%3))\\n            n/=3;\\n\\n        while(!(n%5))\\n            n/=5;\\n        \\n        if(n==1) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(!n) return false;\\n        \\n        while(!(n%2))\\n            n/=2;\\n\\n        while(!(n%3))\\n            n/=3;\\n\\n        while(!(n%5))\\n            n/=5;\\n        \\n        if(n==1) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827264,
                "title": "easy-c-recursive-solution",
                "content": "![image](https://assets.leetcode.com/users/images/674d90df-e172-4b6f-b9df-870cedd7666b_1668775102.469841.png)\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/674d90df-e172-4b6f-b9df-870cedd7666b_1668775102.469841.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2827257,
                "title": "easy-and-understandable-c-code-basic-mathematics",
                "content": "**Approach**\\nwe need to find the number is ugly or not.\\nCase 1 :- If the number(n) is not divisible by any number(2, 3 and 5) then it will definitely not a ugly number.\\nCase 2 :- If the number(n) is divisible by any number (2, 3, and 5) but it will also divisible by any other number then it will also not a ugly number.\\nCase 3 :- If number(n) is divisible by (2, 3, and 5) and it it will become n==1, then it will be a ugly number.\\n\\n**C++ Code is given below**\\n**If you find it is helpful for you give a upvote please..!!**\\nbool isUgly(int n) {\\n        \\n        if(n <= 0) return false;\\n        while(n > 1) {\\n            if(n % 2 == 0)      n = n / 2;\\n            else if(n % 3 == 0) n = n / 3;\\n            else if(n % 5 == 0) n = n / 5;\\n            else    break;\\n        }\\n        return (n == 1);\\n    }",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "**Approach**\\nwe need to find the number is ugly or not.\\nCase 1 :- If the number(n) is not divisible by any number(2, 3 and 5) then it will definitely not a ugly number.\\nCase 2 :- If the number(n) is divisible by any number (2, 3, and 5) but it will also divisible by any other number then it will also not a ugly number.\\nCase 3 :- If number(n) is divisible by (2, 3, and 5) and it it will become n==1, then it will be a ugly number.\\n\\n**C++ Code is given below**\\n**If you find it is helpful for you give a upvote please..!!**\\nbool isUgly(int n) {\\n        \\n        if(n <= 0) return false;\\n        while(n > 1) {\\n            if(n % 2 == 0)      n = n / 2;\\n            else if(n % 3 == 0) n = n / 3;\\n            else if(n % 5 == 0) n = n / 5;\\n            else    break;\\n        }\\n        return (n == 1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2827117,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isUgly(int n) {\\n\\t\\t\\tif(n==0){return false;}\\n\\t\\t\\twhile(n%2==0){\\n\\t\\t\\t\\tn/=2;\\n\\t\\t\\t}\\n\\t\\t\\twhile(n%3==0){\\n\\t\\t\\t\\tn/=3;\\n\\t\\t\\t}\\n\\t\\t\\twhile(n%5==0){\\n\\t\\t\\t\\tn/=5;\\n\\t\\t\\t}\\n\\t\\t\\treturn n==1;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isUgly(int n) {\\n\\t\\t\\tif(n==0){return false;}",
                "codeTag": "Java"
            },
            {
                "id": 2827073,
                "title": "java-100-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDivide number to [2,3,5] until reach the end\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\n    public boolean isUgly(int num) {\\n        if(num == 0) return false;\\n\\n        \\n        while(num%2 ==0){\\n            num /= 2;\\n        }\\n        while(num%3 ==0){\\n            num /= 3;\\n        }\\n        while(num%5 ==0){\\n            num /= 5;\\n        }\\n\\n        \\n\\n        return num == 1;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isUgly(int num) {\\n        if(num == 0) return false;\\n\\n        \\n        while(num%2 ==0){\\n            num /= 2;\\n        }\\n        while(num%3 ==0){\\n            num /= 3;\\n        }\\n        while(num%5 ==0){\\n            num /= 5;\\n        }\\n\\n        \\n\\n        return num == 1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827063,
                "title": "c-easy-brute-force-69-space-21-time",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n      if(n == 0) return false;\\n      while(n % 2 == 0) n /= 2;\\n      while(n % 3 == 0) n /= 3;\\n      while(n % 5 == 0) n /= 5;\\n      return n == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n      if(n == 0) return false;\\n      while(n % 2 == 0) n /= 2;\\n      while(n % 3 == 0) n /= 3;\\n      while(n % 5 == 0) n /= 5;\\n      return n == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826951,
                "title": "java-100-faster-solution-recursion",
                "content": "# Intuition\\n* Need to divide the number recusrsively by prime factors\\n\\n# Approach\\n* Check if the number becomes = 1, after recursively dividing the number by allowed prime factors (2, 3, 5).\\n* If the remainder number is 1, then return true else return false\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int number = 2;\\n    public boolean isUgly(int n) {\\n        if(n == 0){\\n            return false;\\n        }\\n\\n        if(n == 1){\\n            return true;\\n        }\\n        \\n        if(n % 2 == 0) return isUgly(n/2);\\n        if(n % 3 == 0) return isUgly(n/3);\\n        if(n % 5 == 0) return isUgly(n/5);\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int number = 2;\\n    public boolean isUgly(int n) {\\n        if(n == 0){\\n            return false;\\n        }\\n\\n        if(n == 1){\\n            return true;\\n        }\\n        \\n        if(n % 2 == 0) return isUgly(n/2);\\n        if(n % 3 == 0) return isUgly(n/3);\\n        if(n % 5 == 0) return isUgly(n/5);\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826949,
                "title": "java-prime-factors-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHere Break Condition is for if n == 1 return true\\nif(n%2 == 0) recursively call it ie isUgly(n/2)\\nif(n%3 == 0) recursively call it ie isUgly(n/3)\\nif(n%5 == 0) recursively call it ie isUgly(n/5)\\nif n is still greater than 1 return false or else just return true\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n == 0) {\\n            return false;\\n        }\\n        if(n==1){\\n            return true;\\n        }\\n\\n        if(n%2 == 0){\\n            return isUgly(n/2);\\n        }\\n\\n        else if(n%3 == 0){\\n           return isUgly(n/3);\\n        }\\n\\n        else if(n%5 == 0){\\n            return isUgly(n/5);\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n == 0) {\\n            return false;\\n        }\\n        if(n==1){\\n            return true;\\n        }\\n\\n        if(n%2 == 0){\\n            return isUgly(n/2);\\n        }\\n\\n        else if(n%3 == 0){\\n           return isUgly(n/3);\\n        }\\n\\n        else if(n%5 == 0){\\n            return isUgly(n/5);\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826839,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if (n < 1) return false;\\n\\n        while (n % 2 == 0) n /= 2;\\n        while (n % 3 == 0) n /= 3;\\n        while (n % 5 == 0) n /= 5;\\n\\n        return n == 1;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if (n < 1) return false;\\n\\n        while (n % 2 == 0) n /= 2;\\n        while (n % 3 == 0) n /= 3;\\n        while (n % 5 == 0) n /= 5;\\n\\n        return n == 1;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826823,
                "title": "simple-java-iterative-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA prime factor is a natural number, other than 1, whose only factors are 1 and itself. The first few prime numbers are actually 2, 3, 5, 7, 11, and so on Prime factorization is a process of writing all numbers as a product of primes. So, for example, say if we have something like the number 20. We can break that down into two factors. You could break 20 down into 2 times 10. Whichever way you\\u2019d like is fine. So, notice 2 times 10, that 2 is prime, whereas the 10 is composite. So we can break that down into 2 times 5. So we\\u2019re circling all the prime numbers that we see. And, again, we\\u2019ve got 2 times 2 times 5 equaling 20. So that\\u2019s prime factorization.\\n\\n**If prime factorization of n has number other than 2,3 and 5 then return false else return true.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start Dividing the n with 2 until it is divisible by 2 and then we divide n with 3 until n is divisible by 3 and then we divide n with 5 until is divisible by 5. If the result n after these operations comes to be 1 then it returns true else return false.\\n\\n**For example** : 14 has prime factors of 2 and 7 so the answer to this number would be false according to our approach. \\nAccording to the algo:\\nSince 14%2 == 0 then 14/2 = 7, now n becomes 7.\\nNow 7%2!=0 and 7%3!=0 and 7%5!=0, then n remains 7 not 1 so we return false. \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    $$O(log n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n <= 0){\\n            return false;\\n        }\\n        while((n & 1) != 1){\\n            n = n/2;\\n        }\\n        while(n%3 == 0){\\n            n = n/3;\\n        }\\n        while(n%5 == 0){\\n            n = n/5;\\n        }\\n        if(n == 1){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n <= 0){\\n            return false;\\n        }\\n        while((n & 1) != 1){\\n            n = n/2;\\n        }\\n        while(n%3 == 0){\\n            n = n/3;\\n        }\\n        while(n%5 == 0){\\n            n = n/5;\\n        }\\n        if(n == 1){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826762,
                "title": "simple-easy-100timecomplexity-95spacecomplexity",
                "content": "```\\nclass Solution {\\n    public boolean isUgly(int n) \\n    {\\n        if(n==0)return false;\\n\\n        while(n%5==0)\\n        {\\n            n=n/5;\\n        }\\n\\n        while(n%3==0)\\n        {\\n            n=n/3;\\n        }\\n\\n        while(n%2==0)\\n        {\\n            n=n/2;\\n        }\\n\\n        if(n==1)return true;\\n        else return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isUgly(int n) \\n    {\\n        if(n==0)return false;\\n\\n        while(n%5==0)\\n        {\\n            n=n/5;\\n        }\\n\\n        while(n%3==0)\\n        {\\n            n=n/3;\\n        }\\n\\n        while(n%2==0)\\n        {\\n            n=n/2;\\n        }\\n\\n        if(n==1)return true;\\n        else return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826558,
                "title": "easy-and-explainable",
                "content": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        int tc=0;\\n        int thc=0;\\n        int fc=0;\\n        \\n        if(n==0) return false;\\n        \\n        int tmp=n;\\n        \\n        //calculting 2 multiplicity\\n        while(tmp%2==0){\\n            tmp/=2;\\n            tc++;\\n        }\\n        \\n       \\n        \\n        //calculating 3 multiplicity\\n        while(tmp%3==0){\\n            tmp/=3;\\n            thc++;\\n        }\\n        \\n       \\n        //calculating 5 multiplicity\\n        while(tmp%5==0){\\n            tmp/=5;\\n            fc++;\\n        }\\n        \\n        \\n       // System.out.println((tc>0 ? (int)Math.pow(2,tc):1)*(thc>0 ? Math.pow(3,thc):1)*(fc>0 ? Math.pow(5,fc):1));\\n        \\n        return (tc>0 ? (int)Math.pow(2,tc):1)*(thc>0 ? (int)Math.pow(3,thc):1)*(fc>0 ? (int)Math.pow(5,fc):1)==n;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        int tc=0;\\n        int thc=0;\\n        int fc=0;\\n        \\n        if(n==0) return false;\\n        \\n        int tmp=n;\\n        \\n        //calculting 2 multiplicity\\n        while(tmp%2==0){\\n            tmp/=2;\\n            tc++;\\n        }\\n        \\n       \\n        \\n        //calculating 3 multiplicity\\n        while(tmp%3==0){\\n            tmp/=3;\\n            thc++;\\n        }\\n        \\n       \\n        //calculating 5 multiplicity\\n        while(tmp%5==0){\\n            tmp/=5;\\n            fc++;\\n        }\\n        \\n        \\n       // System.out.println((tc>0 ? (int)Math.pow(2,tc):1)*(thc>0 ? Math.pow(3,thc):1)*(fc>0 ? Math.pow(5,fc):1));\\n        \\n        return (tc>0 ? (int)Math.pow(2,tc):1)*(thc>0 ? (int)Math.pow(3,thc):1)*(fc>0 ? (int)Math.pow(5,fc):1)==n;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826548,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        \\n        if(n == 0 || n<0)\\n            return false;\\n        \\n        while(n%2 == 0)\\n        {\\n            n = n/2;\\n        }\\n        while(n%3 == 0)\\n        {\\n            n = n/3;\\n        }\\n        while(n%5 == 0)\\n        {\\n            n = n/5;\\n        }\\n        if(n==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        \\n        if(n == 0 || n<0)\\n            return false;\\n        \\n        while(n%2 == 0)\\n        {\\n            n = n/2;\\n        }\\n        while(n%3 == 0)\\n        {\\n            n = n/3;\\n        }\\n        while(n%5 == 0)\\n        {\\n            n = n/5;\\n        }\\n        if(n==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826410,
                "title": "easy-solution-using-arraylist",
                "content": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n<=0){\\n            return false;\\n        }\\n        ArrayList<Integer> list =new ArrayList<>();\\n        list.add(2);\\n        list.add(3);\\n        list.add(5);\\n        \\n        for(int i=0;i<list.size();i++){\\n          while(n % list.get(i)==0){\\n              n = n/list.get(i);\\n          }   \\n        }\\n        return n==1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n<=0){\\n            return false;\\n        }\\n        ArrayList<Integer> list =new ArrayList<>();\\n        list.add(2);\\n        list.add(3);\\n        list.add(5);\\n        \\n        for(int i=0;i<list.size();i++){\\n          while(n % list.get(i)==0){\\n              n = n/list.get(i);\\n          }   \\n        }\\n        return n==1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826319,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n < 1) return false;\\n        while(n % 2 == 0) n /= 2;\\n        while(n % 3 == 0) n /= 3;\\n        while(n % 5 == 0) n /= 5;\\n        if(n == 1) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n < 1) return false;\\n        while(n % 2 == 0) n /= 2;\\n        while(n % 3 == 0) n /= 3;\\n        while(n % 5 == 0) n /= 5;\\n        if(n == 1) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826280,
                "title": "c-short-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n<1)\\n            return false;\\n\\n        int pn = n;\\n        \\n        while(n!=1){\\n            if(n%2==0)\\n                n /= 2;\\n            else if(n%3==0)\\n                n /= 3;\\n            else if(n%5==0)\\n                n /= 5;\\n            if(pn==n)\\n                return false; \\n            pn = n;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n) {\\n        if(n<1)\\n            return false;\\n\\n        int pn = n;\\n        \\n        while(n!=1){\\n            if(n%2==0)\\n                n /= 2;\\n            else if(n%3==0)\\n                n /= 3;\\n            else if(n%5==0)\\n                n /= 5;\\n            if(pn==n)\\n                return false; \\n            pn = n;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1805367,
                "content": [
                    {
                        "username": "ItzAryanTiwari",
                        "content": "Guys plz Improve the Description of the problem.\\nIf Agreed upvote."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Another rephrase of the definition if this sounds clearer:\n\nAn ugly number is a positive integer which does **not** have a prime factor **other than** 2, 3, and 5."
                    },
                    {
                        "username": "piyu5hkumar",
                        "content": "1 has neither 2 or 3 or 5  or their combination as factor, still its ugly, why so?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "not prime"
                    },
                    {
                        "username": "dyzo",
                        "content": "[@Sakshamji](/Sakshamji) You are right!"
                    },
                    {
                        "username": "Sakshamji",
                        "content": "We can interpret as it ugly number can be written as (2^a)*(3^b)*(5^c)\\nand since 1 = (2^0)*(3^0)*(5^0) thus 1 is ugly number ."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Bhushan_Waingankar",
                        "content": "Make sure to add these as your edge cases\\nif(n <= 0) return false;\\nif(n == 1) return true;"
                    },
                    {
                        "username": "orthogonal1",
                        "content": "n==1 is not necessarily an edge case."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "problem description phrasing could be better"
                    },
                    {
                        "username": "eduard92",
                        "content": "You sound like a canadian..."
                    },
                    {
                        "username": "mpack",
                        "content": "When num is 1, I was thinking it should be false... Can anybody explain this test case for me? Thanks in advance."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Sakshamji",
                        "content": "Every number N can be written as product of prime numbers as\n N = (A^a)(B^b)(C^c)....\nwhere A,B,C.. represent prime numers\ne.g 135 = (3^3)*(5^1) where 3 and 5 are prime numbers\n\nNow in this question they have asked for numbers that have 2,3,5 as A,B,C or prime numbers,\nthat means those numbers that can be represented as -\nUgly number (U) = (2^a)(3^b)(5^c)\nwhere a,b,c are positive numbers\nAs you can see 1 also satisfy above equation as\n1 = (2^0)(3^0)(5^0)\nthus it is also a ugly number\nI hope this insight will help you in solving this question."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Nice Tip, but following statement is incorrect.\\n> where a,b,c are positive numbers\\n\\nThey are whole numbers (or non-negative integers) to be precise."
                    },
                    {
                        "username": "quantupus",
                        "content": "code was going great until I realized negative numbers were a thing lol"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Someone else in the comments pointed out that an ugly number must be a POSITIVE integer. You can easily put a condition to return false if n<0."
                    },
                    {
                        "username": "vinayaktalukder17",
                        "content": "Same here. Just 500 test cases passed out of a 1013 test cases"
                    },
                    {
                        "username": "frankfaustino",
                        "content": "I\\'ve gotten into the habit of reading the constraints because I hate when this happens \\uD83D\\uDE00"
                    },
                    {
                        "username": "helenfanzhang",
                        "content": "I think this problem is seriously flawed as I see the expected cases for the following:\\n0: false\\n1: true\\n2: true\\n3: true\\n5: true\\n7: false"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@Kedarterkhedkar](/Kedarterkhedkar). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@Kedarterkhedkar](/Kedarterkhedkar)  The prime factors of 8 is 2x2x2x2\\nNow look for the definition of ugly numbers\\n"
                    },
                    {
                        "username": "Kedarterkhedkar",
                        "content": "[@RohitSgh](/RohitSgh) Can you explain why 8 is ugly number ?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $0$ simply does not satisfy the first condition. Hence, `False` for $0$ is justified.\\n\\nAll other integers satisfy the first condition. For second condition, let\\'s list down their set of prime factors.\\n- For $1$, the set of prime factors is $\\\\{\\\\}$. And empty set is subset of every set. Thus `True` for $1$ is justified.\\n- For $2$, the set of prime factors is $\\\\{2\\\\}$. And $\\\\{2\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $2$ is justified.\\n- For $3$, the set of prime factors is $\\\\{3\\\\}$. And $\\\\{3\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $3$ is justified.\\n- For $5$, the set of prime factors is $\\\\{5\\\\}$. And $\\\\{5\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $5$ is justified.\\n- For $7$, the set of prime factors is $\\\\{7\\\\}$. And $\\\\{7\\\\}$ is not subset of $\\\\{2, 3, 5\\\\}$. Thus `False` for $7$ is justified."
                    },
                    {
                        "username": "d1mnewz",
                        "content": "Can somebody explain why in this case 1 is treated as ugly number? \\nBy definition\\n> Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.\\n\\nSo I can\\'t understand why 1 is an ugly number because it doesn\\'t have any of those prime factors."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nIn other words, without using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    }
                ]
            },
            {
                "id": 1687894,
                "content": [
                    {
                        "username": "ItzAryanTiwari",
                        "content": "Guys plz Improve the Description of the problem.\\nIf Agreed upvote."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Another rephrase of the definition if this sounds clearer:\n\nAn ugly number is a positive integer which does **not** have a prime factor **other than** 2, 3, and 5."
                    },
                    {
                        "username": "piyu5hkumar",
                        "content": "1 has neither 2 or 3 or 5  or their combination as factor, still its ugly, why so?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "not prime"
                    },
                    {
                        "username": "dyzo",
                        "content": "[@Sakshamji](/Sakshamji) You are right!"
                    },
                    {
                        "username": "Sakshamji",
                        "content": "We can interpret as it ugly number can be written as (2^a)*(3^b)*(5^c)\\nand since 1 = (2^0)*(3^0)*(5^0) thus 1 is ugly number ."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Bhushan_Waingankar",
                        "content": "Make sure to add these as your edge cases\\nif(n <= 0) return false;\\nif(n == 1) return true;"
                    },
                    {
                        "username": "orthogonal1",
                        "content": "n==1 is not necessarily an edge case."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "problem description phrasing could be better"
                    },
                    {
                        "username": "eduard92",
                        "content": "You sound like a canadian..."
                    },
                    {
                        "username": "mpack",
                        "content": "When num is 1, I was thinking it should be false... Can anybody explain this test case for me? Thanks in advance."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Sakshamji",
                        "content": "Every number N can be written as product of prime numbers as\n N = (A^a)(B^b)(C^c)....\nwhere A,B,C.. represent prime numers\ne.g 135 = (3^3)*(5^1) where 3 and 5 are prime numbers\n\nNow in this question they have asked for numbers that have 2,3,5 as A,B,C or prime numbers,\nthat means those numbers that can be represented as -\nUgly number (U) = (2^a)(3^b)(5^c)\nwhere a,b,c are positive numbers\nAs you can see 1 also satisfy above equation as\n1 = (2^0)(3^0)(5^0)\nthus it is also a ugly number\nI hope this insight will help you in solving this question."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Nice Tip, but following statement is incorrect.\\n> where a,b,c are positive numbers\\n\\nThey are whole numbers (or non-negative integers) to be precise."
                    },
                    {
                        "username": "quantupus",
                        "content": "code was going great until I realized negative numbers were a thing lol"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Someone else in the comments pointed out that an ugly number must be a POSITIVE integer. You can easily put a condition to return false if n<0."
                    },
                    {
                        "username": "vinayaktalukder17",
                        "content": "Same here. Just 500 test cases passed out of a 1013 test cases"
                    },
                    {
                        "username": "frankfaustino",
                        "content": "I\\'ve gotten into the habit of reading the constraints because I hate when this happens \\uD83D\\uDE00"
                    },
                    {
                        "username": "helenfanzhang",
                        "content": "I think this problem is seriously flawed as I see the expected cases for the following:\\n0: false\\n1: true\\n2: true\\n3: true\\n5: true\\n7: false"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@Kedarterkhedkar](/Kedarterkhedkar). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@Kedarterkhedkar](/Kedarterkhedkar)  The prime factors of 8 is 2x2x2x2\\nNow look for the definition of ugly numbers\\n"
                    },
                    {
                        "username": "Kedarterkhedkar",
                        "content": "[@RohitSgh](/RohitSgh) Can you explain why 8 is ugly number ?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $0$ simply does not satisfy the first condition. Hence, `False` for $0$ is justified.\\n\\nAll other integers satisfy the first condition. For second condition, let\\'s list down their set of prime factors.\\n- For $1$, the set of prime factors is $\\\\{\\\\}$. And empty set is subset of every set. Thus `True` for $1$ is justified.\\n- For $2$, the set of prime factors is $\\\\{2\\\\}$. And $\\\\{2\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $2$ is justified.\\n- For $3$, the set of prime factors is $\\\\{3\\\\}$. And $\\\\{3\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $3$ is justified.\\n- For $5$, the set of prime factors is $\\\\{5\\\\}$. And $\\\\{5\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $5$ is justified.\\n- For $7$, the set of prime factors is $\\\\{7\\\\}$. And $\\\\{7\\\\}$ is not subset of $\\\\{2, 3, 5\\\\}$. Thus `False` for $7$ is justified."
                    },
                    {
                        "username": "d1mnewz",
                        "content": "Can somebody explain why in this case 1 is treated as ugly number? \\nBy definition\\n> Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.\\n\\nSo I can\\'t understand why 1 is an ugly number because it doesn\\'t have any of those prime factors."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nIn other words, without using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    }
                ]
            },
            {
                "id": 1570058,
                "content": [
                    {
                        "username": "ItzAryanTiwari",
                        "content": "Guys plz Improve the Description of the problem.\\nIf Agreed upvote."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Another rephrase of the definition if this sounds clearer:\n\nAn ugly number is a positive integer which does **not** have a prime factor **other than** 2, 3, and 5."
                    },
                    {
                        "username": "piyu5hkumar",
                        "content": "1 has neither 2 or 3 or 5  or their combination as factor, still its ugly, why so?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "not prime"
                    },
                    {
                        "username": "dyzo",
                        "content": "[@Sakshamji](/Sakshamji) You are right!"
                    },
                    {
                        "username": "Sakshamji",
                        "content": "We can interpret as it ugly number can be written as (2^a)*(3^b)*(5^c)\\nand since 1 = (2^0)*(3^0)*(5^0) thus 1 is ugly number ."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Bhushan_Waingankar",
                        "content": "Make sure to add these as your edge cases\\nif(n <= 0) return false;\\nif(n == 1) return true;"
                    },
                    {
                        "username": "orthogonal1",
                        "content": "n==1 is not necessarily an edge case."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "problem description phrasing could be better"
                    },
                    {
                        "username": "eduard92",
                        "content": "You sound like a canadian..."
                    },
                    {
                        "username": "mpack",
                        "content": "When num is 1, I was thinking it should be false... Can anybody explain this test case for me? Thanks in advance."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Sakshamji",
                        "content": "Every number N can be written as product of prime numbers as\n N = (A^a)(B^b)(C^c)....\nwhere A,B,C.. represent prime numers\ne.g 135 = (3^3)*(5^1) where 3 and 5 are prime numbers\n\nNow in this question they have asked for numbers that have 2,3,5 as A,B,C or prime numbers,\nthat means those numbers that can be represented as -\nUgly number (U) = (2^a)(3^b)(5^c)\nwhere a,b,c are positive numbers\nAs you can see 1 also satisfy above equation as\n1 = (2^0)(3^0)(5^0)\nthus it is also a ugly number\nI hope this insight will help you in solving this question."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Nice Tip, but following statement is incorrect.\\n> where a,b,c are positive numbers\\n\\nThey are whole numbers (or non-negative integers) to be precise."
                    },
                    {
                        "username": "quantupus",
                        "content": "code was going great until I realized negative numbers were a thing lol"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Someone else in the comments pointed out that an ugly number must be a POSITIVE integer. You can easily put a condition to return false if n<0."
                    },
                    {
                        "username": "vinayaktalukder17",
                        "content": "Same here. Just 500 test cases passed out of a 1013 test cases"
                    },
                    {
                        "username": "frankfaustino",
                        "content": "I\\'ve gotten into the habit of reading the constraints because I hate when this happens \\uD83D\\uDE00"
                    },
                    {
                        "username": "helenfanzhang",
                        "content": "I think this problem is seriously flawed as I see the expected cases for the following:\\n0: false\\n1: true\\n2: true\\n3: true\\n5: true\\n7: false"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@Kedarterkhedkar](/Kedarterkhedkar). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@Kedarterkhedkar](/Kedarterkhedkar)  The prime factors of 8 is 2x2x2x2\\nNow look for the definition of ugly numbers\\n"
                    },
                    {
                        "username": "Kedarterkhedkar",
                        "content": "[@RohitSgh](/RohitSgh) Can you explain why 8 is ugly number ?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $0$ simply does not satisfy the first condition. Hence, `False` for $0$ is justified.\\n\\nAll other integers satisfy the first condition. For second condition, let\\'s list down their set of prime factors.\\n- For $1$, the set of prime factors is $\\\\{\\\\}$. And empty set is subset of every set. Thus `True` for $1$ is justified.\\n- For $2$, the set of prime factors is $\\\\{2\\\\}$. And $\\\\{2\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $2$ is justified.\\n- For $3$, the set of prime factors is $\\\\{3\\\\}$. And $\\\\{3\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $3$ is justified.\\n- For $5$, the set of prime factors is $\\\\{5\\\\}$. And $\\\\{5\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $5$ is justified.\\n- For $7$, the set of prime factors is $\\\\{7\\\\}$. And $\\\\{7\\\\}$ is not subset of $\\\\{2, 3, 5\\\\}$. Thus `False` for $7$ is justified."
                    },
                    {
                        "username": "d1mnewz",
                        "content": "Can somebody explain why in this case 1 is treated as ugly number? \\nBy definition\\n> Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.\\n\\nSo I can\\'t understand why 1 is an ugly number because it doesn\\'t have any of those prime factors."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nIn other words, without using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    }
                ]
            },
            {
                "id": 1688131,
                "content": [
                    {
                        "username": "ItzAryanTiwari",
                        "content": "Guys plz Improve the Description of the problem.\\nIf Agreed upvote."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Another rephrase of the definition if this sounds clearer:\n\nAn ugly number is a positive integer which does **not** have a prime factor **other than** 2, 3, and 5."
                    },
                    {
                        "username": "piyu5hkumar",
                        "content": "1 has neither 2 or 3 or 5  or their combination as factor, still its ugly, why so?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "not prime"
                    },
                    {
                        "username": "dyzo",
                        "content": "[@Sakshamji](/Sakshamji) You are right!"
                    },
                    {
                        "username": "Sakshamji",
                        "content": "We can interpret as it ugly number can be written as (2^a)*(3^b)*(5^c)\\nand since 1 = (2^0)*(3^0)*(5^0) thus 1 is ugly number ."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Bhushan_Waingankar",
                        "content": "Make sure to add these as your edge cases\\nif(n <= 0) return false;\\nif(n == 1) return true;"
                    },
                    {
                        "username": "orthogonal1",
                        "content": "n==1 is not necessarily an edge case."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "problem description phrasing could be better"
                    },
                    {
                        "username": "eduard92",
                        "content": "You sound like a canadian..."
                    },
                    {
                        "username": "mpack",
                        "content": "When num is 1, I was thinking it should be false... Can anybody explain this test case for me? Thanks in advance."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Sakshamji",
                        "content": "Every number N can be written as product of prime numbers as\n N = (A^a)(B^b)(C^c)....\nwhere A,B,C.. represent prime numers\ne.g 135 = (3^3)*(5^1) where 3 and 5 are prime numbers\n\nNow in this question they have asked for numbers that have 2,3,5 as A,B,C or prime numbers,\nthat means those numbers that can be represented as -\nUgly number (U) = (2^a)(3^b)(5^c)\nwhere a,b,c are positive numbers\nAs you can see 1 also satisfy above equation as\n1 = (2^0)(3^0)(5^0)\nthus it is also a ugly number\nI hope this insight will help you in solving this question."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Nice Tip, but following statement is incorrect.\\n> where a,b,c are positive numbers\\n\\nThey are whole numbers (or non-negative integers) to be precise."
                    },
                    {
                        "username": "quantupus",
                        "content": "code was going great until I realized negative numbers were a thing lol"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Someone else in the comments pointed out that an ugly number must be a POSITIVE integer. You can easily put a condition to return false if n<0."
                    },
                    {
                        "username": "vinayaktalukder17",
                        "content": "Same here. Just 500 test cases passed out of a 1013 test cases"
                    },
                    {
                        "username": "frankfaustino",
                        "content": "I\\'ve gotten into the habit of reading the constraints because I hate when this happens \\uD83D\\uDE00"
                    },
                    {
                        "username": "helenfanzhang",
                        "content": "I think this problem is seriously flawed as I see the expected cases for the following:\\n0: false\\n1: true\\n2: true\\n3: true\\n5: true\\n7: false"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@Kedarterkhedkar](/Kedarterkhedkar). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@Kedarterkhedkar](/Kedarterkhedkar)  The prime factors of 8 is 2x2x2x2\\nNow look for the definition of ugly numbers\\n"
                    },
                    {
                        "username": "Kedarterkhedkar",
                        "content": "[@RohitSgh](/RohitSgh) Can you explain why 8 is ugly number ?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $0$ simply does not satisfy the first condition. Hence, `False` for $0$ is justified.\\n\\nAll other integers satisfy the first condition. For second condition, let\\'s list down their set of prime factors.\\n- For $1$, the set of prime factors is $\\\\{\\\\}$. And empty set is subset of every set. Thus `True` for $1$ is justified.\\n- For $2$, the set of prime factors is $\\\\{2\\\\}$. And $\\\\{2\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $2$ is justified.\\n- For $3$, the set of prime factors is $\\\\{3\\\\}$. And $\\\\{3\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $3$ is justified.\\n- For $5$, the set of prime factors is $\\\\{5\\\\}$. And $\\\\{5\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $5$ is justified.\\n- For $7$, the set of prime factors is $\\\\{7\\\\}$. And $\\\\{7\\\\}$ is not subset of $\\\\{2, 3, 5\\\\}$. Thus `False` for $7$ is justified."
                    },
                    {
                        "username": "d1mnewz",
                        "content": "Can somebody explain why in this case 1 is treated as ugly number? \\nBy definition\\n> Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.\\n\\nSo I can\\'t understand why 1 is an ugly number because it doesn\\'t have any of those prime factors."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nIn other words, without using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    }
                ]
            },
            {
                "id": 1688165,
                "content": [
                    {
                        "username": "ItzAryanTiwari",
                        "content": "Guys plz Improve the Description of the problem.\\nIf Agreed upvote."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Another rephrase of the definition if this sounds clearer:\n\nAn ugly number is a positive integer which does **not** have a prime factor **other than** 2, 3, and 5."
                    },
                    {
                        "username": "piyu5hkumar",
                        "content": "1 has neither 2 or 3 or 5  or their combination as factor, still its ugly, why so?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "not prime"
                    },
                    {
                        "username": "dyzo",
                        "content": "[@Sakshamji](/Sakshamji) You are right!"
                    },
                    {
                        "username": "Sakshamji",
                        "content": "We can interpret as it ugly number can be written as (2^a)*(3^b)*(5^c)\\nand since 1 = (2^0)*(3^0)*(5^0) thus 1 is ugly number ."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Bhushan_Waingankar",
                        "content": "Make sure to add these as your edge cases\\nif(n <= 0) return false;\\nif(n == 1) return true;"
                    },
                    {
                        "username": "orthogonal1",
                        "content": "n==1 is not necessarily an edge case."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "problem description phrasing could be better"
                    },
                    {
                        "username": "eduard92",
                        "content": "You sound like a canadian..."
                    },
                    {
                        "username": "mpack",
                        "content": "When num is 1, I was thinking it should be false... Can anybody explain this test case for me? Thanks in advance."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Sakshamji",
                        "content": "Every number N can be written as product of prime numbers as\n N = (A^a)(B^b)(C^c)....\nwhere A,B,C.. represent prime numers\ne.g 135 = (3^3)*(5^1) where 3 and 5 are prime numbers\n\nNow in this question they have asked for numbers that have 2,3,5 as A,B,C or prime numbers,\nthat means those numbers that can be represented as -\nUgly number (U) = (2^a)(3^b)(5^c)\nwhere a,b,c are positive numbers\nAs you can see 1 also satisfy above equation as\n1 = (2^0)(3^0)(5^0)\nthus it is also a ugly number\nI hope this insight will help you in solving this question."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Nice Tip, but following statement is incorrect.\\n> where a,b,c are positive numbers\\n\\nThey are whole numbers (or non-negative integers) to be precise."
                    },
                    {
                        "username": "quantupus",
                        "content": "code was going great until I realized negative numbers were a thing lol"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Someone else in the comments pointed out that an ugly number must be a POSITIVE integer. You can easily put a condition to return false if n<0."
                    },
                    {
                        "username": "vinayaktalukder17",
                        "content": "Same here. Just 500 test cases passed out of a 1013 test cases"
                    },
                    {
                        "username": "frankfaustino",
                        "content": "I\\'ve gotten into the habit of reading the constraints because I hate when this happens \\uD83D\\uDE00"
                    },
                    {
                        "username": "helenfanzhang",
                        "content": "I think this problem is seriously flawed as I see the expected cases for the following:\\n0: false\\n1: true\\n2: true\\n3: true\\n5: true\\n7: false"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@Kedarterkhedkar](/Kedarterkhedkar). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@Kedarterkhedkar](/Kedarterkhedkar)  The prime factors of 8 is 2x2x2x2\\nNow look for the definition of ugly numbers\\n"
                    },
                    {
                        "username": "Kedarterkhedkar",
                        "content": "[@RohitSgh](/RohitSgh) Can you explain why 8 is ugly number ?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $0$ simply does not satisfy the first condition. Hence, `False` for $0$ is justified.\\n\\nAll other integers satisfy the first condition. For second condition, let\\'s list down their set of prime factors.\\n- For $1$, the set of prime factors is $\\\\{\\\\}$. And empty set is subset of every set. Thus `True` for $1$ is justified.\\n- For $2$, the set of prime factors is $\\\\{2\\\\}$. And $\\\\{2\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $2$ is justified.\\n- For $3$, the set of prime factors is $\\\\{3\\\\}$. And $\\\\{3\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $3$ is justified.\\n- For $5$, the set of prime factors is $\\\\{5\\\\}$. And $\\\\{5\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $5$ is justified.\\n- For $7$, the set of prime factors is $\\\\{7\\\\}$. And $\\\\{7\\\\}$ is not subset of $\\\\{2, 3, 5\\\\}$. Thus `False` for $7$ is justified."
                    },
                    {
                        "username": "d1mnewz",
                        "content": "Can somebody explain why in this case 1 is treated as ugly number? \\nBy definition\\n> Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.\\n\\nSo I can\\'t understand why 1 is an ugly number because it doesn\\'t have any of those prime factors."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nIn other words, without using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    }
                ]
            },
            {
                "id": 1573013,
                "content": [
                    {
                        "username": "ItzAryanTiwari",
                        "content": "Guys plz Improve the Description of the problem.\\nIf Agreed upvote."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Another rephrase of the definition if this sounds clearer:\n\nAn ugly number is a positive integer which does **not** have a prime factor **other than** 2, 3, and 5."
                    },
                    {
                        "username": "piyu5hkumar",
                        "content": "1 has neither 2 or 3 or 5  or their combination as factor, still its ugly, why so?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "not prime"
                    },
                    {
                        "username": "dyzo",
                        "content": "[@Sakshamji](/Sakshamji) You are right!"
                    },
                    {
                        "username": "Sakshamji",
                        "content": "We can interpret as it ugly number can be written as (2^a)*(3^b)*(5^c)\\nand since 1 = (2^0)*(3^0)*(5^0) thus 1 is ugly number ."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Bhushan_Waingankar",
                        "content": "Make sure to add these as your edge cases\\nif(n <= 0) return false;\\nif(n == 1) return true;"
                    },
                    {
                        "username": "orthogonal1",
                        "content": "n==1 is not necessarily an edge case."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "problem description phrasing could be better"
                    },
                    {
                        "username": "eduard92",
                        "content": "You sound like a canadian..."
                    },
                    {
                        "username": "mpack",
                        "content": "When num is 1, I was thinking it should be false... Can anybody explain this test case for me? Thanks in advance."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Sakshamji",
                        "content": "Every number N can be written as product of prime numbers as\n N = (A^a)(B^b)(C^c)....\nwhere A,B,C.. represent prime numers\ne.g 135 = (3^3)*(5^1) where 3 and 5 are prime numbers\n\nNow in this question they have asked for numbers that have 2,3,5 as A,B,C or prime numbers,\nthat means those numbers that can be represented as -\nUgly number (U) = (2^a)(3^b)(5^c)\nwhere a,b,c are positive numbers\nAs you can see 1 also satisfy above equation as\n1 = (2^0)(3^0)(5^0)\nthus it is also a ugly number\nI hope this insight will help you in solving this question."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Nice Tip, but following statement is incorrect.\\n> where a,b,c are positive numbers\\n\\nThey are whole numbers (or non-negative integers) to be precise."
                    },
                    {
                        "username": "quantupus",
                        "content": "code was going great until I realized negative numbers were a thing lol"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Someone else in the comments pointed out that an ugly number must be a POSITIVE integer. You can easily put a condition to return false if n<0."
                    },
                    {
                        "username": "vinayaktalukder17",
                        "content": "Same here. Just 500 test cases passed out of a 1013 test cases"
                    },
                    {
                        "username": "frankfaustino",
                        "content": "I\\'ve gotten into the habit of reading the constraints because I hate when this happens \\uD83D\\uDE00"
                    },
                    {
                        "username": "helenfanzhang",
                        "content": "I think this problem is seriously flawed as I see the expected cases for the following:\\n0: false\\n1: true\\n2: true\\n3: true\\n5: true\\n7: false"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@Kedarterkhedkar](/Kedarterkhedkar). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@Kedarterkhedkar](/Kedarterkhedkar)  The prime factors of 8 is 2x2x2x2\\nNow look for the definition of ugly numbers\\n"
                    },
                    {
                        "username": "Kedarterkhedkar",
                        "content": "[@RohitSgh](/RohitSgh) Can you explain why 8 is ugly number ?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $0$ simply does not satisfy the first condition. Hence, `False` for $0$ is justified.\\n\\nAll other integers satisfy the first condition. For second condition, let\\'s list down their set of prime factors.\\n- For $1$, the set of prime factors is $\\\\{\\\\}$. And empty set is subset of every set. Thus `True` for $1$ is justified.\\n- For $2$, the set of prime factors is $\\\\{2\\\\}$. And $\\\\{2\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $2$ is justified.\\n- For $3$, the set of prime factors is $\\\\{3\\\\}$. And $\\\\{3\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $3$ is justified.\\n- For $5$, the set of prime factors is $\\\\{5\\\\}$. And $\\\\{5\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $5$ is justified.\\n- For $7$, the set of prime factors is $\\\\{7\\\\}$. And $\\\\{7\\\\}$ is not subset of $\\\\{2, 3, 5\\\\}$. Thus `False` for $7$ is justified."
                    },
                    {
                        "username": "d1mnewz",
                        "content": "Can somebody explain why in this case 1 is treated as ugly number? \\nBy definition\\n> Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.\\n\\nSo I can\\'t understand why 1 is an ugly number because it doesn\\'t have any of those prime factors."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nIn other words, without using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    }
                ]
            },
            {
                "id": 1688944,
                "content": [
                    {
                        "username": "ItzAryanTiwari",
                        "content": "Guys plz Improve the Description of the problem.\\nIf Agreed upvote."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Another rephrase of the definition if this sounds clearer:\n\nAn ugly number is a positive integer which does **not** have a prime factor **other than** 2, 3, and 5."
                    },
                    {
                        "username": "piyu5hkumar",
                        "content": "1 has neither 2 or 3 or 5  or their combination as factor, still its ugly, why so?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "not prime"
                    },
                    {
                        "username": "dyzo",
                        "content": "[@Sakshamji](/Sakshamji) You are right!"
                    },
                    {
                        "username": "Sakshamji",
                        "content": "We can interpret as it ugly number can be written as (2^a)*(3^b)*(5^c)\\nand since 1 = (2^0)*(3^0)*(5^0) thus 1 is ugly number ."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Bhushan_Waingankar",
                        "content": "Make sure to add these as your edge cases\\nif(n <= 0) return false;\\nif(n == 1) return true;"
                    },
                    {
                        "username": "orthogonal1",
                        "content": "n==1 is not necessarily an edge case."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "problem description phrasing could be better"
                    },
                    {
                        "username": "eduard92",
                        "content": "You sound like a canadian..."
                    },
                    {
                        "username": "mpack",
                        "content": "When num is 1, I was thinking it should be false... Can anybody explain this test case for me? Thanks in advance."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Sakshamji",
                        "content": "Every number N can be written as product of prime numbers as\n N = (A^a)(B^b)(C^c)....\nwhere A,B,C.. represent prime numers\ne.g 135 = (3^3)*(5^1) where 3 and 5 are prime numbers\n\nNow in this question they have asked for numbers that have 2,3,5 as A,B,C or prime numbers,\nthat means those numbers that can be represented as -\nUgly number (U) = (2^a)(3^b)(5^c)\nwhere a,b,c are positive numbers\nAs you can see 1 also satisfy above equation as\n1 = (2^0)(3^0)(5^0)\nthus it is also a ugly number\nI hope this insight will help you in solving this question."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Nice Tip, but following statement is incorrect.\\n> where a,b,c are positive numbers\\n\\nThey are whole numbers (or non-negative integers) to be precise."
                    },
                    {
                        "username": "quantupus",
                        "content": "code was going great until I realized negative numbers were a thing lol"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Someone else in the comments pointed out that an ugly number must be a POSITIVE integer. You can easily put a condition to return false if n<0."
                    },
                    {
                        "username": "vinayaktalukder17",
                        "content": "Same here. Just 500 test cases passed out of a 1013 test cases"
                    },
                    {
                        "username": "frankfaustino",
                        "content": "I\\'ve gotten into the habit of reading the constraints because I hate when this happens \\uD83D\\uDE00"
                    },
                    {
                        "username": "helenfanzhang",
                        "content": "I think this problem is seriously flawed as I see the expected cases for the following:\\n0: false\\n1: true\\n2: true\\n3: true\\n5: true\\n7: false"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@Kedarterkhedkar](/Kedarterkhedkar). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@Kedarterkhedkar](/Kedarterkhedkar)  The prime factors of 8 is 2x2x2x2\\nNow look for the definition of ugly numbers\\n"
                    },
                    {
                        "username": "Kedarterkhedkar",
                        "content": "[@RohitSgh](/RohitSgh) Can you explain why 8 is ugly number ?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $0$ simply does not satisfy the first condition. Hence, `False` for $0$ is justified.\\n\\nAll other integers satisfy the first condition. For second condition, let\\'s list down their set of prime factors.\\n- For $1$, the set of prime factors is $\\\\{\\\\}$. And empty set is subset of every set. Thus `True` for $1$ is justified.\\n- For $2$, the set of prime factors is $\\\\{2\\\\}$. And $\\\\{2\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $2$ is justified.\\n- For $3$, the set of prime factors is $\\\\{3\\\\}$. And $\\\\{3\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $3$ is justified.\\n- For $5$, the set of prime factors is $\\\\{5\\\\}$. And $\\\\{5\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $5$ is justified.\\n- For $7$, the set of prime factors is $\\\\{7\\\\}$. And $\\\\{7\\\\}$ is not subset of $\\\\{2, 3, 5\\\\}$. Thus `False` for $7$ is justified."
                    },
                    {
                        "username": "d1mnewz",
                        "content": "Can somebody explain why in this case 1 is treated as ugly number? \\nBy definition\\n> Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.\\n\\nSo I can\\'t understand why 1 is an ugly number because it doesn\\'t have any of those prime factors."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nIn other words, without using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    }
                ]
            },
            {
                "id": 1688681,
                "content": [
                    {
                        "username": "ItzAryanTiwari",
                        "content": "Guys plz Improve the Description of the problem.\\nIf Agreed upvote."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Another rephrase of the definition if this sounds clearer:\n\nAn ugly number is a positive integer which does **not** have a prime factor **other than** 2, 3, and 5."
                    },
                    {
                        "username": "piyu5hkumar",
                        "content": "1 has neither 2 or 3 or 5  or their combination as factor, still its ugly, why so?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "not prime"
                    },
                    {
                        "username": "dyzo",
                        "content": "[@Sakshamji](/Sakshamji) You are right!"
                    },
                    {
                        "username": "Sakshamji",
                        "content": "We can interpret as it ugly number can be written as (2^a)*(3^b)*(5^c)\\nand since 1 = (2^0)*(3^0)*(5^0) thus 1 is ugly number ."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Bhushan_Waingankar",
                        "content": "Make sure to add these as your edge cases\\nif(n <= 0) return false;\\nif(n == 1) return true;"
                    },
                    {
                        "username": "orthogonal1",
                        "content": "n==1 is not necessarily an edge case."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "problem description phrasing could be better"
                    },
                    {
                        "username": "eduard92",
                        "content": "You sound like a canadian..."
                    },
                    {
                        "username": "mpack",
                        "content": "When num is 1, I was thinking it should be false... Can anybody explain this test case for me? Thanks in advance."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Sakshamji",
                        "content": "Every number N can be written as product of prime numbers as\n N = (A^a)(B^b)(C^c)....\nwhere A,B,C.. represent prime numers\ne.g 135 = (3^3)*(5^1) where 3 and 5 are prime numbers\n\nNow in this question they have asked for numbers that have 2,3,5 as A,B,C or prime numbers,\nthat means those numbers that can be represented as -\nUgly number (U) = (2^a)(3^b)(5^c)\nwhere a,b,c are positive numbers\nAs you can see 1 also satisfy above equation as\n1 = (2^0)(3^0)(5^0)\nthus it is also a ugly number\nI hope this insight will help you in solving this question."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Nice Tip, but following statement is incorrect.\\n> where a,b,c are positive numbers\\n\\nThey are whole numbers (or non-negative integers) to be precise."
                    },
                    {
                        "username": "quantupus",
                        "content": "code was going great until I realized negative numbers were a thing lol"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Someone else in the comments pointed out that an ugly number must be a POSITIVE integer. You can easily put a condition to return false if n<0."
                    },
                    {
                        "username": "vinayaktalukder17",
                        "content": "Same here. Just 500 test cases passed out of a 1013 test cases"
                    },
                    {
                        "username": "frankfaustino",
                        "content": "I\\'ve gotten into the habit of reading the constraints because I hate when this happens \\uD83D\\uDE00"
                    },
                    {
                        "username": "helenfanzhang",
                        "content": "I think this problem is seriously flawed as I see the expected cases for the following:\\n0: false\\n1: true\\n2: true\\n3: true\\n5: true\\n7: false"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@Kedarterkhedkar](/Kedarterkhedkar). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@Kedarterkhedkar](/Kedarterkhedkar)  The prime factors of 8 is 2x2x2x2\\nNow look for the definition of ugly numbers\\n"
                    },
                    {
                        "username": "Kedarterkhedkar",
                        "content": "[@RohitSgh](/RohitSgh) Can you explain why 8 is ugly number ?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $0$ simply does not satisfy the first condition. Hence, `False` for $0$ is justified.\\n\\nAll other integers satisfy the first condition. For second condition, let\\'s list down their set of prime factors.\\n- For $1$, the set of prime factors is $\\\\{\\\\}$. And empty set is subset of every set. Thus `True` for $1$ is justified.\\n- For $2$, the set of prime factors is $\\\\{2\\\\}$. And $\\\\{2\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $2$ is justified.\\n- For $3$, the set of prime factors is $\\\\{3\\\\}$. And $\\\\{3\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $3$ is justified.\\n- For $5$, the set of prime factors is $\\\\{5\\\\}$. And $\\\\{5\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $5$ is justified.\\n- For $7$, the set of prime factors is $\\\\{7\\\\}$. And $\\\\{7\\\\}$ is not subset of $\\\\{2, 3, 5\\\\}$. Thus `False` for $7$ is justified."
                    },
                    {
                        "username": "d1mnewz",
                        "content": "Can somebody explain why in this case 1 is treated as ugly number? \\nBy definition\\n> Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.\\n\\nSo I can\\'t understand why 1 is an ugly number because it doesn\\'t have any of those prime factors."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nIn other words, without using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    }
                ]
            },
            {
                "id": 1568030,
                "content": [
                    {
                        "username": "ItzAryanTiwari",
                        "content": "Guys plz Improve the Description of the problem.\\nIf Agreed upvote."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Another rephrase of the definition if this sounds clearer:\n\nAn ugly number is a positive integer which does **not** have a prime factor **other than** 2, 3, and 5."
                    },
                    {
                        "username": "piyu5hkumar",
                        "content": "1 has neither 2 or 3 or 5  or their combination as factor, still its ugly, why so?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "not prime"
                    },
                    {
                        "username": "dyzo",
                        "content": "[@Sakshamji](/Sakshamji) You are right!"
                    },
                    {
                        "username": "Sakshamji",
                        "content": "We can interpret as it ugly number can be written as (2^a)*(3^b)*(5^c)\\nand since 1 = (2^0)*(3^0)*(5^0) thus 1 is ugly number ."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Bhushan_Waingankar",
                        "content": "Make sure to add these as your edge cases\\nif(n <= 0) return false;\\nif(n == 1) return true;"
                    },
                    {
                        "username": "orthogonal1",
                        "content": "n==1 is not necessarily an edge case."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "problem description phrasing could be better"
                    },
                    {
                        "username": "eduard92",
                        "content": "You sound like a canadian..."
                    },
                    {
                        "username": "mpack",
                        "content": "When num is 1, I was thinking it should be false... Can anybody explain this test case for me? Thanks in advance."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Sakshamji",
                        "content": "Every number N can be written as product of prime numbers as\n N = (A^a)(B^b)(C^c)....\nwhere A,B,C.. represent prime numers\ne.g 135 = (3^3)*(5^1) where 3 and 5 are prime numbers\n\nNow in this question they have asked for numbers that have 2,3,5 as A,B,C or prime numbers,\nthat means those numbers that can be represented as -\nUgly number (U) = (2^a)(3^b)(5^c)\nwhere a,b,c are positive numbers\nAs you can see 1 also satisfy above equation as\n1 = (2^0)(3^0)(5^0)\nthus it is also a ugly number\nI hope this insight will help you in solving this question."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Nice Tip, but following statement is incorrect.\\n> where a,b,c are positive numbers\\n\\nThey are whole numbers (or non-negative integers) to be precise."
                    },
                    {
                        "username": "quantupus",
                        "content": "code was going great until I realized negative numbers were a thing lol"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Someone else in the comments pointed out that an ugly number must be a POSITIVE integer. You can easily put a condition to return false if n<0."
                    },
                    {
                        "username": "vinayaktalukder17",
                        "content": "Same here. Just 500 test cases passed out of a 1013 test cases"
                    },
                    {
                        "username": "frankfaustino",
                        "content": "I\\'ve gotten into the habit of reading the constraints because I hate when this happens \\uD83D\\uDE00"
                    },
                    {
                        "username": "helenfanzhang",
                        "content": "I think this problem is seriously flawed as I see the expected cases for the following:\\n0: false\\n1: true\\n2: true\\n3: true\\n5: true\\n7: false"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@Kedarterkhedkar](/Kedarterkhedkar). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@Kedarterkhedkar](/Kedarterkhedkar)  The prime factors of 8 is 2x2x2x2\\nNow look for the definition of ugly numbers\\n"
                    },
                    {
                        "username": "Kedarterkhedkar",
                        "content": "[@RohitSgh](/RohitSgh) Can you explain why 8 is ugly number ?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $0$ simply does not satisfy the first condition. Hence, `False` for $0$ is justified.\\n\\nAll other integers satisfy the first condition. For second condition, let\\'s list down their set of prime factors.\\n- For $1$, the set of prime factors is $\\\\{\\\\}$. And empty set is subset of every set. Thus `True` for $1$ is justified.\\n- For $2$, the set of prime factors is $\\\\{2\\\\}$. And $\\\\{2\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $2$ is justified.\\n- For $3$, the set of prime factors is $\\\\{3\\\\}$. And $\\\\{3\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $3$ is justified.\\n- For $5$, the set of prime factors is $\\\\{5\\\\}$. And $\\\\{5\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $5$ is justified.\\n- For $7$, the set of prime factors is $\\\\{7\\\\}$. And $\\\\{7\\\\}$ is not subset of $\\\\{2, 3, 5\\\\}$. Thus `False` for $7$ is justified."
                    },
                    {
                        "username": "d1mnewz",
                        "content": "Can somebody explain why in this case 1 is treated as ugly number? \\nBy definition\\n> Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.\\n\\nSo I can\\'t understand why 1 is an ugly number because it doesn\\'t have any of those prime factors."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nIn other words, without using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    }
                ]
            },
            {
                "id": 1572705,
                "content": [
                    {
                        "username": "ItzAryanTiwari",
                        "content": "Guys plz Improve the Description of the problem.\\nIf Agreed upvote."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Another rephrase of the definition if this sounds clearer:\n\nAn ugly number is a positive integer which does **not** have a prime factor **other than** 2, 3, and 5."
                    },
                    {
                        "username": "piyu5hkumar",
                        "content": "1 has neither 2 or 3 or 5  or their combination as factor, still its ugly, why so?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "not prime"
                    },
                    {
                        "username": "dyzo",
                        "content": "[@Sakshamji](/Sakshamji) You are right!"
                    },
                    {
                        "username": "Sakshamji",
                        "content": "We can interpret as it ugly number can be written as (2^a)*(3^b)*(5^c)\\nand since 1 = (2^0)*(3^0)*(5^0) thus 1 is ugly number ."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Bhushan_Waingankar",
                        "content": "Make sure to add these as your edge cases\\nif(n <= 0) return false;\\nif(n == 1) return true;"
                    },
                    {
                        "username": "orthogonal1",
                        "content": "n==1 is not necessarily an edge case."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "problem description phrasing could be better"
                    },
                    {
                        "username": "eduard92",
                        "content": "You sound like a canadian..."
                    },
                    {
                        "username": "mpack",
                        "content": "When num is 1, I was thinking it should be false... Can anybody explain this test case for me? Thanks in advance."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Sakshamji",
                        "content": "Every number N can be written as product of prime numbers as\n N = (A^a)(B^b)(C^c)....\nwhere A,B,C.. represent prime numers\ne.g 135 = (3^3)*(5^1) where 3 and 5 are prime numbers\n\nNow in this question they have asked for numbers that have 2,3,5 as A,B,C or prime numbers,\nthat means those numbers that can be represented as -\nUgly number (U) = (2^a)(3^b)(5^c)\nwhere a,b,c are positive numbers\nAs you can see 1 also satisfy above equation as\n1 = (2^0)(3^0)(5^0)\nthus it is also a ugly number\nI hope this insight will help you in solving this question."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Nice Tip, but following statement is incorrect.\\n> where a,b,c are positive numbers\\n\\nThey are whole numbers (or non-negative integers) to be precise."
                    },
                    {
                        "username": "quantupus",
                        "content": "code was going great until I realized negative numbers were a thing lol"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Someone else in the comments pointed out that an ugly number must be a POSITIVE integer. You can easily put a condition to return false if n<0."
                    },
                    {
                        "username": "vinayaktalukder17",
                        "content": "Same here. Just 500 test cases passed out of a 1013 test cases"
                    },
                    {
                        "username": "frankfaustino",
                        "content": "I\\'ve gotten into the habit of reading the constraints because I hate when this happens \\uD83D\\uDE00"
                    },
                    {
                        "username": "helenfanzhang",
                        "content": "I think this problem is seriously flawed as I see the expected cases for the following:\\n0: false\\n1: true\\n2: true\\n3: true\\n5: true\\n7: false"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@Kedarterkhedkar](/Kedarterkhedkar). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@Kedarterkhedkar](/Kedarterkhedkar)  The prime factors of 8 is 2x2x2x2\\nNow look for the definition of ugly numbers\\n"
                    },
                    {
                        "username": "Kedarterkhedkar",
                        "content": "[@RohitSgh](/RohitSgh) Can you explain why 8 is ugly number ?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $0$ simply does not satisfy the first condition. Hence, `False` for $0$ is justified.\\n\\nAll other integers satisfy the first condition. For second condition, let\\'s list down their set of prime factors.\\n- For $1$, the set of prime factors is $\\\\{\\\\}$. And empty set is subset of every set. Thus `True` for $1$ is justified.\\n- For $2$, the set of prime factors is $\\\\{2\\\\}$. And $\\\\{2\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $2$ is justified.\\n- For $3$, the set of prime factors is $\\\\{3\\\\}$. And $\\\\{3\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $3$ is justified.\\n- For $5$, the set of prime factors is $\\\\{5\\\\}$. And $\\\\{5\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $5$ is justified.\\n- For $7$, the set of prime factors is $\\\\{7\\\\}$. And $\\\\{7\\\\}$ is not subset of $\\\\{2, 3, 5\\\\}$. Thus `False` for $7$ is justified."
                    },
                    {
                        "username": "d1mnewz",
                        "content": "Can somebody explain why in this case 1 is treated as ugly number? \\nBy definition\\n> Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.\\n\\nSo I can\\'t understand why 1 is an ugly number because it doesn\\'t have any of those prime factors."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nIn other words, without using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    }
                ]
            },
            {
                "id": 1805367,
                "content": [
                    {
                        "username": "ItzAryanTiwari",
                        "content": "Guys plz Improve the Description of the problem.\\nIf Agreed upvote."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Another rephrase of the definition if this sounds clearer:\n\nAn ugly number is a positive integer which does **not** have a prime factor **other than** 2, 3, and 5."
                    },
                    {
                        "username": "piyu5hkumar",
                        "content": "1 has neither 2 or 3 or 5  or their combination as factor, still its ugly, why so?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "not prime"
                    },
                    {
                        "username": "dyzo",
                        "content": "[@Sakshamji](/Sakshamji) You are right!"
                    },
                    {
                        "username": "Sakshamji",
                        "content": "We can interpret as it ugly number can be written as (2^a)*(3^b)*(5^c)\\nand since 1 = (2^0)*(3^0)*(5^0) thus 1 is ugly number ."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Bhushan_Waingankar",
                        "content": "Make sure to add these as your edge cases\\nif(n <= 0) return false;\\nif(n == 1) return true;"
                    },
                    {
                        "username": "orthogonal1",
                        "content": "n==1 is not necessarily an edge case."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "problem description phrasing could be better"
                    },
                    {
                        "username": "eduard92",
                        "content": "You sound like a canadian..."
                    },
                    {
                        "username": "mpack",
                        "content": "When num is 1, I was thinking it should be false... Can anybody explain this test case for me? Thanks in advance."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Sakshamji",
                        "content": "Every number N can be written as product of prime numbers as\n N = (A^a)(B^b)(C^c)....\nwhere A,B,C.. represent prime numers\ne.g 135 = (3^3)*(5^1) where 3 and 5 are prime numbers\n\nNow in this question they have asked for numbers that have 2,3,5 as A,B,C or prime numbers,\nthat means those numbers that can be represented as -\nUgly number (U) = (2^a)(3^b)(5^c)\nwhere a,b,c are positive numbers\nAs you can see 1 also satisfy above equation as\n1 = (2^0)(3^0)(5^0)\nthus it is also a ugly number\nI hope this insight will help you in solving this question."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Nice Tip, but following statement is incorrect.\\n> where a,b,c are positive numbers\\n\\nThey are whole numbers (or non-negative integers) to be precise."
                    },
                    {
                        "username": "quantupus",
                        "content": "code was going great until I realized negative numbers were a thing lol"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Someone else in the comments pointed out that an ugly number must be a POSITIVE integer. You can easily put a condition to return false if n<0."
                    },
                    {
                        "username": "vinayaktalukder17",
                        "content": "Same here. Just 500 test cases passed out of a 1013 test cases"
                    },
                    {
                        "username": "frankfaustino",
                        "content": "I\\'ve gotten into the habit of reading the constraints because I hate when this happens \\uD83D\\uDE00"
                    },
                    {
                        "username": "helenfanzhang",
                        "content": "I think this problem is seriously flawed as I see the expected cases for the following:\\n0: false\\n1: true\\n2: true\\n3: true\\n5: true\\n7: false"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@Kedarterkhedkar](/Kedarterkhedkar). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@Kedarterkhedkar](/Kedarterkhedkar)  The prime factors of 8 is 2x2x2x2\\nNow look for the definition of ugly numbers\\n"
                    },
                    {
                        "username": "Kedarterkhedkar",
                        "content": "[@RohitSgh](/RohitSgh) Can you explain why 8 is ugly number ?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $0$ simply does not satisfy the first condition. Hence, `False` for $0$ is justified.\\n\\nAll other integers satisfy the first condition. For second condition, let\\'s list down their set of prime factors.\\n- For $1$, the set of prime factors is $\\\\{\\\\}$. And empty set is subset of every set. Thus `True` for $1$ is justified.\\n- For $2$, the set of prime factors is $\\\\{2\\\\}$. And $\\\\{2\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $2$ is justified.\\n- For $3$, the set of prime factors is $\\\\{3\\\\}$. And $\\\\{3\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $3$ is justified.\\n- For $5$, the set of prime factors is $\\\\{5\\\\}$. And $\\\\{5\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $5$ is justified.\\n- For $7$, the set of prime factors is $\\\\{7\\\\}$. And $\\\\{7\\\\}$ is not subset of $\\\\{2, 3, 5\\\\}$. Thus `False` for $7$ is justified."
                    },
                    {
                        "username": "d1mnewz",
                        "content": "Can somebody explain why in this case 1 is treated as ugly number? \\nBy definition\\n> Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.\\n\\nSo I can\\'t understand why 1 is an ugly number because it doesn\\'t have any of those prime factors."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nIn other words, without using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    }
                ]
            },
            {
                "id": 1687894,
                "content": [
                    {
                        "username": "ItzAryanTiwari",
                        "content": "Guys plz Improve the Description of the problem.\\nIf Agreed upvote."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Another rephrase of the definition if this sounds clearer:\n\nAn ugly number is a positive integer which does **not** have a prime factor **other than** 2, 3, and 5."
                    },
                    {
                        "username": "piyu5hkumar",
                        "content": "1 has neither 2 or 3 or 5  or their combination as factor, still its ugly, why so?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "not prime"
                    },
                    {
                        "username": "dyzo",
                        "content": "[@Sakshamji](/Sakshamji) You are right!"
                    },
                    {
                        "username": "Sakshamji",
                        "content": "We can interpret as it ugly number can be written as (2^a)*(3^b)*(5^c)\\nand since 1 = (2^0)*(3^0)*(5^0) thus 1 is ugly number ."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Bhushan_Waingankar",
                        "content": "Make sure to add these as your edge cases\\nif(n <= 0) return false;\\nif(n == 1) return true;"
                    },
                    {
                        "username": "orthogonal1",
                        "content": "n==1 is not necessarily an edge case."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "problem description phrasing could be better"
                    },
                    {
                        "username": "eduard92",
                        "content": "You sound like a canadian..."
                    },
                    {
                        "username": "mpack",
                        "content": "When num is 1, I was thinking it should be false... Can anybody explain this test case for me? Thanks in advance."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Sakshamji",
                        "content": "Every number N can be written as product of prime numbers as\n N = (A^a)(B^b)(C^c)....\nwhere A,B,C.. represent prime numers\ne.g 135 = (3^3)*(5^1) where 3 and 5 are prime numbers\n\nNow in this question they have asked for numbers that have 2,3,5 as A,B,C or prime numbers,\nthat means those numbers that can be represented as -\nUgly number (U) = (2^a)(3^b)(5^c)\nwhere a,b,c are positive numbers\nAs you can see 1 also satisfy above equation as\n1 = (2^0)(3^0)(5^0)\nthus it is also a ugly number\nI hope this insight will help you in solving this question."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Nice Tip, but following statement is incorrect.\\n> where a,b,c are positive numbers\\n\\nThey are whole numbers (or non-negative integers) to be precise."
                    },
                    {
                        "username": "quantupus",
                        "content": "code was going great until I realized negative numbers were a thing lol"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Someone else in the comments pointed out that an ugly number must be a POSITIVE integer. You can easily put a condition to return false if n<0."
                    },
                    {
                        "username": "vinayaktalukder17",
                        "content": "Same here. Just 500 test cases passed out of a 1013 test cases"
                    },
                    {
                        "username": "frankfaustino",
                        "content": "I\\'ve gotten into the habit of reading the constraints because I hate when this happens \\uD83D\\uDE00"
                    },
                    {
                        "username": "helenfanzhang",
                        "content": "I think this problem is seriously flawed as I see the expected cases for the following:\\n0: false\\n1: true\\n2: true\\n3: true\\n5: true\\n7: false"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@Kedarterkhedkar](/Kedarterkhedkar). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@Kedarterkhedkar](/Kedarterkhedkar)  The prime factors of 8 is 2x2x2x2\\nNow look for the definition of ugly numbers\\n"
                    },
                    {
                        "username": "Kedarterkhedkar",
                        "content": "[@RohitSgh](/RohitSgh) Can you explain why 8 is ugly number ?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $0$ simply does not satisfy the first condition. Hence, `False` for $0$ is justified.\\n\\nAll other integers satisfy the first condition. For second condition, let\\'s list down their set of prime factors.\\n- For $1$, the set of prime factors is $\\\\{\\\\}$. And empty set is subset of every set. Thus `True` for $1$ is justified.\\n- For $2$, the set of prime factors is $\\\\{2\\\\}$. And $\\\\{2\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $2$ is justified.\\n- For $3$, the set of prime factors is $\\\\{3\\\\}$. And $\\\\{3\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $3$ is justified.\\n- For $5$, the set of prime factors is $\\\\{5\\\\}$. And $\\\\{5\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $5$ is justified.\\n- For $7$, the set of prime factors is $\\\\{7\\\\}$. And $\\\\{7\\\\}$ is not subset of $\\\\{2, 3, 5\\\\}$. Thus `False` for $7$ is justified."
                    },
                    {
                        "username": "d1mnewz",
                        "content": "Can somebody explain why in this case 1 is treated as ugly number? \\nBy definition\\n> Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.\\n\\nSo I can\\'t understand why 1 is an ugly number because it doesn\\'t have any of those prime factors."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nIn other words, without using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    }
                ]
            },
            {
                "id": 1570058,
                "content": [
                    {
                        "username": "ItzAryanTiwari",
                        "content": "Guys plz Improve the Description of the problem.\\nIf Agreed upvote."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Another rephrase of the definition if this sounds clearer:\n\nAn ugly number is a positive integer which does **not** have a prime factor **other than** 2, 3, and 5."
                    },
                    {
                        "username": "piyu5hkumar",
                        "content": "1 has neither 2 or 3 or 5  or their combination as factor, still its ugly, why so?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "not prime"
                    },
                    {
                        "username": "dyzo",
                        "content": "[@Sakshamji](/Sakshamji) You are right!"
                    },
                    {
                        "username": "Sakshamji",
                        "content": "We can interpret as it ugly number can be written as (2^a)*(3^b)*(5^c)\\nand since 1 = (2^0)*(3^0)*(5^0) thus 1 is ugly number ."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Bhushan_Waingankar",
                        "content": "Make sure to add these as your edge cases\\nif(n <= 0) return false;\\nif(n == 1) return true;"
                    },
                    {
                        "username": "orthogonal1",
                        "content": "n==1 is not necessarily an edge case."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "problem description phrasing could be better"
                    },
                    {
                        "username": "eduard92",
                        "content": "You sound like a canadian..."
                    },
                    {
                        "username": "mpack",
                        "content": "When num is 1, I was thinking it should be false... Can anybody explain this test case for me? Thanks in advance."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Sakshamji",
                        "content": "Every number N can be written as product of prime numbers as\n N = (A^a)(B^b)(C^c)....\nwhere A,B,C.. represent prime numers\ne.g 135 = (3^3)*(5^1) where 3 and 5 are prime numbers\n\nNow in this question they have asked for numbers that have 2,3,5 as A,B,C or prime numbers,\nthat means those numbers that can be represented as -\nUgly number (U) = (2^a)(3^b)(5^c)\nwhere a,b,c are positive numbers\nAs you can see 1 also satisfy above equation as\n1 = (2^0)(3^0)(5^0)\nthus it is also a ugly number\nI hope this insight will help you in solving this question."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Nice Tip, but following statement is incorrect.\\n> where a,b,c are positive numbers\\n\\nThey are whole numbers (or non-negative integers) to be precise."
                    },
                    {
                        "username": "quantupus",
                        "content": "code was going great until I realized negative numbers were a thing lol"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Someone else in the comments pointed out that an ugly number must be a POSITIVE integer. You can easily put a condition to return false if n<0."
                    },
                    {
                        "username": "vinayaktalukder17",
                        "content": "Same here. Just 500 test cases passed out of a 1013 test cases"
                    },
                    {
                        "username": "frankfaustino",
                        "content": "I\\'ve gotten into the habit of reading the constraints because I hate when this happens \\uD83D\\uDE00"
                    },
                    {
                        "username": "helenfanzhang",
                        "content": "I think this problem is seriously flawed as I see the expected cases for the following:\\n0: false\\n1: true\\n2: true\\n3: true\\n5: true\\n7: false"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@Kedarterkhedkar](/Kedarterkhedkar). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@Kedarterkhedkar](/Kedarterkhedkar)  The prime factors of 8 is 2x2x2x2\\nNow look for the definition of ugly numbers\\n"
                    },
                    {
                        "username": "Kedarterkhedkar",
                        "content": "[@RohitSgh](/RohitSgh) Can you explain why 8 is ugly number ?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $0$ simply does not satisfy the first condition. Hence, `False` for $0$ is justified.\\n\\nAll other integers satisfy the first condition. For second condition, let\\'s list down their set of prime factors.\\n- For $1$, the set of prime factors is $\\\\{\\\\}$. And empty set is subset of every set. Thus `True` for $1$ is justified.\\n- For $2$, the set of prime factors is $\\\\{2\\\\}$. And $\\\\{2\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $2$ is justified.\\n- For $3$, the set of prime factors is $\\\\{3\\\\}$. And $\\\\{3\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $3$ is justified.\\n- For $5$, the set of prime factors is $\\\\{5\\\\}$. And $\\\\{5\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $5$ is justified.\\n- For $7$, the set of prime factors is $\\\\{7\\\\}$. And $\\\\{7\\\\}$ is not subset of $\\\\{2, 3, 5\\\\}$. Thus `False` for $7$ is justified."
                    },
                    {
                        "username": "d1mnewz",
                        "content": "Can somebody explain why in this case 1 is treated as ugly number? \\nBy definition\\n> Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.\\n\\nSo I can\\'t understand why 1 is an ugly number because it doesn\\'t have any of those prime factors."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nIn other words, without using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    }
                ]
            },
            {
                "id": 1688131,
                "content": [
                    {
                        "username": "ItzAryanTiwari",
                        "content": "Guys plz Improve the Description of the problem.\\nIf Agreed upvote."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Another rephrase of the definition if this sounds clearer:\n\nAn ugly number is a positive integer which does **not** have a prime factor **other than** 2, 3, and 5."
                    },
                    {
                        "username": "piyu5hkumar",
                        "content": "1 has neither 2 or 3 or 5  or their combination as factor, still its ugly, why so?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "not prime"
                    },
                    {
                        "username": "dyzo",
                        "content": "[@Sakshamji](/Sakshamji) You are right!"
                    },
                    {
                        "username": "Sakshamji",
                        "content": "We can interpret as it ugly number can be written as (2^a)*(3^b)*(5^c)\\nand since 1 = (2^0)*(3^0)*(5^0) thus 1 is ugly number ."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Bhushan_Waingankar",
                        "content": "Make sure to add these as your edge cases\\nif(n <= 0) return false;\\nif(n == 1) return true;"
                    },
                    {
                        "username": "orthogonal1",
                        "content": "n==1 is not necessarily an edge case."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "problem description phrasing could be better"
                    },
                    {
                        "username": "eduard92",
                        "content": "You sound like a canadian..."
                    },
                    {
                        "username": "mpack",
                        "content": "When num is 1, I was thinking it should be false... Can anybody explain this test case for me? Thanks in advance."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Sakshamji",
                        "content": "Every number N can be written as product of prime numbers as\n N = (A^a)(B^b)(C^c)....\nwhere A,B,C.. represent prime numers\ne.g 135 = (3^3)*(5^1) where 3 and 5 are prime numbers\n\nNow in this question they have asked for numbers that have 2,3,5 as A,B,C or prime numbers,\nthat means those numbers that can be represented as -\nUgly number (U) = (2^a)(3^b)(5^c)\nwhere a,b,c are positive numbers\nAs you can see 1 also satisfy above equation as\n1 = (2^0)(3^0)(5^0)\nthus it is also a ugly number\nI hope this insight will help you in solving this question."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Nice Tip, but following statement is incorrect.\\n> where a,b,c are positive numbers\\n\\nThey are whole numbers (or non-negative integers) to be precise."
                    },
                    {
                        "username": "quantupus",
                        "content": "code was going great until I realized negative numbers were a thing lol"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Someone else in the comments pointed out that an ugly number must be a POSITIVE integer. You can easily put a condition to return false if n<0."
                    },
                    {
                        "username": "vinayaktalukder17",
                        "content": "Same here. Just 500 test cases passed out of a 1013 test cases"
                    },
                    {
                        "username": "frankfaustino",
                        "content": "I\\'ve gotten into the habit of reading the constraints because I hate when this happens \\uD83D\\uDE00"
                    },
                    {
                        "username": "helenfanzhang",
                        "content": "I think this problem is seriously flawed as I see the expected cases for the following:\\n0: false\\n1: true\\n2: true\\n3: true\\n5: true\\n7: false"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@Kedarterkhedkar](/Kedarterkhedkar). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@Kedarterkhedkar](/Kedarterkhedkar)  The prime factors of 8 is 2x2x2x2\\nNow look for the definition of ugly numbers\\n"
                    },
                    {
                        "username": "Kedarterkhedkar",
                        "content": "[@RohitSgh](/RohitSgh) Can you explain why 8 is ugly number ?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $0$ simply does not satisfy the first condition. Hence, `False` for $0$ is justified.\\n\\nAll other integers satisfy the first condition. For second condition, let\\'s list down their set of prime factors.\\n- For $1$, the set of prime factors is $\\\\{\\\\}$. And empty set is subset of every set. Thus `True` for $1$ is justified.\\n- For $2$, the set of prime factors is $\\\\{2\\\\}$. And $\\\\{2\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $2$ is justified.\\n- For $3$, the set of prime factors is $\\\\{3\\\\}$. And $\\\\{3\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $3$ is justified.\\n- For $5$, the set of prime factors is $\\\\{5\\\\}$. And $\\\\{5\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $5$ is justified.\\n- For $7$, the set of prime factors is $\\\\{7\\\\}$. And $\\\\{7\\\\}$ is not subset of $\\\\{2, 3, 5\\\\}$. Thus `False` for $7$ is justified."
                    },
                    {
                        "username": "d1mnewz",
                        "content": "Can somebody explain why in this case 1 is treated as ugly number? \\nBy definition\\n> Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.\\n\\nSo I can\\'t understand why 1 is an ugly number because it doesn\\'t have any of those prime factors."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nIn other words, without using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    }
                ]
            },
            {
                "id": 1688165,
                "content": [
                    {
                        "username": "ItzAryanTiwari",
                        "content": "Guys plz Improve the Description of the problem.\\nIf Agreed upvote."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Another rephrase of the definition if this sounds clearer:\n\nAn ugly number is a positive integer which does **not** have a prime factor **other than** 2, 3, and 5."
                    },
                    {
                        "username": "piyu5hkumar",
                        "content": "1 has neither 2 or 3 or 5  or their combination as factor, still its ugly, why so?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "not prime"
                    },
                    {
                        "username": "dyzo",
                        "content": "[@Sakshamji](/Sakshamji) You are right!"
                    },
                    {
                        "username": "Sakshamji",
                        "content": "We can interpret as it ugly number can be written as (2^a)*(3^b)*(5^c)\\nand since 1 = (2^0)*(3^0)*(5^0) thus 1 is ugly number ."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Bhushan_Waingankar",
                        "content": "Make sure to add these as your edge cases\\nif(n <= 0) return false;\\nif(n == 1) return true;"
                    },
                    {
                        "username": "orthogonal1",
                        "content": "n==1 is not necessarily an edge case."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "problem description phrasing could be better"
                    },
                    {
                        "username": "eduard92",
                        "content": "You sound like a canadian..."
                    },
                    {
                        "username": "mpack",
                        "content": "When num is 1, I was thinking it should be false... Can anybody explain this test case for me? Thanks in advance."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Sakshamji",
                        "content": "Every number N can be written as product of prime numbers as\n N = (A^a)(B^b)(C^c)....\nwhere A,B,C.. represent prime numers\ne.g 135 = (3^3)*(5^1) where 3 and 5 are prime numbers\n\nNow in this question they have asked for numbers that have 2,3,5 as A,B,C or prime numbers,\nthat means those numbers that can be represented as -\nUgly number (U) = (2^a)(3^b)(5^c)\nwhere a,b,c are positive numbers\nAs you can see 1 also satisfy above equation as\n1 = (2^0)(3^0)(5^0)\nthus it is also a ugly number\nI hope this insight will help you in solving this question."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Nice Tip, but following statement is incorrect.\\n> where a,b,c are positive numbers\\n\\nThey are whole numbers (or non-negative integers) to be precise."
                    },
                    {
                        "username": "quantupus",
                        "content": "code was going great until I realized negative numbers were a thing lol"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Someone else in the comments pointed out that an ugly number must be a POSITIVE integer. You can easily put a condition to return false if n<0."
                    },
                    {
                        "username": "vinayaktalukder17",
                        "content": "Same here. Just 500 test cases passed out of a 1013 test cases"
                    },
                    {
                        "username": "frankfaustino",
                        "content": "I\\'ve gotten into the habit of reading the constraints because I hate when this happens \\uD83D\\uDE00"
                    },
                    {
                        "username": "helenfanzhang",
                        "content": "I think this problem is seriously flawed as I see the expected cases for the following:\\n0: false\\n1: true\\n2: true\\n3: true\\n5: true\\n7: false"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@Kedarterkhedkar](/Kedarterkhedkar). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@Kedarterkhedkar](/Kedarterkhedkar)  The prime factors of 8 is 2x2x2x2\\nNow look for the definition of ugly numbers\\n"
                    },
                    {
                        "username": "Kedarterkhedkar",
                        "content": "[@RohitSgh](/RohitSgh) Can you explain why 8 is ugly number ?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $0$ simply does not satisfy the first condition. Hence, `False` for $0$ is justified.\\n\\nAll other integers satisfy the first condition. For second condition, let\\'s list down their set of prime factors.\\n- For $1$, the set of prime factors is $\\\\{\\\\}$. And empty set is subset of every set. Thus `True` for $1$ is justified.\\n- For $2$, the set of prime factors is $\\\\{2\\\\}$. And $\\\\{2\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $2$ is justified.\\n- For $3$, the set of prime factors is $\\\\{3\\\\}$. And $\\\\{3\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $3$ is justified.\\n- For $5$, the set of prime factors is $\\\\{5\\\\}$. And $\\\\{5\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $5$ is justified.\\n- For $7$, the set of prime factors is $\\\\{7\\\\}$. And $\\\\{7\\\\}$ is not subset of $\\\\{2, 3, 5\\\\}$. Thus `False` for $7$ is justified."
                    },
                    {
                        "username": "d1mnewz",
                        "content": "Can somebody explain why in this case 1 is treated as ugly number? \\nBy definition\\n> Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.\\n\\nSo I can\\'t understand why 1 is an ugly number because it doesn\\'t have any of those prime factors."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nIn other words, without using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    }
                ]
            },
            {
                "id": 1573013,
                "content": [
                    {
                        "username": "ItzAryanTiwari",
                        "content": "Guys plz Improve the Description of the problem.\\nIf Agreed upvote."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Another rephrase of the definition if this sounds clearer:\n\nAn ugly number is a positive integer which does **not** have a prime factor **other than** 2, 3, and 5."
                    },
                    {
                        "username": "piyu5hkumar",
                        "content": "1 has neither 2 or 3 or 5  or their combination as factor, still its ugly, why so?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "not prime"
                    },
                    {
                        "username": "dyzo",
                        "content": "[@Sakshamji](/Sakshamji) You are right!"
                    },
                    {
                        "username": "Sakshamji",
                        "content": "We can interpret as it ugly number can be written as (2^a)*(3^b)*(5^c)\\nand since 1 = (2^0)*(3^0)*(5^0) thus 1 is ugly number ."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Bhushan_Waingankar",
                        "content": "Make sure to add these as your edge cases\\nif(n <= 0) return false;\\nif(n == 1) return true;"
                    },
                    {
                        "username": "orthogonal1",
                        "content": "n==1 is not necessarily an edge case."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "problem description phrasing could be better"
                    },
                    {
                        "username": "eduard92",
                        "content": "You sound like a canadian..."
                    },
                    {
                        "username": "mpack",
                        "content": "When num is 1, I was thinking it should be false... Can anybody explain this test case for me? Thanks in advance."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Sakshamji",
                        "content": "Every number N can be written as product of prime numbers as\n N = (A^a)(B^b)(C^c)....\nwhere A,B,C.. represent prime numers\ne.g 135 = (3^3)*(5^1) where 3 and 5 are prime numbers\n\nNow in this question they have asked for numbers that have 2,3,5 as A,B,C or prime numbers,\nthat means those numbers that can be represented as -\nUgly number (U) = (2^a)(3^b)(5^c)\nwhere a,b,c are positive numbers\nAs you can see 1 also satisfy above equation as\n1 = (2^0)(3^0)(5^0)\nthus it is also a ugly number\nI hope this insight will help you in solving this question."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Nice Tip, but following statement is incorrect.\\n> where a,b,c are positive numbers\\n\\nThey are whole numbers (or non-negative integers) to be precise."
                    },
                    {
                        "username": "quantupus",
                        "content": "code was going great until I realized negative numbers were a thing lol"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Someone else in the comments pointed out that an ugly number must be a POSITIVE integer. You can easily put a condition to return false if n<0."
                    },
                    {
                        "username": "vinayaktalukder17",
                        "content": "Same here. Just 500 test cases passed out of a 1013 test cases"
                    },
                    {
                        "username": "frankfaustino",
                        "content": "I\\'ve gotten into the habit of reading the constraints because I hate when this happens \\uD83D\\uDE00"
                    },
                    {
                        "username": "helenfanzhang",
                        "content": "I think this problem is seriously flawed as I see the expected cases for the following:\\n0: false\\n1: true\\n2: true\\n3: true\\n5: true\\n7: false"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@Kedarterkhedkar](/Kedarterkhedkar). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@Kedarterkhedkar](/Kedarterkhedkar)  The prime factors of 8 is 2x2x2x2\\nNow look for the definition of ugly numbers\\n"
                    },
                    {
                        "username": "Kedarterkhedkar",
                        "content": "[@RohitSgh](/RohitSgh) Can you explain why 8 is ugly number ?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $0$ simply does not satisfy the first condition. Hence, `False` for $0$ is justified.\\n\\nAll other integers satisfy the first condition. For second condition, let\\'s list down their set of prime factors.\\n- For $1$, the set of prime factors is $\\\\{\\\\}$. And empty set is subset of every set. Thus `True` for $1$ is justified.\\n- For $2$, the set of prime factors is $\\\\{2\\\\}$. And $\\\\{2\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $2$ is justified.\\n- For $3$, the set of prime factors is $\\\\{3\\\\}$. And $\\\\{3\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $3$ is justified.\\n- For $5$, the set of prime factors is $\\\\{5\\\\}$. And $\\\\{5\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $5$ is justified.\\n- For $7$, the set of prime factors is $\\\\{7\\\\}$. And $\\\\{7\\\\}$ is not subset of $\\\\{2, 3, 5\\\\}$. Thus `False` for $7$ is justified."
                    },
                    {
                        "username": "d1mnewz",
                        "content": "Can somebody explain why in this case 1 is treated as ugly number? \\nBy definition\\n> Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.\\n\\nSo I can\\'t understand why 1 is an ugly number because it doesn\\'t have any of those prime factors."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nIn other words, without using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    }
                ]
            },
            {
                "id": 1688944,
                "content": [
                    {
                        "username": "ItzAryanTiwari",
                        "content": "Guys plz Improve the Description of the problem.\\nIf Agreed upvote."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Another rephrase of the definition if this sounds clearer:\n\nAn ugly number is a positive integer which does **not** have a prime factor **other than** 2, 3, and 5."
                    },
                    {
                        "username": "piyu5hkumar",
                        "content": "1 has neither 2 or 3 or 5  or their combination as factor, still its ugly, why so?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "not prime"
                    },
                    {
                        "username": "dyzo",
                        "content": "[@Sakshamji](/Sakshamji) You are right!"
                    },
                    {
                        "username": "Sakshamji",
                        "content": "We can interpret as it ugly number can be written as (2^a)*(3^b)*(5^c)\\nand since 1 = (2^0)*(3^0)*(5^0) thus 1 is ugly number ."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Bhushan_Waingankar",
                        "content": "Make sure to add these as your edge cases\\nif(n <= 0) return false;\\nif(n == 1) return true;"
                    },
                    {
                        "username": "orthogonal1",
                        "content": "n==1 is not necessarily an edge case."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "problem description phrasing could be better"
                    },
                    {
                        "username": "eduard92",
                        "content": "You sound like a canadian..."
                    },
                    {
                        "username": "mpack",
                        "content": "When num is 1, I was thinking it should be false... Can anybody explain this test case for me? Thanks in advance."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Sakshamji",
                        "content": "Every number N can be written as product of prime numbers as\n N = (A^a)(B^b)(C^c)....\nwhere A,B,C.. represent prime numers\ne.g 135 = (3^3)*(5^1) where 3 and 5 are prime numbers\n\nNow in this question they have asked for numbers that have 2,3,5 as A,B,C or prime numbers,\nthat means those numbers that can be represented as -\nUgly number (U) = (2^a)(3^b)(5^c)\nwhere a,b,c are positive numbers\nAs you can see 1 also satisfy above equation as\n1 = (2^0)(3^0)(5^0)\nthus it is also a ugly number\nI hope this insight will help you in solving this question."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Nice Tip, but following statement is incorrect.\\n> where a,b,c are positive numbers\\n\\nThey are whole numbers (or non-negative integers) to be precise."
                    },
                    {
                        "username": "quantupus",
                        "content": "code was going great until I realized negative numbers were a thing lol"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Someone else in the comments pointed out that an ugly number must be a POSITIVE integer. You can easily put a condition to return false if n<0."
                    },
                    {
                        "username": "vinayaktalukder17",
                        "content": "Same here. Just 500 test cases passed out of a 1013 test cases"
                    },
                    {
                        "username": "frankfaustino",
                        "content": "I\\'ve gotten into the habit of reading the constraints because I hate when this happens \\uD83D\\uDE00"
                    },
                    {
                        "username": "helenfanzhang",
                        "content": "I think this problem is seriously flawed as I see the expected cases for the following:\\n0: false\\n1: true\\n2: true\\n3: true\\n5: true\\n7: false"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@Kedarterkhedkar](/Kedarterkhedkar). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@Kedarterkhedkar](/Kedarterkhedkar)  The prime factors of 8 is 2x2x2x2\\nNow look for the definition of ugly numbers\\n"
                    },
                    {
                        "username": "Kedarterkhedkar",
                        "content": "[@RohitSgh](/RohitSgh) Can you explain why 8 is ugly number ?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $0$ simply does not satisfy the first condition. Hence, `False` for $0$ is justified.\\n\\nAll other integers satisfy the first condition. For second condition, let\\'s list down their set of prime factors.\\n- For $1$, the set of prime factors is $\\\\{\\\\}$. And empty set is subset of every set. Thus `True` for $1$ is justified.\\n- For $2$, the set of prime factors is $\\\\{2\\\\}$. And $\\\\{2\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $2$ is justified.\\n- For $3$, the set of prime factors is $\\\\{3\\\\}$. And $\\\\{3\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $3$ is justified.\\n- For $5$, the set of prime factors is $\\\\{5\\\\}$. And $\\\\{5\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $5$ is justified.\\n- For $7$, the set of prime factors is $\\\\{7\\\\}$. And $\\\\{7\\\\}$ is not subset of $\\\\{2, 3, 5\\\\}$. Thus `False` for $7$ is justified."
                    },
                    {
                        "username": "d1mnewz",
                        "content": "Can somebody explain why in this case 1 is treated as ugly number? \\nBy definition\\n> Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.\\n\\nSo I can\\'t understand why 1 is an ugly number because it doesn\\'t have any of those prime factors."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nIn other words, without using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    }
                ]
            },
            {
                "id": 1688681,
                "content": [
                    {
                        "username": "ItzAryanTiwari",
                        "content": "Guys plz Improve the Description of the problem.\\nIf Agreed upvote."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Another rephrase of the definition if this sounds clearer:\n\nAn ugly number is a positive integer which does **not** have a prime factor **other than** 2, 3, and 5."
                    },
                    {
                        "username": "piyu5hkumar",
                        "content": "1 has neither 2 or 3 or 5  or their combination as factor, still its ugly, why so?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "not prime"
                    },
                    {
                        "username": "dyzo",
                        "content": "[@Sakshamji](/Sakshamji) You are right!"
                    },
                    {
                        "username": "Sakshamji",
                        "content": "We can interpret as it ugly number can be written as (2^a)*(3^b)*(5^c)\\nand since 1 = (2^0)*(3^0)*(5^0) thus 1 is ugly number ."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Bhushan_Waingankar",
                        "content": "Make sure to add these as your edge cases\\nif(n <= 0) return false;\\nif(n == 1) return true;"
                    },
                    {
                        "username": "orthogonal1",
                        "content": "n==1 is not necessarily an edge case."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "problem description phrasing could be better"
                    },
                    {
                        "username": "eduard92",
                        "content": "You sound like a canadian..."
                    },
                    {
                        "username": "mpack",
                        "content": "When num is 1, I was thinking it should be false... Can anybody explain this test case for me? Thanks in advance."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Sakshamji",
                        "content": "Every number N can be written as product of prime numbers as\n N = (A^a)(B^b)(C^c)....\nwhere A,B,C.. represent prime numers\ne.g 135 = (3^3)*(5^1) where 3 and 5 are prime numbers\n\nNow in this question they have asked for numbers that have 2,3,5 as A,B,C or prime numbers,\nthat means those numbers that can be represented as -\nUgly number (U) = (2^a)(3^b)(5^c)\nwhere a,b,c are positive numbers\nAs you can see 1 also satisfy above equation as\n1 = (2^0)(3^0)(5^0)\nthus it is also a ugly number\nI hope this insight will help you in solving this question."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Nice Tip, but following statement is incorrect.\\n> where a,b,c are positive numbers\\n\\nThey are whole numbers (or non-negative integers) to be precise."
                    },
                    {
                        "username": "quantupus",
                        "content": "code was going great until I realized negative numbers were a thing lol"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Someone else in the comments pointed out that an ugly number must be a POSITIVE integer. You can easily put a condition to return false if n<0."
                    },
                    {
                        "username": "vinayaktalukder17",
                        "content": "Same here. Just 500 test cases passed out of a 1013 test cases"
                    },
                    {
                        "username": "frankfaustino",
                        "content": "I\\'ve gotten into the habit of reading the constraints because I hate when this happens \\uD83D\\uDE00"
                    },
                    {
                        "username": "helenfanzhang",
                        "content": "I think this problem is seriously flawed as I see the expected cases for the following:\\n0: false\\n1: true\\n2: true\\n3: true\\n5: true\\n7: false"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@Kedarterkhedkar](/Kedarterkhedkar). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@Kedarterkhedkar](/Kedarterkhedkar)  The prime factors of 8 is 2x2x2x2\\nNow look for the definition of ugly numbers\\n"
                    },
                    {
                        "username": "Kedarterkhedkar",
                        "content": "[@RohitSgh](/RohitSgh) Can you explain why 8 is ugly number ?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $0$ simply does not satisfy the first condition. Hence, `False` for $0$ is justified.\\n\\nAll other integers satisfy the first condition. For second condition, let\\'s list down their set of prime factors.\\n- For $1$, the set of prime factors is $\\\\{\\\\}$. And empty set is subset of every set. Thus `True` for $1$ is justified.\\n- For $2$, the set of prime factors is $\\\\{2\\\\}$. And $\\\\{2\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $2$ is justified.\\n- For $3$, the set of prime factors is $\\\\{3\\\\}$. And $\\\\{3\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $3$ is justified.\\n- For $5$, the set of prime factors is $\\\\{5\\\\}$. And $\\\\{5\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $5$ is justified.\\n- For $7$, the set of prime factors is $\\\\{7\\\\}$. And $\\\\{7\\\\}$ is not subset of $\\\\{2, 3, 5\\\\}$. Thus `False` for $7$ is justified."
                    },
                    {
                        "username": "d1mnewz",
                        "content": "Can somebody explain why in this case 1 is treated as ugly number? \\nBy definition\\n> Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.\\n\\nSo I can\\'t understand why 1 is an ugly number because it doesn\\'t have any of those prime factors."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nIn other words, without using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    }
                ]
            },
            {
                "id": 1568030,
                "content": [
                    {
                        "username": "ItzAryanTiwari",
                        "content": "Guys plz Improve the Description of the problem.\\nIf Agreed upvote."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Another rephrase of the definition if this sounds clearer:\n\nAn ugly number is a positive integer which does **not** have a prime factor **other than** 2, 3, and 5."
                    },
                    {
                        "username": "piyu5hkumar",
                        "content": "1 has neither 2 or 3 or 5  or their combination as factor, still its ugly, why so?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "not prime"
                    },
                    {
                        "username": "dyzo",
                        "content": "[@Sakshamji](/Sakshamji) You are right!"
                    },
                    {
                        "username": "Sakshamji",
                        "content": "We can interpret as it ugly number can be written as (2^a)*(3^b)*(5^c)\\nand since 1 = (2^0)*(3^0)*(5^0) thus 1 is ugly number ."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Bhushan_Waingankar",
                        "content": "Make sure to add these as your edge cases\\nif(n <= 0) return false;\\nif(n == 1) return true;"
                    },
                    {
                        "username": "orthogonal1",
                        "content": "n==1 is not necessarily an edge case."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "problem description phrasing could be better"
                    },
                    {
                        "username": "eduard92",
                        "content": "You sound like a canadian..."
                    },
                    {
                        "username": "mpack",
                        "content": "When num is 1, I was thinking it should be false... Can anybody explain this test case for me? Thanks in advance."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Sakshamji",
                        "content": "Every number N can be written as product of prime numbers as\n N = (A^a)(B^b)(C^c)....\nwhere A,B,C.. represent prime numers\ne.g 135 = (3^3)*(5^1) where 3 and 5 are prime numbers\n\nNow in this question they have asked for numbers that have 2,3,5 as A,B,C or prime numbers,\nthat means those numbers that can be represented as -\nUgly number (U) = (2^a)(3^b)(5^c)\nwhere a,b,c are positive numbers\nAs you can see 1 also satisfy above equation as\n1 = (2^0)(3^0)(5^0)\nthus it is also a ugly number\nI hope this insight will help you in solving this question."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Nice Tip, but following statement is incorrect.\\n> where a,b,c are positive numbers\\n\\nThey are whole numbers (or non-negative integers) to be precise."
                    },
                    {
                        "username": "quantupus",
                        "content": "code was going great until I realized negative numbers were a thing lol"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Someone else in the comments pointed out that an ugly number must be a POSITIVE integer. You can easily put a condition to return false if n<0."
                    },
                    {
                        "username": "vinayaktalukder17",
                        "content": "Same here. Just 500 test cases passed out of a 1013 test cases"
                    },
                    {
                        "username": "frankfaustino",
                        "content": "I\\'ve gotten into the habit of reading the constraints because I hate when this happens \\uD83D\\uDE00"
                    },
                    {
                        "username": "helenfanzhang",
                        "content": "I think this problem is seriously flawed as I see the expected cases for the following:\\n0: false\\n1: true\\n2: true\\n3: true\\n5: true\\n7: false"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@Kedarterkhedkar](/Kedarterkhedkar). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@Kedarterkhedkar](/Kedarterkhedkar)  The prime factors of 8 is 2x2x2x2\\nNow look for the definition of ugly numbers\\n"
                    },
                    {
                        "username": "Kedarterkhedkar",
                        "content": "[@RohitSgh](/RohitSgh) Can you explain why 8 is ugly number ?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $0$ simply does not satisfy the first condition. Hence, `False` for $0$ is justified.\\n\\nAll other integers satisfy the first condition. For second condition, let\\'s list down their set of prime factors.\\n- For $1$, the set of prime factors is $\\\\{\\\\}$. And empty set is subset of every set. Thus `True` for $1$ is justified.\\n- For $2$, the set of prime factors is $\\\\{2\\\\}$. And $\\\\{2\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $2$ is justified.\\n- For $3$, the set of prime factors is $\\\\{3\\\\}$. And $\\\\{3\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $3$ is justified.\\n- For $5$, the set of prime factors is $\\\\{5\\\\}$. And $\\\\{5\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $5$ is justified.\\n- For $7$, the set of prime factors is $\\\\{7\\\\}$. And $\\\\{7\\\\}$ is not subset of $\\\\{2, 3, 5\\\\}$. Thus `False` for $7$ is justified."
                    },
                    {
                        "username": "d1mnewz",
                        "content": "Can somebody explain why in this case 1 is treated as ugly number? \\nBy definition\\n> Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.\\n\\nSo I can\\'t understand why 1 is an ugly number because it doesn\\'t have any of those prime factors."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nIn other words, without using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    }
                ]
            },
            {
                "id": 1572705,
                "content": [
                    {
                        "username": "ItzAryanTiwari",
                        "content": "Guys plz Improve the Description of the problem.\\nIf Agreed upvote."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Another rephrase of the definition if this sounds clearer:\n\nAn ugly number is a positive integer which does **not** have a prime factor **other than** 2, 3, and 5."
                    },
                    {
                        "username": "piyu5hkumar",
                        "content": "1 has neither 2 or 3 or 5  or their combination as factor, still its ugly, why so?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "not prime"
                    },
                    {
                        "username": "dyzo",
                        "content": "[@Sakshamji](/Sakshamji) You are right!"
                    },
                    {
                        "username": "Sakshamji",
                        "content": "We can interpret as it ugly number can be written as (2^a)*(3^b)*(5^c)\\nand since 1 = (2^0)*(3^0)*(5^0) thus 1 is ugly number ."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Bhushan_Waingankar",
                        "content": "Make sure to add these as your edge cases\\nif(n <= 0) return false;\\nif(n == 1) return true;"
                    },
                    {
                        "username": "orthogonal1",
                        "content": "n==1 is not necessarily an edge case."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "problem description phrasing could be better"
                    },
                    {
                        "username": "eduard92",
                        "content": "You sound like a canadian..."
                    },
                    {
                        "username": "mpack",
                        "content": "When num is 1, I was thinking it should be false... Can anybody explain this test case for me? Thanks in advance."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nWithout using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    },
                    {
                        "username": "Sakshamji",
                        "content": "Every number N can be written as product of prime numbers as\n N = (A^a)(B^b)(C^c)....\nwhere A,B,C.. represent prime numers\ne.g 135 = (3^3)*(5^1) where 3 and 5 are prime numbers\n\nNow in this question they have asked for numbers that have 2,3,5 as A,B,C or prime numbers,\nthat means those numbers that can be represented as -\nUgly number (U) = (2^a)(3^b)(5^c)\nwhere a,b,c are positive numbers\nAs you can see 1 also satisfy above equation as\n1 = (2^0)(3^0)(5^0)\nthus it is also a ugly number\nI hope this insight will help you in solving this question."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Nice Tip, but following statement is incorrect.\\n> where a,b,c are positive numbers\\n\\nThey are whole numbers (or non-negative integers) to be precise."
                    },
                    {
                        "username": "quantupus",
                        "content": "code was going great until I realized negative numbers were a thing lol"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Someone else in the comments pointed out that an ugly number must be a POSITIVE integer. You can easily put a condition to return false if n<0."
                    },
                    {
                        "username": "vinayaktalukder17",
                        "content": "Same here. Just 500 test cases passed out of a 1013 test cases"
                    },
                    {
                        "username": "frankfaustino",
                        "content": "I\\'ve gotten into the habit of reading the constraints because I hate when this happens \\uD83D\\uDE00"
                    },
                    {
                        "username": "helenfanzhang",
                        "content": "I think this problem is seriously flawed as I see the expected cases for the following:\\n0: false\\n1: true\\n2: true\\n3: true\\n5: true\\n7: false"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@Kedarterkhedkar](/Kedarterkhedkar). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@Kedarterkhedkar](/Kedarterkhedkar)  The prime factors of 8 is 2x2x2x2\\nNow look for the definition of ugly numbers\\n"
                    },
                    {
                        "username": "Kedarterkhedkar",
                        "content": "[@RohitSgh](/RohitSgh) Can you explain why 8 is ugly number ?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $0$ simply does not satisfy the first condition. Hence, `False` for $0$ is justified.\\n\\nAll other integers satisfy the first condition. For second condition, let\\'s list down their set of prime factors.\\n- For $1$, the set of prime factors is $\\\\{\\\\}$. And empty set is subset of every set. Thus `True` for $1$ is justified.\\n- For $2$, the set of prime factors is $\\\\{2\\\\}$. And $\\\\{2\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $2$ is justified.\\n- For $3$, the set of prime factors is $\\\\{3\\\\}$. And $\\\\{3\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $3$ is justified.\\n- For $5$, the set of prime factors is $\\\\{5\\\\}$. And $\\\\{5\\\\}$ is subset of $\\\\{2, 3, 5\\\\}$. Thus `True` for $5$ is justified.\\n- For $7$, the set of prime factors is $\\\\{7\\\\}$. And $\\\\{7\\\\}$ is not subset of $\\\\{2, 3, 5\\\\}$. Thus `False` for $7$ is justified."
                    },
                    {
                        "username": "d1mnewz",
                        "content": "Can somebody explain why in this case 1 is treated as ugly number? \\nBy definition\\n> Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.\\n\\nSo I can\\'t understand why 1 is an ugly number because it doesn\\'t have any of those prime factors."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition\\n> An ugly number is a positive integer whose prime factors are **limited** to 2, 3, and 5.\\n\\nThe definition can be broken down to two conditions:\\n- The number should be positive ($> 0$)\\n- The set of prime factors of number should be subset of $\\\\{2, 3, 5\\\\}$\\n\\nNow, $1$ satisfies both the conditions\\n- $1 > 0$\\n- The set of prime factors of $1$ is empty set $\\\\{\\\\}$. And empty set is subset of every set. Please note that $1$ has only one factor $1$, but has no prime factor since $1$ is not a prime number.\\n\\nIn other words, without using set notation, the definition states that factors should be **limited** to $2, 3, 5$. This does not mean that these factors are necessary. However, any other factor than these number simply disqualifies the number from being an ugly number."
                    }
                ]
            },
            {
                "id": 1572689,
                "content": [
                    {
                        "username": "nagarajanpriyadarshan",
                        "content": "My code passed majority of the testcases and fails in -1000, i.e. for -1000 my code results with \"true\" and leetcode expected results as \"False\". Can anyone let me know in detail why -1000 is not treated as Ugly number while 1000 is treated ugly number?"
                    },
                    {
                        "username": "Isshh",
                        "content": "Because It is mentioned in the question that ugly number is a positive number"
                    },
                    {
                        "username": "Sp_ndan111",
                        "content": "how are the numbers like 2 or 6 ugly,look at those curves, they have such a nice figure"
                    },
                    {
                        "username": "rajeshgurgoan",
                        "content": "How is 8 an ugly number ? its  co-factor are [2, 4]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@rajeshgurgoan](/rajeshgurgoan). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "SadHing",
                        "content": "class Solution {\\n    public boolean isUgly(int n) {\\n        return n == me; //\\uD83D\\uDE14\\n    }\\n}"
                    },
                    {
                        "username": "imliuye",
                        "content": "And why? this feels so stupid"
                    },
                    {
                        "username": "harshal1412",
                        "content": "simple way to find ugly number is\\nbool isugly(int n)\\n{while(n>1)\\n{if(n%2==0)\\nn=n/2;\\nelse if(n%3==0)\\nn=n/3;\\nelse if(n%5==0)\\nn=n/5;\\nelse \\nbreak;\\n}\\nreturn n==1;\\n}\\n"
                    },
                    {
                        "username": "alanparmenter",
                        "content": "Who put -2147483648 in the test cases as NOT an ugly number!?"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "        if (n <= 0)// no negative number is allowed\\n            return false;\\n        if (n <= 6)// from 1 to 6 ans will be true\\n            return true;\\n\\n        while (n > 1) {\\n            if (n % 2 == 0) {\\n                n /= 2;\\n            } else if (n % 3 == 0) {\\n                n /= 3;\\n            } else if (n % 5 == 0) {\\n                n /= 5;\\n            } else {\\n                return false;// if not a multiple of either of 2 \\n                            // or 3 or 5 return false because it not ugly"
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "(!!!) In case n = 0, it recursively divides by 2 3 and 5.\\nConsider it in your null case"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "But $0$ isn\\'t Positive Integer. Therefore, `False` for $0$ is justified."
                    },
                    {
                        "username": "Zaydiscool777",
                        "content": " `class Solution:\\n    def isUgly(self, n: int) -> bool:\\n        t = n\\n        for i in [2,3,5]:\\n            while t%i==0:\\n                t/=i\\n        return t==1`\\nwhy is time limit exceeded"
                    },
                    {
                        "username": "manishya1669",
                        "content": "It is because you are checking any condition for `0` ."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Divisions like 0 / 3 = 0 leading to forever loops."
                    }
                ]
            },
            {
                "id": 1688394,
                "content": [
                    {
                        "username": "nagarajanpriyadarshan",
                        "content": "My code passed majority of the testcases and fails in -1000, i.e. for -1000 my code results with \"true\" and leetcode expected results as \"False\". Can anyone let me know in detail why -1000 is not treated as Ugly number while 1000 is treated ugly number?"
                    },
                    {
                        "username": "Isshh",
                        "content": "Because It is mentioned in the question that ugly number is a positive number"
                    },
                    {
                        "username": "Sp_ndan111",
                        "content": "how are the numbers like 2 or 6 ugly,look at those curves, they have such a nice figure"
                    },
                    {
                        "username": "rajeshgurgoan",
                        "content": "How is 8 an ugly number ? its  co-factor are [2, 4]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@rajeshgurgoan](/rajeshgurgoan). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "SadHing",
                        "content": "class Solution {\\n    public boolean isUgly(int n) {\\n        return n == me; //\\uD83D\\uDE14\\n    }\\n}"
                    },
                    {
                        "username": "imliuye",
                        "content": "And why? this feels so stupid"
                    },
                    {
                        "username": "harshal1412",
                        "content": "simple way to find ugly number is\\nbool isugly(int n)\\n{while(n>1)\\n{if(n%2==0)\\nn=n/2;\\nelse if(n%3==0)\\nn=n/3;\\nelse if(n%5==0)\\nn=n/5;\\nelse \\nbreak;\\n}\\nreturn n==1;\\n}\\n"
                    },
                    {
                        "username": "alanparmenter",
                        "content": "Who put -2147483648 in the test cases as NOT an ugly number!?"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "        if (n <= 0)// no negative number is allowed\\n            return false;\\n        if (n <= 6)// from 1 to 6 ans will be true\\n            return true;\\n\\n        while (n > 1) {\\n            if (n % 2 == 0) {\\n                n /= 2;\\n            } else if (n % 3 == 0) {\\n                n /= 3;\\n            } else if (n % 5 == 0) {\\n                n /= 5;\\n            } else {\\n                return false;// if not a multiple of either of 2 \\n                            // or 3 or 5 return false because it not ugly"
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "(!!!) In case n = 0, it recursively divides by 2 3 and 5.\\nConsider it in your null case"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "But $0$ isn\\'t Positive Integer. Therefore, `False` for $0$ is justified."
                    },
                    {
                        "username": "Zaydiscool777",
                        "content": " `class Solution:\\n    def isUgly(self, n: int) -> bool:\\n        t = n\\n        for i in [2,3,5]:\\n            while t%i==0:\\n                t/=i\\n        return t==1`\\nwhy is time limit exceeded"
                    },
                    {
                        "username": "manishya1669",
                        "content": "It is because you are checking any condition for `0` ."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Divisions like 0 / 3 = 0 leading to forever loops."
                    }
                ]
            },
            {
                "id": 1903082,
                "content": [
                    {
                        "username": "nagarajanpriyadarshan",
                        "content": "My code passed majority of the testcases and fails in -1000, i.e. for -1000 my code results with \"true\" and leetcode expected results as \"False\". Can anyone let me know in detail why -1000 is not treated as Ugly number while 1000 is treated ugly number?"
                    },
                    {
                        "username": "Isshh",
                        "content": "Because It is mentioned in the question that ugly number is a positive number"
                    },
                    {
                        "username": "Sp_ndan111",
                        "content": "how are the numbers like 2 or 6 ugly,look at those curves, they have such a nice figure"
                    },
                    {
                        "username": "rajeshgurgoan",
                        "content": "How is 8 an ugly number ? its  co-factor are [2, 4]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@rajeshgurgoan](/rajeshgurgoan). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "SadHing",
                        "content": "class Solution {\\n    public boolean isUgly(int n) {\\n        return n == me; //\\uD83D\\uDE14\\n    }\\n}"
                    },
                    {
                        "username": "imliuye",
                        "content": "And why? this feels so stupid"
                    },
                    {
                        "username": "harshal1412",
                        "content": "simple way to find ugly number is\\nbool isugly(int n)\\n{while(n>1)\\n{if(n%2==0)\\nn=n/2;\\nelse if(n%3==0)\\nn=n/3;\\nelse if(n%5==0)\\nn=n/5;\\nelse \\nbreak;\\n}\\nreturn n==1;\\n}\\n"
                    },
                    {
                        "username": "alanparmenter",
                        "content": "Who put -2147483648 in the test cases as NOT an ugly number!?"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "        if (n <= 0)// no negative number is allowed\\n            return false;\\n        if (n <= 6)// from 1 to 6 ans will be true\\n            return true;\\n\\n        while (n > 1) {\\n            if (n % 2 == 0) {\\n                n /= 2;\\n            } else if (n % 3 == 0) {\\n                n /= 3;\\n            } else if (n % 5 == 0) {\\n                n /= 5;\\n            } else {\\n                return false;// if not a multiple of either of 2 \\n                            // or 3 or 5 return false because it not ugly"
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "(!!!) In case n = 0, it recursively divides by 2 3 and 5.\\nConsider it in your null case"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "But $0$ isn\\'t Positive Integer. Therefore, `False` for $0$ is justified."
                    },
                    {
                        "username": "Zaydiscool777",
                        "content": " `class Solution:\\n    def isUgly(self, n: int) -> bool:\\n        t = n\\n        for i in [2,3,5]:\\n            while t%i==0:\\n                t/=i\\n        return t==1`\\nwhy is time limit exceeded"
                    },
                    {
                        "username": "manishya1669",
                        "content": "It is because you are checking any condition for `0` ."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Divisions like 0 / 3 = 0 leading to forever loops."
                    }
                ]
            },
            {
                "id": 1761602,
                "content": [
                    {
                        "username": "nagarajanpriyadarshan",
                        "content": "My code passed majority of the testcases and fails in -1000, i.e. for -1000 my code results with \"true\" and leetcode expected results as \"False\". Can anyone let me know in detail why -1000 is not treated as Ugly number while 1000 is treated ugly number?"
                    },
                    {
                        "username": "Isshh",
                        "content": "Because It is mentioned in the question that ugly number is a positive number"
                    },
                    {
                        "username": "Sp_ndan111",
                        "content": "how are the numbers like 2 or 6 ugly,look at those curves, they have such a nice figure"
                    },
                    {
                        "username": "rajeshgurgoan",
                        "content": "How is 8 an ugly number ? its  co-factor are [2, 4]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@rajeshgurgoan](/rajeshgurgoan). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "SadHing",
                        "content": "class Solution {\\n    public boolean isUgly(int n) {\\n        return n == me; //\\uD83D\\uDE14\\n    }\\n}"
                    },
                    {
                        "username": "imliuye",
                        "content": "And why? this feels so stupid"
                    },
                    {
                        "username": "harshal1412",
                        "content": "simple way to find ugly number is\\nbool isugly(int n)\\n{while(n>1)\\n{if(n%2==0)\\nn=n/2;\\nelse if(n%3==0)\\nn=n/3;\\nelse if(n%5==0)\\nn=n/5;\\nelse \\nbreak;\\n}\\nreturn n==1;\\n}\\n"
                    },
                    {
                        "username": "alanparmenter",
                        "content": "Who put -2147483648 in the test cases as NOT an ugly number!?"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "        if (n <= 0)// no negative number is allowed\\n            return false;\\n        if (n <= 6)// from 1 to 6 ans will be true\\n            return true;\\n\\n        while (n > 1) {\\n            if (n % 2 == 0) {\\n                n /= 2;\\n            } else if (n % 3 == 0) {\\n                n /= 3;\\n            } else if (n % 5 == 0) {\\n                n /= 5;\\n            } else {\\n                return false;// if not a multiple of either of 2 \\n                            // or 3 or 5 return false because it not ugly"
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "(!!!) In case n = 0, it recursively divides by 2 3 and 5.\\nConsider it in your null case"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "But $0$ isn\\'t Positive Integer. Therefore, `False` for $0$ is justified."
                    },
                    {
                        "username": "Zaydiscool777",
                        "content": " `class Solution:\\n    def isUgly(self, n: int) -> bool:\\n        t = n\\n        for i in [2,3,5]:\\n            while t%i==0:\\n                t/=i\\n        return t==1`\\nwhy is time limit exceeded"
                    },
                    {
                        "username": "manishya1669",
                        "content": "It is because you are checking any condition for `0` ."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Divisions like 0 / 3 = 0 leading to forever loops."
                    }
                ]
            },
            {
                "id": 1574700,
                "content": [
                    {
                        "username": "nagarajanpriyadarshan",
                        "content": "My code passed majority of the testcases and fails in -1000, i.e. for -1000 my code results with \"true\" and leetcode expected results as \"False\". Can anyone let me know in detail why -1000 is not treated as Ugly number while 1000 is treated ugly number?"
                    },
                    {
                        "username": "Isshh",
                        "content": "Because It is mentioned in the question that ugly number is a positive number"
                    },
                    {
                        "username": "Sp_ndan111",
                        "content": "how are the numbers like 2 or 6 ugly,look at those curves, they have such a nice figure"
                    },
                    {
                        "username": "rajeshgurgoan",
                        "content": "How is 8 an ugly number ? its  co-factor are [2, 4]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@rajeshgurgoan](/rajeshgurgoan). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "SadHing",
                        "content": "class Solution {\\n    public boolean isUgly(int n) {\\n        return n == me; //\\uD83D\\uDE14\\n    }\\n}"
                    },
                    {
                        "username": "imliuye",
                        "content": "And why? this feels so stupid"
                    },
                    {
                        "username": "harshal1412",
                        "content": "simple way to find ugly number is\\nbool isugly(int n)\\n{while(n>1)\\n{if(n%2==0)\\nn=n/2;\\nelse if(n%3==0)\\nn=n/3;\\nelse if(n%5==0)\\nn=n/5;\\nelse \\nbreak;\\n}\\nreturn n==1;\\n}\\n"
                    },
                    {
                        "username": "alanparmenter",
                        "content": "Who put -2147483648 in the test cases as NOT an ugly number!?"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "        if (n <= 0)// no negative number is allowed\\n            return false;\\n        if (n <= 6)// from 1 to 6 ans will be true\\n            return true;\\n\\n        while (n > 1) {\\n            if (n % 2 == 0) {\\n                n /= 2;\\n            } else if (n % 3 == 0) {\\n                n /= 3;\\n            } else if (n % 5 == 0) {\\n                n /= 5;\\n            } else {\\n                return false;// if not a multiple of either of 2 \\n                            // or 3 or 5 return false because it not ugly"
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "(!!!) In case n = 0, it recursively divides by 2 3 and 5.\\nConsider it in your null case"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "But $0$ isn\\'t Positive Integer. Therefore, `False` for $0$ is justified."
                    },
                    {
                        "username": "Zaydiscool777",
                        "content": " `class Solution:\\n    def isUgly(self, n: int) -> bool:\\n        t = n\\n        for i in [2,3,5]:\\n            while t%i==0:\\n                t/=i\\n        return t==1`\\nwhy is time limit exceeded"
                    },
                    {
                        "username": "manishya1669",
                        "content": "It is because you are checking any condition for `0` ."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Divisions like 0 / 3 = 0 leading to forever loops."
                    }
                ]
            },
            {
                "id": 1697723,
                "content": [
                    {
                        "username": "nagarajanpriyadarshan",
                        "content": "My code passed majority of the testcases and fails in -1000, i.e. for -1000 my code results with \"true\" and leetcode expected results as \"False\". Can anyone let me know in detail why -1000 is not treated as Ugly number while 1000 is treated ugly number?"
                    },
                    {
                        "username": "Isshh",
                        "content": "Because It is mentioned in the question that ugly number is a positive number"
                    },
                    {
                        "username": "Sp_ndan111",
                        "content": "how are the numbers like 2 or 6 ugly,look at those curves, they have such a nice figure"
                    },
                    {
                        "username": "rajeshgurgoan",
                        "content": "How is 8 an ugly number ? its  co-factor are [2, 4]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@rajeshgurgoan](/rajeshgurgoan). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "SadHing",
                        "content": "class Solution {\\n    public boolean isUgly(int n) {\\n        return n == me; //\\uD83D\\uDE14\\n    }\\n}"
                    },
                    {
                        "username": "imliuye",
                        "content": "And why? this feels so stupid"
                    },
                    {
                        "username": "harshal1412",
                        "content": "simple way to find ugly number is\\nbool isugly(int n)\\n{while(n>1)\\n{if(n%2==0)\\nn=n/2;\\nelse if(n%3==0)\\nn=n/3;\\nelse if(n%5==0)\\nn=n/5;\\nelse \\nbreak;\\n}\\nreturn n==1;\\n}\\n"
                    },
                    {
                        "username": "alanparmenter",
                        "content": "Who put -2147483648 in the test cases as NOT an ugly number!?"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "        if (n <= 0)// no negative number is allowed\\n            return false;\\n        if (n <= 6)// from 1 to 6 ans will be true\\n            return true;\\n\\n        while (n > 1) {\\n            if (n % 2 == 0) {\\n                n /= 2;\\n            } else if (n % 3 == 0) {\\n                n /= 3;\\n            } else if (n % 5 == 0) {\\n                n /= 5;\\n            } else {\\n                return false;// if not a multiple of either of 2 \\n                            // or 3 or 5 return false because it not ugly"
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "(!!!) In case n = 0, it recursively divides by 2 3 and 5.\\nConsider it in your null case"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "But $0$ isn\\'t Positive Integer. Therefore, `False` for $0$ is justified."
                    },
                    {
                        "username": "Zaydiscool777",
                        "content": " `class Solution:\\n    def isUgly(self, n: int) -> bool:\\n        t = n\\n        for i in [2,3,5]:\\n            while t%i==0:\\n                t/=i\\n        return t==1`\\nwhy is time limit exceeded"
                    },
                    {
                        "username": "manishya1669",
                        "content": "It is because you are checking any condition for `0` ."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Divisions like 0 / 3 = 0 leading to forever loops."
                    }
                ]
            },
            {
                "id": 2028359,
                "content": [
                    {
                        "username": "nagarajanpriyadarshan",
                        "content": "My code passed majority of the testcases and fails in -1000, i.e. for -1000 my code results with \"true\" and leetcode expected results as \"False\". Can anyone let me know in detail why -1000 is not treated as Ugly number while 1000 is treated ugly number?"
                    },
                    {
                        "username": "Isshh",
                        "content": "Because It is mentioned in the question that ugly number is a positive number"
                    },
                    {
                        "username": "Sp_ndan111",
                        "content": "how are the numbers like 2 or 6 ugly,look at those curves, they have such a nice figure"
                    },
                    {
                        "username": "rajeshgurgoan",
                        "content": "How is 8 an ugly number ? its  co-factor are [2, 4]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@rajeshgurgoan](/rajeshgurgoan). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "SadHing",
                        "content": "class Solution {\\n    public boolean isUgly(int n) {\\n        return n == me; //\\uD83D\\uDE14\\n    }\\n}"
                    },
                    {
                        "username": "imliuye",
                        "content": "And why? this feels so stupid"
                    },
                    {
                        "username": "harshal1412",
                        "content": "simple way to find ugly number is\\nbool isugly(int n)\\n{while(n>1)\\n{if(n%2==0)\\nn=n/2;\\nelse if(n%3==0)\\nn=n/3;\\nelse if(n%5==0)\\nn=n/5;\\nelse \\nbreak;\\n}\\nreturn n==1;\\n}\\n"
                    },
                    {
                        "username": "alanparmenter",
                        "content": "Who put -2147483648 in the test cases as NOT an ugly number!?"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "        if (n <= 0)// no negative number is allowed\\n            return false;\\n        if (n <= 6)// from 1 to 6 ans will be true\\n            return true;\\n\\n        while (n > 1) {\\n            if (n % 2 == 0) {\\n                n /= 2;\\n            } else if (n % 3 == 0) {\\n                n /= 3;\\n            } else if (n % 5 == 0) {\\n                n /= 5;\\n            } else {\\n                return false;// if not a multiple of either of 2 \\n                            // or 3 or 5 return false because it not ugly"
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "(!!!) In case n = 0, it recursively divides by 2 3 and 5.\\nConsider it in your null case"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "But $0$ isn\\'t Positive Integer. Therefore, `False` for $0$ is justified."
                    },
                    {
                        "username": "Zaydiscool777",
                        "content": " `class Solution:\\n    def isUgly(self, n: int) -> bool:\\n        t = n\\n        for i in [2,3,5]:\\n            while t%i==0:\\n                t/=i\\n        return t==1`\\nwhy is time limit exceeded"
                    },
                    {
                        "username": "manishya1669",
                        "content": "It is because you are checking any condition for `0` ."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Divisions like 0 / 3 = 0 leading to forever loops."
                    }
                ]
            },
            {
                "id": 1964628,
                "content": [
                    {
                        "username": "nagarajanpriyadarshan",
                        "content": "My code passed majority of the testcases and fails in -1000, i.e. for -1000 my code results with \"true\" and leetcode expected results as \"False\". Can anyone let me know in detail why -1000 is not treated as Ugly number while 1000 is treated ugly number?"
                    },
                    {
                        "username": "Isshh",
                        "content": "Because It is mentioned in the question that ugly number is a positive number"
                    },
                    {
                        "username": "Sp_ndan111",
                        "content": "how are the numbers like 2 or 6 ugly,look at those curves, they have such a nice figure"
                    },
                    {
                        "username": "rajeshgurgoan",
                        "content": "How is 8 an ugly number ? its  co-factor are [2, 4]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@rajeshgurgoan](/rajeshgurgoan). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "SadHing",
                        "content": "class Solution {\\n    public boolean isUgly(int n) {\\n        return n == me; //\\uD83D\\uDE14\\n    }\\n}"
                    },
                    {
                        "username": "imliuye",
                        "content": "And why? this feels so stupid"
                    },
                    {
                        "username": "harshal1412",
                        "content": "simple way to find ugly number is\\nbool isugly(int n)\\n{while(n>1)\\n{if(n%2==0)\\nn=n/2;\\nelse if(n%3==0)\\nn=n/3;\\nelse if(n%5==0)\\nn=n/5;\\nelse \\nbreak;\\n}\\nreturn n==1;\\n}\\n"
                    },
                    {
                        "username": "alanparmenter",
                        "content": "Who put -2147483648 in the test cases as NOT an ugly number!?"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "        if (n <= 0)// no negative number is allowed\\n            return false;\\n        if (n <= 6)// from 1 to 6 ans will be true\\n            return true;\\n\\n        while (n > 1) {\\n            if (n % 2 == 0) {\\n                n /= 2;\\n            } else if (n % 3 == 0) {\\n                n /= 3;\\n            } else if (n % 5 == 0) {\\n                n /= 5;\\n            } else {\\n                return false;// if not a multiple of either of 2 \\n                            // or 3 or 5 return false because it not ugly"
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "(!!!) In case n = 0, it recursively divides by 2 3 and 5.\\nConsider it in your null case"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "But $0$ isn\\'t Positive Integer. Therefore, `False` for $0$ is justified."
                    },
                    {
                        "username": "Zaydiscool777",
                        "content": " `class Solution:\\n    def isUgly(self, n: int) -> bool:\\n        t = n\\n        for i in [2,3,5]:\\n            while t%i==0:\\n                t/=i\\n        return t==1`\\nwhy is time limit exceeded"
                    },
                    {
                        "username": "manishya1669",
                        "content": "It is because you are checking any condition for `0` ."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Divisions like 0 / 3 = 0 leading to forever loops."
                    }
                ]
            },
            {
                "id": 1687919,
                "content": [
                    {
                        "username": "nagarajanpriyadarshan",
                        "content": "My code passed majority of the testcases and fails in -1000, i.e. for -1000 my code results with \"true\" and leetcode expected results as \"False\". Can anyone let me know in detail why -1000 is not treated as Ugly number while 1000 is treated ugly number?"
                    },
                    {
                        "username": "Isshh",
                        "content": "Because It is mentioned in the question that ugly number is a positive number"
                    },
                    {
                        "username": "Sp_ndan111",
                        "content": "how are the numbers like 2 or 6 ugly,look at those curves, they have such a nice figure"
                    },
                    {
                        "username": "rajeshgurgoan",
                        "content": "How is 8 an ugly number ? its  co-factor are [2, 4]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@rajeshgurgoan](/rajeshgurgoan). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "SadHing",
                        "content": "class Solution {\\n    public boolean isUgly(int n) {\\n        return n == me; //\\uD83D\\uDE14\\n    }\\n}"
                    },
                    {
                        "username": "imliuye",
                        "content": "And why? this feels so stupid"
                    },
                    {
                        "username": "harshal1412",
                        "content": "simple way to find ugly number is\\nbool isugly(int n)\\n{while(n>1)\\n{if(n%2==0)\\nn=n/2;\\nelse if(n%3==0)\\nn=n/3;\\nelse if(n%5==0)\\nn=n/5;\\nelse \\nbreak;\\n}\\nreturn n==1;\\n}\\n"
                    },
                    {
                        "username": "alanparmenter",
                        "content": "Who put -2147483648 in the test cases as NOT an ugly number!?"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "        if (n <= 0)// no negative number is allowed\\n            return false;\\n        if (n <= 6)// from 1 to 6 ans will be true\\n            return true;\\n\\n        while (n > 1) {\\n            if (n % 2 == 0) {\\n                n /= 2;\\n            } else if (n % 3 == 0) {\\n                n /= 3;\\n            } else if (n % 5 == 0) {\\n                n /= 5;\\n            } else {\\n                return false;// if not a multiple of either of 2 \\n                            // or 3 or 5 return false because it not ugly"
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "(!!!) In case n = 0, it recursively divides by 2 3 and 5.\\nConsider it in your null case"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "But $0$ isn\\'t Positive Integer. Therefore, `False` for $0$ is justified."
                    },
                    {
                        "username": "Zaydiscool777",
                        "content": " `class Solution:\\n    def isUgly(self, n: int) -> bool:\\n        t = n\\n        for i in [2,3,5]:\\n            while t%i==0:\\n                t/=i\\n        return t==1`\\nwhy is time limit exceeded"
                    },
                    {
                        "username": "manishya1669",
                        "content": "It is because you are checking any condition for `0` ."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Divisions like 0 / 3 = 0 leading to forever loops."
                    }
                ]
            },
            {
                "id": 1687859,
                "content": [
                    {
                        "username": "nagarajanpriyadarshan",
                        "content": "My code passed majority of the testcases and fails in -1000, i.e. for -1000 my code results with \"true\" and leetcode expected results as \"False\". Can anyone let me know in detail why -1000 is not treated as Ugly number while 1000 is treated ugly number?"
                    },
                    {
                        "username": "Isshh",
                        "content": "Because It is mentioned in the question that ugly number is a positive number"
                    },
                    {
                        "username": "Sp_ndan111",
                        "content": "how are the numbers like 2 or 6 ugly,look at those curves, they have such a nice figure"
                    },
                    {
                        "username": "rajeshgurgoan",
                        "content": "How is 8 an ugly number ? its  co-factor are [2, 4]"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer $8$ can be factorized as $2 \\\\times 2 \\\\times 2$, [@rajeshgurgoan](/rajeshgurgoan). And $\\\\{2\\\\}$ is subset of $\\\\{2,3,5\\\\}$. Hence, $8$ is Ugly"
                    },
                    {
                        "username": "SadHing",
                        "content": "class Solution {\\n    public boolean isUgly(int n) {\\n        return n == me; //\\uD83D\\uDE14\\n    }\\n}"
                    },
                    {
                        "username": "imliuye",
                        "content": "And why? this feels so stupid"
                    },
                    {
                        "username": "harshal1412",
                        "content": "simple way to find ugly number is\\nbool isugly(int n)\\n{while(n>1)\\n{if(n%2==0)\\nn=n/2;\\nelse if(n%3==0)\\nn=n/3;\\nelse if(n%5==0)\\nn=n/5;\\nelse \\nbreak;\\n}\\nreturn n==1;\\n}\\n"
                    },
                    {
                        "username": "alanparmenter",
                        "content": "Who put -2147483648 in the test cases as NOT an ugly number!?"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "        if (n <= 0)// no negative number is allowed\\n            return false;\\n        if (n <= 6)// from 1 to 6 ans will be true\\n            return true;\\n\\n        while (n > 1) {\\n            if (n % 2 == 0) {\\n                n /= 2;\\n            } else if (n % 3 == 0) {\\n                n /= 3;\\n            } else if (n % 5 == 0) {\\n                n /= 5;\\n            } else {\\n                return false;// if not a multiple of either of 2 \\n                            // or 3 or 5 return false because it not ugly"
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "(!!!) In case n = 0, it recursively divides by 2 3 and 5.\\nConsider it in your null case"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "But $0$ isn\\'t Positive Integer. Therefore, `False` for $0$ is justified."
                    },
                    {
                        "username": "Zaydiscool777",
                        "content": " `class Solution:\\n    def isUgly(self, n: int) -> bool:\\n        t = n\\n        for i in [2,3,5]:\\n            while t%i==0:\\n                t/=i\\n        return t==1`\\nwhy is time limit exceeded"
                    },
                    {
                        "username": "manishya1669",
                        "content": "It is because you are checking any condition for `0` ."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Divisions like 0 / 3 = 0 leading to forever loops."
                    }
                ]
            },
            {
                "id": 2069959,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "bruh, I was able to solve this, but ain\\'t no way this is easy, especially with this atrocious description"
                    },
                    {
                        "username": "PRANAB_DAS1",
                        "content": "It seems people some dont understand one simple term \"Not to post solution in discussion section\""
                    },
                    {
                        "username": "alanparmenter",
                        "content": "I don\\'t know, maybe darkhorse007d thought it was OK to ask for advice about their solution which was not working, and they got some help debugging from RohitSgh, but in principle the \\'don\\'t post any solutions\\' rule does seem pretty important for the discussions page"
                    },
                    {
                        "username": "abanand132",
                        "content": "While Sieve of Eratosthenes, I don\\'t why but for n= 64, it is not working. It gives error heap overflow in c++. But it is working well in my local ide."
                    },
                    {
                        "username": "Yusuf_Bogatyrev",
                        "content": "Very bad problem condition! Confusing and not clear."
                    },
                    {
                        "username": "darkhorse007d",
                        "content": "class Solution {\\npublic:\\n    bool sohel(int n)\\n    {\\n        return n == 2 or n == 3 or n == 5 or n == 1;\\n    }\\n    bool isUgly(int n) {\\n       // cout << INT_MIN << endl;\\n       n = (long long)n;\\n       vector<bool>prime(n+1 , true);\\n       long long i , j;\\n       for(i = 2 ; i*i <= n ; i++)\\n       {\\n           if(prime[i])\\n           {\\n               for(j = i*i ; j <= n ; j+=i)\\n               prime[j] = false;\\n           }\\n       }\\n        for(i = 2 ; i*i <= n ; i++)\\n        {\\n            if(prime[i])\\n            {\\n                while(n%i == 0)\\n                {\\n                    if(!sohel(i))\\n                    return false;\\n                    n /= i;\\n                }\\n            }\\n        }\\n        return sohel(n);\\n    }\\n};\\ncan anyone help me find out the reason for runtime error in this code?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The `n` can be non-positive ($\\\\leq 0$). And we cannot initialize `prime` with non-negative size. That\\'s why run-time error, [@The_Underdog26](/darkhorse007d)"
                    },
                    {
                        "username": "weselyong",
                        "content": "You said `1 has no prime factors so return True`, fine.\\nBut how about `0` is False, does 0 have any prime factors?\\n "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "But $0$ isn\\'t Positive Integer. Therefore, `False` for $0$ is justified, [@weselyong](/weselyong). An Ugly Number should satisfy following two conditions\\n- it should be positive\\n- prime factors should be limited to 2, 3, and 5."
                    },
                    {
                        "username": "jerryy147",
                        "content": "looks fun"
                    },
                    {
                        "username": "user5400vw",
                        "content": "tricky problem!!"
                    },
                    {
                        "username": "andresstawski",
                        "content": "guess for any number pow(-2, 31) <= n going as false \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Dude description for this problem is shit let me explain this  check wheater a number is divisible bt 2,3,5 if its modulo  for each case is zero then divide the number by 2,3,5  at last if n ==1 then return true else return false."
                    }
                ]
            },
            {
                "id": 2058558,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "bruh, I was able to solve this, but ain\\'t no way this is easy, especially with this atrocious description"
                    },
                    {
                        "username": "PRANAB_DAS1",
                        "content": "It seems people some dont understand one simple term \"Not to post solution in discussion section\""
                    },
                    {
                        "username": "alanparmenter",
                        "content": "I don\\'t know, maybe darkhorse007d thought it was OK to ask for advice about their solution which was not working, and they got some help debugging from RohitSgh, but in principle the \\'don\\'t post any solutions\\' rule does seem pretty important for the discussions page"
                    },
                    {
                        "username": "abanand132",
                        "content": "While Sieve of Eratosthenes, I don\\'t why but for n= 64, it is not working. It gives error heap overflow in c++. But it is working well in my local ide."
                    },
                    {
                        "username": "Yusuf_Bogatyrev",
                        "content": "Very bad problem condition! Confusing and not clear."
                    },
                    {
                        "username": "darkhorse007d",
                        "content": "class Solution {\\npublic:\\n    bool sohel(int n)\\n    {\\n        return n == 2 or n == 3 or n == 5 or n == 1;\\n    }\\n    bool isUgly(int n) {\\n       // cout << INT_MIN << endl;\\n       n = (long long)n;\\n       vector<bool>prime(n+1 , true);\\n       long long i , j;\\n       for(i = 2 ; i*i <= n ; i++)\\n       {\\n           if(prime[i])\\n           {\\n               for(j = i*i ; j <= n ; j+=i)\\n               prime[j] = false;\\n           }\\n       }\\n        for(i = 2 ; i*i <= n ; i++)\\n        {\\n            if(prime[i])\\n            {\\n                while(n%i == 0)\\n                {\\n                    if(!sohel(i))\\n                    return false;\\n                    n /= i;\\n                }\\n            }\\n        }\\n        return sohel(n);\\n    }\\n};\\ncan anyone help me find out the reason for runtime error in this code?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The `n` can be non-positive ($\\\\leq 0$). And we cannot initialize `prime` with non-negative size. That\\'s why run-time error, [@The_Underdog26](/darkhorse007d)"
                    },
                    {
                        "username": "weselyong",
                        "content": "You said `1 has no prime factors so return True`, fine.\\nBut how about `0` is False, does 0 have any prime factors?\\n "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "But $0$ isn\\'t Positive Integer. Therefore, `False` for $0$ is justified, [@weselyong](/weselyong). An Ugly Number should satisfy following two conditions\\n- it should be positive\\n- prime factors should be limited to 2, 3, and 5."
                    },
                    {
                        "username": "jerryy147",
                        "content": "looks fun"
                    },
                    {
                        "username": "user5400vw",
                        "content": "tricky problem!!"
                    },
                    {
                        "username": "andresstawski",
                        "content": "guess for any number pow(-2, 31) <= n going as false \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Dude description for this problem is shit let me explain this  check wheater a number is divisible bt 2,3,5 if its modulo  for each case is zero then divide the number by 2,3,5  at last if n ==1 then return true else return false."
                    }
                ]
            },
            {
                "id": 2019012,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "bruh, I was able to solve this, but ain\\'t no way this is easy, especially with this atrocious description"
                    },
                    {
                        "username": "PRANAB_DAS1",
                        "content": "It seems people some dont understand one simple term \"Not to post solution in discussion section\""
                    },
                    {
                        "username": "alanparmenter",
                        "content": "I don\\'t know, maybe darkhorse007d thought it was OK to ask for advice about their solution which was not working, and they got some help debugging from RohitSgh, but in principle the \\'don\\'t post any solutions\\' rule does seem pretty important for the discussions page"
                    },
                    {
                        "username": "abanand132",
                        "content": "While Sieve of Eratosthenes, I don\\'t why but for n= 64, it is not working. It gives error heap overflow in c++. But it is working well in my local ide."
                    },
                    {
                        "username": "Yusuf_Bogatyrev",
                        "content": "Very bad problem condition! Confusing and not clear."
                    },
                    {
                        "username": "darkhorse007d",
                        "content": "class Solution {\\npublic:\\n    bool sohel(int n)\\n    {\\n        return n == 2 or n == 3 or n == 5 or n == 1;\\n    }\\n    bool isUgly(int n) {\\n       // cout << INT_MIN << endl;\\n       n = (long long)n;\\n       vector<bool>prime(n+1 , true);\\n       long long i , j;\\n       for(i = 2 ; i*i <= n ; i++)\\n       {\\n           if(prime[i])\\n           {\\n               for(j = i*i ; j <= n ; j+=i)\\n               prime[j] = false;\\n           }\\n       }\\n        for(i = 2 ; i*i <= n ; i++)\\n        {\\n            if(prime[i])\\n            {\\n                while(n%i == 0)\\n                {\\n                    if(!sohel(i))\\n                    return false;\\n                    n /= i;\\n                }\\n            }\\n        }\\n        return sohel(n);\\n    }\\n};\\ncan anyone help me find out the reason for runtime error in this code?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The `n` can be non-positive ($\\\\leq 0$). And we cannot initialize `prime` with non-negative size. That\\'s why run-time error, [@The_Underdog26](/darkhorse007d)"
                    },
                    {
                        "username": "weselyong",
                        "content": "You said `1 has no prime factors so return True`, fine.\\nBut how about `0` is False, does 0 have any prime factors?\\n "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "But $0$ isn\\'t Positive Integer. Therefore, `False` for $0$ is justified, [@weselyong](/weselyong). An Ugly Number should satisfy following two conditions\\n- it should be positive\\n- prime factors should be limited to 2, 3, and 5."
                    },
                    {
                        "username": "jerryy147",
                        "content": "looks fun"
                    },
                    {
                        "username": "user5400vw",
                        "content": "tricky problem!!"
                    },
                    {
                        "username": "andresstawski",
                        "content": "guess for any number pow(-2, 31) <= n going as false \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Dude description for this problem is shit let me explain this  check wheater a number is divisible bt 2,3,5 if its modulo  for each case is zero then divide the number by 2,3,5  at last if n ==1 then return true else return false."
                    }
                ]
            },
            {
                "id": 1983720,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "bruh, I was able to solve this, but ain\\'t no way this is easy, especially with this atrocious description"
                    },
                    {
                        "username": "PRANAB_DAS1",
                        "content": "It seems people some dont understand one simple term \"Not to post solution in discussion section\""
                    },
                    {
                        "username": "alanparmenter",
                        "content": "I don\\'t know, maybe darkhorse007d thought it was OK to ask for advice about their solution which was not working, and they got some help debugging from RohitSgh, but in principle the \\'don\\'t post any solutions\\' rule does seem pretty important for the discussions page"
                    },
                    {
                        "username": "abanand132",
                        "content": "While Sieve of Eratosthenes, I don\\'t why but for n= 64, it is not working. It gives error heap overflow in c++. But it is working well in my local ide."
                    },
                    {
                        "username": "Yusuf_Bogatyrev",
                        "content": "Very bad problem condition! Confusing and not clear."
                    },
                    {
                        "username": "darkhorse007d",
                        "content": "class Solution {\\npublic:\\n    bool sohel(int n)\\n    {\\n        return n == 2 or n == 3 or n == 5 or n == 1;\\n    }\\n    bool isUgly(int n) {\\n       // cout << INT_MIN << endl;\\n       n = (long long)n;\\n       vector<bool>prime(n+1 , true);\\n       long long i , j;\\n       for(i = 2 ; i*i <= n ; i++)\\n       {\\n           if(prime[i])\\n           {\\n               for(j = i*i ; j <= n ; j+=i)\\n               prime[j] = false;\\n           }\\n       }\\n        for(i = 2 ; i*i <= n ; i++)\\n        {\\n            if(prime[i])\\n            {\\n                while(n%i == 0)\\n                {\\n                    if(!sohel(i))\\n                    return false;\\n                    n /= i;\\n                }\\n            }\\n        }\\n        return sohel(n);\\n    }\\n};\\ncan anyone help me find out the reason for runtime error in this code?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The `n` can be non-positive ($\\\\leq 0$). And we cannot initialize `prime` with non-negative size. That\\'s why run-time error, [@The_Underdog26](/darkhorse007d)"
                    },
                    {
                        "username": "weselyong",
                        "content": "You said `1 has no prime factors so return True`, fine.\\nBut how about `0` is False, does 0 have any prime factors?\\n "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "But $0$ isn\\'t Positive Integer. Therefore, `False` for $0$ is justified, [@weselyong](/weselyong). An Ugly Number should satisfy following two conditions\\n- it should be positive\\n- prime factors should be limited to 2, 3, and 5."
                    },
                    {
                        "username": "jerryy147",
                        "content": "looks fun"
                    },
                    {
                        "username": "user5400vw",
                        "content": "tricky problem!!"
                    },
                    {
                        "username": "andresstawski",
                        "content": "guess for any number pow(-2, 31) <= n going as false \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Dude description for this problem is shit let me explain this  check wheater a number is divisible bt 2,3,5 if its modulo  for each case is zero then divide the number by 2,3,5  at last if n ==1 then return true else return false."
                    }
                ]
            },
            {
                "id": 1949427,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "bruh, I was able to solve this, but ain\\'t no way this is easy, especially with this atrocious description"
                    },
                    {
                        "username": "PRANAB_DAS1",
                        "content": "It seems people some dont understand one simple term \"Not to post solution in discussion section\""
                    },
                    {
                        "username": "alanparmenter",
                        "content": "I don\\'t know, maybe darkhorse007d thought it was OK to ask for advice about their solution which was not working, and they got some help debugging from RohitSgh, but in principle the \\'don\\'t post any solutions\\' rule does seem pretty important for the discussions page"
                    },
                    {
                        "username": "abanand132",
                        "content": "While Sieve of Eratosthenes, I don\\'t why but for n= 64, it is not working. It gives error heap overflow in c++. But it is working well in my local ide."
                    },
                    {
                        "username": "Yusuf_Bogatyrev",
                        "content": "Very bad problem condition! Confusing and not clear."
                    },
                    {
                        "username": "darkhorse007d",
                        "content": "class Solution {\\npublic:\\n    bool sohel(int n)\\n    {\\n        return n == 2 or n == 3 or n == 5 or n == 1;\\n    }\\n    bool isUgly(int n) {\\n       // cout << INT_MIN << endl;\\n       n = (long long)n;\\n       vector<bool>prime(n+1 , true);\\n       long long i , j;\\n       for(i = 2 ; i*i <= n ; i++)\\n       {\\n           if(prime[i])\\n           {\\n               for(j = i*i ; j <= n ; j+=i)\\n               prime[j] = false;\\n           }\\n       }\\n        for(i = 2 ; i*i <= n ; i++)\\n        {\\n            if(prime[i])\\n            {\\n                while(n%i == 0)\\n                {\\n                    if(!sohel(i))\\n                    return false;\\n                    n /= i;\\n                }\\n            }\\n        }\\n        return sohel(n);\\n    }\\n};\\ncan anyone help me find out the reason for runtime error in this code?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The `n` can be non-positive ($\\\\leq 0$). And we cannot initialize `prime` with non-negative size. That\\'s why run-time error, [@The_Underdog26](/darkhorse007d)"
                    },
                    {
                        "username": "weselyong",
                        "content": "You said `1 has no prime factors so return True`, fine.\\nBut how about `0` is False, does 0 have any prime factors?\\n "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "But $0$ isn\\'t Positive Integer. Therefore, `False` for $0$ is justified, [@weselyong](/weselyong). An Ugly Number should satisfy following two conditions\\n- it should be positive\\n- prime factors should be limited to 2, 3, and 5."
                    },
                    {
                        "username": "jerryy147",
                        "content": "looks fun"
                    },
                    {
                        "username": "user5400vw",
                        "content": "tricky problem!!"
                    },
                    {
                        "username": "andresstawski",
                        "content": "guess for any number pow(-2, 31) <= n going as false \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Dude description for this problem is shit let me explain this  check wheater a number is divisible bt 2,3,5 if its modulo  for each case is zero then divide the number by 2,3,5  at last if n ==1 then return true else return false."
                    }
                ]
            },
            {
                "id": 1942185,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "bruh, I was able to solve this, but ain\\'t no way this is easy, especially with this atrocious description"
                    },
                    {
                        "username": "PRANAB_DAS1",
                        "content": "It seems people some dont understand one simple term \"Not to post solution in discussion section\""
                    },
                    {
                        "username": "alanparmenter",
                        "content": "I don\\'t know, maybe darkhorse007d thought it was OK to ask for advice about their solution which was not working, and they got some help debugging from RohitSgh, but in principle the \\'don\\'t post any solutions\\' rule does seem pretty important for the discussions page"
                    },
                    {
                        "username": "abanand132",
                        "content": "While Sieve of Eratosthenes, I don\\'t why but for n= 64, it is not working. It gives error heap overflow in c++. But it is working well in my local ide."
                    },
                    {
                        "username": "Yusuf_Bogatyrev",
                        "content": "Very bad problem condition! Confusing and not clear."
                    },
                    {
                        "username": "darkhorse007d",
                        "content": "class Solution {\\npublic:\\n    bool sohel(int n)\\n    {\\n        return n == 2 or n == 3 or n == 5 or n == 1;\\n    }\\n    bool isUgly(int n) {\\n       // cout << INT_MIN << endl;\\n       n = (long long)n;\\n       vector<bool>prime(n+1 , true);\\n       long long i , j;\\n       for(i = 2 ; i*i <= n ; i++)\\n       {\\n           if(prime[i])\\n           {\\n               for(j = i*i ; j <= n ; j+=i)\\n               prime[j] = false;\\n           }\\n       }\\n        for(i = 2 ; i*i <= n ; i++)\\n        {\\n            if(prime[i])\\n            {\\n                while(n%i == 0)\\n                {\\n                    if(!sohel(i))\\n                    return false;\\n                    n /= i;\\n                }\\n            }\\n        }\\n        return sohel(n);\\n    }\\n};\\ncan anyone help me find out the reason for runtime error in this code?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The `n` can be non-positive ($\\\\leq 0$). And we cannot initialize `prime` with non-negative size. That\\'s why run-time error, [@The_Underdog26](/darkhorse007d)"
                    },
                    {
                        "username": "weselyong",
                        "content": "You said `1 has no prime factors so return True`, fine.\\nBut how about `0` is False, does 0 have any prime factors?\\n "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "But $0$ isn\\'t Positive Integer. Therefore, `False` for $0$ is justified, [@weselyong](/weselyong). An Ugly Number should satisfy following two conditions\\n- it should be positive\\n- prime factors should be limited to 2, 3, and 5."
                    },
                    {
                        "username": "jerryy147",
                        "content": "looks fun"
                    },
                    {
                        "username": "user5400vw",
                        "content": "tricky problem!!"
                    },
                    {
                        "username": "andresstawski",
                        "content": "guess for any number pow(-2, 31) <= n going as false \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Dude description for this problem is shit let me explain this  check wheater a number is divisible bt 2,3,5 if its modulo  for each case is zero then divide the number by 2,3,5  at last if n ==1 then return true else return false."
                    }
                ]
            },
            {
                "id": 1922490,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "bruh, I was able to solve this, but ain\\'t no way this is easy, especially with this atrocious description"
                    },
                    {
                        "username": "PRANAB_DAS1",
                        "content": "It seems people some dont understand one simple term \"Not to post solution in discussion section\""
                    },
                    {
                        "username": "alanparmenter",
                        "content": "I don\\'t know, maybe darkhorse007d thought it was OK to ask for advice about their solution which was not working, and they got some help debugging from RohitSgh, but in principle the \\'don\\'t post any solutions\\' rule does seem pretty important for the discussions page"
                    },
                    {
                        "username": "abanand132",
                        "content": "While Sieve of Eratosthenes, I don\\'t why but for n= 64, it is not working. It gives error heap overflow in c++. But it is working well in my local ide."
                    },
                    {
                        "username": "Yusuf_Bogatyrev",
                        "content": "Very bad problem condition! Confusing and not clear."
                    },
                    {
                        "username": "darkhorse007d",
                        "content": "class Solution {\\npublic:\\n    bool sohel(int n)\\n    {\\n        return n == 2 or n == 3 or n == 5 or n == 1;\\n    }\\n    bool isUgly(int n) {\\n       // cout << INT_MIN << endl;\\n       n = (long long)n;\\n       vector<bool>prime(n+1 , true);\\n       long long i , j;\\n       for(i = 2 ; i*i <= n ; i++)\\n       {\\n           if(prime[i])\\n           {\\n               for(j = i*i ; j <= n ; j+=i)\\n               prime[j] = false;\\n           }\\n       }\\n        for(i = 2 ; i*i <= n ; i++)\\n        {\\n            if(prime[i])\\n            {\\n                while(n%i == 0)\\n                {\\n                    if(!sohel(i))\\n                    return false;\\n                    n /= i;\\n                }\\n            }\\n        }\\n        return sohel(n);\\n    }\\n};\\ncan anyone help me find out the reason for runtime error in this code?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The `n` can be non-positive ($\\\\leq 0$). And we cannot initialize `prime` with non-negative size. That\\'s why run-time error, [@The_Underdog26](/darkhorse007d)"
                    },
                    {
                        "username": "weselyong",
                        "content": "You said `1 has no prime factors so return True`, fine.\\nBut how about `0` is False, does 0 have any prime factors?\\n "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "But $0$ isn\\'t Positive Integer. Therefore, `False` for $0$ is justified, [@weselyong](/weselyong). An Ugly Number should satisfy following two conditions\\n- it should be positive\\n- prime factors should be limited to 2, 3, and 5."
                    },
                    {
                        "username": "jerryy147",
                        "content": "looks fun"
                    },
                    {
                        "username": "user5400vw",
                        "content": "tricky problem!!"
                    },
                    {
                        "username": "andresstawski",
                        "content": "guess for any number pow(-2, 31) <= n going as false \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Dude description for this problem is shit let me explain this  check wheater a number is divisible bt 2,3,5 if its modulo  for each case is zero then divide the number by 2,3,5  at last if n ==1 then return true else return false."
                    }
                ]
            },
            {
                "id": 1910860,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "bruh, I was able to solve this, but ain\\'t no way this is easy, especially with this atrocious description"
                    },
                    {
                        "username": "PRANAB_DAS1",
                        "content": "It seems people some dont understand one simple term \"Not to post solution in discussion section\""
                    },
                    {
                        "username": "alanparmenter",
                        "content": "I don\\'t know, maybe darkhorse007d thought it was OK to ask for advice about their solution which was not working, and they got some help debugging from RohitSgh, but in principle the \\'don\\'t post any solutions\\' rule does seem pretty important for the discussions page"
                    },
                    {
                        "username": "abanand132",
                        "content": "While Sieve of Eratosthenes, I don\\'t why but for n= 64, it is not working. It gives error heap overflow in c++. But it is working well in my local ide."
                    },
                    {
                        "username": "Yusuf_Bogatyrev",
                        "content": "Very bad problem condition! Confusing and not clear."
                    },
                    {
                        "username": "darkhorse007d",
                        "content": "class Solution {\\npublic:\\n    bool sohel(int n)\\n    {\\n        return n == 2 or n == 3 or n == 5 or n == 1;\\n    }\\n    bool isUgly(int n) {\\n       // cout << INT_MIN << endl;\\n       n = (long long)n;\\n       vector<bool>prime(n+1 , true);\\n       long long i , j;\\n       for(i = 2 ; i*i <= n ; i++)\\n       {\\n           if(prime[i])\\n           {\\n               for(j = i*i ; j <= n ; j+=i)\\n               prime[j] = false;\\n           }\\n       }\\n        for(i = 2 ; i*i <= n ; i++)\\n        {\\n            if(prime[i])\\n            {\\n                while(n%i == 0)\\n                {\\n                    if(!sohel(i))\\n                    return false;\\n                    n /= i;\\n                }\\n            }\\n        }\\n        return sohel(n);\\n    }\\n};\\ncan anyone help me find out the reason for runtime error in this code?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The `n` can be non-positive ($\\\\leq 0$). And we cannot initialize `prime` with non-negative size. That\\'s why run-time error, [@The_Underdog26](/darkhorse007d)"
                    },
                    {
                        "username": "weselyong",
                        "content": "You said `1 has no prime factors so return True`, fine.\\nBut how about `0` is False, does 0 have any prime factors?\\n "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "But $0$ isn\\'t Positive Integer. Therefore, `False` for $0$ is justified, [@weselyong](/weselyong). An Ugly Number should satisfy following two conditions\\n- it should be positive\\n- prime factors should be limited to 2, 3, and 5."
                    },
                    {
                        "username": "jerryy147",
                        "content": "looks fun"
                    },
                    {
                        "username": "user5400vw",
                        "content": "tricky problem!!"
                    },
                    {
                        "username": "andresstawski",
                        "content": "guess for any number pow(-2, 31) <= n going as false \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Dude description for this problem is shit let me explain this  check wheater a number is divisible bt 2,3,5 if its modulo  for each case is zero then divide the number by 2,3,5  at last if n ==1 then return true else return false."
                    }
                ]
            },
            {
                "id": 1910336,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "bruh, I was able to solve this, but ain\\'t no way this is easy, especially with this atrocious description"
                    },
                    {
                        "username": "PRANAB_DAS1",
                        "content": "It seems people some dont understand one simple term \"Not to post solution in discussion section\""
                    },
                    {
                        "username": "alanparmenter",
                        "content": "I don\\'t know, maybe darkhorse007d thought it was OK to ask for advice about their solution which was not working, and they got some help debugging from RohitSgh, but in principle the \\'don\\'t post any solutions\\' rule does seem pretty important for the discussions page"
                    },
                    {
                        "username": "abanand132",
                        "content": "While Sieve of Eratosthenes, I don\\'t why but for n= 64, it is not working. It gives error heap overflow in c++. But it is working well in my local ide."
                    },
                    {
                        "username": "Yusuf_Bogatyrev",
                        "content": "Very bad problem condition! Confusing and not clear."
                    },
                    {
                        "username": "darkhorse007d",
                        "content": "class Solution {\\npublic:\\n    bool sohel(int n)\\n    {\\n        return n == 2 or n == 3 or n == 5 or n == 1;\\n    }\\n    bool isUgly(int n) {\\n       // cout << INT_MIN << endl;\\n       n = (long long)n;\\n       vector<bool>prime(n+1 , true);\\n       long long i , j;\\n       for(i = 2 ; i*i <= n ; i++)\\n       {\\n           if(prime[i])\\n           {\\n               for(j = i*i ; j <= n ; j+=i)\\n               prime[j] = false;\\n           }\\n       }\\n        for(i = 2 ; i*i <= n ; i++)\\n        {\\n            if(prime[i])\\n            {\\n                while(n%i == 0)\\n                {\\n                    if(!sohel(i))\\n                    return false;\\n                    n /= i;\\n                }\\n            }\\n        }\\n        return sohel(n);\\n    }\\n};\\ncan anyone help me find out the reason for runtime error in this code?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The `n` can be non-positive ($\\\\leq 0$). And we cannot initialize `prime` with non-negative size. That\\'s why run-time error, [@The_Underdog26](/darkhorse007d)"
                    },
                    {
                        "username": "weselyong",
                        "content": "You said `1 has no prime factors so return True`, fine.\\nBut how about `0` is False, does 0 have any prime factors?\\n "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "But $0$ isn\\'t Positive Integer. Therefore, `False` for $0$ is justified, [@weselyong](/weselyong). An Ugly Number should satisfy following two conditions\\n- it should be positive\\n- prime factors should be limited to 2, 3, and 5."
                    },
                    {
                        "username": "jerryy147",
                        "content": "looks fun"
                    },
                    {
                        "username": "user5400vw",
                        "content": "tricky problem!!"
                    },
                    {
                        "username": "andresstawski",
                        "content": "guess for any number pow(-2, 31) <= n going as false \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Dude description for this problem is shit let me explain this  check wheater a number is divisible bt 2,3,5 if its modulo  for each case is zero then divide the number by 2,3,5  at last if n ==1 then return true else return false."
                    }
                ]
            },
            {
                "id": 1855844,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "bruh, I was able to solve this, but ain\\'t no way this is easy, especially with this atrocious description"
                    },
                    {
                        "username": "PRANAB_DAS1",
                        "content": "It seems people some dont understand one simple term \"Not to post solution in discussion section\""
                    },
                    {
                        "username": "alanparmenter",
                        "content": "I don\\'t know, maybe darkhorse007d thought it was OK to ask for advice about their solution which was not working, and they got some help debugging from RohitSgh, but in principle the \\'don\\'t post any solutions\\' rule does seem pretty important for the discussions page"
                    },
                    {
                        "username": "abanand132",
                        "content": "While Sieve of Eratosthenes, I don\\'t why but for n= 64, it is not working. It gives error heap overflow in c++. But it is working well in my local ide."
                    },
                    {
                        "username": "Yusuf_Bogatyrev",
                        "content": "Very bad problem condition! Confusing and not clear."
                    },
                    {
                        "username": "darkhorse007d",
                        "content": "class Solution {\\npublic:\\n    bool sohel(int n)\\n    {\\n        return n == 2 or n == 3 or n == 5 or n == 1;\\n    }\\n    bool isUgly(int n) {\\n       // cout << INT_MIN << endl;\\n       n = (long long)n;\\n       vector<bool>prime(n+1 , true);\\n       long long i , j;\\n       for(i = 2 ; i*i <= n ; i++)\\n       {\\n           if(prime[i])\\n           {\\n               for(j = i*i ; j <= n ; j+=i)\\n               prime[j] = false;\\n           }\\n       }\\n        for(i = 2 ; i*i <= n ; i++)\\n        {\\n            if(prime[i])\\n            {\\n                while(n%i == 0)\\n                {\\n                    if(!sohel(i))\\n                    return false;\\n                    n /= i;\\n                }\\n            }\\n        }\\n        return sohel(n);\\n    }\\n};\\ncan anyone help me find out the reason for runtime error in this code?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The `n` can be non-positive ($\\\\leq 0$). And we cannot initialize `prime` with non-negative size. That\\'s why run-time error, [@The_Underdog26](/darkhorse007d)"
                    },
                    {
                        "username": "weselyong",
                        "content": "You said `1 has no prime factors so return True`, fine.\\nBut how about `0` is False, does 0 have any prime factors?\\n "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "But $0$ isn\\'t Positive Integer. Therefore, `False` for $0$ is justified, [@weselyong](/weselyong). An Ugly Number should satisfy following two conditions\\n- it should be positive\\n- prime factors should be limited to 2, 3, and 5."
                    },
                    {
                        "username": "jerryy147",
                        "content": "looks fun"
                    },
                    {
                        "username": "user5400vw",
                        "content": "tricky problem!!"
                    },
                    {
                        "username": "andresstawski",
                        "content": "guess for any number pow(-2, 31) <= n going as false \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Dude description for this problem is shit let me explain this  check wheater a number is divisible bt 2,3,5 if its modulo  for each case is zero then divide the number by 2,3,5  at last if n ==1 then return true else return false."
                    }
                ]
            },
            {
                "id": 1807117,
                "content": [
                    {
                        "username": "sanjeev15002",
                        "content": "0 has no prime factors. Thus, its prime factors are limited to 2, 3 and 5 which should make 0 an ugly number. However, this question expects output \"False\" for input \"0\"."
                    },
                    {
                        "username": "sanjeev15002",
                        "content": "[@RohitSgh](/RohitSgh) Oh yes, my bad, I missed that! Thank you! "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "0 is **NOT** a positive integer. As per [problem description](https://leetcode.com/problems/ugly-number/description/), ugly number should be positive. \\n\\nThus, 0 cannot be ugly. Hence, `False` is justified."
                    },
                    {
                        "username": "Shankhadeep2017",
                        "content": "its Very simple questions .\\nall positive number n % 2 or n % 3 or n % 5 and reduce n = n//2, n = n // 3 , n = n // 5 used while n > 1\\nif n == 1 return true else false \\nfor example:\\nn = 20 \\n20 % 2 == 0\\n20 // 2 = 10\\n10 % 2 == 0\\n10 // 2 = 5\\n5 %  5 == 0\\n5 // 5 = 1\\nno we got 1 so ans is True\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Damn this problem has negative numbers... I passed 1003/1013 first try, now idk what to do with those negative numbers.."
                    },
                    {
                        "username": "rrajatutort",
                        "content": "Hi ,\\nMy code prints 8 as not ugly since it has 4 as prime factor. But leetcode expecting to return as ugly. Can someone explain what is wrong here?\\n\\nLeetcode result:\\n\\nn =\\n8\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue"
                    },
                    {
                        "username": "SDriscoll",
                        "content": "[@RohitSgh](/RohitSgh) That is not clear in the description, I should not need to read this many comments to find this explanation"
                    },
                    {
                        "username": "rrajatutort",
                        "content": "[@RohitSgh](/RohitSgh) Thanks for the explanation Rohit."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\n- The number should be positive ($> 0$)\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\{2, 3, 5\\}$\n\nNow, $8$ satisfies the first condition. For second condition, the set of prime factors of $8$ is $\\{2\\}$, since $8 = 2 \\cdot 2 \\cdot 2$, and $\\{2\\}$ is a subset of $\\{2, 3, 5\\}$. Thus `true` for $8$ is justified."
                    },
                    {
                        "username": "sam1906",
                        "content": "How is 12 ugly?\\n\\nThe answer should be false but compiler showed otherwise.\\n\\nhttps://imgur.com/t9Df0Ov"
                    },
                    {
                        "username": "sam1906",
                        "content": "Understood. Thanks for the explanation [@Rohit Singh](/RohitSgh) and [@Mitul Agrawal](/Mitulagr08)"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The set of prime factors of $12$ are $\\\\{2,3\\\\}$, since $12 = 2 \\\\times 2 \\\\times 3$. Since prime factors of $12$ are limited to $2, 3$ and $5$, (and $12$ is positive), it is Ugly Number. Hence, answer is `True`.\\n\\nWe don\\'t necessarily need all three factors in factorization. But all prime factors should be there in set  $\\\\{2,3,5\\\\}$."
                    },
                    {
                        "username": "Mitulagr",
                        "content": "12 = 2 x 2 x 3, so its prime factors are 2 and 3 only"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "<0 : not ugly\\n0 : not ugly\\n1 : ugly"
                    },
                    {
                        "username": "tarunjain_973",
                        "content": "can we do this question with seieve of erotisthenese for prime number.... \\n"
                    },
                    {
                        "username": "Pritam-Padhan",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n==1) return true;\\n        if(n%2==0) return isUgly(n/2);\\n        else if(n%3==0) return isUgly(n/3);\\n        else if(n%5==0) return isUgly(n/5);\\n        else {\\n           return false;\\n        }\\n    }\\n}\\n\\nIn this code why i am getting stack over flow error"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "When `n = 0`, the condition of `if` will evaluate to `True`, hence it will recursively call `isUgly(0)`. This will initiate infinite recursion, because whenever `isUgly(0)` is called, `if` condition will be `True` and `isUgly(0)` will be called again. \n\nA quick fix is to follow definition and this line of code as first statement of function `isUgly(n)`\n\n```java\nif(n<=0) return false;\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Every number less than or equal to 0 is NOT an ugly number."
                    },
                    {
                        "username": "dollarSign",
                        "content": "This is the number = -2147483648 and its factors are 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2, so why its returning false? "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer is negative. And as per [problem description](https://leetcode.com/problems/ugly-number/discussion/), an ugly number is positive integer. Thus, `False` is correct."
                    }
                ]
            },
            {
                "id": 1795717,
                "content": [
                    {
                        "username": "sanjeev15002",
                        "content": "0 has no prime factors. Thus, its prime factors are limited to 2, 3 and 5 which should make 0 an ugly number. However, this question expects output \"False\" for input \"0\"."
                    },
                    {
                        "username": "sanjeev15002",
                        "content": "[@RohitSgh](/RohitSgh) Oh yes, my bad, I missed that! Thank you! "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "0 is **NOT** a positive integer. As per [problem description](https://leetcode.com/problems/ugly-number/description/), ugly number should be positive. \\n\\nThus, 0 cannot be ugly. Hence, `False` is justified."
                    },
                    {
                        "username": "Shankhadeep2017",
                        "content": "its Very simple questions .\\nall positive number n % 2 or n % 3 or n % 5 and reduce n = n//2, n = n // 3 , n = n // 5 used while n > 1\\nif n == 1 return true else false \\nfor example:\\nn = 20 \\n20 % 2 == 0\\n20 // 2 = 10\\n10 % 2 == 0\\n10 // 2 = 5\\n5 %  5 == 0\\n5 // 5 = 1\\nno we got 1 so ans is True\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Damn this problem has negative numbers... I passed 1003/1013 first try, now idk what to do with those negative numbers.."
                    },
                    {
                        "username": "rrajatutort",
                        "content": "Hi ,\\nMy code prints 8 as not ugly since it has 4 as prime factor. But leetcode expecting to return as ugly. Can someone explain what is wrong here?\\n\\nLeetcode result:\\n\\nn =\\n8\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue"
                    },
                    {
                        "username": "SDriscoll",
                        "content": "[@RohitSgh](/RohitSgh) That is not clear in the description, I should not need to read this many comments to find this explanation"
                    },
                    {
                        "username": "rrajatutort",
                        "content": "[@RohitSgh](/RohitSgh) Thanks for the explanation Rohit."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\n- The number should be positive ($> 0$)\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\{2, 3, 5\\}$\n\nNow, $8$ satisfies the first condition. For second condition, the set of prime factors of $8$ is $\\{2\\}$, since $8 = 2 \\cdot 2 \\cdot 2$, and $\\{2\\}$ is a subset of $\\{2, 3, 5\\}$. Thus `true` for $8$ is justified."
                    },
                    {
                        "username": "sam1906",
                        "content": "How is 12 ugly?\\n\\nThe answer should be false but compiler showed otherwise.\\n\\nhttps://imgur.com/t9Df0Ov"
                    },
                    {
                        "username": "sam1906",
                        "content": "Understood. Thanks for the explanation [@Rohit Singh](/RohitSgh) and [@Mitul Agrawal](/Mitulagr08)"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The set of prime factors of $12$ are $\\\\{2,3\\\\}$, since $12 = 2 \\\\times 2 \\\\times 3$. Since prime factors of $12$ are limited to $2, 3$ and $5$, (and $12$ is positive), it is Ugly Number. Hence, answer is `True`.\\n\\nWe don\\'t necessarily need all three factors in factorization. But all prime factors should be there in set  $\\\\{2,3,5\\\\}$."
                    },
                    {
                        "username": "Mitulagr",
                        "content": "12 = 2 x 2 x 3, so its prime factors are 2 and 3 only"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "<0 : not ugly\\n0 : not ugly\\n1 : ugly"
                    },
                    {
                        "username": "tarunjain_973",
                        "content": "can we do this question with seieve of erotisthenese for prime number.... \\n"
                    },
                    {
                        "username": "Pritam-Padhan",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n==1) return true;\\n        if(n%2==0) return isUgly(n/2);\\n        else if(n%3==0) return isUgly(n/3);\\n        else if(n%5==0) return isUgly(n/5);\\n        else {\\n           return false;\\n        }\\n    }\\n}\\n\\nIn this code why i am getting stack over flow error"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "When `n = 0`, the condition of `if` will evaluate to `True`, hence it will recursively call `isUgly(0)`. This will initiate infinite recursion, because whenever `isUgly(0)` is called, `if` condition will be `True` and `isUgly(0)` will be called again. \n\nA quick fix is to follow definition and this line of code as first statement of function `isUgly(n)`\n\n```java\nif(n<=0) return false;\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Every number less than or equal to 0 is NOT an ugly number."
                    },
                    {
                        "username": "dollarSign",
                        "content": "This is the number = -2147483648 and its factors are 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2, so why its returning false? "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer is negative. And as per [problem description](https://leetcode.com/problems/ugly-number/discussion/), an ugly number is positive integer. Thus, `False` is correct."
                    }
                ]
            },
            {
                "id": 1766739,
                "content": [
                    {
                        "username": "sanjeev15002",
                        "content": "0 has no prime factors. Thus, its prime factors are limited to 2, 3 and 5 which should make 0 an ugly number. However, this question expects output \"False\" for input \"0\"."
                    },
                    {
                        "username": "sanjeev15002",
                        "content": "[@RohitSgh](/RohitSgh) Oh yes, my bad, I missed that! Thank you! "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "0 is **NOT** a positive integer. As per [problem description](https://leetcode.com/problems/ugly-number/description/), ugly number should be positive. \\n\\nThus, 0 cannot be ugly. Hence, `False` is justified."
                    },
                    {
                        "username": "Shankhadeep2017",
                        "content": "its Very simple questions .\\nall positive number n % 2 or n % 3 or n % 5 and reduce n = n//2, n = n // 3 , n = n // 5 used while n > 1\\nif n == 1 return true else false \\nfor example:\\nn = 20 \\n20 % 2 == 0\\n20 // 2 = 10\\n10 % 2 == 0\\n10 // 2 = 5\\n5 %  5 == 0\\n5 // 5 = 1\\nno we got 1 so ans is True\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Damn this problem has negative numbers... I passed 1003/1013 first try, now idk what to do with those negative numbers.."
                    },
                    {
                        "username": "rrajatutort",
                        "content": "Hi ,\\nMy code prints 8 as not ugly since it has 4 as prime factor. But leetcode expecting to return as ugly. Can someone explain what is wrong here?\\n\\nLeetcode result:\\n\\nn =\\n8\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue"
                    },
                    {
                        "username": "SDriscoll",
                        "content": "[@RohitSgh](/RohitSgh) That is not clear in the description, I should not need to read this many comments to find this explanation"
                    },
                    {
                        "username": "rrajatutort",
                        "content": "[@RohitSgh](/RohitSgh) Thanks for the explanation Rohit."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\n- The number should be positive ($> 0$)\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\{2, 3, 5\\}$\n\nNow, $8$ satisfies the first condition. For second condition, the set of prime factors of $8$ is $\\{2\\}$, since $8 = 2 \\cdot 2 \\cdot 2$, and $\\{2\\}$ is a subset of $\\{2, 3, 5\\}$. Thus `true` for $8$ is justified."
                    },
                    {
                        "username": "sam1906",
                        "content": "How is 12 ugly?\\n\\nThe answer should be false but compiler showed otherwise.\\n\\nhttps://imgur.com/t9Df0Ov"
                    },
                    {
                        "username": "sam1906",
                        "content": "Understood. Thanks for the explanation [@Rohit Singh](/RohitSgh) and [@Mitul Agrawal](/Mitulagr08)"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The set of prime factors of $12$ are $\\\\{2,3\\\\}$, since $12 = 2 \\\\times 2 \\\\times 3$. Since prime factors of $12$ are limited to $2, 3$ and $5$, (and $12$ is positive), it is Ugly Number. Hence, answer is `True`.\\n\\nWe don\\'t necessarily need all three factors in factorization. But all prime factors should be there in set  $\\\\{2,3,5\\\\}$."
                    },
                    {
                        "username": "Mitulagr",
                        "content": "12 = 2 x 2 x 3, so its prime factors are 2 and 3 only"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "<0 : not ugly\\n0 : not ugly\\n1 : ugly"
                    },
                    {
                        "username": "tarunjain_973",
                        "content": "can we do this question with seieve of erotisthenese for prime number.... \\n"
                    },
                    {
                        "username": "Pritam-Padhan",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n==1) return true;\\n        if(n%2==0) return isUgly(n/2);\\n        else if(n%3==0) return isUgly(n/3);\\n        else if(n%5==0) return isUgly(n/5);\\n        else {\\n           return false;\\n        }\\n    }\\n}\\n\\nIn this code why i am getting stack over flow error"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "When `n = 0`, the condition of `if` will evaluate to `True`, hence it will recursively call `isUgly(0)`. This will initiate infinite recursion, because whenever `isUgly(0)` is called, `if` condition will be `True` and `isUgly(0)` will be called again. \n\nA quick fix is to follow definition and this line of code as first statement of function `isUgly(n)`\n\n```java\nif(n<=0) return false;\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Every number less than or equal to 0 is NOT an ugly number."
                    },
                    {
                        "username": "dollarSign",
                        "content": "This is the number = -2147483648 and its factors are 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2, so why its returning false? "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer is negative. And as per [problem description](https://leetcode.com/problems/ugly-number/discussion/), an ugly number is positive integer. Thus, `False` is correct."
                    }
                ]
            },
            {
                "id": 1763270,
                "content": [
                    {
                        "username": "sanjeev15002",
                        "content": "0 has no prime factors. Thus, its prime factors are limited to 2, 3 and 5 which should make 0 an ugly number. However, this question expects output \"False\" for input \"0\"."
                    },
                    {
                        "username": "sanjeev15002",
                        "content": "[@RohitSgh](/RohitSgh) Oh yes, my bad, I missed that! Thank you! "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "0 is **NOT** a positive integer. As per [problem description](https://leetcode.com/problems/ugly-number/description/), ugly number should be positive. \\n\\nThus, 0 cannot be ugly. Hence, `False` is justified."
                    },
                    {
                        "username": "Shankhadeep2017",
                        "content": "its Very simple questions .\\nall positive number n % 2 or n % 3 or n % 5 and reduce n = n//2, n = n // 3 , n = n // 5 used while n > 1\\nif n == 1 return true else false \\nfor example:\\nn = 20 \\n20 % 2 == 0\\n20 // 2 = 10\\n10 % 2 == 0\\n10 // 2 = 5\\n5 %  5 == 0\\n5 // 5 = 1\\nno we got 1 so ans is True\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Damn this problem has negative numbers... I passed 1003/1013 first try, now idk what to do with those negative numbers.."
                    },
                    {
                        "username": "rrajatutort",
                        "content": "Hi ,\\nMy code prints 8 as not ugly since it has 4 as prime factor. But leetcode expecting to return as ugly. Can someone explain what is wrong here?\\n\\nLeetcode result:\\n\\nn =\\n8\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue"
                    },
                    {
                        "username": "SDriscoll",
                        "content": "[@RohitSgh](/RohitSgh) That is not clear in the description, I should not need to read this many comments to find this explanation"
                    },
                    {
                        "username": "rrajatutort",
                        "content": "[@RohitSgh](/RohitSgh) Thanks for the explanation Rohit."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\n- The number should be positive ($> 0$)\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\{2, 3, 5\\}$\n\nNow, $8$ satisfies the first condition. For second condition, the set of prime factors of $8$ is $\\{2\\}$, since $8 = 2 \\cdot 2 \\cdot 2$, and $\\{2\\}$ is a subset of $\\{2, 3, 5\\}$. Thus `true` for $8$ is justified."
                    },
                    {
                        "username": "sam1906",
                        "content": "How is 12 ugly?\\n\\nThe answer should be false but compiler showed otherwise.\\n\\nhttps://imgur.com/t9Df0Ov"
                    },
                    {
                        "username": "sam1906",
                        "content": "Understood. Thanks for the explanation [@Rohit Singh](/RohitSgh) and [@Mitul Agrawal](/Mitulagr08)"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The set of prime factors of $12$ are $\\\\{2,3\\\\}$, since $12 = 2 \\\\times 2 \\\\times 3$. Since prime factors of $12$ are limited to $2, 3$ and $5$, (and $12$ is positive), it is Ugly Number. Hence, answer is `True`.\\n\\nWe don\\'t necessarily need all three factors in factorization. But all prime factors should be there in set  $\\\\{2,3,5\\\\}$."
                    },
                    {
                        "username": "Mitulagr",
                        "content": "12 = 2 x 2 x 3, so its prime factors are 2 and 3 only"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "<0 : not ugly\\n0 : not ugly\\n1 : ugly"
                    },
                    {
                        "username": "tarunjain_973",
                        "content": "can we do this question with seieve of erotisthenese for prime number.... \\n"
                    },
                    {
                        "username": "Pritam-Padhan",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n==1) return true;\\n        if(n%2==0) return isUgly(n/2);\\n        else if(n%3==0) return isUgly(n/3);\\n        else if(n%5==0) return isUgly(n/5);\\n        else {\\n           return false;\\n        }\\n    }\\n}\\n\\nIn this code why i am getting stack over flow error"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "When `n = 0`, the condition of `if` will evaluate to `True`, hence it will recursively call `isUgly(0)`. This will initiate infinite recursion, because whenever `isUgly(0)` is called, `if` condition will be `True` and `isUgly(0)` will be called again. \n\nA quick fix is to follow definition and this line of code as first statement of function `isUgly(n)`\n\n```java\nif(n<=0) return false;\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Every number less than or equal to 0 is NOT an ugly number."
                    },
                    {
                        "username": "dollarSign",
                        "content": "This is the number = -2147483648 and its factors are 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2, so why its returning false? "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer is negative. And as per [problem description](https://leetcode.com/problems/ugly-number/discussion/), an ugly number is positive integer. Thus, `False` is correct."
                    }
                ]
            },
            {
                "id": 1688619,
                "content": [
                    {
                        "username": "sanjeev15002",
                        "content": "0 has no prime factors. Thus, its prime factors are limited to 2, 3 and 5 which should make 0 an ugly number. However, this question expects output \"False\" for input \"0\"."
                    },
                    {
                        "username": "sanjeev15002",
                        "content": "[@RohitSgh](/RohitSgh) Oh yes, my bad, I missed that! Thank you! "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "0 is **NOT** a positive integer. As per [problem description](https://leetcode.com/problems/ugly-number/description/), ugly number should be positive. \\n\\nThus, 0 cannot be ugly. Hence, `False` is justified."
                    },
                    {
                        "username": "Shankhadeep2017",
                        "content": "its Very simple questions .\\nall positive number n % 2 or n % 3 or n % 5 and reduce n = n//2, n = n // 3 , n = n // 5 used while n > 1\\nif n == 1 return true else false \\nfor example:\\nn = 20 \\n20 % 2 == 0\\n20 // 2 = 10\\n10 % 2 == 0\\n10 // 2 = 5\\n5 %  5 == 0\\n5 // 5 = 1\\nno we got 1 so ans is True\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Damn this problem has negative numbers... I passed 1003/1013 first try, now idk what to do with those negative numbers.."
                    },
                    {
                        "username": "rrajatutort",
                        "content": "Hi ,\\nMy code prints 8 as not ugly since it has 4 as prime factor. But leetcode expecting to return as ugly. Can someone explain what is wrong here?\\n\\nLeetcode result:\\n\\nn =\\n8\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue"
                    },
                    {
                        "username": "SDriscoll",
                        "content": "[@RohitSgh](/RohitSgh) That is not clear in the description, I should not need to read this many comments to find this explanation"
                    },
                    {
                        "username": "rrajatutort",
                        "content": "[@RohitSgh](/RohitSgh) Thanks for the explanation Rohit."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\n- The number should be positive ($> 0$)\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\{2, 3, 5\\}$\n\nNow, $8$ satisfies the first condition. For second condition, the set of prime factors of $8$ is $\\{2\\}$, since $8 = 2 \\cdot 2 \\cdot 2$, and $\\{2\\}$ is a subset of $\\{2, 3, 5\\}$. Thus `true` for $8$ is justified."
                    },
                    {
                        "username": "sam1906",
                        "content": "How is 12 ugly?\\n\\nThe answer should be false but compiler showed otherwise.\\n\\nhttps://imgur.com/t9Df0Ov"
                    },
                    {
                        "username": "sam1906",
                        "content": "Understood. Thanks for the explanation [@Rohit Singh](/RohitSgh) and [@Mitul Agrawal](/Mitulagr08)"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The set of prime factors of $12$ are $\\\\{2,3\\\\}$, since $12 = 2 \\\\times 2 \\\\times 3$. Since prime factors of $12$ are limited to $2, 3$ and $5$, (and $12$ is positive), it is Ugly Number. Hence, answer is `True`.\\n\\nWe don\\'t necessarily need all three factors in factorization. But all prime factors should be there in set  $\\\\{2,3,5\\\\}$."
                    },
                    {
                        "username": "Mitulagr",
                        "content": "12 = 2 x 2 x 3, so its prime factors are 2 and 3 only"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "<0 : not ugly\\n0 : not ugly\\n1 : ugly"
                    },
                    {
                        "username": "tarunjain_973",
                        "content": "can we do this question with seieve of erotisthenese for prime number.... \\n"
                    },
                    {
                        "username": "Pritam-Padhan",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n==1) return true;\\n        if(n%2==0) return isUgly(n/2);\\n        else if(n%3==0) return isUgly(n/3);\\n        else if(n%5==0) return isUgly(n/5);\\n        else {\\n           return false;\\n        }\\n    }\\n}\\n\\nIn this code why i am getting stack over flow error"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "When `n = 0`, the condition of `if` will evaluate to `True`, hence it will recursively call `isUgly(0)`. This will initiate infinite recursion, because whenever `isUgly(0)` is called, `if` condition will be `True` and `isUgly(0)` will be called again. \n\nA quick fix is to follow definition and this line of code as first statement of function `isUgly(n)`\n\n```java\nif(n<=0) return false;\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Every number less than or equal to 0 is NOT an ugly number."
                    },
                    {
                        "username": "dollarSign",
                        "content": "This is the number = -2147483648 and its factors are 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2, so why its returning false? "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer is negative. And as per [problem description](https://leetcode.com/problems/ugly-number/discussion/), an ugly number is positive integer. Thus, `False` is correct."
                    }
                ]
            },
            {
                "id": 1688614,
                "content": [
                    {
                        "username": "sanjeev15002",
                        "content": "0 has no prime factors. Thus, its prime factors are limited to 2, 3 and 5 which should make 0 an ugly number. However, this question expects output \"False\" for input \"0\"."
                    },
                    {
                        "username": "sanjeev15002",
                        "content": "[@RohitSgh](/RohitSgh) Oh yes, my bad, I missed that! Thank you! "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "0 is **NOT** a positive integer. As per [problem description](https://leetcode.com/problems/ugly-number/description/), ugly number should be positive. \\n\\nThus, 0 cannot be ugly. Hence, `False` is justified."
                    },
                    {
                        "username": "Shankhadeep2017",
                        "content": "its Very simple questions .\\nall positive number n % 2 or n % 3 or n % 5 and reduce n = n//2, n = n // 3 , n = n // 5 used while n > 1\\nif n == 1 return true else false \\nfor example:\\nn = 20 \\n20 % 2 == 0\\n20 // 2 = 10\\n10 % 2 == 0\\n10 // 2 = 5\\n5 %  5 == 0\\n5 // 5 = 1\\nno we got 1 so ans is True\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Damn this problem has negative numbers... I passed 1003/1013 first try, now idk what to do with those negative numbers.."
                    },
                    {
                        "username": "rrajatutort",
                        "content": "Hi ,\\nMy code prints 8 as not ugly since it has 4 as prime factor. But leetcode expecting to return as ugly. Can someone explain what is wrong here?\\n\\nLeetcode result:\\n\\nn =\\n8\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue"
                    },
                    {
                        "username": "SDriscoll",
                        "content": "[@RohitSgh](/RohitSgh) That is not clear in the description, I should not need to read this many comments to find this explanation"
                    },
                    {
                        "username": "rrajatutort",
                        "content": "[@RohitSgh](/RohitSgh) Thanks for the explanation Rohit."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\n- The number should be positive ($> 0$)\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\{2, 3, 5\\}$\n\nNow, $8$ satisfies the first condition. For second condition, the set of prime factors of $8$ is $\\{2\\}$, since $8 = 2 \\cdot 2 \\cdot 2$, and $\\{2\\}$ is a subset of $\\{2, 3, 5\\}$. Thus `true` for $8$ is justified."
                    },
                    {
                        "username": "sam1906",
                        "content": "How is 12 ugly?\\n\\nThe answer should be false but compiler showed otherwise.\\n\\nhttps://imgur.com/t9Df0Ov"
                    },
                    {
                        "username": "sam1906",
                        "content": "Understood. Thanks for the explanation [@Rohit Singh](/RohitSgh) and [@Mitul Agrawal](/Mitulagr08)"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The set of prime factors of $12$ are $\\\\{2,3\\\\}$, since $12 = 2 \\\\times 2 \\\\times 3$. Since prime factors of $12$ are limited to $2, 3$ and $5$, (and $12$ is positive), it is Ugly Number. Hence, answer is `True`.\\n\\nWe don\\'t necessarily need all three factors in factorization. But all prime factors should be there in set  $\\\\{2,3,5\\\\}$."
                    },
                    {
                        "username": "Mitulagr",
                        "content": "12 = 2 x 2 x 3, so its prime factors are 2 and 3 only"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "<0 : not ugly\\n0 : not ugly\\n1 : ugly"
                    },
                    {
                        "username": "tarunjain_973",
                        "content": "can we do this question with seieve of erotisthenese for prime number.... \\n"
                    },
                    {
                        "username": "Pritam-Padhan",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n==1) return true;\\n        if(n%2==0) return isUgly(n/2);\\n        else if(n%3==0) return isUgly(n/3);\\n        else if(n%5==0) return isUgly(n/5);\\n        else {\\n           return false;\\n        }\\n    }\\n}\\n\\nIn this code why i am getting stack over flow error"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "When `n = 0`, the condition of `if` will evaluate to `True`, hence it will recursively call `isUgly(0)`. This will initiate infinite recursion, because whenever `isUgly(0)` is called, `if` condition will be `True` and `isUgly(0)` will be called again. \n\nA quick fix is to follow definition and this line of code as first statement of function `isUgly(n)`\n\n```java\nif(n<=0) return false;\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Every number less than or equal to 0 is NOT an ugly number."
                    },
                    {
                        "username": "dollarSign",
                        "content": "This is the number = -2147483648 and its factors are 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2, so why its returning false? "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer is negative. And as per [problem description](https://leetcode.com/problems/ugly-number/discussion/), an ugly number is positive integer. Thus, `False` is correct."
                    }
                ]
            },
            {
                "id": 1688489,
                "content": [
                    {
                        "username": "sanjeev15002",
                        "content": "0 has no prime factors. Thus, its prime factors are limited to 2, 3 and 5 which should make 0 an ugly number. However, this question expects output \"False\" for input \"0\"."
                    },
                    {
                        "username": "sanjeev15002",
                        "content": "[@RohitSgh](/RohitSgh) Oh yes, my bad, I missed that! Thank you! "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "0 is **NOT** a positive integer. As per [problem description](https://leetcode.com/problems/ugly-number/description/), ugly number should be positive. \\n\\nThus, 0 cannot be ugly. Hence, `False` is justified."
                    },
                    {
                        "username": "Shankhadeep2017",
                        "content": "its Very simple questions .\\nall positive number n % 2 or n % 3 or n % 5 and reduce n = n//2, n = n // 3 , n = n // 5 used while n > 1\\nif n == 1 return true else false \\nfor example:\\nn = 20 \\n20 % 2 == 0\\n20 // 2 = 10\\n10 % 2 == 0\\n10 // 2 = 5\\n5 %  5 == 0\\n5 // 5 = 1\\nno we got 1 so ans is True\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Damn this problem has negative numbers... I passed 1003/1013 first try, now idk what to do with those negative numbers.."
                    },
                    {
                        "username": "rrajatutort",
                        "content": "Hi ,\\nMy code prints 8 as not ugly since it has 4 as prime factor. But leetcode expecting to return as ugly. Can someone explain what is wrong here?\\n\\nLeetcode result:\\n\\nn =\\n8\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue"
                    },
                    {
                        "username": "SDriscoll",
                        "content": "[@RohitSgh](/RohitSgh) That is not clear in the description, I should not need to read this many comments to find this explanation"
                    },
                    {
                        "username": "rrajatutort",
                        "content": "[@RohitSgh](/RohitSgh) Thanks for the explanation Rohit."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\n- The number should be positive ($> 0$)\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\{2, 3, 5\\}$\n\nNow, $8$ satisfies the first condition. For second condition, the set of prime factors of $8$ is $\\{2\\}$, since $8 = 2 \\cdot 2 \\cdot 2$, and $\\{2\\}$ is a subset of $\\{2, 3, 5\\}$. Thus `true` for $8$ is justified."
                    },
                    {
                        "username": "sam1906",
                        "content": "How is 12 ugly?\\n\\nThe answer should be false but compiler showed otherwise.\\n\\nhttps://imgur.com/t9Df0Ov"
                    },
                    {
                        "username": "sam1906",
                        "content": "Understood. Thanks for the explanation [@Rohit Singh](/RohitSgh) and [@Mitul Agrawal](/Mitulagr08)"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The set of prime factors of $12$ are $\\\\{2,3\\\\}$, since $12 = 2 \\\\times 2 \\\\times 3$. Since prime factors of $12$ are limited to $2, 3$ and $5$, (and $12$ is positive), it is Ugly Number. Hence, answer is `True`.\\n\\nWe don\\'t necessarily need all three factors in factorization. But all prime factors should be there in set  $\\\\{2,3,5\\\\}$."
                    },
                    {
                        "username": "Mitulagr",
                        "content": "12 = 2 x 2 x 3, so its prime factors are 2 and 3 only"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "<0 : not ugly\\n0 : not ugly\\n1 : ugly"
                    },
                    {
                        "username": "tarunjain_973",
                        "content": "can we do this question with seieve of erotisthenese for prime number.... \\n"
                    },
                    {
                        "username": "Pritam-Padhan",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n==1) return true;\\n        if(n%2==0) return isUgly(n/2);\\n        else if(n%3==0) return isUgly(n/3);\\n        else if(n%5==0) return isUgly(n/5);\\n        else {\\n           return false;\\n        }\\n    }\\n}\\n\\nIn this code why i am getting stack over flow error"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "When `n = 0`, the condition of `if` will evaluate to `True`, hence it will recursively call `isUgly(0)`. This will initiate infinite recursion, because whenever `isUgly(0)` is called, `if` condition will be `True` and `isUgly(0)` will be called again. \n\nA quick fix is to follow definition and this line of code as first statement of function `isUgly(n)`\n\n```java\nif(n<=0) return false;\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Every number less than or equal to 0 is NOT an ugly number."
                    },
                    {
                        "username": "dollarSign",
                        "content": "This is the number = -2147483648 and its factors are 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2, so why its returning false? "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer is negative. And as per [problem description](https://leetcode.com/problems/ugly-number/discussion/), an ugly number is positive integer. Thus, `False` is correct."
                    }
                ]
            },
            {
                "id": 1688450,
                "content": [
                    {
                        "username": "sanjeev15002",
                        "content": "0 has no prime factors. Thus, its prime factors are limited to 2, 3 and 5 which should make 0 an ugly number. However, this question expects output \"False\" for input \"0\"."
                    },
                    {
                        "username": "sanjeev15002",
                        "content": "[@RohitSgh](/RohitSgh) Oh yes, my bad, I missed that! Thank you! "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "0 is **NOT** a positive integer. As per [problem description](https://leetcode.com/problems/ugly-number/description/), ugly number should be positive. \\n\\nThus, 0 cannot be ugly. Hence, `False` is justified."
                    },
                    {
                        "username": "Shankhadeep2017",
                        "content": "its Very simple questions .\\nall positive number n % 2 or n % 3 or n % 5 and reduce n = n//2, n = n // 3 , n = n // 5 used while n > 1\\nif n == 1 return true else false \\nfor example:\\nn = 20 \\n20 % 2 == 0\\n20 // 2 = 10\\n10 % 2 == 0\\n10 // 2 = 5\\n5 %  5 == 0\\n5 // 5 = 1\\nno we got 1 so ans is True\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Damn this problem has negative numbers... I passed 1003/1013 first try, now idk what to do with those negative numbers.."
                    },
                    {
                        "username": "rrajatutort",
                        "content": "Hi ,\\nMy code prints 8 as not ugly since it has 4 as prime factor. But leetcode expecting to return as ugly. Can someone explain what is wrong here?\\n\\nLeetcode result:\\n\\nn =\\n8\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue"
                    },
                    {
                        "username": "SDriscoll",
                        "content": "[@RohitSgh](/RohitSgh) That is not clear in the description, I should not need to read this many comments to find this explanation"
                    },
                    {
                        "username": "rrajatutort",
                        "content": "[@RohitSgh](/RohitSgh) Thanks for the explanation Rohit."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\n- The number should be positive ($> 0$)\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\{2, 3, 5\\}$\n\nNow, $8$ satisfies the first condition. For second condition, the set of prime factors of $8$ is $\\{2\\}$, since $8 = 2 \\cdot 2 \\cdot 2$, and $\\{2\\}$ is a subset of $\\{2, 3, 5\\}$. Thus `true` for $8$ is justified."
                    },
                    {
                        "username": "sam1906",
                        "content": "How is 12 ugly?\\n\\nThe answer should be false but compiler showed otherwise.\\n\\nhttps://imgur.com/t9Df0Ov"
                    },
                    {
                        "username": "sam1906",
                        "content": "Understood. Thanks for the explanation [@Rohit Singh](/RohitSgh) and [@Mitul Agrawal](/Mitulagr08)"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The set of prime factors of $12$ are $\\\\{2,3\\\\}$, since $12 = 2 \\\\times 2 \\\\times 3$. Since prime factors of $12$ are limited to $2, 3$ and $5$, (and $12$ is positive), it is Ugly Number. Hence, answer is `True`.\\n\\nWe don\\'t necessarily need all three factors in factorization. But all prime factors should be there in set  $\\\\{2,3,5\\\\}$."
                    },
                    {
                        "username": "Mitulagr",
                        "content": "12 = 2 x 2 x 3, so its prime factors are 2 and 3 only"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "<0 : not ugly\\n0 : not ugly\\n1 : ugly"
                    },
                    {
                        "username": "tarunjain_973",
                        "content": "can we do this question with seieve of erotisthenese for prime number.... \\n"
                    },
                    {
                        "username": "Pritam-Padhan",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n==1) return true;\\n        if(n%2==0) return isUgly(n/2);\\n        else if(n%3==0) return isUgly(n/3);\\n        else if(n%5==0) return isUgly(n/5);\\n        else {\\n           return false;\\n        }\\n    }\\n}\\n\\nIn this code why i am getting stack over flow error"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "When `n = 0`, the condition of `if` will evaluate to `True`, hence it will recursively call `isUgly(0)`. This will initiate infinite recursion, because whenever `isUgly(0)` is called, `if` condition will be `True` and `isUgly(0)` will be called again. \n\nA quick fix is to follow definition and this line of code as first statement of function `isUgly(n)`\n\n```java\nif(n<=0) return false;\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Every number less than or equal to 0 is NOT an ugly number."
                    },
                    {
                        "username": "dollarSign",
                        "content": "This is the number = -2147483648 and its factors are 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2, so why its returning false? "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer is negative. And as per [problem description](https://leetcode.com/problems/ugly-number/discussion/), an ugly number is positive integer. Thus, `False` is correct."
                    }
                ]
            },
            {
                "id": 1688429,
                "content": [
                    {
                        "username": "sanjeev15002",
                        "content": "0 has no prime factors. Thus, its prime factors are limited to 2, 3 and 5 which should make 0 an ugly number. However, this question expects output \"False\" for input \"0\"."
                    },
                    {
                        "username": "sanjeev15002",
                        "content": "[@RohitSgh](/RohitSgh) Oh yes, my bad, I missed that! Thank you! "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "0 is **NOT** a positive integer. As per [problem description](https://leetcode.com/problems/ugly-number/description/), ugly number should be positive. \\n\\nThus, 0 cannot be ugly. Hence, `False` is justified."
                    },
                    {
                        "username": "Shankhadeep2017",
                        "content": "its Very simple questions .\\nall positive number n % 2 or n % 3 or n % 5 and reduce n = n//2, n = n // 3 , n = n // 5 used while n > 1\\nif n == 1 return true else false \\nfor example:\\nn = 20 \\n20 % 2 == 0\\n20 // 2 = 10\\n10 % 2 == 0\\n10 // 2 = 5\\n5 %  5 == 0\\n5 // 5 = 1\\nno we got 1 so ans is True\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Damn this problem has negative numbers... I passed 1003/1013 first try, now idk what to do with those negative numbers.."
                    },
                    {
                        "username": "rrajatutort",
                        "content": "Hi ,\\nMy code prints 8 as not ugly since it has 4 as prime factor. But leetcode expecting to return as ugly. Can someone explain what is wrong here?\\n\\nLeetcode result:\\n\\nn =\\n8\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue"
                    },
                    {
                        "username": "SDriscoll",
                        "content": "[@RohitSgh](/RohitSgh) That is not clear in the description, I should not need to read this many comments to find this explanation"
                    },
                    {
                        "username": "rrajatutort",
                        "content": "[@RohitSgh](/RohitSgh) Thanks for the explanation Rohit."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\n- The number should be positive ($> 0$)\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\{2, 3, 5\\}$\n\nNow, $8$ satisfies the first condition. For second condition, the set of prime factors of $8$ is $\\{2\\}$, since $8 = 2 \\cdot 2 \\cdot 2$, and $\\{2\\}$ is a subset of $\\{2, 3, 5\\}$. Thus `true` for $8$ is justified."
                    },
                    {
                        "username": "sam1906",
                        "content": "How is 12 ugly?\\n\\nThe answer should be false but compiler showed otherwise.\\n\\nhttps://imgur.com/t9Df0Ov"
                    },
                    {
                        "username": "sam1906",
                        "content": "Understood. Thanks for the explanation [@Rohit Singh](/RohitSgh) and [@Mitul Agrawal](/Mitulagr08)"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The set of prime factors of $12$ are $\\\\{2,3\\\\}$, since $12 = 2 \\\\times 2 \\\\times 3$. Since prime factors of $12$ are limited to $2, 3$ and $5$, (and $12$ is positive), it is Ugly Number. Hence, answer is `True`.\\n\\nWe don\\'t necessarily need all three factors in factorization. But all prime factors should be there in set  $\\\\{2,3,5\\\\}$."
                    },
                    {
                        "username": "Mitulagr",
                        "content": "12 = 2 x 2 x 3, so its prime factors are 2 and 3 only"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "<0 : not ugly\\n0 : not ugly\\n1 : ugly"
                    },
                    {
                        "username": "tarunjain_973",
                        "content": "can we do this question with seieve of erotisthenese for prime number.... \\n"
                    },
                    {
                        "username": "Pritam-Padhan",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n==1) return true;\\n        if(n%2==0) return isUgly(n/2);\\n        else if(n%3==0) return isUgly(n/3);\\n        else if(n%5==0) return isUgly(n/5);\\n        else {\\n           return false;\\n        }\\n    }\\n}\\n\\nIn this code why i am getting stack over flow error"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "When `n = 0`, the condition of `if` will evaluate to `True`, hence it will recursively call `isUgly(0)`. This will initiate infinite recursion, because whenever `isUgly(0)` is called, `if` condition will be `True` and `isUgly(0)` will be called again. \n\nA quick fix is to follow definition and this line of code as first statement of function `isUgly(n)`\n\n```java\nif(n<=0) return false;\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Every number less than or equal to 0 is NOT an ugly number."
                    },
                    {
                        "username": "dollarSign",
                        "content": "This is the number = -2147483648 and its factors are 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2, so why its returning false? "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer is negative. And as per [problem description](https://leetcode.com/problems/ugly-number/discussion/), an ugly number is positive integer. Thus, `False` is correct."
                    }
                ]
            },
            {
                "id": 1688405,
                "content": [
                    {
                        "username": "sanjeev15002",
                        "content": "0 has no prime factors. Thus, its prime factors are limited to 2, 3 and 5 which should make 0 an ugly number. However, this question expects output \"False\" for input \"0\"."
                    },
                    {
                        "username": "sanjeev15002",
                        "content": "[@RohitSgh](/RohitSgh) Oh yes, my bad, I missed that! Thank you! "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "0 is **NOT** a positive integer. As per [problem description](https://leetcode.com/problems/ugly-number/description/), ugly number should be positive. \\n\\nThus, 0 cannot be ugly. Hence, `False` is justified."
                    },
                    {
                        "username": "Shankhadeep2017",
                        "content": "its Very simple questions .\\nall positive number n % 2 or n % 3 or n % 5 and reduce n = n//2, n = n // 3 , n = n // 5 used while n > 1\\nif n == 1 return true else false \\nfor example:\\nn = 20 \\n20 % 2 == 0\\n20 // 2 = 10\\n10 % 2 == 0\\n10 // 2 = 5\\n5 %  5 == 0\\n5 // 5 = 1\\nno we got 1 so ans is True\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Damn this problem has negative numbers... I passed 1003/1013 first try, now idk what to do with those negative numbers.."
                    },
                    {
                        "username": "rrajatutort",
                        "content": "Hi ,\\nMy code prints 8 as not ugly since it has 4 as prime factor. But leetcode expecting to return as ugly. Can someone explain what is wrong here?\\n\\nLeetcode result:\\n\\nn =\\n8\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue"
                    },
                    {
                        "username": "SDriscoll",
                        "content": "[@RohitSgh](/RohitSgh) That is not clear in the description, I should not need to read this many comments to find this explanation"
                    },
                    {
                        "username": "rrajatutort",
                        "content": "[@RohitSgh](/RohitSgh) Thanks for the explanation Rohit."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per definition, an ugly number should satisfy two conditions:\n- The number should be positive ($> 0$)\n- The set of prime factors of number should be *subset* (because definition mentions *limited*) of $\\{2, 3, 5\\}$\n\nNow, $8$ satisfies the first condition. For second condition, the set of prime factors of $8$ is $\\{2\\}$, since $8 = 2 \\cdot 2 \\cdot 2$, and $\\{2\\}$ is a subset of $\\{2, 3, 5\\}$. Thus `true` for $8$ is justified."
                    },
                    {
                        "username": "sam1906",
                        "content": "How is 12 ugly?\\n\\nThe answer should be false but compiler showed otherwise.\\n\\nhttps://imgur.com/t9Df0Ov"
                    },
                    {
                        "username": "sam1906",
                        "content": "Understood. Thanks for the explanation [@Rohit Singh](/RohitSgh) and [@Mitul Agrawal](/Mitulagr08)"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The set of prime factors of $12$ are $\\\\{2,3\\\\}$, since $12 = 2 \\\\times 2 \\\\times 3$. Since prime factors of $12$ are limited to $2, 3$ and $5$, (and $12$ is positive), it is Ugly Number. Hence, answer is `True`.\\n\\nWe don\\'t necessarily need all three factors in factorization. But all prime factors should be there in set  $\\\\{2,3,5\\\\}$."
                    },
                    {
                        "username": "Mitulagr",
                        "content": "12 = 2 x 2 x 3, so its prime factors are 2 and 3 only"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "<0 : not ugly\\n0 : not ugly\\n1 : ugly"
                    },
                    {
                        "username": "tarunjain_973",
                        "content": "can we do this question with seieve of erotisthenese for prime number.... \\n"
                    },
                    {
                        "username": "Pritam-Padhan",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public boolean isUgly(int n) {\\n        if(n==1) return true;\\n        if(n%2==0) return isUgly(n/2);\\n        else if(n%3==0) return isUgly(n/3);\\n        else if(n%5==0) return isUgly(n/5);\\n        else {\\n           return false;\\n        }\\n    }\\n}\\n\\nIn this code why i am getting stack over flow error"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "When `n = 0`, the condition of `if` will evaluate to `True`, hence it will recursively call `isUgly(0)`. This will initiate infinite recursion, because whenever `isUgly(0)` is called, `if` condition will be `True` and `isUgly(0)` will be called again. \n\nA quick fix is to follow definition and this line of code as first statement of function `isUgly(n)`\n\n```java\nif(n<=0) return false;\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Every number less than or equal to 0 is NOT an ugly number."
                    },
                    {
                        "username": "dollarSign",
                        "content": "This is the number = -2147483648 and its factors are 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2, so why its returning false? "
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The integer is negative. And as per [problem description](https://leetcode.com/problems/ugly-number/discussion/), an ugly number is positive integer. Thus, `False` is correct."
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Length of Repeated Subarray",
        "question_content": "<p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>the maximum length of a subarray that appears in <strong>both</strong> arrays</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The repeated subarray with maximum length is [3,2,1].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The repeated subarray with maximum length is [0,0,0,0,0].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1324248,
                "title": "c-python-dp-kmp-hashing-solutions-clean-concise-o-nlogn",
                "content": "**\\u2714\\uFE0F  Solution 1: Dynamic Programming**\\n- It\\'s the classic **Longest Common Substring** problem, can be used by using Dynamic Programming.\\n- Let `dp[i][j]` is the longest common suffix between `nums1[0..i-1]` and `nums2[0..j-1]`.\\n\\n<iframe src=\"https://leetcode.com/playground/dhfVqvSQ/shared\" frameBorder=\"0\" width=\"100%\" height=\"360\"></iframe>\\n\\nComplexity:\\n- Time: `O(M*N)`, where `M <= 1000` is length of `nums1`, `N <= 1000` is length of `nums2`.\\n- Space: `O(M*N)`\\n\\n- - -\\n**\\u2714\\uFE0F  Solution 2: Dynamic Programming (Space Optimized)**\\n- Since our dp only access the previous dp state and current dp state, so we can use 2 variable `dp`, `prevDP` which will optimize space to `O(N)`.\\n\\n<iframe src=\"https://leetcode.com/playground/3tWvLU6K/shared\" frameBorder=\"0\" width=\"100%\" height=\"400\"></iframe>\\n\\nComplexity:\\n- Time: `O(M*N)`, where `M <= 1000` is the maximum, `N <= 1000` is the minimum between length of `nums1` and length of `nums2` coressponding.\\n- Space: `O(N)`\\n- - -\\n**\\u2714\\uFE0F  Solution 3: KMP Solution**\\n<details>\\n  <summary>Click to see detail</summary>\\n  \\n  - The basic problem of KMP is that: Given a string `s` and a pattern `p`, return the indices of the occurrences of `p` in `s`.\\n- While doing KMP matching between `s` and `p`, we can have the longest matching between substring of `s` with prefix of `p`.\\n- The idea is that, we try all patterns `p\\'` = `p[0..n-1]`, `[1..n-1]`, ..., `[n-1..n-1]`, and keep update the longest matching between substring of `s`and patterns `p\\'`.\\n```python\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        if len(nums1) < len(nums2): \\n            return self.findLength(nums2, nums1)  # Make sure len(nums1) > len(nums2) to optimize time & space\\n\\n        def computeKMP(pattern):\\n            n = len(pattern)\\n            lps = [0] * n\\n            j = 0\\n            for i in range(1, n):\\n                while j > 0 and pattern[i] != pattern[j]: j = lps[j - 1]\\n                if pattern[i] == pattern[j]: j += 1\\n                lps[i] = j\\n            return lps\\n\\n        ans = 0\\n        while len(nums2) > ans:\\n            lps = computeKMP(nums2)\\n            j = 0  # pattern pointer\\n            for i in range(len(nums1)):\\n                while j > 0 and nums1[i] != nums2[j]: j = lps[j - 1]\\n                if nums1[i] == nums2[j]: j += 1\\n                ans = max(ans, j)  # update longest matching between prefix of P and substring of S so far\\n                if j == len(nums2):  # if P was found in S\\n                    j = lps[j - 1]\\n            del nums2[0]\\n        return ans\\n```\\nComplexity:\\n- Time: `O(N*(M + N))`, where `M <= 1000` is the maximum, `N <= 1000` is the minimum between length of `nums1` and length of `nums2` coressponding.\\n- Space: `O(N)`\\n</details>\\n\\n**\\u2714\\uFE0F Solution 4: Polynomial rolling hash Solution**\\n- Pre-compute [**Polynomial rolling hash** ](https://en.wikipedia.org/wiki/Rolling_hash) of `nums1` and `nums2`, so that we can get the hash value of an arbitrary subarray in `O(1)`.\\n\\t- We need to choose a good `BASE` and `MOD` so that collision only happens rarely if have. \\n\\t- `BASE` should be a prime number >= maximum the maximum of all numbers, here I choose `BASE = 101`.\\n\\t- `MOD` should be a prime number large enough. In C++, I use `long long` type and leave it overflow by default. In Python, I used a  big `MOD` to limit their value.\\n- Then we binary search to find the **maximum size of subarray** which appears in both `nums1` and `nums2`.\\n- How to check if we can found any subarray of size `size` in both `nums1` and `nums2`?\\n\\t- Firstly, we iterate `i = 0..m-size+1` to get all hashing values of subarray of size `size` in the `nums1`, and put them into HashMap, let name it `seen`.\\n\\t- Secondly, we iterate `i = 0..n-size+1` to get all hashing values of subarray of size `size` in the `nums2`, if any `hash` is already found in `seen`, then it\\'s a possible there is a subarray which exists in both `nums1` and `nums2`. To make sure, we can do double-checking for it.\\n\\t- Return TRUE, if we found a valid subarray which exists in both `nums1` and `nums2`, else return FALSE.\\n\\n<iframe src=\"https://leetcode.com/playground/6rsZMoTn/shared\" frameBorder=\"0\" width=\"100%\" height=\"780\"></iframe>\\n\\nComplexity:\\n- Time: `O((M+N) * logN)`, where `M <= 1000` is the maximum, `N <= 1000` is the minimum between length of `nums1` and length of `nums2` coressponding.\\n- Space: `O(M + N)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome**! Thanks.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        if len(nums1) < len(nums2): \\n            return self.findLength(nums2, nums1)  # Make sure len(nums1) > len(nums2) to optimize time & space\\n\\n        def computeKMP(pattern):\\n            n = len(pattern)\\n            lps = [0] * n\\n            j = 0\\n            for i in range(1, n):\\n                while j > 0 and pattern[i] != pattern[j]: j = lps[j - 1]\\n                if pattern[i] == pattern[j]: j += 1\\n                lps[i] = j\\n            return lps\\n\\n        ans = 0\\n        while len(nums2) > ans:\\n            lps = computeKMP(nums2)\\n            j = 0  # pattern pointer\\n            for i in range(len(nums1)):\\n                while j > 0 and nums1[i] != nums2[j]: j = lps[j - 1]\\n                if nums1[i] == nums2[j]: j += 1\\n                ans = max(ans, j)  # update longest matching between prefix of P and substring of S so far\\n                if j == len(nums2):  # if P was found in S\\n                    j = lps[j - 1]\\n            del nums2[0]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109039,
                "title": "concise-java-dp-same-idea-of-longest-common-substring",
                "content": "The code explains itself:\\n```\\n\\nclass Solution {\\n    public int findLength(int[] A, int[] B) {\\n        if(A == null||B == null) return 0;\\n        int m = A.length;\\n        int n = B.length;\\n        int max = 0;\\n        //dp[i][j] is the length of longest common subarray ending with nums[i] and nums[j]\\n        int[][] dp = new int[m + 1][n + 1];\\n        for(int i = 0;i <= m;i++){\\n            for(int j = 0;j <= n;j++){\\n                if(i == 0 || j == 0){\\n                    dp[i][j] = 0;\\n                }\\n                else{\\n                    if(A[i - 1] == B[j - 1]){\\n                        dp[i][j] = 1 + dp[i - 1][j - 1];\\n                        max = Math.max(max,dp[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\nHope it helps!",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int findLength(int[] A, int[] B) {\\n        if(A == null||B == null) return 0;\\n        int m = A.length;\\n        int n = B.length;\\n        int max = 0;\\n        //dp[i][j] is the length of longest common subarray ending with nums[i] and nums[j]\\n        int[][] dp = new int[m + 1][n + 1];\\n        for(int i = 0;i <= m;i++){\\n            for(int j = 0;j <= n;j++){\\n                if(i == 0 || j == 0){\\n                    dp[i][j] = 0;\\n                }\\n                else{\\n                    if(A[i - 1] == B[j - 1]){\\n                        dp[i][j] = 1 + dp[i - 1][j - 1];\\n                        max = Math.max(max,dp[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324737,
                "title": "optimization-from-brute-force-to-dp-to-space-optimized-dp-explained",
                "content": "\\u274C ***Solution - I (Brute-Force)***\\n\\nWe need to find maximum length of common subarray between `A` and `B`. Let\\'s try solving it starting with brute-force approach. \\n\\nWe know that the maximum common subarray will start at some indices `i` and `j` of array `A` and `B` respectively. So, we will just simply take each possible pair `(i, j)` and try to extend it from there to get maximum common subarray starting at that index pair. Finally, we will return the max length found after trying out all pairs\\n\\n* **Recursive Version :** \\n\\t```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint ans = 0;\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n\\t\\t\\tsolve(A, B, 0, 0);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tint solve(vector<int>& A, vector<int>& B, int i, int j) {\\n\\t\\t\\tif(i >= size(A) || j >= size(B)) return 0;\\n\\t\\t\\tsolve(A, B, i+1, j), solve(A, B, i, j+1);                   // recurse to solve for each possible (i, j)\\n\\t\\t\\tint common = A[i] == B[j] ? 1 + solve(A, B, i+1, j+1) : 0;  // longest common subarray starting at A[i] & B[j]\\n\\t\\t\\tans = max(ans, common);                                     // update ans to hold max length found till now\\n\\t\\t\\treturn common;\\n\\t\\t}\\n\\t};\\t\\n\\t```\\n\\t\\n\\t***Time Complexity :***  <b><code>O(3<sup>M + N</sup>)</code></b>, where `M` is size of `A` and `N` is size of `B`. We have 3 choices at each recursion and max recursion depth is `M+N`.\\n\\t***Space Complexity :***  **`O(M + N)`**, max depth of recursive stack. \\n\\t\\n\\t---\\n\\n* **Iterative Version :**\\n\\n\\t```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n\\t\\t\\tint m = size(A), n = size(B), ans = 0;\\n\\t\\t\\tfor(int i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\t\\t\\tint len = 0;\\n\\t\\t\\t\\t\\twhile(i + len < m and j + len < n and A[i+len] == B[j+len]) len++; // get length of longest common subarray starting at A[i] & B[j]\\n\\t\\t\\t\\t\\tans = max(ans, len);  // update ans to hold max length found till now\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\t\\n\\t```\\n\\t\\n\\t***Time Complexity :***  **`O(M * N * min(M,N))`**, Here, at each possible `(i, j)` we find longest common subarray. There at total of `M*N` pairs and we can extend at max `O(min(M, N))` from each pair.\\n\\t***Space Complexity :***  **`O(1)`**\\n\\n\\n\\t\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Dynamic Programming)***\\n\\nWe can see that the length of common subarray starting at `A[i]` and `B[i]` will always be same. But we are still re-calculating the same multiple times in the brute force approaches. Instead, we could store the answer for a given pair of indices and re-use it in the future instead of re-calculating over and over. Thus, we can apply dynamic programming here.\\n\\nHere, we are using `dp` matrix where `dp[i][j]` will denote longest common subarray starting at `A[i]` and `B[j]`. Once we calculate the result for `dp[i][j]`, it can be re-used whenever required in the future recursive calls / iterations.\\n\\n* **Recursive DP - Memoization :**\\n\\n\\t```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>>dp;\\n\\t\\tint ans = 0;\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n\\t\\t\\tdp.resize(size(A), vector<int>(size(B), -1));\\n\\t\\t\\tsolve(A, B, 0, 0);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tint solve(vector<int>& A, vector<int>& B, int i, int j) {\\n\\t\\t\\tif(i >= size(A) || j >= size(B)) return 0;\\n\\t\\t\\tif(dp[i][j] != -1) return dp[i][j];\\n\\t\\t\\tsolve(A, B, i+1, j), solve(A, B, i, j+1);\\n\\t\\t\\tdp[i][j] = A[i] == B[j] ? solve(A, B, i+1, j+1) + 1 : 0;  // store the result for state (i, j) for future\\n\\t\\t\\tans = max(ans, dp[i][j]);\\n\\t\\t\\treturn dp[i][j];\\n\\t\\t}\\n\\t};\\t\\n\\t```\\n\\t\\n\\t---\\n\\t\\n* **Iterative DP - Tabulation :**\\n\\t\\n\\t```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n\\t\\t\\tint m = size(A), n = size(B), ans = 0, dp[m+1][n+1]; \\n\\t\\t\\tmemset(dp, -1, sizeof dp);\\n\\t\\t\\tfor(int i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor(int j = 0, len = 0; j < n; j++) {\\n\\t\\t\\t\\t\\tif(dp[i][j] == -1) {\\n\\t\\t\\t\\t\\t\\twhile(i + len < m and j + len < n and A[i+len] == B[j+len]) len++;\\n\\t\\t\\t\\t\\t\\twhile(len) dp[i + len][j + len] = len--;  // store the result for states (i, j) : \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  // we know results for all states from (i, j) - (i+len, j+len)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tans = max(ans, dp[i][j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\t\\n\\t```\\n   \\n     I have mentioned the above approach as a direct DP integration into brute-force solution. It can be seen that it\\'s probably better to start from the end of both array so that we don\\'t need to forward iterate once (for finding longest subarray length) and then re-iterate backward again (for storing the results in `dp`). The above code can be re-written as -\\n\\t \\n\\t ```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n\\t\\t\\tint m = size(A), n = size(B), ans = 0, dp[m+1][n+1]; \\n\\t\\t\\tmemset(dp, 0, sizeof dp);\\n\\t\\t\\tfor(int i = m-1; ~i; i--) \\n\\t\\t\\t\\tfor(int j = n-1; ~j; j--) \\n\\t\\t\\t\\t\\tdp[i][j] = A[i-1] == B[j-1] ? dp[i+1][j+1] + 1 : 0,\\n\\t\\t\\t\\t\\tans = max(ans, dp[i][j]);\\n\\t\\t\\t\\t\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\t\\t \\n\\t ```\\n\\n***Time Complexity :***  **`O(M * N)`**, In both the approaches, we calculate the result for an index pair `(i, j)` only once\\n***Space Complexity :***  **`O(M * N)`**, required to store `dp` matrix.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Another DP Variant)***\\n\\nWe can solve this using dp in another way. Instead of storing the longest common substring starting at `(i, j)` index pair (i.e longest common prefix subarray), we can store the longest common substring ending at `(i, j)` as well (i.e longest common suffix subarray). Here `dp[i][j]` will denote longest subarray ending at `A[i]` and `B[j]` -\\n\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        int m = size(A), n = size(B), ans = 0;\\n\\t\\tint dp[m+1][n+1]; memset(dp, 0, sizeof dp);\\n        for(int i = 1; i <= m; i++) \\n            for(int j = 1; j <= n; j++) \\n                dp[i][j] = A[i-1] == B[j-1] ? dp[i-1][j-1] + 1 : 0,\\n                ans = max(ans, dp[i][j]);\\n            \\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :***  **`O(M * N)`**\\n***Space Complexity :***  **`O(M * N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Space-Optimized DP)***\\n\\nWe can see that in both the dp variants, we are only ever accessing the current previous rows of the `dp` matrix. So we don\\'t need to store all the dp matrix throughout our program. We just need to store the current row and the previous row of `dp` at any given point of time. Thus we can optimize the space usage to linear complexity.\\n\\nA common way to optimize from 2D DP to 1D DP is to just declare a two row matrix and alternate between the rows at each iteration. We declare two variables `cur` and `prev` and alternate them for each row.\\n\\n* **1st DP Variant - Space Optimized :**\\n\\n\\t```\\n\\tclass Solution {\\n\\tpublic:\\n\\t   int findLength(vector<int>& A, vector<int>& B) {\\n\\t\\tif(size(A) < size(B)) A.swap(B);   // ensures dp length is min(M, N)\\n\\t\\tint m = size(A), n = size(B), ans = 0, dp[2][n+1]; \\n\\t\\tmemset(dp, 0, sizeof dp);\\n\\t\\tfor(int i = m-1, cur=i&1, next=!(i&1); ~i; i--, cur ^= 1, next ^= 1) // ~i ends loop when i goes -ve, ^= 1 used to flip bit\\n\\t\\t\\tfor(int j = n-1; ~j; j--) \\n\\t\\t\\t\\tdp[cur][j] = A[i] == B[j] ? dp[next][j+1] + 1 : 0,\\n\\t\\t\\t\\tans = max(ans, dp[cur][j]);\\n\\t\\t\\t\\n\\t\\treturn ans;\\n\\t   }\\n\\t};\\t\\t\\n\\t```\\n\\t\\n\\t---\\n\\n* **2nd DP Variant - Space Optimized :**\\n\\n\\t```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n\\t\\t\\tif(size(A) < size(B)) A.swap(B); \\n\\t\\t\\tint m = size(A), n = size(B), ans = 0, dp[2][n+1]; \\n\\t\\t\\tmemset(dp, 0, sizeof dp);\\n\\t\\t\\tfor(int i = 1, cur = 1, prev{}; i <= m; i++, cur ^= 1, prev ^= 1) \\n\\t\\t\\t\\tfor(int j = 1; j <= n; j++) \\n\\t\\t\\t\\t\\tdp[cur][j] = A[i-1] == B[j-1] ? dp[prev][j-1] + 1 : 0,\\n\\t\\t\\t\\t\\tans = max(ans, dp[cur][j]);\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\t\\n\\t```\\n\\t\\n\\n\\n\\n***Time Complexity :***  **`O(M * N)`**\\n***Space Complexity :***  **`O(min(M, N))`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint ans = 0;\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n\\t\\t\\tsolve(A, B, 0, 0);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tint solve(vector<int>& A, vector<int>& B, int i, int j) {\\n\\t\\t\\tif(i >= size(A) || j >= size(B)) return 0;\\n\\t\\t\\tsolve(A, B, i+1, j), solve(A, B, i, j+1);                   // recurse to solve for each possible (i, j)\\n\\t\\t\\tint common = A[i] == B[j] ? 1 + solve(A, B, i+1, j+1) : 0;  // longest common subarray starting at A[i] & B[j]\\n\\t\\t\\tans = max(ans, common);                                     // update ans to hold max length found till now\\n\\t\\t\\treturn common;\\n\\t\\t}\\n\\t};\\t\\n\\t```\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n\\t\\t\\tint m = size(A), n = size(B), ans = 0;\\n\\t\\t\\tfor(int i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\t\\t\\tint len = 0;\\n\\t\\t\\t\\t\\twhile(i + len < m and j + len < n and A[i+len] == B[j+len]) len++; // get length of longest common subarray starting at A[i] & B[j]\\n\\t\\t\\t\\t\\tans = max(ans, len);  // update ans to hold max length found till now\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\t\\n\\t```\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>>dp;\\n\\t\\tint ans = 0;\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n\\t\\t\\tdp.resize(size(A), vector<int>(size(B), -1));\\n\\t\\t\\tsolve(A, B, 0, 0);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tint solve(vector<int>& A, vector<int>& B, int i, int j) {\\n\\t\\t\\tif(i >= size(A) || j >= size(B)) return 0;\\n\\t\\t\\tif(dp[i][j] != -1) return dp[i][j];\\n\\t\\t\\tsolve(A, B, i+1, j), solve(A, B, i, j+1);\\n\\t\\t\\tdp[i][j] = A[i] == B[j] ? solve(A, B, i+1, j+1) + 1 : 0;  // store the result for state (i, j) for future\\n\\t\\t\\tans = max(ans, dp[i][j]);\\n\\t\\t\\treturn dp[i][j];\\n\\t\\t}\\n\\t};\\t\\n\\t```\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n\\t\\t\\tint m = size(A), n = size(B), ans = 0, dp[m+1][n+1]; \\n\\t\\t\\tmemset(dp, -1, sizeof dp);\\n\\t\\t\\tfor(int i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor(int j = 0, len = 0; j < n; j++) {\\n\\t\\t\\t\\t\\tif(dp[i][j] == -1) {\\n\\t\\t\\t\\t\\t\\twhile(i + len < m and j + len < n and A[i+len] == B[j+len]) len++;\\n\\t\\t\\t\\t\\t\\twhile(len) dp[i + len][j + len] = len--;  // store the result for states (i, j) : \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  // we know results for all states from (i, j) - (i+len, j+len)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tans = max(ans, dp[i][j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\t\\n\\t```\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n\\t\\t\\tint m = size(A), n = size(B), ans = 0, dp[m+1][n+1]; \\n\\t\\t\\tmemset(dp, 0, sizeof dp);\\n\\t\\t\\tfor(int i = m-1; ~i; i--) \\n\\t\\t\\t\\tfor(int j = n-1; ~j; j--) \\n\\t\\t\\t\\t\\tdp[i][j] = A[i-1] == B[j-1] ? dp[i+1][j+1] + 1 : 0,\\n\\t\\t\\t\\t\\tans = max(ans, dp[i][j]);\\n\\t\\t\\t\\t\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\t\\t \\n\\t ```\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        int m = size(A), n = size(B), ans = 0;\\n\\t\\tint dp[m+1][n+1]; memset(dp, 0, sizeof dp);\\n        for(int i = 1; i <= m; i++) \\n            for(int j = 1; j <= n; j++) \\n                dp[i][j] = A[i-1] == B[j-1] ? dp[i-1][j-1] + 1 : 0,\\n                ans = max(ans, dp[i][j]);\\n            \\n        return ans;\\n    }\\n};\\n```\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t   int findLength(vector<int>& A, vector<int>& B) {\\n\\t\\tif(size(A) < size(B)) A.swap(B);   // ensures dp length is min(M, N)\\n\\t\\tint m = size(A), n = size(B), ans = 0, dp[2][n+1]; \\n\\t\\tmemset(dp, 0, sizeof dp);\\n\\t\\tfor(int i = m-1, cur=i&1, next=!(i&1); ~i; i--, cur ^= 1, next ^= 1) // ~i ends loop when i goes -ve, ^= 1 used to flip bit\\n\\t\\t\\tfor(int j = n-1; ~j; j--) \\n\\t\\t\\t\\tdp[cur][j] = A[i] == B[j] ? dp[next][j+1] + 1 : 0,\\n\\t\\t\\t\\tans = max(ans, dp[cur][j]);\\n\\t\\t\\t\\n\\t\\treturn ans;\\n\\t   }\\n\\t};\\t\\t\\n\\t```\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n\\t\\t\\tif(size(A) < size(B)) A.swap(B); \\n\\t\\t\\tint m = size(A), n = size(B), ans = 0, dp[2][n+1]; \\n\\t\\t\\tmemset(dp, 0, sizeof dp);\\n\\t\\t\\tfor(int i = 1, cur = 1, prev{}; i <= m; i++, cur ^= 1, prev ^= 1) \\n\\t\\t\\t\\tfor(int j = 1; j <= n; j++) \\n\\t\\t\\t\\t\\tdp[cur][j] = A[i-1] == B[j-1] ? dp[prev][j-1] + 1 : 0,\\n\\t\\t\\t\\t\\tans = max(ans, dp[cur][j]);\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\t\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 109059,
                "title": "o-mn-time-o-1-space-solution",
                "content": "Intuitively, the algorithm slides one array over the other and for each sliding position compute the max length of repeated subarray within the overlapping window.\\n```\\nclass Solution(object):\\n    def findLength(self, A, B):\\n        B,A = sorted([A,B],key=len)\\n        m = len(A)\\n        n = len(B)\\n        maxLen = 0\\n        for a in xrange(-n+1,m+n-1):\\n            cnt = 0\\n            for ptrB in xrange(n):\\n                ptrA = a+ptrB\\n                if ptrA < 0 : continue\\n                if ptrA >= m : break\\n                if A[ptrA]==B[ptrB]:\\n                    cnt += 1\\n                    if cnt > maxLen: maxLen = cnt\\n                else:\\n                    cnt = 0\\n        return maxLen\\n```\\nComplexity: Let m>n, the outer loop runs for m+2n-1 (< 3m) times  and the inner loop runs n times. So the time complexity is O(mn) and no extra space used.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findLength(self, A, B):\\n        B,A = sorted([A,B],key=len)\\n        m = len(A)\\n        n = len(B)\\n        maxLen = 0\\n        for a in xrange(-n+1,m+n-1):\\n            cnt = 0\\n            for ptrB in xrange(n):\\n                ptrA = a+ptrB\\n                if ptrA < 0 : continue\\n                if ptrA >= m : break\\n                if A[ptrA]==B[ptrB]:\\n                    cnt += 1\\n                    if cnt > maxLen: maxLen = cnt\\n                else:\\n                    cnt = 0\\n        return maxLen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076749,
                "title": "c-pawri-dp-he-beginner-explained-easily-with-image",
                "content": "Example strings.\\uD83D\\uDC83\\uD83C\\uDFFC \\uD83D\\uDD7A\\uD83C\\uDFFC\\nstring s = parwihorihe \\nstring t = humpawri\\n\\n1. Make dp MxN matrix. (M,N are lengths of both strings)\\n2. Mark first row and first column as 0 for all.\\n3. Start from first char of s and match with every char of t, do this for all chars of S.\\n4. If char of S[i] matches with char of T[j] then we have found a common char that can contribute to our ans, so just copy the previous answers from both strings without the current char (if strings are abcde and abcdlkjlk and you are at \\'d\\' so we check what was the previous answer before coming to d, and we add 1 to the previous ans). The max val till now is the ans.\\n5. If chars dont match, put dp[i][j]=0;\\n\\n```\\nclass Solution {\\npublic:\\n    int LCSubstringNikalo(vector<int>& s, vector<int>& t)\\n    {\\n        int sl=s.size();\\n        int tl=t.size();\\n        vector<vector<int>> koiMilGaya(sl+1,vector<int>(tl+1,0));\\n        int sabseLambi=0;\\n        for(int i=1;i<=sl;i++)\\n        {\\n            for(int j=1;j<=tl;j++)\\n            {\\n                if(s[i-1]==t[j-1])\\n                    koiMilGaya[i][j]=koiMilGaya[i-1][j-1]+1;\\n                sabseLambi=max(sabseLambi,koiMilGaya[i][j]);\\n            }\\n        }\\n        return sabseLambi;\\n    }\\n    int findLength(vector<int>& a, vector<int>& b) {\\n        return LCSubstringNikalo(a,b);\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/09833075-f267-47d3-b4fa-8139eeb58d7a_1613933403.1984982.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int LCSubstringNikalo(vector<int>& s, vector<int>& t)\\n    {\\n        int sl=s.size();\\n        int tl=t.size();\\n        vector<vector<int>> koiMilGaya(sl+1,vector<int>(tl+1,0));\\n        int sabseLambi=0;\\n        for(int i=1;i<=sl;i++)\\n        {\\n            for(int j=1;j<=tl;j++)\\n            {\\n                if(s[i-1]==t[j-1])\\n                    koiMilGaya[i][j]=koiMilGaya[i-1][j-1]+1;\\n                sabseLambi=max(sabseLambi,koiMilGaya[i][j]);\\n            }\\n        }\\n        return sabseLambi;\\n    }\\n    int findLength(vector<int>& a, vector<int>& b) {\\n        return LCSubstringNikalo(a,b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109026,
                "title": "python-concise-dp",
                "content": "This is essentially the same question as longest common substring.\\n\\n**\\uD83D\\uDCAF Check out https://techinterviewhandbook.org for more tips and tricks to ace your technical interview \\uD83D\\uDCAF**\\n\\n```\\nclass Solution(object):\\n    def findLength(self, A, B):\\n        dp = [[0 for _ in range(len(B) + 1)] for _ in range(len(A) + 1)]\\n        for i in range(1, len(A) + 1):\\n            for j in range(1, len(B) + 1):\\n                if A[i - 1] == B[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1] + 1\\n        return max(max(row) for row in dp)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findLength(self, A, B):\\n        dp = [[0 for _ in range(len(B) + 1)] for _ in range(len(A) + 1)]\\n        for i in range(1, len(A) + 1):\\n            for j in range(1, len(B) + 1):\\n                if A[i - 1] == B[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1] + 1\\n        return max(max(row) for row in dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109068,
                "title": "java-c-clean-code-8-lines",
                "content": "**DP formula**\\n```\\n/**\\n * dp[i][j] = a[i] == b[j] ? 1 + dp[i + 1][j + 1] : 0;\\n * dp[i][j] : max lenth of common subarray start at a[i] & b[j];\\n */\\n```\\n**Java - DP matrix**\\n```\\nclass Solution {\\n    public int findLength(int[] a, int[] b) {\\n        int m = a.length, n = b.length;\\n        if (m == 0 || n == 0) return 0;\\n        int[][] dp = new int[m + 1][n + 1];\\n        int max = 0;\\n        for (int i = m - 1; i >= 0; i--)\\n            for (int j = n - 1; j >= 0; j--)\\n                max = Math.max(max, dp[i][j] = a[i] == b[j] ? 1 + dp[i + 1][j + 1] : 0);\\n        return max;        \\n    }\\n}\\n```\\n**Java - DP array**\\n```\\nclass Solution {\\n    public int findLength(int[] a, int[] b) {\\n        int m = a.length, n = b.length;\\n        if (m == 0 || n == 0) return 0;\\n        int[] dp = new int[n + 1];\\n        int max = 0;\\n        for (int i = m - 1; i >= 0; i--)\\n            for (int j = 0; j < n; j++)\\n                max = Math.max(max, dp[j] = a[i] == b[j] ? 1 + dp[j + 1] : 0);\\n        return max;        \\n    }\\n}\\n```\\n**C++ - DP array**\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& a, vector<int>& b) {\\n        int m = a.size(), n = b.size();\\n        if (!m || !n) return 0;\\n        vector<int> dp(n + 1);\\n        int res = 0;\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = 0; j < n; j++) {\\n                res = max(res, dp[j] = a[i] == b[j] ? 1 + dp[j + 1] : 0);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * dp[i][j] = a[i] == b[j] ? 1 + dp[i + 1][j + 1] : 0;\\n * dp[i][j] : max lenth of common subarray start at a[i] & b[j];\\n */\\n```\n```\\nclass Solution {\\n    public int findLength(int[] a, int[] b) {\\n        int m = a.length, n = b.length;\\n        if (m == 0 || n == 0) return 0;\\n        int[][] dp = new int[m + 1][n + 1];\\n        int max = 0;\\n        for (int i = m - 1; i >= 0; i--)\\n            for (int j = n - 1; j >= 0; j--)\\n                max = Math.max(max, dp[i][j] = a[i] == b[j] ? 1 + dp[i + 1][j + 1] : 0);\\n        return max;        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findLength(int[] a, int[] b) {\\n        int m = a.length, n = b.length;\\n        if (m == 0 || n == 0) return 0;\\n        int[] dp = new int[n + 1];\\n        int max = 0;\\n        for (int i = m - 1; i >= 0; i--)\\n            for (int j = 0; j < n; j++)\\n                max = Math.max(max, dp[j] = a[i] == b[j] ? 1 + dp[j + 1] : 0);\\n        return max;        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& a, vector<int>& b) {\\n        int m = a.size(), n = b.size();\\n        if (!m || !n) return 0;\\n        vector<int> dp(n + 1);\\n        int res = 0;\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = 0; j < n; j++) {\\n                res = max(res, dp[j] = a[i] == b[j] ? 1 + dp[j + 1] : 0);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599448,
                "title": "c-dp-related-problems",
                "content": "<details>\\n<summary> Approach </summary>\\n\\nLet `dp[i + 1][j + 1]` be the lenght of the maximum subarray that appears in both the tail of `A` and `B`.\\n```\\ndp[i + 1][j + 1] = 1 + dp[i][j]     // A[i] == B[j]\\n                 = 0                // A[i] != B[j]\\n```\\n\\nSince `dp[i + 1][j + 1]` only depends on `dp[i][j]`, we can use 1D array to store the `dp` array.\\n\\n</details>\\n \\nWe are comparing **each element of vector 1 (starting from left boundary)** to each element of **vector 2 (starting from right boundary)**. If at any point they are equal, we increase the value of dp array at point index after adding one to previous index value in dp.\\n\\nIn step 4, we are writing **2 in dp** because there is **1 at previous index**, we are adding 1 to that value. \\n\\n![image](https://assets.leetcode.com/users/images/ab4463c4-e7f3-472c-9f82-35c50e6532e8_1663643098.80958.png)\\n\\n```cpp\\nint findLength(vector<int>& A, vector<int>& B) {\\n        \\n        if (A.size() < B.size()) swap(A, B);\\n        int M = A.size(), N = B.size();\\n        vector<int> dp(N + 1, 0);\\n        int ans = 0;\\n        \\n        for(int i = 0; i < M; i++) {\\n            for(int j = N - 1; j >= 0; j--) {\\n                \\n                if (A[i] == B[j]) {\\n                    dp[j + 1] = 1 + dp[j];\\n                } else {\\n                    dp[j + 1] = 0;\\n                }\\n                              \\n                ans = max(ans, dp[j + 1]);\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n**Note** : As our dp is actually 1d array, so it will cleared after every iteration (for those elements which are not equal). The actual dp will store the result of current and last iteration as shown in step 6.\\n\\n**Dynamic Programming Related Problems**\\n[1. Maximum Subarray ](https://leetcode.com/problems/maximum-subarray/)\\n[2. Jump Game II ](https://leetcode.com/problems/jump-game-ii/)\\n[3. Unique Paths ](https://leetcode.com/problems/unique-paths/)\\n[4. Decode Ways ](https://leetcode.com/problems/decode-ways/)\\n[5. Pascal\\'s Triangle ](https://leetcode.com/problems/pascals-triangle/)\\n[6. Maximum Product Subarray ](https://leetcode.com/problems/maximum-product-subarray/)\\n[7. House Robber ](https://leetcode.com/problems/house-robber/)\\n[8. Longest Increasing Subsequence ](https://leetcode.com/problems/longest-increasing-subsequence/)\\n[9. Coin Change ](https://leetcode.com/problems/coin-change/)\\n[10. Counting Bits ](https://leetcode.com/problems/counting-bits/)\\n[11. Ones and Zeroes ](https://leetcode.com/problems/ones-and-zeroes/)\\n[12. Target Sum ](https://leetcode.com/problems/target-sum/)\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\ndp[i + 1][j + 1] = 1 + dp[i][j]     // A[i] == B[j]\\n                 = 0                // A[i] != B[j]\\n```\n```cpp\\nint findLength(vector<int>& A, vector<int>& B) {\\n        \\n        if (A.size() < B.size()) swap(A, B);\\n        int M = A.size(), N = B.size();\\n        vector<int> dp(N + 1, 0);\\n        int ans = 0;\\n        \\n        for(int i = 0; i < M; i++) {\\n            for(int j = N - 1; j >= 0; j--) {\\n                \\n                if (A[i] == B[j]) {\\n                    dp[j + 1] = 1 + dp[j];\\n                } else {\\n                    dp[j + 1] = 0;\\n                }\\n                              \\n                ans = max(ans, dp[j + 1]);\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 109040,
                "title": "java-o-mn-time-o-1-space",
                "content": "maxLen[i][j] --> the max length of common subarray ending at A[i] and B[j]\\n             =>     0 , if A[i] != A[j]\\n                    maxLen[i-1][j-1] + 1, if A[i] = B[j]\\n        \\nSo maxLen[i][j] only depends on maxLen[i-1][j-1], so you only need to keep maxLen[i-1][j-1] which is one element.\\n\\nIn below code we use maxLenEnding to keep maxLen[i-1][j-1] and traverse the matrix diagonally \\n\\n\\n```\\npublic int findLength(int[] A, int[] B) {\\n        \\n        int maxLen = 0;\\n        \\n        \\n        for (int j = 0; j < B.length; j++) {\\n            int maxLenEnding = 0;\\n            for (int i = 0, k = j; i < A.length && k < B.length; i++, k++) {\\n                if (A[i] != B[k]) maxLenEnding = 0;\\n                else {\\n                    maxLenEnding++;\\n                    maxLen = Math.max(maxLen, maxLenEnding);\\n                }\\n            }\\n        }\\n        \\n        for (int i =1; i < A.length; i++) {\\n            int maxLenEnding = 0;\\n            for (int j = 0, k = i; k < A.length && j < B.length; j++, k++) {\\n                if (A[k] != B[j]) maxLenEnding = 0;\\n                else {\\n                    maxLenEnding++;\\n                    maxLen = Math.max(maxLen, maxLenEnding);\\n                }\\n            }\\n        }\\n        \\n        return maxLen;\\n        \\n        \\n        \\n    }\\n'''",
                "solutionTags": [],
                "code": "maxLen[i][j] --> the max length of common subarray ending at A[i] and B[j]\\n             =>     0 , if A[i] != A[j]\\n                    maxLen[i-1][j-1] + 1, if A[i] = B[j]\\n        \\nSo maxLen[i][j] only depends on maxLen[i-1][j-1], so you only need to keep maxLen[i-1][j-1] which is one element.\\n\\nIn below code we use maxLenEnding to keep maxLen[i-1][j-1] and traverse the matrix diagonally \\n\\n\\n```\\npublic int findLength(int[] A, int[] B) {\\n        \\n        int maxLen = 0;\\n        \\n        \\n        for (int j = 0; j < B.length; j++) {\\n            int maxLenEnding = 0;\\n            for (int i = 0, k = j; i < A.length && k < B.length; i++, k++) {\\n                if (A[i] != B[k]) maxLenEnding = 0;\\n                else {\\n                    maxLenEnding++;\\n                    maxLen = Math.max(maxLen, maxLenEnding);\\n                }\\n            }\\n        }\\n        \\n        for (int i =1; i < A.length; i++) {\\n            int maxLenEnding = 0;\\n            for (int j = 0, k = i; k < A.length && j < B.length; j++, k++) {\\n                if (A[k] != B[j]) maxLenEnding = 0;\\n                else {\\n                    maxLenEnding++;\\n                    maxLen = Math.max(maxLen, maxLenEnding);\\n                }\\n            }\\n        }\\n        \\n        return maxLen;\\n        \\n        \\n        \\n    }\\n'''",
                "codeTag": "Unknown"
            },
            {
                "id": 109030,
                "title": "return-the-array-instead-of-the-length-very-simple-dp-solution-with-the-both-max-and-the-array",
                "content": "What if you asked to return the array instead of the length! No worries \\nlet's first fill our 2D dp array. The question here is how?\\nlet's use the example given in the problem \\neg \\n              A = {1,2,3,2,1}\\n              B = {3,2,1,4,7}\\n   ![0_1511474399873_Screen Shot 2017-11-23 at 4.59.28 PM.png](/assets/uploads/files/1511474401032-screen-shot-2017-11-23-at-4.59.28-pm.png) \\n\\nthat is the initial dp array of size [A.length+1][B.length+1]\\n\\nso let's fill the third and fourth row to get a pattern of how our dp formula should look like.\\n![0_1511476366531_Screen Shot 2017-11-23 at 5.32.33 PM.png](/assets/uploads/files/1511476367150-screen-shot-2017-11-23-at-5.32.33-pm.png) \\nIf the number is the same we get the element at position  i-1 and j-1 and add 1 to it and store it at dp[i][j] .\\nAfter filling the whole array then the length of the longest gives you the answer you can keep tract of it with a max variable. \\nThe complete table is showed below\\n![0_1511476664902_Screen Shot 2017-11-23 at 5.37.14 PM.png](/assets/uploads/files/1511476665686-screen-shot-2017-11-23-at-5.37.14-pm.png) \\n\\n    public int findLength(int[] A, int[] B) {\\n\\t     int max = 0;\\n\\t     int[][] dp = new int[A.length+1][B.length+1];\\n\\t        for(int i=1; i<dp.length; i++){\\n\\t            for(int j=1; j<dp[i].length;j++){\\n\\t                if(B[i-1] == A[j-1]){  \\t\\t\\n\\t                \\tif((dp[i][j] = dp[i-1][j-1] + 1) > max){\\n\\t                \\t\\t max = dp[i][j] = dp[i-1][j-1] +1;\\n\\t                \\t}\\n\\t                }\\n\\t              }\\n\\t        }   \\n        return max;\\n    }\\n     \\nThat returns the longest length from the array.\\n\\nWhat happens if you are asked to return the array instead of length.\\nIt's actually so easy go back to the dp array and just back trace it. We need to modify the above above to keep tract of the i-th and j-th index of the max for easy backtracking.\\nAfter observing the table just back trace starting from either of index whether i-th of j-th you will get the same result \\n\\n     public int findLength(int[] A, int[] B) {\\n\\t\\t int maxIindex = 0;\\n\\t     int maxJindex = 0;\\n\\t     int max = 0;\\n\\t        int[][] dp = new int[A.length+1][B.length+1];\\n\\t        for(int i=1; i<dp.length; i++){\\n\\t            for(int j=1; j<dp[i].length;j++){\\n\\t                if(B[i-1] == A[j-1]){  \\t\\t\\n\\t                \\tif((dp[i][j] = dp[i-1][j-1] + 1) > max){\\n\\t                \\t\\tmax = dp[i][j] = dp[i-1][j-1] + 1;\\n\\t                \\t\\tmaxIindex = i;\\n\\t               \\t        maxJindex = j ;\\n\\t                \\t}\\n\\t                }\\n\\t              }\\n\\t        }\\n\\t        \\n\\t        int[] result = new int[max];\\n\\t        int k = result.length-1;\\n\\t        while(k>=0){\\t\\n\\t        \\t\\tresult[k] = B[maxIindex-1];\\n\\t        \\t\\tmaxIindex--;\\n\\t        \\t\\tk--;\\n\\t        }  \\n        System.out.println(Arrays.toString(result)); \\n        return max;\\n    }",
                "solutionTags": [],
                "code": "What if you asked to return the array instead of the length! No worries \\nlet's first fill our 2D dp array. The question here is how?\\nlet's use the example given in the problem \\neg \\n              A = {1,2,3,2,1}\\n              B = {3,2,1,4,7}\\n   ![0_1511474399873_Screen Shot 2017-11-23 at 4.59.28 PM.png](/assets/uploads/files/1511474401032-screen-shot-2017-11-23-at-4.59.28-pm.png) \\n\\nthat is the initial dp array of size [A.length+1][B.length+1]\\n\\nso let's fill the third and fourth row to get a pattern of how our dp formula should look like.\\n![0_1511476366531_Screen Shot 2017-11-23 at 5.32.33 PM.png](/assets/uploads/files/1511476367150-screen-shot-2017-11-23-at-5.32.33-pm.png) \\nIf the number is the same we get the element at position  i-1 and j-1 and add 1 to it and store it at dp[i][j] .\\nAfter filling the whole array then the length of the longest gives you the answer you can keep tract of it with a max variable. \\nThe complete table is showed below\\n![0_1511476664902_Screen Shot 2017-11-23 at 5.37.14 PM.png](/assets/uploads/files/1511476665686-screen-shot-2017-11-23-at-5.37.14-pm.png) \\n\\n    public int findLength(int[] A, int[] B) {\\n\\t     int max = 0;\\n\\t     int[][] dp = new int[A.length+1][B.length+1];\\n\\t        for(int i=1; i<dp.length; i++){\\n\\t            for(int j=1; j<dp[i].length;j++){\\n\\t                if(B[i-1] == A[j-1]){  \\t\\t\\n\\t                \\tif((dp[i][j] = dp[i-1][j-1] + 1) > max){\\n\\t                \\t\\t max = dp[i][j] = dp[i-1][j-1] +1;\\n\\t                \\t}\\n\\t                }\\n\\t              }\\n\\t        }   \\n        return max;\\n    }\\n     \\nThat returns the longest length from the array.\\n\\nWhat happens if you are asked to return the array instead of length.\\nIt's actually so easy go back to the dp array and just back trace it. We need to modify the above above to keep tract of the i-th and j-th index of the max for easy backtracking.\\nAfter observing the table just back trace starting from either of index whether i-th of j-th you will get the same result \\n\\n     public int findLength(int[] A, int[] B) {\\n\\t\\t int maxIindex = 0;\\n\\t     int maxJindex = 0;\\n\\t     int max = 0;\\n\\t        int[][] dp = new int[A.length+1][B.length+1];\\n\\t        for(int i=1; i<dp.length; i++){\\n\\t            for(int j=1; j<dp[i].length;j++){\\n\\t                if(B[i-1] == A[j-1]){  \\t\\t\\n\\t                \\tif((dp[i][j] = dp[i-1][j-1] + 1) > max){\\n\\t                \\t\\tmax = dp[i][j] = dp[i-1][j-1] + 1;\\n\\t                \\t\\tmaxIindex = i;\\n\\t               \\t        maxJindex = j ;\\n\\t                \\t}\\n\\t                }\\n\\t              }\\n\\t        }\\n\\t        \\n\\t        int[] result = new int[max];\\n\\t        int k = result.length-1;\\n\\t        while(k>=0){\\t\\n\\t        \\t\\tresult[k] = B[maxIindex-1];\\n\\t        \\t\\tmaxIindex--;\\n\\t        \\t\\tk--;\\n\\t        }  \\n        System.out.println(Arrays.toString(result)); \\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 853888,
                "title": "java-recursive-tle-memoization-2d-bottom-up-1d-bottom-up",
                "content": "```\\n\\t- If we are currently comparing two numbers at \\'i\\' and \\'j\\' in the two respective arrays\\n\\t\\t- If the two numbers are the same\\n\\t\\t\\t- Then we have found the subarray of length 1\\n\\t\\t\\t\\t- We will continue to find the rest of the subarray at \\'i + 1\\' and \\'j + 1\\'\\n\\t\\t- If the two numbers are different\\n\\t\\t\\t- Then we will have two choices\\n\\t\\t\\t\\t- We can either move forward \\'i\\' or move forward \\'j\\'\\n```\\n```\\npublic class MaximumLengthRepeatedSubarrayRecursiveApproach {\\n    private class MaxLength {\\n        public int val = 0;\\n    }\\n\\n    public int findLength(int[] A, int[] B) {\\n        MaxLength maxLength = new MaxLength();\\n        findLength(0, 0, A, B, maxLength);\\n        return maxLength.val;\\n    }\\n\\n    private int findLength(int i, int j, int[] A, int[] B, MaxLength maxLength) {\\n        if (i >= A.length || j >= B.length) return 0;\\n\\n        int length = 0;\\n\\n        if (A[i] == B[j]) {\\n            length = findLength(i + 1, j + 1, A, B, maxLength) + 1;\\n            maxLength.val = Math.max(maxLength.val, length);\\n        }\\n\\n        findLength(i + 1, j, A, B, maxLength);\\n        findLength(i, j + 1, A, B, maxLength);\\n\\n        return length;\\n    }\\n}\\n```\\n```\\npublic class MaximumLengthRepeatedSubarrayMemoizationApproach {\\n    private class MaxLength {\\n        public int val = 0;\\n    }\\n\\n    public int findLength(int[] A, int[] B) {\\n        MaxLength maxLength = new MaxLength();\\n        int[][] memo = new int[A.length][B.length];\\n\\n        for (int row = 0; row < memo.length; row++) {\\n            Arrays.fill(memo[row], -1);\\n        }\\n\\n        findLength(0, 0, A, B, maxLength, memo);\\n        return maxLength.val;\\n    }\\n\\n    private int findLength(int i, int j, int[] A, int[] B, MaxLength maxLength, int[][] memo) {\\n        if (i >= A.length || j >= B.length) return 0;\\n        if (memo[i][j] != -1) return memo[i][j];\\n\\n        int length = 0;\\n\\n        if (A[i] == B[j]) {\\n            length = findLength(i + 1, j + 1, A, B, maxLength, memo) + 1;\\n            maxLength.val = Math.max(maxLength.val, length);\\n        }\\n\\n        findLength(i + 1, j, A, B, maxLength, memo);\\n        findLength(i, j + 1, A, B, maxLength, memo);\\n\\n        memo[i][j] = length;\\n        return length;\\n    }\\n}\\n```\\n```\\npublic class MaximumLengthRepeatedSubarrayBottomUp2DApproach {\\n    public int findLength(int[] A, int[] B) {\\n        int[][] length = new int[A.length + 1][B.length + 1];\\n        int maxLength = 0;\\n\\n        for (int i = A.length - 1; i >= 0; i--) {\\n            for (int j = B.length - 1; j >= 0; j--) {\\n                if (A[i] == B[j]) {\\n                    length[i][j] = length[i + 1][j + 1] + 1;\\n                    maxLength = Math.max(maxLength, length[i][j]);\\n                }\\n            }\\n        }\\n\\n        return maxLength;\\n    }\\n}\\n```\\n```\\npublic class MaximumLengthRepeatedSubarrayBottomUp1DApproach {\\n    public int findLength(int[] A, int[] B) {\\n        int[] length = new int[B.length + 1];\\n        int maxLength = 0;\\n\\n        for (int i = A.length - 1; i >= 0; i--) {\\n            int prev = 0;\\n\\n            for (int j = B.length - 1; j >= 0; j--) {\\n                int current = length[j];\\n\\n                if (A[i] == B[j]) {\\n                    length[j] = prev + 1;\\n                    maxLength = Math.max(maxLength, length[j]);\\n                } else {\\n                    length[j] = 0;\\n                }\\n\\n                prev = current;\\n            }\\n        }\\n\\n        return maxLength;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\t- If we are currently comparing two numbers at \\'i\\' and \\'j\\' in the two respective arrays\\n\\t\\t- If the two numbers are the same\\n\\t\\t\\t- Then we have found the subarray of length 1\\n\\t\\t\\t\\t- We will continue to find the rest of the subarray at \\'i + 1\\' and \\'j + 1\\'\\n\\t\\t- If the two numbers are different\\n\\t\\t\\t- Then we will have two choices\\n\\t\\t\\t\\t- We can either move forward \\'i\\' or move forward \\'j\\'\\n```\n```\\npublic class MaximumLengthRepeatedSubarrayRecursiveApproach {\\n    private class MaxLength {\\n        public int val = 0;\\n    }\\n\\n    public int findLength(int[] A, int[] B) {\\n        MaxLength maxLength = new MaxLength();\\n        findLength(0, 0, A, B, maxLength);\\n        return maxLength.val;\\n    }\\n\\n    private int findLength(int i, int j, int[] A, int[] B, MaxLength maxLength) {\\n        if (i >= A.length || j >= B.length) return 0;\\n\\n        int length = 0;\\n\\n        if (A[i] == B[j]) {\\n            length = findLength(i + 1, j + 1, A, B, maxLength) + 1;\\n            maxLength.val = Math.max(maxLength.val, length);\\n        }\\n\\n        findLength(i + 1, j, A, B, maxLength);\\n        findLength(i, j + 1, A, B, maxLength);\\n\\n        return length;\\n    }\\n}\\n```\n```\\npublic class MaximumLengthRepeatedSubarrayMemoizationApproach {\\n    private class MaxLength {\\n        public int val = 0;\\n    }\\n\\n    public int findLength(int[] A, int[] B) {\\n        MaxLength maxLength = new MaxLength();\\n        int[][] memo = new int[A.length][B.length];\\n\\n        for (int row = 0; row < memo.length; row++) {\\n            Arrays.fill(memo[row], -1);\\n        }\\n\\n        findLength(0, 0, A, B, maxLength, memo);\\n        return maxLength.val;\\n    }\\n\\n    private int findLength(int i, int j, int[] A, int[] B, MaxLength maxLength, int[][] memo) {\\n        if (i >= A.length || j >= B.length) return 0;\\n        if (memo[i][j] != -1) return memo[i][j];\\n\\n        int length = 0;\\n\\n        if (A[i] == B[j]) {\\n            length = findLength(i + 1, j + 1, A, B, maxLength, memo) + 1;\\n            maxLength.val = Math.max(maxLength.val, length);\\n        }\\n\\n        findLength(i + 1, j, A, B, maxLength, memo);\\n        findLength(i, j + 1, A, B, maxLength, memo);\\n\\n        memo[i][j] = length;\\n        return length;\\n    }\\n}\\n```\n```\\npublic class MaximumLengthRepeatedSubarrayBottomUp2DApproach {\\n    public int findLength(int[] A, int[] B) {\\n        int[][] length = new int[A.length + 1][B.length + 1];\\n        int maxLength = 0;\\n\\n        for (int i = A.length - 1; i >= 0; i--) {\\n            for (int j = B.length - 1; j >= 0; j--) {\\n                if (A[i] == B[j]) {\\n                    length[i][j] = length[i + 1][j + 1] + 1;\\n                    maxLength = Math.max(maxLength, length[i][j]);\\n                }\\n            }\\n        }\\n\\n        return maxLength;\\n    }\\n}\\n```\n```\\npublic class MaximumLengthRepeatedSubarrayBottomUp1DApproach {\\n    public int findLength(int[] A, int[] B) {\\n        int[] length = new int[B.length + 1];\\n        int maxLength = 0;\\n\\n        for (int i = A.length - 1; i >= 0; i--) {\\n            int prev = 0;\\n\\n            for (int j = B.length - 1; j >= 0; j--) {\\n                int current = length[j];\\n\\n                if (A[i] == B[j]) {\\n                    length[j] = prev + 1;\\n                    maxLength = Math.max(maxLength, length[j]);\\n                } else {\\n                    length[j] = 0;\\n                }\\n\\n                prev = current;\\n            }\\n        }\\n\\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599433,
                "title": "java-easy-solution-dp-beginner-friendly",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {    \\n    public int findLength(int[] nums1, int[] nums2) {\\n        int n= nums1.length;\\n        int m= nums2.length;\\n        int ans=0;\\n        int dp[][]= new int[n+1][m+1];\\n        \\n        for(int i=1;i<=n;i++)\\n            for(int j=1;j<=m;j++){\\n                \\n                if(nums1[i-1]==nums2[j-1] ){\\n                    dp[i][j]= 1+ dp[i-1][j-1];\\n                    ans=Math.max (ans,dp[i][j] );\\n                } \\n                else dp[i][j]=0;\\n            }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {    \\n    public int findLength(int[] nums1, int[] nums2) {\\n        int n= nums1.length;\\n        int m= nums2.length;\\n        int ans=0;\\n        int dp[][]= new int[n+1][m+1];\\n        \\n        for(int i=1;i<=n;i++)\\n            for(int j=1;j<=m;j++){\\n                \\n                if(nums1[i-1]==nums2[j-1] ){\\n                    dp[i][j]= 1+ dp[i-1][j-1];\\n                    ans=Math.max (ans,dp[i][j] );\\n                } \\n                else dp[i][j]=0;\\n            }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599501,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n**C++**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // DP Approach - Similar to 1143. Longest Common Subsequence\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size(), ans = 0;\\n        // dp[i][j] means the length of repeated subarray of nums1[:i] and nums2[:j]\\n        // initially the first row (i = 0) and the first col (j = 0) would be zero\\n        // dp[i][0] = 0 for all i and dp[0][j] = 0 for all j\\n        // if you use int dp[n + 1][m + 1], then you need to take care of this part\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tfor (int j = 1; j <= m; j++) {\\n                // if both character is same\\n\\t\\t\\t\\tif (nums1[i - 1] == nums2[j - 1]) {\\n                    // then we add 1 to the previous state, which is dp[i - 1][j - 1]\\n                    // in other word, we extend the repeated subarray by 1\\n                    // e.g. a = [1], b = [1], length of repeated array is 1\\n                    //      a = [1,2], b = [1,2], length of repeated array is the previous result + 1 = 2\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1] + 1;\\n                    // record the max ans here\\n\\t\\t\\t\\t\\tans = max(ans, dp[i][j]);\\n\\t\\t\\t\\t} else {\\n                    // if you are looking for longest common sequence,\\n                    // then you put dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); here\\n                    // however, this problem is looking for subarray,\\n                    // since both character is not equal, which means we need to break it here\\n                    // hence, set dp[i][j] to 0\\n                    // since we use vector<vector<int>> dp instead of int dp[n + 1][m + 1]\\n                    // this part can be skipped as it is already 0\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // DP Approach - Space Optimized\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size(), ans = 0;\\n        // swap it to ensure n > m\\n        if (n < m) {\\n            // or you can call findLength(nums2, nums1); \\n            swap(nums1, nums2);\\n            swap(n, m);\\n        }\\n        // dp records current dp state\\n        // dp2 records the previous dp state\\n        vector<int> dp(n + 1), dp2(n + 1);\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (nums1[i - 1] == nums2[j - 1]) {\\n                    // extend from the previous dp state\\n                    dp[j] = dp2[j - 1] + 1; \\n                } else {\\n                    // reset to 0\\n                    dp[j] = 0;\\n                }\\n                // record the max length\\n                ans = max(ans, dp[j]);\\n            }\\n            // the current state now becomes the previous state for next round\\n            dp2 = dp;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```cpp\\n// Rolling Hash Approach\\nclass Solution {\\npublic:\\n    // the idea is to use binary search to find the length `m`\\n    // then we check if there is any nums1[i : i + m] == nums2[i : i + m]\\n    // for c++, it may get TLE. so we can use rolling hash to speed up\\n    // we can see `nums1[i : j]` as a hash, then we insert all the possible hashes to a set\\n    // then we do the same on `nums2` to see if the hash exists in the set\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int N = nums1.size(), M = nums2.size();\\n        // build hashes for nums1\\n        PolyHash H1 = PolyHash(nums1);\\n        // build hashes for nums2\\n        PolyHash H2 = PolyHash(nums2);\\n        \\n        int l = 0, r = min(N, M);\\n        // binary search\\n        while (l < r) {\\n            // guess that the length is m\\n            int m = l + (r - l + 1) / 2, ok = 0;\\n            // use set to store all the possible hashes\\n            set<int> s;\\n            // for each subarray, we get the hash and store in set\\n            for (int i = 0; i < N - m + 1; i++) {\\n                s.insert(H1.get_hash(i, i + m - 1));\\n            }\\n            // see if we can get the same hash\\n            for (int i = 0; i < M - m + 1; i++) {\\n                if (s.find(H2.get_hash(i, i + m - 1)) != s.end()) {\\n                    ok = 1;\\n                    break;\\n                }\\n            }\\n            // include m\\n            if (ok) l = m;\\n            // exclude m\\n            else r = m - 1;\\n        }\\n        return l;\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```py\\nclass Solution:\\n    # DP Approach - Similar to 1143. Longest Common Subsequence\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        n, m = len(nums1), len(nums2)\\n        # dp[i][j] means the length of repeated subarray of nums1[:i] and nums2[:j]\\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\\n        ans = 0\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                # if both character is same\\n                if nums1[i - 1] == nums2[j - 1]:\\n                    # then we add 1 to the previous state, which is dp[i - 1][j - 1]\\n                    # in other word, we extend the repeated subarray by 1\\n                    # e.g. a = [1], b = [1], length of repeated array is 1\\n                    #      a = [1,2], b = [1,2], length of repeated array is the previous result + 1 = 2\\n                    dp[i][j] = dp[i - 1][j - 1] + 1\\n                    # record the max ans here\\n                    ans = max(ans, dp[i][j])\\n                # else:\\n                    # if you are looking for longest common sequence,\\n                    # then you put dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); here\\n                    # however, this problem is looking for subarray,\\n                    # since both character is not equal, which means we need to break it here\\n                    # hence, set dp[i][j] to 0\\n        return ans\\n```\\n\\n```py\\nclass Solution:\\n    # Binary Search Approach\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        N, M = len(nums1), len(nums2)\\n        \\n        def ok(k):\\n            # the idea is to use binary search to find the length `k`\\n            # then we check if there is any nums1[i : i + k] == nums2[i : i + k]\\n            s = set(tuple(nums1[i : i + k]) for i in range(N - k + 1))\\n            return any(tuple(nums2[i : i + k]) in s for i in range(M - k + 1))\\n        \\n        # init possible boundary\\n        l, r = 0, min(N, M)\\n        while l < r:\\n            # get the middle one\\n            # for even number of elements, take the upper one\\n            m = (l + r + 1) // 2\\n            if ok(m): \\n                # include m\\n                l = m\\n            else:\\n                # exclude m\\n                r = m - 1\\n        return l\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "C",
                    "Dynamic Programming",
                    "Rolling Hash"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // DP Approach - Similar to 1143. Longest Common Subsequence\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size(), ans = 0;\\n        // dp[i][j] means the length of repeated subarray of nums1[:i] and nums2[:j]\\n        // initially the first row (i = 0) and the first col (j = 0) would be zero\\n        // dp[i][0] = 0 for all i and dp[0][j] = 0 for all j\\n        // if you use int dp[n + 1][m + 1], then you need to take care of this part\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tfor (int j = 1; j <= m; j++) {\\n                // if both character is same\\n\\t\\t\\t\\tif (nums1[i - 1] == nums2[j - 1]) {\\n                    // then we add 1 to the previous state, which is dp[i - 1][j - 1]\\n                    // in other word, we extend the repeated subarray by 1\\n                    // e.g. a = [1], b = [1], length of repeated array is 1\\n                    //      a = [1,2], b = [1,2], length of repeated array is the previous result + 1 = 2\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1] + 1;\\n                    // record the max ans here\\n\\t\\t\\t\\t\\tans = max(ans, dp[i][j]);\\n\\t\\t\\t\\t} else {\\n                    // if you are looking for longest common sequence,\\n                    // then you put dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); here\\n                    // however, this problem is looking for subarray,\\n                    // since both character is not equal, which means we need to break it here\\n                    // hence, set dp[i][j] to 0\\n                    // since we use vector<vector<int>> dp instead of int dp[n + 1][m + 1]\\n                    // this part can be skipped as it is already 0\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    // DP Approach - Space Optimized\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size(), ans = 0;\\n        // swap it to ensure n > m\\n        if (n < m) {\\n            // or you can call findLength(nums2, nums1); \\n            swap(nums1, nums2);\\n            swap(n, m);\\n        }\\n        // dp records current dp state\\n        // dp2 records the previous dp state\\n        vector<int> dp(n + 1), dp2(n + 1);\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (nums1[i - 1] == nums2[j - 1]) {\\n                    // extend from the previous dp state\\n                    dp[j] = dp2[j - 1] + 1; \\n                } else {\\n                    // reset to 0\\n                    dp[j] = 0;\\n                }\\n                // record the max length\\n                ans = max(ans, dp[j]);\\n            }\\n            // the current state now becomes the previous state for next round\\n            dp2 = dp;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// Rolling Hash Approach\\nclass Solution {\\npublic:\\n    // the idea is to use binary search to find the length `m`\\n    // then we check if there is any nums1[i : i + m] == nums2[i : i + m]\\n    // for c++, it may get TLE. so we can use rolling hash to speed up\\n    // we can see `nums1[i : j]` as a hash, then we insert all the possible hashes to a set\\n    // then we do the same on `nums2` to see if the hash exists in the set\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int N = nums1.size(), M = nums2.size();\\n        // build hashes for nums1\\n        PolyHash H1 = PolyHash(nums1);\\n        // build hashes for nums2\\n        PolyHash H2 = PolyHash(nums2);\\n        \\n        int l = 0, r = min(N, M);\\n        // binary search\\n        while (l < r) {\\n            // guess that the length is m\\n            int m = l + (r - l + 1) / 2, ok = 0;\\n            // use set to store all the possible hashes\\n            set<int> s;\\n            // for each subarray, we get the hash and store in set\\n            for (int i = 0; i < N - m + 1; i++) {\\n                s.insert(H1.get_hash(i, i + m - 1));\\n            }\\n            // see if we can get the same hash\\n            for (int i = 0; i < M - m + 1; i++) {\\n                if (s.find(H2.get_hash(i, i + m - 1)) != s.end()) {\\n                    ok = 1;\\n                    break;\\n                }\\n            }\\n            // include m\\n            if (ok) l = m;\\n            // exclude m\\n            else r = m - 1;\\n        }\\n        return l;\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    # DP Approach - Similar to 1143. Longest Common Subsequence\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        n, m = len(nums1), len(nums2)\\n        # dp[i][j] means the length of repeated subarray of nums1[:i] and nums2[:j]\\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\\n        ans = 0\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                # if both character is same\\n                if nums1[i - 1] == nums2[j - 1]:\\n                    # then we add 1 to the previous state, which is dp[i - 1][j - 1]\\n                    # in other word, we extend the repeated subarray by 1\\n                    # e.g. a = [1], b = [1], length of repeated array is 1\\n                    #      a = [1,2], b = [1,2], length of repeated array is the previous result + 1 = 2\\n                    dp[i][j] = dp[i - 1][j - 1] + 1\\n                    # record the max ans here\\n                    ans = max(ans, dp[i][j])\\n                # else:\\n                    # if you are looking for longest common sequence,\\n                    # then you put dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); here\\n                    # however, this problem is looking for subarray,\\n                    # since both character is not equal, which means we need to break it here\\n                    # hence, set dp[i][j] to 0\\n        return ans\\n```\n```py\\nclass Solution:\\n    # Binary Search Approach\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        N, M = len(nums1), len(nums2)\\n        \\n        def ok(k):\\n            # the idea is to use binary search to find the length `k`\\n            # then we check if there is any nums1[i : i + k] == nums2[i : i + k]\\n            s = set(tuple(nums1[i : i + k]) for i in range(N - k + 1))\\n            return any(tuple(nums2[i : i + k]) in s for i in range(M - k + 1))\\n        \\n        # init possible boundary\\n        l, r = 0, min(N, M)\\n        while l < r:\\n            # get the middle one\\n            # for even number of elements, take the upper one\\n            m = (l + r + 1) // 2\\n            if ok(m): \\n                # include m\\n                l = m\\n            else:\\n                # exclude m\\n                r = m - 1\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324432,
                "title": "python-2-solutions-dp-and-rolling-hash-explained",
                "content": "#### Solution 1\\nOne way to solve this problem is to use `dp` approach, where `dp[i][j]` is the length of longest common suffix for `A[:i]` and `B[:j]`. Here we use trick that `dp[-1][i]` in the beginning is equal to zero. To evaluate `dp[i][j]` we just need to look at `dp[i-1][j-1]` if `A[i] == B[j]` and add one to it.\\n\\n#### Complexity\\nTime and space complexity here is `O(nm)`. Space complexity can be reduced to `O(m)` or `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution(object):\\n    def findLength(self, A, B):\\n        n, m = len(A), len(B)\\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\\n        for i in range(n):\\n            for j in range(m):\\n                if A[i] == B[j]:\\n                    dp[i][j] = dp[i-1][j-1]+1\\n        return max(max(row) for row in dp)\\n```\\n\\n#### Solution 2\\n\\nThere is even better solution, using rolling hash: let us ask question if we have common subarray of length `mid`:  Then we do binary search on this mid. Note that we can have collisions, so when we evaluate hashes, I go through all hashes and carefully check for each pair if we have common substring or not.\\n\\n#### Complexity\\nFor fixed `mid` we need `O(min(m,n))`, so overall complexity is `O(log min(m,n) *(m+n))`, space complexity is `O(m+n)`. This is true if we assume that probability of collision is small enough and it is always matter of agreement in these type of approaches what we mean by small. Even though we say have `1` collision, complexity is still the same, because we need to do just additional comparison of strings. \\n\\n#### Code\\n```python\\nclass Solution:\\n    def findLength(self, A, B):\\n        def RabinKarp(text, M):\\n            if M == 0: return {0: [0]}\\n            q = (1 << 31) - 1\\n            h, t, d = (1<<(8*M-8))%q, 0, 256\\n\\n            dic = defaultdict(list)\\n\\n            for i in range(M): \\n                t = (d * t + text[i])% q\\n\\n            dic[t].append(i-M+1)\\n\\n            for i in range(len(text) - M):\\n                t = (d*(t-text[i]*h) + text[i + M])% q\\n                dic[t].append(i+1)\\n            return dic\\n        \\n        beg, end = 0, min(len(A), len(B)) + 1\\n        while beg + 1 < end:\\n            mid = (beg + end)//2\\n            d1, d2 = RabinKarp(A, mid), RabinKarp(B, mid)\\n            check = False\\n            for el in d1:\\n                l1, l2 = d1[el], d2[el]\\n                if any(A[q1:q1+mid]==B[q2:q2+mid] for q1, q2 in product(l1, l2)): check = True\\n                \\n            if check:\\n                beg = mid\\n            else:\\n                end = mid\\n        return beg\\n```\\n\\n#### Remark\\nSee also problem **1923. Longest Common Subpath** https://leetcode.com/problems/longest-common-subpath/discuss/1314316/Python-Rolling-Hash-solution-explained , where you can apply rolling hash approach, but you can not apply dp approach. That is why I think it is important after you solved problem check discussion section and see if there are different ways to solve it and what are complexities.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Rolling Hash"
                ],
                "code": "```python\\nclass Solution(object):\\n    def findLength(self, A, B):\\n        n, m = len(A), len(B)\\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\\n        for i in range(n):\\n            for j in range(m):\\n                if A[i] == B[j]:\\n                    dp[i][j] = dp[i-1][j-1]+1\\n        return max(max(row) for row in dp)\\n```\n```python\\nclass Solution:\\n    def findLength(self, A, B):\\n        def RabinKarp(text, M):\\n            if M == 0: return {0: [0]}\\n            q = (1 << 31) - 1\\n            h, t, d = (1<<(8*M-8))%q, 0, 256\\n\\n            dic = defaultdict(list)\\n\\n            for i in range(M): \\n                t = (d * t + text[i])% q\\n\\n            dic[t].append(i-M+1)\\n\\n            for i in range(len(text) - M):\\n                t = (d*(t-text[i]*h) + text[i + M])% q\\n                dic[t].append(i+1)\\n            return dic\\n        \\n        beg, end = 0, min(len(A), len(B)) + 1\\n        while beg + 1 < end:\\n            mid = (beg + end)//2\\n            d1, d2 = RabinKarp(A, mid), RabinKarp(B, mid)\\n            check = False\\n            for el in d1:\\n                l1, l2 = d1[el], d2[el]\\n                if any(A[q1:q1+mid]==B[q2:q2+mid] for q1, q2 in product(l1, l2)): check = True\\n                \\n            if check:\\n                beg = mid\\n            else:\\n                end = mid\\n        return beg\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599253,
                "title": "python3-runtime-178-ms-faster-than-99-92-memory-13-8-mb-less-than-99-81",
                "content": "```\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        strnum2 = \\'\\'.join([chr(x) for x in nums2])\\n        strmax = \\'\\'\\n        ans = 0\\n        for num in nums1:\\n            strmax += chr(num)\\n            if strmax in strnum2:\\n                ans = max(ans,len(strmax))\\n            else:\\n                strmax = strmax[1:]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        strnum2 = \\'\\'.join([chr(x) for x in nums2])\\n        strmax = \\'\\'\\n        ans = 0\\n        for num in nums1:\\n            strmax += chr(num)\\n            if strmax in strnum2:\\n                ans = max(ans,len(strmax))\\n            else:\\n                strmax = strmax[1:]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 259890,
                "title": "c-linear-space-dp",
                "content": "We define `dp[i][j]` to be the length of the longest common subarray ending at `A[i]` and `B[j]`. If `A[i] != B[j]`, the length is simply 0; otherwise, `dp[i][j] = dp[i - 1][j - 1] + 1`. And the maximum length is the maximum of `dp[i][j]`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        int m = A.size(), n = B.size(), ans = 0;\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (A[i - 1] == B[j - 1]) {\\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\\n                    ans = max(ans, dp[i][j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIn the above code, each time we update `dp[i][j]`, we only need the value of `dp[i - 1][j - 1]`, so we need not store the whole `m * n` matrix. Instead, two rows is enough.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        int m = A.size(), n = B.size(), ans = 0;\\n        vector<int> pre(n + 1, 0), cur(n + 1, 0);\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (A[i - 1] == B[j - 1]) {\\n                    cur[j] = pre[j - 1] + 1;\\n                    ans = max(ans, cur[j]);\\n                }\\n            }\\n            fill(pre.begin(), pre.end(), 0);\\n            swap(pre, cur);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nWe may further reduce `pre` to be just a single variable.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        int m = A.size(), n = B.size(), ans = 0;\\n        vector<int> cur(n + 1, 0);\\n        for (int i = 1; i <= m; i++) {\\n            int pre = cur[0];\\n            for (int j = 1; j <= n; j++) {\\n                int temp = cur[j];\\n                if (A[i - 1] == B[j - 1]) {\\n                    cur[j] = pre + 1;\\n                    ans = max(ans, cur[j]);\\n                } else {\\n                    cur[j] = 0;\\n                }\\n                pre = temp;                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        int m = A.size(), n = B.size(), ans = 0;\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (A[i - 1] == B[j - 1]) {\\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\\n                    ans = max(ans, dp[i][j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        int m = A.size(), n = B.size(), ans = 0;\\n        vector<int> pre(n + 1, 0), cur(n + 1, 0);\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (A[i - 1] == B[j - 1]) {\\n                    cur[j] = pre[j - 1] + 1;\\n                    ans = max(ans, cur[j]);\\n                }\\n            }\\n            fill(pre.begin(), pre.end(), 0);\\n            swap(pre, cur);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        int m = A.size(), n = B.size(), ans = 0;\\n        vector<int> cur(n + 1, 0);\\n        for (int i = 1; i <= m; i++) {\\n            int pre = cur[0];\\n            for (int j = 1; j <= n; j++) {\\n                int temp = cur[j];\\n                if (A[i - 1] == B[j - 1]) {\\n                    cur[j] = pre + 1;\\n                    ans = max(ans, cur[j]);\\n                } else {\\n                    cur[j] = 0;\\n                }\\n                pre = temp;                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600660,
                "title": "short-c-explained-solution-beginner-friendly-by-mr-coder",
                "content": "\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**\\n\\n***Watch this video for the better explanation of the code.***\\n\\n\\nhttps://www.youtube.com/watch?v=jAQkdXSXHAg\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n  int findLength(vector<int>& A, vector<int>& B) {\\n        \\n       \\n        int n1 = A.size(), n2 = B.size();\\n     \\n        vector<int> dp(n2+1, 0);\\n        int ans = 0;\\n        \\n        for(int i = 0; i < n1; i++) {\\n            for(int j = n2 - 1; j >= 0; j--) {\\n                \\n                if (A[i] == B[j]) {\\n                    dp[j + 1] = 1 + dp[j];\\n                } else {\\n                    dp[j + 1] = 0;\\n                }\\n                              \\n                ans = max(ans, dp[j + 1]);\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int findLength(vector<int>& A, vector<int>& B) {\\n        \\n       \\n        int n1 = A.size(), n2 = B.size();\\n     \\n        vector<int> dp(n2+1, 0);\\n        int ans = 0;\\n        \\n        for(int i = 0; i < n1; i++) {\\n            for(int j = n2 - 1; j >= 0; j--) {\\n                \\n                if (A[i] == B[j]) {\\n                    dp[j + 1] = 1 + dp[j];\\n                } else {\\n                    dp[j + 1] = 0;\\n                }\\n                              \\n                ans = max(ans, dp[j + 1]);\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324738,
                "title": "maximum-length-of-repeated-subarray-optimization-from-brute-force-to-dp-explained",
                "content": "\\u274C ***Solution - I (Brute-Force)***\\n\\nWe need to find maximum length of common subarray between `A` and `B`. Let\\'s try solving it starting with brute-force approach. \\n\\nWe know that the maximum common subarray will start at some indices `i` and `j` of array `A` and `B` respectively. So, we will just simply take each possible pair `(i, j)` and try to extend it from there to get maximum common subarray starting at that index pair. Finally, we will return the max length found after trying out all pairs\\n\\n* **Recursive Version :** \\n\\t```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint ans = 0;\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n\\t\\t\\tsolve(A, B, 0, 0);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tint solve(vector<int>& A, vector<int>& B, int i, int j) {\\n\\t\\t\\tif(i >= size(A) || j >= size(B)) return 0;\\n\\t\\t\\tsolve(A, B, i+1, j), solve(A, B, i, j+1);                   // recurse to solve for each possible (i, j)\\n\\t\\t\\tint common = A[i] == B[j] ? 1 + solve(A, B, i+1, j+1) : 0;  // longest common subarray starting at A[i] & B[j]\\n\\t\\t\\tans = max(ans, common);                                     // update ans to hold max length found till now\\n\\t\\t\\treturn common;\\n\\t\\t}\\n\\t};\\t\\n\\t```\\n\\t\\n\\t***Time Complexity :***  <b><code>O(3<sup>M + N</sup>)</code></b>, where `M` is size of `A` and `N` is size of `B`. We have 3 choices at each recursion and max recursion depth is `M+N`.\\n\\t***Space Complexity :***  **`O(M + N)`**, max depth of recursive stack. \\n\\t\\n\\t---\\n\\n* **Iterative Version :**\\n\\n\\t```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n\\t\\t\\tint m = size(A), n = size(B), ans = 0;\\n\\t\\t\\tfor(int i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\t\\t\\tint len = 0;\\n\\t\\t\\t\\t\\twhile(i + len < m and j + len < n and A[i+len] == B[j+len]) len++; // get length of longest common subarray starting at A[i] & B[j]\\n\\t\\t\\t\\t\\tans = max(ans, len);  // update ans to hold max length found till now\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\t\\n\\t```\\n\\t\\n\\t***Time Complexity :***  **`O(M * N * min(M,N))`**, Here, at each possible `(i, j)` we find longest common subarray. There at total of `M*N` pairs and we can extend at max `O(min(M, N))` from each pair.\\n\\t***Space Complexity :***  **`O(1)`**\\n\\n\\n\\t\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Dynamic Programming)***\\n\\nWe can see that the length of common subarray starting at `A[i]` and `B[i]` will always be same. But we are still re-calculating the same multiple times in the brute force approaches. Instead, we could store the answer for a given pair of indices and re-use it in the future instead of re-calculating over and over. Thus, we can apply dynamic programming here.\\n\\nHere, we are using `dp` matrix where `dp[i][j]` will denote longest common subarray starting at `A[i]` and `B[j]`. Once we calculate the result for `dp[i][j]`, it can be re-used whenever required in the future recursive calls / iterations.\\n\\n* **Recursive DP - Memoization :**\\n\\n\\t```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>>dp;\\n\\t\\tint ans = 0;\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n\\t\\t\\tdp.resize(size(A), vector<int>(size(B), -1));\\n\\t\\t\\tsolve(A, B, 0, 0);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tint solve(vector<int>& A, vector<int>& B, int i, int j) {\\n\\t\\t\\tif(i >= size(A) || j >= size(B)) return 0;\\n\\t\\t\\tif(dp[i][j] != -1) return dp[i][j];\\n\\t\\t\\tsolve(A, B, i+1, j), solve(A, B, i, j+1);\\n\\t\\t\\tdp[i][j] = A[i] == B[j] ? solve(A, B, i+1, j+1) + 1 : 0;  // store the result for state (i, j) for future\\n\\t\\t\\tans = max(ans, dp[i][j]);\\n\\t\\t\\treturn dp[i][j];\\n\\t\\t}\\n\\t};\\t\\n\\t```\\n\\t\\n\\t---\\n\\t\\n* **Iterative DP - Tabulation :**\\n\\t\\n\\t```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n\\t\\t\\tint m = size(A), n = size(B), ans = 0, dp[m+1][n+1]; \\n\\t\\t\\tmemset(dp, -1, sizeof dp);\\n\\t\\t\\tfor(int i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor(int j = 0, len = 0; j < n; j++) {\\n\\t\\t\\t\\t\\tif(dp[i][j] == -1) {\\n\\t\\t\\t\\t\\t\\twhile(i + len < m and j + len < n and A[i+len] == B[j+len]) len++;\\n\\t\\t\\t\\t\\t\\twhile(len) dp[i + len][j + len] = len--;  // store the result for states (i, j) : \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  // we know results for all states from (i, j) - (i+len, j+len)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tans = max(ans, dp[i][j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\t\\n\\t```\\n   \\n     I have mentioned the above approach as a direct DP integration into brute-force solution. It can be seen that it\\'s probably better to start from the end of both array so that we don\\'t need to forward iterate once (for finding longest subarray length) and then re-iterate backward again (for storing the results in `dp`). The above code can be re-written as -\\n\\t \\n\\t ```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n\\t\\t\\tint m = size(A), n = size(B), ans = 0, dp[m+1][n+1]; \\n\\t\\t\\tmemset(dp, 0, sizeof dp);\\n\\t\\t\\tfor(int i = m-1; ~i; i--) \\n\\t\\t\\t\\tfor(int j = n-1; ~j; j--) \\n\\t\\t\\t\\t\\tdp[i][j] = A[i-1] == B[j-1] ? dp[i+1][j+1] + 1 : 0,\\n\\t\\t\\t\\t\\tans = max(ans, dp[i][j]);\\n\\t\\t\\t\\t\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\t\\t \\n\\t ```\\n\\n***Time Complexity :***  **`O(M * N)`**, In both the approaches, we calculate the result for an index pair `(i, j)` only once\\n***Space Complexity :***  **`O(M * N)`**, required to store `dp` matrix.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Another DP Variant)***\\n\\nWe can solve this using dp in another way. Instead of storing the longest common substring starting at `(i, j)` index pair (i.e longest common prefix subarray), we can store the longest common substring ending at `(i, j)` as well (i.e longest common suffix subarray). Here `dp[i][j]` will denote longest subarray ending at `A[i]` and `B[j]` -\\n\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        int m = size(A), n = size(B), ans = 0;\\n\\t\\tint dp[m+1][n+1]; memset(dp, 0, sizeof dp);\\n        for(int i = 1; i <= m; i++) \\n            for(int j = 1; j <= n; j++) \\n                dp[i][j] = A[i-1] == B[j-1] ? dp[i-1][j-1] + 1 : 0,\\n                ans = max(ans, dp[i][j]);\\n            \\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :***  **`O(M * N)`**\\n***Space Complexity :***  **`O(M * N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Space-Optimized DP)***\\n\\nWe can see that in both the dp variants, we are only ever accessing the current previous rows of the `dp` matrix. So we don\\'t need to store all the dp matrix throughout our program. We just need to store the current row and the previous row of `dp` at any given point of time. Thus we can optimize the space usage to linear complexity.\\n\\nA common way to optimize from 2D DP to 1D DP is to just declare a two row matrix and alternate between the rows at each iteration. We declare two variables `cur` and `prev` and alternate them for each row.\\n\\n* **1st DP Variant - Space Optimized :**\\n\\n\\t```\\n\\tclass Solution {\\n\\tpublic:\\n\\t   int findLength(vector<int>& A, vector<int>& B) {\\n\\t\\tif(size(A) < size(B)) A.swap(B);   // ensures dp length is min(M, N)\\n\\t\\tint m = size(A), n = size(B), ans = 0, dp[2][n+1]; \\n\\t\\tmemset(dp, 0, sizeof dp);\\n\\t\\tfor(int i = m-1, cur=i&1, next=!(i&1); ~i; i--, cur ^= 1, next ^= 1) // ~i ends loop when i goes -ve, ^= 1 used to flip bit\\n\\t\\t\\tfor(int j = n-1; ~j; j--) \\n\\t\\t\\t\\tdp[cur][j] = A[i] == B[j] ? dp[next][j+1] + 1 : 0,\\n\\t\\t\\t\\tans = max(ans, dp[cur][j]);\\n\\t\\t\\t\\n\\t\\treturn ans;\\n\\t   }\\n\\t};\\t\\t\\n\\t```\\n\\t\\n\\t---\\n\\n* **2nd DP Variant - Space Optimized :**\\n\\n\\t```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n\\t\\t\\tif(size(A) < size(B)) A.swap(B); \\n\\t\\t\\tint m = size(A), n = size(B), ans = 0, dp[2][n+1]; \\n\\t\\t\\tmemset(dp, 0, sizeof dp);\\n\\t\\t\\tfor(int i = 1, cur = 1, prev{}; i <= m; i++, cur ^= 1, prev ^= 1) \\n\\t\\t\\t\\tfor(int j = 1; j <= n; j++) \\n\\t\\t\\t\\t\\tdp[cur][j] = A[i-1] == B[j-1] ? dp[prev][j-1] + 1 : 0,\\n\\t\\t\\t\\t\\tans = max(ans, dp[cur][j]);\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\t\\n\\t```\\n\\t\\n\\n\\n\\n***Time Complexity :***  **`O(M * N)`**\\n***Space Complexity :***  **`O(min(M, N))`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint ans = 0;\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n\\t\\t\\tsolve(A, B, 0, 0);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tint solve(vector<int>& A, vector<int>& B, int i, int j) {\\n\\t\\t\\tif(i >= size(A) || j >= size(B)) return 0;\\n\\t\\t\\tsolve(A, B, i+1, j), solve(A, B, i, j+1);                   // recurse to solve for each possible (i, j)\\n\\t\\t\\tint common = A[i] == B[j] ? 1 + solve(A, B, i+1, j+1) : 0;  // longest common subarray starting at A[i] & B[j]\\n\\t\\t\\tans = max(ans, common);                                     // update ans to hold max length found till now\\n\\t\\t\\treturn common;\\n\\t\\t}\\n\\t};\\t\\n\\t```\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n\\t\\t\\tint m = size(A), n = size(B), ans = 0;\\n\\t\\t\\tfor(int i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\t\\t\\tint len = 0;\\n\\t\\t\\t\\t\\twhile(i + len < m and j + len < n and A[i+len] == B[j+len]) len++; // get length of longest common subarray starting at A[i] & B[j]\\n\\t\\t\\t\\t\\tans = max(ans, len);  // update ans to hold max length found till now\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\t\\n\\t```\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>>dp;\\n\\t\\tint ans = 0;\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n\\t\\t\\tdp.resize(size(A), vector<int>(size(B), -1));\\n\\t\\t\\tsolve(A, B, 0, 0);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tint solve(vector<int>& A, vector<int>& B, int i, int j) {\\n\\t\\t\\tif(i >= size(A) || j >= size(B)) return 0;\\n\\t\\t\\tif(dp[i][j] != -1) return dp[i][j];\\n\\t\\t\\tsolve(A, B, i+1, j), solve(A, B, i, j+1);\\n\\t\\t\\tdp[i][j] = A[i] == B[j] ? solve(A, B, i+1, j+1) + 1 : 0;  // store the result for state (i, j) for future\\n\\t\\t\\tans = max(ans, dp[i][j]);\\n\\t\\t\\treturn dp[i][j];\\n\\t\\t}\\n\\t};\\t\\n\\t```\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n\\t\\t\\tint m = size(A), n = size(B), ans = 0, dp[m+1][n+1]; \\n\\t\\t\\tmemset(dp, -1, sizeof dp);\\n\\t\\t\\tfor(int i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor(int j = 0, len = 0; j < n; j++) {\\n\\t\\t\\t\\t\\tif(dp[i][j] == -1) {\\n\\t\\t\\t\\t\\t\\twhile(i + len < m and j + len < n and A[i+len] == B[j+len]) len++;\\n\\t\\t\\t\\t\\t\\twhile(len) dp[i + len][j + len] = len--;  // store the result for states (i, j) : \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  // we know results for all states from (i, j) - (i+len, j+len)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tans = max(ans, dp[i][j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\t\\n\\t```\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n\\t\\t\\tint m = size(A), n = size(B), ans = 0, dp[m+1][n+1]; \\n\\t\\t\\tmemset(dp, 0, sizeof dp);\\n\\t\\t\\tfor(int i = m-1; ~i; i--) \\n\\t\\t\\t\\tfor(int j = n-1; ~j; j--) \\n\\t\\t\\t\\t\\tdp[i][j] = A[i-1] == B[j-1] ? dp[i+1][j+1] + 1 : 0,\\n\\t\\t\\t\\t\\tans = max(ans, dp[i][j]);\\n\\t\\t\\t\\t\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\t\\t \\n\\t ```\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        int m = size(A), n = size(B), ans = 0;\\n\\t\\tint dp[m+1][n+1]; memset(dp, 0, sizeof dp);\\n        for(int i = 1; i <= m; i++) \\n            for(int j = 1; j <= n; j++) \\n                dp[i][j] = A[i-1] == B[j-1] ? dp[i-1][j-1] + 1 : 0,\\n                ans = max(ans, dp[i][j]);\\n            \\n        return ans;\\n    }\\n};\\n```\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t   int findLength(vector<int>& A, vector<int>& B) {\\n\\t\\tif(size(A) < size(B)) A.swap(B);   // ensures dp length is min(M, N)\\n\\t\\tint m = size(A), n = size(B), ans = 0, dp[2][n+1]; \\n\\t\\tmemset(dp, 0, sizeof dp);\\n\\t\\tfor(int i = m-1, cur=i&1, next=!(i&1); ~i; i--, cur ^= 1, next ^= 1) // ~i ends loop when i goes -ve, ^= 1 used to flip bit\\n\\t\\t\\tfor(int j = n-1; ~j; j--) \\n\\t\\t\\t\\tdp[cur][j] = A[i] == B[j] ? dp[next][j+1] + 1 : 0,\\n\\t\\t\\t\\tans = max(ans, dp[cur][j]);\\n\\t\\t\\t\\n\\t\\treturn ans;\\n\\t   }\\n\\t};\\t\\t\\n\\t```\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n\\t\\t\\tif(size(A) < size(B)) A.swap(B); \\n\\t\\t\\tint m = size(A), n = size(B), ans = 0, dp[2][n+1]; \\n\\t\\t\\tmemset(dp, 0, sizeof dp);\\n\\t\\t\\tfor(int i = 1, cur = 1, prev{}; i <= m; i++, cur ^= 1, prev ^= 1) \\n\\t\\t\\t\\tfor(int j = 1; j <= n; j++) \\n\\t\\t\\t\\t\\tdp[cur][j] = A[i-1] == B[j-1] ? dp[prev][j-1] + 1 : 0,\\n\\t\\t\\t\\t\\tans = max(ans, dp[cur][j]);\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\t\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1752606,
                "title": "c-java-memo-tabulation-4-solutions-time-o-n-m-space-o-n-lcs",
                "content": "**MEMOIZATION 1 -** *TC - O(N^3) & SC - O(N^3)*   **(TLE)**\\n<iframe src=\"https://leetcode.com/playground/RSiM7Fmj/shared\" frameBorder=\"0\" width=\"1080\" height=\"420\"></iframe>\\n\\n**MEMOIZATION 2 -** *TC - O(N^2) & SC - O(N^2)*   **(ACCEPTED)**\\n<iframe src=\"https://leetcode.com/playground/3Wv988ou/shared\" frameBorder=\"0\" width=\"1080\" height=\"450\"></iframe>\\n\\n**TABULATION 1 -** *TC - O(N^2) & SC - O(N^2)*   **(ACCEPTED)**\\n\\n<iframe src=\"https://leetcode.com/playground/My49dxro/shared\" frameBorder=\"0\" width=\"1080\" height=\"410\"></iframe>\\n\\n**TABULATION 2 -** *TC - O(N^2) & SC - O(N)*   **(BEST APPROACH)**\\n<iframe src=\"https://leetcode.com/playground/VAVVMAC3/shared\" frameBorder=\"0\" width=\"1080\" height=\"412\"></iframe>",
                "solutionTags": [
                    "Java",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "**MEMOIZATION 1 -** *TC - O(N^3) & SC - O(N^3)*   **(TLE)**\\n<iframe src=\"https://leetcode.com/playground/RSiM7Fmj/shared\" frameBorder=\"0\" width=\"1080\" height=\"420\"></iframe>\\n\\n**MEMOIZATION 2 -** *TC - O(N^2) & SC - O(N^2)*   **(ACCEPTED)**\\n<iframe src=\"https://leetcode.com/playground/3Wv988ou/shared\" frameBorder=\"0\" width=\"1080\" height=\"450\"></iframe>\\n\\n**TABULATION 1 -** *TC - O(N^2) & SC - O(N^2)*   **(ACCEPTED)**\\n\\n<iframe src=\"https://leetcode.com/playground/My49dxro/shared\" frameBorder=\"0\" width=\"1080\" height=\"410\"></iframe>\\n\\n**TABULATION 2 -** *TC - O(N^2) & SC - O(N)*   **(BEST APPROACH)**\\n<iframe src=\"https://leetcode.com/playground/VAVVMAC3/shared\" frameBorder=\"0\" width=\"1080\" height=\"412\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 156891,
                "title": "binary-search-rabin-karp-hash-table-o-n-log-n-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        const int P = 19941229; //Rabin-Karp\\n        \\n        vector<int> hash1(A.size() + 1, 0), hash2(B.size() + 1, 0), p(max(A.size(), B.size()) + 1);\\n        int len = max(A.size(), B.size());\\n        p[0] = 1;\\n        for (int i = 1; i <= len; i++)\\n            p[i] = p[i - 1] * P;\\n        for (int i = 1; i <= A.size(); i++)\\n            hash1[i] = hash1[i - 1] + A[i - 1] * p[i];\\n        for (int i = 1; i <= B.size(); i++)\\n            hash2[i] = hash2[i - 1] + B[i - 1] * p[i];\\n        int l = 1, r = min(A.size(), B.size());\\n        while (l <= r) { //Binary search the answer\\n            int m = (l + r) / 2;\\n            unordered_set<int> hash;\\n            bool ok = false;\\n            for (int i = 1; i + m - 1 <= A.size(); i++) //Calculate Rabin-Karp hash for all substring s for the first string of length m, insert into hash table\\n                hash.insert((hash1[i + m - 1] - hash1[i - 1]) * p[len - (i + m - 1)]);\\n            for (int i = 1; i + m - 1 <= B.size(); i++){ //Calculate Rabin-Karp hash for the second string, query the hash table\\n                if (hash.count((hash2[i + m - 1] - hash2[i - 1]) * p[len - (i + m - 1)])) {\\n                    ok = true;\\n                    break;\\n                }\\n            }\\n            if (ok)\\n                l = m + 1;\\n            else\\n                r = m - 1;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        const int P = 19941229; //Rabin-Karp\\n        \\n        vector<int> hash1(A.size() + 1, 0), hash2(B.size() + 1, 0), p(max(A.size(), B.size()) + 1);\\n        int len = max(A.size(), B.size());\\n        p[0] = 1;\\n        for (int i = 1; i <= len; i++)\\n            p[i] = p[i - 1] * P;\\n        for (int i = 1; i <= A.size(); i++)\\n            hash1[i] = hash1[i - 1] + A[i - 1] * p[i];\\n        for (int i = 1; i <= B.size(); i++)\\n            hash2[i] = hash2[i - 1] + B[i - 1] * p[i];\\n        int l = 1, r = min(A.size(), B.size());\\n        while (l <= r) { //Binary search the answer\\n            int m = (l + r) / 2;\\n            unordered_set<int> hash;\\n            bool ok = false;\\n            for (int i = 1; i + m - 1 <= A.size(); i++) //Calculate Rabin-Karp hash for all substring s for the first string of length m, insert into hash table\\n                hash.insert((hash1[i + m - 1] - hash1[i - 1]) * p[len - (i + m - 1)]);\\n            for (int i = 1; i + m - 1 <= B.size(); i++){ //Calculate Rabin-Karp hash for the second string, query the hash table\\n                if (hash.count((hash2[i + m - 1] - hash2[i - 1]) * p[len - (i + m - 1)])) {\\n                    ok = true;\\n                    break;\\n                }\\n            }\\n            if (ok)\\n                l = m + 1;\\n            else\\n                r = m - 1;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181612,
                "title": "java-clean-o-n-logn-rolling-hash-solution-with-comments",
                "content": "For those who are not familiar with Rabin-Karp rolling-hash method, I strongly recommand you try this question first. \\n* [28. Implement strStr()](https://leetcode.com/problems/implement-strstr/)\\n\\nYou might also want to try and compare these questions to realize the power of Rabin-Karp\\'s:\\n* [214. Shortest Palindrome](https://leetcode.com/problems/shortest-palindrome/)\\n* [718. Maximum Length of Repeated Subarray](https://leetcode.com/problems/maximum-length-of-repeated-subarray/discuss/1181612/Java-Clean-O(N-logN)-Rolling-Hash-Solution-oror-with-comments)\\n* [1044. Longest Duplicate Substring (collision)](https://leetcode.com/problems/longest-duplicate-substring/discuss/1260058/Java-Rabin-Karp-O(N-logN)-Solution-oror-with-comments)\\n* [1316. Distinct Echo Substrings](https://leetcode.com/problems/distinct-echo-substrings/discuss/1181698/Java-clean-O(n2)-Rolling-Hash-Solution-oror-with-comments)\\n* [1698. Number of Distinct Substrings in a String](https://leetcode.com/problems/number-of-distinct-substrings-in-a-string/discuss/1196782/Java-clean-O(N2)-Rabin-Karp-Solution)\\n\\nThe rolling hash solution is pretty straightforward and this article aims to give some important notes when performing this algorithm. \\n\\nThe key step is to update hash similar to: \\n```\\nhash = hash - B[i] * (long) Math.pow(PRIME, mid-1);\\nhash = hash * PRIME + B[j];\\n```\\nHowever, chances are that your solution will fail if you implement your algorithm like above. These frustrating failures happen not because of the instablilty of hashing, but because of these three main issues. \\n1.  since hash == 0 at the beginning, if each step B[i] == 0, hash will still be 0; Namely, [0], [0, 0], [0, 0, ..., 0] will have the same hash value;\\n2.  Math.pow(PRIME, mid-1) will overflow even if we use long\\n3.  after minus some number, hash may be negative\\n \\nTo solve these issues, we may consider: \\n1. use (B[i] + 1) instead of B[i] since A[i], B[i] >= 0 for all i;\\n2. pre-calculate the remainder of Math.pow(PRIME, mid-1) by taking modulus in each step\\n3. take modulus again for (B[i] + 1) * power to make it less than MOD\\n4. add MOD after calculation to make hash non-smaller than 0;\\n\\nSo we may do something like this when updating hash value at each step:\\n```\\nlong power = 1;\\nfor (int i = 0; i < mid-1; i++) {\\n\\tpower = (power * PRIME) % MOD;\\n}\\n\\nhash = hash - ((B[i] + 1) * power % MOD) + MOD;\\nhash = hash * PRIME + (B[j] + 1);\\nhash %= MOD;\\n```\\n\\nFinally, here is the complete Solution: \\n```\\nclass Solution {\\n    private static final int PRIME = 101;\\n    private static final int MOD = 1_000_000_007;\\n    \\n    public int findLength(int[] A, int[] B) {\\n        if (A.length < B.length) return findLength(B, A);\\n        \\n        // 1.) Check result for length 1  <==>  single character\\n        Set<Integer> set = new HashSet<>();\\n        boolean lenZero = false;\\n        \\n        for (int a : A) set.add(a);\\n        for (int b : B) {\\n            if (!set.contains(b)) continue;\\n            lenZero = true;\\n            break;\\n        }\\n        \\n        if (!lenZero) return 0;\\n        \\n        \\n        // 2). Now the result lies in [1, min(A.length, B.length)], perform binary serach\\n        int left = 1, right = Math.min(A.length, B.length);\\n        while (left < right - 1) {\\n            int mid = left + (right - left) / 2;\\n            if (check(mid, A, B)) left = mid;\\n            else right = mid - 1;\\n        }\\n        return check(right, A, B) ? right : left;\\n    }\\n    \\n    // check every subarray with length mid\\n    private boolean check(int mid, int[] A, int[] B) {\\n        Set<Integer> set = new HashSet<>();  \\n        \\n        // 1). Adding hash values of subarrays of B into set\\n        long hash = 0;\\n        for (int j = 0; j < mid; j++) {\\n            hash = hash * PRIME + (B[j] + 1);\\n            hash %= MOD;\\n        }\\n        set.add((int) hash);\\n        \\n        long power = 1;\\n        for (int i = 0; i < mid-1; i++) {\\n            power = (power * PRIME) % MOD;\\n        }\\n        \\n        for (int i = 0, j = mid; j < B.length; i++, j++) {\\n            hash = hash - ((B[i] + 1) * power % MOD) + MOD;\\n            hash = hash * PRIME + (B[j] + 1);\\n            hash %= MOD;\\n            set.add((int) hash);\\n        }\\n        \\n        // 2.) Check the hash values of subarrays of A\\n        hash = 0;\\n        for (int j = 0; j < mid; j++) {\\n            hash = hash * PRIME + (A[j] + 1);\\n            hash %= MOD;\\n        }\\n        if (set.contains((int)hash)) return true;\\n        \\n        for (int i = 0, j = mid; j < A.length; i++, j++) {\\n            hash = hash - ((A[i] + 1) * power % MOD) + MOD;\\n            hash = hash * PRIME + (A[j] + 1);\\n            hash %= MOD;\\n            if (set.contains((int)hash)) return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\nNote, using Dynammic Programming to solve this problem may be more natural for some people. Feel free to check this post for an O(1)-Space Dynammic Programming Solution: \\n* [718. Maximum Length of Repeated Subarray: Dynammic Programming Solution](https://leetcode.com/problems/maximum-length-of-repeated-subarray/discuss/1199034/Java-Clean-O(N2)-Time-O(1)-Space-Dynamic-Programming-Solution-oror-with-comments)",
                "solutionTags": [
                    "Java",
                    "Rolling Hash",
                    "Binary Tree"
                ],
                "code": "```\\nhash = hash - B[i] * (long) Math.pow(PRIME, mid-1);\\nhash = hash * PRIME + B[j];\\n```\n```\\nlong power = 1;\\nfor (int i = 0; i < mid-1; i++) {\\n\\tpower = (power * PRIME) % MOD;\\n}\\n\\nhash = hash - ((B[i] + 1) * power % MOD) + MOD;\\nhash = hash * PRIME + (B[j] + 1);\\nhash %= MOD;\\n```\n```\\nclass Solution {\\n    private static final int PRIME = 101;\\n    private static final int MOD = 1_000_000_007;\\n    \\n    public int findLength(int[] A, int[] B) {\\n        if (A.length < B.length) return findLength(B, A);\\n        \\n        // 1.) Check result for length 1  <==>  single character\\n        Set<Integer> set = new HashSet<>();\\n        boolean lenZero = false;\\n        \\n        for (int a : A) set.add(a);\\n        for (int b : B) {\\n            if (!set.contains(b)) continue;\\n            lenZero = true;\\n            break;\\n        }\\n        \\n        if (!lenZero) return 0;\\n        \\n        \\n        // 2). Now the result lies in [1, min(A.length, B.length)], perform binary serach\\n        int left = 1, right = Math.min(A.length, B.length);\\n        while (left < right - 1) {\\n            int mid = left + (right - left) / 2;\\n            if (check(mid, A, B)) left = mid;\\n            else right = mid - 1;\\n        }\\n        return check(right, A, B) ? right : left;\\n    }\\n    \\n    // check every subarray with length mid\\n    private boolean check(int mid, int[] A, int[] B) {\\n        Set<Integer> set = new HashSet<>();  \\n        \\n        // 1). Adding hash values of subarrays of B into set\\n        long hash = 0;\\n        for (int j = 0; j < mid; j++) {\\n            hash = hash * PRIME + (B[j] + 1);\\n            hash %= MOD;\\n        }\\n        set.add((int) hash);\\n        \\n        long power = 1;\\n        for (int i = 0; i < mid-1; i++) {\\n            power = (power * PRIME) % MOD;\\n        }\\n        \\n        for (int i = 0, j = mid; j < B.length; i++, j++) {\\n            hash = hash - ((B[i] + 1) * power % MOD) + MOD;\\n            hash = hash * PRIME + (B[j] + 1);\\n            hash %= MOD;\\n            set.add((int) hash);\\n        }\\n        \\n        // 2.) Check the hash values of subarrays of A\\n        hash = 0;\\n        for (int j = 0; j < mid; j++) {\\n            hash = hash * PRIME + (A[j] + 1);\\n            hash %= MOD;\\n        }\\n        if (set.contains((int)hash)) return true;\\n        \\n        for (int i = 0, j = mid; j < A.length; i++, j++) {\\n            hash = hash - ((A[i] + 1) * power % MOD) + MOD;\\n            hash = hash * PRIME + (A[j] + 1);\\n            hash %= MOD;\\n            if (set.contains((int)hash)) return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768495,
                "title": "longest-common-substring-python-dp-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef findLength(self, A: List[int], B: List[int]) -> int:\\n\\n\\t\\t\\tn = len(A)\\n\\t\\t\\tm = len(B)\\n\\t\\t\\t\\n\\t\\t\\t#Edge cases.\\n\\t\\t\\tif m == 0 or n == 0:\\n\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\tif n == 1 and m == 1:\\n\\t\\t\\t\\tif A[0] == B[0]:\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\n\\t\\t\\t#Initializing first row and column with 0 (for ease i intialized everthing 0 :p)\\n\\t\\t\\tdp = [[0 for x in range(m + 1)] for y in range(n + 1)]\\n\\n\\t\\t\\tfinal = 0\\n\\t\\t\\t\\n\\t\\t\\t#this code is a lot like longest common subsequence(only else condition is different). \\n\\t\\t\\tfor i in range(1, n + 1):\\n\\t\\t\\t\\tfor j in range(1, m + 1):\\n\\t\\t\\t\\t\\tif A[i - 1] == B[j - 1]:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = 1 + dp[i - 1][j - 1]\\n\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = 0\\n\\n\\t\\t\\t\\t\\tfinal = max(final, dp[i][j])\\n\\n\\t\\t\\treturn final\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef findLength(self, A: List[int], B: List[int]) -> int:\\n\\n\\t\\t\\tn = len(A)\\n\\t\\t\\tm = len(B)\\n\\t\\t\\t\\n\\t\\t\\t#Edge cases.\\n\\t\\t\\tif m == 0 or n == 0:\\n\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\tif n == 1 and m == 1:\\n\\t\\t\\t\\tif A[0] == B[0]:\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\n\\t\\t\\t#Initializing first row and column with 0 (for ease i intialized everthing 0 :p)\\n\\t\\t\\tdp = [[0 for x in range(m + 1)] for y in range(n + 1)]\\n\\n\\t\\t\\tfinal = 0\\n\\t\\t\\t\\n\\t\\t\\t#this code is a lot like longest common subsequence(only else condition is different). \\n\\t\\t\\tfor i in range(1, n + 1):\\n\\t\\t\\t\\tfor j in range(1, m + 1):\\n\\t\\t\\t\\t\\tif A[i - 1] == B[j - 1]:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = 1 + dp[i - 1][j - 1]\\n\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = 0\\n\\n\\t\\t\\t\\t\\tfinal = max(final, dp[i][j])\\n\\n\\t\\t\\treturn final\\n",
                "codeTag": "Java"
            },
            {
                "id": 2599245,
                "title": "java-explained-in-detail-dynamic-programming-tabulation",
                "content": "I do my best everyday to give a clear explanation, so to help everyone improve their skills.\\n\\nIf you find this **helpful**, please \\uD83D\\uDC4D **upvote** this post and watch my [Github Repository](https://github.com/cheehwatang/leetcode-java).\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n---\\n\\n**Java - 2D Matrix**\\n\\n```\\nclass Solution {\\n    \\n    public int findLength(int[] nums1, int[] nums2) {\\n        int m = nums1.length;\\n        int n = nums2.length;\\n\\n        // Check for empty nums1 or nums2. If any is 0, then there won\\'t be any repeated subarray.\\n        if (m == 0 || n == 0) {\\n            return 0;\\n        }\\n\\n        // Dynamic Programming using 2D Matrix.\\n        int[][] dp = new int[m + 1][n + 1];\\n        int max = 0;\\n\\n        // Traverse both nums2 for every numbers in nums1, to check if same number.\\n        // If same, then we increase the count of dp[i][j] by 1.\\n        // If there are already matching number previously dp[i+1][j+1], we add the count.\\n        // Then update max.\\n\\t    // Example:\\n        // nums1 = [1,2,3,4]\\n        // nums2 = [4,2,3,4]\\n        // i = 3, [[1,0,0,1,0]  (nums[i] = 4), max = 1\\n        // i = 2,  [0,0,2,0,0]  (nums[i] = 3), max = 2\\n        // i = 1,  [0,3,0,0,0]  (nums[i] = 2), max = 3\\n        // i = 0,  [0,0,0,0,0]] (nums[i] = 1), max = 3\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (nums1[i] == nums2[j]) {\\n                    dp[i][j] = dp[i+1][j+1] + 1;\\n\\t\\t\\t\\t\\tmax = Math.max(max, dp[i][j]);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n**Java - 1D Array**\\n```\\nclass Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        int m = nums1.length;\\n        int n = nums2.length;\\n\\n        // Check for empty nums1 or nums2. If any is 0, then there won\\'t be any repeated subarray.\\n        if (m == 0 || n == 0) {\\n            return 0;\\n        }\\n\\n        // Dynamic Programming using 1D Array.\\n        int[] dp = new int[n + 1];\\n        int max = 0;\\n\\n        // Traverse both nums2 for every numbers in nums1, to check if same number.\\n        // Method is similar to the 2D Matrix solution, but we only use an array to keep track of the count.\\n\\t\\t// Example:\\n        // nums1 = [1,2,3,4]\\n        // nums2 = [4,2,3,4]\\n        // i = 3, dp = [1,0,0,1,0], max = 1\\n        // i = 2, dp = [0,0,2,0,0], max = 2\\n        // i = 1, dp = [0,3,0,0,0], max = 3\\n        // i = 0, dp = [0,0,0,0,0], max = 3\\n        // Note that the count for each round only increase when there is a continuing match from previous number.\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = 0; j < n; j++) {\\n                dp[j] = nums1[i] == nums2[j] ? dp[j + 1] + 1 : 0;\\n                max = Math.max(max, dp[j]);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int findLength(int[] nums1, int[] nums2) {\\n        int m = nums1.length;\\n        int n = nums2.length;\\n\\n        // Check for empty nums1 or nums2. If any is 0, then there won\\'t be any repeated subarray.\\n        if (m == 0 || n == 0) {\\n            return 0;\\n        }\\n\\n        // Dynamic Programming using 2D Matrix.\\n        int[][] dp = new int[m + 1][n + 1];\\n        int max = 0;\\n\\n        // Traverse both nums2 for every numbers in nums1, to check if same number.\\n        // If same, then we increase the count of dp[i][j] by 1.\\n        // If there are already matching number previously dp[i+1][j+1], we add the count.\\n        // Then update max.\\n\\t    // Example:\\n        // nums1 = [1,2,3,4]\\n        // nums2 = [4,2,3,4]\\n        // i = 3, [[1,0,0,1,0]  (nums[i] = 4), max = 1\\n        // i = 2,  [0,0,2,0,0]  (nums[i] = 3), max = 2\\n        // i = 1,  [0,3,0,0,0]  (nums[i] = 2), max = 3\\n        // i = 0,  [0,0,0,0,0]] (nums[i] = 1), max = 3\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (nums1[i] == nums2[j]) {\\n                    dp[i][j] = dp[i+1][j+1] + 1;\\n\\t\\t\\t\\t\\tmax = Math.max(max, dp[i][j]);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        int m = nums1.length;\\n        int n = nums2.length;\\n\\n        // Check for empty nums1 or nums2. If any is 0, then there won\\'t be any repeated subarray.\\n        if (m == 0 || n == 0) {\\n            return 0;\\n        }\\n\\n        // Dynamic Programming using 1D Array.\\n        int[] dp = new int[n + 1];\\n        int max = 0;\\n\\n        // Traverse both nums2 for every numbers in nums1, to check if same number.\\n        // Method is similar to the 2D Matrix solution, but we only use an array to keep track of the count.\\n\\t\\t// Example:\\n        // nums1 = [1,2,3,4]\\n        // nums2 = [4,2,3,4]\\n        // i = 3, dp = [1,0,0,1,0], max = 1\\n        // i = 2, dp = [0,0,2,0,0], max = 2\\n        // i = 1, dp = [0,3,0,0,0], max = 3\\n        // i = 0, dp = [0,0,0,0,0], max = 3\\n        // Note that the count for each round only increase when there is a continuing match from previous number.\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = 0; j < n; j++) {\\n                dp[j] = nums1[i] == nums2[j] ? dp[j + 1] + 1 : 0;\\n                max = Math.max(max, dp[j]);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599911,
                "title": "c-two-pointers-o-1-space-easy-solution-maximum-length-of-repeated-subarray",
                "content": "**Approach:**\\n\\n\\nA = We will move num2 on num1 and keep count of maximum length equal values. (Largest Equal Subarray)\\nB = Then we will move num1 on num2 and keep count of maximum length equal values. \\n\\nMaximum of these two is answer. max(A,B)\\n\\n\\n**Working:**\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/d80b4343-fe3b-412c-9d7d-326085cd2e84_1663652480.215856.png)\\n\\nMax Equal Length on Iteration 1 = 1\\nMax Equal Length on Iteration 2 = 0\\nMax Equal Length on Iteration 3 = 3\\nMax Equal Length on Iteration 4 = 0\\nMax Equal Length on Iteration 5 = 0\\n\\nA = Longest Max = 3\\n\\n<br>\\n\\n\\n\\nDo this same for num1 on num2.\\n\\n![image](https://assets.leetcode.com/users/images/778baa3e-dbf8-4581-8b98-cb35f03b03f3_1663652802.250731.png)\\n\\n\\nMax Equal Length on Iteration 1 = 1\\nMax Equal Length on Iteration 2 = 0\\nMax Equal Length on Iteration 3 = 1\\nMax Equal Length on Iteration 4 = 0\\nMax Equal Length on Iteration 5 = 0\\n\\nB = Longest Max = 1\\n\\n\\n<br>\\n\\n**Answer** -> OverAll Max = Max(A,B) = 3 \\n\\n<br>\\nCount the maximum length equal (subarray) while iterating.\\n\\n<br>\\n<br>\\n\\n**Caution:** Keep pointers within the bounds of num1 and num2 while iterating.\\n\\n<br>\\n<br>\\n\\n**Time Complexity** - O(N * M)\\n**Space Complexity** - O(1)\\n\\n\\n<br>\\n<br>\\n\\n\\n\\n**C++ Code**:\\n<br>\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        \\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n\\n        //moving num2 on num1\\n        \\n        int ptr2 = 0;\\n        \\n        int cnt = 0;\\n        \\n        int largest  = INT_MIN;\\n        \\n        for(int i=0;i<n1;i++)\\n        {\\n            cnt = 0;\\n            for(int j=i,ptr2=0;j<n1 && ptr2<n2;j++,ptr2++)\\n            {\\n                if(nums1[j]==nums2[ptr2])\\n                {\\n                    cnt++;\\n                    \\n                }\\n                else\\n                {\\n                    cnt = 0;\\n                }\\n                largest = max(largest,cnt);\\n            }\\n        }\\n        \\n        //moving num1 on num2\\n        ptr2 = 0;\\n        cnt = 0;\\n        for(int i=0;i<n2;i++)\\n        {\\n            cnt = 0;\\n            for(int j=i,ptr2=0;j<n2 && ptr2<n1;j++,ptr2++)\\n            {\\n                if(nums2[j]==nums1[ptr2])\\n                {\\n                    cnt++;\\n                }\\n                else\\n                {\\n                    cnt = 0;\\n                }\\n                largest = max(largest,cnt);\\n            }\\n        }\\n        \\n        return largest;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        \\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n\\n        //moving num2 on num1\\n        \\n        int ptr2 = 0;\\n        \\n        int cnt = 0;\\n        \\n        int largest  = INT_MIN;\\n        \\n        for(int i=0;i<n1;i++)\\n        {\\n            cnt = 0;\\n            for(int j=i,ptr2=0;j<n1 && ptr2<n2;j++,ptr2++)\\n            {\\n                if(nums1[j]==nums2[ptr2])\\n                {\\n                    cnt++;\\n                    \\n                }\\n                else\\n                {\\n                    cnt = 0;\\n                }\\n                largest = max(largest,cnt);\\n            }\\n        }\\n        \\n        //moving num1 on num2\\n        ptr2 = 0;\\n        cnt = 0;\\n        for(int i=0;i<n2;i++)\\n        {\\n            cnt = 0;\\n            for(int j=i,ptr2=0;j<n2 && ptr2<n1;j++,ptr2++)\\n            {\\n                if(nums2[j]==nums1[ptr2])\\n                {\\n                    cnt++;\\n                }\\n                else\\n                {\\n                    cnt = 0;\\n                }\\n                largest = max(largest,cnt);\\n            }\\n        }\\n        \\n        return largest;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433635,
                "title": "c-all-4-approaches-recur-memo-dp-space-optimized",
                "content": "```\\n\\n//Recursion\\nclass Solution {\\nprivate:\\n    int lcs(vector<int>& n1, vector<int>& n2, int i, int j, int count, vector<vector<vector<int>>>&dp){\\n        if (i >= n1.size() || j >= n2.size()) return count; \\n        if(dp[i][j][count]!=-1) return dp[i][j][count];\\n        int same = count; \\n        if (n1[i] == n2[j]) { \\n            same = lcs(n1, n2, i + 1, j + 1, count + 1, dp); \\n        }\\n        int diff1 = lcs(n1, n2, i, j + 1, 0, dp);\\n        int diff2 =  lcs(n1, n2, i + 1, j, 0, dp);\\n        return dp[i][j][count] = max(same, max(diff1, diff2));\\n    } \\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(m+1, vector<int>(min(n,m),-1)));\\n        return lcs(nums1, nums2, 0, 0, 0, dp);\\n    }\\n};\\n// Memoization\\nclass Solution {\\nprivate:\\n    int lcs(vector<int>& n1, vector<int>& n2, int i, int j, int &ans, vector<vector<int>>&dp){\\n        if (i >= n1.size() || j >= n2.size()) return 0; \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int cur = 0;\\n        if (n1[i] == n2[j]){\\n            cur = lcs(n1, n2, i + 1, j + 1, ans, dp)+1; \\n        }\\n        lcs(n1, n2, i, j + 1, ans, dp);\\n        lcs(n1, n2, i + 1, j, ans, dp);\\n        ans = max(ans, cur);\\n        return dp[i][j] = cur;\\n    } \\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        int ans = 0;\\n        lcs(nums1, nums2, 0, 0, ans, dp);\\n        return ans;\\n    }\\n};\\n\\n// Dynamic Programming\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        int dp[n+1][m+1];\\n        for(int i = 0 ; i <= n ; i++) dp[i][0] = 0;\\n        for(int j = 0 ; j <= m ; j++) dp[0][j] = 0;\\n        int ans = 0;\\n        for(int i = 1 ; i <= n ; i++){\\n            for(int j = 1 ; j <= m ; j++){\\n                if(nums1[i-1]==nums2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+1;\\n                else\\n                    dp[i][j] = 0;\\n                ans = max(ans, dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n// Space Optimized \\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        vector<int>prev(n+1,0);\\n        int ans = 0;\\n        for(int i = 1 ; i <= n ; i++){\\n            vector<int>cur(n+1,0);\\n            for(int j = 1 ; j <= m ; j++){\\n                if(nums1[i-1]==nums2[j-1])\\n                   cur[j] = prev[j-1]+1;\\n                else\\n                    cur[j] = 0;\\n                ans = max(ans, cur[j]);\\n            }\\n            prev = cur;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n\\n//Recursion\\nclass Solution {\\nprivate:\\n    int lcs(vector<int>& n1, vector<int>& n2, int i, int j, int count, vector<vector<vector<int>>>&dp){\\n        if (i >= n1.size() || j >= n2.size()) return count; \\n        if(dp[i][j][count]!=-1) return dp[i][j][count];\\n        int same = count; \\n        if (n1[i] == n2[j]) { \\n            same = lcs(n1, n2, i + 1, j + 1, count + 1, dp); \\n        }\\n        int diff1 = lcs(n1, n2, i, j + 1, 0, dp);\\n        int diff2 =  lcs(n1, n2, i + 1, j, 0, dp);\\n        return dp[i][j][count] = max(same, max(diff1, diff2));\\n    } \\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(m+1, vector<int>(min(n,m),-1)));\\n        return lcs(nums1, nums2, 0, 0, 0, dp);\\n    }\\n};\\n// Memoization\\nclass Solution {\\nprivate:\\n    int lcs(vector<int>& n1, vector<int>& n2, int i, int j, int &ans, vector<vector<int>>&dp){\\n        if (i >= n1.size() || j >= n2.size()) return 0; \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int cur = 0;\\n        if (n1[i] == n2[j]){\\n            cur = lcs(n1, n2, i + 1, j + 1, ans, dp)+1; \\n        }\\n        lcs(n1, n2, i, j + 1, ans, dp);\\n        lcs(n1, n2, i + 1, j, ans, dp);\\n        ans = max(ans, cur);\\n        return dp[i][j] = cur;\\n    } \\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        int ans = 0;\\n        lcs(nums1, nums2, 0, 0, ans, dp);\\n        return ans;\\n    }\\n};\\n\\n// Dynamic Programming\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        int dp[n+1][m+1];\\n        for(int i = 0 ; i <= n ; i++) dp[i][0] = 0;\\n        for(int j = 0 ; j <= m ; j++) dp[0][j] = 0;\\n        int ans = 0;\\n        for(int i = 1 ; i <= n ; i++){\\n            for(int j = 1 ; j <= m ; j++){\\n                if(nums1[i-1]==nums2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+1;\\n                else\\n                    dp[i][j] = 0;\\n                ans = max(ans, dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n// Space Optimized \\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        vector<int>prev(n+1,0);\\n        int ans = 0;\\n        for(int i = 1 ; i <= n ; i++){\\n            vector<int>cur(n+1,0);\\n            for(int j = 1 ; j <= m ; j++){\\n                if(nums1[i-1]==nums2[j-1])\\n                   cur[j] = prev[j-1]+1;\\n                else\\n                    cur[j] = 0;\\n                ans = max(ans, cur[j]);\\n            }\\n            prev = cur;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169215,
                "title": "1-recursive-memo-2-bottom-up-c",
                "content": "More interview Qns : https://github.com/MAZHARMIK/Interview_DS_Algo\\nJuly Challenge Full Solution till now : https://github.com/MAZHARMIK/Leetcode-July-Challenge-2021/blob/main/README.md\\n```\\nclass Solution {\\npublic:\\n    int t[1005][1005];\\n    int maxC = 0;\\n   int recur_memo(vector<int>& nums1, vector<int>& nums2, int m, int n) {\\n        if(t[m][n] != -1)\\n            return t[m][n];\\n        \\n        if(m == 0 || n == 0)\\n            return 0;\\n        \\n        int max_substring_ending_here = 0;\\n\\t\\t//Example : \"abcdezf\"   \"abcdelf\"\\n\\t\\t//You see that wowww, string1[m-1] = string2[n-1] = \\'f\\' and you happily go for (m-1, n-1)\\n\\t\\t//But you see, in future after a gap of \\'l\\' and \\'z\\', you will find \"abcde\" and \"abcde\"\\n\\t\\tif(nums1[m-1] == nums2[n-1]) {\\n            max_substring_ending_here = 1 + recur_memo(nums1, nums2, m-1, n-1);\\n        }\\n        \\n\\t\\t//May be you find better results if you do (m-1, n) and you end up updating maxC with some LAAARGEST COMMON SUBSTRING LENGTH\\n        int decrease_m = recur_memo(nums1, nums2, m-1, n); //stage (m-1, n)\\n\\t\\t\\n\\t\\t//OR,\\n\\t\\t//May be you find better results if you do (m, n-1) and you end up updating maxC with some LAAARGEST COMMON SUBSTRING LENGTH\\n        int decrease_n  = recur_memo(nums1, nums2, m, n-1); //stage (m, n-1)\\n        \\n\\t\\t//Like I said, you need to keep on finding the maxC in every call you make throughout your journey.\\n        maxC = max({maxC, max_substring_ending_here, decrease_m, decrease_n});\\n        \\n\\t\\t\\n\\t\\t//BUT BUT BUT, you need to return the best you found at this stage (m, n)\\n        return t[m][n] = max_substring_ending_here;\\n    }\\n\\t   \\n\\tint dp(vector<int>& nums1, vector<int>& nums2, int m, int n) {\\n        vector<vector<int>> t(m+1, vector<int>(n+1));\\n        \\n        int result = 0;\\n        for(int i = 0; i<m+1; i++) {\\n            for(int j = 0; j<n+1; j++) {\\n                if(i == 0 || j == 0)\\n                    t[i][j] = 0;\\n                else if(nums1[i-1] == nums2[j-1]) {\\n                    t[i][j] = 1 + t[i-1][j-1];\\n                    result = max(result, t[i][j]);\\n                } else\\n                    t[i][j] = 0;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n\\t\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        memset(t, -1, sizeof(t));\\n        recur_memo(nums1, nums2, m, n); //resurive+memoization\\n        return maxC;\\n        //return dp(nums1, nums2, m, n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int t[1005][1005];\\n    int maxC = 0;\\n   int recur_memo(vector<int>& nums1, vector<int>& nums2, int m, int n) {\\n        if(t[m][n] != -1)\\n            return t[m][n];\\n        \\n        if(m == 0 || n == 0)\\n            return 0;\\n        \\n        int max_substring_ending_here = 0;\\n\\t\\t//Example : \"abcdezf\"   \"abcdelf\"\\n\\t\\t//You see that wowww, string1[m-1] = string2[n-1] = \\'f\\' and you happily go for (m-1, n-1)\\n\\t\\t//But you see, in future after a gap of \\'l\\' and \\'z\\', you will find \"abcde\" and \"abcde\"\\n\\t\\tif(nums1[m-1] == nums2[n-1]) {\\n            max_substring_ending_here = 1 + recur_memo(nums1, nums2, m-1, n-1);\\n        }\\n        \\n\\t\\t//May be you find better results if you do (m-1, n) and you end up updating maxC with some LAAARGEST COMMON SUBSTRING LENGTH\\n        int decrease_m = recur_memo(nums1, nums2, m-1, n); //stage (m-1, n)\\n\\t\\t\\n\\t\\t//OR,\\n\\t\\t//May be you find better results if you do (m, n-1) and you end up updating maxC with some LAAARGEST COMMON SUBSTRING LENGTH\\n        int decrease_n  = recur_memo(nums1, nums2, m, n-1); //stage (m, n-1)\\n        \\n\\t\\t//Like I said, you need to keep on finding the maxC in every call you make throughout your journey.\\n        maxC = max({maxC, max_substring_ending_here, decrease_m, decrease_n});\\n        \\n\\t\\t\\n\\t\\t//BUT BUT BUT, you need to return the best you found at this stage (m, n)\\n        return t[m][n] = max_substring_ending_here;\\n    }\\n\\t   \\n\\tint dp(vector<int>& nums1, vector<int>& nums2, int m, int n) {\\n        vector<vector<int>> t(m+1, vector<int>(n+1));\\n        \\n        int result = 0;\\n        for(int i = 0; i<m+1; i++) {\\n            for(int j = 0; j<n+1; j++) {\\n                if(i == 0 || j == 0)\\n                    t[i][j] = 0;\\n                else if(nums1[i-1] == nums2[j-1]) {\\n                    t[i][j] = 1 + t[i-1][j-1];\\n                    result = max(result, t[i][j]);\\n                } else\\n                    t[i][j] = 0;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n\\t\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        memset(t, -1, sizeof(t));\\n        recur_memo(nums1, nums2, m, n); //resurive+memoization\\n        return maxC;\\n        //return dp(nums1, nums2, m, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599361,
                "title": "c-dp-tabulation-space-optimization",
                "content": "**If you like it, please give a star, to my [Github](https://github.com/champmaniac/LeetCode) Repository and upvote this post.**\\n\\n**Solution: 1 (DP Tabulation)**:\\n\\n**Intuition:**\\nWe can use a 2D DP array to store the length of the longest common subarray ending at nums1[i] and nums2[j].\\nThe recurrence relation is **dp[i][j] = dp[i-1][j-1] + 1** if **nums1[i] == nums2[j],** otherwise **dp[i][j] = 0.**\\n\\n**Approach:**\\n* Create a **2D DP** array of size **(nums1.size() + 1) * (nums2.size() + 1)** and initialize it with 0.\\n* Iterate over the **DP** array and update the values using the **recurrence** relation.\\n* Return the **maximum** value in the DP array.\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        vector<vector<int>> dp(n, vector<int>(m, 0));\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (nums1[i] == nums2[j]) {\\n                    if (i == 0 || j == 0) dp[i][j] = 1;\\n                    else dp[i][j] = dp[i-1][j-1] + 1;\\n                    ans = max(ans, dp[i][j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n****\\n**Time Complexity:** **O(n*m)**, where n is the size of nums1 and m is the size of nums2.\\n**Space Complexity:** **O(n*m)**\\n****\\n**Solution: 2 (DP Space Optimization)**:\\n\\n**Intuition:**\\nWe can use a 1D DP array to store the length of the longest common subarray ending at nums1[i] and nums2[j].\\nThe recurrence relation is **dp[j] = dp[j-1] + 1** if **nums1[i] == nums2[j]**, otherwise **dp[j] = 0.**\\n\\n**Approach:**\\n* Create a **1D DP** array of size **(nums2.size() + 1)** and initialize it with **0**.\\n* Iterate over the **DP** array and update the values using the **recurrence** relation.\\n* Return the **maximum** value in the DP array.\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        vector<int> dp(m, 0);\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = m-1; j >= 0; j--) {\\n                if (nums1[i] == nums2[j]) {\\n                    if (i == 0 || j == 0) dp[j] = 1;\\n                    else dp[j] = dp[j-1] + 1;\\n                    ans = max(ans, dp[j]);\\n                }\\n                else dp[j] = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n****\\n**Time Complexity:** **O(n*m)**, where n is the size of nums1 and m is the size of nums2.\\n**Space Complexity:** **O(m)**\\n****\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        vector<vector<int>> dp(n, vector<int>(m, 0));\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (nums1[i] == nums2[j]) {\\n                    if (i == 0 || j == 0) dp[i][j] = 1;\\n                    else dp[i][j] = dp[i-1][j-1] + 1;\\n                    ans = max(ans, dp[i][j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        vector<int> dp(m, 0);\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = m-1; j >= 0; j--) {\\n                if (nums1[i] == nums2[j]) {\\n                    if (i == 0 || j == 0) dp[j] = 1;\\n                    else dp[j] = dp[j-1] + 1;\\n                    ans = max(ans, dp[j]);\\n                }\\n                else dp[j] = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324567,
                "title": "well-explained-with-and-without-dp-99-66-faster-easily-understandable",
                "content": "## IDEA :\\n\\uD83D\\uDC49 **searching in string is very fast in built in python function.**\\n\\uD83D\\uDC49 convert \"nums2\" into a string.\\n\\uD83D\\uDC49 now maitain a string \"max_str\" to contain longest substring of both array.\\n\\uD83D\\uDC49 if character of both array matches then add the new character into max_str otherwise remove one character from the begining.\\n\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        nums2_str = \\'\\'.join([chr(x) for x in nums2])\\n        max_str = \\'\\'\\n        res = 0\\n        for num in nums1:\\n            max_str+=chr(num)\\n            if max_str in nums2_str:\\n                res = max(res,len(max_str))\\n            else:\\n                max_str = max_str[1:]\\n        \\n        return res\\n\\n**Using  DP :**\\n\\uD83D\\uDC49 Here dp is used to maintain the length of longest substring till that character.\\n\\uD83D\\uDC49 IF characters in both array doesnt match then gives 0, otherwise add 1 from the previous diagonal value.\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        m=len(nums1)\\n        n=len(nums2)\\n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\\n        res=0\\n        for i in range(m):\\n            for j in range(n):\\n                if nums1[i]==nums2[j]:\\n                    dp[i+1][j+1]=dp[i][j]+1\\n                else:\\n                    dp[i+1][j+1]=0\\n                res=max(res,dp[i+1][j+1])\\n        \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "## IDEA :\\n\\uD83D\\uDC49 **searching in string is very fast in built in python function.**\\n\\uD83D\\uDC49 convert \"nums2\" into a string.\\n\\uD83D\\uDC49 now maitain a string \"max_str\" to contain longest substring of both array.\\n\\uD83D\\uDC49 if character of both array matches then add the new character into max_str otherwise remove one character from the begining.\\n\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        nums2_str = \\'\\'.join([chr(x) for x in nums2])\\n        max_str = \\'\\'\\n        res = 0\\n        for num in nums1:\\n            max_str+=chr(num)\\n            if max_str in nums2_str:\\n                res = max(res,len(max_str))\\n            else:\\n                max_str = max_str[1:]\\n        \\n        return res\\n\\n**Using  DP :**\\n\\uD83D\\uDC49 Here dp is used to maintain the length of longest substring till that character.\\n\\uD83D\\uDC49 IF characters in both array doesnt match then gives 0, otherwise add 1 from the previous diagonal value.\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        m=len(nums1)\\n        n=len(nums2)\\n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\\n        res=0\\n        for i in range(m):\\n            for j in range(n):\\n                if nums1[i]==nums2[j]:\\n                    dp[i+1][j+1]=dp[i][j]+1\\n                else:\\n                    dp[i+1][j+1]=0\\n                res=max(res,dp[i+1][j+1])\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1324210,
                "title": "maximum-length-of-repeated-subarray-dp-java",
                "content": "Same as longest common substring\\n```\\nclass Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        int n1=nums1.length,n2=nums2.length;\\n        int dp[][]=new int[n1+1][n2+1];\\n        int max=0;\\n        for(int i=0;i<n1+1;i++)\\n        {\\n            for(int j=0;j<n2+1;j++)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j]=0;\\n                else if(nums1[i-1]==nums2[j-1])\\n                {\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                    max=Math.max(dp[i][j],max);\\n                }\\n                else\\n                    dp[i][j]=0;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\nDo upvote if u find it useful\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        int n1=nums1.length,n2=nums2.length;\\n        int dp[][]=new int[n1+1][n2+1];\\n        int max=0;\\n        for(int i=0;i<n1+1;i++)\\n        {\\n            for(int j=0;j<n2+1;j++)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j]=0;\\n                else if(nums1[i-1]==nums2[j-1])\\n                {\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                    max=Math.max(dp[i][j],max);\\n                }\\n                else\\n                    dp[i][j]=0;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 306354,
                "title": "python-dp-solution-longest-common-substring",
                "content": "This question is basically minimum window substring of 2 strings, except they are numbers in this question. Solution: create a dp table with 1+len(string) for row and col. Your 0th row/col are initialized with 0. dp[i][j] tells you the length of your substring that is in common with both strings at A[i-1] and B[j-1]. We do -1 because our 0th row is an initialization row so we don\\'t go out of bounds. If A[i - 1] == B[j - 1], we look at the diagnal value and add 1. If it\\'s not the same value, the longest substring ENDING at A[i - 1] and B[j - 1] is 0 because they are different letters so no substrings in common can end there. \\n\\nWe keep a res variable so we can know the longest substring at the end. Most other DP solutions look at a specific index (dp[-1][-1] or dp[0][len(str)]) but in this one our answer can be anywhere in the dp. \\n\\nRuntime: O(M*N)\\nSpace: O(M*N)\\n\\n```\\n        res = 0 \\n        R, C = len(A), len(B)\\n        dp = [[0]*(C + 1) for i in range(R + 1)]\\n        for i in range(1, R + 1):\\n            for j in range(1, C + 1):\\n                if A[i - 1] == B[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1] + 1\\n                else: \\n                    dp[i][j] = 0\\n                res = max(res, dp[i][j])\\n        return res \\n```\\n\\nWe can improve the memory here to O(min(M, N)) by switching the words if len(B) > len(A) and we can make our dp array 1D by just reusing the space each time we move to another row (versus in our orig 2D array). Note that we need to traverse each row backwards so that we do not erase the data from our previous row. If you don\\'t traverse backwards, maybe you can keep a temp variable for the diagnal (the only one you would care about). \\n\\n```\\n        res = 0 \\n        R, C = len(A), len(B)\\n        dp = [0]*(C + 1)\\n        for i in range(1, R + 1):\\n            for j in range(C, 0, -1):\\n                if A[i - 1] == B[j - 1]:\\n                    dp[j] = dp[j - 1] + 1\\n                else: \\n                    dp[j] = 0\\n                res = max(res, dp[j])\\n            #print dp\\n        return res \\n```\\n\\nIf you need to find the word, remember the i and j index of your max substring length. Keep going diagnally (ie i -= 1, j -= 1) until the value is = 0 in the next ith and jth iteration.",
                "solutionTags": [],
                "code": "```\\n        res = 0 \\n        R, C = len(A), len(B)\\n        dp = [[0]*(C + 1) for i in range(R + 1)]\\n        for i in range(1, R + 1):\\n            for j in range(1, C + 1):\\n                if A[i - 1] == B[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1] + 1\\n                else: \\n                    dp[i][j] = 0\\n                res = max(res, dp[i][j])\\n        return res \\n```\n```\\n        res = 0 \\n        R, C = len(A), len(B)\\n        dp = [0]*(C + 1)\\n        for i in range(1, R + 1):\\n            for j in range(C, 0, -1):\\n                if A[i - 1] == B[j - 1]:\\n                    dp[j] = dp[j - 1] + 1\\n                else: \\n                    dp[j] = 0\\n                res = max(res, dp[j])\\n            #print dp\\n        return res \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 109033,
                "title": "solution-1-dp-o-n-2-with-o-n-space-solution-2-stringify",
                "content": "Solution 1: DP (~40ms)\\n\\n    public int findLength(int[] A, int[] B) {\\n        int n = A.length, m = B.length, max = 0;\\n        int[] dp = new int[m+1];\\n        for(int i = 1; i <= n; i++)\\n            for(int j = m; j > 0; j--)\\n                max = Math.max(max, dp[j] = A[i-1] == B[j-1] ? dp[j-1] + 1 : 0);\\n        return max;\\n    }\\n\\nSolution 2 (~75ms): binary search + stringify A and B, then use HashSet to check if there are duplicated substrings:\\n```\\n    String Sa = null, Sb = null;\\n    public int findLength(int[] A, int[] B) {\\n        Sa = stringify(A);\\n        Sb = stringify(B);\\n        int l = 0, r = Math.min(A.length, B.length);\\n        while(l < r) {\\n            int mid = (l + r + 1) / 2;\\n            if (check(mid))\\n                l = mid;\\n            else\\n                r = mid - 1;\\n        }\\n        return l;\\n    }\\n    \\n    private String stringify(int[] a) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int x : a)\\n            sb.append((char)x);\\n        return sb.toString();\\n    }\\n    \\n    private boolean check(int len) {\\n        Set<String> set = new HashSet<>();\\n        for(int l = 0, r = len; r <= Sa.length(); l++, r++)\\n            set.add(Sa.substring(l, r));\\n        for(int l = 0, r = len; r <= Sb.length(); l++, r++)\\n            if (set.contains(Sb.substring(l,r))) return true;\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    String Sa = null, Sb = null;\\n    public int findLength(int[] A, int[] B) {\\n        Sa = stringify(A);\\n        Sb = stringify(B);\\n        int l = 0, r = Math.min(A.length, B.length);\\n        while(l < r) {\\n            int mid = (l + r + 1) / 2;\\n            if (check(mid))\\n                l = mid;\\n            else\\n                r = mid - 1;\\n        }\\n        return l;\\n    }\\n    \\n    private String stringify(int[] a) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int x : a)\\n            sb.append((char)x);\\n        return sb.toString();\\n    }\\n    \\n    private boolean check(int len) {\\n        Set<String> set = new HashSet<>();\\n        for(int l = 0, r = len; r <= Sa.length(); l++, r++)\\n            set.add(Sa.substring(l, r));\\n        for(int l = 0, r = len; r <= Sb.length(); l++, r++)\\n            if (set.contains(Sb.substring(l,r))) return true;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2599823,
                "title": "java-recursion-tabulation-space-optimization",
                "content": "```\\n// Recursive : TLE\\n// TC - exponential\\nclass Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        \\n        return helper(nums1, nums2, nums1.length-1, nums2.length-1, 0);\\n    }\\n    \\n    private int helper(int[] nums1, int[] nums2, int i, int j, int cnt){\\n        \\n        if(i < 0 || j < 0){\\n            return cnt;\\n        }\\n        \\n        if(nums1[i] == nums2[j]){\\n            cnt = helper(nums1, nums2, i-1, j-1, cnt+1);\\n        }\\n        return Math.max(cnt, Math.max(helper(nums1, nums2, i-1, j, 0), helper(nums1, nums2, i, j-1, 0)));\\n    }\\n}\\n\\n\\n// Tabulation\\n// TC - O(m*n), SC - O(m*n)\\nclass Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        \\n        int m = nums1.length, n = nums2.length, ans = 0;\\n        int[][] dp = new int[m+1][n+1];\\n\\n        for(int i = 1; i <= m; i++){\\n            for(int j = 1; j <= n; j++){\\n                if(nums1[i-1] == nums2[j-1]){\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                    ans = Math.max(ans, dp[i][j]);\\n                }else{\\n                    dp[i][j] = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n// Space Optimization\\n// TC - O(m*n), SC - O(2*n)\\nclass Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        \\n        int m = nums1.length, n = nums2.length, ans = 0;\\n        int[][] dp = new int[2][n+1];\\n\\n        for(int i = 1; i <= m; i++){\\n            for(int j = 1; j <= n; j++){\\n                if(nums1[i-1] == nums2[j-1]){\\n                    dp[i%2][j] = 1 + dp[(i-1)%2][j-1];\\n                    ans = Math.max(ans, dp[i%2][j]);\\n                }else{\\n                    dp[i%2][j] = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n// Recursive : TLE\\n// TC - exponential\\nclass Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        \\n        return helper(nums1, nums2, nums1.length-1, nums2.length-1, 0);\\n    }\\n    \\n    private int helper(int[] nums1, int[] nums2, int i, int j, int cnt){\\n        \\n        if(i < 0 || j < 0){\\n            return cnt;\\n        }\\n        \\n        if(nums1[i] == nums2[j]){\\n            cnt = helper(nums1, nums2, i-1, j-1, cnt+1);\\n        }\\n        return Math.max(cnt, Math.max(helper(nums1, nums2, i-1, j, 0), helper(nums1, nums2, i, j-1, 0)));\\n    }\\n}\\n\\n\\n// Tabulation\\n// TC - O(m*n), SC - O(m*n)\\nclass Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        \\n        int m = nums1.length, n = nums2.length, ans = 0;\\n        int[][] dp = new int[m+1][n+1];\\n\\n        for(int i = 1; i <= m; i++){\\n            for(int j = 1; j <= n; j++){\\n                if(nums1[i-1] == nums2[j-1]){\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                    ans = Math.max(ans, dp[i][j]);\\n                }else{\\n                    dp[i][j] = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n// Space Optimization\\n// TC - O(m*n), SC - O(2*n)\\nclass Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        \\n        int m = nums1.length, n = nums2.length, ans = 0;\\n        int[][] dp = new int[2][n+1];\\n\\n        for(int i = 1; i <= m; i++){\\n            for(int j = 1; j <= n; j++){\\n                if(nums1[i-1] == nums2[j-1]){\\n                    dp[i%2][j] = 1 + dp[(i-1)%2][j-1];\\n                    ans = Math.max(ans, dp[i%2][j]);\\n                }else{\\n                    dp[i%2][j] = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325472,
                "title": "c-lcp-array-same-as-longest-common-substring",
                "content": "**\\u2713 Solution: LCP Array**\\n* Concatenate Two Vector.\\n* Bulid Suffix Array for it.\\n* Build LCP Array from that suffix Array.\\n* Now, notice that LCP value of two consecutive Suffixes in LCP Array, those came from different vector, will contribute to the answer.\\n* Find the maximum of those values. That will be the answer.\\n\\nCode in C++\\n```\\nclass Solution {\\n    pair<int, int> initial_label[2000+3];\\n    int final_label[2000+3];\\n    int SA[2000+3];\\n    int LCP[2000+3];\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2)\\n    {\\n        ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\n        vector<int> nums = nums1;\\n        nums.push_back(-2);\\n        nums.insert(nums.end(), nums2.begin(), nums2.end());\\n        nums.push_back(-3);\\n\\n        int i, j, k, m, n = nums.size();\\n        int a, b;\\n        for (i = 0; i < n; i++) final_label[i] = nums[i];\\n\\n        //for(j = 0; j < n; j++) cout << final_label[j] << \" \\\\n\"[j == n-1];\\n        for (i = 1; i < n; i *= 2)\\n        {\\n            for(j = 0; j < n; j++)\\n            {\\n                a = final_label[j]; b = (i+j < n ? final_label[i+j] : 0);\\n                initial_label[j] = make_pair(a, b);\\n            }\\n            //for(j = 0; j < n; j++) cout << initial_label[j].first << \",\" << initial_label[j].second << \" \";\\n            //cout << \"  \";\\n            sort(initial_label, initial_label+n);\\n            m = unique(initial_label, initial_label+n)-initial_label;\\n            for(j = 0; j < n; j++)\\n            {\\n                a = final_label[j]; b = (i+j < n ? final_label[i+j] : 0);\\n                final_label[j] = lower_bound(initial_label, initial_label+m, make_pair(a, b))-initial_label+1;\\n            }\\n\\n            //for (j = 0; j < n; j++) cout << final_label[j] << \" \\\\n\"[j == n-1];\\n        }\\n        for(j = 0; j < n; j++) SA[final_label[j]-1] = j;\\n\\n        for (i = 0, j = SA[final_label[0]-1-1]; j < n and nums[i] == nums[j]; i++, j++); LCP[final_label[0]-1] = i;\\n\\n        for (k = 1; k < n-1; k++)\\n        {\\n            LCP[final_label[k]-1] = max(0, LCP[final_label[k-1]-1]-1);\\n            //cout << \"LCP \" << k << \": \" << LCP[final_label[k]-1] << endl;\\n            for (i = k+LCP[final_label[k]-1], j = SA[final_label[k]-1-1]+LCP[final_label[k]-1];\\n                 j < n and nums[i] == nums[j]; i++, j++)\\n            {\\n                LCP[final_label[k]-1]++;\\n            }\\n            //cout << \"LCP>\" << k << \": \" << LCP[final_label[k]-1] << endl;\\n        }\\n\\n        /*for(j = 0; j < n; j++)\\n        {\\n            cout << j << \"  \" << SA[j] << \"  \" << LCP[j] << \"\\\\t\\\\t\";\\n            for (i = SA[j]; i < n; i++) cout << setw(2) << nums[i] << \" \\\\n\"[i == n-1];\\n        }*/\\n\\n        int ans = 0;\\n        for (i = 0; i < n-1; i++)\\n        {\\n            if ((SA[i] < nums1.size())+(SA[i+1] < nums1.size()) == 1)\\n            {\\n                ans = max(ans, LCP[i+1]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n<ul> \\n<li>Complexity:</li>\\n\\t<ul> \\n\\t\\t<li> Time : O( (m+n)*log(m+n)*log(m+n) ) </li>\\n\\t\\t<li> Space : O(m+n) </li>\\n\\t</ul>\\n</ul>\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    pair<int, int> initial_label[2000+3];\\n    int final_label[2000+3];\\n    int SA[2000+3];\\n    int LCP[2000+3];\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2)\\n    {\\n        ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\n        vector<int> nums = nums1;\\n        nums.push_back(-2);\\n        nums.insert(nums.end(), nums2.begin(), nums2.end());\\n        nums.push_back(-3);\\n\\n        int i, j, k, m, n = nums.size();\\n        int a, b;\\n        for (i = 0; i < n; i++) final_label[i] = nums[i];\\n\\n        //for(j = 0; j < n; j++) cout << final_label[j] << \" \\\\n\"[j == n-1];\\n        for (i = 1; i < n; i *= 2)\\n        {\\n            for(j = 0; j < n; j++)\\n            {\\n                a = final_label[j]; b = (i+j < n ? final_label[i+j] : 0);\\n                initial_label[j] = make_pair(a, b);\\n            }\\n            //for(j = 0; j < n; j++) cout << initial_label[j].first << \",\" << initial_label[j].second << \" \";\\n            //cout << \"  \";\\n            sort(initial_label, initial_label+n);\\n            m = unique(initial_label, initial_label+n)-initial_label;\\n            for(j = 0; j < n; j++)\\n            {\\n                a = final_label[j]; b = (i+j < n ? final_label[i+j] : 0);\\n                final_label[j] = lower_bound(initial_label, initial_label+m, make_pair(a, b))-initial_label+1;\\n            }\\n\\n            //for (j = 0; j < n; j++) cout << final_label[j] << \" \\\\n\"[j == n-1];\\n        }\\n        for(j = 0; j < n; j++) SA[final_label[j]-1] = j;\\n\\n        for (i = 0, j = SA[final_label[0]-1-1]; j < n and nums[i] == nums[j]; i++, j++); LCP[final_label[0]-1] = i;\\n\\n        for (k = 1; k < n-1; k++)\\n        {\\n            LCP[final_label[k]-1] = max(0, LCP[final_label[k-1]-1]-1);\\n            //cout << \"LCP \" << k << \": \" << LCP[final_label[k]-1] << endl;\\n            for (i = k+LCP[final_label[k]-1], j = SA[final_label[k]-1-1]+LCP[final_label[k]-1];\\n                 j < n and nums[i] == nums[j]; i++, j++)\\n            {\\n                LCP[final_label[k]-1]++;\\n            }\\n            //cout << \"LCP>\" << k << \": \" << LCP[final_label[k]-1] << endl;\\n        }\\n\\n        /*for(j = 0; j < n; j++)\\n        {\\n            cout << j << \"  \" << SA[j] << \"  \" << LCP[j] << \"\\\\t\\\\t\";\\n            for (i = SA[j]; i < n; i++) cout << setw(2) << nums[i] << \" \\\\n\"[i == n-1];\\n        }*/\\n\\n        int ans = 0;\\n        for (i = 0; i < n-1; i++)\\n        {\\n            if ((SA[i] < nums1.size())+(SA[i+1] < nums1.size()) == 1)\\n            {\\n                ans = max(ans, LCP[i+1]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1557033,
                "title": "very-simple-and-fast-python-solution",
                "content": "```\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        res = 0\\n        # left to right sliding \\n        for k in range(len(nums1)):\\n            s = 0 \\n            for (x1,x2) in zip(nums1[k:],nums2):\\n                if x1==x2:\\n                    s += 1 \\n                else:\\n                    res = max(res,s)\\n                    s = 0 \\n            res = max(res,s)\\n        # right to left sliding \\n        for k in range(len(nums2)):\\n            s = 0 \\n            for (x1,x2) in zip(nums2[k:],nums1):\\n                if x1==x2:\\n                    s += 1 \\n                else:\\n                    res = max(res,s)\\n                    s = 0 \\n            res = max(res,s)\\n        return res \\n```\\nPlease upvote if you like it",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        res = 0\\n        # left to right sliding \\n        for k in range(len(nums1)):\\n            s = 0 \\n            for (x1,x2) in zip(nums1[k:],nums2):\\n                if x1==x2:\\n                    s += 1 \\n                else:\\n                    res = max(res,s)\\n                    s = 0 \\n            res = max(res,s)\\n        # right to left sliding \\n        for k in range(len(nums2)):\\n            s = 0 \\n            for (x1,x2) in zip(nums2[k:],nums1):\\n                if x1==x2:\\n                    s += 1 \\n                else:\\n                    res = max(res,s)\\n                    s = 0 \\n            res = max(res,s)\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325302,
                "title": "c-solution-using-lcs-logic-dp",
                "content": "![image](https://assets.leetcode.com/users/images/3e076163-ab32-4bf5-81cb-b27aef5582c1_1625763536.218669.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size(), n2 = nums2.size(), ans = 0;\\n        vector<vector<int>>dp(n1+1, vector<int>(n2+1, 0));\\n  \\n        for(int i = 1; i <= n1; i++)\\n            for(int j = 1; j <= n2; j++){\\n                if(nums1[i-1] == nums2[j-1]) dp[i][j] = 1 + dp[i-1][j-1];\\n                else dp[i][j] = 0;\\n                ans = max(ans, dp[i][j]);\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size(), n2 = nums2.size(), ans = 0;\\n        vector<vector<int>>dp(n1+1, vector<int>(n2+1, 0));\\n  \\n        for(int i = 1; i <= n1; i++)\\n            for(int j = 1; j <= n2; j++){\\n                if(nums1[i-1] == nums2[j-1]) dp[i][j] = 1 + dp[i-1][j-1];\\n                else dp[i][j] = 0;\\n                ans = max(ans, dp[i][j]);\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109071,
                "title": "c-easy-solution-with-explanation",
                "content": "The idea is to shift one of the arrays left by k position (0 <= k < n), and to find the longest common sub-array in each case. The run time is O(mn).\\nFor example,\\n```\\nshift array A left by 2 positions, max length is helper(A, B, 2, 0)\\nA: 3 5 1 2 3 4 6 2\\nB:     1 2 3 4 5 4\\n```\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        int ans = 0, m = A.size(), n = B.size();\\n        for (int i = 0; i < m; i++) \\n            ans = max(ans, helper(A, B, i, 0));\\n        for (int j = 1; j < n; j++) \\n            ans = max(ans, helper(A, B, 0, j));\\n        return ans;\\n    }\\nprivate:\\n    int helper(vector<int>& A, vector<int>& B, int i, int j) {\\n        int len = 0, cnt = 0;\\n        for (;i < A.size() && j < B.size(); i++, j++) {\\n            if (A[i] == B[j]) \\n                len = max(len, ++cnt);\\n            else \\n                cnt = 0;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nshift array A left by 2 positions, max length is helper(A, B, 2, 0)\\nA: 3 5 1 2 3 4 6 2\\nB:     1 2 3 4 5 4\\n```\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        int ans = 0, m = A.size(), n = B.size();\\n        for (int i = 0; i < m; i++) \\n            ans = max(ans, helper(A, B, i, 0));\\n        for (int j = 1; j < n; j++) \\n            ans = max(ans, helper(A, B, 0, j));\\n        return ans;\\n    }\\nprivate:\\n    int helper(vector<int>& A, vector<int>& B, int i, int j) {\\n        int len = 0, cnt = 0;\\n        for (;i < A.size() && j < B.size(); i++, j++) {\\n            if (A[i] == B[j]) \\n                len = max(len, ++cnt);\\n            else \\n                cnt = 0;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324994,
                "title": "maximum-length-of-repeated-subarray-javascript-simple-solution",
                "content": "Using Dynamic Programming to Find The Maximum Length of Repeated Subarray\\n\\n<h3>Code Block</h3>\\n\\n```javascript\\nvar findLength = function (nums1, nums2) {\\n  const dp = new Array(nums1.length + 1).fill(0).map(() => new Array(nums2.length + 1).fill(0)); // 1- Initialize 2D Array\\n\\n  let maxLength = 0; // 2- Set Max Length to Zero\\n  for (let i = 1; i <= nums1.length; i++)\\n    for (let j = 1; j <= nums2.length; j++)\\n      if (nums1[i - 1] == nums2[j - 1]) { // 3- Compare if both Equals\\n        dp[i][j] = 1 + dp[i - 1][j - 1]; // 4- Added Plus Previous One\\n        maxLength = Math.max(maxLength, dp[i][j]); // 5- Find Max Between maxLength and Current Value\\n      }\\n\\n  return maxLength;\\n};\\n```\\n\\nUp Vote if you Find it Useful",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```javascript\\nvar findLength = function (nums1, nums2) {\\n  const dp = new Array(nums1.length + 1).fill(0).map(() => new Array(nums2.length + 1).fill(0)); // 1- Initialize 2D Array\\n\\n  let maxLength = 0; // 2- Set Max Length to Zero\\n  for (let i = 1; i <= nums1.length; i++)\\n    for (let j = 1; j <= nums2.length; j++)\\n      if (nums1[i - 1] == nums2[j - 1]) { // 3- Compare if both Equals\\n        dp[i][j] = 1 + dp[i - 1][j - 1]; // 4- Added Plus Previous One\\n        maxLength = Math.max(maxLength, dp[i][j]); // 5- Find Max Between maxLength and Current Value\\n      }\\n\\n  return maxLength;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1324225,
                "title": "java-short-and-simple-using-4-different-approach",
                "content": "**Please Upvote if the Solution Helps you , Happy Coding !!!**\\n**1. Brute Force (TLE)**\\n* Loop through all the elements in A and B, and check the corresponding matchness\\n* If the elements match, we check as far as we can and then get the maximum length\\n* Else we skip\\n* Time complexity O(mn^2)\\n* Space complexity O(1)\\n\\n**Solution**\\n```\\nclass Solution {\\n    public int findLength(int[] A, int[] B) {\\n        int res = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            for (int j = 0; j < B.length; j++) {\\n                if (A[i] == B[j]) {\\n                    int k = 1;\\n                    while (i + k < A.length && j + k < B.length && A[i + k] == B[j + k]) k++;\\n                    res = Math.max(res, k);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n**2. Naive Binary Search**\\n* Having length k subarray appear in both array indicates having shorter length of subarray as well\\n* Using the above fact, we can use binary search to narrow our search\\n* We create a separate function checkLength(x, A, B) to check if there is length x subarray common to both arrays\\n* If x is checked, we need to continue search the right part, so lo = mi\\n* Else hi = mi\\n* However, we need special formula to take care of infinite loop to make mi calculation right leaning\\n* Time complexity O(mnl(logl)), where m is length of A, n is length of B, l is min of m and n\\n* Space complexity O(m^2)\\n\\n**Solution**\\n```\\nclass Solution {\\n    public int findLength(int[] A, int[] B) {\\n        int lo = 0, hi = Math.min(A.length, B.length);\\n        while (lo < hi) {\\n            int mi = lo + (hi - lo + 1) / 2;\\n            if (checkLength(mi, A, B)) lo = mi;\\n            else hi = mi - 1;\\n        }\\n        return lo;\\n    }\\n\\n    private boolean checkLength(int x, int[] A, int[] B) {\\n        if (x == 0) return true;\\n        else if (x > Math.min(A.length, B.length)) return false;\\n        else {\\n            Set<String> seen = new HashSet<>();\\n            for (int i = 0; i + x <= A.length; i++) {\\n                seen.add(Arrays.toString(Arrays.copyOfRange(A, i, i + x)));\\n            }\\n            for (int i = 0; i + x <= B.length; i++) {\\n                if (seen.contains(Arrays.toString(Arrays.copyOfRange(B, i, i + x)))) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n}\\n\\n```\\n\\n**3. Dynamic Programing**\\n* Use similar idea as typical longest subsequence of string, we use dynamic programing to record the best length so far\\n* If the integers are the same for ith A and jth B element, we set dp[i][j] = dp[i - 1][j - 1] + 1\\n* Else we set dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\\n* Time complexity O(mn)\\n* Space complexity O(mn)\\n*\\n**Solution**\\n\\n```\\nclass Solution {\\n    public int findLength(int[] A, int[] B) {\\n        int m = A.length, n = B.length;\\n        int[][] dp = new int[m + 1][n + 1];\\n        int ans = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (A[i] == B[j]) {\\n                    dp[i + 1][j + 1] = dp[i][j] + 1;\\n                    ans = Math.max(ans, dp[i + 1][j + 1]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**4. Binary Search with Rolling Hash**\\n* Instead of using string to check whether the two subarrays are equal, we use hash\\n* To efficiently calculate the hash, we use rolling hash function, more specifically Rabin-Karp algorithm\\n* The formula is h(i) = Sum(a[i]p^i) mod M, where i range from 0 to L - 1, calculating the next hash is h(i+1) = [(h(i) - a[0])/p + a[i+1]p^(L - 1)] mod M\\n* Using a map to store the A\\'s hash and its indices, then we can loop through the hash from B\\n* Instead of relying in the hash, we double check whether these two subarrays match even if they have same hash\\n* Time complexity O(log(l)(m + n)), where l = min(m, n)\\n* Space complexity O(m + n)\\n*\\n**Solution**\\n\\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    private int p = 113;\\n    private int M = 1000000007;\\n    private int pInv = BigInteger.valueOf(p).modInverse(BigInteger.valueOf(M)).intValue();\\n\\n    public int findLength(int[] A, int[] B) {\\n        int lo = 0, hi = Math.min(A.length, B.length);\\n        while (lo < hi) {\\n            int mi = lo + (hi - lo + 1) / 2;\\n            if (checkLength(mi, A, B)) lo = mi;\\n            else hi = mi - 1;\\n        }\\n        return lo;\\n    }\\n\\n    private boolean checkLength(int x, int[] A, int[] B) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int k = 0;\\n        for (int h : getHashes2(A, x)) {\\n            map.computeIfAbsent(h, z -> new ArrayList<>()).add(k++);\\n        }\\n        int j = 0;\\n        for (int h : getHashes2(B, x)) {\\n            for (int i : map.getOrDefault(h, new ArrayList<>())) {\\n                if (Arrays.equals(Arrays.copyOfRange(A, i, i + x), Arrays.copyOfRange(B, j, j + x))) return true;\\n            }\\n            j++;\\n        }\\n        return false;\\n    }\\n\\n    private int[] getHashes(int[] a, int L) {\\n        int[] res = new int[a.length - L + 1];\\n        long h = 0, power = 1;\\n        for (int i = 0; i < L - 1; i++) {\\n            h = (h + a[i] * power) % M;\\n            power = (power * p) % M;\\n        }\\n        for (int i = L - 1; i < a.length; i++) {\\n            h = (h + a[i] * power) % M;\\n            res[i - L + 1] = (int) h;\\n            h = (h - a[i - L + 1]) * pInv % M;\\n        }\\n        return res;\\n    }\\n\\n    private int[] getHashes2(int[] a, int L) {\\n        int[] res = new int[a.length - L + 1];\\n        long h = 0, power = 1;\\n        for (int i = 0; i < L - 1; i++) {\\n            h = (h * p % M + a[i]) % M;\\n            power = (power * p) % M;\\n        }\\n        for (int i = L - 1; i < a.length; i++) {\\n            h = (h * p % M + a[i]) % M;\\n            res[i - L + 1] = (int) h;\\n            h = (h - a[i - L + 1] * power) % M;\\n            if (h < 0) h += M;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findLength(int[] A, int[] B) {\\n        int res = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            for (int j = 0; j < B.length; j++) {\\n                if (A[i] == B[j]) {\\n                    int k = 1;\\n                    while (i + k < A.length && j + k < B.length && A[i + k] == B[j + k]) k++;\\n                    res = Math.max(res, k);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findLength(int[] A, int[] B) {\\n        int lo = 0, hi = Math.min(A.length, B.length);\\n        while (lo < hi) {\\n            int mi = lo + (hi - lo + 1) / 2;\\n            if (checkLength(mi, A, B)) lo = mi;\\n            else hi = mi - 1;\\n        }\\n        return lo;\\n    }\\n\\n    private boolean checkLength(int x, int[] A, int[] B) {\\n        if (x == 0) return true;\\n        else if (x > Math.min(A.length, B.length)) return false;\\n        else {\\n            Set<String> seen = new HashSet<>();\\n            for (int i = 0; i + x <= A.length; i++) {\\n                seen.add(Arrays.toString(Arrays.copyOfRange(A, i, i + x)));\\n            }\\n            for (int i = 0; i + x <= B.length; i++) {\\n                if (seen.contains(Arrays.toString(Arrays.copyOfRange(B, i, i + x)))) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int findLength(int[] A, int[] B) {\\n        int m = A.length, n = B.length;\\n        int[][] dp = new int[m + 1][n + 1];\\n        int ans = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (A[i] == B[j]) {\\n                    dp[i + 1][j + 1] = dp[i][j] + 1;\\n                    ans = Math.max(ans, dp[i + 1][j + 1]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    private int p = 113;\\n    private int M = 1000000007;\\n    private int pInv = BigInteger.valueOf(p).modInverse(BigInteger.valueOf(M)).intValue();\\n\\n    public int findLength(int[] A, int[] B) {\\n        int lo = 0, hi = Math.min(A.length, B.length);\\n        while (lo < hi) {\\n            int mi = lo + (hi - lo + 1) / 2;\\n            if (checkLength(mi, A, B)) lo = mi;\\n            else hi = mi - 1;\\n        }\\n        return lo;\\n    }\\n\\n    private boolean checkLength(int x, int[] A, int[] B) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int k = 0;\\n        for (int h : getHashes2(A, x)) {\\n            map.computeIfAbsent(h, z -> new ArrayList<>()).add(k++);\\n        }\\n        int j = 0;\\n        for (int h : getHashes2(B, x)) {\\n            for (int i : map.getOrDefault(h, new ArrayList<>())) {\\n                if (Arrays.equals(Arrays.copyOfRange(A, i, i + x), Arrays.copyOfRange(B, j, j + x))) return true;\\n            }\\n            j++;\\n        }\\n        return false;\\n    }\\n\\n    private int[] getHashes(int[] a, int L) {\\n        int[] res = new int[a.length - L + 1];\\n        long h = 0, power = 1;\\n        for (int i = 0; i < L - 1; i++) {\\n            h = (h + a[i] * power) % M;\\n            power = (power * p) % M;\\n        }\\n        for (int i = L - 1; i < a.length; i++) {\\n            h = (h + a[i] * power) % M;\\n            res[i - L + 1] = (int) h;\\n            h = (h - a[i - L + 1]) * pInv % M;\\n        }\\n        return res;\\n    }\\n\\n    private int[] getHashes2(int[] a, int L) {\\n        int[] res = new int[a.length - L + 1];\\n        long h = 0, power = 1;\\n        for (int i = 0; i < L - 1; i++) {\\n            h = (h * p % M + a[i]) % M;\\n            power = (power * p) % M;\\n        }\\n        for (int i = L - 1; i < a.length; i++) {\\n            h = (h * p % M + a[i]) % M;\\n            res[i - L + 1] = (int) h;\\n            h = (h - a[i - L + 1] * power) % M;\\n            if (h < 0) h += M;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915794,
                "title": "dfs-dp-progression-with-explanation-35-25",
                "content": "In this problem, we are looking for the largest continuous overlapping subarray.  Therefore, we can brute force the solution by simply looking at all continuous subarrays between `A` and `B`, and return the largest.  We can use DFS to understand how to compare all meaningful combinations of subarrays. (Notice this DFS is not a solution, just a visual tool)\\n```\\ndef dfs(A, B)\\n\\tif A[0] == B[0]:\\n\\t\\treturn 1 + dfs(A[1:], B[1:])\\n\\telse:\\n\\t\\ta = dfs(A[1:], B)\\n\\t\\tb = dfs(A, B[1:])\\n\\t\\treturn max(a, b)\\n```\\nWe want to use this sort of scheme to solve the subproblem, but there is a major issue with it.  It will take much to long to calculate larger inputs and time out.  Let\\'s take a look at the DFS tree to see why\\n![image](https://assets.leetcode.com/users/images/fdc45cf4-34bd-49e8-94ba-43b64ee2760e_1604022567.965033.png)\\nNotice that just after 2 layers, we encounter identical problems.  However, DFS does not understand this and will do the calculation twice.  This takes exponentially longer as the input array sizes grow, causing the DFS tree to grow taller.  This is where the DP approach comes in.\\nInstead of solving this problem from the top down, let\\'s build the solution from the ground up, saving the results at each step.\\n```\\ndef dp(A, B):\\n\\tlongest = 0\\n\\tDP = [[0] * (len(B) + 1) for _ in range(len(A) + 1)]\\n\\n\\tfor i in range(1, len(A) + 1):\\n\\t\\tfor j in range(1, len(B) + 1):\\n\\t\\t\\tif A[i - 1] == B[j - 1]:\\n\\t\\t\\t\\tDP[i][j] = 1 + DP[i - 1][j - 1]\\n\\t\\t\\t\\tlongest = max(longest, DP[i][j])\\n\\treturn longest\\nreturn dp(A, B)\\n```\\nThis has the same recursive relation as DFS (we ignore `a` and `b` as it would just be adding 0).  This majorly cuts down the time on solving this problem as we are saving the solution in an array rather than recalculating it every time we see it.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\ndef dfs(A, B)\\n\\tif A[0] == B[0]:\\n\\t\\treturn 1 + dfs(A[1:], B[1:])\\n\\telse:\\n\\t\\ta = dfs(A[1:], B)\\n\\t\\tb = dfs(A, B[1:])\\n\\t\\treturn max(a, b)\\n```\n```\\ndef dp(A, B):\\n\\tlongest = 0\\n\\tDP = [[0] * (len(B) + 1) for _ in range(len(A) + 1)]\\n\\n\\tfor i in range(1, len(A) + 1):\\n\\t\\tfor j in range(1, len(B) + 1):\\n\\t\\t\\tif A[i - 1] == B[j - 1]:\\n\\t\\t\\t\\tDP[i][j] = 1 + DP[i - 1][j - 1]\\n\\t\\t\\t\\tlongest = max(longest, DP[i][j])\\n\\treturn longest\\nreturn dp(A, B)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 109063,
                "title": "simple-o-nm-dp-solution",
                "content": "dp[i][j] is the max repeated length if the subarray in a ends at index i-1 and subarray in b ends at index j-1\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& a, vector<int>& b) {\\n        int na = a.size(), nb= b.size();\\n        int dp[na+1][nb+1] = {};\\n        int mx = 0;\\n        for (int i = 1; i <= na; ++i) for (int j = 1; j <=nb; ++j) {\\n            if (a[i-1] == b[j-1]) dp[i][j] = dp[i-1][j-1] + 1;\\n            mx = max(mx,dp[i][j]);\\n        }\\n        \\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& a, vector<int>& b) {\\n        int na = a.size(), nb= b.size();\\n        int dp[na+1][nb+1] = {};\\n        int mx = 0;\\n        for (int i = 1; i <= na; ++i) for (int j = 1; j <=nb; ++j) {\\n            if (a[i-1] == b[j-1]) dp[i][j] = dp[i-1][j-1] + 1;\\n            mx = max(mx,dp[i][j]);\\n        }\\n        \\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109064,
                "title": "easy-o-n-2-time-o-1-space-solution-no-dp",
                "content": "```java\\nclass Solution {\\n    public int findLength(int[] A, int[] B) {\\n        int n1 = A.length, n2 = B.length;\\n        int res = 0;\\n        for (int offset = -n1; offset < n2; offset++) {\\n            int count = 0;\\n            for (int i = Math.max(offset, 0); i - offset < n1 && i < n2; i++) {\\n                if (A[i - offset] == B[i]) {\\n                    count++;\\n                    res = Math.max(res, count);\\n                } else {\\n                    count = 0;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int findLength(int[] A, int[] B) {\\n        int n1 = A.length, n2 = B.length;\\n        int res = 0;\\n        for (int offset = -n1; offset < n2; offset++) {\\n            int count = 0;\\n            for (int i = Math.max(offset, 0); i - offset < n1 && i < n2; i++) {\\n                if (A[i - offset] == B[i]) {\\n                    count++;\\n                    res = Math.max(res, count);\\n                } else {\\n                    count = 0;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546113,
                "title": "c-dp-memoization-recursive-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int ans=0;\\n    int solve(vector<int> &a,vector<int> &b,int i,int j)\\n    {\\n        if(i>=a.size()||j>=b.size())\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        solve(a,b,i+1,j);\\n        solve(a,b,i,j+1);\\n        dp[i][j]=a[i]==b[j]?1+solve(a,b,i+1,j+1):0;\\n        ans=max(ans,dp[i][j]);\\n        return dp[i][j];\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2)\\n    {\\n        dp.resize(nums1.size(),vector<int>(nums2.size(),-1));\\n        solve(nums1,nums2,0,0);\\n        return ans;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int ans=0;\\n    int solve(vector<int> &a,vector<int> &b,int i,int j)\\n    {\\n        if(i>=a.size()||j>=b.size())\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        solve(a,b,i+1,j);\\n        solve(a,b,i,j+1);\\n        dp[i][j]=a[i]==b[j]?1+solve(a,b,i+1,j+1):0;\\n        ans=max(ans,dp[i][j]);\\n        return dp[i][j];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2439051,
                "title": "simple-commented-java-code-memoization",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    public int findLength(int[] nums1, int[] nums2) {\\n        Integer[][] dp = new Integer[nums1.length][nums2.length];\\n        helper(nums1,nums2,0,0,dp);\\n        return ans;\\n    }\\n    public int helper(int[] nums1,int[] nums2,int i, int j, Integer[][] dp){\\n        if(i==nums1.length || j==nums2.length){\\n            return 0;\\n        }\\n        if(dp[i][j] != null){\\n            return dp[i][j];\\n        }\\n        int take = 0;\\n        //We are increasing value of take if value of both the array are equal\\n        if(nums1[i]==nums2[j]){\\n            take=1+helper(nums1,nums2,i+1,j+1,dp);\\n            //Here, We put maxiumum value of take in our ans\\n            ans = Math.max(ans,take);\\n        }\\n        //Subarray are successive, so if values are not equal then we doesn\\'t need to count that part\\n        helper(nums1,nums2,i+1,j,dp);\\n        helper(nums1,nums2,i,j+1,dp);\\n        //lastly we return the value of take \\n        return dp[i][j]=take;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public int findLength(int[] nums1, int[] nums2) {\\n        Integer[][] dp = new Integer[nums1.length][nums2.length];\\n        helper(nums1,nums2,0,0,dp);\\n        return ans;\\n    }\\n    public int helper(int[] nums1,int[] nums2,int i, int j, Integer[][] dp){\\n        if(i==nums1.length || j==nums2.length){\\n            return 0;\\n        }\\n        if(dp[i][j] != null){\\n            return dp[i][j];\\n        }\\n        int take = 0;\\n        //We are increasing value of take if value of both the array are equal\\n        if(nums1[i]==nums2[j]){\\n            take=1+helper(nums1,nums2,i+1,j+1,dp);\\n            //Here, We put maxiumum value of take in our ans\\n            ans = Math.max(ans,take);\\n        }\\n        //Subarray are successive, so if values are not equal then we doesn\\'t need to count that part\\n        helper(nums1,nums2,i+1,j,dp);\\n        helper(nums1,nums2,i,j+1,dp);\\n        //lastly we return the value of take \\n        return dp[i][j]=take;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879077,
                "title": "sliding-one-array-over-the-other",
                "content": "Sliding the 2 arrays over eachother. An analogy would be like 2 trains passing eachother going in opposite directions. (Or just one overtakes the other. It doesn\\'t matter. It is relative.) We need to make 2 passes because we need the 2 arrays fully passed eachother. The arrays would only compare half of the possibilities with only 1 pass. With just 1 pass, we can imagine the first element of the 1st array never had the chance to see the last element of the 2nd array.\\nexample:\\n```\\nTrain Station:\\n[////////Platform A////////]\\n[7]_[4]_[3]_[2]_[1]_[train>\\n<train]_[1]_[2]_[1]_[4]\\n[////////Platform B////////]\\n```\\ncode:\\n```\\nclass Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        // 2 passes because we need to have the 2 arrays fully pass eachother \\n        return Math.max(helper(nums1,nums2),helper(nums2,nums1));\\n    }\\n    \\n    private int helper(int[] arr1, int[] arr2){\\n        int max = 0;\\n        // move arr1 forward one step at a time\\n        for(int i = 1; i <= arr1.length; i++){\\n            // set the comparison starting points of both arr1 and arr2\\n            int arr1Index = arr1.length - i;\\n            int arr2Index = 0;\\n            int matched = 0;\\n            while(arr1Index < arr1.length && arr2Index < arr2.length){\\n                // increment match count each time a match is found; reset otherwise\\n                matched = arr1[arr1Index++] == arr2[arr2Index++]? matched + 1: 0;\\n                max = Math.max(max,matched);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\nThe time complexity is O(nm), where n is the length of the 1st array, and m is the length of the 2nd array. This is because we compare the arrays from the front to the end of the arrays with number of array length times. Technically, it is O(2nm) because we have 2 passes, but we can drop the constant value 2, thus O(nm).\\nThe space complexity is O(1)",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nTrain Station:\\n[////////Platform A////////]\\n[7]_[4]_[3]_[2]_[1]_[train>\\n<train]_[1]_[2]_[1]_[4]\\n[////////Platform B////////]\\n```\n```\\nclass Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        // 2 passes because we need to have the 2 arrays fully pass eachother \\n        return Math.max(helper(nums1,nums2),helper(nums2,nums1));\\n    }\\n    \\n    private int helper(int[] arr1, int[] arr2){\\n        int max = 0;\\n        // move arr1 forward one step at a time\\n        for(int i = 1; i <= arr1.length; i++){\\n            // set the comparison starting points of both arr1 and arr2\\n            int arr1Index = arr1.length - i;\\n            int arr2Index = 0;\\n            int matched = 0;\\n            while(arr1Index < arr1.length && arr2Index < arr2.length){\\n                // increment match count each time a match is found; reset otherwise\\n                matched = arr1[arr1Index++] == arr2[arr2Index++]? matched + 1: 0;\\n                max = Math.max(max,matched);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325687,
                "title": "java-sliding-window-solution-t-o-m-n-s-o-1",
                "content": "```\\nclass Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        int res = 0;\\n        for (int i = 0; i < nums1.length + nums2.length - 1; i++) {\\n\\t\\t\\t/*\\n\\t\\t\\t** The following [start1, start2] position is important. For example, if nums1.length == 5, nums2.length == 3,\\n\\t\\t\\t** this is to ensure [start1, start2] are calculated as follows: [4, 0], [3, 0], [2, 0], [1, 0], [0, 0], [0, 1], [0, 2].\\n\\t\\t\\t** Basically, this algorithm is alike a hard-to-think DP solution, but without additional space used.\\n\\t\\t\\t*/\\n            int start1 = Math.max(0, nums1.length - i - 1);\\n            int start2 = Math.max(0, i - nums1.length + 1);\\n            int count = 0;\\n            for (int j = start1, k = start2; j < nums1.length && k < nums2.length; j++, k++) {\\n                if (nums1[j] == nums2[k])\\n                    count++;\\n                else\\n                    count = 0;\\n                res = Math.max(res, count);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        int res = 0;\\n        for (int i = 0; i < nums1.length + nums2.length - 1; i++) {\\n\\t\\t\\t/*\\n\\t\\t\\t** The following [start1, start2] position is important. For example, if nums1.length == 5, nums2.length == 3,\\n\\t\\t\\t** this is to ensure [start1, start2] are calculated as follows: [4, 0], [3, 0], [2, 0], [1, 0], [0, 0], [0, 1], [0, 2].\\n\\t\\t\\t** Basically, this algorithm is alike a hard-to-think DP solution, but without additional space used.\\n\\t\\t\\t*/\\n            int start1 = Math.max(0, nums1.length - i - 1);\\n            int start2 = Math.max(0, i - nums1.length + 1);\\n            int count = 0;\\n            for (int j = start1, k = start2; j < nums1.length && k < nums2.length; j++, k++) {\\n                if (nums1[j] == nums2[k])\\n                    count++;\\n                else\\n                    count = 0;\\n                res = Math.max(res, count);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324458,
                "title": "maximum-length-of-repeated-subarray-binary-search-hashing-c-99-4-faster",
                "content": "First question . Why Binary Search ??\\nThink like this , if their exists a **subarray of length x** , then also their will be subarray of length x-1 , x-2 , . . . .  0.\\nSo now , if we know their is subarray of length x , then now we check on right hand side of x . \\n\\nNow think how you can **efficiently** check , whether the particular length subarray will be in both the arrays or not . \\nSuppose their are **two arrays** , a and b\\nHere comes the idea of hashing . We will store the the hash of every substring of length x of array a . Now we will check for every substring of length x for array b , if their exists a same hash of any substing in a , then the length of substring  x will occur in both of them . \\n\\n**Below is the code :-** \\n\\n```\\n#define ll long long\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    vector<int>a , b;\\n    int n,m;\\n    int base = 109;\\n\\n    bool check(int mid){\\n        \\n        \\n        map<ll,ll>mp;\\n        ll d = 1;\\n        ll hash_value = 0;\\n        for(int i=0;i<n;i++){\\n            hash_value = (hash_value*base + a[i])%mod;\\n            if(i>=mid){\\n                hash_value = (hash_value + mod -  (d*a[i-mid])%mod)%mod;\\n            }else{\\n                d = (d%mod *base%mod)%mod;\\n            }\\n            if(i>=(mid-1)){\\n               mp[hash_value]++;\\n            }\\n        }\\n        \\n        d = 1;hash_value = 0;\\n        for(int i=0;i<m;i++){\\n            hash_value = (hash_value*base + b[i])%mod;\\n            if(i>=mid){\\n                 hash_value = (hash_value + mod - (d*b[i-mid])%mod)%mod;\\n            }else{\\n                d = (d%mod *base%mod)%mod;\\n            }\\n            if(i>=mid-1){\\n                if(mp.count(hash_value)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int findLength(vector<int>& aa, vector<int>& bb) {\\n        a = aa;\\n        b = bb;\\n        n = a.size();\\n        m = b.size();\\n        \\n        int low  = 0 ,high = min(n,m);\\n        int ans= 0;\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            bool x = check(mid);\\n            if(x){\\n                ans = mid;\\n                low = mid + 1;\\n            }else{\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n**PS:**  Go through this article once , you will know more about hashing . **[Hashing - CP algorithms](https://cp-algorithms.com/string/string-hashing.html)** . This is very **useful technique** in these type of questions . \\n\\n**Comment below** , if you have any doubt and **upvote the post** if you learnt something new \\u270C .\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Rolling Hash",
                    "Binary Tree"
                ],
                "code": "```\\n#define ll long long\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    vector<int>a , b;\\n    int n,m;\\n    int base = 109;\\n\\n    bool check(int mid){\\n        \\n        \\n        map<ll,ll>mp;\\n        ll d = 1;\\n        ll hash_value = 0;\\n        for(int i=0;i<n;i++){\\n            hash_value = (hash_value*base + a[i])%mod;\\n            if(i>=mid){\\n                hash_value = (hash_value + mod -  (d*a[i-mid])%mod)%mod;\\n            }else{\\n                d = (d%mod *base%mod)%mod;\\n            }\\n            if(i>=(mid-1)){\\n               mp[hash_value]++;\\n            }\\n        }\\n        \\n        d = 1;hash_value = 0;\\n        for(int i=0;i<m;i++){\\n            hash_value = (hash_value*base + b[i])%mod;\\n            if(i>=mid){\\n                 hash_value = (hash_value + mod - (d*b[i-mid])%mod)%mod;\\n            }else{\\n                d = (d%mod *base%mod)%mod;\\n            }\\n            if(i>=mid-1){\\n                if(mp.count(hash_value)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int findLength(vector<int>& aa, vector<int>& bb) {\\n        a = aa;\\n        b = bb;\\n        n = a.size();\\n        m = b.size();\\n        \\n        int low  = 0 ,high = min(n,m);\\n        int ans= 0;\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            bool x = check(mid);\\n            if(x){\\n                ans = mid;\\n                low = mid + 1;\\n            }else{\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 401051,
                "title": "dynamic-programming",
                "content": "```java\\n    // solution 1\\n    public int findLength(int[] A, int[] B) {\\n        int lenA=A.length,lenB=B.length;\\n        int[][] dp = new int[lenA+1][lenB+1];\\n        \\n        int res = 0;\\n        for(int i=1;i<=lenA;i++){\\n            for(int j=1;j<=lenB;j++){\\n                dp[i][j]=(A[i-1]==B[j-1]) ? dp[i-1][j-1]+1 : 0;\\n                res = Math.max(res,dp[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    // solution 2\\n    public int findLength(int[] A, int[] B) {\\n        int lenA=A.length, lenB=B.length;\\n        int[][] dp = new int[lenA][lenB];\\n    \\n        int res=0;\\n        for(int i=0;i<lenA;i++){\\n            for(int j=0;j<lenB;j++){\\n                if(A[i]!=B[j]) dp[i][j]=0;\\n                else{\\n                    if(i-1>=0 && j-1>=0) dp[i][j]=dp[i-1][j-1]+1;\\n                    else dp[i][j]=1;\\n                }\\n                res = Math.max(res,dp[i][j]);\\n            }\\n            \\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\n    // solution 1\\n    public int findLength(int[] A, int[] B) {\\n        int lenA=A.length,lenB=B.length;\\n        int[][] dp = new int[lenA+1][lenB+1];\\n        \\n        int res = 0;\\n        for(int i=1;i<=lenA;i++){\\n            for(int j=1;j<=lenB;j++){\\n                dp[i][j]=(A[i-1]==B[j-1]) ? dp[i-1][j-1]+1 : 0;\\n                res = Math.max(res,dp[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    // solution 2\\n    public int findLength(int[] A, int[] B) {\\n        int lenA=A.length, lenB=B.length;\\n        int[][] dp = new int[lenA][lenB];\\n    \\n        int res=0;\\n        for(int i=0;i<lenA;i++){\\n            for(int j=0;j<lenB;j++){\\n                if(A[i]!=B[j]) dp[i][j]=0;\\n                else{\\n                    if(i-1>=0 && j-1>=0) dp[i][j]=dp[i-1][j-1]+1;\\n                    else dp[i][j]=1;\\n                }\\n                res = Math.max(res,dp[i][j]);\\n            }\\n            \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151096,
                "title": "python-iterative-dp-and-recursive-memoization-tle-solutions",
                "content": "\\n\\n\\t# 1. Dynamic Programming\\n\\t# O(nm) time\\n\\t# O(nm) space\\n    def findLength(self, A, B):\\n        n, m = len(A), len(B)\\n        dp = [[0 for j in range(m+1)] for i in range(n+1)]\\n        max_subarr = 0\\n        for i in range(n+1):\\n            for j in range(m+1):\\n                if i==0 or j==0:\\n                    dp[i][j] = 0\\n                else:\\n                    max_ending_here = 0\\n                    if A[i-1] == B[j-1]:\\n                        max_ending_here = 1+dp[i-1][j-1]\\n                        max_subarr = max(max_subarr, max_ending_here)\\n                    dp[i][j] = max_ending_here\\n        return max_subarr\\n\\n\\n\\t# 2. Memoization - Time Limit Exceeded\\n\\t# O(nm) time\\n\\t# O(nm) space\\n    def findLength(self, A, B):\\n        def max_common_subarr(n, m):\\n            global max_subarr\\n            if (n,m) in memory:\\n                return memory[(n,m)]\\n            if n==0 or m==0:\\n                return 0\\n            else:\\n                max_ending_here = 0\\n                if A[n-1] == B[m-1]:\\n                    max_ending_here = 1+max_common_subarr(n-1, m-1)\\n                decrease_n = max_common_subarr(n-1, m)\\n                decrease_m = max_common_subarr(n, m-1)\\n                max_subarr = max(max_subarr,max_ending_here, decrease_n, decrease_m)\\n                memory[(n,m)] = max_ending_here\\n                return max_ending_here\\n        \\n        n, m = len(A), len(B)\\n        global max_subarr\\n        max_subarr = 0\\n        memory = {}\\n        max_common_subarr(n, m)\\n        return max_subarr",
                "solutionTags": [],
                "code": "\\n\\n\\t# 1. Dynamic Programming\\n\\t# O(nm) time\\n\\t# O(nm) space\\n    def findLength(self, A, B):\\n        n, m = len(A), len(B)\\n        dp = [[0 for j in range(m+1)] for i in range(n+1)]\\n        max_subarr = 0\\n        for i in range(n+1):\\n            for j in range(m+1):\\n                if i==0 or j==0:\\n                    dp[i][j] = 0\\n                else:\\n                    max_ending_here = 0\\n                    if A[i-1] == B[j-1]:\\n                        max_ending_here = 1+dp[i-1][j-1]\\n                        max_subarr = max(max_subarr, max_ending_here)\\n                    dp[i][j] = max_ending_here\\n        return max_subarr\\n\\n\\n\\t# 2. Memoization - Time Limit Exceeded\\n\\t# O(nm) time\\n\\t# O(nm) space\\n    def findLength(self, A, B):\\n        def max_common_subarr(n, m):\\n            global max_subarr\\n            if (n,m) in memory:\\n                return memory[(n,m)]\\n            if n==0 or m==0:\\n                return 0\\n            else:\\n                max_ending_here = 0\\n                if A[n-1] == B[m-1]:\\n                    max_ending_here = 1+max_common_subarr(n-1, m-1)\\n                decrease_n = max_common_subarr(n-1, m)\\n                decrease_m = max_common_subarr(n, m-1)\\n                max_subarr = max(max_subarr,max_ending_here, decrease_n, decrease_m)\\n                memory[(n,m)] = max_ending_here\\n                return max_ending_here\\n        \\n        n, m = len(A), len(B)\\n        global max_subarr\\n        max_subarr = 0\\n        memory = {}\\n        max_common_subarr(n, m)\\n        return max_subarr",
                "codeTag": "Python3"
            },
            {
                "id": 2599218,
                "title": "c-bottom-up-iterative-code-space-optimised",
                "content": "**TC:- O(m*n)\\nSC:-O(nums2.size())**\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        vector<int> dp(nums2.size()+1,0); \\n        int maxLen = 0;\\n        for(int i = 1; i <= nums1.size(); i++)\\n        {\\n                for(int j = nums2.size(); j >= 1 ; j--)\\n                {\\n                    if(nums1[i-1] == nums2[j-1])\\n                    {\\n                        dp[j] = 1 + dp[j-1];\\n                        maxLen = max(maxLen, dp[j]);\\n                    }\\n                    else\\n                    {\\n                        dp[j] = 0;\\n                    }\\n                }\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        vector<int> dp(nums2.size()+1,0); \\n        int maxLen = 0;\\n        for(int i = 1; i <= nums1.size(); i++)\\n        {\\n                for(int j = nums2.size(); j >= 1 ; j--)\\n                {\\n                    if(nums1[i-1] == nums2[j-1])\\n                    {\\n                        dp[j] = 1 + dp[j-1];\\n                        maxLen = max(maxLen, dp[j]);\\n                    }\\n                    else\\n                    {\\n                        dp[j] = 0;\\n                    }\\n                }\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888689,
                "title": "evolve-from-brute-force-to-dp",
                "content": "This is very similar to [5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/discuss/753169/Evolve-from-brute-force-to-dp)\\n1. brute force O(nm*min(m,n)) \\n```\\n\\tpublic int findLength(int[] A, int[] B) {\\n        int maxLen=0, an=A.length, bn=B.length;\\n        for(int i=0;i<an;i++) \\n            for(int j=0;j<bn;j++) \\n                maxLen=Math.max(maxLen,getCommonLength(i,j,A,B));\\n        return maxLen;\\n    }\\n    private int getCommonLength(int i, int j, int[] A, int[] B) {\\n        if(i==A.length || j==B.length || A[i]!=B[j]) return 0;\\n        return 1+getCommonLength(i+1,j+1,A,B);\\n    }\\n}\\n```\\n2. Memoization O(mn)\\n```\\n\\tpublic int findLength(int[] A, int[] B) {\\n        int maxLen=0, an=A.length, bn=B.length;\\n        Integer[][] mem=new Integer[an][bn];\\n        for(int i=0;i<an;i++) \\n            for(int j=0;j<bn;j++) \\n                maxLen=Math.max(maxLen,getCommonLength(i,j,A,B,mem));\\n        return maxLen;\\n    }\\n    private int getCommonLength(int i, int j, int[] A, int[] B, Integer[][] mem) {\\n        if(i==A.length || j==B.length || A[i]!=B[j]) return 0;\\n        if(mem[i][j]!=null) return mem[i][j];\\n        return mem[i][j]=1+getCommonLength(i+1,j+1,A,B,mem);\\n    }\\n```\\n3. dp O(mn) Time, O(mn) Space. dp[i][j] means the max length of common subarray starting from A[i] and B[j]. \\n```\\n\\tpublic int findLength(int[] A, int[] B) {\\n        int maxLen=0, an=A.length, bn=B.length;\\n        int[][] dp=new int[an+1][bn+1];\\n        for(int i=an-1;i>=0;i--) \\n            for(int j=bn-1;j>=0;j--) {\\n                if(A[i]==B[j]) dp[i][j]=dp[i+1][j+1]+1;\\n                maxLen=Math.max(maxLen,dp[i][j]);\\n            }\\n        return maxLen;\\n    }\\n```\\n4. dp O(mn) Time, O(n) Space.\\n```\\n\\tpublic int findLength(int[] A, int[] B) {\\n        int maxLen=0, bn=B.length;\\n        int[] pre=new int[bn+1];\\n        for(int i=A.length-1;i>=0;i--) {\\n            int[] cur=new int[bn+1];\\n            for(int j=bn-1;j>=0;j--) {\\n                if(A[i]==B[j]) {\\n                    cur[j]=pre[j+1]+1;\\n                    maxLen=Math.max(maxLen,cur[j]);\\n                }\\n            }\\n            pre=cur;\\n        }\\n        return maxLen;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int findLength(int[] A, int[] B) {\\n        int maxLen=0, an=A.length, bn=B.length;\\n        for(int i=0;i<an;i++) \\n            for(int j=0;j<bn;j++) \\n                maxLen=Math.max(maxLen,getCommonLength(i,j,A,B));\\n        return maxLen;\\n    }\\n    private int getCommonLength(int i, int j, int[] A, int[] B) {\\n        if(i==A.length || j==B.length || A[i]!=B[j]) return 0;\\n        return 1+getCommonLength(i+1,j+1,A,B);\\n    }\\n}\\n```\n```\\n\\tpublic int findLength(int[] A, int[] B) {\\n        int maxLen=0, an=A.length, bn=B.length;\\n        Integer[][] mem=new Integer[an][bn];\\n        for(int i=0;i<an;i++) \\n            for(int j=0;j<bn;j++) \\n                maxLen=Math.max(maxLen,getCommonLength(i,j,A,B,mem));\\n        return maxLen;\\n    }\\n    private int getCommonLength(int i, int j, int[] A, int[] B, Integer[][] mem) {\\n        if(i==A.length || j==B.length || A[i]!=B[j]) return 0;\\n        if(mem[i][j]!=null) return mem[i][j];\\n        return mem[i][j]=1+getCommonLength(i+1,j+1,A,B,mem);\\n    }\\n```\n```\\n\\tpublic int findLength(int[] A, int[] B) {\\n        int maxLen=0, an=A.length, bn=B.length;\\n        int[][] dp=new int[an+1][bn+1];\\n        for(int i=an-1;i>=0;i--) \\n            for(int j=bn-1;j>=0;j--) {\\n                if(A[i]==B[j]) dp[i][j]=dp[i+1][j+1]+1;\\n                maxLen=Math.max(maxLen,dp[i][j]);\\n            }\\n        return maxLen;\\n    }\\n```\n```\\n\\tpublic int findLength(int[] A, int[] B) {\\n        int maxLen=0, bn=B.length;\\n        int[] pre=new int[bn+1];\\n        for(int i=A.length-1;i>=0;i--) {\\n            int[] cur=new int[bn+1];\\n            for(int j=bn-1;j>=0;j--) {\\n                if(A[i]==B[j]) {\\n                    cur[j]=pre[j+1]+1;\\n                    maxLen=Math.max(maxLen,cur[j]);\\n                }\\n            }\\n            pre=cur;\\n        }\\n        return maxLen;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 196385,
                "title": "java-recursion-memo",
                "content": "We have three cases to get the optimal solution for ```OPT(i,j)```, where i denotes the i\\'th index of array A and j denotes the j\\'th index of array B. And remeber we looking for the longest common sub-array, so our solution has to be contiguous, and that factors in how solve this.\\n\\n```Case 1: OPT(i,j) when A[i] == B[j]``` Since we have to digits match we possible have a candidate solution at the previous pair ```(i-1,j-1) + 1```\\n```Case 2 & Case 3: OPT(i,j) when A[i] != B[j]``` Since we dont have digits matching at this location check the next two possible pairs for matching indicies ```(i-1,j) & (i,j-1)```\\n\\n```\\n    public int findLength(int[] A, int[] B) {\\n        int[] max = new int[1];\\n        memo(A.length-1,B.length-1,A,B, new Integer[A.length][B.length],max);\\n        return max[0];\\n    }\\n    \\n    int memo(int i, int j, int[] A, int[] B, Integer[][] dp, int[] max){\\n        if(i < 0 || j < 0)\\n            return 0;\\n        \\n        if(dp[i][j] == null){\\n            dp[i][j] = 0;\\n            if(A[i] == B[j])\\n                dp[i][j] = memo(i-1,j-1,A,B,dp,max) + 1;\\n            memo(i-1,j,A,B,dp,max);\\n            memo(i,j-1,A,B,dp,max);\\n        }\\n        \\n        max[0] = Math.max(max[0],dp[i][j]);\\n        return dp[i][j];\\n    }\\n```",
                "solutionTags": [],
                "code": "```OPT(i,j)```\n```Case 1: OPT(i,j) when A[i] == B[j]```\n```(i-1,j-1) + 1```\n```Case 2 & Case 3: OPT(i,j) when A[i] != B[j]```\n```(i-1,j) & (i,j-1)```\n```\\n    public int findLength(int[] A, int[] B) {\\n        int[] max = new int[1];\\n        memo(A.length-1,B.length-1,A,B, new Integer[A.length][B.length],max);\\n        return max[0];\\n    }\\n    \\n    int memo(int i, int j, int[] A, int[] B, Integer[][] dp, int[] max){\\n        if(i < 0 || j < 0)\\n            return 0;\\n        \\n        if(dp[i][j] == null){\\n            dp[i][j] = 0;\\n            if(A[i] == B[j])\\n                dp[i][j] = memo(i-1,j-1,A,B,dp,max) + 1;\\n            memo(i-1,j,A,B,dp,max);\\n            memo(i,j-1,A,B,dp,max);\\n        }\\n        \\n        max[0] = Math.max(max[0],dp[i][j]);\\n        return dp[i][j];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 135695,
                "title": "javascript-solution-beats-100-00-runtime-100ms-no-dp-with-explanation",
                "content": "```\\nvar findLength = function(A, B) {\\n    let l1=A.length, l2=B.length, max=0;\\n    for(let offset=-l2+1; offset<l1; offset++){\\n    \\tlet l=0;\\n    \\tfor(let i=Math.max(0,offset); i<l1 && i-offset<l2; i++){\\n    \\t\\tif(A[i]===B[i-offset]){\\n    \\t\\t\\tl++;\\n    \\t\\t\\tmax = Math.max(max, l);\\n    \\t\\t}\\n    \\t\\telse l=0;\\n    \\t}\\n    }\\n    return max;\\n};\\n```\\n## Example to illustrate the algorithm:\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/lmiaoj/image_1528003145.png)\\n\\n\\nwhen offset=4, because overlap<max, we end the loop.\\nIn the code above, I didn\\'t calculate the overlap to compare with max;\\nif you add this limit to the loop, it may cut the runtime even more.",
                "solutionTags": [],
                "code": "```\\nvar findLength = function(A, B) {\\n    let l1=A.length, l2=B.length, max=0;\\n    for(let offset=-l2+1; offset<l1; offset++){\\n    \\tlet l=0;\\n    \\tfor(let i=Math.max(0,offset); i<l1 && i-offset<l2; i++){\\n    \\t\\tif(A[i]===B[i-offset]){\\n    \\t\\t\\tl++;\\n    \\t\\t\\tmax = Math.max(max, l);\\n    \\t\\t}\\n    \\t\\telse l=0;\\n    \\t}\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 109062,
                "title": "brute-force-python",
                "content": "I just try to longer and longer lengths, stopping at the first length where there's no common subarray of that length.\\n\\n    def findLength(self, A, B):\\n        A = bytes(A)\\n        B = bytes(B)\\n        for length in range(len(A) + 1):\\n            if not any(A[i:i+length] in B for i in range(len(A) - length + 1)):\\n                return length - 1\\n        return length\\n\\nShorter version:\\n\\n    def findLength(self, A, B):\\n        A, B = bytes(A), bytes(B)\\n        return next(k - 1\\n                    for k in range(len(A) + 2)\\n                    if not any(A[i:i+k] in B for i in range(len(A) - k + 1)))\\n\\nIt's O(n<sup>4</sup>) or more precisely O(|A|<sup>3</sup> &sdot; |B|), though I'm not sure that's a tight bound. Anyway, this gets accepted (in about 7000 ms) despite the poor complexity, thanks to using LeetCode's high time limit for Python (because Python code is slow) and builtin functionality written in C and fast.\\n\\nThe above is for Python 3, here's a Python 2 version that's a bit longer and which only got accepted (in about 6400 ms) two times in six submissions I just tried, because the Python 2 time limit is smaller than the Python 3 time limit for this problem:\\n\\n    def findLength(self, A, B):\\n        A = ''.join(map(chr, A))\\n        B = ''.join(map(chr, B))\\n        for length in xrange(len(A) + 1):\\n            if not any(A[i:i+length] in B for i in xrange(len(A) - length + 1)):\\n                return length - 1\\n        return length\\n\\nAnd here's a faster version (takes about 770 ms), using binary search for finding the length but still using the fast brute force for checking whether a length works.\\n\\n    def findLength(self, A, B):\\n        A, B = bytes(A), bytes(B)\\n        lo, hi = 0, len(A)\\n        while lo < hi:\\n            length = (lo + hi + 1) // 2\\n            if any(A[i:i+length] in B for i in range(len(A) - length + 1)):\\n                lo = length\\n            else:\\n                hi = length - 1\\n        return lo",
                "solutionTags": [],
                "code": "I just try to longer and longer lengths, stopping at the first length where there's no common subarray of that length.\\n\\n    def findLength(self, A, B):\\n        A = bytes(A)\\n        B = bytes(B)\\n        for length in range(len(A) + 1):\\n            if not any(A[i:i+length] in B for i in range(len(A) - length + 1)):\\n                return length - 1\\n        return length\\n\\nShorter version:\\n\\n    def findLength(self, A, B):\\n        A, B = bytes(A), bytes(B)\\n        return next(k - 1\\n                    for k in range(len(A) + 2)\\n                    if not any(A[i:i+k] in B for i in range(len(A) - k + 1)))\\n\\nIt's O(n<sup>4</sup>) or more precisely O(|A|<sup>3</sup> &sdot; |B|), though I'm not sure that's a tight bound. Anyway, this gets accepted (in about 7000 ms) despite the poor complexity, thanks to using LeetCode's high time limit for Python (because Python code is slow) and builtin functionality written in C and fast.\\n\\nThe above is for Python 3, here's a Python 2 version that's a bit longer and which only got accepted (in about 6400 ms) two times in six submissions I just tried, because the Python 2 time limit is smaller than the Python 3 time limit for this problem:\\n\\n    def findLength(self, A, B):\\n        A = ''.join(map(chr, A))\\n        B = ''.join(map(chr, B))\\n        for length in xrange(len(A) + 1):\\n            if not any(A[i:i+length] in B for i in xrange(len(A) - length + 1)):\\n                return length - 1\\n        return length\\n\\nAnd here's a faster version (takes about 770 ms), using binary search for finding the length but still using the fast brute force for checking whether a length works.\\n\\n    def findLength(self, A, B):\\n        A, B = bytes(A), bytes(B)\\n        lo, hi = 0, len(A)\\n        while lo < hi:\\n            length = (lo + hi + 1) // 2\\n            if any(A[i:i+length] in B for i in range(len(A) - length + 1)):\\n                lo = length\\n            else:\\n                hi = length - 1\\n        return lo",
                "codeTag": "Python3"
            },
            {
                "id": 3726415,
                "title": "no-dynamic-programming-2-approach-with-intuition-complexity-details-beginner-friendly-beats-60",
                "content": "# **Brute Force:-** \\n***Intuition***\\nThe code generates all subarrays of nums1 and checks for their presence in nums2. It finds the length of the longest common subarray between the two arrays.\\n\\n***Approach***\\n1. Generate all subarrays of nums1 by using two nested loops.\\n2. Iterate through nums2 and generate subarrays.\\n3. Check if each subarray of nums2 is present in the list of subarrays of nums1.\\n4. Update max with the length of the longest common subarray found.\\n5. Return max, or 0 if no common subarray is found.\\n\\n***Complexity***\\n1. Time complexity: O((n1 * n1) + (n2 * n2)), where n1 is the length of nums1 and n2 is the length of nums2.\\n2. Space complexity: O(n1^2 + n2).\\n\\n```\\nclass Solution {\\npublic int findLength(int[] nums1, int[] nums2) {\\n    // Store all subarrays of nums1\\n    List<List<Integer>> subarrays1 = new ArrayList<>();\\n\\n    // Generate all subarrays of nums1\\n    for (int i = 0; i < nums1.length; i++) {\\n        List<Integer> subarray = new ArrayList<>();\\n        for (int j = i; j < nums1.length; j++) {\\n            subarray.add(nums1[j]);\\n            subarrays1.add(new ArrayList<>(subarray));\\n        }\\n    }\\n\\n    // Find the length of the longest common subarray\\n    int max = Integer.MIN_VALUE;\\n\\n    // Iterate through nums2 and check for common subarrays\\n    for (int i = 0; i < nums2.length; i++) {\\n        List<Integer> subarray = new ArrayList<>();\\n        for (int j = i; j < nums2.length; j++) {\\n            subarray.add(nums2[j]);\\n            if (subarrays1.contains(subarray)) {\\n                max = Integer.max(max, subarray.size());\\n            }\\n        }\\n    }\\n\\n    // Return the length of the longest common subarray\\n    if (max == Integer.MIN_VALUE) {\\n        return 0;\\n    } else {\\n        return max;\\n    }\\n}\\n}\\n```\\n\\n# Optimized Code:- \\n\\nThe initial code **(first snippet)** will give you **Out of Memory errror**. To simplify the code and make it more efficient, we can use a different approach without explicitly generating all the subarrays. Here is the explanation of the optimized code:\\n\\n1. We start by initializing a variable, maxLen, to keep track of the length of the longest common subarray found so far.\\n\\n2. We iterate over each index, i, of nums1, representing the potential starting point of a common subarray.\\n\\n3. For each starting index, we compare the elements of nums1 starting from i with the elements of nums2 starting from the beginning (index 0).\\n\\n4. If the elements match, we increment a variable, len, to count the length of the current common subarray.\\n\\n5. We continue comparing the elements until they no longer match or until we reach the end of either array.\\n\\n6. Whenever the comparison ends, we update maxLen with the maximum value between maxLen and len, ensuring that it stores the length of the longest common subarray seen so far.\\n\\n7. We reset len to 0 for the next potential subarray starting from a different index in nums1.\\n\\n8. After comparing all possible subarrays, we return maxLen, which represents the length of the longest common subarray between nums1 and nums2.\\n\\nIn summary, the optimized code avoids explicitly generating all subarrays and instead uses a nested loop approach to compare elements directly. This leads to better efficiency and reduces the complexity of the code.\\n\\n# Complexity\\n- Time complexity:\\nThe code has a time complexity of O(n1 * n2), where n1 and n2 are the lengths of nums1 and nums2 respectively. This is because the code iterates through each index of nums1 (n1 iterations) and, for each index, iterates through each index of nums2 (n2 iterations). Within the nested loops, the elements of nums1 and nums2 are compared until they no longer match or until the end of one of the arrays is reached.\\n\\n- Space complexity:\\nThe code uses constant space for variables. It does not use any additional data structures, so the space complexity is O(1).\\n\\n# Code\\n```\\nclass Solution {\\n   public int findLength(int[] nums1, int[] nums2) {\\n    int m = nums1.length;\\n    int n = nums2.length;\\n    int maxLen = 0;\\n\\n    for (int i = 0; i < m; i++) {\\n        int len = 0; // Length of the current common subarray\\n        for (int j = 0; j < n; j++) {\\n            int k = i; // Pointer for nums1\\n            int l = j; // Pointer for nums2\\n\\n    // Compare elements and count the length of the common subarray\\n            while (k < m && l < n && nums1[k] == nums2[l]) {\\n                k++; // Move pointer in nums1\\n                l++; // Move pointer in nums2\\n                len++; // Increment the length of the common subarray\\n            }\\n\\n            // Update maxLen if a longer common subarray is found\\n            maxLen = Math.max(maxLen, len);\\n\\n            len = 0; // Reset len for the next subarray\\n        }\\n    }\\n\\n    return maxLen;\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic int findLength(int[] nums1, int[] nums2) {\\n    // Store all subarrays of nums1\\n    List<List<Integer>> subarrays1 = new ArrayList<>();\\n\\n    // Generate all subarrays of nums1\\n    for (int i = 0; i < nums1.length; i++) {\\n        List<Integer> subarray = new ArrayList<>();\\n        for (int j = i; j < nums1.length; j++) {\\n            subarray.add(nums1[j]);\\n            subarrays1.add(new ArrayList<>(subarray));\\n        }\\n    }\\n\\n    // Find the length of the longest common subarray\\n    int max = Integer.MIN_VALUE;\\n\\n    // Iterate through nums2 and check for common subarrays\\n    for (int i = 0; i < nums2.length; i++) {\\n        List<Integer> subarray = new ArrayList<>();\\n        for (int j = i; j < nums2.length; j++) {\\n            subarray.add(nums2[j]);\\n            if (subarrays1.contains(subarray)) {\\n                max = Integer.max(max, subarray.size());\\n            }\\n        }\\n    }\\n\\n    // Return the length of the longest common subarray\\n    if (max == Integer.MIN_VALUE) {\\n        return 0;\\n    } else {\\n        return max;\\n    }\\n}\\n}\\n```\n```\\nclass Solution {\\n   public int findLength(int[] nums1, int[] nums2) {\\n    int m = nums1.length;\\n    int n = nums2.length;\\n    int maxLen = 0;\\n\\n    for (int i = 0; i < m; i++) {\\n        int len = 0; // Length of the current common subarray\\n        for (int j = 0; j < n; j++) {\\n            int k = i; // Pointer for nums1\\n            int l = j; // Pointer for nums2\\n\\n    // Compare elements and count the length of the common subarray\\n            while (k < m && l < n && nums1[k] == nums2[l]) {\\n                k++; // Move pointer in nums1\\n                l++; // Move pointer in nums2\\n                len++; // Increment the length of the common subarray\\n            }\\n\\n            // Update maxLen if a longer common subarray is found\\n            maxLen = Math.max(maxLen, len);\\n\\n            len = 0; // Reset len for the next subarray\\n        }\\n    }\\n\\n    return maxLen;\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599536,
                "title": "why-python-solution-is-giving-tle",
                "content": "I solved this problem earlier but now I am getting TLE for O(N^2) approach.\\n\\nEarlier Accepted Python Solution now giving TLE\\n```python\\n\\nclass Solution(object):\\n    def findLength(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        dp = [ [0]* (len(nums1)+1) for i in range (len(nums2)+1)]\\n        \\n        \\n        maximum = float(\\'-inf\\')\\n        \\n        for i in range (1, len(nums2)+1):\\n            for j in range (1, len(nums1)+1):\\n         \\n                if nums2[i-1]== nums1[j-1]:\\n                    dp[i][j] = 1 + dp[i-1][j-1]\\n                else :\\n                    dp[i][j] = 0                    \\n                maximum = max(dp[i][j], maximum)        \\n        return maximum\\n```\\n\\n",
                "solutionTags": [],
                "code": "```python\\n\\nclass Solution(object):\\n    def findLength(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        dp = [ [0]* (len(nums1)+1) for i in range (len(nums2)+1)]\\n        \\n        \\n        maximum = float(\\'-inf\\')\\n        \\n        for i in range (1, len(nums2)+1):\\n            for j in range (1, len(nums1)+1):\\n         \\n                if nums2[i-1]== nums1[j-1]:\\n                    dp[i][j] = 1 + dp[i-1][j-1]\\n                else :\\n                    dp[i][j] = 0                    \\n                maximum = max(dp[i][j], maximum)        \\n        return maximum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599241,
                "title": "javascript-not-dp-just-optimized-95",
                "content": "The optimization is that when we find a match of length `ans`, we know we can stop searching at `n-ans` and `m-ans`, as these will not have long enough matches to beat what we already found.\\n\\n```\\nvar findLength = function(nums1, nums2) {\\n    let n = nums1.length;\\n    let m = nums2.length;\\n    var i, j;\\n    var x, y;\\n    var ans=0;\\n    \\n    for( i=0; i<n-ans; i++ ) {\\n        x = i;\\n        for( j=0; j<m-ans; j++ ) {\\n            y = j;\\n            while( x<nums1.length && y<nums2.length && nums1[x] == nums2[y] ) {\\n                x++;\\n                y++;\\n            }\\n            ans = Math.max(ans, x-i);\\n            x = i;\\n        }\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findLength = function(nums1, nums2) {\\n    let n = nums1.length;\\n    let m = nums2.length;\\n    var i, j;\\n    var x, y;\\n    var ans=0;\\n    \\n    for( i=0; i<n-ans; i++ ) {\\n        x = i;\\n        for( j=0; j<m-ans; j++ ) {\\n            y = j;\\n            while( x<nums1.length && y<nums2.length && nums1[x] == nums2[y] ) {\\n                x++;\\n                y++;\\n            }\\n            ans = Math.max(ans, x-i);\\n            x = i;\\n        }\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2414214,
                "title": "recursion-giving-wrong-answer-instead-of-tle",
                "content": "What is wrong in this implementation as it is failing at this test case:\\n\\n[0,1,1,1,1]\\n[1,0,1,0,1]\\n\\n```\\n    def helper2(self,nums1,nums2,m,n):        \\n        if(m==0 or n==0):\\n            return 0\\n        \\n        if(nums1[m-1]==nums2[n-1]):\\n            curr1=1+self.helper2(nums1,nums2,m-1,n-1)\\n            curr2=max(self.helper2(nums1,nums2,m-1,n),self.helper2(nums1,nums2,m,n-1))\\n            return max(curr1,curr2)\\n        else: \\n            \\n            return max(self.helper2(nums1,nums2,m-1,n),self.helper2(nums1,nums2,m,n-1))\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n    def helper2(self,nums1,nums2,m,n):        \\n        if(m==0 or n==0):\\n            return 0\\n        \\n        if(nums1[m-1]==nums2[n-1]):\\n            curr1=1+self.helper2(nums1,nums2,m-1,n-1)\\n            curr2=max(self.helper2(nums1,nums2,m-1,n),self.helper2(nums1,nums2,m,n-1))\\n            return max(curr1,curr2)\\n        else: \\n            \\n            return max(self.helper2(nums1,nums2,m-1,n),self.helper2(nums1,nums2,m,n-1))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1434672,
                "title": "javascript-top-down-approach",
                "content": "**Approach** : This is a classic implementation of longest common substring.\\n\\nPS: Feel free to ask your queries in comments ! I would love to answer \\uD83D\\uDE42\\uD83D\\uDE80\\uD83D\\uDE80\\n\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar findLength = function(nums1, nums2) {\\n    \\n    let dp = [];\\n    let ans = 0;\\n\\n    for(let row = 0 ; row<= nums1.length ; row++)\\n    {\\n        let array = [];\\n        for(let col = 0 ; col <= nums2.length ; col ++)\\n            array.push(-1);\\n        dp.push(array);\\n    }\\n    \\n    for(let ctr = 0 ; ctr < nums1.length+1; ctr ++)\\n        dp[ctr][0] = 0 ;\\n\\n    for(let ctr = 0 ; ctr < nums2.length + 1 ; ctr++)\\n        dp[0][ctr] = 0;\\n\\n    for(let row = 1 ; row < nums1.length + 1 ; row ++)\\n        for(let col = 1 ; col < nums2.length + 1 ; col ++)\\n        {\\n            if(nums1[row-1] == nums2[col-1]){\\n                dp[row][col] = 1 + dp[row-1][col-1];\\n                ans = Math.max(dp[row][col],ans);\\n            }\\n            else\\n                dp[row][col] = 0;\\n        }\\n\\n    return ans;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar findLength = function(nums1, nums2) {\\n    \\n    let dp = [];\\n    let ans = 0;\\n\\n    for(let row = 0 ; row<= nums1.length ; row++)\\n    {\\n        let array = [];\\n        for(let col = 0 ; col <= nums2.length ; col ++)\\n            array.push(-1);\\n        dp.push(array);\\n    }\\n    \\n    for(let ctr = 0 ; ctr < nums1.length+1; ctr ++)\\n        dp[ctr][0] = 0 ;\\n\\n    for(let ctr = 0 ; ctr < nums2.length + 1 ; ctr++)\\n        dp[0][ctr] = 0;\\n\\n    for(let row = 1 ; row < nums1.length + 1 ; row ++)\\n        for(let col = 1 ; col < nums2.length + 1 ; col ++)\\n        {\\n            if(nums1[row-1] == nums2[col-1]){\\n                dp[row][col] = 1 + dp[row-1][col-1];\\n                ans = Math.max(dp[row][col],ans);\\n            }\\n            else\\n                dp[row][col] = 0;\\n        }\\n\\n    return ans;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1150317,
                "title": "c-7-lines-dp",
                "content": "```\\n  int findLength(vector<int>& A, vector<int>& B) {\\n        vector<vector<int>>dp(A.size()+1, vector<int>(B.size()+1));\\n        int maxNum = 0;\\n        for (int i = 1; i <= A.size(); ++i) \\n            for (int j = 1; j <= B.size(); ++j) \\n                if (A[i-1] == B[j-1]) {\\n                    dp[i][j] = dp[i-1][j-1]+1;\\n                    maxNum = max(maxNum,dp[i][j]);\\n                }\\n        return maxNum;\\n    }\\n```\\n\\nUPVOTE if you like the solution",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n  int findLength(vector<int>& A, vector<int>& B) {\\n        vector<vector<int>>dp(A.size()+1, vector<int>(B.size()+1));\\n        int maxNum = 0;\\n        for (int i = 1; i <= A.size(); ++i) \\n            for (int j = 1; j <= B.size(); ++j) \\n                if (A[i-1] == B[j-1]) {\\n                    dp[i][j] = dp[i-1][j-1]+1;\\n                    maxNum = max(maxNum,dp[i][j]);\\n                }\\n        return maxNum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 109054,
                "title": "simple-java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int findLength(int[] A, int[] B) {\\n        int l1 = A.length, l2 = B.length, ans = 0;\\n        if (l1 == 0 || l2 == 0)\\n            return 0;        \\n        HashMap < Integer, List < Integer >> map = new HashMap < > ();\\n        List < Integer > list;\\n        for (int i = 0; i < l1; i++) {\\n            int n = A[i];\\n            list = map.getOrDefault(n, new ArrayList<Integer>());\\n            list.add(i);\\n            map.put(n, list);\\n        }\\n        \\n        for (int i = 0; i < l2 && l2-i > ans; i++) {\\n            int n = B[i];\\n            if (map.containsKey(n)){\\n                list = map.get(n);\\n                for (int m: list) {\\n                    if (l1 - m < ans)\\n                        break;                \\n                    int count = 1, k = m + 1;\\n                    for (int j = i + 1; j < l2 && k < l1; j++, k++) {\\n                        if (B[j] == A[k]) {\\n                            count++;\\n                        } else {\\n                            break;\\n                        }\\n                    }\\n                    ans = Math.max(ans, count);                \\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\nUpdate: I have updated my code. Thanks for suggestions.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findLength(int[] A, int[] B) {\\n        int l1 = A.length, l2 = B.length, ans = 0;\\n        if (l1 == 0 || l2 == 0)\\n            return 0;        \\n        HashMap < Integer, List < Integer >> map = new HashMap < > ();\\n        List < Integer > list;\\n        for (int i = 0; i < l1; i++) {\\n            int n = A[i];\\n            list = map.getOrDefault(n, new ArrayList<Integer>());\\n            list.add(i);\\n            map.put(n, list);\\n        }\\n        \\n        for (int i = 0; i < l2 && l2-i > ans; i++) {\\n            int n = B[i];\\n            if (map.containsKey(n)){\\n                list = map.get(n);\\n                for (int m: list) {\\n                    if (l1 - m < ans)\\n                        break;                \\n                    int count = 1, k = m + 1;\\n                    for (int j = i + 1; j < l2 && k < l1; j++, k++) {\\n                        if (B[j] == A[k]) {\\n                            count++;\\n                        } else {\\n                            break;\\n                        }\\n                    }\\n                    ans = Math.max(ans, count);                \\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841996,
                "title": "clean-code-simplest-c-dp-tabulation",
                "content": "\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int LCSubStr(vector<int>& X, vector<int>& Y, int n, int m){\\n   int LCSuff[n + 1][m + 1];\\n    int result = 0; \\n\\n    /* LCSuff[m+1][n+1] in\\n        bottom up fashion. */\\n    for (int i = 0; i <= n; i++){\\n        \\n        for (int j = 0; j <= m; j++){\\n            // The first row and first column\\n            // entries have no logical meaning,\\n            if (i == 0 || j == 0)\\n                LCSuff[i][j] = 0;\\n \\n            else if (X[i - 1] == Y[j - 1]) {\\n                LCSuff[i][j] = LCSuff[i - 1][j - 1] + 1;\\n                result = max(result, LCSuff[i][j]);\\n            }\\n            else\\n                LCSuff[i][j] = 0;\\n        }\\n    }\\n    return result;\\n}\\n\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        \\n        return LCSubStr(nums1,nums2,n,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int LCSubStr(vector<int>& X, vector<int>& Y, int n, int m){\\n   int LCSuff[n + 1][m + 1];\\n    int result = 0; \\n\\n    /* LCSuff[m+1][n+1] in\\n        bottom up fashion. */\\n    for (int i = 0; i <= n; i++){\\n        \\n        for (int j = 0; j <= m; j++){\\n            // The first row and first column\\n            // entries have no logical meaning,\\n            if (i == 0 || j == 0)\\n                LCSuff[i][j] = 0;\\n \\n            else if (X[i - 1] == Y[j - 1]) {\\n                LCSuff[i][j] = LCSuff[i - 1][j - 1] + 1;\\n                result = max(result, LCSuff[i][j]);\\n            }\\n            else\\n                LCSuff[i][j] = 0;\\n        }\\n    }\\n    return result;\\n}\\n\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        \\n        return LCSubStr(nums1,nums2,n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600837,
                "title": "python-simple-python-solution-using-dynamic-programming",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 8141 ms, faster than 19.36% of Python3 online submissions for Maximum Length of Repeated Subarray.\\n# Memory Usage: 38.6 MB, less than 79.13% of Python3 online submissions for Maximum Length of Repeated Subarray.\\n\\n\\tclass Solution:\\n\\t\\tdef findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tdp = [[0] * (len(nums2)+1) for _ in range(len(nums1)+1)] \\n\\n\\t\\t\\tfor i in range(len(nums1)):\\n\\n\\t\\t\\t\\tfor j in range(len(nums2)):\\n\\n\\t\\t\\t\\t\\tif nums1[i] == nums2[j]:\\n\\n\\t\\t\\t\\t\\t\\tnew_value = dp[i][j] + 1 \\n\\n\\t\\t\\t\\t\\t\\tdp[i+1][j+1] = new_value\\n\\n\\t\\t\\t\\t\\t\\tresult = max(result, new_value)\\n\\n\\t\\t\\treturn result\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 8141 ms, faster than 19.36% of Python3 online submissions for Maximum Length of Repeated Subarray.\\n# Memory Usage: 38.6 MB, less than 79.13% of Python3 online submissions for Maximum Length of Repeated Subarray.\\n\\n\\tclass Solution:\\n\\t\\tdef findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tdp = [[0] * (len(nums2)+1) for _ in range(len(nums1)+1)] \\n\\n\\t\\t\\tfor i in range(len(nums1)):\\n\\n\\t\\t\\t\\tfor j in range(len(nums2)):\\n\\n\\t\\t\\t\\t\\tif nums1[i] == nums2[j]:\\n\\n\\t\\t\\t\\t\\t\\tnew_value = dp[i][j] + 1 \\n\\n\\t\\t\\t\\t\\t\\tdp[i+1][j+1] = new_value\\n\\n\\t\\t\\t\\t\\t\\tresult = max(result, new_value)\\n\\n\\t\\t\\treturn result\\n",
                "codeTag": "Java"
            },
            {
                "id": 2600758,
                "title": "easy-and-99-2-faster-solution",
                "content": "```\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums2=\\'\\'.join([chr(i) for i in nums2])\\n        mx=\"\"\\n        ans=0\\n        for i in nums1:\\n            mx+=chr(i)\\n            if(mx in nums2):\\n                ans=max(ans,len(mx))\\n            else:\\n                mx=mx[1:]\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums2=\\'\\'.join([chr(i) for i in nums2])\\n        mx=\"\"\\n        ans=0\\n        for i in nums1:\\n            mx+=chr(i)\\n            if(mx in nums2):\\n                ans=max(ans,len(mx))\\n            else:\\n                mx=mx[1:]\\n        \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2599740,
                "title": "iterative-dp-same-as-longest-common-substring",
                "content": "Create a 2D dp vector of `nums1.size() * nums2.size()`\\n\\n1.  if `nums[i] != nums[j]`   we set the value dp[i][j] as 0.\\n\\n2.  if `nums1[i] == nums2[j]` , then the characters match and we simply set its value to`dp[i][j]= 1+dp[i-1][j-1]`.\\n```\\n        vector<vector<int>> dp(nums1.size(),vector<int> (nums2.size(),0));\\n        int res = 0;\\n        \\n        for(int i =0;i<nums1.size();i++){\\n            for(int  j = 0;j<nums2.size();j++){\\n                \\n                if(nums1[i] == nums2[j]){\\n                    dp[i][j]+=1;\\n                    if(i-1>=0 && j-1>=0)dp[i][j]+= dp[i-1][j-1];\\n                }\\n                res = max(res,dp[i][j]);\\n            }\\n        }\\n        return res;\\n```\\n\\n**We can optimize space as or any i,j  we only need the previous row for our computation. So size of dp array can be reduced to**\\n`2 * min(nums1.size(),nums2.size())` .",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n        vector<vector<int>> dp(nums1.size(),vector<int> (nums2.size(),0));\\n        int res = 0;\\n        \\n        for(int i =0;i<nums1.size();i++){\\n            for(int  j = 0;j<nums2.size();j++){\\n                \\n                if(nums1[i] == nums2[j]){\\n                    dp[i][j]+=1;\\n                    if(i-1>=0 && j-1>=0)dp[i][j]+= dp[i-1][j-1];\\n                }\\n                res = max(res,dp[i][j]);\\n            }\\n        }\\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1434668,
                "title": "cpp-concise-recursive-memoization-dp",
                "content": "This is a classic longest substring problem. The only catch is we have an array instead of string.\\n\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) \\n    {     \\n        int dp[nums1.size() + 1][nums2.size() + 1];\\n        int ans = 0;\\n        \\n        for(int idx = 0; idx <= nums1.size(); idx++)\\n            dp[idx][0] = 0;\\n        \\n        for(int idx = 0; idx <= nums2.size(); idx++)\\n            dp[0][idx] = 0;\\n        \\n        for(int row = 1; row <= nums1.size(); row++)\\n        {\\n            for(int col = 1; col <= nums2.size(); col++)\\n            {  \\n                if(nums1[row - 1] == nums2[col - 1]){\\n                    dp[row][col] = 1 + dp[row - 1][col - 1];\\n                    ans = max(dp[row][col], ans);\\n                }\\n                \\n                else dp[row][col] = 0;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    \\n    int helper(vector<int>& n1, vector<int> &n2, int idx1, int idx2)\\n    {\\n        if(idx1 < 0 || idx2 < 0) return 0;\\n        if(dp[idx1][idx2] != -1) return dp[idx1][idx2];\\n        \\n        helper(n1, n2, idx1 - 1, idx2);\\n        helper(n1, n2, idx1, idx2 - 1);\\n        \\n        if(n1[idx1] == n2[idx2]) return dp[idx1][idx2] = helper(n1,n2, idx1 - 1, idx2 -1) + 1;\\n        \\n        return dp[idx1][idx2] = 0;\\n    }\\n    \\n    int findLength(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        memset(dp, -1, sizeof(dp));\\n            \\n        int ans = 0;\\n        \\n        helper(nums1, nums2, nums1.size() - 1, nums2.size() - 1);\\n        \\n        for(int row = 0; row <= nums1.size(); row++)\\n        {\\n            for(int col = 0; col <= nums2.size(); col++)\\n                ans = max(ans, dp[row][col]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) \\n    {     \\n        int dp[nums1.size() + 1][nums2.size() + 1];\\n        int ans = 0;\\n        \\n        for(int idx = 0; idx <= nums1.size(); idx++)\\n            dp[idx][0] = 0;\\n        \\n        for(int idx = 0; idx <= nums2.size(); idx++)\\n            dp[0][idx] = 0;\\n        \\n        for(int row = 1; row <= nums1.size(); row++)\\n        {\\n            for(int col = 1; col <= nums2.size(); col++)\\n            {  \\n                if(nums1[row - 1] == nums2[col - 1]){\\n                    dp[row][col] = 1 + dp[row - 1][col - 1];\\n                    ans = max(dp[row][col], ans);\\n                }\\n                \\n                else dp[row][col] = 0;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    \\n    int helper(vector<int>& n1, vector<int> &n2, int idx1, int idx2)\\n    {\\n        if(idx1 < 0 || idx2 < 0) return 0;\\n        if(dp[idx1][idx2] != -1) return dp[idx1][idx2];\\n        \\n        helper(n1, n2, idx1 - 1, idx2);\\n        helper(n1, n2, idx1, idx2 - 1);\\n        \\n        if(n1[idx1] == n2[idx2]) return dp[idx1][idx2] = helper(n1,n2, idx1 - 1, idx2 -1) + 1;\\n        \\n        return dp[idx1][idx2] = 0;\\n    }\\n    \\n    int findLength(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        memset(dp, -1, sizeof(dp));\\n            \\n        int ans = 0;\\n        \\n        helper(nums1, nums2, nums1.size() - 1, nums2.size() - 1);\\n        \\n        for(int row = 0; row <= nums1.size(); row++)\\n        {\\n            for(int col = 0; col <= nums2.size(); col++)\\n                ans = max(ans, dp[row][col]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325251,
                "title": "maximum-length-of-repeated-subarray-solution-python3-dp",
                "content": "```\\nclass Solution:        \\n    def findLength(self, nums_a, nums_b):\\n        count_a = len(nums_a)\\n        count_b = len(nums_b)\\n        \\n        matrix = [[0 for k in range(count_b)] for l in range(count_a)]\\n        result = 0\\n        for i in range(count_a):\\n            for j in range(count_b):\\n                if nums_a[i] == nums_b[j]:\\n                    if i ==0 or j == 0:\\n                        matrix[i][j] = 1\\n                        result = max(result, matrix[i][j])\\n                    else:\\n                        matrix[i][j] = matrix[i-1][j-1] + 1\\n                        result = max(result, matrix[i][j])\\n                else:\\n                    pass\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:        \\n    def findLength(self, nums_a, nums_b):\\n        count_a = len(nums_a)\\n        count_b = len(nums_b)\\n        \\n        matrix = [[0 for k in range(count_b)] for l in range(count_a)]\\n        result = 0\\n        for i in range(count_a):\\n            for j in range(count_b):\\n                if nums_a[i] == nums_b[j]:\\n                    if i ==0 or j == 0:\\n                        matrix[i][j] = 1\\n                        result = max(result, matrix[i][j])\\n                    else:\\n                        matrix[i][j] = matrix[i-1][j-1] + 1\\n                        result = max(result, matrix[i][j])\\n                else:\\n                    pass\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324212,
                "title": "c-simple-easy-and-clean-lcs-solution-7-short-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size(), res = 0;\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                dp[i][j] = nums1[i-1] == nums2[j-1] ? 1 + dp[i-1][j-1] : 0;\\n                res = max(res, dp[i][j]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size(), res = 0;\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                dp[i][j] = nums1[i-1] == nums2[j-1] ? 1 + dp[i-1][j-1] : 0;\\n                res = max(res, dp[i][j]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201357,
                "title": "cpp-recursion-memozization-solution-easy-to-grasp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[1001][1001];\\n    \\n    int recurs(vector<int>& nums1, vector<int>& nums2,int i,int j)\\n    {\\n        \\n        if(i<0||j<0)\\n        {\\n            return 0;\\n        }\\n        \\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        \\n       \\n        recurs(nums1,nums2,i-1,j);\\n        recurs(nums1,nums2,i,j-1);\\n            \\n            if(nums1[i]==nums2[j])\\n            {\\n                return dp[i][j]=recurs(nums1,nums2,i-1,j-1)+1;\\n            }\\n        \\n           else\\n            {\\n            return dp[i][j]=0;\\n            }\\n    }\\n    \\n    \\n    \\n    \\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        for(int i=0;i<=nums1.size();i++)\\n        {\\n             for(int j=0;j<=nums2.size();j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n            \\n        }\\n        \\n         recurs(nums1,nums2,nums1.size()-1,nums2.size()-1);\\n        int max1=0;\\n        \\n         for(int i=0;i<=nums1.size();i++)\\n        {\\n             for(int j=0;j<=nums2.size();j++)\\n            {\\n                max1=max(max1,dp[i][j]);\\n            }\\n            \\n        }\\n        \\n        return max1;\\n    }\\n};\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[1001][1001];\\n    \\n    int recurs(vector<int>& nums1, vector<int>& nums2,int i,int j)\\n    {\\n        \\n        if(i<0||j<0)\\n        {\\n            return 0;\\n        }\\n        \\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        \\n       \\n        recurs(nums1,nums2,i-1,j);\\n        recurs(nums1,nums2,i,j-1);\\n            \\n            if(nums1[i]==nums2[j])\\n            {\\n                return dp[i][j]=recurs(nums1,nums2,i-1,j-1)+1;\\n            }\\n        \\n           else\\n            {\\n            return dp[i][j]=0;\\n            }\\n    }\\n    \\n    \\n    \\n    \\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        for(int i=0;i<=nums1.size();i++)\\n        {\\n             for(int j=0;j<=nums2.size();j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n            \\n        }\\n        \\n         recurs(nums1,nums2,nums1.size()-1,nums2.size()-1);\\n        int max1=0;\\n        \\n         for(int i=0;i<=nums1.size();i++)\\n        {\\n             for(int j=0;j<=nums2.size();j++)\\n            {\\n                max1=max(max1,dp[i][j]);\\n            }\\n            \\n        }\\n        \\n        return max1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1199034,
                "title": "java-clean-o-n-2-time-o-1-space-dynamic-programming-solution-with-comments",
                "content": "This article aims to show the process of how we can get an O(1)-space Dynammic Programming Solution from the most naive one. However, we may have a solution with better time complexity using Rabin-Karp\\'s Algorithm. Feel free to check this post: \\n* [718. Maximum Length of Repeated Subarray: Rabin-Karp Solution](https://leetcode.com/problems/maximum-length-of-repeated-subarray/discuss/1181612/Java-Clean-O(N-logN)-Rolling-Hash-Solution-oror-with-comments)\\n\\nFirst of all, defining each entry of dp-table is pretty straightforward. For each index pair i, j, we only consider subarrays **ending at** nums1[i] & ending at nums2[j]. And dp\\\\[i\\\\]\\\\[j\\\\] stores the max length of common subarrays only for those subarrays. \\n\\nThe relation of bigger problem & smaller problem is also straightforward: \\n```\\n// for index pair (i+1, j+1)\\n1. nums1[i+1] != nums2[j+1]    ==>  dp[i+1][j+1] = 0\\n2. nums1[i+1] == nums2[j+1]    ==>  dp[i+1][j+1] = dp[i][j] + 1\\n```\\n\\nThus we may have this very straightforward Solution Version 1: \\n```\\n// Version 1:  O(N^2)-Space\\nclass Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        int m = nums1.length, n = nums2.length, res = 0;\\n        \\n        // dp[i][j] : max length for subarray of nums1[0: i] ending at nums1[i] \\n        //                       and subarray of nums2[0: j] ending at nums2[j]\\n        int[][] dp = new int[m][n];\\n        \\n        // first row:\\n        for (int j = 0; j < n; j++) {\\n            dp[0][j] = (nums1[0] == nums2[j]) ? 1 : 0;\\n            res = Math.max(res, dp[0][j]);\\n        }\\n        \\n        // first column: \\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = (nums1[i] == nums2[0]) ? 1 : 0;\\n            res = Math.max(res, dp[i][0]);\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                if (nums1[i] != nums2[j]) continue;\\n                dp[i][j] = dp[i-1][j-1] + 1;\\n                res = Math.max(res, dp[i][j]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\nOr equivalently, we may rewrite Version 1 as Version 2. \\n```\\n// Version 2:  O(N^2)-Space\\nclass Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        int m = nums1.length, n = nums2.length, res = 0;\\n        \\n        int[][] dp = new int[m+1][n+1];\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (nums1[i] != nums2[j]) continue;\\n                dp[i+1][j+1] = dp[i][j] + 1;\\n                res = Math.max(res, dp[i+1][j+1]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\nNow notice in the dp-table, for each entry (i, j) we only need the information from its left-top entry (i-1, j-1). Thus we can traverse all entries in the dp-table by:\\n1. starting from every entry on the **left boundary** of dp-table, and traverse in the direction of **right-bottom** until reach a boundary. \\n2. starting from every entry on the **top boundary** of dp-table, and traverse in the direction of **right-bottom** until reach a boundary. \\n\\nNamely, we should start with the entries:\\n```\\n1. left boundary:     [0, 0],  [1, 0], ... , [m-1, 0]\\n2. top boundary:     ([0, 0]), [0, 1], ... , [0, n-1]\\n```\\n\\nThen we may reduce the Space Complexity to O(1) by only keep the record of previous entry. \\n```\\n// Version 3:  O(1)-Space\\nclass Solution {\\n    private int[] nums1;\\n    private int[] nums2;\\n    private int res;\\n    public int findLength(int[] nums1, int[] nums2) {\\n        this.nums1 = nums1;\\n        this.nums2 = nums2;\\n        this.res = 0;\\n        \\n        // starting from first column \\n        for (int i = 0; i < nums1.length; i++) {\\n            checkRightBottom(i, 0);\\n        }\\n        \\n        // starting from first column \\n        for (int j = 1; j < nums2.length; j++) {\\n            checkRightBottom(0, j);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void checkRightBottom(int i, int j) {\\n        int prev = 0;\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i++] == nums2[j++]) {\\n                res = Math.max(res, ++prev);\\n            } else {\\n                prev = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n// for index pair (i+1, j+1)\\n1. nums1[i+1] != nums2[j+1]    ==>  dp[i+1][j+1] = 0\\n2. nums1[i+1] == nums2[j+1]    ==>  dp[i+1][j+1] = dp[i][j] + 1\\n```\n```\\n// Version 1:  O(N^2)-Space\\nclass Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        int m = nums1.length, n = nums2.length, res = 0;\\n        \\n        // dp[i][j] : max length for subarray of nums1[0: i] ending at nums1[i] \\n        //                       and subarray of nums2[0: j] ending at nums2[j]\\n        int[][] dp = new int[m][n];\\n        \\n        // first row:\\n        for (int j = 0; j < n; j++) {\\n            dp[0][j] = (nums1[0] == nums2[j]) ? 1 : 0;\\n            res = Math.max(res, dp[0][j]);\\n        }\\n        \\n        // first column: \\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = (nums1[i] == nums2[0]) ? 1 : 0;\\n            res = Math.max(res, dp[i][0]);\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                if (nums1[i] != nums2[j]) continue;\\n                dp[i][j] = dp[i-1][j-1] + 1;\\n                res = Math.max(res, dp[i][j]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\n// Version 2:  O(N^2)-Space\\nclass Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        int m = nums1.length, n = nums2.length, res = 0;\\n        \\n        int[][] dp = new int[m+1][n+1];\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (nums1[i] != nums2[j]) continue;\\n                dp[i+1][j+1] = dp[i][j] + 1;\\n                res = Math.max(res, dp[i+1][j+1]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\n1. left boundary:     [0, 0],  [1, 0], ... , [m-1, 0]\\n2. top boundary:     ([0, 0]), [0, 1], ... , [0, n-1]\\n```\n```\\n// Version 3:  O(1)-Space\\nclass Solution {\\n    private int[] nums1;\\n    private int[] nums2;\\n    private int res;\\n    public int findLength(int[] nums1, int[] nums2) {\\n        this.nums1 = nums1;\\n        this.nums2 = nums2;\\n        this.res = 0;\\n        \\n        // starting from first column \\n        for (int i = 0; i < nums1.length; i++) {\\n            checkRightBottom(i, 0);\\n        }\\n        \\n        // starting from first column \\n        for (int j = 1; j < nums2.length; j++) {\\n            checkRightBottom(0, j);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void checkRightBottom(int i, int j) {\\n        int prev = 0;\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i++] == nums2[j++]) {\\n                res = Math.max(res, ++prev);\\n            } else {\\n                prev = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119308,
                "title": "javascript-simple-dynamic-programming",
                "content": "Time: `O(M * N)`\\nSpace:  `O(M * N)`\\n```javascript\\nvar findLength = function(A, B) {\\n    const dp = [...Array(A.length+1)].map(() => Array(B.length+1).fill(0));\\n    let maxLen = 0;\\n    \\n    for(let i = 1; i <= A.length; i++) {\\n        for(let j = 1; j <= B.length; j++) {\\n            if(A[i-1] === B[j-1]) {\\n                dp[i][j] = dp[i-1][j-1] + 1;\\n                maxLen = Math.max(maxLen, dp[i][j]);\\n            }\\n        }\\n    }\\n    return maxLen;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```javascript\\nvar findLength = function(A, B) {\\n    const dp = [...Array(A.length+1)].map(() => Array(B.length+1).fill(0));\\n    let maxLen = 0;\\n    \\n    for(let i = 1; i <= A.length; i++) {\\n        for(let j = 1; j <= B.length; j++) {\\n            if(A[i-1] === B[j-1]) {\\n                dp[i][j] = dp[i-1][j-1] + 1;\\n                maxLen = Math.max(maxLen, dp[i][j]);\\n            }\\n        }\\n    }\\n    return maxLen;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1030289,
                "title": "simple-java-approach-dynamic-programming-clean-code",
                "content": "```\\nclass Solution {\\n    public int findLength(int[] A, int[] B) {\\n        int ans = 0;\\n        int[][] memo = new int[A.length + 1][B.length + 1];\\n     \\n        for (int i = 0; i < A.length; i++) {\\n            for (int j = 0; j < B.length; j++) {\\n                if (A[i] == B[j]) {\\n                    if(i==0 || j==0)\\n                         memo[i][j]=1;    \\n                    else\\n                         memo[i][j] = memo[i-1][j-1] + 1;\\n                    if (ans < memo[i][j]) \\n                        ans = memo[i][j];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findLength(int[] A, int[] B) {\\n        int ans = 0;\\n        int[][] memo = new int[A.length + 1][B.length + 1];\\n     \\n        for (int i = 0; i < A.length; i++) {\\n            for (int j = 0; j < B.length; j++) {\\n                if (A[i] == B[j]) {\\n                    if(i==0 || j==0)\\n                         memo[i][j]=1;    \\n                    else\\n                         memo[i][j] = memo[i-1][j-1] + 1;\\n                    if (ans < memo[i][j]) \\n                        ans = memo[i][j];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958194,
                "title": "python3-longest-common-substring-concept",
                "content": "```\\nclass Solution:\\n    def findLength(self, A: List[int], B: List[int]) -> int:\\n        \\n        if not A or not B:\\n            return 0\\n        \\n        return self.lcs(A,B)\\n        \\n    def lcs(self,a,b):\\n        n = len(a)\\n        m = len(b)\\n        \\n        dp = [[0]*(n+1) for i in range(m+1)]\\n        res = 0\\n        \\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                \\n                if a[i-1] == b[j-1]:\\n                    dp[i][j] = 1 + dp[i-1][j-1]\\n                    res = max(res,dp[i][j])\\n                    \\n                else:\\n                    dp[i][j] = 0\\n                    \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findLength(self, A: List[int], B: List[int]) -> int:\\n        \\n        if not A or not B:\\n            return 0\\n        \\n        return self.lcs(A,B)\\n        \\n    def lcs(self,a,b):\\n        n = len(a)\\n        m = len(b)\\n        \\n        dp = [[0]*(n+1) for i in range(m+1)]\\n        res = 0\\n        \\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                \\n                if a[i-1] == b[j-1]:\\n                    dp[i][j] = 1 + dp[i-1][j-1]\\n                    res = max(res,dp[i][j])\\n                    \\n                else:\\n                    dp[i][j] = 0\\n                    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914373,
                "title": "python-super-concise-string-matching-no-dp",
                "content": "**Idea:** for each value b in B, we record the longest common subarray that **ends** at b and keep recording the length. We also use `chr` function to convert array matching to string matching. \\n\\nWe keep a string `s` to be the longest common string that ends at the current position in B and `s` is extended at the end in each step. If the new `s` is not in A, we remove one element of `s` from the start, otherwise we update the longest length.\\n\\nFor example, if `A=[1,2,3,5,6,7]`, `B=[1,2,3,4,5,6]`,  initially `s=\\'\\'`. As we loop over B, `s` goes from `[1]` to `[1,2]` to `[1,2,3]` as all these subarrays are found in `A`, and the max length is now 3 (Note that from now on we don\\'t need to consider common arrays shorter than or equal to 3). Next step `s=[1,2,3,4]` is not found in `A`, so we remove one element from the start `s=[2,3,4]`  and next step we extend one element at the end, now `s=[2,3,4,5]` still not in `A`. We keep going until reaching the end of `B`, `s=[3,4,5,6]` still not in `A` and conclude that the max length=3. \\n\\n```\\nclass Solution:\\n    def findLength(self, A: List[int], B: List[int]) -> int:\\n        a=\\'\\'.join([chr(n) for n in A])\\n        ans=0\\n        s=\\'\\'\\n        for b in B:\\n            s+=chr(b)\\n            if s in a:\\n                ans=len(s)\\n            else:\\n                s=s[1:]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLength(self, A: List[int], B: List[int]) -> int:\\n        a=\\'\\'.join([chr(n) for n in A])\\n        ans=0\\n        s=\\'\\'\\n        for b in B:\\n            s+=chr(b)\\n            if s in a:\\n                ans=len(s)\\n            else:\\n                s=s[1:]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907260,
                "title": "python-2-clean-solutions-dp-and-binary-search",
                "content": "### DP\\n    def findLength(self, A: List[int], B: List[int]) -> int:\\n        \\'\\'\\'\\n            dp[i][j] = dp[i-1][j-1] + 1,  if A[i-1] == B[j-1]\\n                     = 0,                 else\\n            \\n            dp[i][0] = dp[0][j] = 0\\n            \\n            Time: O(n^2)     # test 4920 ms\\n        \\'\\'\\'\\n        dp = [[0 for j in range(len(B)+1)] for i in range(len(A)+1)]\\n        res = 0\\n        for i in range(1, len(A)+1):\\n            for j in range(1, len(B)+1):\\n                if A[i-1] == B[j-1]:\\n                    dp[i][j] = dp[i-1][j-1] + 1\\n                    res = max(dp[i][j],res)\\n        return res\\n\\t\\t\\n### Binary Search\\n```\\n    def findLength(self, A: List[int], B: List[int]) -> int:\\n        \\'\\'\\'\\n            Binary search:\\n\\t\\t\\t    0. The idea comes from the property:\\n\\t\\t\\t        if there exists a length-k common subarray, there will be also 1,2,..,k-1 length common subarrays.  \\n\\t\\t\\t\\t\\t(When we try to search for a length-k subarray,\\n\\t\\t\\t\\t\\t      if we can\\'t find, we want to decrease k; if we find it, we want to increase k.)\\n                1. The target is to binary search maximum length. \\n                   For each current length \"mid\", check if there are repeated subarry in both arrays.  \\n                   The init range is [1, min(len(A),len(B))+1 )\\n                2. Use set to hash every subarray with \"k\" length in A. \\n                   Then for every subarray with \"k\" length in B, check if could match.\\n            \\n            Time: O(k*(n-k)*logn)  # test 480 ms    \\n        \\'\\'\\'\\n        def check(k): # O((n-k)*k)\\n            setA = set([tuple(A[i:i+k]) for i in range(len(A)-k+1)])  \\n            return any(tuple(B[j:j+k]) in setA for j in range(len(B)-k+1))\\n        \\n        res = 0\\n        lo, hi = 1, min(len(A),len(B))+1\\n        while lo < hi: # O(logn)\\n            mid = (lo+hi) // 2\\n            if check(mid) == True:\\n                res = max(mid, res)\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return res\\n```\\n\\n#### **Upvote** is the best encouragement for me. Thanks!",
                "solutionTags": [],
                "code": "```\\n    def findLength(self, A: List[int], B: List[int]) -> int:\\n        \\'\\'\\'\\n            Binary search:\\n\\t\\t\\t    0. The idea comes from the property:\\n\\t\\t\\t        if there exists a length-k common subarray, there will be also 1,2,..,k-1 length common subarrays.  \\n\\t\\t\\t\\t\\t(When we try to search for a length-k subarray,\\n\\t\\t\\t\\t\\t      if we can\\'t find, we want to decrease k; if we find it, we want to increase k.)\\n                1. The target is to binary search maximum length. \\n                   For each current length \"mid\", check if there are repeated subarry in both arrays.  \\n                   The init range is [1, min(len(A),len(B))+1 )\\n                2. Use set to hash every subarray with \"k\" length in A. \\n                   Then for every subarray with \"k\" length in B, check if could match.\\n            \\n            Time: O(k*(n-k)*logn)  # test 480 ms    \\n        \\'\\'\\'\\n        def check(k): # O((n-k)*k)\\n            setA = set([tuple(A[i:i+k]) for i in range(len(A)-k+1)])  \\n            return any(tuple(B[j:j+k]) in setA for j in range(len(B)-k+1))\\n        \\n        res = 0\\n        lo, hi = 1, min(len(A),len(B))+1\\n        while lo < hi: # O(logn)\\n            mid = (lo+hi) // 2\\n            if check(mid) == True:\\n                res = max(mid, res)\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 785113,
                "title": "c-bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int longest(vector<int>& A, vector<int>& B,int n1,int n2){\\n        if(dp[n1][n2]!=-1)return dp[n1][n2];\\n        if(n1==0 or n2==0)return dp[n1][n2]=0;\\n        if(A[n1-1]==B[n2-1])return dp[n1][n2]=1+longest(A,B,n1-1,n2-1);\\n        else return dp[n1][n2]=0;\\n    }\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=0;\\n        for(int i=A.size();i>=0;i--)\\n            for(int j=B.size();j>=0;j--)\\n                longest(A,B,i,j);\\n        for(int i=A.size();i>=0;i--)\\n            for(int j=B.size();j>=0;j--)\\n                ans=max(ans,dp[i][j]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int longest(vector<int>& A, vector<int>& B,int n1,int n2){\\n        if(dp[n1][n2]!=-1)return dp[n1][n2];\\n        if(n1==0 or n2==0)return dp[n1][n2]=0;\\n        if(A[n1-1]==B[n2-1])return dp[n1][n2]=1+longest(A,B,n1-1,n2-1);\\n        else return dp[n1][n2]=0;\\n    }\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=0;\\n        for(int i=A.size();i>=0;i--)\\n            for(int j=B.size();j>=0;j--)\\n                longest(A,B,i,j);\\n        for(int i=A.size();i>=0;i--)\\n            for(int j=B.size();j>=0;j--)\\n                ans=max(ans,dp[i][j]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 131784,
                "title": "python-6-lines-easy-and-clear-solution-268-ms-beats-99",
                "content": "Just make string A with every num separated by \"X\" and add B\\'s nums to substring separated by \"X\" and check if substring is in A. If it is in A, increase result by 1 else shift substring to next num in substring.\\n```\\nclass Solution:\\n    def findLength(self, A, B):\\n        A, res, sub = \"X%sX\" % \"X\".join(map(str, A)), 0, \"X\"\\n        for num in B:\\n            sub += str(num) + \"X\"\\n            if sub in A: res += 1\\n            else: sub = sub[sub[1:].index(\"X\") + 1:]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLength(self, A, B):\\n        A, res, sub = \"X%sX\" % \"X\".join(map(str, A)), 0, \"X\"\\n        for num in B:\\n            sub += str(num) + \"X\"\\n            if sub in A: res += 1\\n            else: sub = sub[sub[1:].index(\"X\") + 1:]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696911,
                "title": "simple-c-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& s1, vector<int>& s2) {\\n        int x=s1.size();\\n//calculating Size of first vector s1\\n        int y=s2.size();\\n//calculating Size of 2nd vector s2\\n        vector<vector<int>> dp(x+1,vector<int>(y+1,0));\\n//a 2d vector of size x+1 and y+1 \\n        for(int j=0;j<=y;j++){\\n            dp[0][j]=0;\\n//storing value 0 for 1st row\\n            \\n        }\\n        for(int i=0;i<=x;i++){\\n            dp[i][0]=0;\\n            \\n        }\\n//storing value 0 for 1st column\\n        \\n        int ans = 0;\\n//a answer variable initial value set to 0\\n        for(int i=1;i<=x;i++){\\n            for(int j=1;j<=y;j++){\\n                if(s1[i-1]==s2[j-1]){\\n//if vectors consecutive element are matched the adding 1 to previous //diagonally stored value\\n                    dp[i][j]=1+dp[i-1][j-1];\\n\\n                    ans=max(ans,dp[i][j]);\\n//storing maximum value to ans variable\\n                }\\n                else{\\n                    dp[i][j]=0;\\n// if element not matched then store 0 at that index\\n                }\\n            }\\n        }\\n        return ans;\\n// at last return 0\\n    }\\n    \\n};\\n\\n\\n//if helpful please upvote the solution\\n//by divyanshu singh....\\uD83D\\uDE0C\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& s1, vector<int>& s2) {\\n        int x=s1.size();\\n//calculating Size of first vector s1\\n        int y=s2.size();\\n//calculating Size of 2nd vector s2\\n        vector<vector<int>> dp(x+1,vector<int>(y+1,0));\\n//a 2d vector of size x+1 and y+1 \\n        for(int j=0;j<=y;j++){\\n            dp[0][j]=0;\\n//storing value 0 for 1st row\\n            \\n        }\\n        for(int i=0;i<=x;i++){\\n            dp[i][0]=0;\\n            \\n        }\\n//storing value 0 for 1st column\\n        \\n        int ans = 0;\\n//a answer variable initial value set to 0\\n        for(int i=1;i<=x;i++){\\n            for(int j=1;j<=y;j++){\\n                if(s1[i-1]==s2[j-1]){\\n//if vectors consecutive element are matched the adding 1 to previous //diagonally stored value\\n                    dp[i][j]=1+dp[i-1][j-1];\\n\\n                    ans=max(ans,dp[i][j]);\\n//storing maximum value to ans variable\\n                }\\n                else{\\n                    dp[i][j]=0;\\n// if element not matched then store 0 at that index\\n                }\\n            }\\n        }\\n        return ans;\\n// at last return 0\\n    }\\n    \\n};\\n\\n\\n//if helpful please upvote the solution\\n//by divyanshu singh....\\uD83D\\uDE0C\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793122,
                "title": "longest-common-substring-tabulation-memoization-simple-way-easy-to-understand",
                "content": "**Longest Common substring** is a similar question as **Longest Common Subsequence** but only have smaller changes :\\nIf characters are equal : **dp[i][j]=1 + dp[i-1][j-1]**\\n**else dp[i][j]=0** // this is the only change\\nIf any Querry then Comment \\n\\n//Tabulation    \\n       \\n\\t int fun_tab(string s1,string s2,int n,int m)\\n    {\\n        int dp[n+1][m+1];\\n        for(int i = 0; i<= n;i++)\\n        {\\n            for(int j = 0; j <= m; j++)\\n            {\\n                 // dp[i][j] = 0;\\n                  if(i == 0 or j == 0) dp[i][j] = 0;\\n            }\\n        }\\n\\t   int maxLen=0;\\n\\t   for(int i = 1; i<= n;i++)\\n        {\\n            for(int j = 1; j <= m; j++)\\n            {\\n                if(s1[i-1] == s2[j-1])\\n                    dp[i][j] = 1+dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 0;\\n\\t\\t\\t\\tmaxLen=max(maxLen,dp[i][j]);\\n            }\\n        }\\n        return maxLen;\\n    }\\n\\t int longestCommonSubsequence(string text1, string text2) {\\n        int n = text1.size();\\n        int m = text2.size();\\n        return fun_tab(text1,text2,n,m);\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "**Longest Common substring** is a similar question as **Longest Common Subsequence** but only have smaller changes :\\nIf characters are equal : **dp[i][j]=1 + dp[i-1][j-1]**\\n**else dp[i][j]=0** // this is the only change\\nIf any Querry then Comment \\n\\n//Tabulation    \\n       \\n\\t int fun_tab(string s1,string s2,int n,int m)\\n    {\\n        int dp[n+1][m+1];\\n        for(int i = 0; i<= n;i++)\\n        {\\n            for(int j = 0; j <= m; j++)\\n            {\\n                 // dp[i][j] = 0;\\n                  if(i == 0 or j == 0) dp[i][j] = 0;\\n            }\\n        }\\n\\t   int maxLen=0;\\n\\t   for(int i = 1; i<= n;i++)\\n        {\\n            for(int j = 1; j <= m; j++)\\n            {\\n                if(s1[i-1] == s2[j-1])\\n                    dp[i][j] = 1+dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 0;\\n\\t\\t\\t\\tmaxLen=max(maxLen,dp[i][j]);\\n            }\\n        }\\n        return maxLen;\\n    }\\n\\t int longestCommonSubsequence(string text1, string text2) {\\n        int n = text1.size();\\n        int m = text2.size();\\n        return fun_tab(text1,text2,n,m);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2601584,
                "title": "python-iterative-bottom-up-solution-o-mn-time-o-mn-space",
                "content": "```\\n# * Iterative Bottom-Up Solution | O(mn) Time | O(mn) Space\\n# * m -> The length of nums1 array | n -> The length of nums2 array\\n\\n\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1_len, nums2_len = len(nums1), len(nums2)\\n        # * Create a 2-D DP with the rows as nums1_len + 1 (Including empty subarray)\\n        # * and cols as nums2_len + 1 (Including empty subarray).\\n        dp = [[0] * (nums2_len + 1) for _ in range(nums1_len + 1)]\\n\\n        max_subarray_len = 0\\n        # * Start the iteration from the first row and first col.\\n        for i in range(1, nums1_len + 1):\\n            for j in range(1, nums2_len + 1):\\n                # * If both elements match then we set the value by chopping\\n                # * the current element in both the arrays and adding 1 to it.\\n                if nums1[i - 1] == nums2[j - 1]:\\n                    dp[i][j] = 1 + dp[i - 1][j - 1]\\n                    max_subarray_len = max(max_subarray_len, dp[i][j])\\n\\n        return max_subarray_len\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n# * Iterative Bottom-Up Solution | O(mn) Time | O(mn) Space\\n# * m -> The length of nums1 array | n -> The length of nums2 array\\n\\n\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1_len, nums2_len = len(nums1), len(nums2)\\n        # * Create a 2-D DP with the rows as nums1_len + 1 (Including empty subarray)\\n        # * and cols as nums2_len + 1 (Including empty subarray).\\n        dp = [[0] * (nums2_len + 1) for _ in range(nums1_len + 1)]\\n\\n        max_subarray_len = 0\\n        # * Start the iteration from the first row and first col.\\n        for i in range(1, nums1_len + 1):\\n            for j in range(1, nums2_len + 1):\\n                # * If both elements match then we set the value by chopping\\n                # * the current element in both the arrays and adding 1 to it.\\n                if nums1[i - 1] == nums2[j - 1]:\\n                    dp[i][j] = 1 + dp[i - 1][j - 1]\\n                    max_subarray_len = max(max_subarray_len, dp[i][j])\\n\\n        return max_subarray_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600154,
                "title": "simple-java-tabulated-dp-solution",
                "content": "```\\nclass Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        int n=nums1.length,m=nums2.length,i,j,res=0;\\n        int dp[][]=new int[n+1][m+1];\\n        for(i=1;i<=n;i++)\\n            for(j=1;j<=m;j++)\\n                if(nums1[i-1]==nums2[j-1])\\n                    res=Math.max(dp[i][j]=dp[i-1][j-1]+1,res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        int n=nums1.length,m=nums2.length,i,j,res=0;\\n        int dp[][]=new int[n+1][m+1];\\n        for(i=1;i<=n;i++)\\n            for(j=1;j<=m;j++)\\n                if(nums1[i-1]==nums2[j-1])\\n                    res=Math.max(dp[i][j]=dp[i-1][j-1]+1,res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599951,
                "title": "dynamic-programming-with-go",
                "content": "```\\nfunc findLength(nums1 []int, nums2 []int) int {\\n\\tarr := make([][]int, len(nums1)+1)\\n\\n\\tfor i := 0; i < len(arr); i++ {\\n\\t\\tarr[i] = make([]int, len(nums2)+1)\\n\\t}\\n    \\n    result := 0\\n    \\n\\tfor i := len(nums1) - 1; i > -1; i-- {\\n\\t\\tfor j := len(nums2) - 1; j > -1; j-- {\\n\\t\\t\\tif nums1[i] == nums2[j] {\\n                if arr[i+1][j+1] != 0 {\\n                    arr[i][j] = arr[i+1][j+1] + 1\\n                } else {\\n                    arr[i][j] = 1\\n                }\\n                \\n                result = max(result, arr[i][j])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    \\n\\treturn result\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc findLength(nums1 []int, nums2 []int) int {\\n\\tarr := make([][]int, len(nums1)+1)\\n\\n\\tfor i := 0; i < len(arr); i++ {\\n\\t\\tarr[i] = make([]int, len(nums2)+1)\\n\\t}\\n    \\n    result := 0\\n    \\n\\tfor i := len(nums1) - 1; i > -1; i-- {\\n\\t\\tfor j := len(nums2) - 1; j > -1; j-- {\\n\\t\\t\\tif nums1[i] == nums2[j] {\\n                if arr[i+1][j+1] != 0 {\\n                    arr[i][j] = arr[i+1][j+1] + 1\\n                } else {\\n                    arr[i][j] = 1\\n                }\\n                \\n                result = max(result, arr[i][j])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    \\n\\treturn result\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2599914,
                "title": "daily-leetcode-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        int m=nums2.size();\\n        vector<int> prev(m+1,0);\\n        vector<int> curr(m+1,0);\\n        int maxi=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(nums1[i-1]==nums2[j-1])\\n                {\\n                    curr[j]=1+prev[j-1];\\n                    maxi=max(maxi,curr[j]);\\n                }\\n                else\\n                {\\n                    curr[j]=0;\\n                }\\n            }\\n            prev=curr;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        int m=nums2.size();\\n        vector<int> prev(m+1,0);\\n        vector<int> curr(m+1,0);\\n        int maxi=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(nums1[i-1]==nums2[j-1])\\n                {\\n                    curr[j]=1+prev[j-1];\\n                    maxi=max(maxi,curr[j]);\\n                }\\n                else\\n                {\\n                    curr[j]=0;\\n                }\\n            }\\n            prev=curr;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599837,
                "title": "c-three-solutions-using-kmp-dp-and-binary-search",
                "content": "We can solve this problem using KMP.\\nFor every subarray of `nums1` starting at `index i`, find the largest occurrence in `nums2`.\\nThe code for this approach :\\n```\\nclass Solution {\\npublic:\\n    vector<int>getLPS(vector<int>&a){\\n        int n=a.size();\\n        vector<int>lps(n);\\n        lps[0]=0;\\n        int i=1, j=0;\\n        while(i<n){\\n            if(a[i]==a[j])\\n                lps[i++]=++j;\\n            else if(j!=0)\\n                j=lps[j-1];\\n            else\\n                lps[i++]=0;\\n        }\\n        return lps;\\n    }\\n    \\n    int getMaxLen(vector<int>&a, vector<int>&pat){\\n        vector<int>b=pat;\\n        b.push_back(INT_MAX);\\n        for(auto &x:a)b.push_back(x);\\n        vector<int>lps = getLPS(b);\\n        int ans=0;\\n        for(int i=pat.size()+1; i<b.size(); i++){\\n            ans=max(ans, lps[i]);\\n        }\\n        return ans;\\n    }\\n    \\n    int findLength(vector<int>& a, vector<int>& b) {\\n        int ans=0;\\n        if(a.size()>b.size())swap(a,b);\\n        for(int i = 0; i<a.size(); i++){\\n            vector<int>temp;\\n            for(int k=i; k<a.size(); k++)\\n                temp.push_back(a[k]);\\n            ans=max(ans, getMaxLen(b, temp));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nSimple DP based approach where `DP[i][j]` tells us how many elements from `nums1[i]` and `nums2[j]` are continously matching.\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& a, vector<int>& b) {\\n        int n=a.size(), m=b.size();\\n        vector<vector<int>>DP(n+1, vector<int>(m+1));\\n        int ans=0;\\n        for(int i=n; i>=0; i--){\\n            for(int j=m; j>=0; j--){\\n                if(i==n || j==m){\\n                    DP[i][j] = 0;\\n                    continue;\\n                }\\n                if(a[i]!=b[j])\\n                    DP[i][j]=0;\\n                else\\n                    DP[i][j] = DP[i+1][j+1]+1;\\n                ans=max(ans, DP[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nWe can also solve this question by using binary search on answer, by checking, \"for evey subarray (of `nums1`) of length `mid`, whether it is present in `nums2` or not (Using KMP or any other pattern searching algorithm).\\nif it is present, the `leftBound = mid+1`, Otherwise `rightBound = mid`.\\nCode for the same:\\n(I haven\\'t used KMP in this approach, instead i converted the arrays into strings and used library `find()`  function (alongside a hashSet)\\n```\\nclass Solution {\\npublic:\\n    string s1,s2; int n1,n2;\\n    bool can(int k){\\n        if(k==0)return true;\\n        unordered_set<string>st;\\n        for(int i=0;i+k<=n2;i++){\\n            st.insert(s2.substr(i,k));\\n        }\\n        for(int i=0;i+k<=n1;i++){\\n            string s=s1.substr(i,k);\\n            if(st.find(s)!=st.end())\\n                return true;\\n        }\\n        return false;\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        for(auto x:nums1)\\n            s1.push_back(x+\\'0\\');\\n        for(auto x:nums2)\\n            s2.push_back(x+\\'0\\');\\n        n1=s1.size(); n2=s2.size();\\n        int l=0,r=min(s1.size(),s2.size())+1;\\n        while(l<r){\\n            int mid=(l+r)/2;\\n            if(can(mid))\\n                l=mid+1;\\n            else\\n                r=mid;\\n        }\\n        return l-1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>getLPS(vector<int>&a){\\n        int n=a.size();\\n        vector<int>lps(n);\\n        lps[0]=0;\\n        int i=1, j=0;\\n        while(i<n){\\n            if(a[i]==a[j])\\n                lps[i++]=++j;\\n            else if(j!=0)\\n                j=lps[j-1];\\n            else\\n                lps[i++]=0;\\n        }\\n        return lps;\\n    }\\n    \\n    int getMaxLen(vector<int>&a, vector<int>&pat){\\n        vector<int>b=pat;\\n        b.push_back(INT_MAX);\\n        for(auto &x:a)b.push_back(x);\\n        vector<int>lps = getLPS(b);\\n        int ans=0;\\n        for(int i=pat.size()+1; i<b.size(); i++){\\n            ans=max(ans, lps[i]);\\n        }\\n        return ans;\\n    }\\n    \\n    int findLength(vector<int>& a, vector<int>& b) {\\n        int ans=0;\\n        if(a.size()>b.size())swap(a,b);\\n        for(int i = 0; i<a.size(); i++){\\n            vector<int>temp;\\n            for(int k=i; k<a.size(); k++)\\n                temp.push_back(a[k]);\\n            ans=max(ans, getMaxLen(b, temp));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& a, vector<int>& b) {\\n        int n=a.size(), m=b.size();\\n        vector<vector<int>>DP(n+1, vector<int>(m+1));\\n        int ans=0;\\n        for(int i=n; i>=0; i--){\\n            for(int j=m; j>=0; j--){\\n                if(i==n || j==m){\\n                    DP[i][j] = 0;\\n                    continue;\\n                }\\n                if(a[i]!=b[j])\\n                    DP[i][j]=0;\\n                else\\n                    DP[i][j] = DP[i+1][j+1]+1;\\n                ans=max(ans, DP[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string s1,s2; int n1,n2;\\n    bool can(int k){\\n        if(k==0)return true;\\n        unordered_set<string>st;\\n        for(int i=0;i+k<=n2;i++){\\n            st.insert(s2.substr(i,k));\\n        }\\n        for(int i=0;i+k<=n1;i++){\\n            string s=s1.substr(i,k);\\n            if(st.find(s)!=st.end())\\n                return true;\\n        }\\n        return false;\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        for(auto x:nums1)\\n            s1.push_back(x+\\'0\\');\\n        for(auto x:nums2)\\n            s2.push_back(x+\\'0\\');\\n        n1=s1.size(); n2=s2.size();\\n        int l=0,r=min(s1.size(),s2.size())+1;\\n        while(l<r){\\n            int mid=(l+r)/2;\\n            if(can(mid))\\n                l=mid+1;\\n            else\\n                r=mid;\\n        }\\n        return l-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599502,
                "title": "javascript-solution",
                "content": "```\\nvar findLength = function(nums1, nums2) {\\n    var temp_arr = Array(nums2.length + 1).fill(0);\\n    var ans = 0;\\n    for(var i = 1; i <= nums1.length; i++) {\\n        //Loop from the end to avoid duplicate\\n        for(var j = nums2.length; j > 0; j--) { \\n            if(nums1[i - 1] === nums2[j - 1]) {\\n                temp_arr[j] = temp_arr[j - 1] + 1;\\n            } else {\\n                //reset result\\n                temp_arr[j] = 0; \\n            }\\n            if(ans < temp_arr[j]) {\\n              ans = temp_arr[j];  \\n            } \\n        }\\n    }\\n    return ans;\\n};\\n\\n// Runtime: 219 ms, faster than 94.18% of JavaScript online submissions for Maximum Length of Repeated Subarray.\\n// Memory Usage: 42.5 MB, less than 91.64% of JavaScript online submissions for Maximum Length of Repeated Subarray.\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findLength = function(nums1, nums2) {\\n    var temp_arr = Array(nums2.length + 1).fill(0);\\n    var ans = 0;\\n    for(var i = 1; i <= nums1.length; i++) {\\n        //Loop from the end to avoid duplicate\\n        for(var j = nums2.length; j > 0; j--) { \\n            if(nums1[i - 1] === nums2[j - 1]) {\\n                temp_arr[j] = temp_arr[j - 1] + 1;\\n            } else {\\n                //reset result\\n                temp_arr[j] = 0; \\n            }\\n            if(ans < temp_arr[j]) {\\n              ans = temp_arr[j];  \\n            } \\n        }\\n    }\\n    return ans;\\n};\\n\\n// Runtime: 219 ms, faster than 94.18% of JavaScript online submissions for Maximum Length of Repeated Subarray.\\n// Memory Usage: 42.5 MB, less than 91.64% of JavaScript online submissions for Maximum Length of Repeated Subarray.\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2599363,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Bottom Up Dp***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N * N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n1 = nums1.size();\\n        \\n        int n2 = nums2.size();\\n        \\n        // declare a dp\\n        \\n        vector<vector<int>> dp(n1 + 1, vector<int> (n2 + 1, 0));\\n        \\n        int maxi = 0;\\n        \\n        // fill dp\\n        \\n        for(int i = 0; i <= n1; i++)\\n        {\\n            for(int j = 0; j <= n2; j++)\\n            {\\n                // base case\\n                \\n                if(i == 0 || j == 0)\\n                {\\n                    dp[i][j] = 0;\\n                }\\n                else\\n                {\\n                    if(nums1[i - 1] == nums2[j - 1])\\n                    {\\n                        dp[i][j] = 1 + dp[i - 1][j - 1];\\n                    }\\n                    else\\n                    {\\n                        dp[i][j] = 0;\\n                    }\\n                }\\n                \\n                // update maxi\\n                \\n                maxi = max(maxi, dp[i][j]);\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n1 = nums1.size();\\n        \\n        int n2 = nums2.size();\\n        \\n        // declare a dp\\n        \\n        vector<vector<int>> dp(n1 + 1, vector<int> (n2 + 1, 0));\\n        \\n        int maxi = 0;\\n        \\n        // fill dp\\n        \\n        for(int i = 0; i <= n1; i++)\\n        {\\n            for(int j = 0; j <= n2; j++)\\n            {\\n                // base case\\n                \\n                if(i == 0 || j == 0)\\n                {\\n                    dp[i][j] = 0;\\n                }\\n                else\\n                {\\n                    if(nums1[i - 1] == nums2[j - 1])\\n                    {\\n                        dp[i][j] = 1 + dp[i - 1][j - 1];\\n                    }\\n                    else\\n                    {\\n                        dp[i][j] = 0;\\n                    }\\n                }\\n                \\n                // update maxi\\n                \\n                maxi = max(maxi, dp[i][j]);\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599291,
                "title": "c-simple-and-concise-sliding-window-o-mn-o-1",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        // try to slide on both side\\n        return max(solve(nums1, nums2), solve(nums2, nums1));\\n    }\\nprivate:\\n    int solve(vector<int> &nums1, vector<int> &nums2) {\\n        // slide nums1 on nums2, from left to right\\n        //\\n        // nums1: [a, b, c, d, e], nums2: [w, x, y, z]\\n        // [a, b, c, d, e]->       [a, b, c, d, e]->          [a, b, c, d, e]-> ...\\n        // [w, x, y, z]         [w, x, y, z]            [w, x, y, z]\\n        \\n        int res = 0;\\n        for (int start = 0; start < size(nums2); ++start) {\\n            int acc = 0;\\n            for (int i = 0; i < size(nums1) && start + i < size(nums2); ++i) {\\n                if (nums1[i] == nums2[start + i]) acc++;\\n                else acc = 0;\\n                \\n                res = max(res, acc);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nTime complexity: `O(MN)`, where `M` is the size of nums1 and `N` is the size of nums2\\nSpace complexity: `O(1)`",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        // try to slide on both side\\n        return max(solve(nums1, nums2), solve(nums2, nums1));\\n    }\\nprivate:\\n    int solve(vector<int> &nums1, vector<int> &nums2) {\\n        // slide nums1 on nums2, from left to right\\n        //\\n        // nums1: [a, b, c, d, e], nums2: [w, x, y, z]\\n        // [a, b, c, d, e]->       [a, b, c, d, e]->          [a, b, c, d, e]-> ...\\n        // [w, x, y, z]         [w, x, y, z]            [w, x, y, z]\\n        \\n        int res = 0;\\n        for (int start = 0; start < size(nums2); ++start) {\\n            int acc = 0;\\n            for (int i = 0; i < size(nums1) && start + i < size(nums2); ++i) {\\n                if (nums1[i] == nums2[start + i]) acc++;\\n                else acc = 0;\\n                \\n                res = max(res, acc);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599274,
                "title": "python3-7-lines-memo-w-explanation-t-m-81-79",
                "content": "```\\nclass Solution:                 # 1) We build memo, a 2Darray, 2) iterate thru nums1 & nums2\\n                                # in reverse to populate memo, and then 3) find the max element\\n                                # in memo; its row and col in memo shows the starting indices\\n                                # for the common seq in nums1 and nums2.  \\n\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        n1, n2 = len(nums1), len(nums2)          \\n        memo = [[0]*(n2+1) for _ in range(n1+1)]                    # <-- 1)\\n        \\n        for idx1 in range(n1)[::-1]:\\n            for idx2 in range(n2)[::-1]:\\n                \\n                if nums1[idx1] == nums2[idx2]:\\n                    memo[idx1][idx2] = 1 + memo[idx1+1][idx2+1]     # <-- 2)\\n       \\n        return max(chain(*memo))                                    # <-- 3)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:                 # 1) We build memo, a 2Darray, 2) iterate thru nums1 & nums2\\n                                # in reverse to populate memo, and then 3) find the max element\\n                                # in memo; its row and col in memo shows the starting indices\\n                                # for the common seq in nums1 and nums2.  \\n\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        n1, n2 = len(nums1), len(nums2)          \\n        memo = [[0]*(n2+1) for _ in range(n1+1)]                    # <-- 1)\\n        \\n        for idx1 in range(n1)[::-1]:\\n            for idx2 in range(n2)[::-1]:\\n                \\n                if nums1[idx1] == nums2[idx2]:\\n                    memo[idx1][idx2] = 1 + memo[idx1+1][idx2+1]     # <-- 2)\\n       \\n        return max(chain(*memo))                                    # <-- 3)",
                "codeTag": "Java"
            },
            {
                "id": 2599199,
                "title": "daily-leetcoding-challenge-september-day-20",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-length-of-repeated-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force with Initial Character Map [Time Limit Exceeded]\n\n  \n**Approach 2:** Binary Search with Naive Check [Time Limit Exceeded]\n\n  \n**Approach 3:** Dynamic Programming [Accepted]\n\n  \n**Approach 4:** Binary Search with Rolling Hash [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-length-of-repeated-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2226167,
                "title": "90-faster-java-ac-similar-to-longest-common-substring-bottom-up-approach",
                "content": "\\n\\t \\n\\t class Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        int m=nums1.length;\\n        int n=nums2.length;\\n        int dp[][]=new int[m+1][n+1];\\n        int ans=0;\\n        for(int i=1;i<=m;i++)\\n            for(int j=1;j<=n;j++){\\n                if(nums1[i-1]==nums2[j-1]){\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                    ans=Math.max(ans,dp[i][j]);\\n                }\\n                else\\n                    dp[i][j] = 0;\\n            }\\n        \\n        return ans;\\n        \\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        int m=nums1.length;\\n        int n=nums2.length;\\n        int dp[][]=new int[m+1][n+1];\\n        int ans=0;\\n        for(int i=1;i<=m;i++)\\n            for(int j=1;j<=n;j++){\\n                if(nums1[i-1]==nums2[j-1]){\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                    ans=Math.max(ans,dp[i][j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2134600,
                "title": "simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        int result[n+1][m+1], mx = 0;\\n        memset(result, 0, sizeof(result));\\n        for(int i = 1; i <= n; i++)\\n        {\\n            for(int j = 1; j <= m; j++)\\n            {\\n                if(nums1[i-1] == nums2[j-1])\\n                {\\n                    result[i][j] = 1+result[i-1][j-1];\\n                    mx = max(mx,result[i][j]);\\n                } \\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        int result[n+1][m+1], mx = 0;\\n        memset(result, 0, sizeof(result));\\n        for(int i = 1; i <= n; i++)\\n        {\\n            for(int j = 1; j <= m; j++)\\n            {\\n                if(nums1[i-1] == nums2[j-1])\\n                {\\n                    result[i][j] = 1+result[i-1][j-1];\\n                    mx = max(mx,result[i][j]);\\n                } \\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065804,
                "title": "python-top-down-dp-o-n-2",
                "content": "```\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        if not nums1 or not nums2:\\n            return 0\\n        \\n        M, N = len(nums1), len(nums2)\\n        memo = {}\\n        \\n        if nums1 == nums2: return M\\n        \\n        def matching(i,j):\\n\\n            state = (i,j)\\n            \\n            if state in memo: return memo[state]\\n            \\n            if i > M-1 or j > N-1: \\n                memo[state] = 0\\n                return 0\\n            \\n            if nums1[i] != nums2[j]: \\n                memo[state] = 0\\n                return 0\\n            \\n            memo[state] = 1 + matching(i+1, j+1)\\n            \\n            return memo[state]            \\n            \\n        result = 0\\n        \\n        for i in range(M):\\n            for j in range(N):\\n                if nums1[i] == nums2[j] and result < min(M-i, N-j):\\n                    result = max(result, matching(i,j))\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        if not nums1 or not nums2:\\n            return 0\\n        \\n        M, N = len(nums1), len(nums2)\\n        memo = {}\\n        \\n        if nums1 == nums2: return M\\n        \\n        def matching(i,j):\\n\\n            state = (i,j)\\n            \\n            if state in memo: return memo[state]\\n            \\n            if i > M-1 or j > N-1: \\n                memo[state] = 0\\n                return 0\\n            \\n            if nums1[i] != nums2[j]: \\n                memo[state] = 0\\n                return 0\\n            \\n            memo[state] = 1 + matching(i+1, j+1)\\n            \\n            return memo[state]            \\n            \\n        result = 0\\n        \\n        for i in range(M):\\n            for j in range(N):\\n                if nums1[i] == nums2[j] and result < min(M-i, N-j):\\n                    result = max(result, matching(i,j))\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519986,
                "title": "c-sliding-window-explanation-120ms-100-faster",
                "content": "Sliding first array into another and check for max subarray and then the same op but exchanging arrays.\\ne.g. Here is one of the test cases:\\n```\\n[1,2,3,2,1]\\n[3,2,1,4,7]\\n```\\nHere we will see the sliding approach:\\n```\\nnums1: [1,2,3,2,1]\\nnums2: [7]\\n\\nnums1: [1,2,3,2,1]\\nnums2: [4,7]\\n\\nnums1: [1,2,3,2,1]\\nnums2: [1,4,7]\\n\\nnums1: [1,2,3,2,1]\\nnums2: [2,1,4,7]\\n\\nnums1: [1,2,3,2,1]\\nnums2: [3,2,1,4,7]\\n```\\nNow flipping array and slide again:\\n```\\nnums1: [3,2,1,4,7]\\nnums2: [1]\\n\\nnums1: [3,2,1,4,7]\\nnums2: [2,1]\\n```\\nAnd here is the longest subarray:\\n\\nnums1: [**3,2,1**,4,7]\\nnums2: [**3,2,1**]\\n```\\nnums1: [3,2,1,4,7]\\nnums2: [2,3,2,1]\\n\\nnums1: [3,2,1,4,7]\\nnums2: [1,2,3,2,1]\\n```\\n\\nActual code:\\n```\\npublic class Solution {\\n   public int FindLength(int[] nums1, int[] nums2) {\\n        return Math.Max(slide(nums1, nums2), slide(nums2, nums1));\\n    }\\n    \\n    private int slide(int[] nums1, int[] nums2)\\n    {\\n        var result = 0;\\n        var i = nums1.Length - 1;\\n        while(i > -1)\\n        {\\n            var k = 0;\\n            var current = 0;\\n            for(var j = i; j < nums1.Length; j++)\\n            {\\n                if (k >= nums2.Length) break;\\n                if (nums1[j] == nums2[k])\\n                {\\n                    current++;\\n                    result = Math.Max(result, current);\\n                }\\n                else current = 0;\\n                k++;\\n            }\\n            i--;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n[1,2,3,2,1]\\n[3,2,1,4,7]\\n```\n```\\nnums1: [1,2,3,2,1]\\nnums2: [7]\\n\\nnums1: [1,2,3,2,1]\\nnums2: [4,7]\\n\\nnums1: [1,2,3,2,1]\\nnums2: [1,4,7]\\n\\nnums1: [1,2,3,2,1]\\nnums2: [2,1,4,7]\\n\\nnums1: [1,2,3,2,1]\\nnums2: [3,2,1,4,7]\\n```\n```\\nnums1: [3,2,1,4,7]\\nnums2: [1]\\n\\nnums1: [3,2,1,4,7]\\nnums2: [2,1]\\n```\n```\\nnums1: [3,2,1,4,7]\\nnums2: [2,3,2,1]\\n\\nnums1: [3,2,1,4,7]\\nnums2: [1,2,3,2,1]\\n```\n```\\npublic class Solution {\\n   public int FindLength(int[] nums1, int[] nums2) {\\n        return Math.Max(slide(nums1, nums2), slide(nums2, nums1));\\n    }\\n    \\n    private int slide(int[] nums1, int[] nums2)\\n    {\\n        var result = 0;\\n        var i = nums1.Length - 1;\\n        while(i > -1)\\n        {\\n            var k = 0;\\n            var current = 0;\\n            for(var j = i; j < nums1.Length; j++)\\n            {\\n                if (k >= nums2.Length) break;\\n                if (nums1[j] == nums2[k])\\n                {\\n                    current++;\\n                    result = Math.Max(result, current);\\n                }\\n                else current = 0;\\n                k++;\\n            }\\n            i--;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349510,
                "title": "java-easy-bottom-up-aditya-verma-trick-of-lcs",
                "content": "```\\nclass Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        int n=nums1.length;\\n        int m=nums2.length;\\n        int [][]dp =new int[n+1][m+1];\\n        \\n         \\n        for(int i=0;i<n+1;i++)\\n        {\\n            for(int j=0;j<m+1;j++)\\n            {\\n                if(i==0||j==0)\\n                {\\n                    dp[i][j]=0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<n+1;i++)\\n        {\\n            for(int j=1;j<m+1;j++)\\n            {\\n                if(nums1[i-1]==nums2[j-1])\\n                {\\n                    dp[i][j]=dp[i-1][j-1]+1;\\n                }\\n                else\\n                {\\n                    dp[i][j]=0;\\n                }\\n                \\n            }            \\n        }\\n        int max=0;\\n        for(int i=0;i<n+1;i++)\\n        {\\n            for(int j=0;j<m+1;j++)\\n            {\\n                max=Math.max(max,dp[i][j]);\\n            }\\n        }\\n        \\n        return max;\\n    }   \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        int n=nums1.length;\\n        int m=nums2.length;\\n        int [][]dp =new int[n+1][m+1];\\n        \\n         \\n        for(int i=0;i<n+1;i++)\\n        {\\n            for(int j=0;j<m+1;j++)\\n            {\\n                if(i==0||j==0)\\n                {\\n                    dp[i][j]=0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1325574,
                "title": "c-without-dp-98-better-memory-very-easy-understandable-code-simple",
                "content": "\\nI simply run the loop for every number in first array and same process for second array.\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& num1, vector<int>& num2) {\\n        int cnt = 0;\\n        for(int i = 0; i < num2.size(); i++) {\\n            int c = 0, k = i;\\n            for(int j = 0; j < num1.size(); j++) {\\n                if(num1[j] == num2[k]) {\\n                    c++; k++;\\n                    cnt = max(c,cnt);\\n                } else { \\n                    c = 0; k = i;\\n                    if(num1[j] == num2[k]) {\\n                        c++; k++;\\n                        cnt = max(c,cnt);\\n                    } else {\\n                        continue;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i = 0; i < num1.size(); i++) {\\n            int c = 0, k = i;\\n            for(int j = 0; j < num2.size(); j++) {\\n                if(num2[j] == num1[k]) {\\n                    c++; k++;\\n                    cnt = max(c,cnt);\\n                } else { \\n                    c = 0; k = i;\\n                    if(num2[j] == num1[k]) {\\n                        c++; k++;\\n                        cnt = max(c,cnt);\\n                    } else {\\n                        continue;\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& num1, vector<int>& num2) {\\n        int cnt = 0;\\n        for(int i = 0; i < num2.size(); i++) {\\n            int c = 0, k = i;\\n            for(int j = 0; j < num1.size(); j++) {\\n                if(num1[j] == num2[k]) {\\n                    c++; k++;\\n                    cnt = max(c,cnt);\\n                } else { \\n                    c = 0; k = i;\\n                    if(num1[j] == num2[k]) {\\n                        c++; k++;\\n                        cnt = max(c,cnt);\\n                    } else {\\n                        continue;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i = 0; i < num1.size(); i++) {\\n            int c = 0, k = i;\\n            for(int j = 0; j < num2.size(); j++) {\\n                if(num2[j] == num1[k]) {\\n                    c++; k++;\\n                    cnt = max(c,cnt);\\n                } else { \\n                    c = 0; k = i;\\n                    if(num2[j] == num1[k]) {\\n                        c++; k++;\\n                        cnt = max(c,cnt);\\n                    } else {\\n                        continue;\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325241,
                "title": "c-clean-easy-dynamic-programming-solution",
                "content": "**Solution:**\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int dp[nums1.size() + 1][nums2.size() + 1];\\n        int max_1 = 0;\\n        \\n        for(int i = 0; i <= nums1.size(); i++) {\\n            for(int j = 0; j <= nums2.size(); j++) {\\n                \\n                if(i == 0 or j == 0)\\n                    dp[i][j] = 0;\\n                else {\\n                    if(nums1[i - 1] == nums2[j - 1])\\n                        dp[i][j] = dp[i - 1][j - 1] + 1;\\n                    else\\n                        dp[i][j] = 0;\\n                }\\n                max_1 = max(max_1, dp[i][j]);\\n            }\\n        }\\n        \\n        /*for(int i = 0; i <= nums1.size(); i++){\\n            for(int j = 0; j <= nums2.size(); j++)\\n                cout << dp[i][j] << \" \";\\n            \\n            cout << \"\\\\n\";\\n        }*/\\n      \\n        return max_1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int dp[nums1.size() + 1][nums2.size() + 1];\\n        int max_1 = 0;\\n        \\n        for(int i = 0; i <= nums1.size(); i++) {\\n            for(int j = 0; j <= nums2.size(); j++) {\\n                \\n                if(i == 0 or j == 0)\\n                    dp[i][j] = 0;\\n                else {\\n                    if(nums1[i - 1] == nums2[j - 1])\\n                        dp[i][j] = dp[i - 1][j - 1] + 1;\\n                    else\\n                        dp[i][j] = 0;\\n                }\\n                max_1 = max(max_1, dp[i][j]);\\n            }\\n        }\\n        \\n        /*for(int i = 0; i <= nums1.size(); i++){\\n            for(int j = 0; j <= nums2.size(); j++)\\n                cout << dp[i][j] << \" \";\\n            \\n            cout << \"\\\\n\";\\n        }*/\\n      \\n        return max_1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1324562,
                "title": "maximum-length-of-repeated-subarray-dp-c",
                "content": "This is very common dp problem, It\\'s similar to Longest common subsequence problem\\nor Longest common substring.\\n\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        int dp[n+1][m+1];\\n        \\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                if(i == 0 || j == 0)\\n                    dp[i][j] = 0;\\n                else {\\n                    if(nums1[i-1] == nums2[j-1]) dp[i][j] = dp[i-1][j-1]+1;\\n                    else dp[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        int maxm = INT_MIN;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(maxm < dp[i][j]) maxm = dp[i][j];\\n            }\\n        }\\n        \\n        return maxm;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        int dp[n+1][m+1];\\n        \\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                if(i == 0 || j == 0)\\n                    dp[i][j] = 0;\\n                else {\\n                    if(nums1[i-1] == nums2[j-1]) dp[i][j] = dp[i-1][j-1]+1;\\n                    else dp[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        int maxm = INT_MIN;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(maxm < dp[i][j]) maxm = dp[i][j];\\n            }\\n        }\\n        \\n        return maxm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324490,
                "title": "maximum-length-of-repeated-subarray-simple-dp-longest-common-subarray-java",
                "content": "```\\n public int findLength(int[] nums1, int[] nums2) {\\n        int mx=0;\\n        int t[][] = new int[1001][1001];\\n        int m = nums1.length,n = nums2.length;\\n        \\n        for(int i=1;i<m+1;i++){\\n            for(int j=1;j<n+1;j++){\\n                if(i==0||j==0) t[i][j]=0;\\n                else if(nums1[i-1]==nums2[j-1]) t[i][j] = 1+t[i-1][j-1];\\n                else t[i][j] = 0;\\n                if(t[i][j]>mx) mx=t[i][j];\\n            }\\n        }\\n        return mx;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int findLength(int[] nums1, int[] nums2) {\\n        int mx=0;\\n        int t[][] = new int[1001][1001];\\n        int m = nums1.length,n = nums2.length;\\n        \\n        for(int i=1;i<m+1;i++){\\n            for(int j=1;j<n+1;j++){\\n                if(i==0||j==0) t[i][j]=0;\\n                else if(nums1[i-1]==nums2[j-1]) t[i][j] = 1+t[i-1][j-1];\\n                else t[i][j] = 0;\\n                if(t[i][j]>mx) mx=t[i][j];\\n            }\\n        }\\n        return mx;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1324376,
                "title": "maximum-length-of-repeated-subarray-all-approaches-cpp-c",
                "content": "If you are fully aware of **Longest Common Substring** then this question is a piece of cake for you. But in case if you didn\\'t, Please go and read about that. Now, coming back to the question. The question is **return the maximum length of a subarray that appears in both arrays** or if  i would change the statement slightly **return the maximum length of a substring that appears in both strings**. Now, If you have done **Longest Common Substring** then you will be knowing what I\\'m talking about. Technically, we have to find the **Longest Common Subarray**.\\n\\n**Recursive**\\n```\\nclass Solution {\\npublic:\\n    //Time: O(2^(n+m)), Space: O(n)\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        return helper(nums1, nums2, m, n, 0);\\n    }\\n    \\n    int helper(vector<int>& nums1, vector<int>& nums2, int m, int n, int result){\\n        if(m == 0 || n == 0)\\n            return result;\\n        \\n        if(nums1[m-1] == nums2[n-1])\\n            return result = helper(nums1, nums2, m-1, n-1, result+1);\\n        return max({result, helper(nums1, nums2, m, n-1, 0), helper(nums1, nums2, m-1, n, 0)});\\n    }\\n};\\n```\\n\\n**Recursive + Memoization**\\n```\\nclass Solution {\\npublic:\\n    //Time: O(m*n), Space: O(m*n), without including the recursion stack\\n    int result = 0;\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        vector<vector<int>> memo(m+1, vector<int>(n+1, -1));\\n        helper(nums1, nums2, m, n, memo);\\n        return result;\\n    }\\n    \\n    int helper(vector<int>& nums1, vector<int>& nums2, int m, int n, vector<vector<int>>& memo){\\n        if(m == 0 || n == 0)\\n            return 0;\\n        \\n        if(memo[m][n] != -1) return memo[m][n];\\n        \\n        helper(nums1, nums2, m, n-1, memo);\\n        helper(nums1, nums2, m-1, n, memo);\\n    \\n        if(nums1[m-1] == nums2[n-1]){\\n            memo[m][n] = 1 + helper(nums1, nums2, m-1, n-1, memo);\\n            result = max(result, memo[m][n]);\\n            return memo[m][n];\\n        }\\n        return memo[m][n] = 0;\\n    }\\n};\\n```\\n\\n**Bottom Up Approach**\\n```\\nclass Solution {\\npublic:\\n    //Time: O(m*n), Space: O(m*n), without including the recursion stack\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        int result = 0;\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        \\n        //Initialization\\n        for(int i=0; i<m+1; i++){\\n            for(int j=0; j<n+1; j++){\\n                if(i == 0 || j == 0)\\n                    dp[i][j] = 0;\\n            }\\n        }\\n        \\n        //solving the subproblems\\n        for(int i=1; i<m+1; i++){\\n            for(int j=1; j<n+1; j++){\\n                if(nums1[i-1] == nums2[j-1]){\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                    result = max(result, dp[i][j]);\\n                }\\n                else\\n                    dp[i][j] = 0;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Time: O(2^(n+m)), Space: O(n)\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        return helper(nums1, nums2, m, n, 0);\\n    }\\n    \\n    int helper(vector<int>& nums1, vector<int>& nums2, int m, int n, int result){\\n        if(m == 0 || n == 0)\\n            return result;\\n        \\n        if(nums1[m-1] == nums2[n-1])\\n            return result = helper(nums1, nums2, m-1, n-1, result+1);\\n        return max({result, helper(nums1, nums2, m, n-1, 0), helper(nums1, nums2, m-1, n, 0)});\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //Time: O(m*n), Space: O(m*n), without including the recursion stack\\n    int result = 0;\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        vector<vector<int>> memo(m+1, vector<int>(n+1, -1));\\n        helper(nums1, nums2, m, n, memo);\\n        return result;\\n    }\\n    \\n    int helper(vector<int>& nums1, vector<int>& nums2, int m, int n, vector<vector<int>>& memo){\\n        if(m == 0 || n == 0)\\n            return 0;\\n        \\n        if(memo[m][n] != -1) return memo[m][n];\\n        \\n        helper(nums1, nums2, m, n-1, memo);\\n        helper(nums1, nums2, m-1, n, memo);\\n    \\n        if(nums1[m-1] == nums2[n-1]){\\n            memo[m][n] = 1 + helper(nums1, nums2, m-1, n-1, memo);\\n            result = max(result, memo[m][n]);\\n            return memo[m][n];\\n        }\\n        return memo[m][n] = 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //Time: O(m*n), Space: O(m*n), without including the recursion stack\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        int result = 0;\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        \\n        //Initialization\\n        for(int i=0; i<m+1; i++){\\n            for(int j=0; j<n+1; j++){\\n                if(i == 0 || j == 0)\\n                    dp[i][j] = 0;\\n            }\\n        }\\n        \\n        //solving the subproblems\\n        for(int i=1; i<m+1; i++){\\n            for(int j=1; j<n+1; j++){\\n                if(nums1[i-1] == nums2[j-1]){\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                    result = max(result, dp[i][j]);\\n                }\\n                else\\n                    dp[i][j] = 0;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993057,
                "title": "rolling-hash-c-clean-code",
                "content": "The same idea as  https://leetcode.com/problems/longest-repeating-substring/\\n\\n\\n```\\n    unordered_map<long,int> rolling(vector<int>& S, int k) {\\n        unordered_map<long,int> map0;\\n        long mod = 1000000000007;\\n\\n        long pow = 1;\\n        for (int i = 0; i < k; i++) {\\n            pow = (pow * 101) % mod;\\n        }\\n\\n        long hash0 = 0;\\n\\n        for (int i = 0; i < S.size(); i++) {\\n            // rolling hash\\n            hash0 = (hash0 * 101 + (S[i])) % mod;\\n\\n            if (i >= k) {\\n                // remove previous\\n                hash0 -= (S[i - k]) * pow % mod;\\n                if (hash0 < 0) {\\n                    hash0 = (hash0 + mod) % mod;\\n                }\\n            }\\n\\n            if (i >= k - 1) {\\n                map0[hash0] = i;\\n            }\\n        }\\n        return map0;\\n    }   \\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        auto isValid = [&](int len) {\\n            auto map1 = rolling(A, len);\\n            auto map2 = rolling(B, len);\\n            for (auto [hash1, i] : map1) {\\n                if (map2.count(hash1)) {\\n                    int j = map2[hash1];\\n                    int k;\\n                    for (k = 0; k < len; k++) {\\n                        if (A[i-k] != B[j-k]) break;\\n                    }\\n                    if (k == len) {\\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n        };\\n        \\n        int left = 0, right = min(A.size(), B.size());\\n        while (left < right) {\\n            int mid = left + (right - left + 1) / 2;\\n            if (isValid(mid)) {\\n                left = mid;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return left;\\n    }",
                "solutionTags": [
                    "Rolling Hash",
                    "Binary Tree"
                ],
                "code": "The same idea as  https://leetcode.com/problems/longest-repeating-substring/\\n\\n\\n```\\n    unordered_map<long,int> rolling(vector<int>& S, int k) {\\n        unordered_map<long,int> map0;\\n        long mod = 1000000000007;\\n\\n        long pow = 1;\\n        for (int i = 0; i < k; i++) {\\n            pow = (pow * 101) % mod;\\n        }\\n\\n        long hash0 = 0;\\n\\n        for (int i = 0; i < S.size(); i++) {\\n            // rolling hash\\n            hash0 = (hash0 * 101 + (S[i])) % mod;\\n\\n            if (i >= k) {\\n                // remove previous\\n                hash0 -= (S[i - k]) * pow % mod;\\n                if (hash0 < 0) {\\n                    hash0 = (hash0 + mod) % mod;\\n                }\\n            }\\n\\n            if (i >= k - 1) {\\n                map0[hash0] = i;\\n            }\\n        }\\n        return map0;\\n    }   \\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        auto isValid = [&](int len) {\\n            auto map1 = rolling(A, len);\\n            auto map2 = rolling(B, len);\\n            for (auto [hash1, i] : map1) {\\n                if (map2.count(hash1)) {\\n                    int j = map2[hash1];\\n                    int k;\\n                    for (k = 0; k < len; k++) {\\n                        if (A[i-k] != B[j-k]) break;\\n                    }\\n                    if (k == len) {\\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n        };\\n        \\n        int left = 0, right = min(A.size(), B.size());\\n        while (left < right) {\\n            int mid = left + (right - left + 1) / 2;\\n            if (isValid(mid)) {\\n                left = mid;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return left;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 915316,
                "title": "python3-dp-binary-search",
                "content": "Approach 1 - dp \\nDefine `dp[i][j]` to indicate the length of common prefix subarray for `A[i:]` and `B[j:]`. Then, \\n\\nif `A[i] == B[j]`, `dp[i][j] = 1 + dp[i+1][j+1]`;\\nelse `dp[i][j] = 0`. \\n\\nBoundary condition is that `dp[len(A)][j] = dp[i][len(B)] = 0`. \\n\\nThe bottom-up implementation is given below. The top-down implementation gives TLE. \\ntime complexity `O(N^2)` assuming `len(A) == len(B) == N`\\n\\n(4920ms, 38.21%)\\n```\\nclass Solution:\\n    def findLength(self, A: List[int], B: List[int]) -> int:\\n        m, n = len(A), len(B)\\n        dp = [[0]*(n+1) for _ in range(m+1)] # (m+1) x (n+1)\\n        ans = 0\\n        for i in reversed(range(m)):\\n            for j in reversed(range(n)):\\n                if A[i] == B[j]: dp[i][j] = 1 + dp[i+1][j+1]\\n                ans = max(ans, dp[i][j])\\n        return ans\\n```\\n\\nApproach 2 - binary search \\n\\nThe fact that top-down dp gives TLE already indicates that DP isn\\'t the best approach to solve this problem. In fact, a `Nlog(N)` solution is possible via binary search and rolling hash. \\n\\nDefine `fn(k)` to return `True` if a length `k` common subarray is available for `A` and `B`. Then, binary search could be applied to find the maximum `k`. In addition, rolling hash could be used in `fn(k)` to achieve `O(N)` performance. Overall, the time compleixty becomes `O(NlogN)`. \\n\\n(404ms, 97.95%)\\n```\\nclass Solution:\\n    def findLength(self, A: List[int], B: List[int]) -> int:\\n        \\n        def fn(k): \\n            \"\"\"Return True if a subarray of length k can be found in A and B.\"\"\"\\n            seen = {}\\n            rh = 0 # rolling hash \\n            for i in range(len(A)):\\n                rh = (100*rh + A[i] - (i >= k)*A[i-k]*100**k) % 1_000_000_007\\n                if i >= k-1: seen.setdefault(rh, []).append(i)\\n                    \\n            rh = 0\\n            for i in range(len(B)):\\n                rh = (100*rh + B[i] - (i >= k)*B[i-k]*100**k) % 1_000_000_007\\n                if i >= k-1: \\n                    for ii in seen.get(rh, []): \\n                        if A[ii-k+1:ii+1] == B[i-k+1:i+1]: return True \\n            return False \\n        \\n        # last True binary search \\n        lo, hi = -1, len(A)\\n        while lo < hi: \\n            mid = lo + hi + 1>> 1\\n            if fn(mid): lo = mid\\n            else: hi = mid - 1\\n        return lo \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLength(self, A: List[int], B: List[int]) -> int:\\n        m, n = len(A), len(B)\\n        dp = [[0]*(n+1) for _ in range(m+1)] # (m+1) x (n+1)\\n        ans = 0\\n        for i in reversed(range(m)):\\n            for j in reversed(range(n)):\\n                if A[i] == B[j]: dp[i][j] = 1 + dp[i+1][j+1]\\n                ans = max(ans, dp[i][j])\\n        return ans\\n```\n```\\nclass Solution:\\n    def findLength(self, A: List[int], B: List[int]) -> int:\\n        \\n        def fn(k): \\n            \"\"\"Return True if a subarray of length k can be found in A and B.\"\"\"\\n            seen = {}\\n            rh = 0 # rolling hash \\n            for i in range(len(A)):\\n                rh = (100*rh + A[i] - (i >= k)*A[i-k]*100**k) % 1_000_000_007\\n                if i >= k-1: seen.setdefault(rh, []).append(i)\\n                    \\n            rh = 0\\n            for i in range(len(B)):\\n                rh = (100*rh + B[i] - (i >= k)*B[i-k]*100**k) % 1_000_000_007\\n                if i >= k-1: \\n                    for ii in seen.get(rh, []): \\n                        if A[ii-k+1:ii+1] == B[i-k+1:i+1]: return True \\n            return False \\n        \\n        # last True binary search \\n        lo, hi = -1, len(A)\\n        while lo < hi: \\n            mid = lo + hi + 1>> 1\\n            if fn(mid): lo = mid\\n            else: hi = mid - 1\\n        return lo \\n```",
                "codeTag": "Java"
            },
            {
                "id": 819844,
                "title": "same-as-longest-common-substring-easy-solution",
                "content": "Do upvote if find this solution useful\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        \\n        int m=A.size();\\n        int n=A.size();\\n        int dp[m+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        \\n        int max=INT_MIN;\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(A[i-1]==B[j-1])\\n                {\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else\\n                {\\n                    dp[i][j]=0;\\n                }\\n                \\n                int a=dp[i][j];\\n                if(a>max)\\n                {\\n                    max=a;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        \\n        int m=A.size();\\n        int n=A.size();\\n        int dp[m+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        \\n        int max=INT_MIN;\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(A[i-1]==B[j-1])\\n                {\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 710274,
                "title": "javascript-top-down-approach",
                "content": "```\\nvar findLength = function(A, B) {\\n    // dp[start][end], maximum length of subarray that end at (start, end)\\n    // dp[start][end] = dp[start-1][end-1] + 1 if A[start]=B[end]\\n    const dp = [];\\n    let max = 0;\\n    \\n    const helper = (AEnd, BEnd) => {\\n\\t    // Out of bound, return 0\\n        if (AEnd == -1 || BEnd == -1) return 0;\\n\\t\\t// If not initialized, initialize\\n        if (!dp[AEnd]) dp[AEnd] = [];\\n\\t\\t// It answer saved, directly return\\n        if (dp[AEnd][BEnd]) return dp[AEnd][BEnd];\\n\\t\\t// If end with the same letter, we need to recurse\\n        if (A[AEnd] === B[BEnd]) {\\n            dp[AEnd][BEnd] = helper(AEnd-1,BEnd-1) + 1;\\n        } else {\\n\\t\\t   // If doesn\\'t end with the same letter, then automatically 0\\n            dp[AEnd][BEnd] = 0;\\n        }\\n\\t\\t// Always taking the max\\n        max = Math.max(dp[AEnd][BEnd], max);\\n        return dp[AEnd][BEnd];\\n    }\\n\\t\\n\\t// Iterate though all possible choices of (i, j)\\n    for (let i = 0; i < A.length; i++) {\\n    \\tfor (let j = 0; j < B.length; j++) {\\n            helper(i, j);\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findLength = function(A, B) {\\n    // dp[start][end], maximum length of subarray that end at (start, end)\\n    // dp[start][end] = dp[start-1][end-1] + 1 if A[start]=B[end]\\n    const dp = [];\\n    let max = 0;\\n    \\n    const helper = (AEnd, BEnd) => {\\n\\t    // Out of bound, return 0\\n        if (AEnd == -1 || BEnd == -1) return 0;\\n\\t\\t// If not initialized, initialize\\n        if (!dp[AEnd]) dp[AEnd] = [];\\n\\t\\t// It answer saved, directly return\\n        if (dp[AEnd][BEnd]) return dp[AEnd][BEnd];\\n\\t\\t// If end with the same letter, we need to recurse\\n        if (A[AEnd] === B[BEnd]) {\\n            dp[AEnd][BEnd] = helper(AEnd-1,BEnd-1) + 1;\\n        } else {\\n\\t\\t   // If doesn\\'t end with the same letter, then automatically 0\\n            dp[AEnd][BEnd] = 0;\\n        }\\n\\t\\t// Always taking the max\\n        max = Math.max(dp[AEnd][BEnd], max);\\n        return dp[AEnd][BEnd];\\n    }\\n\\t\\n\\t// Iterate though all possible choices of (i, j)\\n    for (let i = 0; i < A.length; i++) {\\n    \\tfor (let j = 0; j < B.length; j++) {\\n            helper(i, j);\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 658066,
                "title": "python-solution-using-difflib",
                "content": "```\\nfrom difflib import SequenceMatcher\\n\\nclass Solution:\\n    def findLength(self, A: List[int], B: List[int]) -> int:\\n        if set(A).isdisjoint(B): return 0\\n        a, b, size = SequenceMatcher(None, A, B, autojunk=False).find_longest_match(0, len(A), 0, len(B))\\n        return size\\n```\\n\\nExplanation:\\n1. `find_longest_match()` : Find longest matching block in a[a_low : a_high] and b[b_low : b_high]\\n2. It\\'s part of the `class difflib.SequenceMatcher` - which is core standard python library for computing deltas.\\n3. Returns a \\'named tuple\\' - Match(a, b, size). where `size` is the length of the maximum substring.\\nReference: https://docs.python.org/3.1/library/difflib.html#difflib.SequenceMatcher.find_longest_match",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom difflib import SequenceMatcher\\n\\nclass Solution:\\n    def findLength(self, A: List[int], B: List[int]) -> int:\\n        if set(A).isdisjoint(B): return 0\\n        a, b, size = SequenceMatcher(None, A, B, autojunk=False).find_longest_match(0, len(A), 0, len(B))\\n        return size\\n```",
                "codeTag": "Java"
            },
            {
                "id": 637520,
                "title": "c-dp-same-as-longest-common-substring",
                "content": "```\\nint findLength( vector<int>& A, vector<int>& B ) {\\n\\tint m = A.size(), n = B.size();\\n\\n\\t//dp[i][j] is the length of longest common subarray ending with A[i] and B[j]\\n\\tvector<vector<int>> dp( m+1, vector<int>(n+1, 0) );\\n\\tint result = 0;\\n\\tfor( int i=1; i<=m; i++ ) {\\n\\t\\tfor( int j=1; j<=n; j++ ) {\\n\\t\\t\\tif( A[i-1] == B[j-1] ) {\\n\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1] + 1;\\n\\t\\t\\t\\tresult = max( result, dp[i][j] );\\n\\t\\t\\t} else\\n\\t\\t\\t\\tdp[i][j] = 0;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint findLength( vector<int>& A, vector<int>& B ) {\\n\\tint m = A.size(), n = B.size();\\n\\n\\t//dp[i][j] is the length of longest common subarray ending with A[i] and B[j]\\n\\tvector<vector<int>> dp( m+1, vector<int>(n+1, 0) );\\n\\tint result = 0;\\n\\tfor( int i=1; i<=m; i++ ) {\\n\\t\\tfor( int j=1; j<=n; j++ ) {\\n\\t\\t\\tif( A[i-1] == B[j-1] ) {\\n\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1] + 1;\\n\\t\\t\\t\\tresult = max( result, dp[i][j] );\\n\\t\\t\\t} else\\n\\t\\t\\t\\tdp[i][j] = 0;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 602396,
                "title": "c-sliding-window-o-mn-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        int M = A.size();\\n        int N = B.size();\\n        \\n        // i is beginning of string B window\\n        int maxCnt = 0;\\n        for (int offset = -N; offset < M; offset++) {\\n            int aPos = max(offset, 0);\\n            int bPos = aPos - offset;\\n            \\n            int cnt = 0;\\n            // run along string B\\n            while (bPos < N && aPos < M) {\\n                if (A[aPos] == B[bPos]) {\\n                    cnt++;\\n                    maxCnt = max(maxCnt, cnt);\\n                } else {\\n                    cnt = 0;\\n                }\\n                aPos++;\\n                bPos++;\\n            }\\n        }\\n        return maxCnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        int M = A.size();\\n        int N = B.size();\\n        \\n        // i is beginning of string B window\\n        int maxCnt = 0;\\n        for (int offset = -N; offset < M; offset++) {\\n            int aPos = max(offset, 0);\\n            int bPos = aPos - offset;\\n            \\n            int cnt = 0;\\n            // run along string B\\n            while (bPos < N && aPos < M) {\\n                if (A[aPos] == B[bPos]) {\\n                    cnt++;\\n                    maxCnt = max(maxCnt, cnt);\\n                } else {\\n                    cnt = 0;\\n                }\\n                aPos++;\\n                bPos++;\\n            }\\n        }\\n        return maxCnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 555377,
                "title": "binary-search-97-3",
                "content": "```\\nclass Solution:\\n    def findLength(self, A: List[int], B: List[int]) -> int:\\n        l = 0\\n        r = min(len(A),len(B))\\n        \\n        def check(nums1,nums2,k):\\n            temp = set()\\n            for i in range(len(nums1)-k+1):\\n                temp.add(tuple(nums1[i:i+k]))\\n            for j in range(len(nums2)-k+1):\\n                if tuple(nums2[j:j+k]) in temp:\\n                    return True\\n            return False\\n        mid = 0\\n        ans = 0\\n        while l<=r:\\n            mid = l + (r-l)//2\\n            if check(A,B,mid):\\n                ans = mid\\n                l=mid+1\\n            else:\\n                r=mid-1\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLength(self, A: List[int], B: List[int]) -> int:\\n        l = 0\\n        r = min(len(A),len(B))\\n        \\n        def check(nums1,nums2,k):\\n            temp = set()\\n            for i in range(len(nums1)-k+1):\\n                temp.add(tuple(nums1[i:i+k]))\\n            for j in range(len(nums2)-k+1):\\n                if tuple(nums2[j:j+k]) in temp:\\n                    return True\\n            return False\\n        mid = 0\\n        ans = 0\\n        while l<=r:\\n            mid = l + (r-l)//2\\n            if check(A,B,mid):\\n                ans = mid\\n                l=mid+1\\n            else:\\n                r=mid-1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307707,
                "title": "c-27-lines-o-n1-n2-linear-suffix-arrays-longest-common-prefix-lcp-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        if ((A.size() == 0) || (B.size() == 0))     return 0;\\n        \\n        A.push_back(-1); // -1 represents the Unique Sentinel to separate 2 strings \\n        A.insert(A.end(), B.begin(), B.end());\\n        \\n        map<vector<int>, vector<int>> intsToSortedIndexSizeColorMap;\\n        int color = 0;\\n        for (int i=0; i<A.size(); i++) {\\n            if (A[i] == -1)    ++color;\\n            intsToSortedIndexSizeColorMap[vector<int>(A.begin()+i, A.end())] = vector<int>({i, A.size()-1-i, color});\\n        }\\n        \\n        int count = 0;\\n        vector<pair<int,int>> lcpColorPairVec(1, pair<int,int>({0,-1}));\\n        vector<int> prevElem = (*intsToSortedIndexSizeColorMap.begin()).first;\\n        for (const auto & elem : intsToSortedIndexSizeColorMap) {\\n            if (0 == count++)     continue;\\n            int matchCount = 0;\\n            int minSize = (elem.first.size() <= prevElem.size()) ? elem.first.size() : prevElem.size();\\n            while ((matchCount < minSize) && (elem.first[matchCount] == prevElem[matchCount]))   ++matchCount;\\n            lcpColorPairVec.push_back(pair<int,int>{matchCount, elem.second[2]}); \\n            prevElem = elem.first;\\n        }\\n        \\n\\t\\t// This sliding window approach is simplified since only 2 strings(/vector<int>) are used in the argument\\n\\t\\t// but it could be generalized to finding maximum length subarray in k out of n strings where 2<=k<=n\\n        int maxComps = 2, maxSubarrSize = 0;\\n        vector<pair<int,int>> compLCPColorPairVec(1, lcpColorPairVec[0]);\\n        for (int i=1; i<lcpColorPairVec.size(); i++) {\\n            compLCPColorPairVec.push_back(lcpColorPairVec[i]);\\n            if (lcpColorPairVec[i].second == lcpColorPairVec[i-1].second)   continue;\\n            \\n\\t\\t\\twhile ((compLCPColorPairVec.size()>maxComps) && (compLCPColorPairVec[1].second == compLCPColorPairVec[0].second))\\n                compLCPColorPairVec.erase(compLCPColorPairVec.begin());\\n            \\n\\t\\t\\tif (maxSubarrSize < compLCPColorPairVec[1].first)   maxSubarrSize = compLCPColorPairVec[1].first;\\n            compLCPColorPairVec.erase(compLCPColorPairVec.begin());\\n        }\\n        \\n        return maxSubarrSize;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        if ((A.size() == 0) || (B.size() == 0))     return 0;\\n        \\n        A.push_back(-1); // -1 represents the Unique Sentinel to separate 2 strings \\n        A.insert(A.end(), B.begin(), B.end());\\n        \\n        map<vector<int>, vector<int>> intsToSortedIndexSizeColorMap;\\n        int color = 0;\\n        for (int i=0; i<A.size(); i++) {\\n            if (A[i] == -1)    ++color;\\n            intsToSortedIndexSizeColorMap[vector<int>(A.begin()+i, A.end())] = vector<int>({i, A.size()-1-i, color});\\n        }\\n        \\n        int count = 0;\\n        vector<pair<int,int>> lcpColorPairVec(1, pair<int,int>({0,-1}));\\n        vector<int> prevElem = (*intsToSortedIndexSizeColorMap.begin()).first;\\n        for (const auto & elem : intsToSortedIndexSizeColorMap) {\\n            if (0 == count++)     continue;\\n            int matchCount = 0;\\n            int minSize = (elem.first.size() <= prevElem.size()) ? elem.first.size() : prevElem.size();\\n            while ((matchCount < minSize) && (elem.first[matchCount] == prevElem[matchCount]))   ++matchCount;\\n            lcpColorPairVec.push_back(pair<int,int>{matchCount, elem.second[2]}); \\n            prevElem = elem.first;\\n        }\\n        \\n\\t\\t// This sliding window approach is simplified since only 2 strings(/vector<int>) are used in the argument\\n\\t\\t// but it could be generalized to finding maximum length subarray in k out of n strings where 2<=k<=n\\n        int maxComps = 2, maxSubarrSize = 0;\\n        vector<pair<int,int>> compLCPColorPairVec(1, lcpColorPairVec[0]);\\n        for (int i=1; i<lcpColorPairVec.size(); i++) {\\n            compLCPColorPairVec.push_back(lcpColorPairVec[i]);\\n            if (lcpColorPairVec[i].second == lcpColorPairVec[i-1].second)   continue;\\n            \\n\\t\\t\\twhile ((compLCPColorPairVec.size()>maxComps) && (compLCPColorPairVec[1].second == compLCPColorPairVec[0].second))\\n                compLCPColorPairVec.erase(compLCPColorPairVec.begin());\\n            \\n\\t\\t\\tif (maxSubarrSize < compLCPColorPairVec[1].first)   maxSubarrSize = compLCPColorPairVec[1].first;\\n            compLCPColorPairVec.erase(compLCPColorPairVec.begin());\\n        }\\n        \\n        return maxSubarrSize;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 271449,
                "title": "c-o-1-space-beats-98",
                "content": "This method uses two nested loops to solve. Essentially, think of it as displacemnt of letters comparison. Initially, we have word A[0,...,n-1] and B[0,...,m-1].\\n\\nThe first for-loop compares word A at index 0 with the entire string of B[0,...,m-1], then proceed to A at index 1 with the entire string of B[0,...,m-1]. The two conditions of the inner loop is to prevent going out of bounds. \\n\\nSimilarly, the second nested loop serves the same purpose but for string B at index 0... all the way to m-1.\\n\\nMy first giving-back-to-Leetcode post :)\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        int n = A.size(), m = B.size();\\n        \\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            int temp = 0;\\n            for (int j = i, k = 0; k < m && j < n; j++, k++) {\\n                if (A[j] == B[k]) {\\n                    temp++;\\n                    res = max(temp, res);\\n                } else {\\n                    temp = 0;\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            int temp = 0;\\n            for (int j = i, k = 0; k < n && j < m; j++, k++) {\\n                if (B[j] == A[k]) {\\n                    temp++;\\n                    res = max(temp, res);\\n                } else {\\n                    temp = 0;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        int n = A.size(), m = B.size();\\n        \\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            int temp = 0;\\n            for (int j = i, k = 0; k < m && j < n; j++, k++) {\\n                if (A[j] == B[k]) {\\n                    temp++;\\n                    res = max(temp, res);\\n                } else {\\n                    temp = 0;\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            int temp = 0;\\n            for (int j = i, k = 0; k < n && j < m; j++, k++) {\\n                if (B[j] == A[k]) {\\n                    temp++;\\n                    res = max(temp, res);\\n                } else {\\n                    temp = 0;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 261197,
                "title": "simple-solution-using-hashmap",
                "content": "**1** This soultion firstly travesel the short array and get their number index, because the max_len is never could be longer than any len of A or B. \\n**2** After get the short array A\\'s number index map, we can start traverse the array B from start i, and any index with the same value of B[i] in array A can be easily get from A index map.\\n**3** Using a inner loop to check the similar subarry in A and B, mark the max_len.\\n\\n```\\nclass Solution {\\n    public int findLength(int[] A, int[] B) {\\n        if(A.length > B.length) return findLength(B,A);\\n        if(A.length == 0) return 0;\\n        int max_len = 0;\\n        \\n        HashMap<Integer,List<Integer>> map =new HashMap<Integer, List<Integer>>();\\n        for(int i=0;i<A.length;i++){\\n            if(!map.containsKey(A[i])){\\n                map.put(A[i],new LinkedList<>());\\n            }\\n            map.get(A[i]).add(i);\\n        }\\n        for(int j=0;j<B.length;j++){\\n            int cur = B[j];\\n            if(!map.containsKey(cur)) continue;\\n            \\n            for(Integer k:map.get(cur)){\\n                int startA=k, startB=j;\\n                if(A.length-startA <= max_len || B.length-startB <= max_len) continue;\\n                \\n                while(startA <A.length && startB < B.length && A[startA] == B[startB]){\\n                    startA++;\\n                    startB++;\\n                }\\n                max_len = Math.max(startA-k,max_len);\\n            }\\n        }\\n        return max_len;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findLength(int[] A, int[] B) {\\n        if(A.length > B.length) return findLength(B,A);\\n        if(A.length == 0) return 0;\\n        int max_len = 0;\\n        \\n        HashMap<Integer,List<Integer>> map =new HashMap<Integer, List<Integer>>();\\n        for(int i=0;i<A.length;i++){\\n            if(!map.containsKey(A[i])){\\n                map.put(A[i],new LinkedList<>());\\n            }\\n            map.get(A[i]).add(i);\\n        }\\n        for(int j=0;j<B.length;j++){\\n            int cur = B[j];\\n            if(!map.containsKey(cur)) continue;\\n            \\n            for(Integer k:map.get(cur)){\\n                int startA=k, startB=j;\\n                if(A.length-startA <= max_len || B.length-startB <= max_len) continue;\\n                \\n                while(startA <A.length && startB < B.length && A[startA] == B[startB]){\\n                    startA++;\\n                    startB++;\\n                }\\n                max_len = Math.max(startA-k,max_len);\\n            }\\n        }\\n        return max_len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241166,
                "title": "javascript-solution",
                "content": "```\\nvar findLength = function(A, B) {\\n    const rows = A.length\\n    const cols = B.length\\n    \\n    const dp = Array(rows + 1).fill().map(() => Array(cols).fill(0))\\n    let max = 0\\n    \\n    for (let i = 1; i <= rows; i++) {\\n        for (let j = 1; j <= cols; j++) {\\n            if (A[i - 1] === B[j - 1]) {\\n                dp[i][j] = dp[i - 1][j - 1] + 1\\n                max = Math.max(max, dp[i][j])\\n            }\\n        }\\n    }\\n    \\n    return max\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findLength = function(A, B) {\\n    const rows = A.length\\n    const cols = B.length\\n    \\n    const dp = Array(rows + 1).fill().map(() => Array(cols).fill(0))\\n    let max = 0\\n    \\n    for (let i = 1; i <= rows; i++) {\\n        for (let j = 1; j <= cols; j++) {\\n            if (A[i - 1] === B[j - 1]) {\\n                dp[i][j] = dp[i - 1][j - 1] + 1\\n                max = Math.max(max, dp[i][j])\\n            }\\n        }\\n    }\\n    \\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 109049,
                "title": "c-dp-solution-with-space-optimized",
                "content": "For the regular DP solution, we'd need a 2D array of size m*n where m is the size of array A and n is the size of array B. However, when I had code like this:\\n```\\nvector<vector<int>> dp (m+1, vector<int> (n+1, 0));\\n```\\nI got an `Memory Limit Exceeded ` error, I suppose it's because for some test cases, this caused stack to overflow. This problem can be addressed by allocating the 2D array on heap instead of stack:\\n```\\nauto dp_ptr = new vector<vector<int>>(m+1, vector<int> (n+1, 0));\\nauto dp = *dp_ptr;\\n```\\n\\nHowever, for this problem, we don't have to use a 2D array actually. A 1D array is good enough since we only need to find out the maximum length of the repeated subarray of A and B. Here is how: we just need to pick an array of shorter length, say n < m, so B is shorter, then allocating a 1D array:\\n```\\nvector<int> dp (n+1, 0);\\n```\\nFor any `i` where `0 < i < m`, `dp[j]` means the maximum length of repeated subarray ends at A[i] and B[j-1]. So `dp[j] = 0` if `A[i] != B[j-1]` and `dp[j] = 1 + dp[j-1]` if `A[i] == B[j-1]`, note here `dp[j-1]` means the maximum length of repeated subarray ends at A[i-1] and B[j-2], it was computed when i was i - 1.\\n\\nBelow is the full code:\\n```\\nclass Solution3 {\\nprivate:\\n  // A.size >= B.size\\n  int _findLength(vector<int>& A, vector<int>& B) {\\n    int m = A.size();\\n    int n = B.size();\\n    int max_len = 0;\\n\\n    vector<int> dp (n+1, 0);\\n    for (int i = 0; i < m; ++i) {\\n      for (int j = n; j >= 1; --j) {\\n        if (B[j-1] == A[i]) dp[j] = 1 + dp[j-1]; \\n        else dp[j] = 0;\\n        max_len = max(max_len, dp[j]);\\n      }\\n    }\\n\\n    return max_len;\\n  }\\n\\npublic:\\n  int findLength(vector<int>& A, vector<int>& B) {\\n    int max_len;\\n\\n    if (B.size() <= A.size()) {\\n      max_len =_findLength(A, B);\\n    } else {\\n      max_len =_findLength(B, A);\\n    }\\n\\n    return max_len;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nvector<vector<int>> dp (m+1, vector<int> (n+1, 0));\\n```\n```\\nauto dp_ptr = new vector<vector<int>>(m+1, vector<int> (n+1, 0));\\nauto dp = *dp_ptr;\\n```\n```\\nvector<int> dp (n+1, 0);\\n```\n```\\nclass Solution3 {\\nprivate:\\n  // A.size >= B.size\\n  int _findLength(vector<int>& A, vector<int>& B) {\\n    int m = A.size();\\n    int n = B.size();\\n    int max_len = 0;\\n\\n    vector<int> dp (n+1, 0);\\n    for (int i = 0; i < m; ++i) {\\n      for (int j = n; j >= 1; --j) {\\n        if (B[j-1] == A[i]) dp[j] = 1 + dp[j-1]; \\n        else dp[j] = 0;\\n        max_len = max(max_len, dp[j]);\\n      }\\n    }\\n\\n    return max_len;\\n  }\\n\\npublic:\\n  int findLength(vector<int>& A, vector<int>& B) {\\n    int max_len;\\n\\n    if (B.size() <= A.size()) {\\n      max_len =_findLength(A, B);\\n    } else {\\n      max_len =_findLength(B, A);\\n    }\\n\\n    return max_len;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109050,
                "title": "unexpected-memory-limit-exceeded-possible-leetcode-bug",
                "content": "During the contest, I had to code this question twice, because my first attempt got memory limit exceeded. After the contest, I saw similar solutions to my MLE solution got accepted! Here is the solution that gets MLE:\\n\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        vector<vector<int>> DP(1001, vector<int>(1001));\\n        int ans = 0;\\n        for (int i = A.size()-1; i >= 0; --i) {\\n        \\tfor (int j = 0; j < B.size(); ++j) {\\n        \\t\\tif (A[i] == B[j]) {\\n        \\t\\t\\tDP[i][j] = DP[i+1][j+1]+1;\\n                    ans = max(ans, DP[i][j]);\\n        \\t\\t}\\n        \\t}\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nI want to point out that this appears to be a faithful, idomatic C++ translation of the intended solution. So it is unfair that it should MLE.\\n\\nIf I replace vectors with static arrays, or dynamically allocated arrays, it passes. It is ONLY vectors that fail. Can anyone explain this? Is it a problem with leetcode? Running on my machine, I cannot find a case that causes much more memory usage than with other methods, including the breaking case that gets MLE on leetcode. They all use < 8MB on my machine.\\n\\nThis equivalent code passes:\\n\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        int DP[1001][1001];\\n        for (int i = 0; i <= A.size(); ++i) {\\n            for (int j = 0; j <= B.size(); ++j) {\\n                DP[i][j] = 0;\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = A.size()-1; i >= 0; --i) {\\n        \\tfor (int j = 0; j < B.size(); ++j) {\\n        \\t\\tif (A[i] == B[j]) {\\n        \\t\\t\\tDP[i][j] = DP[i+1][j+1]+1;\\n                    ans = max(ans, DP[i][j]);\\n        \\t\\t}\\n        \\t}\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nUPDATE:\\n\\nI have done some more testing, and I definitely think something strange is going on with LeetCode. The code below passes. Also, running the MLE test case on my machine using this code (compiled under G++ 6.3.0 in Ubuntu 17.04) only uses around 6616 KB at peak memory usage, while the accepted code uses around 7192 KB, which is more! Both are still very small, however.\\n\\nI also experimented using the MLE and the accepted code below with the MLE test case from LeetCode, and running the test case 100 times. I was thinking perhaps something odd is going on with the vector destructor in the STL. However, this produced the exactly same peak memory as before.\\n\\nThus, I make the tentative claim that this is a bug in LeetCode's system.\\n\\n```\\nvector<vector<int>> DP(1001, vector<int>(1001));\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        for (int i = 0; i < A.size()+1; ++i) {\\n            for (int j = 0; j < B.size()+1; ++j) {\\n                DP[i][j] = 0;\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = A.size()-1; i >= 0; --i) {\\n        \\tfor (int j = 0; j < B.size(); ++j) {\\n        \\t\\tif (A[i] == B[j]) {\\n        \\t\\t\\tDP[i][j] = DP[i+1][j+1]+1;\\n                    ans = max(ans, DP[i][j]);\\n        \\t\\t}\\n        \\t}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        vector<vector<int>> DP(1001, vector<int>(1001));\\n        int ans = 0;\\n        for (int i = A.size()-1; i >= 0; --i) {\\n        \\tfor (int j = 0; j < B.size(); ++j) {\\n        \\t\\tif (A[i] == B[j]) {\\n        \\t\\t\\tDP[i][j] = DP[i+1][j+1]+1;\\n                    ans = max(ans, DP[i][j]);\\n        \\t\\t}\\n        \\t}\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        int DP[1001][1001];\\n        for (int i = 0; i <= A.size(); ++i) {\\n            for (int j = 0; j <= B.size(); ++j) {\\n                DP[i][j] = 0;\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = A.size()-1; i >= 0; --i) {\\n        \\tfor (int j = 0; j < B.size(); ++j) {\\n        \\t\\tif (A[i] == B[j]) {\\n        \\t\\t\\tDP[i][j] = DP[i+1][j+1]+1;\\n                    ans = max(ans, DP[i][j]);\\n        \\t\\t}\\n        \\t}\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nvector<vector<int>> DP(1001, vector<int>(1001));\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& A, vector<int>& B) {\\n        for (int i = 0; i < A.size()+1; ++i) {\\n            for (int j = 0; j < B.size()+1; ++j) {\\n                DP[i][j] = 0;\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = A.size()-1; i >= 0; --i) {\\n        \\tfor (int j = 0; j < B.size(); ++j) {\\n        \\t\\tif (A[i] == B[j]) {\\n        \\t\\t\\tDP[i][j] = DP[i+1][j+1]+1;\\n                    ans = max(ans, DP[i][j]);\\n        \\t\\t}\\n        \\t}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747529,
                "title": "recursion-momoization-tabulation-optimization-dp-c",
                "content": "# 1. Naive Recursive approach (TLE)\\n### Time Complexity: O(m * n * (m + n))\\nThe code consists of two nested loops: one for loop iterating over i from 1 to m, and another nested loop iterating over j from 1 to n. Inside these loops, the function f is called, which has a time complexity of O(m+n) in the worst case, where m and n are the sizes of nums1 and nums2 respectively.\\nTherefore, the overall time complexity of the code is O(m * n * (m + n)).\\n### Space Complexity: O(m + n)\\nThe space complexity of the code is determined by the stack space used for recursive calls to the f function. In the worst case, the recursion depth can be up to m + n, as the function is called recursively with m-1 and n-1 in each iteration.\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& nums1, vector<int>& nums2, int m, int n){\\n        if(m==0 || n==0) return 0;\\n        if(nums1[m-1]==nums2[n-1]){\\n            return 1+f(nums1, nums2, m-1, n-1);\\n        }\\n        return 0;\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m=nums1.size();\\n        int n=nums2.size();\\n        int ans=0;\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                int res= f(nums1, nums2, i, j);\\n                ans=max(ans, res);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n\\n# 2. Memoization(DP)\\n### Time Complexity: O(m * n)\\nThe time complexity of the code is determined by the nested loops iterating over i and j, which run from 1 to m and n respectively. Inside these loops, the function f is called, which has a time complexity of O(1) for each unique combination of m and n due to the use of the dp table.\\nTherefore, the overall time complexity of the code is O(m * n), significantly better than the previous implementation.\\n### Space Complexity: O(m * n)\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& nums1, vector<int>& nums2, int m, int n, vector<vector<int>>&dp){\\n        if(m==0 || n==0) return dp[m][n]=0;\\n        if(dp[m][n]!=-1) return dp[m][n];\\n        if(nums1[m-1]==nums2[n-1]){\\n            return dp[m][n]=1+f(nums1, nums2, m-1, n-1, dp);\\n        }\\n        return dp[m][n]= 0;\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m=nums1.size();\\n        int n=nums2.size();\\n        int ans=0;\\n        vector<vector<int>>dp(m+1, vector<int>(n+1, -1));\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                int res= f(nums1, nums2, i, j, dp);\\n                ans=max(ans, res);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n---\\n\\n\\n# 3. Tabulation(DP)\\n- Time complexity: O(m*n)\\n- Space complexity: O(m*n)\\n\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m=nums1.size();\\n        int n=nums2.size();\\n        int ans=0;\\n        vector<vector<int>>dp(m+1, vector<int>(n+1, 0));\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(nums1[i-1]==nums2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                    ans=max(ans, dp[i][j]);\\n                }\\n                else dp[i][j]=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n# 4. Optimized Space (BEST Approach)\\n- Time complexity: O(m*n)\\n- Space complexity: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n     int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m=nums1.size();\\n        int n=nums2.size();\\n        int ans=0;\\n        int temp=0, temp2=0;\\n        vector<int>dp(n+1, 0);\\n        for(int i=1;i<=m;i++){\\n            temp2=dp[0];\\n            for(int j=1;j<=n;j++){\\n                temp=dp[j];\\n                if(nums1[i-1]==nums2[j-1]){\\n                    dp[j]=1+temp2;\\n                    ans=max(ans, dp[j]);\\n                }\\n                else dp[j]=0;\\n                temp2=temp;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<int>& nums1, vector<int>& nums2, int m, int n){\\n        if(m==0 || n==0) return 0;\\n        if(nums1[m-1]==nums2[n-1]){\\n            return 1+f(nums1, nums2, m-1, n-1);\\n        }\\n        return 0;\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m=nums1.size();\\n        int n=nums2.size();\\n        int ans=0;\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                int res= f(nums1, nums2, i, j);\\n                ans=max(ans, res);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& nums1, vector<int>& nums2, int m, int n, vector<vector<int>>&dp){\\n        if(m==0 || n==0) return dp[m][n]=0;\\n        if(dp[m][n]!=-1) return dp[m][n];\\n        if(nums1[m-1]==nums2[n-1]){\\n            return dp[m][n]=1+f(nums1, nums2, m-1, n-1, dp);\\n        }\\n        return dp[m][n]= 0;\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m=nums1.size();\\n        int n=nums2.size();\\n        int ans=0;\\n        vector<vector<int>>dp(m+1, vector<int>(n+1, -1));\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                int res= f(nums1, nums2, i, j, dp);\\n                ans=max(ans, res);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m=nums1.size();\\n        int n=nums2.size();\\n        int ans=0;\\n        vector<vector<int>>dp(m+1, vector<int>(n+1, 0));\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(nums1[i-1]==nums2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                    ans=max(ans, dp[i][j]);\\n                }\\n                else dp[i][j]=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n     int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m=nums1.size();\\n        int n=nums2.size();\\n        int ans=0;\\n        int temp=0, temp2=0;\\n        vector<int>dp(n+1, 0);\\n        for(int i=1;i<=m;i++){\\n            temp2=dp[0];\\n            for(int j=1;j<=n;j++){\\n                temp=dp[j];\\n                if(nums1[i-1]==nums2[j-1]){\\n                    dp[j]=1+temp2;\\n                    ans=max(ans, dp[j]);\\n                }\\n                else dp[j]=0;\\n                temp2=temp;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745741,
                "title": "recursive-memoization-tabulation-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n## Recursive Approach\\n\\n### Complexity\\n-  The time complexity can be expressed as O(2^(m+n)), where m and n are the lengths of nums1 and nums2 respectively. This is because, in the worst case, the function explores all possible combinations of elements from both arrays.\\n- There can be a maximum of m+n recursive calls in the worst case, the space complexity is O(m+n). This is because the function will keep making recursive calls until either m or n reaches zero.\\n\\n#### TLE\\n\\n### Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(vector<int>& nums1, vector<int>& nums2, int m, int n, int len) {\\n        if(n == 0 || m == 0) return len;\\n        if(nums1[m-1] == nums2[n-1])\\n            len = solve(nums1, nums2, m-1, n-1, len+1);\\n        int len1 = max(solve(nums1, nums2, m-1, n, 0), solve(nums1, nums2, m, n-1, 0));\\n        len = max(len, len1);\\n        return len;\\n\\n    }\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size(), n = nums2.size();\\n        return solve(nums1, nums2, m, n, 0);   \\n    }\\n};\\n```\\n\\n\\n# Recursive + memoization\\n\\n## Complexity\\n- The memoization technique ensures that each subproblem is calculated only once and stored in the DP table. Therefore, the time complexity is improved to O(m * n). This is because the function explores all possible combinations of elements from both arrays once and fills the dp table.\\n- The code creates a 2D DP table with dimensions (m+1) x (n+1) to store the results of subproblems. Therefore, the space complexity is O(m * n). Additionally, the recursion stack uses space for the maximum depth of recursive calls, which can be at most O(m + n) in the worst case.\\n\\n\\n### code\\n```\\nclass Solution {\\nprivate:\\n    int solve(vector<int>& nums1, vector<int>& nums2, int m, int n, int &maxlen, vector<vector<int>> &dp) {\\n        if(n == 0 || m == 0) return 0;\\n        if(dp[m][n] != -1) return dp[m][n];\\n        int len = 0;\\n        if(nums1[m-1] == nums2[n-1])\\n            len = 1 + solve(nums1, nums2, m-1, n-1, maxlen, dp);\\n        maxlen = max(len, maxlen);\\n        solve(nums1, nums2, m-1, n, maxlen, dp); \\n        solve(nums1, nums2, m, n-1, maxlen, dp);\\n        return dp[m][n] = len;\\n\\n    }\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size(), n = nums2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, -1));\\n        int maxlen = 0;\\n        solve(nums1, nums2, m, n, maxlen, dp);\\n        return maxlen;\\n    }\\n};\\n```\\n# Dp\\n## Complexity\\n- The nested loops iterate over each element of nums1 and nums2, resulting in a time complexity of O(m * n), where m and n are the lengths of nums1 and nums2 respectively. This is because the code needs to compare each pair of elements once.\\n- The space complexity is O(m * n) since it depends on the sizes of nums1 and nums2.\\n### code\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size(), n = nums2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        for(int i=1; i<=m; i++) {\\n            for(int j=1; j<=n; j++) {\\n                if(nums1[i-1] == nums2[j-1])\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n            }\\n        }\\n        int ans=0;\\n        for(int i=1; i<=m; i++) {\\n            for(int j=1; j<=n; j++) {\\n                ans = max(ans, dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Happy Coding \\uD83D\\uDE80",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(vector<int>& nums1, vector<int>& nums2, int m, int n, int len) {\\n        if(n == 0 || m == 0) return len;\\n        if(nums1[m-1] == nums2[n-1])\\n            len = solve(nums1, nums2, m-1, n-1, len+1);\\n        int len1 = max(solve(nums1, nums2, m-1, n, 0), solve(nums1, nums2, m, n-1, 0));\\n        len = max(len, len1);\\n        return len;\\n\\n    }\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size(), n = nums2.size();\\n        return solve(nums1, nums2, m, n, 0);   \\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(vector<int>& nums1, vector<int>& nums2, int m, int n, int &maxlen, vector<vector<int>> &dp) {\\n        if(n == 0 || m == 0) return 0;\\n        if(dp[m][n] != -1) return dp[m][n];\\n        int len = 0;\\n        if(nums1[m-1] == nums2[n-1])\\n            len = 1 + solve(nums1, nums2, m-1, n-1, maxlen, dp);\\n        maxlen = max(len, maxlen);\\n        solve(nums1, nums2, m-1, n, maxlen, dp); \\n        solve(nums1, nums2, m, n-1, maxlen, dp);\\n        return dp[m][n] = len;\\n\\n    }\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size(), n = nums2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, -1));\\n        int maxlen = 0;\\n        solve(nums1, nums2, m, n, maxlen, dp);\\n        return maxlen;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size(), n = nums2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        for(int i=1; i<=m; i++) {\\n            for(int j=1; j<=n; j++) {\\n                if(nums1[i-1] == nums2[j-1])\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n            }\\n        }\\n        int ans=0;\\n        for(int i=1; i<=m; i++) {\\n            for(int j=1; j<=n; j++) {\\n                ans = max(ans, dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355708,
                "title": "memoization-tabulation-dp-c",
                "content": "# Memoization\\n```\\nclass Solution {\\n    int ans = 0;\\n    int dfs(int i, int j, int n, int m, vector<int> &nums1, vector<int> &nums2, vector<vector<int>> &dp) {\\n        if(i == n || j == m) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        dfs(i + 1, j, n, m, nums1, nums2, dp);\\n        dfs(i, j + 1, n, m, nums1, nums2, dp);\\n\\n        dp[i][j] = nums1[i] == nums2[j] ? 1 + dfs(i + 1, j + 1, n, m, nums1, nums2, dp) : 0;\\n        ans = max(ans, dp[i][j]);\\n        return dp[i][j];\\n    }\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        dfs(0, 0, n, m, nums1, nums2, dp);\\n        return ans;\\n    }\\n};\\n```\\n\\n# Tanulation\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size(), ans = 0;\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            for(int j=m-1; j>=0; j--) {\\n                dp[i][j] = nums1[i] == nums2[j] ? 1 + dp[i + 1][j + 1] : 0;\\n                ans = max(ans, dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    int dfs(int i, int j, int n, int m, vector<int> &nums1, vector<int> &nums2, vector<vector<int>> &dp) {\\n        if(i == n || j == m) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        dfs(i + 1, j, n, m, nums1, nums2, dp);\\n        dfs(i, j + 1, n, m, nums1, nums2, dp);\\n\\n        dp[i][j] = nums1[i] == nums2[j] ? 1 + dfs(i + 1, j + 1, n, m, nums1, nums2, dp) : 0;\\n        ans = max(ans, dp[i][j]);\\n        return dp[i][j];\\n    }\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        dfs(0, 0, n, m, nums1, nums2, dp);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size(), ans = 0;\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            for(int j=m-1; j>=0; j--) {\\n                dp[i][j] = nums1[i] == nums2[j] ? 1 + dp[i + 1][j + 1] : 0;\\n                ans = max(ans, dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320257,
                "title": "c-approach-recursion-memoization",
                "content": "# Approach\\n\\nWe are checking an element of s1 with an element of s2 , if they are equal then we are calling the same function just by reducing one index.\\n```\\nint val = 0;\\nif(s1[i] == s2[j]){\\n    val = 1 + lcs(s1,s2,i-1,j-1,maxVal);\\n}\\n```\\nWe are using a variable \\'maxVal\\' which keeps track of the **maximum length substring among all function calls** , so when ever we found an equality , maxVal is updated.\\n```\\nmaxVal = max(maxVal , val)\\n```\\n\\nand we will call\\n```\\n    lcs(s1,s2,i-1,j,maxVal);\\n    lcs(s1,s2,i,j-1,maxVal);\\n```\\nto generate all possible cases of substrings and updating the value of maxVal in all those cases , and finally maxVal will be our **answer**.\\n\\nThese two function calls are **not dependent** on whether the elements match or not.\\n\\n---\\n\\n\\n# Complexity of Recursion\\n- Time complexity : O(3^(M) * 3^(N))\\n(basically exponential in nature)\\n\\n- Space complexity: O(M + N)\\n\\n# Complexity of Memoization\\n- Time complexity : O(M * N)\\n\\n- Space complexity: O(M * N) + O(M + N)\\n\\n---\\n\\n\\n# Recursion Code\\n```\\nint lcs(vector<int>& s1 , vector<int>& s2 , int i , int j , int& maxVal)\\n{\\n    if(i<0 || j<0){\\n        return 0;\\n    }\\n    int val = 0;\\n    if(s1[i] == s2[j]){\\n        val = 1 + lcs(s1,s2,i-1,j-1,maxVal);\\n        maxVal = max(maxVal , val);\\n    }\\n\\n    lcs(s1,s2,i-1,j,maxVal);\\n    lcs(s1,s2,i,j-1,maxVal);\\n\\n    return val;\\n}\\nint findLength(vector<int>& s1 , vector<int>& s2)\\n{\\n    int maxVal = 0;\\n    int m = s1.size();\\n    int n = s2.size();\\n\\n    lcs(s1,s2,m-1,n-1,maxVal);\\n\\n    return maxVal;\\n}\\n\\n```\\n\\n---\\n\\n\\n# Memoization Code\\n``` \\nclass Solution {\\npublic:\\n    int lcs(vector<int>& s1 , vector<int>& s2 , vector<vector<int>>& dp , int i , int j , int& maxVal)\\n    {\\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        int val = 0;\\n        if(s1[i] == s2[j]){\\n            val = 1 + lcs(s1,s2,dp,i-1,j-1,maxVal);\\n        }\\n        maxVal = max(maxVal , val);\\n\\n        lcs(s1,s2,dp,i-1,j,maxVal);\\n        lcs(s1,s2,dp,i,j-1,maxVal);\\n\\n        return dp[i][j] = val;\\n    }\\n    int findLength(vector<int>& s1 , vector<int>& s2)\\n    {\\n        int maxVal = 0;\\n        int m = s1.size();\\n        int n = s2.size();\\n\\n        vector<vector<int>> dp(m , vector<int>(n , -1));\\n        lcs(s1,s2,dp,m-1,n-1,maxVal);\\n\\n        return maxVal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint val = 0;\\nif(s1[i] == s2[j]){\\n    val = 1 + lcs(s1,s2,i-1,j-1,maxVal);\\n}\\n```\n```\\nmaxVal = max(maxVal , val)\\n```\n```\\n    lcs(s1,s2,i-1,j,maxVal);\\n    lcs(s1,s2,i,j-1,maxVal);\\n```\n```\\nint lcs(vector<int>& s1 , vector<int>& s2 , int i , int j , int& maxVal)\\n{\\n    if(i<0 || j<0){\\n        return 0;\\n    }\\n    int val = 0;\\n    if(s1[i] == s2[j]){\\n        val = 1 + lcs(s1,s2,i-1,j-1,maxVal);\\n        maxVal = max(maxVal , val);\\n    }\\n\\n    lcs(s1,s2,i-1,j,maxVal);\\n    lcs(s1,s2,i,j-1,maxVal);\\n\\n    return val;\\n}\\nint findLength(vector<int>& s1 , vector<int>& s2)\\n{\\n    int maxVal = 0;\\n    int m = s1.size();\\n    int n = s2.size();\\n\\n    lcs(s1,s2,m-1,n-1,maxVal);\\n\\n    return maxVal;\\n}\\n\\n```\n``` \\nclass Solution {\\npublic:\\n    int lcs(vector<int>& s1 , vector<int>& s2 , vector<vector<int>>& dp , int i , int j , int& maxVal)\\n    {\\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        int val = 0;\\n        if(s1[i] == s2[j]){\\n            val = 1 + lcs(s1,s2,dp,i-1,j-1,maxVal);\\n        }\\n        maxVal = max(maxVal , val);\\n\\n        lcs(s1,s2,dp,i-1,j,maxVal);\\n        lcs(s1,s2,dp,i,j-1,maxVal);\\n\\n        return dp[i][j] = val;\\n    }\\n    int findLength(vector<int>& s1 , vector<int>& s2)\\n    {\\n        int maxVal = 0;\\n        int m = s1.size();\\n        int n = s2.size();\\n\\n        vector<vector<int>> dp(m , vector<int>(n , -1));\\n        lcs(s1,s2,dp,m-1,n-1,maxVal);\\n\\n        return maxVal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246523,
                "title": "lcs-type-implementation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size(), n = nums2.size();\\n        int dp[m+1][n+1];\\n        memset(dp, 0, sizeof(dp));\\n\\n        for(int i = 1; i <= m ;i++){\\n            for(int j = 1; j <= n; j++){\\n                dp[i][j] = (nums1[i-1] == nums2[j-1]) ? 1 + dp[i-1][j-1] : 0;\\n            }\\n        }\\n        vector<int> res;\\n        for(int i = 0; i < m+1; i++){\\n            for(int j = 0; j < n+1; j++){\\n                res.push_back(dp[i][j]);\\n            }\\n        }\\n        return *max_element(res.begin(), res.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size(), n = nums2.size();\\n        int dp[m+1][n+1];\\n        memset(dp, 0, sizeof(dp));\\n\\n        for(int i = 1; i <= m ;i++){\\n            for(int j = 1; j <= n; j++){\\n                dp[i][j] = (nums1[i-1] == nums2[j-1]) ? 1 + dp[i-1][j-1] : 0;\\n            }\\n        }\\n        vector<int> res;\\n        for(int i = 0; i < m+1; i++){\\n            for(int j = 0; j < n+1; j++){\\n                res.push_back(dp[i][j]);\\n            }\\n        }\\n        return *max_element(res.begin(), res.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184117,
                "title": "easy-c-solution-using-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n     int dp[1001][1001];\\n     int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=0;\\n        memset(dp, 0, sizeof(dp));\\n        for(int i=1; i<=nums1.size(); i++) {\\n            for(int j=1; j<=nums2.size(); j++) {\\n                if(nums1[i-1]==nums2[j-1]) {\\n                    dp[i][j]= 1+dp[i-1][j-1];\\n                    ans= max(ans, dp[i][j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int dp[1001][1001];\\n     int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=0;\\n        memset(dp, 0, sizeof(dp));\\n        for(int i=1; i<=nums1.size(); i++) {\\n            for(int j=1; j<=nums2.size(); j++) {\\n                if(nums1[i-1]==nums2[j-1]) {\\n                    dp[i][j]= 1+dp[i-1][j-1];\\n                    ans= max(ans, dp[i][j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637344,
                "title": "python3-solution-using-2d-dp-tabulation-solution",
                "content": "```\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        m = len(nums1)\\n        n = len(nums2)\\n        dp = [[0]*n for _ in range(m)]\\n        maxval = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if nums1[i] == nums2[j]:\\n                    if i > 0 and j >0:\\n                        dp[i][j] = 1+dp[i-1][j-1]\\n                    else:\\n                        dp[i][j] = 1\\n                    maxval = max(maxval,dp[i][j])\\n        return maxval\\n#Please Upvote if you like the solution!!!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        m = len(nums1)\\n        n = len(nums2)\\n        dp = [[0]*n for _ in range(m)]\\n        maxval = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if nums1[i] == nums2[j]:\\n                    if i > 0 and j >0:\\n                        dp[i][j] = 1+dp[i-1][j-1]\\n                    else:\\n                        dp[i][j] = 1\\n                    maxval = max(maxval,dp[i][j])\\n        return maxval\\n#Please Upvote if you like the solution!!!",
                "codeTag": "Java"
            },
            {
                "id": 2604220,
                "title": "recursive-memoized-dp-all-3-approaches-c",
                "content": "Recursive TLE\\n```\\nint solve(vector<int> &nums1, vector<int> &nums2, int n, int m, int cnt){\\n        \\n        if(n==0 || m==0){\\n            return cnt;\\n        }\\n        \\n        if(nums1[n-1]==nums2[m-1]){\\n            cnt = solve(nums1,nums2,n-1,m-1,cnt+1);\\n        }\\n        int cnt1 = solve(nums1,nums2,n,m-1,0);\\n        int cnt2 = solve(nums1,nums2,n-1,m,0);\\n        return max({cnt,cnt1,cnt2});\\n    }\\n    \\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        return solve(nums1,nums2,n,m,0);\\n    }\\n```\\n\\nRecursive 2\\n```\\nint solve(vector<int> &nums1, vector<int> &nums2, int n, int m){\\n        if(n==nums1.size() || m==nums2.size())\\n            return 0;\\n        int len=0;\\n        if(nums1[n]==nums2[m]) len = 1+solve(nums1,nums2,n+1,m+1);\\n        \\n        solve(nums1,nums2,n+1,m);\\n        solve(nums1,nums2,n,m+1);\\n        ans = max(ans,len);\\n        return len;\\n    }\\n    \\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        solve(nums1,nums2,0,0);\\n        return ans;\\n    }\\n```\\n\\nMemoized\\n```\\nint t[1001][1001];\\n    int ans=INT_MIN;\\n    int solve(vector<int> &nums1, vector<int> &nums2, int n, int m){\\n        if(t[n][m]!=-1) return t[n][m];\\n        if(n==nums1.size() || m==nums2.size())\\n            return 0;\\n        int len=0;\\n        if(nums1[n]==nums2[m]) len = 1+solve(nums1,nums2,n+1,m+1);\\n        \\n        solve(nums1,nums2,n+1,m);\\n        solve(nums1,nums2,n,m+1);\\n        ans = max(ans,len);\\n        return t[n][m]=len;\\n    }\\n    \\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        memset(t,-1,sizeof(t));\\n        solve(nums1,nums2,0,0);\\n        return ans;\\n    }\\n```\\nDP\\n```\\n    int t[1001][1001];    \\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 || j==0){\\n                    t[i][j]=0;\\n                }\\n            }\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(nums1[i-1]==nums2[j-1]){\\n                    t[i][j] = 1+t[i-1][j-1];\\n                    ans = max(ans,t[i][j]);\\n                }\\n                else{\\n                    t[i][j]=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint solve(vector<int> &nums1, vector<int> &nums2, int n, int m, int cnt){\\n        \\n        if(n==0 || m==0){\\n            return cnt;\\n        }\\n        \\n        if(nums1[n-1]==nums2[m-1]){\\n            cnt = solve(nums1,nums2,n-1,m-1,cnt+1);\\n        }\\n        int cnt1 = solve(nums1,nums2,n,m-1,0);\\n        int cnt2 = solve(nums1,nums2,n-1,m,0);\\n        return max({cnt,cnt1,cnt2});\\n    }\\n    \\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        return solve(nums1,nums2,n,m,0);\\n    }\\n```\n```\\nint solve(vector<int> &nums1, vector<int> &nums2, int n, int m){\\n        if(n==nums1.size() || m==nums2.size())\\n            return 0;\\n        int len=0;\\n        if(nums1[n]==nums2[m]) len = 1+solve(nums1,nums2,n+1,m+1);\\n        \\n        solve(nums1,nums2,n+1,m);\\n        solve(nums1,nums2,n,m+1);\\n        ans = max(ans,len);\\n        return len;\\n    }\\n    \\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        solve(nums1,nums2,0,0);\\n        return ans;\\n    }\\n```\n```\\nint t[1001][1001];\\n    int ans=INT_MIN;\\n    int solve(vector<int> &nums1, vector<int> &nums2, int n, int m){\\n        if(t[n][m]!=-1) return t[n][m];\\n        if(n==nums1.size() || m==nums2.size())\\n            return 0;\\n        int len=0;\\n        if(nums1[n]==nums2[m]) len = 1+solve(nums1,nums2,n+1,m+1);\\n        \\n        solve(nums1,nums2,n+1,m);\\n        solve(nums1,nums2,n,m+1);\\n        ans = max(ans,len);\\n        return t[n][m]=len;\\n    }\\n    \\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        memset(t,-1,sizeof(t));\\n        solve(nums1,nums2,0,0);\\n        return ans;\\n    }\\n```\n```\\n    int t[1001][1001];    \\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 || j==0){\\n                    t[i][j]=0;\\n                }\\n            }\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(nums1[i-1]==nums2[j-1]){\\n                    t[i][j] = 1+t[i-1][j-1];\\n                    ans = max(ans,t[i][j]);\\n                }\\n                else{\\n                    t[i][j]=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2601456,
                "title": "it-is-longest-common-substring-bro-c",
                "content": "![image](https://assets.leetcode.com/users/images/85590937-e036-4580-bdb7-8a600dc67786_1663682281.819941.png)\\n```\\nclass Solution\\n{\\npublic:\\n    int findLength(vector<int> &n, vector<int> &m)\\n    {\\n        vector<vector<int>> dp = vector<vector<int>>(n.size(), vector<int>(m.size(),0));\\n        int ans = 0;\\n        for (int i = 0; i < n.size(); i++)\\n        {\\n            for (int j = 0; j < m.size(); j++)\\n            {\\n                if (n[i] == m[j])\\n                {\\n                    if (i > 0 && j > 0)\\n                    {\\n                        dp[i][j] = 1 + dp[i - 1][j - 1];\\n                    }\\n                    else\\n                    {\\n                        dp[i][j] = 1;\\n                    }\\n                }\\n                ans = max(ans, dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int findLength(vector<int> &n, vector<int> &m)\\n    {\\n        vector<vector<int>> dp = vector<vector<int>>(n.size(), vector<int>(m.size(),0));\\n        int ans = 0;\\n        for (int i = 0; i < n.size(); i++)\\n        {\\n            for (int j = 0; j < m.size(); j++)\\n            {\\n                if (n[i] == m[j])\\n                {\\n                    if (i > 0 && j > 0)\\n                    {\\n                        dp[i][j] = 1 + dp[i - 1][j - 1];\\n                    }\\n                    else\\n                    {\\n                        dp[i][j] = 1;\\n                    }\\n                }\\n                ans = max(ans, dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601339,
                "title": "java-simple-2d-dp-solution",
                "content": "```\\nclass Solution {\\n   public static int findLength(int[] arr1, int[] arr2) {\\n\\t\\tint m = arr1.length;\\n\\t\\tint n = arr2.length;\\n\\t\\tint[][] dp = new int[m + 1][n + 1];\\n\\t\\tint max = 0;\\n\\t\\tfor (int i = 1; i <= m; i++) {\\n\\t\\t\\tfor (int j = 1; j <= n; j++) {\\n\\t\\t\\t\\tif (arr1[i - 1] == arr2[j - 1]) {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1] + 1;\\n\\t\\t\\t\\t\\tmax = Math.max(max, dp[i][j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public static int findLength(int[] arr1, int[] arr2) {\\n\\t\\tint m = arr1.length;\\n\\t\\tint n = arr2.length;\\n\\t\\tint[][] dp = new int[m + 1][n + 1];\\n\\t\\tint max = 0;\\n\\t\\tfor (int i = 1; i <= m; i++) {\\n\\t\\t\\tfor (int j = 1; j <= n; j++) {\\n\\t\\t\\t\\tif (arr1[i - 1] == arr2[j - 1]) {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1] + 1;\\n\\t\\t\\t\\t\\tmax = Math.max(max, dp[i][j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600869,
                "title": "c-dp-tabulation-max-type-of-longest-common-substring-easy",
                "content": "**Classic Dynamic Programming Problem!!\\nExtended Version of Longest Common Substring!!**\\n\\n* Time Complexity:- O(M*N)\\n* Space Complexity:- O(M*N)\\n\\n**NOTE:- Before Attempting this question you can try Longest Common Substring and Longest Common Subsequence. Both this Problem can be solved using Dynamic Programming. And this problem also requires the same concept.**\\n\\n*As we know that in Longest Common Substring we have String.\\nSimilar here we have Vector, but the implementation is as same as that of Longest Common Substring.*\\n\\n* **Assume two Vectors as a string 1 and string 2  as we do in Longest Common Substring ----> String  (Assume)**\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m=nums1.size();\\n        int n=nums2.size();\\n        \\n        vector<vector<int>> dp(m+1,vector<int> (n+1));\\n        \\n        for(int i=0;i<m+1;i++){\\n            for(int j=0;j<n+1;j++){\\n                if(i==0 || j==0){\\n                  dp[i][j]=0;  \\n                }\\n            }\\n        }\\n        \\n        int maxi=0;\\n        \\n        for(int i=1;i<m+1;i++){\\n            for(int j=1;j<n+1;j++){\\n                if(nums1[i-1]==nums2[j-1]){\\n                  dp[i][j]=1+dp[i-1][j-1];\\n                  maxi=max(maxi,dp[i][j]);     \\n                }\\n                else{\\n                    dp[i][j]=0;\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m=nums1.size();\\n        int n=nums2.size();\\n        \\n        vector<vector<int>> dp(m+1,vector<int> (n+1));\\n        \\n        for(int i=0;i<m+1;i++){\\n            for(int j=0;j<n+1;j++){\\n                if(i==0 || j==0){\\n                  dp[i][j]=0;  \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2600597,
                "title": "c-2-approaches-tabulation-space-optimization",
                "content": "**Please Upvote If It Helps**\\n\\n**This Problem is similar with Longest Common Substring (LCS)** ,\\n\\n\\n**Approach 1** **Using Tabulation**\\n**TC : O(n*m)**\\n**SC : O(n*m)**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int findLength(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        vector<vector<int>> dp(n+1,vector<int> (m+1,0));\\n        \\n        int len=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(nums1[i-1]==nums2[j-1])\\n                {\\n                    dp[i][j] = 1+dp[i-1][j-1];\\n                    len = max(len,dp[i][j]);\\n                }\\n                else\\n                {\\n                    dp[i][j] = 0;\\n                }\\n            }\\n        }\\n        return len;\\n    }\\n};\\n```\\n\\n\\n**Approach 2 With Space Optimization**\\n**TC : O(n*m)**\\n**SC : O(m)**\\n\\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        vector<int> prev(m+1,0),curr(m+1,0);\\n        \\n        int len=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(nums1[i-1]==nums2[j-1])\\n                {\\n                    curr[j] = 1+prev[j-1];\\n                    len = max(len,curr[j]);\\n                }\\n                else\\n                {\\n                    curr[j] = 0;\\n                }\\n            }\\n            prev=curr;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findLength(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        vector<vector<int>> dp(n+1,vector<int> (m+1,0));\\n        \\n        int len=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(nums1[i-1]==nums2[j-1])\\n                {\\n                    dp[i][j] = 1+dp[i-1][j-1];\\n                    len = max(len,dp[i][j]);\\n                }\\n                else\\n                {\\n                    dp[i][j] = 0;\\n                }\\n            }\\n        }\\n        return len;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        vector<int> prev(m+1,0),curr(m+1,0);\\n        \\n        int len=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(nums1[i-1]==nums2[j-1])\\n                {\\n                    curr[j] = 1+prev[j-1];\\n                    len = max(len,curr[j]);\\n                }\\n                else\\n                {\\n                    curr[j] = 0;\\n                }\\n            }\\n            prev=curr;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600401,
                "title": "simple-solution-using-tabulation",
                "content": "class Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n         int n = nums1.size();\\n         int m = nums2.size();\\n         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n         int ans=0;\\n         for(int i=1;i<=n;i++){\\n              for(int j=1;j<=m;j++){\\n                   if(nums1[i-1] == nums2[j-1]){\\n                        dp[i][j] = 1+ dp[i-1][j-1];\\n                 }\\n                 ans = max(ans,dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n         int n = nums1.size();\\n         int m = nums2.size();\\n         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n         int ans=0;\\n         for(int i=1;i<=n;i++){\\n              for(int j=1;j<=m;j++){\\n                   if(nums1[i-1] == nums2[j-1]){\\n                        dp[i][j] = 1+ dp[i-1][j-1];\\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 2600077,
                "title": "c-longest-common-substring-idea-easiest-and-simple-dp",
                "content": "Simple and Concise Idea of Longest Common Substring. Consider the elements of the array as an character of the string.\\nPlease upvote!\\n```\\nclass Solution {\\npublic:\\n    int t[1001][1001]; // dp\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        int ans = 0;\\n        for(int i = 0; i <= n; ++i){\\n            for(int j = 0; j <= m; ++j){\\n                if(i == 0 || j == 0)\\n                    t[i][j] = 0; // Initialize\\n                else{\\n                    if(nums1[i-1] == nums2[j-1])\\n                        t[i][j] = t[i-1][j-1]+1; //Increase count of same elements.                    \\n                    else\\n                        t[i][j] = 0; //Unequal so count of being same becomes zero.                   \\n                    ans = max(ans, t[i][j]); //Maximum count\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nThank You!\\nI hope it helps.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t[1001][1001]; // dp\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        int ans = 0;\\n        for(int i = 0; i <= n; ++i){\\n            for(int j = 0; j <= m; ++j){\\n                if(i == 0 || j == 0)\\n                    t[i][j] = 0; // Initialize\\n                else{\\n                    if(nums1[i-1] == nums2[j-1])\\n                        t[i][j] = t[i-1][j-1]+1; //Increase count of same elements.                    \\n                    else\\n                        t[i][j] = 0; //Unequal so count of being same becomes zero.                   \\n                    ans = max(ans, t[i][j]); //Maximum count\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599881,
                "title": "c-easy-to-understand-intuitive-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001] = {0};\\n    int helper(vector<int>& nums1, vector<int>& nums2, int i, int j){\\n        if(i>=nums1.size() || j>=nums2.size()){\\n            return 0;\\n        }\\n        if(dp[i][j]>0)\\n            return dp[i][j];\\n        \\n        int ans = INT_MIN;\\n        if(nums1[i]==nums2[j])\\n            return dp[i][j] = 1 + helper(nums1, nums2, i+1, j+1);\\n        else{\\n            return 0;\\n        }\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m = -1;\\n        for(int i=0; i<nums1.size(); i++){\\n            for(int j=0; j<nums2.size(); j++){\\n                m = max(m,helper(nums1, nums2, i, j));\\n            }\\n        }\\n        \\n        return m;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001] = {0};\\n    int helper(vector<int>& nums1, vector<int>& nums2, int i, int j){\\n        if(i>=nums1.size() || j>=nums2.size()){\\n            return 0;\\n        }\\n        if(dp[i][j]>0)\\n            return dp[i][j];\\n        \\n        int ans = INT_MIN;\\n        if(nums1[i]==nums2[j])\\n            return dp[i][j] = 1 + helper(nums1, nums2, i+1, j+1);\\n        else{\\n            return 0;\\n        }\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int m = -1;\\n        for(int i=0; i<nums1.size(); i++){\\n            for(int j=0; j<nums2.size(); j++){\\n                m = max(m,helper(nums1, nums2, i, j));\\n            }\\n        }\\n        \\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599508,
                "title": "clean-optimal-o-m-n-log-min-n-memo-java-c-py-py3-concise-meme",
                "content": "```\\n\\n**UPVOTE PLEASE**\\npy:\\n\\ndef findLength(self, A, B):\\n        an=0;al=len(A);bl=len(B);\\n        mem=[[0]*(bl+1) for i in xrange(al+1)];\\n        for i in xrange(al-1,-1,-1):\\n            for j in xrange(bl-1,-1,-1):\\n                if(A[i]==B[j]):\\n                    mem[i][j]=mem[i+1][j+1]+1;\\n                    an=max(an,mem[i][j]);\\n        return an;\\n\\t\\t\\n\\t\\t\\n\\t\\tpy3:\\n\\t\\t\\n\\t\\tdef findLength(self, A: List[int], B: List[int]) -> int:\\n        an=0;al=len(A);bl=len(B);\\n        mem=[[0]*(bl+1) for i in range(al+1)];\\n        for i in range(al-1,-1,-1):\\n            for j in range(bl-1,-1,-1):\\n                if(A[i]==B[j]):\\n                    mem[i][j]=mem[i+1][j+1]+1;\\n                    an=max(an,mem[i][j]);\\n        return an;\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\tjava:\\n\\t\\t\\n\\t\\tpublic int findLength(int[] A, int[] B) {\\n        int an=0,al=A.length,bl=B.length,mem[][]=new int[al+1][bl+1];\\n        for(int i=al-1;i>=0;i--)\\n            for(int j=bl-1;j>=0;j--)\\n                if(A[i]==B[j]){\\n                    mem[i][j]=mem[i+1][j+1]+1;\\n                    an=Math.max(an,mem[i][j]);\\n                }\\n        return an;\\n\\t\\t\\n\\t\\t\\n\\t\\tc++:\\n\\t\\t\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n        int an=0,al=A.size(),bl=B.size();\\n        vector<vector<int>>mem(al+1,vector<int>(bl+1,0));\\n        for(int i=al-1;i>=0;i--)\\n            for(int j=bl-1;j>=0;j--)\\n                if(A[i]==B[j]){\\n                    mem[i][j]=mem[i+1][j+1]+1;\\n                    an=max(an,mem[i][j]);\\n                }return an;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tBinary Search with Rolling Hash [Accepted]\\nIntuition\\n\\nAs in Approach #2, we will binary search for the answer. However, we will use a rolling hash (Rabin-Karp algorithm) to store hashes in our set structure.\\n\\nAlgorithm\\n\\nFor some prime pp, consider the following function modulo some prime modulus \\\\mathcal{M}M:\\n\\nFor every i >= length - 1, we will want to record the hash of A[i-length+1], A[i-length+2], ..., A[i]. After, we will truncate the first element by h = (h - A[i - (length - 1)]) * Pinv % MOD to get ready to add the next element.\\n\\nTo make our algorithm air tight, we also make a naive check when our work with rolling hashes says that we have found a match.\\n\\nclass Solution(object):\\n    def findLength(self, A, B):\\n        P, MOD = 113, 10**9 + 7\\n        Pinv = pow(P, MOD - 2, MOD)\\n        def check(guess):\\n            def rolling(A, length):\\n                if length == 0:\\n                    yield 0, 0\\n                    return\\n\\n                h, power = 0, 1\\n                for i, x in enumerate(A):\\n                    h = (h + x * power) % MOD\\n                    if i < length - 1:\\n                        power = (power * P) % MOD\\n                    else:\\n                        yield h, i - (length - 1)\\n                        h = (h - A[i - (length - 1)]) * Pinv % MOD\\n\\n            hashes = collections.defaultdict(list)\\n            for ha, start in rolling(A, guess):\\n                hashes[ha].append(start)\\n            for ha, start in rolling(B, guess):\\n                iarr = hashes.get(ha, [])\\n                if any(A[i: i + guess] == B[start: start + guess] for i in iarr):\\n                    return True\\n            return False\\n\\n        lo, hi = 0, min(len(A), len(B)) + 1\\n        while lo < hi:\\n            mi = (lo + hi) // 2\\n            if check(mi):\\n                lo = mi + 1\\n            else:\\n                hi = mi\\n        return lo - 1\\nJava\\n\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    int P = 113;\\n    int MOD = 1_000_000_007;\\n    int Pinv = BigInteger.valueOf(P).modInverse(BigInteger.valueOf(MOD)).intValue();\\n\\n    private int[] rolling(int[] source, int length) {\\n        int[] ans = new int[source.length - length + 1];\\n        long h = 0, power = 1;\\n        if (length == 0) return ans;\\n        for (int i = 0; i < source.length; ++i) {\\n            h = (h + source[i] * power) % MOD;\\n            if (i < length - 1) {\\n                power = (power * P) % MOD;\\n            } else {\\n                ans[i - (length - 1)] = (int) h;\\n                h = (h - source[i - (length - 1)]) * Pinv % MOD;\\n                if (h < 0) h += MOD;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private boolean check(int guess, int[] A, int[] B) {\\n        Map<Integer, List<Integer>> hashes = new HashMap();\\n        int k = 0;\\n        for (int x: rolling(A, guess)) {\\n            hashes.computeIfAbsent(x, z -> new ArrayList()).add(k++);\\n        }\\n        int j = 0;\\n        for (int x: rolling(B, guess)) {\\n            for (int i: hashes.getOrDefault(x, new ArrayList<Integer>()))\\n                if (Arrays.equals(Arrays.copyOfRange(A, i, i+guess),\\n                                  Arrays.copyOfRange(B, j, j+guess))) {\\n                    return true;\\n                }\\n            j++;\\n        }\\n        return false;\\n    }\\n\\n    public int findLength(int[] A, int[] B) {\\n        int lo = 0, hi = Math.min(A.length, B.length) + 1;\\n        while (lo < hi) {\\n            int mi = (lo + hi) / 2;\\n            if (check(mi, A, B)) lo = mi + 1;\\n            else hi = mi;\\n        }\\n        return lo - 1;\\n    }\\n}\\nComplexity Analysis\\n\\nTime Complexity: O((M+N) * \\\\log{(\\\\min(M, N))})O((M+N)\\u2217log(min(M,N))), where M, NM,N are the lengths of A, B. \\nThe log factor is contributed by the binary search, while creating the rolling hashes is O(M + N)O(M+N). \\nThe checks for duplicate hashes are O(1)O(1). If we perform a naive check to make sure our answer is correct, it adds a factor of O(\\\\min(M, N))O(min(M,N)) to our cost of check, \\nwhich keeps the complexity the same.\\n\\nSpace Complexity: O(M)O(M), the space used to store hashes and the subarrays in our final naive check.\\n\\t\\t\\t\\n\\n```\\n![image](https://assets.leetcode.com/users/images/d543b69d-7945-4dc8-8a23-195009bcf89c_1663644303.0880795.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\n**UPVOTE PLEASE**\\npy:\\n\\ndef findLength(self, A, B):\\n        an=0;al=len(A);bl=len(B);\\n        mem=[[0]*(bl+1) for i in xrange(al+1)];\\n        for i in xrange(al-1,-1,-1):\\n            for j in xrange(bl-1,-1,-1):\\n                if(A[i]==B[j]):\\n                    mem[i][j]=mem[i+1][j+1]+1;\\n                    an=max(an,mem[i][j]);\\n        return an;\\n\\t\\t\\n\\t\\t\\n\\t\\tpy3:\\n\\t\\t\\n\\t\\tdef findLength(self, A: List[int], B: List[int]) -> int:\\n        an=0;al=len(A);bl=len(B);\\n        mem=[[0]*(bl+1) for i in range(al+1)];\\n        for i in range(al-1,-1,-1):\\n            for j in range(bl-1,-1,-1):\\n                if(A[i]==B[j]):\\n                    mem[i][j]=mem[i+1][j+1]+1;\\n                    an=max(an,mem[i][j]);\\n        return an;\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\tjava:\\n\\t\\t\\n\\t\\tpublic int findLength(int[] A, int[] B) {\\n        int an=0,al=A.length,bl=B.length,mem[][]=new int[al+1][bl+1];\\n        for(int i=al-1;i>=0;i--)\\n            for(int j=bl-1;j>=0;j--)\\n                if(A[i]==B[j]){\\n                    mem[i][j]=mem[i+1][j+1]+1;\\n                    an=Math.max(an,mem[i][j]);\\n                }\\n        return an;\\n\\t\\t\\n\\t\\t\\n\\t\\tc++:\\n\\t\\t\\n\\t\\tint findLength(vector<int>& A, vector<int>& B) {\\n        int an=0,al=A.size(),bl=B.size();\\n        vector<vector<int>>mem(al+1,vector<int>(bl+1,0));\\n        for(int i=al-1;i>=0;i--)\\n            for(int j=bl-1;j>=0;j--)\\n                if(A[i]==B[j]){\\n                    mem[i][j]=mem[i+1][j+1]+1;\\n                    an=max(an,mem[i][j]);\\n                }return an;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tBinary Search with Rolling Hash [Accepted]\\nIntuition\\n\\nAs in Approach #2, we will binary search for the answer. However, we will use a rolling hash (Rabin-Karp algorithm) to store hashes in our set structure.\\n\\nAlgorithm\\n\\nFor some prime pp, consider the following function modulo some prime modulus \\\\mathcal{M}M:\\n\\nFor every i >= length - 1, we will want to record the hash of A[i-length+1], A[i-length+2], ..., A[i]. After, we will truncate the first element by h = (h - A[i - (length - 1)]) * Pinv % MOD to get ready to add the next element.\\n\\nTo make our algorithm air tight, we also make a naive check when our work with rolling hashes says that we have found a match.\\n\\nclass Solution(object):\\n    def findLength(self, A, B):\\n        P, MOD = 113, 10**9 + 7\\n        Pinv = pow(P, MOD - 2, MOD)\\n        def check(guess):\\n            def rolling(A, length):\\n                if length == 0:\\n                    yield 0, 0\\n                    return\\n\\n                h, power = 0, 1\\n                for i, x in enumerate(A):\\n                    h = (h + x * power) % MOD\\n                    if i < length - 1:\\n                        power = (power * P) % MOD\\n                    else:\\n                        yield h, i - (length - 1)\\n                        h = (h - A[i - (length - 1)]) * Pinv % MOD\\n\\n            hashes = collections.defaultdict(list)\\n            for ha, start in rolling(A, guess):\\n                hashes[ha].append(start)\\n            for ha, start in rolling(B, guess):\\n                iarr = hashes.get(ha, [])\\n                if any(A[i: i + guess] == B[start: start + guess] for i in iarr):\\n                    return True\\n            return False\\n\\n        lo, hi = 0, min(len(A), len(B)) + 1\\n        while lo < hi:\\n            mi = (lo + hi) // 2\\n            if check(mi):\\n                lo = mi + 1\\n            else:\\n                hi = mi\\n        return lo - 1\\nJava\\n\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    int P = 113;\\n    int MOD = 1_000_000_007;\\n    int Pinv = BigInteger.valueOf(P).modInverse(BigInteger.valueOf(MOD)).intValue();\\n\\n    private int[] rolling(int[] source, int length) {\\n        int[] ans = new int[source.length - length + 1];\\n        long h = 0, power = 1;\\n        if (length == 0) return ans;\\n        for (int i = 0; i < source.length; ++i) {\\n            h = (h + source[i] * power) % MOD;\\n            if (i < length - 1) {\\n                power = (power * P) % MOD;\\n            } else {\\n                ans[i - (length - 1)] = (int) h;\\n                h = (h - source[i - (length - 1)]) * Pinv % MOD;\\n                if (h < 0) h += MOD;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private boolean check(int guess, int[] A, int[] B) {\\n        Map<Integer, List<Integer>> hashes = new HashMap();\\n        int k = 0;\\n        for (int x: rolling(A, guess)) {\\n            hashes.computeIfAbsent(x, z -> new ArrayList()).add(k++);\\n        }\\n        int j = 0;\\n        for (int x: rolling(B, guess)) {\\n            for (int i: hashes.getOrDefault(x, new ArrayList<Integer>()))\\n                if (Arrays.equals(Arrays.copyOfRange(A, i, i+guess),\\n                                  Arrays.copyOfRange(B, j, j+guess))) {\\n                    return true;\\n                }\\n            j++;\\n        }\\n        return false;\\n    }\\n\\n    public int findLength(int[] A, int[] B) {\\n        int lo = 0, hi = Math.min(A.length, B.length) + 1;\\n        while (lo < hi) {\\n            int mi = (lo + hi) / 2;\\n            if (check(mi, A, B)) lo = mi + 1;\\n            else hi = mi;\\n        }\\n        return lo - 1;\\n    }\\n}\\nComplexity Analysis\\n\\nTime Complexity: O((M+N) * \\\\log{(\\\\min(M, N))})O((M+N)\\u2217log(min(M,N))), where M, NM,N are the lengths of A, B. \\nThe log factor is contributed by the binary search, while creating the rolling hashes is O(M + N)O(M+N). \\nThe checks for duplicate hashes are O(1)O(1). If we perform a naive check to make sure our answer is correct, it adds a factor of O(\\\\min(M, N))O(min(M,N)) to our cost of check, \\nwhich keeps the complexity the same.\\n\\nSpace Complexity: O(M)O(M), the space used to store hashes and the subarrays in our final naive check.\\n\\t\\t\\t\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599472,
                "title": "cpp-simple-code-longest-common-substring-pattern",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        // this question is similar to lcsubstring\\n        int n = nums1.size() , m = nums2.size();\\n        vector<vector<int>> dp ( n + 1 , vector<int> ( m + 1 , 0 ));\\n        \\n        int mx = INT_MIN;\\n        \\n        for ( int i = 1 ; i <= n ; i ++ ){\\n            for ( int j = 1 ; j <= m  ;j ++ ){\\n                if ( nums1.at(i-1) == nums2.at(j-1)) dp[i][j] = 1 + dp[i-1][j-1];\\n                else dp[i][j] = 0;\\n                \\n                mx = max ( mx , dp[i][j]);\\n            }\\n        }\\n        \\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        // this question is similar to lcsubstring\\n        int n = nums1.size() , m = nums2.size();\\n        vector<vector<int>> dp ( n + 1 , vector<int> ( m + 1 , 0 ));\\n        \\n        int mx = INT_MIN;\\n        \\n        for ( int i = 1 ; i <= n ; i ++ ){\\n            for ( int j = 1 ; j <= m  ;j ++ ){\\n                if ( nums1.at(i-1) == nums2.at(j-1)) dp[i][j] = 1 + dp[i-1][j-1];\\n                else dp[i][j] = 0;\\n                \\n                mx = max ( mx , dp[i][j]);\\n            }\\n        }\\n        \\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599421,
                "title": "simple-python3-solution-98-fassster-than-others",
                "content": "**UPVOTE** if it is helpful\\n``` \\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        strnum2 = \\'\\'.join([chr(x) for x in nums2])\\n        strmax = \\'\\'\\n        ans = 0\\n        for num in nums1:\\n            strmax += chr(num)\\n            if strmax in strnum2:\\n                ans = max(ans,len(strmax))\\n            else:\\n                strmax = strmax[1:]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` \\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        strnum2 = \\'\\'.join([chr(x) for x in nums2])\\n        strmax = \\'\\'\\n        ans = 0\\n        for num in nums1:\\n            strmax += chr(num)\\n            if strmax in strnum2:\\n                ans = max(ans,len(strmax))\\n            else:\\n                strmax = strmax[1:]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599312,
                "title": "python-elegant-short-bottom-up-dp",
                "content": "\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n*m)\\n\\t\\tMemory: O(n*m)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef findLength(self, a: List[int], b: List[int]) -> int:\\n\\t\\t\\tn, m = len(a), len(b)\\n\\t\\t\\tdp = [[0] * (m + 1) for _ in range(n + 1)]\\n\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\t\\tif a[i] == b[j]:\\n\\t\\t\\t\\t\\t\\tdp[i + 1][j + 1] = dp[i][j] + 1\\n\\n\\t\\t\\treturn max(map(max, dp))\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n*m)\\n\\t\\tMemory: O(n*m)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef findLength(self, a: List[int], b: List[int]) -> int:\\n\\t\\t\\tn, m = len(a), len(b)\\n\\t\\t\\tdp = [[0] * (m + 1) for _ in range(n + 1)]\\n\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\t\\tif a[i] == b[j]:\\n\\t\\t\\t\\t\\t\\tdp[i + 1][j + 1] = dp[i][j] + 1\\n\\n\\t\\t\\treturn max(map(max, dp))\\n",
                "codeTag": "Java"
            },
            {
                "id": 2298768,
                "title": "java-less-space-than-92-and-faster-than-87-o-n-space-complexity",
                "content": "```\\nclass Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        int max = 0;        //this will store ans\\n        int len1 = nums1.length;        \\n        int len2  = nums2.length;\\n        \\n        int dp[] = new int[len2 + 1];     \\n        \\n        for(int i = 1; i <= len1; i++) {\\n            for(int j = len2; j > 0; j--){  //traverse from backward\\n    \\n                if(nums1[i-1] == nums2[j-1]) { //when numbers are same, we add \\'+1\\' to previous value(j-1)\\n                    dp[j] = dp[j-1] + 1;\\n                    max = Math.max(max, dp[j]);      //update the ans\\n                } else {\\n                    dp[j] = 0;\\n                }\\n                \\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n\\n//Time Complexity : O(m * n), where m and n are the length of the two arrays\\n//Space Complexity : O(m)\\n//Please upvote the solution if you like it.\\n```\\nAlso check out my GitHub repository (https://github.com/Ovaishk/DSA-Problems-for-Placement) for solution to other important DSA Problems !!!",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        int max = 0;        //this will store ans\\n        int len1 = nums1.length;        \\n        int len2  = nums2.length;\\n        \\n        int dp[] = new int[len2 + 1];     \\n        \\n        for(int i = 1; i <= len1; i++) {\\n            for(int j = len2; j > 0; j--){  //traverse from backward\\n    \\n                if(nums1[i-1] == nums2[j-1]) { //when numbers are same, we add \\'+1\\' to previous value(j-1)\\n                    dp[j] = dp[j-1] + 1;\\n                    max = Math.max(max, dp[j]);      //update the ans\\n                } else {\\n                    dp[j] = 0;\\n                }\\n                \\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n\\n//Time Complexity : O(m * n), where m and n are the length of the two arrays\\n//Space Complexity : O(m)\\n//Please upvote the solution if you like it.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232661,
                "title": "python-dp-beats-98-simplest-solution",
                "content": "```class Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n            \\n        dp = [[0 for _ in range(len(nums2)+1)] for _ in range(len(nums1)+1)]\\n        ans = 0\\n        for i in range(len(nums1)-1,-1,-1):\\n            for j in range(len(nums2)-1,-1,-1):\\n                if nums1[i] == nums2[j]:\\n                    dp[i][j] = dp[i+1][j+1] + 1\\n                \\n                \\n        return max(max(row) for row in dp)\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```class Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n            \\n        dp = [[0 for _ in range(len(nums2)+1)] for _ in range(len(nums1)+1)]\\n        ans = 0\\n        for i in range(len(nums1)-1,-1,-1):\\n            for j in range(len(nums2)-1,-1,-1):\\n                if nums1[i] == nums2[j]:\\n                    dp[i][j] = dp[i+1][j+1] + 1\\n                \\n                \\n        return max(max(row) for row in dp)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2110667,
                "title": "c-beat-100-in-space-dp-solution",
                "content": "similar to LCS but just keep a max for max element \\n\\n```\\nif(nums1.size()<nums2.size())\\n        swap(nums1,nums2);\\n        \\n        short n = nums1.size();\\n        short m = nums2.size();\\n        \\n        short dp[m+1];\\n        fill(dp,dp+m+1,0);\\n     \\n        short max=0;\\n        \\n        for(short i=1;i<=n;i++)\\n        for(short j=m;j>0;j--){\\n         if(nums1[i-1]==nums2[j-1]){\\n            dp[j]=1+dp[j-1];\\n             \\n             if(dp[j]>max){\\n             max = dp[j];\\n             \\n             if(max==m)\\n              return(max);}\\n         }\\n            \\n            else\\n            dp[j]=0;\\n        }\\n        \\n        return(max);\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nif(nums1.size()<nums2.size())\\n        swap(nums1,nums2);\\n        \\n        short n = nums1.size();\\n        short m = nums2.size();\\n        \\n        short dp[m+1];\\n        fill(dp,dp+m+1,0);\\n     \\n        short max=0;\\n        \\n        for(short i=1;i<=n;i++)\\n        for(short j=m;j>0;j--){\\n         if(nums1[i-1]==nums2[j-1]){\\n            dp[j]=1+dp[j-1];\\n             \\n             if(dp[j]>max){\\n             max = dp[j];\\n             \\n             if(max==m)\\n              return(max);}\\n         }\\n            \\n            else\\n            dp[j]=0;\\n        }\\n        \\n        return(max);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2064488,
                "title": "easy-to-understand-recursive-solution-in-java",
                "content": "```\\nclass Solution {\\n    \\n    private int max = Integer.MIN_VALUE;\\n    \\n    public int findLength(int[] nums1, int[] nums2) {\\n        int[][]dp = new int[nums1.length +1][nums2.length + 1];\\n        \\n        for(int[] arr: dp){ // Initialising DP array to -1\\n            for(int i =0;i <arr.length ;++i){\\n                arr[i] = -1;\\n            }\\n        }\\n        \\n        func(nums1, nums2, 0, 0, dp);\\n        return max;\\n    }\\n    \\n    public int func(int[]nums1, int[] nums2 , int i, int j, int[][]dp){\\n        if(dp[i][j]!=-1) return dp[i][j]; //return if value has already been computed\\n        \\n        if(i == nums1.length || j ==nums2.length) return dp[i][j] = 0; //base case\\n        \\n        int len=0;\\n\\t\\t\\n        // In case the integer at i and j matches, we need to add 1 to the next recursive call. \\n\\t\\t//The next call might return a non zero value - indicating that there is a substring match from nums1[i+1:] and nums2[j+1]. \\n\\t\\t//In case it return a zero value, then hard luck, only nums1[i] and nums2[j] match.\\n        if(nums1[i] == nums2[j]) len =  1 +func(nums1, nums2, i+1, j+1, dp); \\n\\t\\n        max = Math.max(max, len);\\n        \\n        func(nums1, nums2, i, j+1, dp);\\n        func(nums1, nums2, i+1, j, dp);\\n        \\n        return dp[i][j] = len;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int max = Integer.MIN_VALUE;\\n    \\n    public int findLength(int[] nums1, int[] nums2) {\\n        int[][]dp = new int[nums1.length +1][nums2.length + 1];\\n        \\n        for(int[] arr: dp){ // Initialising DP array to -1\\n            for(int i =0;i <arr.length ;++i){\\n                arr[i] = -1;\\n            }\\n        }\\n        \\n        func(nums1, nums2, 0, 0, dp);\\n        return max;\\n    }\\n    \\n    public int func(int[]nums1, int[] nums2 , int i, int j, int[][]dp){\\n        if(dp[i][j]!=-1) return dp[i][j]; //return if value has already been computed\\n        \\n        if(i == nums1.length || j ==nums2.length) return dp[i][j] = 0; //base case\\n        \\n        int len=0;\\n\\t\\t\\n        // In case the integer at i and j matches, we need to add 1 to the next recursive call. \\n\\t\\t//The next call might return a non zero value - indicating that there is a substring match from nums1[i+1:] and nums2[j+1]. \\n\\t\\t//In case it return a zero value, then hard luck, only nums1[i] and nums2[j] match.\\n        if(nums1[i] == nums2[j]) len =  1 +func(nums1, nums2, i+1, j+1, dp); \\n\\t\\n        max = Math.max(max, len);\\n        \\n        func(nums1, nums2, i, j+1, dp);\\n        func(nums1, nums2, i+1, j, dp);\\n        \\n        return dp[i][j] = len;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053512,
                "title": "bottom-up-python",
                "content": "```\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        m=len(nums1)\\n        n=len(nums2)\\n        Max=0\\n        t=[[0 for i in range(n+1)] for j in range(m+1)]\\n        \\n        for i in range(1,m+1,1):\\n            for j in range(1,n+1,1):\\n                if nums1[i-1]==nums2[j-1]:\\n                    t[i][j] += 1+t[i-1][j-1]\\n                    Max=max(Max,t[i][j])                \\n        return Max\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        m=len(nums1)\\n        n=len(nums2)\\n        Max=0\\n        t=[[0 for i in range(n+1)] for j in range(m+1)]\\n        \\n        for i in range(1,m+1,1):\\n            for j in range(1,n+1,1):\\n                if nums1[i-1]==nums2[j-1]:\\n                    t[i][j] += 1+t[i-1][j-1]\\n                    Max=max(Max,t[i][j])                \\n        return Max\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1939025,
                "title": "longest-common-substring-not-subsequence-variation",
                "content": "```\\nHere one important difference should be noted that\\nIn Longest common Subsequence we need to maintain only sequence\\nBut\\nIn Longest common substring we need to maintain sequence as well as continuity, when we encounter discontinuity we reset the count.\\n\\nHere in this particular problem we need *Subarray* it means that we have to preserve both the sequence and continuity\\n\\nthat is why this is variation of LC Substring\\n\\n\\nclass Solution {\\npublic:   \\n     \\n    int lcs(vector<int> text1, vector<int> text2) {\\n        int n = text1.size();\\n        int m = text2.size();\\n        int mx = 0;\\n        int dp[n+1][m+1];\\n        \\n        for(int i = 0 ; i < n + 1 ; i++){\\n            dp[i][0] = 0;\\n        }\\n        \\n        for(int i = 0 ; i < m + 1 ; i++){\\n            dp[0][i] = 0;\\n        }\\n        \\n        for(int i = 1 ; i < n + 1 ; i++){\\n            for(int j = 1 ; j < m + 1 ; j++){\\n                \\n                if(text1[i-1] == text2[j-1]){\\n                    dp[i][j] =  dp[i-1][j-1] + 1;\\n                    mx = max(mx , dp[i][j]);\\n                }\\n                \\n                else{\\n                    dp[i][j] = 0;//discontinuity\\n                }\\n                \\n                \\n            }\\n        }\\n        \\n        return mx;\\n    }\\n    \\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        return lcs(nums1 , nums2);\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:   \\n     \\n    int lcs(vector<int> text1, vector<int> text2) {\\n        int n = text1.size();\\n        int m = text2.size();\\n        int mx = 0;\\n        int dp[n+1][m+1];\\n        \\n        for(int i = 0 ; i < n + 1 ; i++){\\n            dp[i][0] = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1920116,
                "title": "4-approaches-reccursion-dp-longest-common-substring-python",
                "content": "**Reccursive - TLE\\nTime - exponential\\nSpace - Auxilary stack space**\\n```\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        return lcs(nums1,nums2,0,0,0)\\n        \\ndef lcs(x,y,i,j,ct):\\n    if(i>=len(x) or j>= len(y)):\\n        return ct\\n    same = ct\\n    if x[i] == y[j]:\\n        same = lcs(x,y,i+1,j+1,ct+1)\\n    dif1 = lcs(x,y,i,j+1,0)\\n    dif2 = lcs(x,y,i+1,j,0)\\n    \\n    return max(same,dif1,dif2)\\n\\n```\\n**DP Top Down - Memory limit exceeded\\nTime -O(m*n*min(m,n))\\nSpace - O(m*n*min(m,n))  + stack space**\\n```\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        dp = [[[-1 for k in range(min(len(nums1),len(nums2)))] for j in range(len(nums2))] for i in range(len(nums1))]\\n        return lcs(nums1,nums2,0,0,0,dp)\\n        \\ndef lcs(x,y,i,j,ct,dp):\\n    if(i>=len(x) or j>= len(y)):\\n        return ct\\n    \\n    if dp[i][j][ct] != -1:\\n        return dp[i][j][ct]\\n    same = ct  \\n    if x[i] == y[j]:\\n        same = lcs(x,y,i+1,j+1,ct+1,dp)\\n    dif1 = lcs(x,y,i,j+1,0,dp)\\n    dif2 = lcs(x,y,i+1,j,0,dp)\\n    dp[i][j][ct] = max(same,dif1,dif2)\\n    return max(same,dif1,dif2)\\n\\n```\\n**DP Bottom Up -\\nTime - O(m*n)\\nSpace - O(m*n)**\\n```\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        m = len(nums1)\\n        n = len(nums2)\\n        dp = [[0 for i in range(n+1)] for j in range(m+1)]\\n        ans = 0\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if nums1[i-1] == nums2[j-1]:\\n                    dp[i][j] += dp[i-1][j-1] +1\\n                ans = max(ans,dp[i][j])\\n        return ans\\n```\\n**Space Optimized\\nTime - O(m*n)\\nSpace - O(n)**\\n```\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        m = len(nums1)\\n        n = len(nums2)\\n        # dp = [[0 for i in range(n+1)] for j in range(m+1)]\\n        prev = [0 for i in range(n+1)]\\n        \\n        ans = 0\\n        for i in range(1,m+1):\\n            cur = [0 for i in range(n+1)]\\n            for j in range(1,n+1):\\n                if nums1[i-1] == nums2[j-1]:\\n                    cur[j] += prev[j-1] +1\\n                ans = max(ans,cur[j])\\n            prev = cur\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        return lcs(nums1,nums2,0,0,0)\\n        \\ndef lcs(x,y,i,j,ct):\\n    if(i>=len(x) or j>= len(y)):\\n        return ct\\n    same = ct\\n    if x[i] == y[j]:\\n        same = lcs(x,y,i+1,j+1,ct+1)\\n    dif1 = lcs(x,y,i,j+1,0)\\n    dif2 = lcs(x,y,i+1,j,0)\\n    \\n    return max(same,dif1,dif2)\\n\\n```\n```\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        dp = [[[-1 for k in range(min(len(nums1),len(nums2)))] for j in range(len(nums2))] for i in range(len(nums1))]\\n        return lcs(nums1,nums2,0,0,0,dp)\\n        \\ndef lcs(x,y,i,j,ct,dp):\\n    if(i>=len(x) or j>= len(y)):\\n        return ct\\n    \\n    if dp[i][j][ct] != -1:\\n        return dp[i][j][ct]\\n    same = ct  \\n    if x[i] == y[j]:\\n        same = lcs(x,y,i+1,j+1,ct+1,dp)\\n    dif1 = lcs(x,y,i,j+1,0,dp)\\n    dif2 = lcs(x,y,i+1,j,0,dp)\\n    dp[i][j][ct] = max(same,dif1,dif2)\\n    return max(same,dif1,dif2)\\n\\n```\n```\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        m = len(nums1)\\n        n = len(nums2)\\n        dp = [[0 for i in range(n+1)] for j in range(m+1)]\\n        ans = 0\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if nums1[i-1] == nums2[j-1]:\\n                    dp[i][j] += dp[i-1][j-1] +1\\n                ans = max(ans,dp[i][j])\\n        return ans\\n```\n```\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        m = len(nums1)\\n        n = len(nums2)\\n        # dp = [[0 for i in range(n+1)] for j in range(m+1)]\\n        prev = [0 for i in range(n+1)]\\n        \\n        ans = 0\\n        for i in range(1,m+1):\\n            cur = [0 for i in range(n+1)]\\n            for j in range(1,n+1):\\n                if nums1[i-1] == nums2[j-1]:\\n                    cur[j] += prev[j-1] +1\\n                ans = max(ans,cur[j])\\n            prev = cur\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1810515,
                "title": "javascript-recursion-memoization",
                "content": "```\\n\\n// Recursive Solution: TLE\\nlet ans;\\nfunction lcs(s1, s2, i, j) {\\n    if (i < 0 || j < 0) return 0;\\n\\n    let p1 = 0;\\n    if (s1[i] === s2[j]) {\\n        p1 = 1 + lcs(s1, s2, i - 1, j - 1);\\n        ans = Math.max(ans, p1);\\n    }\\n\\n    lcs(s1, s2, i - 1, j);\\n    lcs(s1, s2, i, j - 1);\\n\\n    return p1;\\n}\\nvar findLength = function (nums1, nums2) {\\n    ans = 0;\\n    lcs(nums1, nums2, nums1.length - 1, nums2.length - 1);\\n    return ans;\\n};\\n\\n// Memoized Recursion\\nlet ans;\\nfunction lcsMemo(s1, s2, i, j, dp) {\\n    if (i < 0 || j < 0) return 0;\\n    if (dp[i][j] !== -1) return dp[i][j];\\n\\n    let p1 = 0;\\n    if (s1[i] === s2[j]) {\\n        p1 = 1 + lcsMemo(s1, s2, i - 1, j - 1, dp);\\n        ans = Math.max(ans, p1);\\n    }\\n    lcsMemo(s1, s2, i - 1, j, dp);\\n    lcsMemo(s1, s2, i, j - 1, dp);\\n\\n    return dp[i][j] = p1;\\n}\\n\\nvar findLength = function (nums1, nums2) {\\n    ans = 0;\\n    const m = nums1.length, n = nums2.length;\\n    const dp = new Array(m + 1).fill(-1).map(() => new Array(n + 1).fill(-1));\\n    lcsMemo(nums1, nums2, m - 1, n - 1, dp);\\n    return ans;\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/1f1e0f4b-713f-4c9f-8806-447b73c37258_1649431214.4823656.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\n// Recursive Solution: TLE\\nlet ans;\\nfunction lcs(s1, s2, i, j) {\\n    if (i < 0 || j < 0) return 0;\\n\\n    let p1 = 0;\\n    if (s1[i] === s2[j]) {\\n        p1 = 1 + lcs(s1, s2, i - 1, j - 1);\\n        ans = Math.max(ans, p1);\\n    }\\n\\n    lcs(s1, s2, i - 1, j);\\n    lcs(s1, s2, i, j - 1);\\n\\n    return p1;\\n}\\nvar findLength = function (nums1, nums2) {\\n    ans = 0;\\n    lcs(nums1, nums2, nums1.length - 1, nums2.length - 1);\\n    return ans;\\n};\\n\\n// Memoized Recursion\\nlet ans;\\nfunction lcsMemo(s1, s2, i, j, dp) {\\n    if (i < 0 || j < 0) return 0;\\n    if (dp[i][j] !== -1) return dp[i][j];\\n\\n    let p1 = 0;\\n    if (s1[i] === s2[j]) {\\n        p1 = 1 + lcsMemo(s1, s2, i - 1, j - 1, dp);\\n        ans = Math.max(ans, p1);\\n    }\\n    lcsMemo(s1, s2, i - 1, j, dp);\\n    lcsMemo(s1, s2, i, j - 1, dp);\\n\\n    return dp[i][j] = p1;\\n}\\n\\nvar findLength = function (nums1, nums2) {\\n    ans = 0;\\n    const m = nums1.length, n = nums2.length;\\n    const dp = new Array(m + 1).fill(-1).map(() => new Array(n + 1).fill(-1));\\n    lcsMemo(nums1, nums2, m - 1, n - 1, dp);\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1799421,
                "title": "c-dp-top-down",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n=nums1.size();\\n        int m=nums2.size();\\n        int dp[n+1][m+1];\\n        int mx=INT_MIN;\\n        \\n        for(int i=0;i<n+1;i++)\\n        {\\n            for(int j=0;j<m+1;j++)\\n            {\\n                if(i==0 || j==0)\\n                {\\n                    dp[i][j]=0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<n+1;i++)\\n        {\\n            for(int j=1;j<m+1;j++)\\n            {\\n                if(nums1[i-1]==nums2[j-1])\\n                {\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                    mx=max(mx,dp[i][j]);\\n                }\\n                else\\n                {\\n                    dp[i][j]=0;\\n                }\\n            }\\n        }\\n        if(mx==INT_MIN)\\n            return 0;\\n        return mx;\\n    }\\n};\\n\\'\\'\\'\\n//Complexity O(n*m)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n=nums1.size();\\n        int m=nums2.size();\\n        int dp[n+1][m+1];\\n        int mx=INT_MIN;\\n        \\n        for(int i=0;i<n+1;i++)\\n        {\\n            for(int j=0;j<m+1;j++)\\n            {\\n                if(i==0 || j==0)\\n                {\\n                    dp[i][j]=0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1782298,
                "title": "python-sliding-window-approach",
                "content": "Here\\'s my attempt at solving this problem. Couldn\\'t wrap my head around the dynamic programming around it, and it made more sense to me as a sliding window problem. It\\'s not the fastest, but I didn\\'t try to optimize it. It does use less then 98% of memory though. Any improvements or suggestions are welcome.\\n\\n```\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        def compare_offset(n1, n2, offset):\\n            longest = 0\\n            same_counter = 0\\n            for i in range(offset, len(n1)):\\n                if (i-offset) > len(n2) -1:\\n                    break\\n                    \\n                if n1[i] == n2[i-offset]:\\n                    same_counter += 1\\n                else:\\n                    same_counter = 0\\n                longest = max(longest, same_counter)\\n            return longest\\n        \\n        \\n        best = 0\\n        # slide one way\\n        for i in range(len(nums1)):\\n            length = compare_offset(nums1, nums2, i)\\n            best = max(best, length)\\n\\n        # then slide the next\\n        for i in range(len(nums2)):\\n            length = compare_offset(nums2, nums1, i)\\n            best = max(best, length)\\n\\n        return best\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        def compare_offset(n1, n2, offset):\\n            longest = 0\\n            same_counter = 0\\n            for i in range(offset, len(n1)):\\n                if (i-offset) > len(n2) -1:\\n                    break\\n                    \\n                if n1[i] == n2[i-offset]:\\n                    same_counter += 1\\n                else:\\n                    same_counter = 0\\n                longest = max(longest, same_counter)\\n            return longest\\n        \\n        \\n        best = 0\\n        # slide one way\\n        for i in range(len(nums1)):\\n            length = compare_offset(nums1, nums2, i)\\n            best = max(best, length)\\n\\n        # then slide the next\\n        for i in range(len(nums2)):\\n            length = compare_offset(nums2, nums1, i)\\n            best = max(best, length)\\n\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752290,
                "title": "19-56-test-case-working-why",
                "content": "```class Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        return findLength(nums1, nums2, 0, 0, 0);\\n    }\\n    \\n    private int findLength(int[] nums1, int[] nums2, int i, int j, int sum){\\n        if(i == nums1.length || j == nums2.length){\\n            return 0;\\n        }\\n        if(nums1[i] == nums2[j]){\\n            return sum = 1+ findLength(nums1, nums2, i+1, j+1, sum);\\n        }else{\\n            return sum =\\n            Math.max(\\n            findLength(nums1, nums2, i, j+1, sum),\\n            findLength(nums1, nums2, i+1, j, sum));\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int findLength(int[] nums1, int[] nums2) {\\n        return findLength(nums1, nums2, 0, 0, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1629557,
                "title": "javascript-simple-dp",
                "content": "Runtime: 360 ms, faster than 86.41% of JavaScript online submissions for Maximum Length of Repeated Subarray.\\nMemory Usage: 88.7 MB, less than 5.83% of JavaScript online submissions for Maximum Length of Repeated Subarray.\\n```\\nvar findLength = function(nums1, nums2) {\\n    let n1 = nums1.length;\\n    let n2 = nums2.length;\\n    let res = 0;\\n    \\n    let dp = new Array(n1 + 1).fill().map(() => new Array(n2 + 1).fill(0));\\n    \\n    for(let i = 1; i <= n1; i++) {\\n        for(let j = 1; j <= n2; j++) {\\n            if(nums1[i-1] == nums2[j-1]) {\\n\\t\\t\\t\\t// Since we want a subarray of nums1 AND nums2\\n\\t\\t\\t\\t// we need to make sure its continuous with the\\n\\t\\t\\t\\t// dp[i-1][j-1] location :) \\n                dp[i][j] = dp[i - 1][j - 1] + 1;\\n                res = Math.max(res, dp[i][j])\\n            } \\n        }\\n    }\\n\\n    return res;        \\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nvar findLength = function(nums1, nums2) {\\n    let n1 = nums1.length;\\n    let n2 = nums2.length;\\n    let res = 0;\\n    \\n    let dp = new Array(n1 + 1).fill().map(() => new Array(n2 + 1).fill(0));\\n    \\n    for(let i = 1; i <= n1; i++) {\\n        for(let j = 1; j <= n2; j++) {\\n            if(nums1[i-1] == nums2[j-1]) {\\n\\t\\t\\t\\t// Since we want a subarray of nums1 AND nums2\\n\\t\\t\\t\\t// we need to make sure its continuous with the\\n\\t\\t\\t\\t// dp[i-1][j-1] location :) \\n                dp[i][j] = dp[i - 1][j - 1] + 1;\\n                res = Math.max(res, dp[i][j])\\n            } \\n        }\\n    }\\n\\n    return res;        \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1597041,
                "title": "java-easy-and-clean-dp-tabulation-solution",
                "content": "```\\nclass Solution {\\n    public int findLength(int[] arr1, int[] arr2) {\\n          int[][] dp = new int[arr1.length + 1][arr2.length + 1];\\n          int ans = 0;\\n\\n          for(int i = 1; i < dp.length; i++) {\\n              for(int j = 1; j < dp[0].length; j++) {\\n                  if(arr1[i - 1] == arr2[j - 1])\\n                     dp[i][j] = dp[i - 1][j - 1] + 1;\\n                  if(dp[i][j] > ans)\\n                      ans = dp[i][j];\\n              }\\n          }\\n          return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findLength(int[] arr1, int[] arr2) {\\n          int[][] dp = new int[arr1.length + 1][arr2.length + 1];\\n          int ans = 0;\\n\\n          for(int i = 1; i < dp.length; i++) {\\n              for(int j = 1; j < dp[0].length; j++) {\\n                  if(arr1[i - 1] == arr2[j - 1])\\n                     dp[i][j] = dp[i - 1][j - 1] + 1;\\n                  if(dp[i][j] > ans)\\n                      ans = dp[i][j];\\n              }\\n          }\\n          return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1574172,
                "title": "c-dp-approach",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int findLength(vector<int> &nums1, vector<int> &nums2)\\n    {\\n        int maxi = 0;\\n        vector<vector<int>> dp(nums1.size()+1, vector<int>(nums2.size()+1,0));\\n           \\n        for (int i = nums1.size() - 1; i >= 0; i--)\\n        {\\n            for (int j = nums2.size() - 1; j >= 0; j--)\\n            {\\n                if (nums1[i] == nums2[j])\\n                {\\n                    dp[i][j] = dp[i + 1][j + 1] + 1;\\n                }\\n                maxi = max(dp[i][j], maxi);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int findLength(vector<int> &nums1, vector<int> &nums2)\\n    {\\n        int maxi = 0;\\n        vector<vector<int>> dp(nums1.size()+1, vector<int>(nums2.size()+1,0));\\n           \\n        for (int i = nums1.size() - 1; i >= 0; i--)\\n        {\\n            for (int j = nums2.size() - 1; j >= 0; j--)\\n            {\\n                if (nums1[i] == nums2[j])\\n                {\\n                    dp[i][j] = dp[i + 1][j + 1] + 1;\\n                }\\n                maxi = max(dp[i][j], maxi);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1542335,
                "title": "why-does-memoized-recursion-tle-in-python",
                "content": "Would appreciate any feedback on why this isn\\'t optimal:\\n\\n```\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        maxLen = 0\\n        \\n        cache = {}\\n        def findLenStartingFrom(ndx1: int, ndx2: int) -> int:\\n            nonlocal cache\\n            nonlocal maxLen\\n\\n            if (ndx1, ndx2) in cache:\\n                return cache[(ndx1, ndx2)]\\n                        \\n            if ndx1 >= len(nums1) or ndx2 >= len(nums2):\\n                return 0\\n            \\n            if nums1[ndx1] == nums2[ndx2]:\\n                result = 1 + findLenStartingFrom(ndx1 + 1, ndx2 + 1)\\n                maxLen = max(maxLen, result)\\n            else:\\n                result = 0\\n            \\n            cache[(ndx1, ndx2)] = result\\n            \\n            findLenStartingFrom(ndx1 + 1, ndx2)\\n            findLenStartingFrom(ndx1, ndx2 + 1)\\n            \\n            return result\\n\\n        findLenStartingFrom(0, 0)\\n        return maxLen\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        maxLen = 0\\n        \\n        cache = {}\\n        def findLenStartingFrom(ndx1: int, ndx2: int) -> int:\\n            nonlocal cache\\n            nonlocal maxLen\\n\\n            if (ndx1, ndx2) in cache:\\n                return cache[(ndx1, ndx2)]\\n                        \\n            if ndx1 >= len(nums1) or ndx2 >= len(nums2):\\n                return 0\\n            \\n            if nums1[ndx1] == nums2[ndx2]:\\n                result = 1 + findLenStartingFrom(ndx1 + 1, ndx2 + 1)\\n                maxLen = max(maxLen, result)\\n            else:\\n                result = 0\\n            \\n            cache[(ndx1, ndx2)] = result\\n            \\n            findLenStartingFrom(ndx1 + 1, ndx2)\\n            findLenStartingFrom(ndx1, ndx2 + 1)\\n            \\n            return result\\n\\n        findLenStartingFrom(0, 0)\\n        return maxLen\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460366,
                "title": "c-runtime-o-m-n-and-space-o-1-optimal-space",
                "content": "While there are a lot of posts that show an O(M\\\\*N) runtime algorithm, most use an array or a matrix. This algorithm\\'s runtime complexity is exactly O(M\\\\*N) and its memory complexity is O(1).\\n\\nThe idea is to slide one array over the other and go through their overlapping parts to find the longest common subarray.\\n\\n```\\nclass Solution {\\n    \\npublic:\\n    \\n    /* Runtime: O(M*N) */\\n    /* Memory: O(1) */\\n    int findLength(const vector<int>& s1, const vector<int>& s2) {\\n        \\n        int max_len = 0;\\n\\n\\t\\t// Consider every possible starting index for the second array.\\n\\t\\t// The second array can start right at the end of the first array \\n\\t\\t// so the second array\\'s first element overlaps with the first array\\'s last element.\\n\\t\\t// Or the second array can start before the first array such that only\\n\\t\\t// the last element of the second array overlaps with the first array\\'s first element.\\n        for(int i = s1.size() - 1; -i < int(s2.size()); i--){\\n\\n            int cur_len = 0; // represents a local count\\n\\n            int j = (i >= 0) ? 0 : -i; // Start with the first overlapping index\\n\\n            for(; j < s2.size() && (i + j) < s1.size(); j++){ // iterate until the last overlapping index\\n\\n                if(s1[i + j] != s2[j]){\\n                  cur_len = 0; // reset the local count\\n                }else{\\n                  cur_len++;\\n                  max_len = max(max_len, cur_len);\\n                }\\n                \\n            }\\n\\t\\t\\t\\n        }\\n\\n        return max_len;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    \\n    /* Runtime: O(M*N) */\\n    /* Memory: O(1) */\\n    int findLength(const vector<int>& s1, const vector<int>& s2) {\\n        \\n        int max_len = 0;\\n\\n\\t\\t// Consider every possible starting index for the second array.\\n\\t\\t// The second array can start right at the end of the first array \\n\\t\\t// so the second array\\'s first element overlaps with the first array\\'s last element.\\n\\t\\t// Or the second array can start before the first array such that only\\n\\t\\t// the last element of the second array overlaps with the first array\\'s first element.\\n        for(int i = s1.size() - 1; -i < int(s2.size()); i--){\\n\\n            int cur_len = 0; // represents a local count\\n\\n            int j = (i >= 0) ? 0 : -i; // Start with the first overlapping index\\n\\n            for(; j < s2.size() && (i + j) < s1.size(); j++){ // iterate until the last overlapping index\\n\\n                if(s1[i + j] != s2[j]){\\n                  cur_len = 0; // reset the local count\\n                }else{\\n                  cur_len++;\\n                  max_len = max(max_len, cur_len);\\n                }\\n                \\n            }\\n\\t\\t\\t\\n        }\\n\\n        return max_len;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1449088,
                "title": "simple-python-o-mn-dynamic-programming-solution",
                "content": "```Python\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        # let dp[i][j] be the maximum length of repeated subarray\\n        # ending with the ith element in nums1 and jth element in nums2\\n        # state transition:\\n        # dp[i][j] = dp[i-1][j-1]+1     if nums[i-1] == nums[j-1]\\n        # dp[i][j] = 0                  otherwise\\n        m, n = len(nums1), len(nums2)\\n        dp = [[0]*(n+1) for _ in range(m+1)]\\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if nums1[i-1] == nums2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]+1\\n        return max(max(row) for row in dp)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```Python\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        # let dp[i][j] be the maximum length of repeated subarray\\n        # ending with the ith element in nums1 and jth element in nums2\\n        # state transition:\\n        # dp[i][j] = dp[i-1][j-1]+1     if nums[i-1] == nums[j-1]\\n        # dp[i][j] = 0                  otherwise\\n        m, n = len(nums1), len(nums2)\\n        dp = [[0]*(n+1) for _ in range(m+1)]\\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if nums1[i-1] == nums2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]+1\\n        return max(max(row) for row in dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448392,
                "title": "simple-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size(),m=nums2.size();\\n        int dp[n+1][m+1],r=0;\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=m;j++){\\n                if(i==0||j==0)\\n                    dp[i][j]=0;\\n                else if(nums1[i-1]==nums2[j-1])\\n                {    \\n                    dp[i][j]=1+dp[i-1][j-1];\\n                    r=max(dp[i][j],r);\\n                }\\n                else\\n                    dp[i][j]=0;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```\\n**please consider upvote if you understand this solution**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size(),m=nums2.size();\\n        int dp[n+1][m+1],r=0;\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=m;j++){\\n                if(i==0||j==0)\\n                    dp[i][j]=0;\\n                else if(nums1[i-1]==nums2[j-1])\\n                {    \\n                    dp[i][j]=1+dp[i-1][j-1];\\n                    r=max(dp[i][j],r);\\n                }\\n                else\\n                    dp[i][j]=0;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326459,
                "title": "python3-rolling-hash-faster-than-98",
                "content": "# Explanation\\n**Generating hash for a given input**\\nBoth the arrays can be represented in the form of polynomial. For instance, \\nnums1 = [1,2,3,4], nums2 = [2,3,4,5]\\nnums1 = 1 + 2p + 3p^2 + 4p^3 \\nnums2 = 2 + 3p + 4p^2 + 5p^4\\nIt is reasonable to make *p* equal to a prime bigger than the alphabet size (i.e 100) and since 101 is a prime, *p = 101*. In the worst case the hash can be as large as 1000 (length of input) * 100 (value of each input) * ((101)^1000 - 1)/100 (Geometric series for the growth of prime *p*), which will be a number approximately 3000 digits long. Therefore, we use modulo arithmetic to generate a hash which can fit within a 32 bit integer. Hence, \\nnums1 = (1 + 2p + 3p^2 + 4p^3 )%mod\\nnums2 = (2 + 3p + 4p^2 + 5p^4)%mod\\nThe probablity of two random strings having the same hash is 1/mod, where mod (in this case) = 10^9 + 7. \\n\\n**Generating hash for all the substrings of length M**\\n\\nLet nums1 = [1,2,3,4,5] and M = 2. The polynomial form of nums1 = (1 + 2p + 3p^2 + 4p^3 + 5p^4)%mod. We use sliding window to calculate hash for each substring of length M, first find the hash for the first M elements, t = (1+2p)%mod. When we move the sliding window one-step ahead, the elements are [2,3] and hence the hash has to be (2+3p)%mod. To arrive at the previous step we can subtract 1 from t, which gives us t = (2p)%mod and then divide t by p (basically multiply t by modular inverse of p), t = (2)%mod and finally add 3p, t = (2+3p)%mod. We can write the general version of this approach to give us hashes of all the substrings of length M.\\n\\n**Binary search for the longest length**\\nLargest length of the common substring possible is r = min(len(nums1),len(nums2)) and the smallest being l = 0, we find the common substrings with same hash of length = mid  = (l+r)/2. If there aren\\'t any common hash in the intersection, then the longest common substring is smaller than mid otherwise the length is larger than mid, we repeat the above step until l<r.\\n\\n**Time complexity**\\nLet,\\nn = len(nums1)\\nm = len(nums2)\\nGenerating powers of p = O(max(n,m))\\nRabin karp = O(len(arr))\\nBinary search  = O(log(min(n,m)))\\nSet intersection = O(min(n,m))\\n**Overall complexity** = O(max(n,m)+ ((n+m)+min(n,m))*log(min(n,m))) = O((n+m)*log(min(n,m)))\\n\\n\\n```\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        p = 101\\n        mod = 10**9+7\\n        # Find inverse of p using fermat\\'s little theorem\\n        inv = pow(p,mod-2,mod)\\n        n,m = len(nums1),len(nums2)\\n        N = max(n,m)\\n        p_ = [0]*N\\n        p_[0] = 1\\n        # Calculate p**i for 1<=i<N\\n        for i in range(1,N):\\n            p_[i] = (p_[i-1]*p)%mod\\n        def rabin_karp(arr,M):\\n            t = 0\\n            hashes = set()\\n            for i in range(M):\\n                t = (t+arr[i]*p_[i])%mod\\n            hashes.add(t)\\n            for i in range(1,len(arr)-M+1):\\n                # Remove the first number from the window\\n                t = (t-arr[i-1])%mod\\n                # Divide the entire window by p\\n                t = (t*inv)%mod\\n                # Add the new number to the window\\n                t = (t+arr[i+M-1]*p_[M-1])%mod\\n                hashes.add(t)\\n            return hashes\\n        l = 0\\n        r = min(n,m)+1\\n        while l<r:\\n            mid = (l+r)//2\\n            tt = set.intersection(*[rabin_karp(arr,mid) for arr in [nums1,nums2]])\\n            if len(tt)!=0:\\n                l = mid+1\\n            else:\\n                r = mid\\n        return l-1",
                "solutionTags": [],
                "code": "# Explanation\\n**Generating hash for a given input**\\nBoth the arrays can be represented in the form of polynomial. For instance, \\nnums1 = [1,2,3,4], nums2 = [2,3,4,5]\\nnums1 = 1 + 2p + 3p^2 + 4p^3 \\nnums2 = 2 + 3p + 4p^2 + 5p^4\\nIt is reasonable to make *p* equal to a prime bigger than the alphabet size (i.e 100) and since 101 is a prime, *p = 101*. In the worst case the hash can be as large as 1000 (length of input) * 100 (value of each input) * ((101)^1000 - 1)/100 (Geometric series for the growth of prime *p*), which will be a number approximately 3000 digits long. Therefore, we use modulo arithmetic to generate a hash which can fit within a 32 bit integer. Hence, \\nnums1 = (1 + 2p + 3p^2 + 4p^3 )%mod\\nnums2 = (2 + 3p + 4p^2 + 5p^4)%mod\\nThe probablity of two random strings having the same hash is 1/mod, where mod (in this case) = 10^9 + 7. \\n\\n**Generating hash for all the substrings of length M**\\n\\nLet nums1 = [1,2,3,4,5] and M = 2. The polynomial form of nums1 = (1 + 2p + 3p^2 + 4p^3 + 5p^4)%mod. We use sliding window to calculate hash for each substring of length M, first find the hash for the first M elements, t = (1+2p)%mod. When we move the sliding window one-step ahead, the elements are [2,3] and hence the hash has to be (2+3p)%mod. To arrive at the previous step we can subtract 1 from t, which gives us t = (2p)%mod and then divide t by p (basically multiply t by modular inverse of p), t = (2)%mod and finally add 3p, t = (2+3p)%mod. We can write the general version of this approach to give us hashes of all the substrings of length M.\\n\\n**Binary search for the longest length**\\nLargest length of the common substring possible is r = min(len(nums1),len(nums2)) and the smallest being l = 0, we find the common substrings with same hash of length = mid  = (l+r)/2. If there aren\\'t any common hash in the intersection, then the longest common substring is smaller than mid otherwise the length is larger than mid, we repeat the above step until l<r.\\n\\n**Time complexity**\\nLet,\\nn = len(nums1)\\nm = len(nums2)\\nGenerating powers of p = O(max(n,m))\\nRabin karp = O(len(arr))\\nBinary search  = O(log(min(n,m)))\\nSet intersection = O(min(n,m))\\n**Overall complexity** = O(max(n,m)+ ((n+m)+min(n,m))*log(min(n,m))) = O((n+m)*log(min(n,m)))\\n\\n\\n```\\nclass Solution:\\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\\n        p = 101\\n        mod = 10**9+7\\n        # Find inverse of p using fermat\\'s little theorem\\n        inv = pow(p,mod-2,mod)\\n        n,m = len(nums1),len(nums2)\\n        N = max(n,m)\\n        p_ = [0]*N\\n        p_[0] = 1\\n        # Calculate p**i for 1<=i<N\\n        for i in range(1,N):\\n            p_[i] = (p_[i-1]*p)%mod\\n        def rabin_karp(arr,M):\\n            t = 0\\n            hashes = set()\\n            for i in range(M):\\n                t = (t+arr[i]*p_[i])%mod\\n            hashes.add(t)\\n            for i in range(1,len(arr)-M+1):\\n                # Remove the first number from the window\\n                t = (t-arr[i-1])%mod\\n                # Divide the entire window by p\\n                t = (t*inv)%mod\\n                # Add the new number to the window\\n                t = (t+arr[i+M-1]*p_[M-1])%mod\\n                hashes.add(t)\\n            return hashes\\n        l = 0\\n        r = min(n,m)+1\\n        while l<r:\\n            mid = (l+r)//2\\n            tt = set.intersection(*[rabin_karp(arr,mid) for arr in [nums1,nums2]])\\n            if len(tt)!=0:\\n                l = mid+1\\n            else:\\n                r = mid\\n        return l-1",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1918650,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "LCS variation"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Longest Common Subarray"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "for input : nums1 =[0,0,0,0,0,0,1,0,0,0] ,nums2=[0,0,0,0,0,0,0,1,0,0] my code giving output 6 ,but expected output is 9,anyone can explain please."
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Then your code is wrong,\\nfor nums1 of index 0 to 8 == nums2 of index 1 to 9.\\nso answer is 9.\\n\\nfind subarray which is from any index to any index."
                    },
                    {
                        "username": "sarthak_44",
                        "content": "I tried solving it using DP but for this test case its giving wrong answer. Can someone tell my why it\\'s happening? \\n`class Solution {\\npublic:\\n\\n    int solve(string &a,string &b,vector<vector<int>>&dp,int n,int m){\\n\\n        if(n==0 or m==0) return 0;\\n        if(dp[n][m]!=-1) return dp[n][m];\\n\\n        if(a[n-1]==b[m-1]){\\n            dp[n][m]=1+solve(a,b,dp,n-1,m-1);\\n        }\\n\\n        else dp[n][m]=max(solve(a,b,dp,n-1,m),solve(a,b,dp,n,m-1));\\n\\n        return dp[n][m];\\n\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n\\n        string a=\"\",b=\"\";\\n        for(auto i:nums1){\\n            a+=to_string(i);\\n        } \\n        \\n        for(auto i:nums2){\\n            b+=to_string(i);\\n        } \\n\\n        int n = a.size();\\n        int m = b.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        // cout<<a<<\" \"<<b;\\n        return solve(a,b,dp,n,m);\\n\\n        return 0;\\n    }};\\n\\ntest case is nums1= [0,1,1,1,1] and nums2=[1,0,1,0,1]"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is a problem of substring not subsequence.\\nans should be consecutive that why you missed it...."
                    },
                    {
                        "username": "hejiafu0109",
                        "content": "mine is 3, which is a wrong answer"
                    },
                    {
                        "username": "srujan1234",
                        "content": "yes"
                    },
                    {
                        "username": "shasha2010027",
                        "content": " Wrong Approaches you might be thinking:\\n1. Sort and count the number of equal elements, nope as sorting changes the relative order of elements.\\n2. Run a loop from i=0 to min of size of given arrays and compare each index, if equal than increase count,\\nNope as index need not to be same in both arrays.\\n\\nApproach should be how would you solve Longest common substring problem using DP.\\n(which can be thought of from idea of LCS kind)."
                    },
                    {
                        "username": "ymgcksge",
                        "content": "nums1 and nums2 always have the same size?"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "It is not necessary, nums1 and nums2 have same size\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "It is not mentioned in question. So NO!"
                    },
                    {
                        "username": "rajender7",
                        "content": "No not necessarily."
                    },
                    {
                        "username": "Limon020",
                        "content": "Draw out the 2d comparison grid and you will probably see the solution emerge "
                    },
                    {
                        "username": "anupjaiswal",
                        "content": "is it possible to solve without dynamic programming ? "
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "Input\\nnums1 =\\n[0,0,0,0,1]\\nnums2 =\\n[1,0,0,0,0]\\n\\nOutput\\n5\\nExpected\\n4\\nWhy 4??? As both are same, it should be 5? I am kinda confused."
                    },
                    {
                        "username": "NNP3",
                        "content": "May be hint - Longest Common Substring variant! \n "
                    }
                ]
            },
            {
                "id": 1804494,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "LCS variation"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Longest Common Subarray"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "for input : nums1 =[0,0,0,0,0,0,1,0,0,0] ,nums2=[0,0,0,0,0,0,0,1,0,0] my code giving output 6 ,but expected output is 9,anyone can explain please."
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Then your code is wrong,\\nfor nums1 of index 0 to 8 == nums2 of index 1 to 9.\\nso answer is 9.\\n\\nfind subarray which is from any index to any index."
                    },
                    {
                        "username": "sarthak_44",
                        "content": "I tried solving it using DP but for this test case its giving wrong answer. Can someone tell my why it\\'s happening? \\n`class Solution {\\npublic:\\n\\n    int solve(string &a,string &b,vector<vector<int>>&dp,int n,int m){\\n\\n        if(n==0 or m==0) return 0;\\n        if(dp[n][m]!=-1) return dp[n][m];\\n\\n        if(a[n-1]==b[m-1]){\\n            dp[n][m]=1+solve(a,b,dp,n-1,m-1);\\n        }\\n\\n        else dp[n][m]=max(solve(a,b,dp,n-1,m),solve(a,b,dp,n,m-1));\\n\\n        return dp[n][m];\\n\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n\\n        string a=\"\",b=\"\";\\n        for(auto i:nums1){\\n            a+=to_string(i);\\n        } \\n        \\n        for(auto i:nums2){\\n            b+=to_string(i);\\n        } \\n\\n        int n = a.size();\\n        int m = b.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        // cout<<a<<\" \"<<b;\\n        return solve(a,b,dp,n,m);\\n\\n        return 0;\\n    }};\\n\\ntest case is nums1= [0,1,1,1,1] and nums2=[1,0,1,0,1]"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is a problem of substring not subsequence.\\nans should be consecutive that why you missed it...."
                    },
                    {
                        "username": "hejiafu0109",
                        "content": "mine is 3, which is a wrong answer"
                    },
                    {
                        "username": "srujan1234",
                        "content": "yes"
                    },
                    {
                        "username": "shasha2010027",
                        "content": " Wrong Approaches you might be thinking:\\n1. Sort and count the number of equal elements, nope as sorting changes the relative order of elements.\\n2. Run a loop from i=0 to min of size of given arrays and compare each index, if equal than increase count,\\nNope as index need not to be same in both arrays.\\n\\nApproach should be how would you solve Longest common substring problem using DP.\\n(which can be thought of from idea of LCS kind)."
                    },
                    {
                        "username": "ymgcksge",
                        "content": "nums1 and nums2 always have the same size?"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "It is not necessary, nums1 and nums2 have same size\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "It is not mentioned in question. So NO!"
                    },
                    {
                        "username": "rajender7",
                        "content": "No not necessarily."
                    },
                    {
                        "username": "Limon020",
                        "content": "Draw out the 2d comparison grid and you will probably see the solution emerge "
                    },
                    {
                        "username": "anupjaiswal",
                        "content": "is it possible to solve without dynamic programming ? "
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "Input\\nnums1 =\\n[0,0,0,0,1]\\nnums2 =\\n[1,0,0,0,0]\\n\\nOutput\\n5\\nExpected\\n4\\nWhy 4??? As both are same, it should be 5? I am kinda confused."
                    },
                    {
                        "username": "NNP3",
                        "content": "May be hint - Longest Common Substring variant! \n "
                    }
                ]
            },
            {
                "id": 1828391,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "LCS variation"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Longest Common Subarray"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "for input : nums1 =[0,0,0,0,0,0,1,0,0,0] ,nums2=[0,0,0,0,0,0,0,1,0,0] my code giving output 6 ,but expected output is 9,anyone can explain please."
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Then your code is wrong,\\nfor nums1 of index 0 to 8 == nums2 of index 1 to 9.\\nso answer is 9.\\n\\nfind subarray which is from any index to any index."
                    },
                    {
                        "username": "sarthak_44",
                        "content": "I tried solving it using DP but for this test case its giving wrong answer. Can someone tell my why it\\'s happening? \\n`class Solution {\\npublic:\\n\\n    int solve(string &a,string &b,vector<vector<int>>&dp,int n,int m){\\n\\n        if(n==0 or m==0) return 0;\\n        if(dp[n][m]!=-1) return dp[n][m];\\n\\n        if(a[n-1]==b[m-1]){\\n            dp[n][m]=1+solve(a,b,dp,n-1,m-1);\\n        }\\n\\n        else dp[n][m]=max(solve(a,b,dp,n-1,m),solve(a,b,dp,n,m-1));\\n\\n        return dp[n][m];\\n\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n\\n        string a=\"\",b=\"\";\\n        for(auto i:nums1){\\n            a+=to_string(i);\\n        } \\n        \\n        for(auto i:nums2){\\n            b+=to_string(i);\\n        } \\n\\n        int n = a.size();\\n        int m = b.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        // cout<<a<<\" \"<<b;\\n        return solve(a,b,dp,n,m);\\n\\n        return 0;\\n    }};\\n\\ntest case is nums1= [0,1,1,1,1] and nums2=[1,0,1,0,1]"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is a problem of substring not subsequence.\\nans should be consecutive that why you missed it...."
                    },
                    {
                        "username": "hejiafu0109",
                        "content": "mine is 3, which is a wrong answer"
                    },
                    {
                        "username": "srujan1234",
                        "content": "yes"
                    },
                    {
                        "username": "shasha2010027",
                        "content": " Wrong Approaches you might be thinking:\\n1. Sort and count the number of equal elements, nope as sorting changes the relative order of elements.\\n2. Run a loop from i=0 to min of size of given arrays and compare each index, if equal than increase count,\\nNope as index need not to be same in both arrays.\\n\\nApproach should be how would you solve Longest common substring problem using DP.\\n(which can be thought of from idea of LCS kind)."
                    },
                    {
                        "username": "ymgcksge",
                        "content": "nums1 and nums2 always have the same size?"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "It is not necessary, nums1 and nums2 have same size\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "It is not mentioned in question. So NO!"
                    },
                    {
                        "username": "rajender7",
                        "content": "No not necessarily."
                    },
                    {
                        "username": "Limon020",
                        "content": "Draw out the 2d comparison grid and you will probably see the solution emerge "
                    },
                    {
                        "username": "anupjaiswal",
                        "content": "is it possible to solve without dynamic programming ? "
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "Input\\nnums1 =\\n[0,0,0,0,1]\\nnums2 =\\n[1,0,0,0,0]\\n\\nOutput\\n5\\nExpected\\n4\\nWhy 4??? As both are same, it should be 5? I am kinda confused."
                    },
                    {
                        "username": "NNP3",
                        "content": "May be hint - Longest Common Substring variant! \n "
                    }
                ]
            },
            {
                "id": 1571811,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "LCS variation"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Longest Common Subarray"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "for input : nums1 =[0,0,0,0,0,0,1,0,0,0] ,nums2=[0,0,0,0,0,0,0,1,0,0] my code giving output 6 ,but expected output is 9,anyone can explain please."
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Then your code is wrong,\\nfor nums1 of index 0 to 8 == nums2 of index 1 to 9.\\nso answer is 9.\\n\\nfind subarray which is from any index to any index."
                    },
                    {
                        "username": "sarthak_44",
                        "content": "I tried solving it using DP but for this test case its giving wrong answer. Can someone tell my why it\\'s happening? \\n`class Solution {\\npublic:\\n\\n    int solve(string &a,string &b,vector<vector<int>>&dp,int n,int m){\\n\\n        if(n==0 or m==0) return 0;\\n        if(dp[n][m]!=-1) return dp[n][m];\\n\\n        if(a[n-1]==b[m-1]){\\n            dp[n][m]=1+solve(a,b,dp,n-1,m-1);\\n        }\\n\\n        else dp[n][m]=max(solve(a,b,dp,n-1,m),solve(a,b,dp,n,m-1));\\n\\n        return dp[n][m];\\n\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n\\n        string a=\"\",b=\"\";\\n        for(auto i:nums1){\\n            a+=to_string(i);\\n        } \\n        \\n        for(auto i:nums2){\\n            b+=to_string(i);\\n        } \\n\\n        int n = a.size();\\n        int m = b.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        // cout<<a<<\" \"<<b;\\n        return solve(a,b,dp,n,m);\\n\\n        return 0;\\n    }};\\n\\ntest case is nums1= [0,1,1,1,1] and nums2=[1,0,1,0,1]"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is a problem of substring not subsequence.\\nans should be consecutive that why you missed it...."
                    },
                    {
                        "username": "hejiafu0109",
                        "content": "mine is 3, which is a wrong answer"
                    },
                    {
                        "username": "srujan1234",
                        "content": "yes"
                    },
                    {
                        "username": "shasha2010027",
                        "content": " Wrong Approaches you might be thinking:\\n1. Sort and count the number of equal elements, nope as sorting changes the relative order of elements.\\n2. Run a loop from i=0 to min of size of given arrays and compare each index, if equal than increase count,\\nNope as index need not to be same in both arrays.\\n\\nApproach should be how would you solve Longest common substring problem using DP.\\n(which can be thought of from idea of LCS kind)."
                    },
                    {
                        "username": "ymgcksge",
                        "content": "nums1 and nums2 always have the same size?"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "It is not necessary, nums1 and nums2 have same size\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "It is not mentioned in question. So NO!"
                    },
                    {
                        "username": "rajender7",
                        "content": "No not necessarily."
                    },
                    {
                        "username": "Limon020",
                        "content": "Draw out the 2d comparison grid and you will probably see the solution emerge "
                    },
                    {
                        "username": "anupjaiswal",
                        "content": "is it possible to solve without dynamic programming ? "
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "Input\\nnums1 =\\n[0,0,0,0,1]\\nnums2 =\\n[1,0,0,0,0]\\n\\nOutput\\n5\\nExpected\\n4\\nWhy 4??? As both are same, it should be 5? I am kinda confused."
                    },
                    {
                        "username": "NNP3",
                        "content": "May be hint - Longest Common Substring variant! \n "
                    }
                ]
            },
            {
                "id": 1816324,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "LCS variation"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Longest Common Subarray"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "for input : nums1 =[0,0,0,0,0,0,1,0,0,0] ,nums2=[0,0,0,0,0,0,0,1,0,0] my code giving output 6 ,but expected output is 9,anyone can explain please."
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Then your code is wrong,\\nfor nums1 of index 0 to 8 == nums2 of index 1 to 9.\\nso answer is 9.\\n\\nfind subarray which is from any index to any index."
                    },
                    {
                        "username": "sarthak_44",
                        "content": "I tried solving it using DP but for this test case its giving wrong answer. Can someone tell my why it\\'s happening? \\n`class Solution {\\npublic:\\n\\n    int solve(string &a,string &b,vector<vector<int>>&dp,int n,int m){\\n\\n        if(n==0 or m==0) return 0;\\n        if(dp[n][m]!=-1) return dp[n][m];\\n\\n        if(a[n-1]==b[m-1]){\\n            dp[n][m]=1+solve(a,b,dp,n-1,m-1);\\n        }\\n\\n        else dp[n][m]=max(solve(a,b,dp,n-1,m),solve(a,b,dp,n,m-1));\\n\\n        return dp[n][m];\\n\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n\\n        string a=\"\",b=\"\";\\n        for(auto i:nums1){\\n            a+=to_string(i);\\n        } \\n        \\n        for(auto i:nums2){\\n            b+=to_string(i);\\n        } \\n\\n        int n = a.size();\\n        int m = b.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        // cout<<a<<\" \"<<b;\\n        return solve(a,b,dp,n,m);\\n\\n        return 0;\\n    }};\\n\\ntest case is nums1= [0,1,1,1,1] and nums2=[1,0,1,0,1]"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is a problem of substring not subsequence.\\nans should be consecutive that why you missed it...."
                    },
                    {
                        "username": "hejiafu0109",
                        "content": "mine is 3, which is a wrong answer"
                    },
                    {
                        "username": "srujan1234",
                        "content": "yes"
                    },
                    {
                        "username": "shasha2010027",
                        "content": " Wrong Approaches you might be thinking:\\n1. Sort and count the number of equal elements, nope as sorting changes the relative order of elements.\\n2. Run a loop from i=0 to min of size of given arrays and compare each index, if equal than increase count,\\nNope as index need not to be same in both arrays.\\n\\nApproach should be how would you solve Longest common substring problem using DP.\\n(which can be thought of from idea of LCS kind)."
                    },
                    {
                        "username": "ymgcksge",
                        "content": "nums1 and nums2 always have the same size?"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "It is not necessary, nums1 and nums2 have same size\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "It is not mentioned in question. So NO!"
                    },
                    {
                        "username": "rajender7",
                        "content": "No not necessarily."
                    },
                    {
                        "username": "Limon020",
                        "content": "Draw out the 2d comparison grid and you will probably see the solution emerge "
                    },
                    {
                        "username": "anupjaiswal",
                        "content": "is it possible to solve without dynamic programming ? "
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "Input\\nnums1 =\\n[0,0,0,0,1]\\nnums2 =\\n[1,0,0,0,0]\\n\\nOutput\\n5\\nExpected\\n4\\nWhy 4??? As both are same, it should be 5? I am kinda confused."
                    },
                    {
                        "username": "NNP3",
                        "content": "May be hint - Longest Common Substring variant! \n "
                    }
                ]
            },
            {
                "id": 1761505,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "LCS variation"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Longest Common Subarray"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "for input : nums1 =[0,0,0,0,0,0,1,0,0,0] ,nums2=[0,0,0,0,0,0,0,1,0,0] my code giving output 6 ,but expected output is 9,anyone can explain please."
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Then your code is wrong,\\nfor nums1 of index 0 to 8 == nums2 of index 1 to 9.\\nso answer is 9.\\n\\nfind subarray which is from any index to any index."
                    },
                    {
                        "username": "sarthak_44",
                        "content": "I tried solving it using DP but for this test case its giving wrong answer. Can someone tell my why it\\'s happening? \\n`class Solution {\\npublic:\\n\\n    int solve(string &a,string &b,vector<vector<int>>&dp,int n,int m){\\n\\n        if(n==0 or m==0) return 0;\\n        if(dp[n][m]!=-1) return dp[n][m];\\n\\n        if(a[n-1]==b[m-1]){\\n            dp[n][m]=1+solve(a,b,dp,n-1,m-1);\\n        }\\n\\n        else dp[n][m]=max(solve(a,b,dp,n-1,m),solve(a,b,dp,n,m-1));\\n\\n        return dp[n][m];\\n\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n\\n        string a=\"\",b=\"\";\\n        for(auto i:nums1){\\n            a+=to_string(i);\\n        } \\n        \\n        for(auto i:nums2){\\n            b+=to_string(i);\\n        } \\n\\n        int n = a.size();\\n        int m = b.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        // cout<<a<<\" \"<<b;\\n        return solve(a,b,dp,n,m);\\n\\n        return 0;\\n    }};\\n\\ntest case is nums1= [0,1,1,1,1] and nums2=[1,0,1,0,1]"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is a problem of substring not subsequence.\\nans should be consecutive that why you missed it...."
                    },
                    {
                        "username": "hejiafu0109",
                        "content": "mine is 3, which is a wrong answer"
                    },
                    {
                        "username": "srujan1234",
                        "content": "yes"
                    },
                    {
                        "username": "shasha2010027",
                        "content": " Wrong Approaches you might be thinking:\\n1. Sort and count the number of equal elements, nope as sorting changes the relative order of elements.\\n2. Run a loop from i=0 to min of size of given arrays and compare each index, if equal than increase count,\\nNope as index need not to be same in both arrays.\\n\\nApproach should be how would you solve Longest common substring problem using DP.\\n(which can be thought of from idea of LCS kind)."
                    },
                    {
                        "username": "ymgcksge",
                        "content": "nums1 and nums2 always have the same size?"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "It is not necessary, nums1 and nums2 have same size\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "It is not mentioned in question. So NO!"
                    },
                    {
                        "username": "rajender7",
                        "content": "No not necessarily."
                    },
                    {
                        "username": "Limon020",
                        "content": "Draw out the 2d comparison grid and you will probably see the solution emerge "
                    },
                    {
                        "username": "anupjaiswal",
                        "content": "is it possible to solve without dynamic programming ? "
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "Input\\nnums1 =\\n[0,0,0,0,1]\\nnums2 =\\n[1,0,0,0,0]\\n\\nOutput\\n5\\nExpected\\n4\\nWhy 4??? As both are same, it should be 5? I am kinda confused."
                    },
                    {
                        "username": "NNP3",
                        "content": "May be hint - Longest Common Substring variant! \n "
                    }
                ]
            },
            {
                "id": 2074824,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "LCS variation"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Longest Common Subarray"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "for input : nums1 =[0,0,0,0,0,0,1,0,0,0] ,nums2=[0,0,0,0,0,0,0,1,0,0] my code giving output 6 ,but expected output is 9,anyone can explain please."
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Then your code is wrong,\\nfor nums1 of index 0 to 8 == nums2 of index 1 to 9.\\nso answer is 9.\\n\\nfind subarray which is from any index to any index."
                    },
                    {
                        "username": "sarthak_44",
                        "content": "I tried solving it using DP but for this test case its giving wrong answer. Can someone tell my why it\\'s happening? \\n`class Solution {\\npublic:\\n\\n    int solve(string &a,string &b,vector<vector<int>>&dp,int n,int m){\\n\\n        if(n==0 or m==0) return 0;\\n        if(dp[n][m]!=-1) return dp[n][m];\\n\\n        if(a[n-1]==b[m-1]){\\n            dp[n][m]=1+solve(a,b,dp,n-1,m-1);\\n        }\\n\\n        else dp[n][m]=max(solve(a,b,dp,n-1,m),solve(a,b,dp,n,m-1));\\n\\n        return dp[n][m];\\n\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n\\n        string a=\"\",b=\"\";\\n        for(auto i:nums1){\\n            a+=to_string(i);\\n        } \\n        \\n        for(auto i:nums2){\\n            b+=to_string(i);\\n        } \\n\\n        int n = a.size();\\n        int m = b.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        // cout<<a<<\" \"<<b;\\n        return solve(a,b,dp,n,m);\\n\\n        return 0;\\n    }};\\n\\ntest case is nums1= [0,1,1,1,1] and nums2=[1,0,1,0,1]"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is a problem of substring not subsequence.\\nans should be consecutive that why you missed it...."
                    },
                    {
                        "username": "hejiafu0109",
                        "content": "mine is 3, which is a wrong answer"
                    },
                    {
                        "username": "srujan1234",
                        "content": "yes"
                    },
                    {
                        "username": "shasha2010027",
                        "content": " Wrong Approaches you might be thinking:\\n1. Sort and count the number of equal elements, nope as sorting changes the relative order of elements.\\n2. Run a loop from i=0 to min of size of given arrays and compare each index, if equal than increase count,\\nNope as index need not to be same in both arrays.\\n\\nApproach should be how would you solve Longest common substring problem using DP.\\n(which can be thought of from idea of LCS kind)."
                    },
                    {
                        "username": "ymgcksge",
                        "content": "nums1 and nums2 always have the same size?"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "It is not necessary, nums1 and nums2 have same size\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "It is not mentioned in question. So NO!"
                    },
                    {
                        "username": "rajender7",
                        "content": "No not necessarily."
                    },
                    {
                        "username": "Limon020",
                        "content": "Draw out the 2d comparison grid and you will probably see the solution emerge "
                    },
                    {
                        "username": "anupjaiswal",
                        "content": "is it possible to solve without dynamic programming ? "
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "Input\\nnums1 =\\n[0,0,0,0,1]\\nnums2 =\\n[1,0,0,0,0]\\n\\nOutput\\n5\\nExpected\\n4\\nWhy 4??? As both are same, it should be 5? I am kinda confused."
                    },
                    {
                        "username": "NNP3",
                        "content": "May be hint - Longest Common Substring variant! \n "
                    }
                ]
            },
            {
                "id": 2046774,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "LCS variation"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Longest Common Subarray"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "for input : nums1 =[0,0,0,0,0,0,1,0,0,0] ,nums2=[0,0,0,0,0,0,0,1,0,0] my code giving output 6 ,but expected output is 9,anyone can explain please."
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Then your code is wrong,\\nfor nums1 of index 0 to 8 == nums2 of index 1 to 9.\\nso answer is 9.\\n\\nfind subarray which is from any index to any index."
                    },
                    {
                        "username": "sarthak_44",
                        "content": "I tried solving it using DP but for this test case its giving wrong answer. Can someone tell my why it\\'s happening? \\n`class Solution {\\npublic:\\n\\n    int solve(string &a,string &b,vector<vector<int>>&dp,int n,int m){\\n\\n        if(n==0 or m==0) return 0;\\n        if(dp[n][m]!=-1) return dp[n][m];\\n\\n        if(a[n-1]==b[m-1]){\\n            dp[n][m]=1+solve(a,b,dp,n-1,m-1);\\n        }\\n\\n        else dp[n][m]=max(solve(a,b,dp,n-1,m),solve(a,b,dp,n,m-1));\\n\\n        return dp[n][m];\\n\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n\\n        string a=\"\",b=\"\";\\n        for(auto i:nums1){\\n            a+=to_string(i);\\n        } \\n        \\n        for(auto i:nums2){\\n            b+=to_string(i);\\n        } \\n\\n        int n = a.size();\\n        int m = b.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        // cout<<a<<\" \"<<b;\\n        return solve(a,b,dp,n,m);\\n\\n        return 0;\\n    }};\\n\\ntest case is nums1= [0,1,1,1,1] and nums2=[1,0,1,0,1]"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is a problem of substring not subsequence.\\nans should be consecutive that why you missed it...."
                    },
                    {
                        "username": "hejiafu0109",
                        "content": "mine is 3, which is a wrong answer"
                    },
                    {
                        "username": "srujan1234",
                        "content": "yes"
                    },
                    {
                        "username": "shasha2010027",
                        "content": " Wrong Approaches you might be thinking:\\n1. Sort and count the number of equal elements, nope as sorting changes the relative order of elements.\\n2. Run a loop from i=0 to min of size of given arrays and compare each index, if equal than increase count,\\nNope as index need not to be same in both arrays.\\n\\nApproach should be how would you solve Longest common substring problem using DP.\\n(which can be thought of from idea of LCS kind)."
                    },
                    {
                        "username": "ymgcksge",
                        "content": "nums1 and nums2 always have the same size?"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "It is not necessary, nums1 and nums2 have same size\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "It is not mentioned in question. So NO!"
                    },
                    {
                        "username": "rajender7",
                        "content": "No not necessarily."
                    },
                    {
                        "username": "Limon020",
                        "content": "Draw out the 2d comparison grid and you will probably see the solution emerge "
                    },
                    {
                        "username": "anupjaiswal",
                        "content": "is it possible to solve without dynamic programming ? "
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "Input\\nnums1 =\\n[0,0,0,0,1]\\nnums2 =\\n[1,0,0,0,0]\\n\\nOutput\\n5\\nExpected\\n4\\nWhy 4??? As both are same, it should be 5? I am kinda confused."
                    },
                    {
                        "username": "NNP3",
                        "content": "May be hint - Longest Common Substring variant! \n "
                    }
                ]
            },
            {
                "id": 2023173,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "LCS variation"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Longest Common Subarray"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "for input : nums1 =[0,0,0,0,0,0,1,0,0,0] ,nums2=[0,0,0,0,0,0,0,1,0,0] my code giving output 6 ,but expected output is 9,anyone can explain please."
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Then your code is wrong,\\nfor nums1 of index 0 to 8 == nums2 of index 1 to 9.\\nso answer is 9.\\n\\nfind subarray which is from any index to any index."
                    },
                    {
                        "username": "sarthak_44",
                        "content": "I tried solving it using DP but for this test case its giving wrong answer. Can someone tell my why it\\'s happening? \\n`class Solution {\\npublic:\\n\\n    int solve(string &a,string &b,vector<vector<int>>&dp,int n,int m){\\n\\n        if(n==0 or m==0) return 0;\\n        if(dp[n][m]!=-1) return dp[n][m];\\n\\n        if(a[n-1]==b[m-1]){\\n            dp[n][m]=1+solve(a,b,dp,n-1,m-1);\\n        }\\n\\n        else dp[n][m]=max(solve(a,b,dp,n-1,m),solve(a,b,dp,n,m-1));\\n\\n        return dp[n][m];\\n\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n\\n        string a=\"\",b=\"\";\\n        for(auto i:nums1){\\n            a+=to_string(i);\\n        } \\n        \\n        for(auto i:nums2){\\n            b+=to_string(i);\\n        } \\n\\n        int n = a.size();\\n        int m = b.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        // cout<<a<<\" \"<<b;\\n        return solve(a,b,dp,n,m);\\n\\n        return 0;\\n    }};\\n\\ntest case is nums1= [0,1,1,1,1] and nums2=[1,0,1,0,1]"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is a problem of substring not subsequence.\\nans should be consecutive that why you missed it...."
                    },
                    {
                        "username": "hejiafu0109",
                        "content": "mine is 3, which is a wrong answer"
                    },
                    {
                        "username": "srujan1234",
                        "content": "yes"
                    },
                    {
                        "username": "shasha2010027",
                        "content": " Wrong Approaches you might be thinking:\\n1. Sort and count the number of equal elements, nope as sorting changes the relative order of elements.\\n2. Run a loop from i=0 to min of size of given arrays and compare each index, if equal than increase count,\\nNope as index need not to be same in both arrays.\\n\\nApproach should be how would you solve Longest common substring problem using DP.\\n(which can be thought of from idea of LCS kind)."
                    },
                    {
                        "username": "ymgcksge",
                        "content": "nums1 and nums2 always have the same size?"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "It is not necessary, nums1 and nums2 have same size\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "It is not mentioned in question. So NO!"
                    },
                    {
                        "username": "rajender7",
                        "content": "No not necessarily."
                    },
                    {
                        "username": "Limon020",
                        "content": "Draw out the 2d comparison grid and you will probably see the solution emerge "
                    },
                    {
                        "username": "anupjaiswal",
                        "content": "is it possible to solve without dynamic programming ? "
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "Input\\nnums1 =\\n[0,0,0,0,1]\\nnums2 =\\n[1,0,0,0,0]\\n\\nOutput\\n5\\nExpected\\n4\\nWhy 4??? As both are same, it should be 5? I am kinda confused."
                    },
                    {
                        "username": "NNP3",
                        "content": "May be hint - Longest Common Substring variant! \n "
                    }
                ]
            },
            {
                "id": 2020498,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "LCS variation"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Longest Common Subarray"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "for input : nums1 =[0,0,0,0,0,0,1,0,0,0] ,nums2=[0,0,0,0,0,0,0,1,0,0] my code giving output 6 ,but expected output is 9,anyone can explain please."
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Then your code is wrong,\\nfor nums1 of index 0 to 8 == nums2 of index 1 to 9.\\nso answer is 9.\\n\\nfind subarray which is from any index to any index."
                    },
                    {
                        "username": "sarthak_44",
                        "content": "I tried solving it using DP but for this test case its giving wrong answer. Can someone tell my why it\\'s happening? \\n`class Solution {\\npublic:\\n\\n    int solve(string &a,string &b,vector<vector<int>>&dp,int n,int m){\\n\\n        if(n==0 or m==0) return 0;\\n        if(dp[n][m]!=-1) return dp[n][m];\\n\\n        if(a[n-1]==b[m-1]){\\n            dp[n][m]=1+solve(a,b,dp,n-1,m-1);\\n        }\\n\\n        else dp[n][m]=max(solve(a,b,dp,n-1,m),solve(a,b,dp,n,m-1));\\n\\n        return dp[n][m];\\n\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n\\n        string a=\"\",b=\"\";\\n        for(auto i:nums1){\\n            a+=to_string(i);\\n        } \\n        \\n        for(auto i:nums2){\\n            b+=to_string(i);\\n        } \\n\\n        int n = a.size();\\n        int m = b.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        // cout<<a<<\" \"<<b;\\n        return solve(a,b,dp,n,m);\\n\\n        return 0;\\n    }};\\n\\ntest case is nums1= [0,1,1,1,1] and nums2=[1,0,1,0,1]"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is a problem of substring not subsequence.\\nans should be consecutive that why you missed it...."
                    },
                    {
                        "username": "hejiafu0109",
                        "content": "mine is 3, which is a wrong answer"
                    },
                    {
                        "username": "srujan1234",
                        "content": "yes"
                    },
                    {
                        "username": "shasha2010027",
                        "content": " Wrong Approaches you might be thinking:\\n1. Sort and count the number of equal elements, nope as sorting changes the relative order of elements.\\n2. Run a loop from i=0 to min of size of given arrays and compare each index, if equal than increase count,\\nNope as index need not to be same in both arrays.\\n\\nApproach should be how would you solve Longest common substring problem using DP.\\n(which can be thought of from idea of LCS kind)."
                    },
                    {
                        "username": "ymgcksge",
                        "content": "nums1 and nums2 always have the same size?"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "It is not necessary, nums1 and nums2 have same size\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "It is not mentioned in question. So NO!"
                    },
                    {
                        "username": "rajender7",
                        "content": "No not necessarily."
                    },
                    {
                        "username": "Limon020",
                        "content": "Draw out the 2d comparison grid and you will probably see the solution emerge "
                    },
                    {
                        "username": "anupjaiswal",
                        "content": "is it possible to solve without dynamic programming ? "
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "Input\\nnums1 =\\n[0,0,0,0,1]\\nnums2 =\\n[1,0,0,0,0]\\n\\nOutput\\n5\\nExpected\\n4\\nWhy 4??? As both are same, it should be 5? I am kinda confused."
                    },
                    {
                        "username": "NNP3",
                        "content": "May be hint - Longest Common Substring variant! \n "
                    }
                ]
            },
            {
                "id": 1918650,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "LCS variation"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Longest Common Subarray"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "for input : nums1 =[0,0,0,0,0,0,1,0,0,0] ,nums2=[0,0,0,0,0,0,0,1,0,0] my code giving output 6 ,but expected output is 9,anyone can explain please."
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Then your code is wrong,\\nfor nums1 of index 0 to 8 == nums2 of index 1 to 9.\\nso answer is 9.\\n\\nfind subarray which is from any index to any index."
                    },
                    {
                        "username": "sarthak_44",
                        "content": "I tried solving it using DP but for this test case its giving wrong answer. Can someone tell my why it\\'s happening? \\n`class Solution {\\npublic:\\n\\n    int solve(string &a,string &b,vector<vector<int>>&dp,int n,int m){\\n\\n        if(n==0 or m==0) return 0;\\n        if(dp[n][m]!=-1) return dp[n][m];\\n\\n        if(a[n-1]==b[m-1]){\\n            dp[n][m]=1+solve(a,b,dp,n-1,m-1);\\n        }\\n\\n        else dp[n][m]=max(solve(a,b,dp,n-1,m),solve(a,b,dp,n,m-1));\\n\\n        return dp[n][m];\\n\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n\\n        string a=\"\",b=\"\";\\n        for(auto i:nums1){\\n            a+=to_string(i);\\n        } \\n        \\n        for(auto i:nums2){\\n            b+=to_string(i);\\n        } \\n\\n        int n = a.size();\\n        int m = b.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        // cout<<a<<\" \"<<b;\\n        return solve(a,b,dp,n,m);\\n\\n        return 0;\\n    }};\\n\\ntest case is nums1= [0,1,1,1,1] and nums2=[1,0,1,0,1]"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is a problem of substring not subsequence.\\nans should be consecutive that why you missed it...."
                    },
                    {
                        "username": "hejiafu0109",
                        "content": "mine is 3, which is a wrong answer"
                    },
                    {
                        "username": "srujan1234",
                        "content": "yes"
                    },
                    {
                        "username": "shasha2010027",
                        "content": " Wrong Approaches you might be thinking:\\n1. Sort and count the number of equal elements, nope as sorting changes the relative order of elements.\\n2. Run a loop from i=0 to min of size of given arrays and compare each index, if equal than increase count,\\nNope as index need not to be same in both arrays.\\n\\nApproach should be how would you solve Longest common substring problem using DP.\\n(which can be thought of from idea of LCS kind)."
                    },
                    {
                        "username": "ymgcksge",
                        "content": "nums1 and nums2 always have the same size?"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "It is not necessary, nums1 and nums2 have same size\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "It is not mentioned in question. So NO!"
                    },
                    {
                        "username": "rajender7",
                        "content": "No not necessarily."
                    },
                    {
                        "username": "Limon020",
                        "content": "Draw out the 2d comparison grid and you will probably see the solution emerge "
                    },
                    {
                        "username": "anupjaiswal",
                        "content": "is it possible to solve without dynamic programming ? "
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "Input\\nnums1 =\\n[0,0,0,0,1]\\nnums2 =\\n[1,0,0,0,0]\\n\\nOutput\\n5\\nExpected\\n4\\nWhy 4??? As both are same, it should be 5? I am kinda confused."
                    },
                    {
                        "username": "NNP3",
                        "content": "May be hint - Longest Common Substring variant! \n "
                    }
                ]
            },
            {
                "id": 1804494,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "LCS variation"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Longest Common Subarray"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "for input : nums1 =[0,0,0,0,0,0,1,0,0,0] ,nums2=[0,0,0,0,0,0,0,1,0,0] my code giving output 6 ,but expected output is 9,anyone can explain please."
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Then your code is wrong,\\nfor nums1 of index 0 to 8 == nums2 of index 1 to 9.\\nso answer is 9.\\n\\nfind subarray which is from any index to any index."
                    },
                    {
                        "username": "sarthak_44",
                        "content": "I tried solving it using DP but for this test case its giving wrong answer. Can someone tell my why it\\'s happening? \\n`class Solution {\\npublic:\\n\\n    int solve(string &a,string &b,vector<vector<int>>&dp,int n,int m){\\n\\n        if(n==0 or m==0) return 0;\\n        if(dp[n][m]!=-1) return dp[n][m];\\n\\n        if(a[n-1]==b[m-1]){\\n            dp[n][m]=1+solve(a,b,dp,n-1,m-1);\\n        }\\n\\n        else dp[n][m]=max(solve(a,b,dp,n-1,m),solve(a,b,dp,n,m-1));\\n\\n        return dp[n][m];\\n\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n\\n        string a=\"\",b=\"\";\\n        for(auto i:nums1){\\n            a+=to_string(i);\\n        } \\n        \\n        for(auto i:nums2){\\n            b+=to_string(i);\\n        } \\n\\n        int n = a.size();\\n        int m = b.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        // cout<<a<<\" \"<<b;\\n        return solve(a,b,dp,n,m);\\n\\n        return 0;\\n    }};\\n\\ntest case is nums1= [0,1,1,1,1] and nums2=[1,0,1,0,1]"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is a problem of substring not subsequence.\\nans should be consecutive that why you missed it...."
                    },
                    {
                        "username": "hejiafu0109",
                        "content": "mine is 3, which is a wrong answer"
                    },
                    {
                        "username": "srujan1234",
                        "content": "yes"
                    },
                    {
                        "username": "shasha2010027",
                        "content": " Wrong Approaches you might be thinking:\\n1. Sort and count the number of equal elements, nope as sorting changes the relative order of elements.\\n2. Run a loop from i=0 to min of size of given arrays and compare each index, if equal than increase count,\\nNope as index need not to be same in both arrays.\\n\\nApproach should be how would you solve Longest common substring problem using DP.\\n(which can be thought of from idea of LCS kind)."
                    },
                    {
                        "username": "ymgcksge",
                        "content": "nums1 and nums2 always have the same size?"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "It is not necessary, nums1 and nums2 have same size\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "It is not mentioned in question. So NO!"
                    },
                    {
                        "username": "rajender7",
                        "content": "No not necessarily."
                    },
                    {
                        "username": "Limon020",
                        "content": "Draw out the 2d comparison grid and you will probably see the solution emerge "
                    },
                    {
                        "username": "anupjaiswal",
                        "content": "is it possible to solve without dynamic programming ? "
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "Input\\nnums1 =\\n[0,0,0,0,1]\\nnums2 =\\n[1,0,0,0,0]\\n\\nOutput\\n5\\nExpected\\n4\\nWhy 4??? As both are same, it should be 5? I am kinda confused."
                    },
                    {
                        "username": "NNP3",
                        "content": "May be hint - Longest Common Substring variant! \n "
                    }
                ]
            },
            {
                "id": 1828391,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "LCS variation"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Longest Common Subarray"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "for input : nums1 =[0,0,0,0,0,0,1,0,0,0] ,nums2=[0,0,0,0,0,0,0,1,0,0] my code giving output 6 ,but expected output is 9,anyone can explain please."
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Then your code is wrong,\\nfor nums1 of index 0 to 8 == nums2 of index 1 to 9.\\nso answer is 9.\\n\\nfind subarray which is from any index to any index."
                    },
                    {
                        "username": "sarthak_44",
                        "content": "I tried solving it using DP but for this test case its giving wrong answer. Can someone tell my why it\\'s happening? \\n`class Solution {\\npublic:\\n\\n    int solve(string &a,string &b,vector<vector<int>>&dp,int n,int m){\\n\\n        if(n==0 or m==0) return 0;\\n        if(dp[n][m]!=-1) return dp[n][m];\\n\\n        if(a[n-1]==b[m-1]){\\n            dp[n][m]=1+solve(a,b,dp,n-1,m-1);\\n        }\\n\\n        else dp[n][m]=max(solve(a,b,dp,n-1,m),solve(a,b,dp,n,m-1));\\n\\n        return dp[n][m];\\n\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n\\n        string a=\"\",b=\"\";\\n        for(auto i:nums1){\\n            a+=to_string(i);\\n        } \\n        \\n        for(auto i:nums2){\\n            b+=to_string(i);\\n        } \\n\\n        int n = a.size();\\n        int m = b.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        // cout<<a<<\" \"<<b;\\n        return solve(a,b,dp,n,m);\\n\\n        return 0;\\n    }};\\n\\ntest case is nums1= [0,1,1,1,1] and nums2=[1,0,1,0,1]"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is a problem of substring not subsequence.\\nans should be consecutive that why you missed it...."
                    },
                    {
                        "username": "hejiafu0109",
                        "content": "mine is 3, which is a wrong answer"
                    },
                    {
                        "username": "srujan1234",
                        "content": "yes"
                    },
                    {
                        "username": "shasha2010027",
                        "content": " Wrong Approaches you might be thinking:\\n1. Sort and count the number of equal elements, nope as sorting changes the relative order of elements.\\n2. Run a loop from i=0 to min of size of given arrays and compare each index, if equal than increase count,\\nNope as index need not to be same in both arrays.\\n\\nApproach should be how would you solve Longest common substring problem using DP.\\n(which can be thought of from idea of LCS kind)."
                    },
                    {
                        "username": "ymgcksge",
                        "content": "nums1 and nums2 always have the same size?"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "It is not necessary, nums1 and nums2 have same size\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "It is not mentioned in question. So NO!"
                    },
                    {
                        "username": "rajender7",
                        "content": "No not necessarily."
                    },
                    {
                        "username": "Limon020",
                        "content": "Draw out the 2d comparison grid and you will probably see the solution emerge "
                    },
                    {
                        "username": "anupjaiswal",
                        "content": "is it possible to solve without dynamic programming ? "
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "Input\\nnums1 =\\n[0,0,0,0,1]\\nnums2 =\\n[1,0,0,0,0]\\n\\nOutput\\n5\\nExpected\\n4\\nWhy 4??? As both are same, it should be 5? I am kinda confused."
                    },
                    {
                        "username": "NNP3",
                        "content": "May be hint - Longest Common Substring variant! \n "
                    }
                ]
            },
            {
                "id": 1571811,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "LCS variation"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Longest Common Subarray"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "for input : nums1 =[0,0,0,0,0,0,1,0,0,0] ,nums2=[0,0,0,0,0,0,0,1,0,0] my code giving output 6 ,but expected output is 9,anyone can explain please."
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Then your code is wrong,\\nfor nums1 of index 0 to 8 == nums2 of index 1 to 9.\\nso answer is 9.\\n\\nfind subarray which is from any index to any index."
                    },
                    {
                        "username": "sarthak_44",
                        "content": "I tried solving it using DP but for this test case its giving wrong answer. Can someone tell my why it\\'s happening? \\n`class Solution {\\npublic:\\n\\n    int solve(string &a,string &b,vector<vector<int>>&dp,int n,int m){\\n\\n        if(n==0 or m==0) return 0;\\n        if(dp[n][m]!=-1) return dp[n][m];\\n\\n        if(a[n-1]==b[m-1]){\\n            dp[n][m]=1+solve(a,b,dp,n-1,m-1);\\n        }\\n\\n        else dp[n][m]=max(solve(a,b,dp,n-1,m),solve(a,b,dp,n,m-1));\\n\\n        return dp[n][m];\\n\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n\\n        string a=\"\",b=\"\";\\n        for(auto i:nums1){\\n            a+=to_string(i);\\n        } \\n        \\n        for(auto i:nums2){\\n            b+=to_string(i);\\n        } \\n\\n        int n = a.size();\\n        int m = b.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        // cout<<a<<\" \"<<b;\\n        return solve(a,b,dp,n,m);\\n\\n        return 0;\\n    }};\\n\\ntest case is nums1= [0,1,1,1,1] and nums2=[1,0,1,0,1]"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is a problem of substring not subsequence.\\nans should be consecutive that why you missed it...."
                    },
                    {
                        "username": "hejiafu0109",
                        "content": "mine is 3, which is a wrong answer"
                    },
                    {
                        "username": "srujan1234",
                        "content": "yes"
                    },
                    {
                        "username": "shasha2010027",
                        "content": " Wrong Approaches you might be thinking:\\n1. Sort and count the number of equal elements, nope as sorting changes the relative order of elements.\\n2. Run a loop from i=0 to min of size of given arrays and compare each index, if equal than increase count,\\nNope as index need not to be same in both arrays.\\n\\nApproach should be how would you solve Longest common substring problem using DP.\\n(which can be thought of from idea of LCS kind)."
                    },
                    {
                        "username": "ymgcksge",
                        "content": "nums1 and nums2 always have the same size?"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "It is not necessary, nums1 and nums2 have same size\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "It is not mentioned in question. So NO!"
                    },
                    {
                        "username": "rajender7",
                        "content": "No not necessarily."
                    },
                    {
                        "username": "Limon020",
                        "content": "Draw out the 2d comparison grid and you will probably see the solution emerge "
                    },
                    {
                        "username": "anupjaiswal",
                        "content": "is it possible to solve without dynamic programming ? "
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "Input\\nnums1 =\\n[0,0,0,0,1]\\nnums2 =\\n[1,0,0,0,0]\\n\\nOutput\\n5\\nExpected\\n4\\nWhy 4??? As both are same, it should be 5? I am kinda confused."
                    },
                    {
                        "username": "NNP3",
                        "content": "May be hint - Longest Common Substring variant! \n "
                    }
                ]
            },
            {
                "id": 1816324,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "LCS variation"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Longest Common Subarray"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "for input : nums1 =[0,0,0,0,0,0,1,0,0,0] ,nums2=[0,0,0,0,0,0,0,1,0,0] my code giving output 6 ,but expected output is 9,anyone can explain please."
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Then your code is wrong,\\nfor nums1 of index 0 to 8 == nums2 of index 1 to 9.\\nso answer is 9.\\n\\nfind subarray which is from any index to any index."
                    },
                    {
                        "username": "sarthak_44",
                        "content": "I tried solving it using DP but for this test case its giving wrong answer. Can someone tell my why it\\'s happening? \\n`class Solution {\\npublic:\\n\\n    int solve(string &a,string &b,vector<vector<int>>&dp,int n,int m){\\n\\n        if(n==0 or m==0) return 0;\\n        if(dp[n][m]!=-1) return dp[n][m];\\n\\n        if(a[n-1]==b[m-1]){\\n            dp[n][m]=1+solve(a,b,dp,n-1,m-1);\\n        }\\n\\n        else dp[n][m]=max(solve(a,b,dp,n-1,m),solve(a,b,dp,n,m-1));\\n\\n        return dp[n][m];\\n\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n\\n        string a=\"\",b=\"\";\\n        for(auto i:nums1){\\n            a+=to_string(i);\\n        } \\n        \\n        for(auto i:nums2){\\n            b+=to_string(i);\\n        } \\n\\n        int n = a.size();\\n        int m = b.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        // cout<<a<<\" \"<<b;\\n        return solve(a,b,dp,n,m);\\n\\n        return 0;\\n    }};\\n\\ntest case is nums1= [0,1,1,1,1] and nums2=[1,0,1,0,1]"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is a problem of substring not subsequence.\\nans should be consecutive that why you missed it...."
                    },
                    {
                        "username": "hejiafu0109",
                        "content": "mine is 3, which is a wrong answer"
                    },
                    {
                        "username": "srujan1234",
                        "content": "yes"
                    },
                    {
                        "username": "shasha2010027",
                        "content": " Wrong Approaches you might be thinking:\\n1. Sort and count the number of equal elements, nope as sorting changes the relative order of elements.\\n2. Run a loop from i=0 to min of size of given arrays and compare each index, if equal than increase count,\\nNope as index need not to be same in both arrays.\\n\\nApproach should be how would you solve Longest common substring problem using DP.\\n(which can be thought of from idea of LCS kind)."
                    },
                    {
                        "username": "ymgcksge",
                        "content": "nums1 and nums2 always have the same size?"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "It is not necessary, nums1 and nums2 have same size\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "It is not mentioned in question. So NO!"
                    },
                    {
                        "username": "rajender7",
                        "content": "No not necessarily."
                    },
                    {
                        "username": "Limon020",
                        "content": "Draw out the 2d comparison grid and you will probably see the solution emerge "
                    },
                    {
                        "username": "anupjaiswal",
                        "content": "is it possible to solve without dynamic programming ? "
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "Input\\nnums1 =\\n[0,0,0,0,1]\\nnums2 =\\n[1,0,0,0,0]\\n\\nOutput\\n5\\nExpected\\n4\\nWhy 4??? As both are same, it should be 5? I am kinda confused."
                    },
                    {
                        "username": "NNP3",
                        "content": "May be hint - Longest Common Substring variant! \n "
                    }
                ]
            },
            {
                "id": 1761505,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "LCS variation"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Longest Common Subarray"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "for input : nums1 =[0,0,0,0,0,0,1,0,0,0] ,nums2=[0,0,0,0,0,0,0,1,0,0] my code giving output 6 ,but expected output is 9,anyone can explain please."
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Then your code is wrong,\\nfor nums1 of index 0 to 8 == nums2 of index 1 to 9.\\nso answer is 9.\\n\\nfind subarray which is from any index to any index."
                    },
                    {
                        "username": "sarthak_44",
                        "content": "I tried solving it using DP but for this test case its giving wrong answer. Can someone tell my why it\\'s happening? \\n`class Solution {\\npublic:\\n\\n    int solve(string &a,string &b,vector<vector<int>>&dp,int n,int m){\\n\\n        if(n==0 or m==0) return 0;\\n        if(dp[n][m]!=-1) return dp[n][m];\\n\\n        if(a[n-1]==b[m-1]){\\n            dp[n][m]=1+solve(a,b,dp,n-1,m-1);\\n        }\\n\\n        else dp[n][m]=max(solve(a,b,dp,n-1,m),solve(a,b,dp,n,m-1));\\n\\n        return dp[n][m];\\n\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n\\n        string a=\"\",b=\"\";\\n        for(auto i:nums1){\\n            a+=to_string(i);\\n        } \\n        \\n        for(auto i:nums2){\\n            b+=to_string(i);\\n        } \\n\\n        int n = a.size();\\n        int m = b.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        // cout<<a<<\" \"<<b;\\n        return solve(a,b,dp,n,m);\\n\\n        return 0;\\n    }};\\n\\ntest case is nums1= [0,1,1,1,1] and nums2=[1,0,1,0,1]"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is a problem of substring not subsequence.\\nans should be consecutive that why you missed it...."
                    },
                    {
                        "username": "hejiafu0109",
                        "content": "mine is 3, which is a wrong answer"
                    },
                    {
                        "username": "srujan1234",
                        "content": "yes"
                    },
                    {
                        "username": "shasha2010027",
                        "content": " Wrong Approaches you might be thinking:\\n1. Sort and count the number of equal elements, nope as sorting changes the relative order of elements.\\n2. Run a loop from i=0 to min of size of given arrays and compare each index, if equal than increase count,\\nNope as index need not to be same in both arrays.\\n\\nApproach should be how would you solve Longest common substring problem using DP.\\n(which can be thought of from idea of LCS kind)."
                    },
                    {
                        "username": "ymgcksge",
                        "content": "nums1 and nums2 always have the same size?"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "It is not necessary, nums1 and nums2 have same size\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "It is not mentioned in question. So NO!"
                    },
                    {
                        "username": "rajender7",
                        "content": "No not necessarily."
                    },
                    {
                        "username": "Limon020",
                        "content": "Draw out the 2d comparison grid and you will probably see the solution emerge "
                    },
                    {
                        "username": "anupjaiswal",
                        "content": "is it possible to solve without dynamic programming ? "
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "Input\\nnums1 =\\n[0,0,0,0,1]\\nnums2 =\\n[1,0,0,0,0]\\n\\nOutput\\n5\\nExpected\\n4\\nWhy 4??? As both are same, it should be 5? I am kinda confused."
                    },
                    {
                        "username": "NNP3",
                        "content": "May be hint - Longest Common Substring variant! \n "
                    }
                ]
            },
            {
                "id": 2074824,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "LCS variation"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Longest Common Subarray"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "for input : nums1 =[0,0,0,0,0,0,1,0,0,0] ,nums2=[0,0,0,0,0,0,0,1,0,0] my code giving output 6 ,but expected output is 9,anyone can explain please."
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Then your code is wrong,\\nfor nums1 of index 0 to 8 == nums2 of index 1 to 9.\\nso answer is 9.\\n\\nfind subarray which is from any index to any index."
                    },
                    {
                        "username": "sarthak_44",
                        "content": "I tried solving it using DP but for this test case its giving wrong answer. Can someone tell my why it\\'s happening? \\n`class Solution {\\npublic:\\n\\n    int solve(string &a,string &b,vector<vector<int>>&dp,int n,int m){\\n\\n        if(n==0 or m==0) return 0;\\n        if(dp[n][m]!=-1) return dp[n][m];\\n\\n        if(a[n-1]==b[m-1]){\\n            dp[n][m]=1+solve(a,b,dp,n-1,m-1);\\n        }\\n\\n        else dp[n][m]=max(solve(a,b,dp,n-1,m),solve(a,b,dp,n,m-1));\\n\\n        return dp[n][m];\\n\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n\\n        string a=\"\",b=\"\";\\n        for(auto i:nums1){\\n            a+=to_string(i);\\n        } \\n        \\n        for(auto i:nums2){\\n            b+=to_string(i);\\n        } \\n\\n        int n = a.size();\\n        int m = b.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        // cout<<a<<\" \"<<b;\\n        return solve(a,b,dp,n,m);\\n\\n        return 0;\\n    }};\\n\\ntest case is nums1= [0,1,1,1,1] and nums2=[1,0,1,0,1]"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is a problem of substring not subsequence.\\nans should be consecutive that why you missed it...."
                    },
                    {
                        "username": "hejiafu0109",
                        "content": "mine is 3, which is a wrong answer"
                    },
                    {
                        "username": "srujan1234",
                        "content": "yes"
                    },
                    {
                        "username": "shasha2010027",
                        "content": " Wrong Approaches you might be thinking:\\n1. Sort and count the number of equal elements, nope as sorting changes the relative order of elements.\\n2. Run a loop from i=0 to min of size of given arrays and compare each index, if equal than increase count,\\nNope as index need not to be same in both arrays.\\n\\nApproach should be how would you solve Longest common substring problem using DP.\\n(which can be thought of from idea of LCS kind)."
                    },
                    {
                        "username": "ymgcksge",
                        "content": "nums1 and nums2 always have the same size?"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "It is not necessary, nums1 and nums2 have same size\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "It is not mentioned in question. So NO!"
                    },
                    {
                        "username": "rajender7",
                        "content": "No not necessarily."
                    },
                    {
                        "username": "Limon020",
                        "content": "Draw out the 2d comparison grid and you will probably see the solution emerge "
                    },
                    {
                        "username": "anupjaiswal",
                        "content": "is it possible to solve without dynamic programming ? "
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "Input\\nnums1 =\\n[0,0,0,0,1]\\nnums2 =\\n[1,0,0,0,0]\\n\\nOutput\\n5\\nExpected\\n4\\nWhy 4??? As both are same, it should be 5? I am kinda confused."
                    },
                    {
                        "username": "NNP3",
                        "content": "May be hint - Longest Common Substring variant! \n "
                    }
                ]
            },
            {
                "id": 2046774,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "LCS variation"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Longest Common Subarray"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "for input : nums1 =[0,0,0,0,0,0,1,0,0,0] ,nums2=[0,0,0,0,0,0,0,1,0,0] my code giving output 6 ,but expected output is 9,anyone can explain please."
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Then your code is wrong,\\nfor nums1 of index 0 to 8 == nums2 of index 1 to 9.\\nso answer is 9.\\n\\nfind subarray which is from any index to any index."
                    },
                    {
                        "username": "sarthak_44",
                        "content": "I tried solving it using DP but for this test case its giving wrong answer. Can someone tell my why it\\'s happening? \\n`class Solution {\\npublic:\\n\\n    int solve(string &a,string &b,vector<vector<int>>&dp,int n,int m){\\n\\n        if(n==0 or m==0) return 0;\\n        if(dp[n][m]!=-1) return dp[n][m];\\n\\n        if(a[n-1]==b[m-1]){\\n            dp[n][m]=1+solve(a,b,dp,n-1,m-1);\\n        }\\n\\n        else dp[n][m]=max(solve(a,b,dp,n-1,m),solve(a,b,dp,n,m-1));\\n\\n        return dp[n][m];\\n\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n\\n        string a=\"\",b=\"\";\\n        for(auto i:nums1){\\n            a+=to_string(i);\\n        } \\n        \\n        for(auto i:nums2){\\n            b+=to_string(i);\\n        } \\n\\n        int n = a.size();\\n        int m = b.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        // cout<<a<<\" \"<<b;\\n        return solve(a,b,dp,n,m);\\n\\n        return 0;\\n    }};\\n\\ntest case is nums1= [0,1,1,1,1] and nums2=[1,0,1,0,1]"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is a problem of substring not subsequence.\\nans should be consecutive that why you missed it...."
                    },
                    {
                        "username": "hejiafu0109",
                        "content": "mine is 3, which is a wrong answer"
                    },
                    {
                        "username": "srujan1234",
                        "content": "yes"
                    },
                    {
                        "username": "shasha2010027",
                        "content": " Wrong Approaches you might be thinking:\\n1. Sort and count the number of equal elements, nope as sorting changes the relative order of elements.\\n2. Run a loop from i=0 to min of size of given arrays and compare each index, if equal than increase count,\\nNope as index need not to be same in both arrays.\\n\\nApproach should be how would you solve Longest common substring problem using DP.\\n(which can be thought of from idea of LCS kind)."
                    },
                    {
                        "username": "ymgcksge",
                        "content": "nums1 and nums2 always have the same size?"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "It is not necessary, nums1 and nums2 have same size\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "It is not mentioned in question. So NO!"
                    },
                    {
                        "username": "rajender7",
                        "content": "No not necessarily."
                    },
                    {
                        "username": "Limon020",
                        "content": "Draw out the 2d comparison grid and you will probably see the solution emerge "
                    },
                    {
                        "username": "anupjaiswal",
                        "content": "is it possible to solve without dynamic programming ? "
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "Input\\nnums1 =\\n[0,0,0,0,1]\\nnums2 =\\n[1,0,0,0,0]\\n\\nOutput\\n5\\nExpected\\n4\\nWhy 4??? As both are same, it should be 5? I am kinda confused."
                    },
                    {
                        "username": "NNP3",
                        "content": "May be hint - Longest Common Substring variant! \n "
                    }
                ]
            },
            {
                "id": 2023173,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "LCS variation"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Longest Common Subarray"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "for input : nums1 =[0,0,0,0,0,0,1,0,0,0] ,nums2=[0,0,0,0,0,0,0,1,0,0] my code giving output 6 ,but expected output is 9,anyone can explain please."
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Then your code is wrong,\\nfor nums1 of index 0 to 8 == nums2 of index 1 to 9.\\nso answer is 9.\\n\\nfind subarray which is from any index to any index."
                    },
                    {
                        "username": "sarthak_44",
                        "content": "I tried solving it using DP but for this test case its giving wrong answer. Can someone tell my why it\\'s happening? \\n`class Solution {\\npublic:\\n\\n    int solve(string &a,string &b,vector<vector<int>>&dp,int n,int m){\\n\\n        if(n==0 or m==0) return 0;\\n        if(dp[n][m]!=-1) return dp[n][m];\\n\\n        if(a[n-1]==b[m-1]){\\n            dp[n][m]=1+solve(a,b,dp,n-1,m-1);\\n        }\\n\\n        else dp[n][m]=max(solve(a,b,dp,n-1,m),solve(a,b,dp,n,m-1));\\n\\n        return dp[n][m];\\n\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n\\n        string a=\"\",b=\"\";\\n        for(auto i:nums1){\\n            a+=to_string(i);\\n        } \\n        \\n        for(auto i:nums2){\\n            b+=to_string(i);\\n        } \\n\\n        int n = a.size();\\n        int m = b.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        // cout<<a<<\" \"<<b;\\n        return solve(a,b,dp,n,m);\\n\\n        return 0;\\n    }};\\n\\ntest case is nums1= [0,1,1,1,1] and nums2=[1,0,1,0,1]"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is a problem of substring not subsequence.\\nans should be consecutive that why you missed it...."
                    },
                    {
                        "username": "hejiafu0109",
                        "content": "mine is 3, which is a wrong answer"
                    },
                    {
                        "username": "srujan1234",
                        "content": "yes"
                    },
                    {
                        "username": "shasha2010027",
                        "content": " Wrong Approaches you might be thinking:\\n1. Sort and count the number of equal elements, nope as sorting changes the relative order of elements.\\n2. Run a loop from i=0 to min of size of given arrays and compare each index, if equal than increase count,\\nNope as index need not to be same in both arrays.\\n\\nApproach should be how would you solve Longest common substring problem using DP.\\n(which can be thought of from idea of LCS kind)."
                    },
                    {
                        "username": "ymgcksge",
                        "content": "nums1 and nums2 always have the same size?"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "It is not necessary, nums1 and nums2 have same size\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "It is not mentioned in question. So NO!"
                    },
                    {
                        "username": "rajender7",
                        "content": "No not necessarily."
                    },
                    {
                        "username": "Limon020",
                        "content": "Draw out the 2d comparison grid and you will probably see the solution emerge "
                    },
                    {
                        "username": "anupjaiswal",
                        "content": "is it possible to solve without dynamic programming ? "
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "Input\\nnums1 =\\n[0,0,0,0,1]\\nnums2 =\\n[1,0,0,0,0]\\n\\nOutput\\n5\\nExpected\\n4\\nWhy 4??? As both are same, it should be 5? I am kinda confused."
                    },
                    {
                        "username": "NNP3",
                        "content": "May be hint - Longest Common Substring variant! \n "
                    }
                ]
            },
            {
                "id": 2020498,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "LCS variation"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Longest Common Subarray"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "for input : nums1 =[0,0,0,0,0,0,1,0,0,0] ,nums2=[0,0,0,0,0,0,0,1,0,0] my code giving output 6 ,but expected output is 9,anyone can explain please."
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Then your code is wrong,\\nfor nums1 of index 0 to 8 == nums2 of index 1 to 9.\\nso answer is 9.\\n\\nfind subarray which is from any index to any index."
                    },
                    {
                        "username": "sarthak_44",
                        "content": "I tried solving it using DP but for this test case its giving wrong answer. Can someone tell my why it\\'s happening? \\n`class Solution {\\npublic:\\n\\n    int solve(string &a,string &b,vector<vector<int>>&dp,int n,int m){\\n\\n        if(n==0 or m==0) return 0;\\n        if(dp[n][m]!=-1) return dp[n][m];\\n\\n        if(a[n-1]==b[m-1]){\\n            dp[n][m]=1+solve(a,b,dp,n-1,m-1);\\n        }\\n\\n        else dp[n][m]=max(solve(a,b,dp,n-1,m),solve(a,b,dp,n,m-1));\\n\\n        return dp[n][m];\\n\\n    }\\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\\n\\n        string a=\"\",b=\"\";\\n        for(auto i:nums1){\\n            a+=to_string(i);\\n        } \\n        \\n        for(auto i:nums2){\\n            b+=to_string(i);\\n        } \\n\\n        int n = a.size();\\n        int m = b.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        // cout<<a<<\" \"<<b;\\n        return solve(a,b,dp,n,m);\\n\\n        return 0;\\n    }};\\n\\ntest case is nums1= [0,1,1,1,1] and nums2=[1,0,1,0,1]"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "This is a problem of substring not subsequence.\\nans should be consecutive that why you missed it...."
                    },
                    {
                        "username": "hejiafu0109",
                        "content": "mine is 3, which is a wrong answer"
                    },
                    {
                        "username": "srujan1234",
                        "content": "yes"
                    },
                    {
                        "username": "shasha2010027",
                        "content": " Wrong Approaches you might be thinking:\\n1. Sort and count the number of equal elements, nope as sorting changes the relative order of elements.\\n2. Run a loop from i=0 to min of size of given arrays and compare each index, if equal than increase count,\\nNope as index need not to be same in both arrays.\\n\\nApproach should be how would you solve Longest common substring problem using DP.\\n(which can be thought of from idea of LCS kind)."
                    },
                    {
                        "username": "ymgcksge",
                        "content": "nums1 and nums2 always have the same size?"
                    },
                    {
                        "username": "Baburam-Yadav",
                        "content": "It is not necessary, nums1 and nums2 have same size\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "It is not mentioned in question. So NO!"
                    },
                    {
                        "username": "rajender7",
                        "content": "No not necessarily."
                    },
                    {
                        "username": "Limon020",
                        "content": "Draw out the 2d comparison grid and you will probably see the solution emerge "
                    },
                    {
                        "username": "anupjaiswal",
                        "content": "is it possible to solve without dynamic programming ? "
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "Input\\nnums1 =\\n[0,0,0,0,1]\\nnums2 =\\n[1,0,0,0,0]\\n\\nOutput\\n5\\nExpected\\n4\\nWhy 4??? As both are same, it should be 5? I am kinda confused."
                    },
                    {
                        "username": "NNP3",
                        "content": "May be hint - Longest Common Substring variant! \n "
                    }
                ]
            }
        ]
    }
]