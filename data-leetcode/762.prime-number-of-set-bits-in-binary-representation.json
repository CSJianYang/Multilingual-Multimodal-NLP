[
    {
        "title": "Reconstruct Itinerary",
        "question_content": "You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.\nAll of the tickets belong to a man who departs from \"JFK\", thus, the itinerary must begin with \"JFK\". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\n\n\tFor example, the itinerary [\"JFK\", \"LGA\"] has a smaller lexical order than [\"JFK\", \"LGB\"].\n\nYou may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.\n&nbsp;\nExample 1:\n\nInput: tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]\nOutput: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]\n\nExample 2:\n\nInput: tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\nOutput: [\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]\nExplanation: Another possible reconstruction is [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"] but it is larger in lexical order.\n\n&nbsp;\nConstraints:\n\n\t1 <= tickets.length <= 300\n\ttickets[i].length == 2\n\tfromi.length == 3\n\ttoi.length == 3\n\tfromi and toi consist of uppercase English letters.\n\tfromi != toi",
        "solutions": [
            {
                "id": 78768,
                "title": "short-ruby-python-java-c",
                "content": "Just Eulerian path. Greedy DFS, building the route backwards when retreating.\\n\\nMore explanation and example under the codes.\\n\\nIterative versions inspired by [fangyang](https://leetcode.com/discuss/84706/share-solution-java-greedy-stack-15ms-with-explanation) (I had only thought of recursion, d\\'oh).\\n\\n---\\n\\n**Ruby**\\n\\n    def find_itinerary(tickets)\\n      tickets = tickets.sort.reverse.group_by(&:first)\\n      route = []\\n      visit = -> airport {\\n        visit[tickets[airport].pop()[1]] while (tickets[airport] || []).any?\\n        route << airport\\n      }\\n      visit[\"JFK\"]\\n      route.reverse\\n    end\\n\\nIterative version:\\n\\n    def find_itinerary(tickets)\\n      tickets = tickets.sort.reverse.group_by(&:first)\\n      route, stack = [], [\"JFK\"]\\n      while stack.any?\\n        stack << tickets[stack[-1]].pop()[1] while (tickets[stack[-1]] || []).any?\\n        route << stack.pop()\\n      end\\n      route.reverse\\n    end\\n\\n---\\n\\n**Python**\\n\\n    def findItinerary(self, tickets):\\n        targets = collections.defaultdict(list)\\n        for a, b in sorted(tickets)[::-1]:\\n            targets[a] += b,\\n        route = []\\n        def visit(airport):\\n            while targets[airport]:\\n                visit(targets[airport].pop())\\n            route.append(airport)\\n        visit(\\'JFK\\')\\n        return route[::-1]\\n\\nIterative version:\\n\\n    def findItinerary(self, tickets):\\n        targets = collections.defaultdict(list)\\n        for a, b in sorted(tickets)[::-1]:\\n            targets[a] += b,\\n        route, stack = [], [\\'JFK\\']\\n        while stack:\\n            while targets[stack[-1]]:\\n                stack += targets[stack[-1]].pop(),\\n            route += stack.pop(),\\n        return route[::-1]\\n\\n---\\n\\n**Java**\\n\\n    public List<String> findItinerary(String[][] tickets) {\\n        for (String[] ticket : tickets)\\n            targets.computeIfAbsent(ticket[0], k -> new PriorityQueue()).add(ticket[1]);\\n        visit(\"JFK\");\\n        return route;\\n    }\\n    \\n    Map<String, PriorityQueue<String>> targets = new HashMap<>();\\n    List<String> route = new LinkedList();\\n    \\n    void visit(String airport) {\\n        while(targets.containsKey(airport) && !targets.get(airport).isEmpty())\\n            visit(targets.get(airport).poll());\\n        route.add(0, airport);\\n    }\\n\\nIterative version:\\n\\n    public List<String> findItinerary(String[][] tickets) {\\n        Map<String, PriorityQueue<String>> targets = new HashMap<>();\\n        for (String[] ticket : tickets)\\n            targets.computeIfAbsent(ticket[0], k -> new PriorityQueue()).add(ticket[1]);\\n        List<String> route = new LinkedList();\\n        Stack<String> stack = new Stack<>();\\n        stack.push(\"JFK\");\\n        while (!stack.empty()) {\\n            while (targets.containsKey(stack.peek()) && !targets.get(stack.peek()).isEmpty())\\n                stack.push(targets.get(stack.peek()).poll());\\n            route.add(0, stack.pop());\\n        }\\n        return route;\\n    }\\n\\n---\\n\\n**C++**\\n\\n    vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n        for (auto ticket : tickets)\\n            targets[ticket.first].insert(ticket.second);\\n        visit(\"JFK\");\\n        return vector<string>(route.rbegin(), route.rend());\\n    }\\n\\n    map<string, multiset<string>> targets;\\n    vector<string> route;\\n\\n    void visit(string airport) {\\n        while (targets[airport].size()) {\\n            string next = *targets[airport].begin();\\n            targets[airport].erase(targets[airport].begin());\\n            visit(next);\\n        }\\n        route.push_back(airport);\\n    }\\n\\n---\\n\\n**Explanation**\\n\\nFirst keep going forward until you get stuck. That\\'s a good main path already. Remaining tickets form cycles which are found on the way back and get merged into that main path. By writing down the path backwards when retreating from recursion, merging the cycles into the main path is easy - the end part of the path has already been written, the start part of the path hasn\\'t been written yet, so just write down the cycle now and then keep backwards-writing the path.\\n\\nExample:\\n\\n![enter image description here][1]\\n\\nFrom JFK we first visit JFK -> A -> C -> D -> A. There we\\'re stuck, so we write down A as the end of the route and retreat back to D. There we see the unused ticket to B and follow it: D -> B -> C -> JFK -> D. Then we\\'re stuck again, retreat and write down the airports while doing so: Write down D before the already written A, then JFK before the D, etc. When we\\'re back from our cycle at D, the written route is D -> B -> C -> JFK -> D -> A. Then we retreat further along the original path, prepending C, A and finally JFK to the route, ending up with the route JFK -> A -> C -> D -> B -> C -> JFK -> D -> A.\\n\\n  [1]: https://www.stefan-pochmann.info/misc/reconstruct-itinerary.png",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "Just Eulerian path. Greedy DFS, building the route backwards when retreating.\\n\\nMore explanation and example under the codes.\\n\\nIterative versions inspired by [fangyang](https://leetcode.com/discuss/84706/share-solution-java-greedy-stack-15ms-with-explanation) (I had only thought of recursion, d\\'oh).\\n\\n---\\n\\n**Ruby**\\n\\n    def find_itinerary(tickets)\\n      tickets = tickets.sort.reverse.group_by(&:first)\\n      route = []\\n      visit = -> airport {\\n        visit[tickets[airport].pop()[1]] while (tickets[airport] || []).any?\\n        route << airport\\n      }\\n      visit[\"JFK\"]\\n      route.reverse\\n    end\\n\\nIterative version:\\n\\n    def find_itinerary(tickets)\\n      tickets = tickets.sort.reverse.group_by(&:first)\\n      route, stack = [], [\"JFK\"]\\n      while stack.any?\\n        stack << tickets[stack[-1]].pop()[1] while (tickets[stack[-1]] || []).any?\\n        route << stack.pop()\\n      end\\n      route.reverse\\n    end\\n\\n---\\n\\n**Python**\\n\\n    def findItinerary(self, tickets):\\n        targets = collections.defaultdict(list)\\n        for a, b in sorted(tickets)[::-1]:\\n            targets[a] += b,\\n        route = []\\n        def visit(airport):\\n            while targets[airport]:\\n                visit(targets[airport].pop())\\n            route.append(airport)\\n        visit(\\'JFK\\')\\n        return route[::-1]\\n\\nIterative version:\\n\\n    def findItinerary(self, tickets):\\n        targets = collections.defaultdict(list)\\n        for a, b in sorted(tickets)[::-1]:\\n            targets[a] += b,\\n        route, stack = [], [\\'JFK\\']\\n        while stack:\\n            while targets[stack[-1]]:\\n                stack += targets[stack[-1]].pop(),\\n            route += stack.pop(),\\n        return route[::-1]\\n\\n---\\n\\n**Java**\\n\\n    public List<String> findItinerary(String[][] tickets) {\\n        for (String[] ticket : tickets)\\n            targets.computeIfAbsent(ticket[0], k -> new PriorityQueue()).add(ticket[1]);\\n        visit(\"JFK\");\\n        return route;\\n    }\\n    \\n    Map<String, PriorityQueue<String>> targets = new HashMap<>();\\n    List<String> route = new LinkedList();\\n    \\n    void visit(String airport) {\\n        while(targets.containsKey(airport) && !targets.get(airport).isEmpty())\\n            visit(targets.get(airport).poll());\\n        route.add(0, airport);\\n    }\\n\\nIterative version:\\n\\n    public List<String> findItinerary(String[][] tickets) {\\n        Map<String, PriorityQueue<String>> targets = new HashMap<>();\\n        for (String[] ticket : tickets)\\n            targets.computeIfAbsent(ticket[0], k -> new PriorityQueue()).add(ticket[1]);\\n        List<String> route = new LinkedList();\\n        Stack<String> stack = new Stack<>();\\n        stack.push(\"JFK\");\\n        while (!stack.empty()) {\\n            while (targets.containsKey(stack.peek()) && !targets.get(stack.peek()).isEmpty())\\n                stack.push(targets.get(stack.peek()).poll());\\n            route.add(0, stack.pop());\\n        }\\n        return route;\\n    }\\n\\n---\\n\\n**C++**\\n\\n    vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n        for (auto ticket : tickets)\\n            targets[ticket.first].insert(ticket.second);\\n        visit(\"JFK\");\\n        return vector<string>(route.rbegin(), route.rend());\\n    }\\n\\n    map<string, multiset<string>> targets;\\n    vector<string> route;\\n\\n    void visit(string airport) {\\n        while (targets[airport].size()) {\\n            string next = *targets[airport].begin();\\n            targets[airport].erase(targets[airport].begin());\\n            visit(next);\\n        }\\n        route.push_back(airport);\\n    }\\n\\n---\\n\\n**Explanation**\\n\\nFirst keep going forward until you get stuck. That\\'s a good main path already. Remaining tickets form cycles which are found on the way back and get merged into that main path. By writing down the path backwards when retreating from recursion, merging the cycles into the main path is easy - the end part of the path has already been written, the start part of the path hasn\\'t been written yet, so just write down the cycle now and then keep backwards-writing the path.\\n\\nExample:\\n\\n![enter image description here][1]\\n\\nFrom JFK we first visit JFK -> A -> C -> D -> A. There we\\'re stuck, so we write down A as the end of the route and retreat back to D. There we see the unused ticket to B and follow it: D -> B -> C -> JFK -> D. Then we\\'re stuck again, retreat and write down the airports while doing so: Write down D before the already written A, then JFK before the D, etc. When we\\'re back from our cycle at D, the written route is D -> B -> C -> JFK -> D -> A. Then we retreat further along the original path, prepending C, A and finally JFK to the route, ending up with the route JFK -> A -> C -> D -> B -> C -> JFK -> D -> A.\\n\\n  [1]: https://www.stefan-pochmann.info/misc/reconstruct-itinerary.png",
                "codeTag": "Python3"
            },
            {
                "id": 78766,
                "title": "share-my-solution",
                "content": "See also [here](http://algobox.org/reconstruct-itinerary/)\\n\\nAll the airports are vertices and tickets are directed edges. Then all these tickets form a directed graph.\\n\\nThe graph must be Eulerian since we know that a Eulerian path exists.\\n\\nThus, start from \"JFK\", we can apply the Hierholzer's algorithm to find a Eulerian path in the graph which is a valid reconstruction.\\n\\nSince the problem asks for lexical order smallest solution, we can put the neighbors in a min-heap. In this way, we always visit the smallest possible neighbor first in our trip.\\n\\n    public class Solution {\\n\\n        Map<String, PriorityQueue<String>> flights;\\n        LinkedList<String> path;\\n\\n        public List<String> findItinerary(String[][] tickets) {\\n            flights = new HashMap<>();\\n            path = new LinkedList<>();\\n            for (String[] ticket : tickets) {\\n                flights.putIfAbsent(ticket[0], new PriorityQueue<>());\\n                flights.get(ticket[0]).add(ticket[1]);\\n            }\\n            dfs(\"JFK\");\\n            return path;\\n        }\\n\\n        public void dfs(String departure) {\\n            PriorityQueue<String> arrivals = flights.get(departure);\\n            while (arrivals != null && !arrivals.isEmpty())\\n                dfs(arrivals.poll());\\n            path.addFirst(departure);\\n        }\\n    }\\n\\n    79 / 79 test cases passed.\\n    Status: Accepted\\n    Runtime: 11 ms",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n\\n        Map<String, PriorityQueue<String>> flights;\\n        LinkedList<String> path;\\n\\n        public List<String> findItinerary(String[][] tickets) {\\n            flights = new HashMap<>();\\n            path = new LinkedList<>();\\n            for (String[] ticket : tickets) {\\n                flights.putIfAbsent(ticket[0], new PriorityQueue<>());\\n                flights.get(ticket[0]).add(ticket[1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 78799,
                "title": "very-straightforward-dfs-solution-with-detailed-explanations",
                "content": "The nice thing about DFS is it tries a path, and if that\\'s wrong (i.e. path does not lead to solution), DFS goes one step back and tries another path. It continues to do so until we\\'ve found the correct path (which leads to the solution). You need to always bear this nice feature in mind when utilizing DFS to solve problems.\\n\\nIn this problem, the path we are going to find is an itinerary which:\\n1. uses all tickets to travel among airports\\n2. preferably in ascending lexical order of airport code\\n\\nKeep in mind that requirement 1 must be satisfied before we consider 2. If we always choose the airport with the smallest lexical order, this would lead to a perfectly lexical-ordered itinerary, but pay attention that when doing so, there can be a \"dead end\" somewhere in the tickets such that we are not able visit all airports (or we can\\'t use all our tickets), which is bad because it fails to satisfy requirement 1 of this problem. Thus we need to take a step back and try other possible airports, which might not give us a perfectly ordered solution, but will use all tickets and cover all airports.\\n\\nThus it\\'s natural to think about the \"backtracking\" feature of DFS. We start by building a graph and then sorting vertices in the adjacency list so that when we traverse the graph later, we can guarantee the lexical order of the itinerary can be as good as possible. When we have generated an itinerary, we check if we have used all our airline tickets. If not, we revert the change and try another ticket. We keep trying until we have used all our tickets.\\n\\n    public class Solution {\\n        private HashMap<String, List<String>> adjList = new HashMap<>();\\n        private LinkedList<String> route = new LinkedList<>();\\n        private int numTickets = 0;\\n        private int numTicketsUsed = 0;\\n        \\n        public List<String> findItinerary(String[][] tickets) {\\n            if (tickets == null || tickets.length == 0) return route;\\n            // build graph\\n            numTickets = tickets.length;\\n            for (int i = 0; i < tickets.length; ++i) {\\n                if (!adjList.containsKey(tickets[i][0])) {\\n                    // create a new list\\n                    List<String> list = new ArrayList<>();\\n                    list.add(tickets[i][1]);\\n                    adjList.put(tickets[i][0], list);\\n                } else {\\n                    // add to existing list\\n                    adjList.get(tickets[i][0]).add(tickets[i][1]);\\n                }\\n            }\\n            // sort vertices in the adjacency list so they appear in lexical order\\n            for (Map.Entry<String, List<String>> entry : adjList.entrySet()) {\\n                Collections.sort(entry.getValue());\\n            }\\n            \\n            // start DFS\\n            route.add(\"JFK\");\\n            dfsRoute(\"JFK\");\\n            return route;\\n        }\\n        \\n        private void dfsRoute(String v) {\\n            // base case: vertex v is not in adjacency list\\n            // v is not a starting point in any itinerary, or we would have stored it\\n            // thus we have reached end point in our DFS\\n            if (!adjList.containsKey(v)) return;\\n            List<String> list = adjList.get(v);\\n            for (int i = 0; i < list.size(); ++i) {\\n                String neighbor = list.get(i);\\n                // remove ticket(route) from graph\\n                list.remove(i);\\n                route.add(neighbor);\\n                numTicketsUsed++;\\n                dfsRoute(neighbor);\\n                // we only return when we have used all tickets\\n                if (numTickets == numTicketsUsed) return;\\n                // otherwise we need to revert the changes and try other tickets\\n                list.add(i, neighbor);\\n                // This line took me a long time to debug\\n                // we must remove the last airport, since in an itinerary, the same airport can appear many times!!\\n                route.removeLast();\\n                numTicketsUsed--;\\n            }\\n        }\\n        \\n    }\\n\\n\\nUpdated solution:\\nSimpler explanation: the idea is DFS backtracking and we greedily pick the smallest lexical order possible first when we iterate over all our paths. In this case local optimum leads to global optimum. If we try airports with smallest lexical order first then we always find the desired solution first.\\n\\n```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        // dfs backtracking, each time we go to smallest lexical order airport\\n        HashMap<String, TreeMap<String, Integer>> map = new HashMap<>();   // key: Departure, (Arrival, Number of tickets available)\\n        \\n        for (List<String> ticket : tickets) {\\n            String dep = ticket.get(0);\\n            String arr = ticket.get(1);\\n            if (!map.containsKey(dep)) {\\n                map.put(dep, new TreeMap<>());\\n            }\\n            TreeMap<String, Integer> arrMap = map.get(dep);\\n            if (!arrMap.containsKey(arr)) {\\n                arrMap.put(arr, 0);\\n            }\\n            arrMap.put(arr, arrMap.get(arr)+1);\\n        }\\n        \\n        List<String> itinerary = new LinkedList<>();\\n        dfs(map, tickets.size(), itinerary, \"JFK\");\\n        \\n        itinerary.add(0, \"JFK\");\\n        return itinerary;\\n    }\\n    \\n    private boolean dfs(HashMap<String, TreeMap<String, Integer>> map, int numTickets, List<String> itinerary, String depAirport) {\\n        if (itinerary.size() == numTickets) {\\n            return true;\\n        }\\n        \\n        if (!map.containsKey(depAirport)) {\\n            return false;\\n        }\\n        \\n        TreeMap<String, Integer> arrMap = map.get(depAirport);\\n        for (Map.Entry<String, Integer> entry : arrMap.entrySet()) {\\n            String arrAirport = entry.getKey();\\n            int count = entry.getValue();\\n            // if no ticket availble, continue\\n            if (count == 0) {\\n                continue;\\n            }            \\n            // else make choice\\n            itinerary.add(arrAirport);\\n            arrMap.put(arrAirport, count-1);\\n            if (dfs(map, numTickets, itinerary, arrAirport)) {\\n                return true;\\n            }\\n            // revert back if no answer found\\n            itinerary.remove(itinerary.size()-1);\\n            arrMap.put(arrAirport, count);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        // dfs backtracking, each time we go to smallest lexical order airport\\n        HashMap<String, TreeMap<String, Integer>> map = new HashMap<>();   // key: Departure, (Arrival, Number of tickets available)\\n        \\n        for (List<String> ticket : tickets) {\\n            String dep = ticket.get(0);\\n            String arr = ticket.get(1);\\n            if (!map.containsKey(dep)) {\\n                map.put(dep, new TreeMap<>());\\n            }\\n            TreeMap<String, Integer> arrMap = map.get(dep);\\n            if (!arrMap.containsKey(arr)) {\\n                arrMap.put(arr, 0);\\n            }\\n            arrMap.put(arr, arrMap.get(arr)+1);\\n        }\\n        \\n        List<String> itinerary = new LinkedList<>();\\n        dfs(map, tickets.size(), itinerary, \"JFK\");\\n        \\n        itinerary.add(0, \"JFK\");\\n        return itinerary;\\n    }\\n    \\n    private boolean dfs(HashMap<String, TreeMap<String, Integer>> map, int numTickets, List<String> itinerary, String depAirport) {\\n        if (itinerary.size() == numTickets) {\\n            return true;\\n        }\\n        \\n        if (!map.containsKey(depAirport)) {\\n            return false;\\n        }\\n        \\n        TreeMap<String, Integer> arrMap = map.get(depAirport);\\n        for (Map.Entry<String, Integer> entry : arrMap.entrySet()) {\\n            String arrAirport = entry.getKey();\\n            int count = entry.getValue();\\n            // if no ticket availble, continue\\n            if (count == 0) {\\n                continue;\\n            }            \\n            // else make choice\\n            itinerary.add(arrAirport);\\n            arrMap.put(arrAirport, count-1);\\n            if (dfs(map, numTickets, itinerary, arrAirport)) {\\n                return true;\\n            }\\n            // revert back if no answer found\\n            itinerary.remove(itinerary.size()-1);\\n            arrMap.put(arrAirport, count);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375397,
                "title": "simply-simple-python-solution-using-stack-for-dfs-with-comments",
                "content": "\\tclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph = {}\\n        # Create a graph for each airport and keep list of airport reachable from it\\n        for src, dst in tickets:\\n            if src in graph:\\n                graph[src].append(dst)\\n            else:\\n                graph[src] = [dst]\\n\\n        for src in graph.keys():\\n            graph[src].sort(reverse=True)\\n            # Sort children list in descending order so that we can pop last element \\n            # instead of pop out first element which is costly operation\\n        stack = []\\n        res = []\\n        stack.append(\"JFK\")\\n        # Start with JFK as starting airport and keep adding the next child to traverse \\n        # for the last airport at the top of the stack. If we reach to an airport from where \\n        # we can\\'t go further then add it to the result. This airport should be the last to go \\n        # since we can\\'t go anywhere from here. That\\'s why we return the reverse of the result\\n        # After this backtrack to the top airport in the stack and continue to traaverse it\\'s children\\n        \\n        while len(stack) > 0:\\n            elem = stack[-1]\\n            if elem in graph and len(graph[elem]) > 0: \\n                # Check if elem in graph as there may be a case when there is no out edge from an airport \\n                # In that case it won\\'t be present as a key in graph\\n                stack.append(graph[elem].pop())\\n            else:\\n                res.append(stack.pop())\\n                # If there is no further children to traverse then add that airport to res\\n                # This airport should be the last to go since we can\\'t anywhere from this\\n                # That\\'s why we return the reverse of the result\\n        return res[::-1]\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph = {}",
                "codeTag": "Java"
            },
            {
                "id": 709590,
                "title": "python-short-euler-path-finding-o-e-log-e-explained",
                "content": "Actually, in this problem we are asked to find Euler path, smallest lexically. There is classical algorithm with complexity `O(E)`. Starting from the starting vertex `v`, we build a path by adding at each step an edge that has not yet been passed and is adjacent to the current vertex. The vertices of the path are accumulated in stack `S`. When the moment comes when for the current node `w` all the incident edges have already passed, we write the vertices from `S` in output until we meet the node where the incident has not passed yet edges. Then we continue our traversal of the unattended edges. It can be written both with recursion or with stack, recursion version is shorter.\\n\\nHere is a link, where you can plunge deeper into this:\\nhttp://www.graph-magics.com/articles/euler.php\\n\\nIf you neves saw this problem and even if you know what **Euler path** is, I think it is almost impossible to invent this algorighm by yourself, and this problem should be marked as **hard**.\\n\\n**Complexity**: time and space complexity of usual Euler Path Finding algorighm is `O(E+V) = O(E)`, because we traverse each edge only once and number of edges is more than number of vertixes - 1 in Eulerian graph. However as @ainkartik203 mentioned, here we sort our list for every node, so complexity will be `O(E log E)`.\\n\\n```\\nclass Solution:\\n    def dfs(self, airport):\\n        while self.adj_list[airport]:\\n            candidate = self.adj_list[airport].pop()\\n            self.dfs(candidate)\\n        self.route.append(airport)\\n            \\n    def findItinerary(self, tickets):\\n        self.route = []\\n        self.adj_list = defaultdict(list)\\n        for i,j in tickets:\\n            self.adj_list[i].append(j)\\n        for key in self.adj_list: \\n            self.adj_list[key] = sorted(self.adj_list[key], reverse=True)\\n            \\n        self.dfs(\"JFK\")\\n        return self.route[::-1]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def dfs(self, airport):\\n        while self.adj_list[airport]:\\n            candidate = self.adj_list[airport].pop()\\n            self.dfs(candidate)\\n        self.route.append(airport)\\n            \\n    def findItinerary(self, tickets):\\n        self.route = []\\n        self.adj_list = defaultdict(list)\\n        for i,j in tickets:\\n            self.adj_list[i].append(j)\\n        for key in self.adj_list: \\n            self.adj_list[key] = sorted(self.adj_list[key], reverse=True)\\n            \\n        self.dfs(\"JFK\")\\n        return self.route[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78835,
                "title": "28ms-c-beats-100-short-and-elegant",
                "content": "I think this algorithm is often called Fleury's algorithm. But actually it is  Hierholzer's algorithm according to the wiki. Anyway, it works like this:\\n\\nKeep going one path until stuck, then retreat and push the vertices along the route to a stack until it reaches a vertex that has alternative paths, then go along that path and repeat the process.\\nThe assumption for this to work is there is guaranteed to exist one Euler path. (This problem is basically to find a Euler path of a graph).\\n\\n      class Solution {\\n            unordered_map<string, priority_queue<string, vector<string>, greater<string>>> graph;\\n            vector<string> result;\\n            void dfs(string vtex)\\n            {\\n                auto & edges = graph[vtex];\\n                while (!edges.empty())\\n                {\\n                    string to_vtex = edges.top();\\n                    edges.pop();\\n                    dfs(to_vtex);\\n                }\\n                result.push_back(vtex);\\n            }\\n        public:\\n            vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n                for (auto e : tickets)\\n                    graph[e.first].push(e.second);\\n                dfs(\"JFK\");\\n                reverse(result.begin(), result.end());\\n                return result;\\n            }\\n        };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n            unordered_map<string, priority_queue<string, vector<string>, greater<string>>> graph;\\n            vector<string> result;\\n            void dfs(string vtex)\\n            {\\n                auto & edges = graph[vtex];\\n                while (!edges.empty())\\n                {\\n                    string to_vtex = edges.top();\\n                    edges.pop();\\n                    dfs(to_vtex);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4041944,
                "title": "95-76-dfs-recursive-iterative",
                "content": "# Comprehensive Guide to Solving \"Reconstruct Itinerary\": Navigating Airports Like a Pro\\n\\n## Introduction & Problem Statement\\n\\nHello, coding enthusiasts! Today, we\\'ll tackle a problem that combines graph theory and real-world scenarios: \"Reconstruct Itinerary.\" The problem asks you to reconstruct a trip\\'s itinerary given a list of airline tickets. The catch? You start from JFK airport, and if there are multiple valid itineraries, you should return the one that has the smallest lexical order.\\n\\n## Key Concepts and Constraints\\n\\n### What Makes This Problem Unique?\\n\\n1. **Graph Theory**: \\n   The problem can be modeled as a directed graph, where each airport is a node and each ticket represents a directed edge between airports.\\n  \\n2. **Lexical Order**: \\n   Among multiple valid itineraries, the one with the smallest lexical order is preferred.\\n\\n3. **Constraints**: \\n   - 1 <= tickets.length <= 300\\n   - Tickets are given as pairs [fromi, toi] of strings.\\n   - Each string consists of 3 uppercase English letters.\\n\\n### Strategies to Tackle the Problem\\n\\n1. **Recursive DFS**: \\n   This approach leverages the stack memory implicitly during recursion to backtrack and form the itinerary.\\n   \\n2. **Iterative DFS**: \\n   This approach explicitly uses a stack to perform DFS iteratively.\\n\\n---\\n\\n## Live Coding & More in Python\\nhttps://www.youtube.com/watch?v=migy5oXV1Uc\\n\\n## Recursive DFS Explained\\n\\n### Extended Explanation: Logic Behind the \"Find Itinerary\" Solution using Recursive DFS\\n\\n### What is Recursive DFS?\\n\\nDFS, short for Depth-First Search, is a graph-traversal algorithm. In this specific problem, we use the recursive version of DFS, which exploits the call stack to keep track of the airports (vertices) that still need exploration.\\n\\n### The Intricacies of Recursive DFS in \"Find Itinerary\"\\n\\n1. **Initialize the Graph**:  \\n    - We start by initializing an adjacency list `graph` that will serve as a representation of the directed graph of flights. The graph is implemented as a defaultdict containing lists.\\n  \\n    - The adjacency list is constructed by iterating over the given list of ticket pairs, where each pair consists of a source airport and a destination airport.\\n  \\n    - These lists of destinations are sorted in reverse lexical order. This allows us to pop the last element to ensure that we are choosing the smallest lexical order when there are multiple options.\\n\\n2. **DFS Traversal and Exploration**:  \\n    - The traversal starts from the JFK airport, which is our initial point. We initiate a recursive DFS function that takes the current airport as an argument.\\n  \\n    - Inside this function, we enter a loop that continues until we find an airport that has no more destinations left to visit. This is done by checking the adjacency list for each airport and popping the last element (which is the smallest in lexical order).\\n  \\n    - During this process, we recursively call the DFS function for each new destination, essentially diving deeper into the graph.\\n\\n3. **Backtrack and Construct Itinerary**:  \\n    - Once we reach an airport with no outgoing edges, or in other words, no more destinations to visit, we start backtracking.\\n  \\n    - During the backtracking phase, we add the current airport to our `itinerary` list. This list was initially empty and serves as the container for our final solution.\\n\\n    - Importantly, we are essentially building the itinerary in reverse during this phase because of the way DFS works. As we backtrack, we are popping from the call stack, revisiting the airports in the reverse order of how they will eventually appear in the itinerary.\\n\\n4. **Reverse to Get the Final Itinerary**:  \\n    - Since we constructed the itinerary in reverse, the final step is to reverse this list. This gives us the correct order of airports to visit, starting from JFK, and is our final solution.\\n\\n### Time and Space Complexity\\n\\n- **Time Complexity**: $$O(N \\\\log N)$$ due to sorting the tickets.\\n- **Space Complexity**: $$O(N)$$, for storing the graph and the itinerary.\\n\\n# Code Recursive \\n``` Python []\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph = defaultdict(list)\\n        \\n        for src, dst in sorted(tickets, reverse=True):\\n            graph[src].append(dst)\\n            \\n        itinerary = []\\n        def dfs(airport):\\n            while graph[airport]:\\n                dfs(graph[airport].pop())\\n            itinerary.append(airport)\\n        \\n        dfs(\"JFK\")\\n        \\n        return itinerary[::-1]\\n```\\n``` Go []\\nfunc findItinerary(tickets [][]string) []string {\\n\\tgraph := make(map[string][]string)\\n\\t\\n\\tfor _, ticket := range tickets {\\n\\t\\tgraph[ticket[0]] = append(graph[ticket[0]], ticket[1])\\n\\t}\\n\\t\\n\\tfor key := range graph {\\n\\t\\tsort.Sort(sort.Reverse(sort.StringSlice(graph[key])))\\n\\t}\\n\\t\\n\\tvar itinerary []string\\n\\t\\n\\tvar dfs func(airport string)\\n\\tdfs = func(airport string) {\\n\\t\\tfor len(graph[airport]) > 0 {\\n\\t\\t\\tnext := graph[airport][len(graph[airport])-1]\\n\\t\\t\\tgraph[airport] = graph[airport][:len(graph[airport])-1]\\n\\t\\t\\tdfs(next)\\n\\t\\t}\\n\\t\\titinerary = append(itinerary, airport)\\n\\t}\\n\\t\\n\\tdfs(\"JFK\")\\n\\t\\n\\tfor i := 0; i < len(itinerary)/2; i++ {\\n\\t\\titinerary[i], itinerary[len(itinerary)-1-i] = itinerary[len(itinerary)-1-i], itinerary[i]\\n\\t}\\n\\t\\n\\treturn itinerary\\n}\\n```\\n``` Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn find_itinerary(tickets: Vec<Vec<String>>) -> Vec<String> {\\n        let mut graph: HashMap<String, Vec<String>> = HashMap::new();\\n        \\n        for ticket in &tickets {\\n            let (src, dst) = (ticket[0].clone(), ticket[1].clone());\\n            graph.entry(src.clone()).or_insert(vec![]).push(dst);\\n        }\\n\\n        for destinations in graph.values_mut() {\\n            destinations.sort_by(|a, b| b.cmp(a));\\n        }\\n        \\n        let mut itinerary = vec![];\\n        \\n        fn dfs(graph: &mut HashMap<String, Vec<String>>, airport: &str, itinerary: &mut Vec<String>) {\\n            while let Some(next) = graph.get_mut(airport).and_then(|dests| dests.pop()) {\\n                dfs(graph, &next, itinerary);\\n            }\\n            itinerary.push(airport.to_string());\\n        }\\n        \\n        dfs(&mut graph, \"JFK\", &mut itinerary);\\n        \\n        itinerary.reverse();\\n        \\n        itinerary\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, vector<string>> graph;\\n        \\n        for (auto& ticket : tickets) {\\n            graph[ticket[0]].push_back(ticket[1]);\\n        }\\n        \\n        for (auto& [_, destinations] : graph) {\\n            sort(destinations.rbegin(), destinations.rend());\\n        }\\n        \\n        vector<string> itinerary;\\n        \\n        function<void(const string&)> dfs = [&](const string& airport) {\\n            while (!graph[airport].empty()) {\\n                string next = graph[airport].back();\\n                graph[airport].pop_back();\\n                dfs(next);\\n            }\\n            itinerary.push_back(airport);\\n        };\\n        \\n        dfs(\"JFK\");\\n        reverse(itinerary.begin(), itinerary.end());\\n        \\n        return itinerary;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        \\n        for (List<String> ticket : tickets) {\\n            graph.putIfAbsent(ticket.get(0), new PriorityQueue<>());\\n            graph.get(ticket.get(0)).add(ticket.get(1));\\n        }\\n        \\n        LinkedList<String> itinerary = new LinkedList<>();\\n        \\n        dfs(\"JFK\", graph, itinerary);\\n        \\n        return itinerary;\\n    }\\n    \\n    private void dfs(String airport, Map<String, PriorityQueue<String>> graph, LinkedList<String> itinerary) {\\n        PriorityQueue<String> nextAirports = graph.get(airport);\\n        while (nextAirports != null && !nextAirports.isEmpty()) {\\n            dfs(nextAirports.poll(), graph, itinerary);\\n        }\\n        itinerary.addFirst(airport);\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public IList<string> FindItinerary(IList<IList<string>> tickets) {\\n        var graph = new Dictionary<string, List<string>>();\\n        \\n        foreach (var ticket in tickets) {\\n            if (!graph.ContainsKey(ticket[0])) {\\n                graph[ticket[0]] = new List<string>();\\n            }\\n            graph[ticket[0]].Add(ticket[1]);\\n        }\\n        \\n        foreach (var destinations in graph.Values) {\\n            destinations.Sort((a, b) => b.CompareTo(a));\\n        }\\n        \\n        var itinerary = new List<string>();\\n        \\n        void DFS(string airport) {\\n            while (graph.ContainsKey(airport) && graph[airport].Count > 0) {\\n                var next = graph[airport][^1];\\n                graph[airport].RemoveAt(graph[airport].Count - 1);\\n                DFS(next);\\n            }\\n            itinerary.Add(airport);\\n        }\\n        \\n        DFS(\"JFK\");\\n        itinerary.Reverse();\\n        \\n        return itinerary;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n    const graph = {};\\n    \\n    for (const [src, dst] of tickets) {\\n        if (!graph[src]) graph[src] = [];\\n        graph[src].push(dst);\\n    }\\n    \\n    for (const key in graph) {\\n        graph[key].sort().reverse();\\n    }\\n    \\n    const itinerary = [];\\n    \\n    function dfs(airport) {\\n        while (graph[airport] && graph[airport].length > 0) {\\n            dfs(graph[airport].pop());\\n        }\\n        itinerary.push(airport);\\n    }\\n    \\n    dfs(\"JFK\");\\n    \\n    return itinerary.reverse();\\n};\\n```\\n``` PHP []\\nclass Solution {\\n    function findItinerary($tickets) {\\n        $graph = [];\\n        \\n        foreach ($tickets as [$src, $dst]) {\\n            $graph[$src][] = $dst;\\n        }\\n        \\n        foreach ($graph as &$destinations) {\\n            rsort($destinations);\\n        }\\n        \\n        $itinerary = [];\\n        \\n        $dfs = function($airport) use (&$graph, &$itinerary, &$dfs) {\\n            while (!empty($graph[$airport])) {\\n                $dfs(array_pop($graph[$airport]));\\n            }\\n            $itinerary[] = $airport;\\n        };\\n        \\n        $dfs(\"JFK\");\\n        \\n        return array_reverse($itinerary);\\n    }\\n}\\n```\\n\\n## Iterative DFS Explained\\n\\n### How Does Iterative DFS Work?\\n\\nIterative DFS also starts by initializing the graph in the same manner as the recursive approach. The difference lies in the traversal and the building of the itinerary.\\n\\n1. **Initialize Stack**:  \\n   - We explicitly initialize a stack with \"JFK\" as the starting point.\\n  \\n2. **Iterative DFS Traversal**:  \\n   - We use the stack to manage the DFS traversal. For each airport on the stack, we keep visiting its next available destination until it has no outgoing edges.\\n  \\n3. **Build Itinerary**:  \\n   - During this process, we keep adding the current airport to the `itinerary` list.\\n  \\n4. **Reverse the Itinerary**:  \\n   - Finally, we reverse the `itinerary` list to get the final itinerary in correct order.\\n\\n### Time and Space Complexity\\n\\n- **Time Complexity**: $$O(N \\\\log N)$$, due to sorting.\\n- **Space Complexity**: $$O(N)$$, for storing the graph and the itinerary.\\n\\n\\n# Code Iterative\\n``` Python []\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph = defaultdict(list)\\n        \\n        for src, dst in sorted(tickets, reverse=True):\\n            graph[src].append(dst)\\n        \\n        stack = [\"JFK\"]\\n        itinerary = []\\n        \\n        while stack:\\n            while graph[stack[-1]]:\\n                stack.append(graph[stack[-1]].pop())\\n            itinerary.append(stack.pop())\\n        \\n        return itinerary[::-1]\\n```\\n``` Go []\\nfunc findItinerary(tickets [][]string) []string {\\n\\tgraph := make(map[string][]string)\\n\\t\\n\\tfor _, ticket := range tickets {\\n\\t\\tgraph[ticket[0]] = append(graph[ticket[0]], ticket[1])\\n\\t}\\n\\t\\n\\tfor key := range graph {\\n\\t\\tsort.Sort(sort.Reverse(sort.StringSlice(graph[key])))\\n\\t}\\n\\t\\n\\tstack := []string{\"JFK\"}\\n\\tvar itinerary []string\\n\\t\\n\\tfor len(stack) > 0 {\\n\\t\\tfor len(graph[stack[len(stack)-1]]) > 0 {\\n\\t\\t\\tlast := len(graph[stack[len(stack)-1]]) - 1\\n\\t\\t\\tstack = append(stack, graph[stack[len(stack)-1]][last])\\n\\t\\t\\tgraph[stack[len(stack)-2]] = graph[stack[len(stack)-2]][:last]\\n\\t\\t}\\n\\t\\titinerary = append(itinerary, stack[len(stack)-1])\\n\\t\\tstack = stack[:len(stack)-1]\\n\\t}\\n\\t\\n\\tfor i := 0; i < len(itinerary)/2; i++ {\\n\\t\\titinerary[i], itinerary[len(itinerary)-1-i] = itinerary[len(itinerary)-1-i], itinerary[i]\\n\\t}\\n\\t\\n\\treturn itinerary\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    std::vector<std::string> findItinerary(std::vector<std::vector<std::string>>& tickets) {\\n        std::unordered_map<std::string, std::vector<std::string>> graph;\\n        \\n        for (auto& ticket : tickets) {\\n            graph[ticket[0]].push_back(ticket[1]);\\n        }\\n        \\n        for (auto& [_, dests] : graph) {\\n            std::sort(dests.rbegin(), dests.rend());\\n        }\\n        \\n        std::vector<std::string> stack = {\"JFK\"};\\n        std::vector<std::string> itinerary;\\n        \\n        while (!stack.empty()) {\\n            std::string curr = stack.back();\\n            if (graph.find(curr) != graph.end() && !graph[curr].empty()) {\\n                stack.push_back(graph[curr].back());\\n                graph[curr].pop_back();\\n            } else {\\n                itinerary.push_back(stack.back());\\n                stack.pop_back();\\n            }\\n        }\\n        \\n        std::reverse(itinerary.begin(), itinerary.end());\\n        return itinerary;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        \\n        for (List<String> ticket : tickets) {\\n            graph.computeIfAbsent(ticket.get(0), k -> new PriorityQueue<>()).add(ticket.get(1));\\n        }\\n        \\n        LinkedList<String> stack = new LinkedList<>();\\n        stack.add(\"JFK\");\\n        LinkedList<String> itinerary = new LinkedList<>();\\n        \\n        while (!stack.isEmpty()) {\\n            while (graph.getOrDefault(stack.peekLast(), new PriorityQueue<>()).size() > 0) {\\n                stack.add(graph.get(stack.peekLast()).poll());\\n            }\\n            itinerary.addFirst(stack.pollLast());\\n        }\\n        \\n        return itinerary;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n    const graph = {};\\n    \\n    for (const [src, dst] of tickets) {\\n        if (!graph[src]) graph[src] = [];\\n        graph[src].push(dst);\\n    }\\n    \\n    for (const key in graph) {\\n        graph[key].sort((a, b) => b.localeCompare(a));\\n    }\\n    \\n    const stack = [\\'JFK\\'];\\n    const itinerary = [];\\n    \\n    while (stack.length > 0) {\\n        while (graph[stack[stack.length - 1]] && graph[stack[stack.length - 1]].length > 0) {\\n            stack.push(graph[stack[stack.length - 1]].pop());\\n        }\\n        itinerary.push(stack.pop());\\n    }\\n    \\n    return itinerary.reverse();\\n};\\n```\\n``` C# []\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\n\\npublic class Solution {\\n    public IList<string> FindItinerary(IList<IList<string>> tickets) {\\n        var graph = new Dictionary<string, List<string>>();\\n        \\n        foreach (var ticket in tickets) {\\n            if (!graph.ContainsKey(ticket[0])) {\\n                graph[ticket[0]] = new List<string>();\\n            }\\n            graph[ticket[0]].Add(ticket[1]);\\n        }\\n\\n        foreach (var key in graph.Keys) {\\n            graph[key].Sort((a, b) => b.CompareTo(a));\\n        }\\n        \\n        var stack = new Stack<string>();\\n        stack.Push(\"JFK\");\\n        var itinerary = new List<string>();\\n        \\n        while (stack.Count > 0) {\\n            string curr = stack.Peek();\\n            if (graph.ContainsKey(curr) && graph[curr].Count > 0) {\\n                var next = graph[curr].Last();\\n                graph[curr].RemoveAt(graph[curr].Count - 1);\\n                stack.Push(next);\\n            } else {\\n                itinerary.Add(stack.Pop());\\n            }\\n        }\\n        \\n        itinerary.Reverse();\\n        return itinerary;\\n    }\\n}\\n```\\n``` PHP []\\nclass Solution {\\n    function findItinerary($tickets) {\\n        $graph = [];\\n        foreach ($tickets as $ticket) {\\n            $graph[$ticket[0]][] = $ticket[1];\\n        }\\n        \\n        foreach ($graph as &$dests) {\\n            rsort($dests);\\n        }\\n        \\n        $stack = [\"JFK\"];\\n        $itinerary = [];\\n        \\n        while (!empty($stack)) {\\n            while (!empty($graph[end($stack)])) {\\n                array_push($stack, array_pop($graph[end($stack)]));\\n            }\\n            array_push($itinerary, array_pop($stack));\\n        }\\n        \\n        return array_reverse($itinerary);\\n    }\\n}\\n```\\n\\n## Performance\\n\\n| Language   | Time (ms) | Memory (MB) | Approach  |\\n|------------|-----------|-------------|-----------|\\n| Rust       | 5         | 2.2         | Recursive |\\n| Java       | 5         | 44.1        | Recursive |\\n| Go         | 8         | 6.8         | Recursive |\\n| Go         | 10        | 6.7         | Iterative |\\n| C++        | 12        | 14.6        | Recursive |\\n| PHP        | 18        | 21          | Recursive |\\n| JavaScript | 77        | 47.1        | Recursive |\\n| Python3    | 82        | 16.6        | Recursive |\\n| Python3    | 85        | 16.8        | Iterative |\\n| C#         | 178       | 57.7        | Recursive |\\n\\n![b11.png](https://assets.leetcode.com/users/images/c032f122-5ee0-4d4f-b0f2-1758df340ab5_1694653453.7386682.png)\\n\\n\\n## Live Coding+ & Go\\nhttps://youtu.be/_r9OZwy5x4c?si=P-9OousNlDl-cZnJ\\n\\n## Code Highlights and Best Practices\\n\\n- The Recursive DFS is elegant but uses the system stack, making it susceptible to stack overflow for very large graphs.\\n- The Iterative DFS is more flexible as it explicitly uses a stack, allowing for better control over the traversal process.\\n  \\nMastering these approaches not only helps you solve this problem but also enhances your understanding of graph traversal algorithms, which are widely applicable in various domains. So, are you ready to construct some itineraries? Let\\'s get coding!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "PHP",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph = defaultdict(list)\\n        \\n        for src, dst in sorted(tickets, reverse=True):\\n            graph[src].append(dst)\\n            \\n        itinerary = []\\n        def dfs(airport):\\n            while graph[airport]:\\n                dfs(graph[airport].pop())\\n            itinerary.append(airport)\\n        \\n        dfs(\"JFK\")\\n        \\n        return itinerary[::-1]\\n```\n``` Go []\\nfunc findItinerary(tickets [][]string) []string {\\n\\tgraph := make(map[string][]string)\\n\\t\\n\\tfor _, ticket := range tickets {\\n\\t\\tgraph[ticket[0]] = append(graph[ticket[0]], ticket[1])\\n\\t}\\n\\t\\n\\tfor key := range graph {\\n\\t\\tsort.Sort(sort.Reverse(sort.StringSlice(graph[key])))\\n\\t}\\n\\t\\n\\tvar itinerary []string\\n\\t\\n\\tvar dfs func(airport string)\\n\\tdfs = func(airport string) {\\n\\t\\tfor len(graph[airport]) > 0 {\\n\\t\\t\\tnext := graph[airport][len(graph[airport])-1]\\n\\t\\t\\tgraph[airport] = graph[airport][:len(graph[airport])-1]\\n\\t\\t\\tdfs(next)\\n\\t\\t}\\n\\t\\titinerary = append(itinerary, airport)\\n\\t}\\n\\t\\n\\tdfs(\"JFK\")\\n\\t\\n\\tfor i := 0; i < len(itinerary)/2; i++ {\\n\\t\\titinerary[i], itinerary[len(itinerary)-1-i] = itinerary[len(itinerary)-1-i], itinerary[i]\\n\\t}\\n\\t\\n\\treturn itinerary\\n}\\n```\n``` Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn find_itinerary(tickets: Vec<Vec<String>>) -> Vec<String> {\\n        let mut graph: HashMap<String, Vec<String>> = HashMap::new();\\n        \\n        for ticket in &tickets {\\n            let (src, dst) = (ticket[0].clone(), ticket[1].clone());\\n            graph.entry(src.clone()).or_insert(vec![]).push(dst);\\n        }\\n\\n        for destinations in graph.values_mut() {\\n            destinations.sort_by(|a, b| b.cmp(a));\\n        }\\n        \\n        let mut itinerary = vec![];\\n        \\n        fn dfs(graph: &mut HashMap<String, Vec<String>>, airport: &str, itinerary: &mut Vec<String>) {\\n            while let Some(next) = graph.get_mut(airport).and_then(|dests| dests.pop()) {\\n                dfs(graph, &next, itinerary);\\n            }\\n            itinerary.push(airport.to_string());\\n        }\\n        \\n        dfs(&mut graph, \"JFK\", &mut itinerary);\\n        \\n        itinerary.reverse();\\n        \\n        itinerary\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, vector<string>> graph;\\n        \\n        for (auto& ticket : tickets) {\\n            graph[ticket[0]].push_back(ticket[1]);\\n        }\\n        \\n        for (auto& [_, destinations] : graph) {\\n            sort(destinations.rbegin(), destinations.rend());\\n        }\\n        \\n        vector<string> itinerary;\\n        \\n        function<void(const string&)> dfs = [&](const string& airport) {\\n            while (!graph[airport].empty()) {\\n                string next = graph[airport].back();\\n                graph[airport].pop_back();\\n                dfs(next);\\n            }\\n            itinerary.push_back(airport);\\n        };\\n        \\n        dfs(\"JFK\");\\n        reverse(itinerary.begin(), itinerary.end());\\n        \\n        return itinerary;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        \\n        for (List<String> ticket : tickets) {\\n            graph.putIfAbsent(ticket.get(0), new PriorityQueue<>());\\n            graph.get(ticket.get(0)).add(ticket.get(1));\\n        }\\n        \\n        LinkedList<String> itinerary = new LinkedList<>();\\n        \\n        dfs(\"JFK\", graph, itinerary);\\n        \\n        return itinerary;\\n    }\\n    \\n    private void dfs(String airport, Map<String, PriorityQueue<String>> graph, LinkedList<String> itinerary) {\\n        PriorityQueue<String> nextAirports = graph.get(airport);\\n        while (nextAirports != null && !nextAirports.isEmpty()) {\\n            dfs(nextAirports.poll(), graph, itinerary);\\n        }\\n        itinerary.addFirst(airport);\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public IList<string> FindItinerary(IList<IList<string>> tickets) {\\n        var graph = new Dictionary<string, List<string>>();\\n        \\n        foreach (var ticket in tickets) {\\n            if (!graph.ContainsKey(ticket[0])) {\\n                graph[ticket[0]] = new List<string>();\\n            }\\n            graph[ticket[0]].Add(ticket[1]);\\n        }\\n        \\n        foreach (var destinations in graph.Values) {\\n            destinations.Sort((a, b) => b.CompareTo(a));\\n        }\\n        \\n        var itinerary = new List<string>();\\n        \\n        void DFS(string airport) {\\n            while (graph.ContainsKey(airport) && graph[airport].Count > 0) {\\n                var next = graph[airport][^1];\\n                graph[airport].RemoveAt(graph[airport].Count - 1);\\n                DFS(next);\\n            }\\n            itinerary.Add(airport);\\n        }\\n        \\n        DFS(\"JFK\");\\n        itinerary.Reverse();\\n        \\n        return itinerary;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n    const graph = {};\\n    \\n    for (const [src, dst] of tickets) {\\n        if (!graph[src]) graph[src] = [];\\n        graph[src].push(dst);\\n    }\\n    \\n    for (const key in graph) {\\n        graph[key].sort().reverse();\\n    }\\n    \\n    const itinerary = [];\\n    \\n    function dfs(airport) {\\n        while (graph[airport] && graph[airport].length > 0) {\\n            dfs(graph[airport].pop());\\n        }\\n        itinerary.push(airport);\\n    }\\n    \\n    dfs(\"JFK\");\\n    \\n    return itinerary.reverse();\\n};\\n```\n``` PHP []\\nclass Solution {\\n    function findItinerary($tickets) {\\n        $graph = [];\\n        \\n        foreach ($tickets as [$src, $dst]) {\\n            $graph[$src][] = $dst;\\n        }\\n        \\n        foreach ($graph as &$destinations) {\\n            rsort($destinations);\\n        }\\n        \\n        $itinerary = [];\\n        \\n        $dfs = function($airport) use (&$graph, &$itinerary, &$dfs) {\\n            while (!empty($graph[$airport])) {\\n                $dfs(array_pop($graph[$airport]));\\n            }\\n            $itinerary[] = $airport;\\n        };\\n        \\n        $dfs(\"JFK\");\\n        \\n        return array_reverse($itinerary);\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph = defaultdict(list)\\n        \\n        for src, dst in sorted(tickets, reverse=True):\\n            graph[src].append(dst)\\n        \\n        stack = [\"JFK\"]\\n        itinerary = []\\n        \\n        while stack:\\n            while graph[stack[-1]]:\\n                stack.append(graph[stack[-1]].pop())\\n            itinerary.append(stack.pop())\\n        \\n        return itinerary[::-1]\\n```\n``` Go []\\nfunc findItinerary(tickets [][]string) []string {\\n\\tgraph := make(map[string][]string)\\n\\t\\n\\tfor _, ticket := range tickets {\\n\\t\\tgraph[ticket[0]] = append(graph[ticket[0]], ticket[1])\\n\\t}\\n\\t\\n\\tfor key := range graph {\\n\\t\\tsort.Sort(sort.Reverse(sort.StringSlice(graph[key])))\\n\\t}\\n\\t\\n\\tstack := []string{\"JFK\"}\\n\\tvar itinerary []string\\n\\t\\n\\tfor len(stack) > 0 {\\n\\t\\tfor len(graph[stack[len(stack)-1]]) > 0 {\\n\\t\\t\\tlast := len(graph[stack[len(stack)-1]]) - 1\\n\\t\\t\\tstack = append(stack, graph[stack[len(stack)-1]][last])\\n\\t\\t\\tgraph[stack[len(stack)-2]] = graph[stack[len(stack)-2]][:last]\\n\\t\\t}\\n\\t\\titinerary = append(itinerary, stack[len(stack)-1])\\n\\t\\tstack = stack[:len(stack)-1]\\n\\t}\\n\\t\\n\\tfor i := 0; i < len(itinerary)/2; i++ {\\n\\t\\titinerary[i], itinerary[len(itinerary)-1-i] = itinerary[len(itinerary)-1-i], itinerary[i]\\n\\t}\\n\\t\\n\\treturn itinerary\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    std::vector<std::string> findItinerary(std::vector<std::vector<std::string>>& tickets) {\\n        std::unordered_map<std::string, std::vector<std::string>> graph;\\n        \\n        for (auto& ticket : tickets) {\\n            graph[ticket[0]].push_back(ticket[1]);\\n        }\\n        \\n        for (auto& [_, dests] : graph) {\\n            std::sort(dests.rbegin(), dests.rend());\\n        }\\n        \\n        std::vector<std::string> stack = {\"JFK\"};\\n        std::vector<std::string> itinerary;\\n        \\n        while (!stack.empty()) {\\n            std::string curr = stack.back();\\n            if (graph.find(curr) != graph.end() && !graph[curr].empty()) {\\n                stack.push_back(graph[curr].back());\\n                graph[curr].pop_back();\\n            } else {\\n                itinerary.push_back(stack.back());\\n                stack.pop_back();\\n            }\\n        }\\n        \\n        std::reverse(itinerary.begin(), itinerary.end());\\n        return itinerary;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        \\n        for (List<String> ticket : tickets) {\\n            graph.computeIfAbsent(ticket.get(0), k -> new PriorityQueue<>()).add(ticket.get(1));\\n        }\\n        \\n        LinkedList<String> stack = new LinkedList<>();\\n        stack.add(\"JFK\");\\n        LinkedList<String> itinerary = new LinkedList<>();\\n        \\n        while (!stack.isEmpty()) {\\n            while (graph.getOrDefault(stack.peekLast(), new PriorityQueue<>()).size() > 0) {\\n                stack.add(graph.get(stack.peekLast()).poll());\\n            }\\n            itinerary.addFirst(stack.pollLast());\\n        }\\n        \\n        return itinerary;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n    const graph = {};\\n    \\n    for (const [src, dst] of tickets) {\\n        if (!graph[src]) graph[src] = [];\\n        graph[src].push(dst);\\n    }\\n    \\n    for (const key in graph) {\\n        graph[key].sort((a, b) => b.localeCompare(a));\\n    }\\n    \\n    const stack = [\\'JFK\\'];\\n    const itinerary = [];\\n    \\n    while (stack.length > 0) {\\n        while (graph[stack[stack.length - 1]] && graph[stack[stack.length - 1]].length > 0) {\\n            stack.push(graph[stack[stack.length - 1]].pop());\\n        }\\n        itinerary.push(stack.pop());\\n    }\\n    \\n    return itinerary.reverse();\\n};\\n```\n``` C# []\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\n\\npublic class Solution {\\n    public IList<string> FindItinerary(IList<IList<string>> tickets) {\\n        var graph = new Dictionary<string, List<string>>();\\n        \\n        foreach (var ticket in tickets) {\\n            if (!graph.ContainsKey(ticket[0])) {\\n                graph[ticket[0]] = new List<string>();\\n            }\\n            graph[ticket[0]].Add(ticket[1]);\\n        }\\n\\n        foreach (var key in graph.Keys) {\\n            graph[key].Sort((a, b) => b.CompareTo(a));\\n        }\\n        \\n        var stack = new Stack<string>();\\n        stack.Push(\"JFK\");\\n        var itinerary = new List<string>();\\n        \\n        while (stack.Count > 0) {\\n            string curr = stack.Peek();\\n            if (graph.ContainsKey(curr) && graph[curr].Count > 0) {\\n                var next = graph[curr].Last();\\n                graph[curr].RemoveAt(graph[curr].Count - 1);\\n                stack.Push(next);\\n            } else {\\n                itinerary.Add(stack.Pop());\\n            }\\n        }\\n        \\n        itinerary.Reverse();\\n        return itinerary;\\n    }\\n}\\n```\n``` PHP []\\nclass Solution {\\n    function findItinerary($tickets) {\\n        $graph = [];\\n        foreach ($tickets as $ticket) {\\n            $graph[$ticket[0]][] = $ticket[1];\\n        }\\n        \\n        foreach ($graph as &$dests) {\\n            rsort($dests);\\n        }\\n        \\n        $stack = [\"JFK\"];\\n        $itinerary = [];\\n        \\n        while (!empty($stack)) {\\n            while (!empty($graph[end($stack)])) {\\n                array_push($stack, array_pop($graph[end($stack)]));\\n            }\\n            array_push($itinerary, array_pop($stack));\\n        }\\n        \\n        return array_reverse($itinerary);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78832,
                "title": "short-c-dfs-iterative-44ms-solution-with-explanation-no-recursive-calls-no-backtracking",
                "content": "    class Solution {\\n    public:\\n    \\tvector<string> findItinerary(vector<pair<string, string>> tickets) {\\n    \\t\\t// Each node (airport) contains a set of outgoing edges (destination).\\n    \\t\\tunordered_map<string, multiset<string>> graph;\\n    \\t\\t// We are always appending the deepest node to the itinerary, \\n    \\t\\t// so will need to reverse the itinerary in the end.\\n    \\t\\tvector<string> itinerary;\\n    \\t\\tif (tickets.size() == 0){\\n    \\t\\t\\treturn itinerary;\\n    \\t\\t}\\n    \\t\\t// Construct the node and assign outgoing edges\\n    \\t\\tfor (pair<string, string> eachTicket : tickets){\\n    \\t\\t\\tgraph[eachTicket.first].insert(eachTicket.second);\\n    \\t\\t}\\n    \\t\\tstack<string> dfs;\\n    \\t\\tdfs.push(\"JFK\");\\n    \\t\\twhile (!dfs.empty()){\\n    \\t\\t\\tstring topAirport = dfs.top();\\n    \\t\\t\\tif (graph[topAirport].empty()){\\n    \\t\\t\\t\\t// If there is no more outgoing edges, append to itinerary\\n    \\t\\t\\t\\t// Two cases: \\n    \\t\\t\\t\\t// 1. If it searchs the terminal end first, it will simply get\\n    \\t\\t\\t\\t//    added to the itinerary first as it should, and the proper route\\n    \\t\\t\\t\\t//    will still be traversed since its entry is still on the stack.\\n    \\t\\t\\t\\t// 2. If it search the proper route first, the dead end route will also\\n    \\t\\t\\t\\t//    get added to the itinerary first.\\n    \\t\\t\\t\\titinerary.push_back(topAirport);\\n    \\t\\t\\t\\tdfs.pop();\\n    \\t\\t\\t}\\n    \\t\\t\\telse {\\n    \\t\\t\\t\\t// Otherwise push the outgoing edge to the dfs stack and \\n    \\t\\t\\t\\t// remove it from the node.\\n    \\t\\t\\t\\tdfs.push(*(graph[topAirport].begin()));\\n    \\t\\t\\t\\tgraph[topAirport].erase(graph[topAirport].begin());\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t// Reverse the itinerary.\\n    \\t\\treverse(itinerary.begin(), itinerary.end());\\n    \\t\\treturn itinerary;\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public:\\n    \\tvector<string> findItinerary(vector<pair<string, string>> tickets) {\\n    \\t\\t// Each node (airport) contains a set of outgoing edges (destination).\\n    \\t\\tunordered_map<string, multiset<string>> graph;\\n    \\t\\t// We are always appending the deepest node to the itinerary, \\n    \\t\\t// so will need to reverse the itinerary in the end.\\n    \\t\\tvector<string> itinerary;\\n    \\t\\tif (tickets.size() == 0){\\n    \\t\\t\\treturn itinerary;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 359942,
                "title": "awesome-question-new-algo-to-learn-eulerian-path-full-explanation-code",
                "content": "Will explain things one by one, follow if really wants to understand the algorithm\\n\\n**This problem is based on Eulerian Path in graph**\\nWiki:\\nEulerian path\\n In graph theory, an Eulerian trail (or Eulerian path) is a trail in a finite graph that visits every edge exactly once (allowing for revisiting vertices).\\n Similarly, an Eulerian circuit or Eulerian cycle is an Eulerian trail that starts and ends on the same vertex. They were first discussed by Leonhard Euler while solving the\\n famous Seven Bridges of K\\xF6nigsberg problem in 1736. The problem can be stated mathematically like this:\\n\\n Given the graph in the image, is it possible to construct a path (or a cycle, i.e. a path starting and ending on the same vertex) that visits each edge exactly once?\\n Euler proved that a necessary condition for the existence of Eulerian circuits is that all vertices in the graph have an even degree, and stated without proof that connected\\n graphs with all vertices of even degree have an Eulerian circuit.\\n This is known as Euler\\'s Theorem:\\n\\n**A connected graph has an Euler cycle iff every vertex has even degree**\\n \\n ```\\n A Graph must have nodes with even degree and odd degree. All the odd degree nodes are either start or end but all the even degree node will be only intermediate nodes.\\n But in case when all the nodes has even degree, then it contains the Eulerian Tour, as we we\\'ll start from some node and will end to this same node, as we need to consume all the edges.\\n```\\n\\n* Important:\\n If all nodes in graph has odd degree than its not possible to build Eulerian Path, as for coming and going from/to a node we require even degree for some of the node.\\n\\nWants learn more:\\n* Must Watch:\\nEulerian Path - Intro to Algorithms: https://www.youtube.com/watch?v=ycRuO-u6rt8\\nEulerian Path Solution - Intro to Algorithms: https://www.youtube.com/watch?v=Dx1lpbpSHwI\\n\\nOk now lets do step by step ;\\nFrom: https://leetcode.com/problems/reconstruct-itinerary/discuss/78768/Short-Ruby-Python-Java-C%2B%2B\\nFirst keep going forward until you get stuck. That\\'s a good main path already. Remaining tickets form cycles which are found on the\\nway back and get merged into that main path. By writing down the path backwards when retreating from recursion, merging the cycles into the main path is easy -\\n the end part of the path has already been written, the start part of the path hasn\\'t been written yet, so just write down the cycle now and then keep backwards-writing the path.\\n\\nLets build the graph using input;  PriorityQueue use to achieve lexical order\\n\\n```\\n\\n    private Map<String, PriorityQueue<String>> buildGraph(List<List<String>> tickets) {\\n\\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n\\n        for (List<String> ticket : tickets) {\\n            String source = ticket.get(0);\\n            String destination = ticket.get(1);\\n\\n            if (!graph.containsKey(source))\\n                graph.put(source, new PriorityQueue<>());\\n\\n            graph.get(source).add(destination);\\n\\n        }\\n        return graph;\\n    }\\n```\\n ```\\n For input like :\\n [[JFK, A], [JFK, D] , [A,C], [B,C] , [C, JFK], [C , D], [D,A] , [D, B] ]\\n \\n It will build graph like this \\n {\\'JFK\\': [\\'A\\', \\'D\\'], \\'A\\': [\\'C\\'], \\'B\\': [\\'C\\'], \\'C\\': [\\'D\\', \\'JFK\\'], \\'D\\': [\\'A\\', \\'B\\']}\\n \\n      targets = {\\'JFK\\': [\\'A\\', \\'D\\'], \\'A\\': [\\'C\\'], \\'B\\': [\\'C\\'], \\'C\\': [\\'D\\', \\'JFK\\'], \\'D\\': [\\'A\\', \\'B\\']}\\n     route = []\\n     stack = [\\'JFK\\']\\n     First point at which we get stuck:\\n\\n    \\n     targets = {\\'JFK\\': [\\'D\\'], \\'A\\': [], \\'B\\': [\\'C\\'], \\'C\\': [\\'D\\' , \\'JFK\\',], \\'D\\': [\\'B\\']}\\n     route = []\\n     stack = [\\'JFK\\', \\'A\\', \\'C\\', \\'D\\', \\'A\\']\\n     Update route:\\n\\n    \\n     targets = {\\'JFK\\': [\\'D\\'], \\'A\\': [], \\'B\\': [\\'C\\'], \\'C\\': [\\'JFK\\'], \\'D\\': [\\'B\\']}\\n     route = [\\'A\\']\\n     stack = [\\'JFK\\', \\'A\\', \\'C\\', \\'D\\']\\n     Search forward again until stuck:\\n\\n    \\n     targets = {\\'JFK\\': [], \\'A\\': [], \\'B\\': [], \\'C\\': [], \\'D\\': []}\\n     route = [\\'A\\']\\n     stack = [\\'JFK\\', \\'A\\', \\'C\\', \\'D\\', \\'B\\', \\'C\\', \\'JFK\\', \\'D\\']\\n     Update route:\\n\\n    \\n     targets = {\\'JFK\\': [\\'D\\'], \\'A\\': [], \\'B\\': [], \\'C\\': [\\'JFK\\'], \\'D\\': []}\\n     route = [\\'A\\', \\'D\\', \\'JFK\\', \\'C\\', \\'B\\', \\'D\\', \\'C\\', \\'A\\', \\'JFK\\']\\n     stack = []\\n     Return route in reverse:\\n\\n    \\n     route = [\\'JFK\\', \\'A\\', \\'C\\', \\'D\\', \\'B\\', \\'C\\', \\'JFK\\', \\'D\\', \\'A\\']\\n\\t \\n\\t```\\n\\t\\n\\tCode:\\n\\t```\\n private void dfs(List<String> itinerary, Map<String, PriorityQueue<String>> graph, String source) {\\n\\n        /**\\n         * if now more destination possible from this source, then we are at the bottom most.\\n         */\\n        if (graph.get(source) == null || graph.get(source).isEmpty()) {\\n            itinerary.add(source);\\n            return;\\n        }\\n\\n\\n        /**\\n         * Try all the destination from this source incrementally.\\n         * This is important for input like [[JFK, KUL], [JFK, NRT], [NRT, JFK]]\\n         * because once you reach Kul, you can\\'t go anywhere but we have tickets left, so we should go NTR first\\n         */\\n        while (!graph.get(source).isEmpty()) {\\n            String nextDestination = graph.get(source).poll();\\n            dfs(itinerary, graph, nextDestination);\\n        }\\n        /**\\n         * We are at the bottom, traverse back\\n         */\\n        itinerary.add(source);\\n\\n    }\\n\\t\\n\\t public List<String> findItinerary(List<List<String>> tickets) {\\n\\n        if (tickets == null || tickets.isEmpty())\\n            return Collections.EMPTY_LIST;\\n\\n        Map<String, PriorityQueue<String>> graph = buildGraph(tickets);\\n\\n        List<String> itinerary = new ArrayList<>(graph.size());\\n        dfs(itinerary, graph, \"JFK\");\\n\\n        Collections.reverse(itinerary);\\n        return itinerary;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n A Graph must have nodes with even degree and odd degree. All the odd degree nodes are either start or end but all the even degree node will be only intermediate nodes.\\n But in case when all the nodes has even degree, then it contains the Eulerian Tour, as we we\\'ll start from some node and will end to this same node, as we need to consume all the edges.\\n```\n```\\n\\n    private Map<String, PriorityQueue<String>> buildGraph(List<List<String>> tickets) {\\n\\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n\\n        for (List<String> ticket : tickets) {\\n            String source = ticket.get(0);\\n            String destination = ticket.get(1);\\n\\n            if (!graph.containsKey(source))\\n                graph.put(source, new PriorityQueue<>());\\n\\n            graph.get(source).add(destination);\\n\\n        }\\n        return graph;\\n    }\\n```\n```\\n For input like :\\n [[JFK, A], [JFK, D] , [A,C], [B,C] , [C, JFK], [C , D], [D,A] , [D, B] ]\\n \\n It will build graph like this \\n {\\'JFK\\': [\\'A\\', \\'D\\'], \\'A\\': [\\'C\\'], \\'B\\': [\\'C\\'], \\'C\\': [\\'D\\', \\'JFK\\'], \\'D\\': [\\'A\\', \\'B\\']}\\n \\n      targets = {\\'JFK\\': [\\'A\\', \\'D\\'], \\'A\\': [\\'C\\'], \\'B\\': [\\'C\\'], \\'C\\': [\\'D\\', \\'JFK\\'], \\'D\\': [\\'A\\', \\'B\\']}\\n     route = []\\n     stack = [\\'JFK\\']\\n     First point at which we get stuck:\\n\\n    \\n     targets = {\\'JFK\\': [\\'D\\'], \\'A\\': [], \\'B\\': [\\'C\\'], \\'C\\': [\\'D\\' , \\'JFK\\',], \\'D\\': [\\'B\\']}\\n     route = []\\n     stack = [\\'JFK\\', \\'A\\', \\'C\\', \\'D\\', \\'A\\']\\n     Update route:\\n\\n    \\n     targets = {\\'JFK\\': [\\'D\\'], \\'A\\': [], \\'B\\': [\\'C\\'], \\'C\\': [\\'JFK\\'], \\'D\\': [\\'B\\']}\\n     route = [\\'A\\']\\n     stack = [\\'JFK\\', \\'A\\', \\'C\\', \\'D\\']\\n     Search forward again until stuck:\\n\\n    \\n     targets = {\\'JFK\\': [], \\'A\\': [], \\'B\\': [], \\'C\\': [], \\'D\\': []}\\n     route = [\\'A\\']\\n     stack = [\\'JFK\\', \\'A\\', \\'C\\', \\'D\\', \\'B\\', \\'C\\', \\'JFK\\', \\'D\\']\\n     Update route:\\n\\n    \\n     targets = {\\'JFK\\': [\\'D\\'], \\'A\\': [], \\'B\\': [], \\'C\\': [\\'JFK\\'], \\'D\\': []}\\n     route = [\\'A\\', \\'D\\', \\'JFK\\', \\'C\\', \\'B\\', \\'D\\', \\'C\\', \\'A\\', \\'JFK\\']\\n     stack = []\\n     Return route in reverse:\\n\\n    \\n     route = [\\'JFK\\', \\'A\\', \\'C\\', \\'D\\', \\'B\\', \\'C\\', \\'JFK\\', \\'D\\', \\'A\\']\\n\\t \\n\\t```\n```\\n private void dfs(List<String> itinerary, Map<String, PriorityQueue<String>> graph, String source) {\\n\\n        /**\\n         * if now more destination possible from this source, then we are at the bottom most.\\n         */\\n        if (graph.get(source) == null || graph.get(source).isEmpty()) {\\n            itinerary.add(source);\\n            return;\\n        }\\n\\n\\n        /**\\n         * Try all the destination from this source incrementally.\\n         * This is important for input like [[JFK, KUL], [JFK, NRT], [NRT, JFK]]\\n         * because once you reach Kul, you can\\'t go anywhere but we have tickets left, so we should go NTR first\\n         */\\n        while (!graph.get(source).isEmpty()) {\\n            String nextDestination = graph.get(source).poll();\\n            dfs(itinerary, graph, nextDestination);\\n        }\\n        /**\\n         * We are at the bottom, traverse back\\n         */\\n        itinerary.add(source);\\n\\n    }\\n\\t\\n\\t public List<String> findItinerary(List<List<String>> tickets) {\\n\\n        if (tickets == null || tickets.isEmpty())\\n            return Collections.EMPTY_LIST;\\n\\n        Map<String, PriorityQueue<String>> graph = buildGraph(tickets);\\n\\n        List<String> itinerary = new ArrayList<>(graph.size());\\n        dfs(itinerary, graph, \"JFK\");\\n\\n        Collections.reverse(itinerary);\\n        return itinerary;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 78846,
                "title": "very-short-iterative-java-solution",
                "content": "Just using a hashmap and stack to replace recursion.\\n\\n    public List<String> findItinerary(String[][] tickets) {\\n        LinkedList<String> ret = new LinkedList<String>();\\n        Map<String, PriorityQueue<String>> map = new HashMap<String, PriorityQueue<String>>();\\n        Stack<String> stack = new Stack<String>();\\n        for(String[] t : tickets) {\\n            if(!map.containsKey(t[0])) map.put(t[0], new PriorityQueue<String>());\\n            map.get(t[0]).offer(t[1]);\\n        }\\n        stack.push(\"JFK\");\\n        while(!stack.isEmpty()) {\\n            String next = stack.peek();\\n            if(map.containsKey(next) && map.get(next).size() > 0) stack.push(map.get(next).poll());\\n            else ret.addFirst(stack.pop());\\n        }\\n        return ret;\\n    }",
                "solutionTags": [],
                "code": "Just using a hashmap and stack to replace recursion.\\n\\n    public List<String> findItinerary(String[][] tickets) {\\n        LinkedList<String> ret = new LinkedList<String>();\\n        Map<String, PriorityQueue<String>> map = new HashMap<String, PriorityQueue<String>>();\\n        Stack<String> stack = new Stack<String>();\\n        for(String[] t : tickets) {\\n            if(!map.containsKey(t[0])) map.put(t[0], new PriorityQueue<String>());\\n            map.get(t[0]).offer(t[1]);\\n        }\\n        stack.push(\"JFK\");\\n        while(!stack.isEmpty()) {\\n            String next = stack.peek();\\n            if(map.containsKey(next) && map.get(next).size() > 0) stack.push(map.get(next).poll());\\n            else ret.addFirst(stack.pop());\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 631629,
                "title": "c-solution-with-detailed-explanation",
                "content": "```\\nThis is the variation of dfs.\\nThe way to tweak the dfs is to not to put a base condition and let the dfs fill and tsack and empty itslef\\nWhat i mean by this is \\n\\nInput: [[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]]\\nLets say we built a graph of this and its adjacenecy list look like this:-\\nJFK - MUC\\nMUC - LHR\\nLHR - SFO\\nSFO - SJC\\n\\nSo when we perform a dfs on JFK\\n\\n|        |\\n|        |\\n|        |   <-----Recursion Stack\\n|        |\\n|__JFK___|\\n\\nWe explore JFKs neighbors \\n\\n|        |\\n|        |\\n|        |\\n|  MUC   |\\n|__JFK___|\\n\\nWe explore Muc neighbors\\n\\n|        |\\n|        |\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|        |\\n|  SFO   |\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|  SJC   |\\n|  SFO   |\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\nSince SJC has no neighbors we pus it back to the answer\\n\\n|        |\\n|  SFO   |      ans=SJC\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|        |\\n|        |      ans=SJC,SFO\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|        |\\n|        |      ans=SJC,SFO,LHR\\n|        |\\n|  MUC   |\\n|__JFK___|\\n\\n\\n|        |\\n|        |      ans=SJC,SFO,LHR,MUC \\n|        |\\n|        |\\n|__JFK___|\\n\\n|        |\\n|        |      ans=SJC,SFO,LHR,MUC,JFK \\n|        |\\n|        |\\n|________|\\n\\nWe reverse the array and return it.\\n\\n    unordered_map<string,priority_queue<string,vector<string>,greater<string>>> map;  //We use priority queue for lexographic ordering\\n    vector<string> ans;\\n    void dfs(string s)\\n    {\\n        auto &x=map[s];\\n        while(!x.empty())\\n        {\\n            string to=x.top();\\n            x.pop();\\n            dfs(to);\\n        }\\n        cout<<s<<endl;\\n        ans.push_back(s);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        for(auto &x:tickets)\\n            map[x[0]].push(x[1]);\\n        dfs(\"JFK\");\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nThis is the variation of dfs.\\nThe way to tweak the dfs is to not to put a base condition and let the dfs fill and tsack and empty itslef\\nWhat i mean by this is \\n\\nInput: [[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]]\\nLets say we built a graph of this and its adjacenecy list look like this:-\\nJFK - MUC\\nMUC - LHR\\nLHR - SFO\\nSFO - SJC\\n\\nSo when we perform a dfs on JFK\\n\\n|        |\\n|        |\\n|        |   <-----Recursion Stack\\n|        |\\n|__JFK___|\\n\\nWe explore JFKs neighbors \\n\\n|        |\\n|        |\\n|        |\\n|  MUC   |\\n|__JFK___|\\n\\nWe explore Muc neighbors\\n\\n|        |\\n|        |\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|        |\\n|  SFO   |\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|  SJC   |\\n|  SFO   |\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\nSince SJC has no neighbors we pus it back to the answer\\n\\n|        |\\n|  SFO   |      ans=SJC\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|        |\\n|        |      ans=SJC,SFO\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|        |\\n|        |      ans=SJC,SFO,LHR\\n|        |\\n|  MUC   |\\n|__JFK___|\\n\\n\\n|        |\\n|        |      ans=SJC,SFO,LHR,MUC \\n|        |\\n|        |\\n|__JFK___|\\n\\n|        |\\n|        |      ans=SJC,SFO,LHR,MUC,JFK \\n|        |\\n|        |\\n|________|\\n\\nWe reverse the array and return it.\\n\\n    unordered_map<string,priority_queue<string,vector<string>,greater<string>>> map;  //We use priority queue for lexographic ordering\\n    vector<string> ans;\\n    void dfs(string s)\\n    {\\n        auto &x=map[s];\\n        while(!x.empty())\\n        {\\n            string to=x.top();\\n            x.pop();\\n            dfs(to);\\n        }\\n        cout<<s<<endl;\\n        ans.push_back(s);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        for(auto &x:tickets)\\n            map[x[0]].push(x[1]);\\n        dfs(\"JFK\");\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4042004,
                "title": "beats-99-17-dfs-recursive-iterative-euler-path-intuition-commented-code",
                "content": "# Problem Description\\nThe task is **reconstructing** an itinerary using a list of airline tickets.\\nEach ticket is represented as a pair of departure and arrival airports, denoted as `tickets[i] = [fromi, toi]`.\\n**The goal** is to create an **ordered** itinerary, starting with the airport `JFK` (the departure point), while ensuring that all tickets are used **once**. If there are multiple valid itineraries, you should return the one with the **smallest lexical order** when read as a single string.\\n\\n- **Constraints:**\\n    - `1 <= tickets.length <= 300`\\n    - `tickets[i].length == 2`\\n    - Each town name is at most **3 letters**\\n    - `fromi` and `toi` consist of uppercase English letters.\\n    - `fromi` != `toi`\\n    - Start from `JFK`\\n    - Use each ticket **once and only once**\\n\\n\\n\\n---\\n\\n# Intuition\\nHi there\\uD83D\\uDE00\\nLet\\'s take a look on this interesting problem. It is also challenging one.\\n\\nFor our airports problem we have two **crucial points** we must put in mind: We must use each ticket once and only once, there is atleast one valid itinerary as a solution of the problem.\\n\\nWhat can we **conclude** from that? \\uD83E\\uDD14\\nThe graph that we will build out of tickets list is something called **Semi Euler Graph** and the path that we want is called **Euler Path**.\\nI won\\'t talk about them in depth because they are advanced topics even for me. \\uD83D\\uDE02 but I will give a simple Intuition.\\n\\n\\nLet\\'s call some graph termenolgies that we want later.\\n- **In-degree** for a node: number of edges that points to a specific node.\\n- **Out-degree** for anode: number of edges coming out from a node.\\n\\nLet\\'s see an **exmaple**:\\n![image.png](https://assets.leetcode.com/users/images/f77a0035-03c5-4866-babf-5158a90eedd5_1694660526.9899151.png)\\n| Node | In-degree | Out-degree | \\n| :--- | ---:| :---: | \\n| a | 1 | 2 | \\n| b | 1 | 1 | \\n| c | 1 | 1 |\\n| d | 1 | 0 |  \\n\\n\\na **Semi Euler Graph** is a graph that has **Euler Path** which mean there is a path from starting node to an ending node and we will use all edges once and only once.\\nHuh looks familiar\\uD83E\\uDD14... Yes ITS OUR PROBLEM!!\\uD83E\\uDD2F\\n\\nFor a **directed graph** to be a **Semi Euler Graph** it must meet some conditions:\\n- **In degree** for all nodes = **Out degree** for `all` nodes\\n- Except for two node: \\n    - `Starting` node should have `Out-degree = In degree + 1`\\n    - `Ending` node should have `In-degree = Out-degree + 1`\\n\\n\\nLet\\'s see some examples for our original problem.\\n\\n![image.png](https://assets.leetcode.com/users/images/f77a0035-03c5-4866-babf-5158a90eedd5_1694660526.9899151.png)\\n\\n\\nIn this example, we can see that `d` airport meets the condition for an ending node and `a` meets the condition for a starting node.\\nAn answer will be `(a, b, c, d)` \\n\\n![image.png](https://assets.leetcode.com/users/images/672954c8-7a41-43ae-aeb1-ca8499802fc9_1694660033.5385113.png)\\n\\nIn this example, we can see that `b` airport meets the condition for an ending node and `a` meets the condition for a starting node.\\nAn answer will be also `(a, b, c, d, b)` \\n\\n![image.png](https://assets.leetcode.com/users/images/09129f1c-1d18-468f-99e0-031b24d6e49e_1694659216.810375.png)\\nIn this example, we can see that the nodes didn\\'t meet the condition to be an **Semi Euler Graph**.\\nAnd if you tried to put it as a test case it will tell you `invalid input`.\\n\\nOkay, I think we have something here\\uD83E\\uDD2F \\nThe Pseudo Code for finding Euler Path is easy the only editing we will do it to sort the edges for the graph to be in the smallest lexical order.\\n\\nand for this problem, we will find for each test case that `JFK` meets the conditions to be a starting node.\\n\\nAnd that\\'s it the solution for our problem only a **Semi Euler Graph** \\uD83D\\uDE02\\n\\n\\n\\n---\\n\\n\\n# Approach\\n## 1. DFS Recursive\\n### Steps\\n- Initialize a `flightGraph` as a `dictionary (map)` to represent flights and an itinerary list to store the final travel sequence.\\n- Iterate through each ticket and populate the `flightGraph` dictionary.\\n- Sort the destinations for each airport in reverse order to visit **lexical smaller** destinations first.\\n- Start the DFS traversal from the `JFK` airport.\\n- Using the **depth-first search** (DFS) method called `dfs` that takes an airport as input and recursively explores its destinations while **maintaining lexical order**. It adds the visited airports to the itinerary list.\\n- **Reverse** the itinerary list to get the correct travel order.\\n- **Return** the itinerary list as the final result.\\n\\n### Complexity\\n- **Time complexity:** $$O(N^2log(N))$$\\nSince we loop over lists of destinations in the flight graph and sorts them. Sorting each list has a time complexity of `O(E * log(E))`, where E is the total number of edges (tickets). Since `E` can be at most `N`, this step has a time complexity of `O(N * log(N))`. and since we loop over `N` city then the total time complexity is `O(N^2log(N))` where `N` is the number of airports.\\n- **Space complexity:** $$O(N+E)$$\\nWe are storing the Flight Graph which is represented using map of lists, which will have at most `N` keys (airports) and a total of `E` values (destinations). Therefore, the space complexity is `O(N + E)`.\\n\\n\\n---\\n\\n## 2. DFS Iterative\\n### Steps\\n- Initialize a `flightGraph` as a `dictionary (map)` to represent flights and an itinerary list to store the final travel sequence.\\n- Iterate through each ticket and populate the `flightGraph` dictionary.\\n- Sort the destinations for each airport in reverse order to visit **lexical smaller** destinations first.\\n- **Start** with `JFK` as the initial airport and create a stack.\\n- While the stack is `not empty`:\\n    - **Explore** destinations:\\n        - Push the next destination onto the stack.\\n    - **Backtrack**:\\n        - Add the current airport to the travel itinerary.\\n        - Pop the current airport from the stack.\\n- **Reverse** the travel itinerary to get the correct order.\\n- **Return** the travel itinerary as the final result.\\n\\n### Complexity\\n- **Time complexity:** $$O(N^2log(N))$$\\nSince we loop over lists of destinations in the flight graph and sorts them. Sorting each list has a time complexity of `O(E * log(E))`, where E is the total number of edges (tickets). Since `E` can be at most `N`, this step has a time complexity of `O(N * log(N))`. and since we loop over `N` city then the total time complexity is `O(N^2log(N))` where `N` is the number of airports.\\n- **Space complexity:** $$O(N+E)$$\\nWe are storing the Flight Graph which is represented using map of lists, which will have at most `N` keys (airports) and a total of `E` values (destinations). Therefore, the space complexity is `O(N + E)`.\\n\\n---\\n\\n# Code\\n## DFS Recursive\\n```C++ []\\nclass Solution {\\nprivate:\\n    // Create an adjacency list to represent the flights\\n    unordered_map<string, vector<string>> flightGraph;\\n    \\n    // Store the final itinerary\\n    vector<string> itinerary;\\n\\npublic:\\n\\n    // Depth-First Search to traverse the flight itinerary\\n    void dfs(string airport) {\\n        vector<string> &destinations = flightGraph[airport];\\n        \\n        // Visit destinations in lexical order\\n        while (!destinations.empty()) {\\n            string nextDestination = destinations.back();\\n            destinations.pop_back();\\n            dfs(nextDestination);\\n        }\\n        \\n        // Add the current airport to the itinerary after visiting all destinations\\n        itinerary.push_back(airport);\\n    }\\n\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // Populate the flight graph using ticket information\\n        for (int i = 0; i < tickets.size(); i++) {\\n            string from = tickets[i][0];\\n            string to = tickets[i][1];\\n\\n            flightGraph[from].push_back(to);\\n        }\\n        \\n        // Sort destinations in reverse order to visit lexical smaller destinations first\\n        for (auto &entry : flightGraph) {\\n            sort(entry.second.rbegin(), entry.second.rend());\\n        }\\n        \\n        // Start the DFS from the JFK airport\\n        dfs(\"JFK\");\\n        \\n        // Reverse the itinerary to get the correct order\\n        reverse(itinerary.begin(), itinerary.end());\\n        \\n        return itinerary;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    private Map<String, List<String>> flightGraph;\\n    private List<String> itinerary;\\n\\n    public Solution() {\\n        flightGraph = new HashMap<>();\\n        itinerary = new ArrayList<>();\\n    }\\n\\n    // Depth-First Search to traverse the flight itinerary\\n    private void dfs(String airport) {\\n        List<String> destinations = flightGraph.get(airport);\\n\\n        // Visit destinations in lexical order\\n        while (destinations != null && !destinations.isEmpty()) {\\n            String nextDestination = destinations.remove(destinations.size() - 1);\\n            dfs(nextDestination);\\n        }\\n\\n        // Add the current airport to the itinerary after visiting all destinations\\n        itinerary.add(airport);\\n    }\\n\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        // Populate the flight graph using ticket information\\n        for (List<String> ticket : tickets) {\\n            String from = ticket.get(0);\\n            String to = ticket.get(1);\\n\\n            flightGraph.computeIfAbsent(from, k -> new ArrayList<>()).add(to);\\n        }\\n\\n        // Sort destinations in reverse order to visit lexical smaller destinations first\\n        for (List<String> destinations : flightGraph.values()) {\\n            destinations.sort(Collections.reverseOrder());\\n        }\\n\\n        // Start the DFS from the JFK airport\\n        dfs(\"JFK\");\\n\\n        // Reverse the itinerary to get the correct order\\n        Collections.reverse(itinerary);\\n\\n        return itinerary;\\n    }\\n}\\n```\\n```Python []\\n\\nclass Solution:\\n    def __init__(self):\\n        self.flight_graph = defaultdict(list)\\n        self.itinerary = []\\n\\n    # Depth-First Search to traverse the flight itinerary\\n    def dfs(self, airport:str) -> None:\\n        destinations = self.flight_graph[airport]\\n\\n        # Visit destinations in lexical order\\n        while destinations:\\n            next_destination = destinations.pop()\\n            self.dfs(next_destination)\\n\\n        # Add the current airport to the itinerary after visiting all destinations\\n        self.itinerary.append(airport)\\n\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        # Populate the flight graph using ticket information\\n        for ticket in tickets:\\n            from_airport, to_airport = ticket\\n\\n            self.flight_graph[from_airport].append(to_airport)\\n\\n        # Sort destinations in reverse order to visit lexical smaller destinations first\\n        for destinations in self.flight_graph.values():\\n            destinations.sort(reverse=True)\\n\\n        # Start the DFS from the JFK airport\\n        self.dfs(\"JFK\")\\n\\n        # Reverse the itinerary to get the correct order\\n        self.itinerary.reverse()\\n\\n        return self.itinerary\\n```\\n\\n## DFS Iterative\\n```C++ []\\nclass Solution {\\nprivate:\\n    unordered_map<string, vector<string>> flightGraph; // Represents flights from one airport to another\\n    vector<string> travelItinerary; // Stores the final travel itinerary\\n\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // Populate the flight graph using ticket information\\n        for (int i = 0; i < tickets.size(); i++) {\\n            string fromAirport = tickets[i][0];\\n            string toAirport = tickets[i][1];\\n\\n            flightGraph[fromAirport].push_back(toAirport);\\n        }\\n        \\n        // Sort destinations in reverse order to visit lexical smaller destinations first\\n        for (auto &entry : flightGraph) {\\n            sort(entry.second.rbegin(), entry.second.rend());\\n        }\\n\\n        stack<string> dfsStack;\\n        dfsStack.push(\"JFK\");\\n\\n        while (!dfsStack.empty()) {\\n            // Get the current airport from the top of the stack\\n            string currentAirport = dfsStack.top();\\n\\n            vector<string> &destinations = flightGraph[currentAirport];\\n\\n            if (!destinations.empty()) {\\n                // Choose the next destination (the one in lexicographically larger order)\\n                string nextDestination = destinations.back();\\n                destinations.pop_back();\\n\\n                dfsStack.push(nextDestination);\\n            } else {\\n                // If there are no more destinations from the current airport, add it to the itinerary\\n                travelItinerary.push_back(currentAirport);\\n        \\n                dfsStack.pop();\\n            }\\n        }\\n        \\n        // Reverse the itinerary to get the correct order\\n        reverse(travelItinerary.begin(), travelItinerary.end());\\n        return travelItinerary;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    private Map<String, List<String>> flightGraph; // Represents flights from one airport to another\\n    private List<String> travelItinerary; // Stores the final travel itinerary\\n\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        // Initialize the flight graph using ticket information\\n        flightGraph = new HashMap<>();\\n        travelItinerary = new ArrayList<>() ;\\n        for (List<String> ticket : tickets) {\\n            String fromAirport = ticket.get(0);\\n            String toAirport = ticket.get(1);\\n            flightGraph.computeIfAbsent(fromAirport, k -> new ArrayList<>()).add(toAirport);\\n        }\\n\\n        // Sort destinations in reverse order to visit lexical smaller destinations first\\n        for (List<String> destinations : flightGraph.values()) {\\n            destinations.sort(Collections.reverseOrder());\\n        }\\n\\n        Stack<String> dfsStack = new Stack<>();\\n        dfsStack.push(\"JFK\");\\n\\n        while (!dfsStack.isEmpty()) {\\n            // Get the current airport from the top of the stack\\n            String currentAirport = dfsStack.peek();\\n            List<String> destinations = flightGraph.get(currentAirport);\\n\\n            if (destinations != null && !destinations.isEmpty()) {\\n                // Choose the next destination (the one in lexicographically larger order)\\n                String nextDestination = destinations.remove(destinations.size() - 1);\\n                dfsStack.push(nextDestination);\\n            } else {\\n                // If there are no more destinations from the current airport, add it to the itinerary\\n                travelItinerary.add(currentAirport);\\n                dfsStack.pop();\\n            }\\n        }\\n\\n        // Reverse the itinerary to get the correct order\\n        Collections.reverse(travelItinerary);\\n        return travelItinerary;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def findItinerary(self, tickets) -> list[str]:\\n        # Initialize the flight graph using ticket information\\n        flightGraph = defaultdict(list)\\n        travelItinerary = []\\n\\n        for ticket in tickets:\\n            fromAirport, toAirport = ticket[0], ticket[1]\\n            flightGraph[fromAirport].append(toAirport)\\n\\n        # Sort destinations in reverse order to visit lexical smaller destinations first\\n        for destinations in flightGraph.values():\\n            destinations.sort(reverse=True)\\n\\n        dfsStack = [\"JFK\"]\\n\\n        while dfsStack:\\n            # Get the current airport from the top of the stack\\n            currentAirport = dfsStack[-1]\\n            destinations = flightGraph.get(currentAirport, [])\\n\\n            if destinations:\\n                # Choose the next destination (the one in lexicographically larger order)\\n                nextDestination = destinations.pop()\\n                dfsStack.append(nextDestination)\\n            else:\\n                # If there are no more destinations from the current airport, add it to the itinerary\\n                travelItinerary.append(currentAirport)\\n                dfsStack.pop()\\n\\n        # Reverse the itinerary to get the correct order\\n        travelItinerary.reverse()\\n        return travelItinerary\\n```\\n\\n\\n---\\n\\n\\n\\n# Further Improvements?\\n[@v4g](/v4g) had a great improvement that gave better time.\\nInstead of sorting we can simply use **multiset** with reverse order and take the last element every time.\\nIn `C++`: Since we are pointing to `multiset.end()` then it will be in `O(1)` and erasing the element given its iterator it also will be `O(1)`.\\n\\n- **Time complexity:** $$O(Elog(N))$$\\nSince we loop over list of tickets with size `E` and each node can have at most `N` airports that you can travel to them. \\n- **Space complexity:** $$O(N+E)$$\\nIt still the same.\\n\\nHere is the code for C++ and the solution can be generalized to other languages as well.\\n\\n## DFS Recursive \\n```\\nclass Solution {\\nprivate:\\n    unordered_map<string, multiset<string, greater<string>>> flightGraph;\\n    vector<string> itinerary;\\n\\npublic:\\n    void dfs(string airport) {\\n        auto &destinations = flightGraph[airport];\\n        \\n        while (!destinations.empty()) {\\n            auto nextDestination = *(--destinations.end());\\n            destinations.erase(--destinations.end());\\n            dfs(nextDestination);\\n        }\\n        itinerary.push_back(airport);\\n    }\\n\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        for (int i = 0; i < tickets.size(); i++) {\\n            string from = tickets[i][0];\\n            string to = tickets[i][1];\\n\\n            flightGraph[from].insert(to);\\n        }\\n        dfs(\"JFK\");\\n        \\n        reverse(itinerary.begin(), itinerary.end());\\n        return itinerary;\\n    }\\n};\\n```\\n\\n## DFS Iterative \\n```\\nclass Solution {\\nprivate:\\n    unordered_map<string, multiset<string, greater<string>>> flightGraph;\\n    vector<string> travelItinerary;\\n\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        for (int i = 0; i < tickets.size(); i++) {\\n            string fromAirport = tickets[i][0];\\n            string toAirport = tickets[i][1];\\n\\n            flightGraph[fromAirport].insert(toAirport);\\n        }\\n        stack<string> dfsStack;\\n        dfsStack.push(\"JFK\");\\n\\n        while (!dfsStack.empty()) {\\n            string currentAirport = dfsStack.top();\\n\\n            auto &destinations = flightGraph[currentAirport];\\n\\n            if (!destinations.empty()) {\\n                auto nextDestination = *(--destinations.end());\\n                destinations.erase(--destinations.end());\\n                \\n                dfsStack.push(nextDestination);\\n            } else {\\n                travelItinerary.push_back(currentAirport);\\n        \\n                dfsStack.pop();\\n            }\\n        }\\n        \\n        reverse(travelItinerary.begin(), travelItinerary.end());\\n        return travelItinerary;\\n    }\\n};\\n```\\n\\n\\n![leet_sol.jpg](https://assets.leetcode.com/users/images/a0442556-19d5-4cdc-8682-0255e2247e1c_1694658839.7230825.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Stack",
                    "Depth-First Search",
                    "Graph",
                    "Recursion",
                    "Eulerian Circuit"
                ],
                "code": "```C++ []\\nclass Solution {\\nprivate:\\n    // Create an adjacency list to represent the flights\\n    unordered_map<string, vector<string>> flightGraph;\\n    \\n    // Store the final itinerary\\n    vector<string> itinerary;\\n\\npublic:\\n\\n    // Depth-First Search to traverse the flight itinerary\\n    void dfs(string airport) {\\n        vector<string> &destinations = flightGraph[airport];\\n        \\n        // Visit destinations in lexical order\\n        while (!destinations.empty()) {\\n            string nextDestination = destinations.back();\\n            destinations.pop_back();\\n            dfs(nextDestination);\\n        }\\n        \\n        // Add the current airport to the itinerary after visiting all destinations\\n        itinerary.push_back(airport);\\n    }\\n\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // Populate the flight graph using ticket information\\n        for (int i = 0; i < tickets.size(); i++) {\\n            string from = tickets[i][0];\\n            string to = tickets[i][1];\\n\\n            flightGraph[from].push_back(to);\\n        }\\n        \\n        // Sort destinations in reverse order to visit lexical smaller destinations first\\n        for (auto &entry : flightGraph) {\\n            sort(entry.second.rbegin(), entry.second.rend());\\n        }\\n        \\n        // Start the DFS from the JFK airport\\n        dfs(\"JFK\");\\n        \\n        // Reverse the itinerary to get the correct order\\n        reverse(itinerary.begin(), itinerary.end());\\n        \\n        return itinerary;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    private Map<String, List<String>> flightGraph;\\n    private List<String> itinerary;\\n\\n    public Solution() {\\n        flightGraph = new HashMap<>();\\n        itinerary = new ArrayList<>();\\n    }\\n\\n    // Depth-First Search to traverse the flight itinerary\\n    private void dfs(String airport) {\\n        List<String> destinations = flightGraph.get(airport);\\n\\n        // Visit destinations in lexical order\\n        while (destinations != null && !destinations.isEmpty()) {\\n            String nextDestination = destinations.remove(destinations.size() - 1);\\n            dfs(nextDestination);\\n        }\\n\\n        // Add the current airport to the itinerary after visiting all destinations\\n        itinerary.add(airport);\\n    }\\n\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        // Populate the flight graph using ticket information\\n        for (List<String> ticket : tickets) {\\n            String from = ticket.get(0);\\n            String to = ticket.get(1);\\n\\n            flightGraph.computeIfAbsent(from, k -> new ArrayList<>()).add(to);\\n        }\\n\\n        // Sort destinations in reverse order to visit lexical smaller destinations first\\n        for (List<String> destinations : flightGraph.values()) {\\n            destinations.sort(Collections.reverseOrder());\\n        }\\n\\n        // Start the DFS from the JFK airport\\n        dfs(\"JFK\");\\n\\n        // Reverse the itinerary to get the correct order\\n        Collections.reverse(itinerary);\\n\\n        return itinerary;\\n    }\\n}\\n```\n```Python []\\n\\nclass Solution:\\n    def __init__(self):\\n        self.flight_graph = defaultdict(list)\\n        self.itinerary = []\\n\\n    # Depth-First Search to traverse the flight itinerary\\n    def dfs(self, airport:str) -> None:\\n        destinations = self.flight_graph[airport]\\n\\n        # Visit destinations in lexical order\\n        while destinations:\\n            next_destination = destinations.pop()\\n            self.dfs(next_destination)\\n\\n        # Add the current airport to the itinerary after visiting all destinations\\n        self.itinerary.append(airport)\\n\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        # Populate the flight graph using ticket information\\n        for ticket in tickets:\\n            from_airport, to_airport = ticket\\n\\n            self.flight_graph[from_airport].append(to_airport)\\n\\n        # Sort destinations in reverse order to visit lexical smaller destinations first\\n        for destinations in self.flight_graph.values():\\n            destinations.sort(reverse=True)\\n\\n        # Start the DFS from the JFK airport\\n        self.dfs(\"JFK\")\\n\\n        # Reverse the itinerary to get the correct order\\n        self.itinerary.reverse()\\n\\n        return self.itinerary\\n```\n```C++ []\\nclass Solution {\\nprivate:\\n    unordered_map<string, vector<string>> flightGraph; // Represents flights from one airport to another\\n    vector<string> travelItinerary; // Stores the final travel itinerary\\n\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // Populate the flight graph using ticket information\\n        for (int i = 0; i < tickets.size(); i++) {\\n            string fromAirport = tickets[i][0];\\n            string toAirport = tickets[i][1];\\n\\n            flightGraph[fromAirport].push_back(toAirport);\\n        }\\n        \\n        // Sort destinations in reverse order to visit lexical smaller destinations first\\n        for (auto &entry : flightGraph) {\\n            sort(entry.second.rbegin(), entry.second.rend());\\n        }\\n\\n        stack<string> dfsStack;\\n        dfsStack.push(\"JFK\");\\n\\n        while (!dfsStack.empty()) {\\n            // Get the current airport from the top of the stack\\n            string currentAirport = dfsStack.top();\\n\\n            vector<string> &destinations = flightGraph[currentAirport];\\n\\n            if (!destinations.empty()) {\\n                // Choose the next destination (the one in lexicographically larger order)\\n                string nextDestination = destinations.back();\\n                destinations.pop_back();\\n\\n                dfsStack.push(nextDestination);\\n            } else {\\n                // If there are no more destinations from the current airport, add it to the itinerary\\n                travelItinerary.push_back(currentAirport);\\n        \\n                dfsStack.pop();\\n            }\\n        }\\n        \\n        // Reverse the itinerary to get the correct order\\n        reverse(travelItinerary.begin(), travelItinerary.end());\\n        return travelItinerary;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    private Map<String, List<String>> flightGraph; // Represents flights from one airport to another\\n    private List<String> travelItinerary; // Stores the final travel itinerary\\n\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        // Initialize the flight graph using ticket information\\n        flightGraph = new HashMap<>();\\n        travelItinerary = new ArrayList<>() ;\\n        for (List<String> ticket : tickets) {\\n            String fromAirport = ticket.get(0);\\n            String toAirport = ticket.get(1);\\n            flightGraph.computeIfAbsent(fromAirport, k -> new ArrayList<>()).add(toAirport);\\n        }\\n\\n        // Sort destinations in reverse order to visit lexical smaller destinations first\\n        for (List<String> destinations : flightGraph.values()) {\\n            destinations.sort(Collections.reverseOrder());\\n        }\\n\\n        Stack<String> dfsStack = new Stack<>();\\n        dfsStack.push(\"JFK\");\\n\\n        while (!dfsStack.isEmpty()) {\\n            // Get the current airport from the top of the stack\\n            String currentAirport = dfsStack.peek();\\n            List<String> destinations = flightGraph.get(currentAirport);\\n\\n            if (destinations != null && !destinations.isEmpty()) {\\n                // Choose the next destination (the one in lexicographically larger order)\\n                String nextDestination = destinations.remove(destinations.size() - 1);\\n                dfsStack.push(nextDestination);\\n            } else {\\n                // If there are no more destinations from the current airport, add it to the itinerary\\n                travelItinerary.add(currentAirport);\\n                dfsStack.pop();\\n            }\\n        }\\n\\n        // Reverse the itinerary to get the correct order\\n        Collections.reverse(travelItinerary);\\n        return travelItinerary;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def findItinerary(self, tickets) -> list[str]:\\n        # Initialize the flight graph using ticket information\\n        flightGraph = defaultdict(list)\\n        travelItinerary = []\\n\\n        for ticket in tickets:\\n            fromAirport, toAirport = ticket[0], ticket[1]\\n            flightGraph[fromAirport].append(toAirport)\\n\\n        # Sort destinations in reverse order to visit lexical smaller destinations first\\n        for destinations in flightGraph.values():\\n            destinations.sort(reverse=True)\\n\\n        dfsStack = [\"JFK\"]\\n\\n        while dfsStack:\\n            # Get the current airport from the top of the stack\\n            currentAirport = dfsStack[-1]\\n            destinations = flightGraph.get(currentAirport, [])\\n\\n            if destinations:\\n                # Choose the next destination (the one in lexicographically larger order)\\n                nextDestination = destinations.pop()\\n                dfsStack.append(nextDestination)\\n            else:\\n                # If there are no more destinations from the current airport, add it to the itinerary\\n                travelItinerary.append(currentAirport)\\n                dfsStack.pop()\\n\\n        # Reverse the itinerary to get the correct order\\n        travelItinerary.reverse()\\n        return travelItinerary\\n```\n```\\nclass Solution {\\nprivate:\\n    unordered_map<string, multiset<string, greater<string>>> flightGraph;\\n    vector<string> itinerary;\\n\\npublic:\\n    void dfs(string airport) {\\n        auto &destinations = flightGraph[airport];\\n        \\n        while (!destinations.empty()) {\\n            auto nextDestination = *(--destinations.end());\\n            destinations.erase(--destinations.end());\\n            dfs(nextDestination);\\n        }\\n        itinerary.push_back(airport);\\n    }\\n\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        for (int i = 0; i < tickets.size(); i++) {\\n            string from = tickets[i][0];\\n            string to = tickets[i][1];\\n\\n            flightGraph[from].insert(to);\\n        }\\n        dfs(\"JFK\");\\n        \\n        reverse(itinerary.begin(), itinerary.end());\\n        return itinerary;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    unordered_map<string, multiset<string, greater<string>>> flightGraph;\\n    vector<string> travelItinerary;\\n\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        for (int i = 0; i < tickets.size(); i++) {\\n            string fromAirport = tickets[i][0];\\n            string toAirport = tickets[i][1];\\n\\n            flightGraph[fromAirport].insert(toAirport);\\n        }\\n        stack<string> dfsStack;\\n        dfsStack.push(\"JFK\");\\n\\n        while (!dfsStack.empty()) {\\n            string currentAirport = dfsStack.top();\\n\\n            auto &destinations = flightGraph[currentAirport];\\n\\n            if (!destinations.empty()) {\\n                auto nextDestination = *(--destinations.end());\\n                destinations.erase(--destinations.end());\\n                \\n                dfsStack.push(nextDestination);\\n            } else {\\n                travelItinerary.push_back(currentAirport);\\n        \\n                dfsStack.pop();\\n            }\\n        }\\n        \\n        reverse(travelItinerary.begin(), travelItinerary.end());\\n        return travelItinerary;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78772,
                "title": "python-dfs-backtracking",
                "content": "I use a dictionary to represent the tickets (start -> [list of possible destinations]).   Then, I start the route at JFK and I dfs from there.  Since I do the dfs in sorted order, the first time that I find a possible route, I can return it and know that it is in the smallest lexigraphic order.  Finally, note that the worked variable either contains None (as a result of a failed search) or the correct route.\\n\\n    def findItinerary(self, tickets):\\n        d = defaultdict(list)\\n        for flight in tickets:\\n            d[flight[0]] += flight[1],\\n        self.route = [\"JFK\"]\\n        def dfs(start = 'JFK'):\\n            if len(self.route) == len(tickets) + 1:\\n                return self.route\\n            myDsts = sorted(d[start])\\n            for dst in myDsts:\\n                d[start].remove(dst)\\n                self.route += dst,\\n                worked = dfs(dst)\\n                if worked:\\n                    return worked\\n                self.route.pop()\\n                d[start] += dst,\\n        return dfs()",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "I use a dictionary to represent the tickets (start -> [list of possible destinations]).   Then, I start the route at JFK and I dfs from there.  Since I do the dfs in sorted order, the first time that I find a possible route, I can return it and know that it is in the smallest lexigraphic order.  Finally, note that the worked variable either contains None (as a result of a failed search) or the correct route.\\n\\n    def findItinerary(self, tickets):\\n        d = defaultdict(list)\\n        for flight in tickets:\\n            d[flight[0]] += flight[1],\\n        self.route = [\"JFK\"]\\n        def dfs(start = 'JFK'):\\n            if len(self.route) == len(tickets) + 1:\\n                return self.route\\n            myDsts = sorted(d[start])\\n            for dst in myDsts:\\n                d[start].remove(dst)\\n                self.route += dst,\\n                worked = dfs(dst)\\n                if worked:\\n                    return worked\\n                self.route.pop()\\n                d[start] += dst,\\n        return dfs()",
                "codeTag": "Python3"
            },
            {
                "id": 437594,
                "title": "super-easy-and-clean-javascript-greedy-dfs-with-detailed-explanations",
                "content": "Greedy strategy  + post order traversal\\n1. build a map to store each departure location and its destinations array.\\n2. sort the destinations array.\\n3. now we assume that the departure airport \\'JFK\\' is the root node for this tree, and its destinations are the children. Since the destinations are sorted, the children are arranged alfabetically from left to right. For each destination, if it is also a departure airport, then its children are the related destinations. Hopefully by now you get an idea of the structure of the tree.\\n4. run a post order traversal of the tree , as a result, \\'JFK\\' now is the last airport visited, hence the Greedy part. \\n5. finally we reverse the result as the return value.\\n\\n\\n```\\nvar findItinerary = function(tickets) {\\n    var map = {};\\n    var res = [];\\n    for(var i=0; i<tickets.length; i++) {\\n        var dep = tickets[i][0];\\n        var des = tickets[i][1];\\n        if(map[dep]) {\\n            map[dep].push(des);\\n        } else {\\n            map[dep] = [des];\\n        }\\n    }\\n    for(let loc in map) {\\n        map[loc].sort();\\n    }  \\n    var dfs = function(node) {\\n        var des = map[node];\\n        while(des && des.length>0) {\\n            dfs(des.shift());\\n        }\\n        res.push(node);\\n    }\\n    dfs(\\'JFK\\');\\n    return res.reverse();\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar findItinerary = function(tickets) {\\n    var map = {};\\n    var res = [];\\n    for(var i=0; i<tickets.length; i++) {\\n        var dep = tickets[i][0];\\n        var des = tickets[i][1];\\n        if(map[dep]) {\\n            map[dep].push(des);\\n        } else {\\n            map[dep] = [des];\\n        }\\n    }\\n    for(let loc in map) {\\n        map[loc].sort();\\n    }  \\n    var dfs = function(node) {\\n        var des = map[node];\\n        while(des && des.length>0) {\\n            dfs(des.shift());\\n        }\\n        res.push(node);\\n    }\\n    dfs(\\'JFK\\');\\n    return res.reverse();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 78841,
                "title": "share-solution-java-greedy-stack-15ms-with-explanation",
                "content": "Noticed some folks are using Hierholzer's algorithm to find a Eulerian path.\\n\\nMy solution is similar, considering this passenger has to be physically in one place before move to another airport, we are considering using up all tickets and choose lexicographically smaller solution if in tie as two constraints.\\n\\nThinking as that passenger, the passenger choose his/her flight greedy as the lexicographical order, once he/she figures out go to an airport without departure with more tickets at hand. the passenger will push current ticket in a stack and look at whether it is possible for him/her to travel to other places from the airport on his/her way.\\n\\nPlease let me know if you have any suggestions.\\n\\n        public List<String> findItinerary(String[][] tickets) {\\n            List<String> ans = new ArrayList<String>();\\n            if(tickets == null || tickets.length == 0) return ans;\\n            Map<String, PriorityQueue<String>> ticketsMap = new HashMap<>();\\n            for(int i = 0; i < tickets.length; i++) {\\n                if(!ticketsMap.containsKey(tickets[i][0])) ticketsMap.put(tickets[i][0], new PriorityQueue<String>());\\n                ticketsMap.get(tickets[i][0]).add(tickets[i][1]);\\n            }\\n    \\n            String curr = \"JFK\";\\n            Stack<String> drawBack = new Stack<String>();\\n            for(int i = 0; i < tickets.length; i++) {\\n                while(!ticketsMap.containsKey(curr) || ticketsMap.get(curr).isEmpty()) {\\n                    drawBack.push(curr);\\n                    curr = ans.remove(ans.size()-1);\\n                }\\n                ans.add(curr);\\n                curr = ticketsMap.get(curr).poll();\\n            }\\n            ans.add(curr);\\n            while(!drawBack.isEmpty()) ans.add(drawBack.pop());\\n            return ans;\\n        }",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "Noticed some folks are using Hierholzer's algorithm to find a Eulerian path.\\n\\nMy solution is similar, considering this passenger has to be physically in one place before move to another airport, we are considering using up all tickets and choose lexicographically smaller solution if in tie as two constraints.\\n\\nThinking as that passenger, the passenger choose his/her flight greedy as the lexicographical order, once he/she figures out go to an airport without departure with more tickets at hand. the passenger will push current ticket in a stack and look at whether it is possible for him/her to travel to other places from the airport on his/her way.\\n\\nPlease let me know if you have any suggestions.\\n\\n        public List<String> findItinerary(String[][] tickets) {\\n            List<String> ans = new ArrayList<String>();\\n            if(tickets == null || tickets.length == 0) return ans;\\n            Map<String, PriorityQueue<String>> ticketsMap = new HashMap<>();\\n            for(int i = 0; i < tickets.length; i++) {\\n                if(!ticketsMap.containsKey(tickets[i][0])) ticketsMap.put(tickets[i][0], new PriorityQueue<String>());\\n                ticketsMap.get(tickets[i][0]).add(tickets[i][1]);\\n            }\\n    \\n            String curr = \"JFK\";\\n            Stack<String> drawBack = new Stack<String>();\\n            for(int i = 0; i < tickets.length; i++) {\\n                while(!ticketsMap.containsKey(curr) || ticketsMap.get(curr).isEmpty()) {\\n                    drawBack.push(curr);\\n                    curr = ans.remove(ans.size()-1);\\n                }\\n                ans.add(curr);\\n                curr = ticketsMap.get(curr).poll();\\n            }\\n            ans.add(curr);\\n            while(!drawBack.isEmpty()) ans.add(drawBack.pop());\\n            return ans;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 78842,
                "title": "c-non-recursive-o-n-time-o-n-space-solution-with-detail-explanations",
                "content": "The idea of this algorithm, which was originally found in fangyang's thread [https://leetcode.com/discuss/84706/share-solution-java-greedy-stack-15ms-with-explanation][1], consists of two steps:\\n\\n- **Step 1**: Store the flight in a hash map. (say `m` in the code below. This map enables us to find all possible destinations from a place in amortized constant time.)\\n\\n- **Step 2**: Use a greedy and trace-back approach to find the optimal itinerary. Specifically, we use greedy method to find a lexicographically-smallest path until we can not move any further (the path can be stored in a vector, say `march` in the code below). Each time we reach such an exhaustive state, we find a place which is exactly the end of the itinerary. (The reason is, the path `march` is an optimal itinerary expect that some loops are omitted. The optimal itinerary can be obtained by inserting some loops into this path, which does not change the last vertex of the path.) Therefore, we can record the last vertex in another place (say `results` in the code below). So and so forth, the vector `results` stores the optimal itinerary reversely, since we always place the optimal last vertex at the end of this vector. Reversing the vertex `results` leads to the correct answer.\\n\\n\\n-----\\n\\n**Example**:\\nThis example is originally shown in  StefanPochmann's thread [https://leetcode.com/discuss/84659/short-ruby-python-java-c][2]\\n\\n\\n![][3]  \\n[ Source of this picture: http://www.stefan-pochmann.info/misc/reconstruct-itinerary.png[][4] ]\\n\\n\\nIn Step 2, we first march greedily, and get the vector `march` as:\\n\\n    march: JFK -> A -> C -> D -> A      (the red path)\\n\\nHowever, the optimal itinerary, is \\n\\n    JFK -> A -> C -> D( -> B -> C -> JFK -> D) -> A\\n\\nwhere the loop (D -> B -> C -> JFK -> D) shall be inserted in the vector `march`. However, we have already found the last vertex A, Therefore, we can record this result. So `march` and `results` become\\n\\n    march: JFK -> A -> C -> D\\n    results: A\\n\\nThen we march greedily again, results in\\n\\n    march: JFK -> A -> C -> D -> B -> C -> JFK -> D\\n    results: A\\n\\nNow all edges are used. Before the final reversion, `march` and `results` become\\n\\n    march: (empty)\\n    results: A <- D <- JFK <- C <- B <- D <- C <- A <- JFK\\n\\n\\n----\\n\\n**Overall Complexities**:\\n\\nLet N be the number of tickets. Let D be the largest outgoing degree of a vertex.\\n\\n- **Time**: *O*(N log D)  \\nStep 1: O(N log D)  \\nStep 2: O(N). Each vertex needs to be put into `march` once and be moved from `march` to `results`. At the very end, `results` is reversed.\\n- **Space**: *O*(N)            \\nThe map `m` needs to store all vertices.\\n\\n\\n-----\\n\\n**Code** (40 ms):\\n\\n    class Solution {\\n    public:\\n        vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n            \\n            // Step 1: Store directed edges in a hash map\\n            unordered_map<string, multiset<string>> m;\\n            for (const pair<string, string> & ticket : tickets) {\\n                m[ticket.first].insert(ticket.second);\\n            }\\n            \\n            // Step 2: March greedily and traceback\\n            vector<string> march = { \"JFK\" }; // the storage for greedy searching\\n            vector<string> results; // store the final results reversely\\n            while (march.empty() == false) {\\n                string & from = march.back();\\n                if ((m.find(from) != m.end()) && (m[from].empty() == false)) { // march further\\n                    multiset<string> & to = m[from];\\n                    march.push_back(*(to.begin()));\\n                    to.erase(to.begin());\\n                } else { // can not march further, trace back\\n                    results.push_back(march.back()); // archive the last place\\n                    march.pop_back();\\n                }\\n            }\\n            reverse(results.begin(), results.end()); // reverse the entries back\\n            return results;\\n        }\\n    };\\n\\n\\n  [1]: https://leetcode.com/discuss/84706/share-solution-java-greedy-stack-15ms-with-explanation\\n  [2]: https://leetcode.com/discuss/84659/short-ruby-python-java-c\\n  [3]: http://www.stefan-pochmann.info/misc/reconstruct-itinerary.png\\n  [4]: https://leetcode.com/discuss/84659/short-ruby-python-java-c",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n            \\n            // Step 1: Store directed edges in a hash map\\n            unordered_map<string, multiset<string>> m;\\n            for (const pair<string, string> & ticket : tickets) {\\n                m[ticket.first].insert(ticket.second);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1490090,
                "title": "java-easy-approach-with-explanation-dfs-euler-topological-sort",
                "content": "```\\nclass Solution\\n{\\n    private HashMap<String, PriorityQueue<String>> map= new HashMap<>();//Starting airport -> Destination airport(lexically asc sorted)\\n    private LinkedList<String> res= new LinkedList<>();//result \\n    \\n    public List<String> findItinerary(List<List<String>> tickets)\\n    {\\n        /*Note::\\n         *->The main idea is to traverse every edge atmost once\\n         *->And we are starting from JFK airport\\n         *->We use Priority Queue to store the adjacent airport in Lexically sorted manner\\n         *->We use a topological sort like approach for displaying the result, i.e, we start from an no in-dependency edge to the most in-dependenncy edge\\n         *->We are considering the euler path to traverse the graph \\n         *->Priority Queue is also helping us keep track of the visited and non-visited edge \\n         *->Hash Map is Used like a adjacency list here \\n         */\\n        \\n        for (List<String> ticket: tickets)\\n        {\\n            String u= ticket.get(0);//starting airport\\n            String v= ticket.get(1);//destination airport\\n            \\n            PriorityQueue<String> temp= map.getOrDefault(u, new PriorityQueue<>());\\n            temp.offer(v);//adding the desitination airport \\n            map.put(u, temp);//adding to the map \\n        }\\n        \\n        dfs(\"JFK\");//Journey Starting Airport\\n        \\n        return res;\\n    }\\n    private void dfs(String src)\\n    {\\n        PriorityQueue<String> pq= map.get(src);//Adjacent Airports\\n        \\n        while (pq != null && pq.size() > 0){//processsing all the destination Airport of the current Airport(src)\\n            String temp= pq.poll();//removing the edge//visited \\n            dfs(temp);//recursing down \\n        }\\n        res.addFirst(src);//adding the Airport while backtracking//least in-dependency as far as possible \\n        return;\\n    }\\n}//Please do Upvote, it helps a lot \\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution\\n{\\n    private HashMap<String, PriorityQueue<String>> map= new HashMap<>();//Starting airport -> Destination airport(lexically asc sorted)\\n    private LinkedList<String> res= new LinkedList<>();//result \\n    \\n    public List<String> findItinerary(List<List<String>> tickets)\\n    {\\n        /*Note::\\n         *->The main idea is to traverse every edge atmost once\\n         *->And we are starting from JFK airport\\n         *->We use Priority Queue to store the adjacent airport in Lexically sorted manner\\n         *->We use a topological sort like approach for displaying the result, i.e, we start from an no in-dependency edge to the most in-dependenncy edge\\n         *->We are considering the euler path to traverse the graph \\n         *->Priority Queue is also helping us keep track of the visited and non-visited edge \\n         *->Hash Map is Used like a adjacency list here \\n         */\\n        \\n        for (List<String> ticket: tickets)\\n        {\\n            String u= ticket.get(0);//starting airport\\n            String v= ticket.get(1);//destination airport\\n            \\n            PriorityQueue<String> temp= map.getOrDefault(u, new PriorityQueue<>());\\n            temp.offer(v);//adding the desitination airport \\n            map.put(u, temp);//adding to the map \\n        }\\n        \\n        dfs(\"JFK\");//Journey Starting Airport\\n        \\n        return res;\\n    }\\n    private void dfs(String src)\\n    {\\n        PriorityQueue<String> pq= map.get(src);//Adjacent Airports\\n        \\n        while (pq != null && pq.size() > 0){//processsing all the destination Airport of the current Airport(src)\\n            String temp= pq.poll();//removing the edge//visited \\n            dfs(temp);//recursing down \\n        }\\n        res.addFirst(src);//adding the Airport while backtracking//least in-dependency as far as possible \\n        return;\\n    }\\n}//Please do Upvote, it helps a lot \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042491,
                "title": "video-visualized-solution-python-javascript-java-c",
                "content": "# Intuition\\nThis code uses airline ticket information to construct a valid itinerary starting from the departure airport \"JFK\" and organizing destinations into a dictionary-style graph. It manages the routes from departure to arrival using a stack, adding them to a new itinerary when there are no more destinations. The final itinerary is reversed to obtain the correct order.\\n\\n---\\n\\n# Solution Video\\n\\nhttps://youtu.be/7kZKIod8L94\\n\\n### \\u2B50\\uFE0F\\u2B50\\uFE0F Don\\'t forget to subscribe to my channel! \\u2B50\\uFE0F\\u2B50\\uFE0F\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nSubscribers: 2310\\nThank you for your support!\\n\\n---\\n\\n# Approach\\n1. Creating the Graph and Organizing Ticket Information:\\n   - Create a dictionary-style graph to store airports and their destinations.\\n   - Sort the ticket information in reverse order based on arrival airports.\\n\\n2. Initializing the Stack and New Itinerary:\\n   - Create a stack initialized with `JFK` as the departure airport.\\n   - Initialize a list to store the new itinerary.\\n\\n3. Constructing the Itinerary Using the Stack:\\n   - Repeat the following process as long as the stack is not empty:\\n   - Add potential destinations departing from the current airport to the stack.\\n   - When there are no more destinations, add the current airport to the new itinerary.\\n\\n4. Reversing the Itinerary:\\n   - Reverse the new itinerary to obtain the correct order of the itinerary.\\n\\n5. Returning the Correct Order Itinerary:\\n   - Return the reversed itinerary as the final result.\\n\\n# How it works\\n\\n```\\nInput: tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],\\n[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\\n```\\n\\n## **Step 1:** Graph Initialization\\n\\nIn this step, the graph is initialized. The graph is represented as a dictionary with departure points (airports) as keys and lists of arrival points (other airports) as values. In this initialization, no information has been added yet.\\n\\nIn this step, the provided airline ticket information is sorted in reverse order.\\n\\nAirline tickets sorted in reverse order for lexical order: `[[\\'SFO\\', \\'ATL\\'], [\\'JFK\\', \\'SFO\\'], [\\'JFK\\', \\'ATL\\'], [\\'ATL\\', \\'SFO\\'], [\\'ATL\\', \\'JFK\\']]`\\n\\nThe reason for performing reverse sorting (reverse order) in this code is to use a stack and find the \"lexicographically smallest route\" according to the constraints of the problem. There are two key points in the constraints:\\n\\n1. The departure point must be `JFK.`\\n2. The lexicographically smallest route needs to be found.\\n\\nBy performing reverse sorting, when the departure point is `JFK` the route will start with the ticket that has the smallest destination in lexicographical order. In other words, the route that starts from `JFK` is chosen as the smallest route initially.\\n\\nThe other important reason is that we can use `pop()` and easily get the smallest destination in lexicographical order with `O(1)`. Therefore, reverse sorting is necessary to meet the constraints of the problem.\\n\\n```\\ngraph = {\\n    \"SFO\": [\"ATL\"],\\n    \"JFK\": [\"SFO\", \"ATL\"],\\n    \"ATL\": [\"SFO\", \"JFK\"]\\n}\\n```\\n\\nThe graph has been correctly updated as a result of this step.\\n\\n## **Step 2:** Stack and Itinerary Initialization\\n\\nIn this step, the stack `st` and an empty itinerary list `new_itinerary` are initialized.\\n\\n```\\nst: [\"JFK\"]\\nnew_itinerary: []\\n```\\n\\n## **Step 3:** Building the Itinerary Using the Stack\\n\\nIn this step, the itinerary is constructed using a stack. The following operations are repeated in each step of stack operation.\\n\\n1. Check the current airport at the top of the stack. The initial airport is `JFK`.\\n\\n    - `st`: `[\"JFK\"]`\\n    - `new_itinerary`: `[]`\\n\\n2. Find the places reachable from the current airport `JFK`. From the current airport `JFK`, you can go to `SFO` and `ATL`. Add `ATL` to the stack.\\n\\n    - `st`: `[\"JFK\", \"ATL\"]`\\n    - `new_itinerary`: `[]`\\n\\nCurrent graph:\\n```\\ngraph = {\\n    \"SFO\": [\"ATL\"],\\n    \"JFK\": [\"SFO\"],\\n    \"ATL\": [\"SFO\", \"JFK\"]\\n}\\n```\\n\\n4. Add the places reachable from `ATL` to the stack. From the current airport `ATL`, you can go to `SFO` and `JFK`. Add `JFK` to the stack.\\n\\n    - `st`: `[\"JFK\", \"ATL\", \"JFK\"]`\\n    - `new_itinerary`: `[]`\\n\\nCurrent graph:\\n```\\ngraph = {\\n    \"SFO\": [\"ATL\"],\\n    \"JFK\": [\"SFO\"],\\n    \"ATL\": [\"SFO\"]\\n}\\n```\\n\\n5. Add the places reachable from `JFK` to the stack. From the current airport `JFK`, you can go to `SFO`. Add `JFK` to the stack.\\n\\n    - `st`: `[\"JFK\", \"ATL\", \"JFK\", \"SFO\"]`\\n    - `new_itinerary`: `[\"\"]`\\n\\nCurrent graph:\\n```\\ngraph = {\\n    \"SFO\": [\"ATL\"],\\n    \"JFK\": [\"\"],\\n    \"ATL\": [\"SFO\"]\\n}\\n```\\n\\n6. Add the places reachable from `SFO` to the stack. From the current airport `SFO`, you can go to `ATL`. Add ATL` to the stack.\\n\\n    - `st`: `[\"JFK\", \"ATL\", \"JFK\", \"SFO\", \"ATL\"]`\\n    - `new_itinerary`: `[\"\"]`\\n\\nCurrent graph:\\n```\\ngraph = {\\n    \"SFO\": [\"\"],\\n    \"JFK\": [\"\"],\\n    \"ATL\": [\"SFO\"]\\n}\\n```\\n\\n7. Add the places reachable from `ATL` to the stack. From the current airport `ATL`, you can go to `SFO`. Add `SFO` to the stack.\\n\\n    - `st`: `[\"JFK\", \"ATL\", \"JFK\", \"SFO\", \"ATL\", \"SFO\"]`\\n    - `new_itinerary`: `[\"\"]`\\n\\nCurrent graph:\\n```\\ngraph = {\\n    \"SFO\": [\"\"],\\n    \"JFK\": [\"\"],\\n    \"ATL\": [\"\"]\\n}\\n```\\n\\nFinally, pop data from `st` and assign it to `new_itinerary`. This operation is necessary to avoid an infinite loop in the outermost `while` loop.\\n\\n```\\n`st`: `[\"JFK\", \"ATL\", \"JFK\", \"SFO\", \"ATL\", \"SFO\"]`\\n\\nnew_itinerary [\\'SFO\\']\\nnew_itinerary [\\'SFO\\', \\'ATL\\']\\nnew_itinerary [\\'SFO\\', \\'ATL\\', \\'SFO\\']\\nnew_itinerary [\\'SFO\\', \\'ATL\\', \\'SFO\\', \\'JFK\\']\\nnew_itinerary [\\'SFO\\', \\'ATL\\', \\'SFO\\', \\'JFK\\', \\'ATL\\']\\nnew_itinerary [\\'SFO\\', \\'ATL\\', \\'SFO\\', \\'JFK\\', \\'ATL\\', \\'JFK\\']\\n```\\n\\nReverse `new_itinerary` and return it.\\n\\n```\\nOutput: [\"JFK\", \"ATL\", \"JFK\", \"SFO\", \"ATL\", \"SFO\"]\\n```\\n\\n# Complexity\\n- Time complexity: O(N log N)\\n    - Let N be the number of tickets. Sorting the tickets in reverse order takes O(N log N) time.\\n    - Processing each ticket using the stack takes O(N) time.\\n\\n\\n\\n- Space complexity: O(N)\\n    - To represent the graph, O(N) space is required.\\n    - O(N) space is needed for the stack and the new itinerary.\\n\\n    \\n```python []\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        # Create a graph represented as a dictionary where each airport is a key, and its destinations are values.\\n        graph = defaultdict(list)\\n\\n        for departure, arrival in sorted(tickets, reverse=True):\\n            graph[departure].append(arrival)\\n\\n        # Initialize the stack with the starting airport \"JFK\" and an empty itinerary.\\n        st = [\"JFK\"]\\n        new_itinerary = []\\n\\n        while st:\\n            # If there are destinations from the current airport, add the next destination to the stack.\\n            if graph[st[-1]]:\\n                st.append(graph[st[-1]].pop())\\n            else:\\n                # When there are no more destinations, add the current airport to the new itinerary.\\n                new_itinerary.append(st.pop())\\n\\n        # Reverse the new itinerary to get the correct order.\\n        return new_itinerary[::-1]\\n```\\n```javascript []\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n    const graph = new Map();\\n\\n    for (const [departure, arrival] of tickets.sort().reverse()) {\\n        if (!graph.has(departure)) {\\n            graph.set(departure, []);\\n        }\\n        graph.get(departure).push(arrival);\\n    }\\n\\n    const stack = [\"JFK\"];\\n    const newItinerary = [];\\n\\n    while (stack.length > 0) {\\n        const currentAirport = stack[stack.length - 1];\\n\\n        if (graph.has(currentAirport) && graph.get(currentAirport).length > 0) {\\n            stack.push(graph.get(currentAirport).pop());\\n        } else {\\n            newItinerary.push(stack.pop());\\n        }\\n    }\\n\\n    return newItinerary.reverse();    \\n};\\n```\\n```java []\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, List<String>> graph = new HashMap<>();\\n\\n        for (List<String> ticket : tickets) {\\n            String departure = ticket.get(0);\\n            String arrival = ticket.get(1);\\n\\n            graph.computeIfAbsent(departure, k -> new ArrayList<>()).add(arrival);\\n        }\\n\\n        for (List<String> destinations : graph.values()) {\\n            destinations.sort(Collections.reverseOrder());\\n        }\\n\\n        List<String> newItinerary = new ArrayList<>();\\n        Deque<String> stack = new ArrayDeque<>();\\n        stack.push(\"JFK\");\\n\\n        while (!stack.isEmpty()) {\\n            String currentAirport = stack.peek();\\n\\n            if (graph.containsKey(currentAirport) && !graph.get(currentAirport).isEmpty()) {\\n                stack.push(graph.get(currentAirport).remove(graph.get(currentAirport).size() - 1));\\n            } else {\\n                newItinerary.add(stack.pop());\\n            }\\n        }\\n\\n        Collections.reverse(newItinerary);\\n        return newItinerary;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, priority_queue<string, vector<string>, greater<string>>> graph;\\n\\n        for (const auto& ticket : tickets) {\\n            graph[ticket[0]].push(ticket[1]);\\n        }\\n\\n        vector<string> newItinerary;\\n        stack<string> st;\\n        st.push(\"JFK\");\\n\\n        while (!st.empty()) {\\n            string currentAirport = st.top();\\n\\n            if (graph.find(currentAirport) != graph.end() && !graph[currentAirport].empty()) {\\n                st.push(graph[currentAirport].top());\\n                graph[currentAirport].pop();\\n            } else {\\n                newItinerary.push_back(st.top());\\n                st.pop();\\n            }\\n        }\\n\\n        reverse(newItinerary.begin(), newItinerary.end());\\n        return newItinerary;        \\n    }\\n};\\n```\\n\\n\\n---\\n\\n\\n\\n# Can I make a small request?\\nThank you for watching my video and reading my article!\\n\\n\\u2B50\\uFE0F If you like my video and my article, please subscribe to my youtube channel and upvote the article. My initial goal for youtube is to reach 10,000 subscribers. It\\'s far from done.\\n\\nHave a nice day!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nInput: tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],\\n[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\\n```\n```\\ngraph = {\\n    \"SFO\": [\"ATL\"],\\n    \"JFK\": [\"SFO\", \"ATL\"],\\n    \"ATL\": [\"SFO\", \"JFK\"]\\n}\\n```\n```\\nst: [\"JFK\"]\\nnew_itinerary: []\\n```\n```\\ngraph = {\\n    \"SFO\": [\"ATL\"],\\n    \"JFK\": [\"SFO\"],\\n    \"ATL\": [\"SFO\", \"JFK\"]\\n}\\n```\n```\\ngraph = {\\n    \"SFO\": [\"ATL\"],\\n    \"JFK\": [\"SFO\"],\\n    \"ATL\": [\"SFO\"]\\n}\\n```\n```\\ngraph = {\\n    \"SFO\": [\"ATL\"],\\n    \"JFK\": [\"\"],\\n    \"ATL\": [\"SFO\"]\\n}\\n```\n```\\ngraph = {\\n    \"SFO\": [\"\"],\\n    \"JFK\": [\"\"],\\n    \"ATL\": [\"SFO\"]\\n}\\n```\n```\\ngraph = {\\n    \"SFO\": [\"\"],\\n    \"JFK\": [\"\"],\\n    \"ATL\": [\"\"]\\n}\\n```\n```\\n`st`: `[\"JFK\", \"ATL\", \"JFK\", \"SFO\", \"ATL\", \"SFO\"]`\\n\\nnew_itinerary [\\'SFO\\']\\nnew_itinerary [\\'SFO\\', \\'ATL\\']\\nnew_itinerary [\\'SFO\\', \\'ATL\\', \\'SFO\\']\\nnew_itinerary [\\'SFO\\', \\'ATL\\', \\'SFO\\', \\'JFK\\']\\nnew_itinerary [\\'SFO\\', \\'ATL\\', \\'SFO\\', \\'JFK\\', \\'ATL\\']\\nnew_itinerary [\\'SFO\\', \\'ATL\\', \\'SFO\\', \\'JFK\\', \\'ATL\\', \\'JFK\\']\\n```\n```\\nOutput: [\"JFK\", \"ATL\", \"JFK\", \"SFO\", \"ATL\", \"SFO\"]\\n```\n```python []\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        # Create a graph represented as a dictionary where each airport is a key, and its destinations are values.\\n        graph = defaultdict(list)\\n\\n        for departure, arrival in sorted(tickets, reverse=True):\\n            graph[departure].append(arrival)\\n\\n        # Initialize the stack with the starting airport \"JFK\" and an empty itinerary.\\n        st = [\"JFK\"]\\n        new_itinerary = []\\n\\n        while st:\\n            # If there are destinations from the current airport, add the next destination to the stack.\\n            if graph[st[-1]]:\\n                st.append(graph[st[-1]].pop())\\n            else:\\n                # When there are no more destinations, add the current airport to the new itinerary.\\n                new_itinerary.append(st.pop())\\n\\n        # Reverse the new itinerary to get the correct order.\\n        return new_itinerary[::-1]\\n```\n```javascript []\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n    const graph = new Map();\\n\\n    for (const [departure, arrival] of tickets.sort().reverse()) {\\n        if (!graph.has(departure)) {\\n            graph.set(departure, []);\\n        }\\n        graph.get(departure).push(arrival);\\n    }\\n\\n    const stack = [\"JFK\"];\\n    const newItinerary = [];\\n\\n    while (stack.length > 0) {\\n        const currentAirport = stack[stack.length - 1];\\n\\n        if (graph.has(currentAirport) && graph.get(currentAirport).length > 0) {\\n            stack.push(graph.get(currentAirport).pop());\\n        } else {\\n            newItinerary.push(stack.pop());\\n        }\\n    }\\n\\n    return newItinerary.reverse();    \\n};\\n```\n```java []\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, List<String>> graph = new HashMap<>();\\n\\n        for (List<String> ticket : tickets) {\\n            String departure = ticket.get(0);\\n            String arrival = ticket.get(1);\\n\\n            graph.computeIfAbsent(departure, k -> new ArrayList<>()).add(arrival);\\n        }\\n\\n        for (List<String> destinations : graph.values()) {\\n            destinations.sort(Collections.reverseOrder());\\n        }\\n\\n        List<String> newItinerary = new ArrayList<>();\\n        Deque<String> stack = new ArrayDeque<>();\\n        stack.push(\"JFK\");\\n\\n        while (!stack.isEmpty()) {\\n            String currentAirport = stack.peek();\\n\\n            if (graph.containsKey(currentAirport) && !graph.get(currentAirport).isEmpty()) {\\n                stack.push(graph.get(currentAirport).remove(graph.get(currentAirport).size() - 1));\\n            } else {\\n                newItinerary.add(stack.pop());\\n            }\\n        }\\n\\n        Collections.reverse(newItinerary);\\n        return newItinerary;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, priority_queue<string, vector<string>, greater<string>>> graph;\\n\\n        for (const auto& ticket : tickets) {\\n            graph[ticket[0]].push(ticket[1]);\\n        }\\n\\n        vector<string> newItinerary;\\n        stack<string> st;\\n        st.push(\"JFK\");\\n\\n        while (!st.empty()) {\\n            string currentAirport = st.top();\\n\\n            if (graph.find(currentAirport) != graph.end() && !graph[currentAirport].empty()) {\\n                st.push(graph[currentAirport].top());\\n                graph[currentAirport].pop();\\n            } else {\\n                newItinerary.push_back(st.top());\\n                st.pop();\\n            }\\n        }\\n\\n        reverse(newItinerary.begin(), newItinerary.end());\\n        return newItinerary;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78785,
                "title": "java-11ms-solution-hashmap-sorted-list",
                "content": "    public class Solution {\\n        public List<String> findItinerary(String[][] tickets) {\\n            ArrayList<String> result = new ArrayList<String>();\\n            \\n            if(tickets == null || tickets.length == 0){\\n                return result;\\n            }\\n            \\n            int total = tickets.length + 1;\\n            \\n            HashMap<String, ArrayList<String>> map = new HashMap<String, ArrayList<String>>();\\n            \\n            for(int i = 0; i < tickets.length; i++){\\n                if(map.containsKey(tickets[i][0])){\\n                    ArrayList<String> tmp = map.get(tickets[i][0]);\\n                    listAdd(tickets[i][1], tmp);\\n                }\\n                else{\\n                    ArrayList<String> tmp = new ArrayList<String>();\\n                    tmp.add(tickets[i][1]);\\n                    map.put(tickets[i][0], tmp);\\n                }\\n            }\\n            \\n            result.add(\"JFK\");\\n            \\n            itineraryHelper(\"JFK\", map, result, total, 1);\\n            \\n            return result;\\n        }\\n        \\n        public boolean itineraryHelper(String current, HashMap<String, ArrayList<String>> map, ArrayList<String> result, int total, int num){\\n            \\n            if(num >= total){\\n                return true;\\n            }\\n            \\n            if(!map.containsKey(current) || map.get(current).size() == 0){\\n                return false;\\n            }\\n            \\n            ArrayList<String> curList = map.get(current);\\n            int i = 0;\\n            \\n            while(i < curList.size()){\\n                String next = curList.remove(i);\\n                result.add(next);\\n                \\n                if(itineraryHelper(next, map, result, total, num + 1)){\\n                    return true;\\n                }\\n                \\n                result.remove(result.size() - 1);\\n                listAdd(next, curList);\\n                i++;\\n            }\\n            \\n            return false;\\n        }\\n        \\n        \\n        public void listAdd(String value, ArrayList<String> list){\\n            if(list.size() == 0){\\n                list.add(value);\\n                return;\\n            }\\n            else{\\n                int i = 0;\\n                while(i < list.size()){\\n                    if(value.compareTo(list.get(i)) <= 0){\\n                        list.add(i, value);\\n                        return;\\n                    }\\n                    i++;\\n                }\\n                list.add(value);\\n                return;\\n            }\\n        }\\n        \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<String> findItinerary(String[][] tickets) {\\n            ArrayList<String> result = new ArrayList<String>();\\n            \\n            if(tickets == null || tickets.length == 0){\\n                return result;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 78789,
                "title": "java-14ms-dfs-backtrack",
                "content": "Calculate Euler path. For each point, try to DFS its out-going point. There is chance that a DFS won't get a result. So, we do backtrack. Out-going points should keep ascending order.\\n\\n    public static List<String> findItinerary(String[][] tickets) {\\n        // construct graph\\n        HashMap<String, ArrayList<String>> graph = new HashMap<String, ArrayList<String>>();\\n        ArrayList<String> al = null;\\n        for (String[] ticket : tickets) {\\n            al = graph.get(ticket[0]);\\n            if (al == null) {\\n                al = new ArrayList<String>();\\n                graph.put(ticket[0], al);\\n            }\\n            al.add(ticket[1]);\\n        }\\n        for (ArrayList<String> curr : graph.values()) {\\n            Collections.sort(curr);\\n        }\\n        ArrayList<String> ans = new ArrayList<>();\\n        itineraryHelper(\"JFK\", ans, graph, tickets.length + 1);\\n        return ans;\\n    }\\n\\n    // n is how many stops totally should contain\\n    public static boolean itineraryHelper(String curr, List<String> ans, HashMap<String, ArrayList<String>> graph, int n) {\\n        ans.add(curr);\\n        if (ans.size() >= n) {\\n            return true;\\n        }\\n        if (!graph.containsKey(curr) || graph.get(curr).isEmpty()) {\\n            return false;\\n        }\\n        ArrayList<String> arrivals = graph.get(curr);\\n        for (int i = 0; i < arrivals.size(); i++) { // iterate each arrival point\\n            String arrival = graph.get(curr).remove(i);\\n            if (itineraryHelper(arrival, ans, graph, n)) {\\n                return true;\\n            }\\n            ans.remove(ans.size() - 1); // backtrack\\n            arrivals.add(i, arrival);\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "Calculate Euler path. For each point, try to DFS its out-going point. There is chance that a DFS won't get a result. So, we do backtrack. Out-going points should keep ascending order.\\n\\n    public static List<String> findItinerary(String[][] tickets) {\\n        // construct graph\\n        HashMap<String, ArrayList<String>> graph = new HashMap<String, ArrayList<String>>();\\n        ArrayList<String> al = null;\\n        for (String[] ticket : tickets) {\\n            al = graph.get(ticket[0]);\\n            if (al == null) {\\n                al = new ArrayList<String>();\\n                graph.put(ticket[0], al);\\n            }\\n            al.add(ticket[1]);\\n        }\\n        for (ArrayList<String> curr : graph.values()) {\\n            Collections.sort(curr);\\n        }\\n        ArrayList<String> ans = new ArrayList<>();\\n        itineraryHelper(\"JFK\", ans, graph, tickets.length + 1);\\n        return ans;\\n    }\\n\\n    // n is how many stops totally should contain\\n    public static boolean itineraryHelper(String curr, List<String> ans, HashMap<String, ArrayList<String>> graph, int n) {\\n        ans.add(curr);\\n        if (ans.size() >= n) {\\n            return true;\\n        }\\n        if (!graph.containsKey(curr) || graph.get(curr).isEmpty()) {\\n            return false;\\n        }\\n        ArrayList<String> arrivals = graph.get(curr);\\n        for (int i = 0; i < arrivals.size(); i++) { // iterate each arrival point\\n            String arrival = graph.get(curr).remove(i);\\n            if (itineraryHelper(arrival, ans, graph, n)) {\\n                return true;\\n            }\\n            ans.remove(ans.size() - 1); // backtrack\\n            arrivals.add(i, arrival);\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 138641,
                "title": "logical-thinking-with-clear-java-code",
                "content": "It is intuitive to model the problem as a graph, such that airports are nodes, and tickets are directed edges.\\nWe ought to take two factors into consideration when reconstruct the itinerary:\\n- all tickets are used up; [comments on code `1.`]\\n- the smaller lexical order is preferred;\\n\\nWe simply DFS the graph, and backtrack if the path can not use up all tickets.[comments on code `2.`]\\nTo ensure smallest lexical order, for a departure airport, we sort its arrival airports in the lexical order before DFS.[comments on code `3.`]\\nThen, the first path uses up all tickets should be the final answer. [comments on code `4.`]\\n\\nFor **DFS**,\\nthe **start point** is the airport \"JFK\",\\n**for each departure airport** {\\n\\t\\t\\tit can get an access to any one of its arrival airports, i.e., map.get(start),\\n\\t\\t\\tand move forward to the next step..\\n}\\nthe **end point** is the first path that ensures all tickets to be used up, i.e., result.size() > 0,\\n\\nThe clear code in Java is as below:\\n```\\nList<String> result;\\n\\npublic List<String> findItinerary(String[][] tickets) {\\n    result = new ArrayList<>();\\n    Map<String, List<String>> map = new HashMap<>();\\n    for (String[] ticket : tickets) {\\n        if (!map.containsKey(ticket[0])) {\\n            map.put(ticket[0], new ArrayList<>());\\n        }\\n        map.get(ticket[0]).add(ticket[1]);\\n    }\\n    for (Map.Entry<String, List<String>> entry : map.entrySet()) {\\n        Collections.sort(entry.getValue()); // 3.\\n    }\\n    findItineraryFrom(\"JFK\", map, new ArrayList<>(), tickets.length);\\n    result.add(0, \"JFK\");\\n    return result;\\n}\\n\\nprivate void findItineraryFrom(String start, Map<String, List<String>> map, List<String> curRes, int numTickets) {\\n    if (curRes.size() == numTickets) { // 1.all tickets are used up\\n        result.addAll(curRes);\\n        return;\\n    }\\n    if (map.get(start) == null) { // 2.the path can not use up all tickets\\n        return;\\n    }\\n    for (int i = 0; i < map.get(start).size(); i++) {\\n        String dest = map.get(start).get(i);\\n        map.get(start).remove(dest);\\n        curRes.add(dest);\\n        findItineraryFrom(dest, map, curRes, numTickets);\\n        if (result.size() > 0) { // 4.the first valid path is the final answer\\n            return;\\n        }\\n        map.get(start).add(i, dest);\\n        curRes.remove(curRes.size() - 1);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nList<String> result;\\n\\npublic List<String> findItinerary(String[][] tickets) {\\n    result = new ArrayList<>();\\n    Map<String, List<String>> map = new HashMap<>();\\n    for (String[] ticket : tickets) {\\n        if (!map.containsKey(ticket[0])) {\\n            map.put(ticket[0], new ArrayList<>());\\n        }\\n        map.get(ticket[0]).add(ticket[1]);\\n    }\\n    for (Map.Entry<String, List<String>> entry : map.entrySet()) {\\n        Collections.sort(entry.getValue()); // 3.\\n    }\\n    findItineraryFrom(\"JFK\", map, new ArrayList<>(), tickets.length);\\n    result.add(0, \"JFK\");\\n    return result;\\n}\\n\\nprivate void findItineraryFrom(String start, Map<String, List<String>> map, List<String> curRes, int numTickets) {\\n    if (curRes.size() == numTickets) { // 1.all tickets are used up\\n        result.addAll(curRes);\\n        return;\\n    }\\n    if (map.get(start) == null) { // 2.the path can not use up all tickets\\n        return;\\n    }\\n    for (int i = 0; i < map.get(start).size(); i++) {\\n        String dest = map.get(start).get(i);\\n        map.get(start).remove(dest);\\n        curRes.add(dest);\\n        findItineraryFrom(dest, map, curRes, numTickets);\\n        if (result.size() > 0) { // 4.the first valid path is the final answer\\n            return;\\n        }\\n        map.get(start).add(i, dest);\\n        curRes.remove(curRes.size() - 1);\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1161401,
                "title": "c-explaination-transition-from-dfs-to-eulerian-path",
                "content": "The problem can be modelled as a graph, with each node representing a city, and each ticket representing an edge from source city to destination city. The problem asks us to find a connected sequence(path) consisting of all edges in a graph, starting with \"JFK\".\\n\\nOur general intuition is to jump to algorithms like DFS/BFS. The DFS/BFS algorithms help us traverse all nodes in the graph, but fail to cover all edges in the graph, so we need to look for something more special.\\n\\nThis is where Eulerian Path comes into play. An Eulerian Path is a list of all edges in a graph in a sequence such that you can go from point A to all other nodes in the graph multiple times, as long as an edge is not visited. This should solve our problem.\\n\\nEulerian Path can be implemented using a slightly modified version of DFS. A normal DFS algorithm would look like this:\\n\\n```\\n// Normal DFS Pseudo Code\\n\\nDFS(node)\\n{\\n\\tif (visited[node])\\n\\t\\treturn;\\n\\tvisited[node]=true;\\n\\tfor (neighbour : graph[node]) {\\n\\t\\tDFS(neighbour);\\n\\t}\\n}\\n```\\nNote that here, we only check if a node is visited, which does not guarantee if all paths going to the node have been visited or not. One way to track if all edges have been visited to a node, is to track the outdegree of the node and continuously decrementing the outdegree until it becomes 0. So our modified DFS becomes:\\n\\n```\\nModifiedDFS(node)\\n{\\n\\tif (outdegree[node] == 0) // no more outgoing edges to visit\\n\\t\\treturn;\\n\\t\\t--outdegree[node]       // next neighbour will be visited, reduce outdegree\\n\\tfor (next_unvisited_neighbour : graph[node])\\n\\t{\\n\\t\\tModifiedDFS(next_unvisited_neighbour);\\n\\t}\\n}\\n```\\n\\nIn addition to this, we would also like to make sure that while returning, we capture the node that we have completed visiting while returing back. We could either reverse the order at the end of capturing all nodes we visited to get our path, or we could just use list and record our nodes from back to front. I went ahead with linked list.\\n\\nKindly upvote if you found this helpful!\\n\\n```\\nvoid findPath(string currNode, list <string> &path, map <string, \\n                    vector <string>>& graph, map <string, int> &outDegree)\\n    {\\n\\t    while (outDegree[currNode]) {\\n            findPath(graph[currNode][--outDegree[currNode]],path, graph, outDegree);\\n\\t    }\\n\\t    path.push_front(currNode);\\n    }\\n\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        list <string> path;\\n\\t    string startNode = \"JFK\";\\n\\t    map <string, vector <string>> graph;\\n        map <string, int> outDegree;\\n\\n\\t    for (auto e : tickets) {\\n\\t\\t    graph[e[0]].push_back(e[1]);\\n\\t\\t    outDegree[e[0]]++;\\n\\t    }\\n       \\n        for (auto &g: graph) {\\n            sort(g.second.begin(), g.second.end(), greater<string>());\\n        }\\n\\n\\t    findPath(startNode, path, graph, outDegree);\\n\\t    return vector <string> (path.begin(), path.end());\\n    }\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n// Normal DFS Pseudo Code\\n\\nDFS(node)\\n{\\n\\tif (visited[node])\\n\\t\\treturn;\\n\\tvisited[node]=true;\\n\\tfor (neighbour : graph[node]) {\\n\\t\\tDFS(neighbour);\\n\\t}\\n}\\n```\n```\\nModifiedDFS(node)\\n{\\n\\tif (outdegree[node] == 0) // no more outgoing edges to visit\\n\\t\\treturn;\\n\\t\\t--outdegree[node]       // next neighbour will be visited, reduce outdegree\\n\\tfor (next_unvisited_neighbour : graph[node])\\n\\t{\\n\\t\\tModifiedDFS(next_unvisited_neighbour);\\n\\t}\\n}\\n```\n```\\nvoid findPath(string currNode, list <string> &path, map <string, \\n                    vector <string>>& graph, map <string, int> &outDegree)\\n    {\\n\\t    while (outDegree[currNode]) {\\n            findPath(graph[currNode][--outDegree[currNode]],path, graph, outDegree);\\n\\t    }\\n\\t    path.push_front(currNode);\\n    }\\n\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        list <string> path;\\n\\t    string startNode = \"JFK\";\\n\\t    map <string, vector <string>> graph;\\n        map <string, int> outDegree;\\n\\n\\t    for (auto e : tickets) {\\n\\t\\t    graph[e[0]].push_back(e[1]);\\n\\t\\t    outDegree[e[0]]++;\\n\\t    }\\n       \\n        for (auto &g: graph) {\\n            sort(g.second.begin(), g.second.end(), greater<string>());\\n        }\\n\\n\\t    findPath(startNode, path, graph, outDegree);\\n\\t    return vector <string> (path.begin(), path.end());\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 4042140,
                "title": "96-90-beats-c-hard-easy-easy-to-understand-beginner",
                "content": "# Intuition\\n- The problem requires finding a valid itinerary for a given list of flight tickets. \\n- The itinerary must start from \"JFK\" (John F. Kennedy International Airport) and visit all airports exactly once. \\n- This problem can be solved using depth-first search (DFS) on a directed graph, treating each airport as a node and each ticket as a directed edge.\\n\\n\\n\\n# Approach\\n1. Create an adjacency list representation of the flights. Use an unordered_map where the key is the source airport, and the value is a multiset (sorted set) of destination airports. This allows multiple tickets to have the same source airport.\\n\\n1. Initialize an empty vector called `result` to store the final itinerary.\\n\\n1. Start the DFS traversal from the \"JFK\" airport. The goal is to visit all airports in a way that respects the lexicographically smallest order.\\n\\n1. In the DFS function:\\n\\n   - While there are destinations connected to the current airport:\\n   - Get the next destination by picking the smallest destination lexicographically (because it\\'s stored in a multiset).\\n   - Remove this destination from the list to ensure it\\'s not visited again.\\n   - Recursively explore this destination.\\n 1. After finishing the DFS traversal, reverse the `result` vector. This is necessary because the DFS builds the itinerary in reverse order.\\n\\n1. Return the reversed `result` vector, which now contains the valid itinerary.\\n\\n\\n\\n\\n\\n# Complexity\\n- **Time complexity:**\\n  **O(n * log(n))**\\n\\n  - **The time complexity is O(n * log(n)) for building the adjacency list and O(n * log(n)) for DFS traversal, which is often the dominant factor**\\n\\n\\n\\n- Space complexity:\\n   **O(n * log(n))**\\n\\n    - **The space complexity is O(n * log(n)) for the adjacency list and O(n) for other data structures.**\\n\\n\\n# PLEASE UPVOTE\\u2763\\uD83D\\uDE0D\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    // Depth-first search function to find the itinerary\\n    void dfs(unordered_map<string, multiset<string>>& adj, vector<string>& result, string s){\\n        // While there are destinations connected to the current airport\\n        while(adj[s].size()){\\n            // Get the next destination\\n            string v = *(adj[s].begin());\\n            // Remove this destination from the list\\n            adj[s].erase(adj[s].begin());\\n            // Recursively explore this destination\\n            dfs(adj, result, v);\\n        }\\n        // Add the current airport to the result\\n        result.push_back(s);\\n    }\\npublic:\\n    // Main function to find the itinerary\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // Create an adjacency list to represent the flights\\n        unordered_map<string, multiset<string>> adj;\\n        for(vector<string>& t: tickets)\\n            // Add each destination to the multiset connected to its source airport\\n            adj[t[0]].insert(t[1]);\\n        \\n        // Initialize the result vector\\n        vector<string> result;\\n        // Start the depth-first search from JFK (John F. Kennedy International Airport)\\n        dfs(adj, result, \"JFK\");\\n        // Reverse the result to get the correct itinerary\\n        reverse(result.begin(), result.end());\\n        // Return the itinerary\\n        return result;\\n    }\\n};\\n\\n```\\n# JAVA\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    // Depth-first search function to find the itinerary\\n    private void dfs(Map<String, PriorityQueue<String>> adj, List<String> result, String s) {\\n        // Check if the airport exists in the adjacency list\\n        if (adj.containsKey(s)) {\\n            // While there are destinations connected to the current airport\\n            while (!adj.get(s).isEmpty()) {\\n                // Get the next destination\\n                String v = adj.get(s).poll();\\n                // Recursively explore this destination\\n                dfs(adj, result, v);\\n            }\\n        }\\n        // Add the current airport to the result\\n        result.add(s);\\n    }\\n\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        // Create an adjacency list to represent the flights\\n        Map<String, PriorityQueue<String>> adj = new HashMap<>();\\n        for (List<String> t : tickets) {\\n            adj.computeIfAbsent(t.get(0), k -> new PriorityQueue<>()).offer(t.get(1));\\n        }\\n\\n        // Initialize the result list\\n        List<String> result = new ArrayList<>();\\n        // Start the depth-first search from JFK (John F. Kennedy International Airport)\\n        dfs(adj, result, \"JFK\");\\n        // Reverse the result to get the correct itinerary\\n        Collections.reverse(result);\\n        // Return the itinerary\\n        return result;\\n    }\\n}\\n\\n```\\n# JAVASCRIPT\\n```\\nclass Solution {\\n    // Depth-first search function to find the itinerary\\n    dfs(adj, result, s) {\\n        // While there are destinations connected to the current airport\\n        while (adj[s].size) {\\n            // Get the next destination\\n            let v = adj[s].values().next().value;\\n            // Remove this destination from the list\\n            adj[s].delete(v);\\n            // Recursively explore this destination\\n            this.dfs(adj, result, v);\\n        }\\n        // Add the current airport to the result\\n        result.push(s);\\n    }\\n\\n    findItinerary(tickets) {\\n        // Create an adjacency list to represent the flights\\n        const adj = new Map();\\n        for (const t of tickets) {\\n            if (!adj.has(t[0])) {\\n                adj.set(t[0], new Set());\\n            }\\n            adj.get(t[0]).add(t[1]);\\n        }\\n\\n        // Initialize the result array\\n        const result = [];\\n        // Start the depth-first search from JFK (John F. Kennedy International Airport)\\n        this.dfs(adj, result, \"JFK\");\\n        // Reverse the result to get the correct itinerary\\n        result.reverse();\\n        // Return the itinerary\\n        return result;\\n    }\\n}\\n\\n```\\n# PYTHON\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def dfs(self, adj, result, s):\\n        if s in adj:\\n            destinations = adj[s][:]\\n            while destinations:\\n                dest = destinations[0]\\n                adj[s].pop(0)  # Remove the used ticket\\n                self.dfs(adj, result, dest)\\n                destinations = adj[s][:]\\n        result.append(s)\\n\\n    def findItinerary(self, tickets):\\n        # Create an adjacency list to represent the flights\\n        adj = defaultdict(list)\\n        for t in tickets:\\n            adj[t[0]].append(t[1])\\n        \\n        # Sort the destinations in lexicographical order to get the correct itinerary\\n        for key in adj:\\n            adj[key].sort()\\n\\n        # Initialize the result list\\n        result = []\\n        # Start the depth-first search from JFK (John F. Kennedy International Airport)\\n        self.dfs(adj, result, \"JFK\")\\n        # Reverse the result to get the correct itinerary\\n        result.reverse()\\n\\n        # Check if all tickets have been used\\n        total_tickets = len(tickets) + 1  # Plus one for the starting airport JFK\\n        if len(result) != total_tickets:\\n            return []\\n\\n        # Return the itinerary\\n        return result\\n\\n```\\n# GO\\n```\\npackage main\\n\\nimport (\\n\\t\"container/heap\"\\n\\t\"sort\"\\n)\\n\\ntype Solution struct{}\\n\\n// Depth-first search function to find the itinerary\\nfunc (s Solution) dfs(adj map[string]*PriorityQueue, result *[]string, s string) {\\n\\t// While there are destinations connected to the current airport\\n\\tfor adj[s].Len() > 0 {\\n\\t\\t// Get the next destination\\n\\t\\tv := heap.Pop(adj[s]).(string)\\n\\t\\t// Recursively explore this destination\\n\\t\\ts.dfs(adj, result, v)\\n\\t}\\n\\t// Add the current airport to the result\\n\\t*result = append(*result, s)\\n}\\n\\n// Main function to find the itinerary\\nfunc (s Solution) findItinerary(tickets [][]string) []string {\\n\\t// Create an adjacency list to represent the flights\\n\\tadj := make(map[string]*PriorityQueue)\\n\\tfor _, t := range tickets {\\n\\t\\tsrc, dest := t[0], t[1]\\n\\t\\tif _, ok := adj[src]; !ok {\\n\\t\\t\\tadj[src] = &PriorityQueue{}\\n\\t\\t\\theap.Init(adj[src])\\n\\t\\t}\\n\\t\\theap.Push(adj[src], dest)\\n\\t}\\n\\n\\t// Initialize the result slice\\n\\tvar result []string\\n\\t// Start the depth-first search from JFK (John F. Kennedy International Airport)\\n\\ts.dfs(adj, &result, \"JFK\")\\n\\t// Reverse the result to get the correct itinerary\\n\\tsort.Sort(sort.Reverse(sort.StringSlice(result)))\\n\\t// Return the itinerary\\n\\treturn result\\n}\\n\\n// PriorityQueue is a simple priority queue implemented using a slice\\ntype PriorityQueue []string\\n\\nfunc (pq PriorityQueue) Len() int           { return len(pq) }\\nfunc (pq PriorityQueue) Less(i, j int) bool { return pq[i] < pq[j] }\\nfunc (pq PriorityQueue) Swap(i, j int)      { pq[i], pq[j] = pq[j], pq[i] }\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\t*pq = append(*pq, x.(string))\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n\\n```\\n# PLEASE UPVOTE\\u2763\\uD83D\\uDE0D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Go"
                ],
                "code": "```\\nclass Solution {\\n    // Depth-first search function to find the itinerary\\n    void dfs(unordered_map<string, multiset<string>>& adj, vector<string>& result, string s){\\n        // While there are destinations connected to the current airport\\n        while(adj[s].size()){\\n            // Get the next destination\\n            string v = *(adj[s].begin());\\n            // Remove this destination from the list\\n            adj[s].erase(adj[s].begin());\\n            // Recursively explore this destination\\n            dfs(adj, result, v);\\n        }\\n        // Add the current airport to the result\\n        result.push_back(s);\\n    }\\npublic:\\n    // Main function to find the itinerary\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // Create an adjacency list to represent the flights\\n        unordered_map<string, multiset<string>> adj;\\n        for(vector<string>& t: tickets)\\n            // Add each destination to the multiset connected to its source airport\\n            adj[t[0]].insert(t[1]);\\n        \\n        // Initialize the result vector\\n        vector<string> result;\\n        // Start the depth-first search from JFK (John F. Kennedy International Airport)\\n        dfs(adj, result, \"JFK\");\\n        // Reverse the result to get the correct itinerary\\n        reverse(result.begin(), result.end());\\n        // Return the itinerary\\n        return result;\\n    }\\n};\\n\\n```\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    // Depth-first search function to find the itinerary\\n    private void dfs(Map<String, PriorityQueue<String>> adj, List<String> result, String s) {\\n        // Check if the airport exists in the adjacency list\\n        if (adj.containsKey(s)) {\\n            // While there are destinations connected to the current airport\\n            while (!adj.get(s).isEmpty()) {\\n                // Get the next destination\\n                String v = adj.get(s).poll();\\n                // Recursively explore this destination\\n                dfs(adj, result, v);\\n            }\\n        }\\n        // Add the current airport to the result\\n        result.add(s);\\n    }\\n\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        // Create an adjacency list to represent the flights\\n        Map<String, PriorityQueue<String>> adj = new HashMap<>();\\n        for (List<String> t : tickets) {\\n            adj.computeIfAbsent(t.get(0), k -> new PriorityQueue<>()).offer(t.get(1));\\n        }\\n\\n        // Initialize the result list\\n        List<String> result = new ArrayList<>();\\n        // Start the depth-first search from JFK (John F. Kennedy International Airport)\\n        dfs(adj, result, \"JFK\");\\n        // Reverse the result to get the correct itinerary\\n        Collections.reverse(result);\\n        // Return the itinerary\\n        return result;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    // Depth-first search function to find the itinerary\\n    dfs(adj, result, s) {\\n        // While there are destinations connected to the current airport\\n        while (adj[s].size) {\\n            // Get the next destination\\n            let v = adj[s].values().next().value;\\n            // Remove this destination from the list\\n            adj[s].delete(v);\\n            // Recursively explore this destination\\n            this.dfs(adj, result, v);\\n        }\\n        // Add the current airport to the result\\n        result.push(s);\\n    }\\n\\n    findItinerary(tickets) {\\n        // Create an adjacency list to represent the flights\\n        const adj = new Map();\\n        for (const t of tickets) {\\n            if (!adj.has(t[0])) {\\n                adj.set(t[0], new Set());\\n            }\\n            adj.get(t[0]).add(t[1]);\\n        }\\n\\n        // Initialize the result array\\n        const result = [];\\n        // Start the depth-first search from JFK (John F. Kennedy International Airport)\\n        this.dfs(adj, result, \"JFK\");\\n        // Reverse the result to get the correct itinerary\\n        result.reverse();\\n        // Return the itinerary\\n        return result;\\n    }\\n}\\n\\n```\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def dfs(self, adj, result, s):\\n        if s in adj:\\n            destinations = adj[s][:]\\n            while destinations:\\n                dest = destinations[0]\\n                adj[s].pop(0)  # Remove the used ticket\\n                self.dfs(adj, result, dest)\\n                destinations = adj[s][:]\\n        result.append(s)\\n\\n    def findItinerary(self, tickets):\\n        # Create an adjacency list to represent the flights\\n        adj = defaultdict(list)\\n        for t in tickets:\\n            adj[t[0]].append(t[1])\\n        \\n        # Sort the destinations in lexicographical order to get the correct itinerary\\n        for key in adj:\\n            adj[key].sort()\\n\\n        # Initialize the result list\\n        result = []\\n        # Start the depth-first search from JFK (John F. Kennedy International Airport)\\n        self.dfs(adj, result, \"JFK\")\\n        # Reverse the result to get the correct itinerary\\n        result.reverse()\\n\\n        # Check if all tickets have been used\\n        total_tickets = len(tickets) + 1  # Plus one for the starting airport JFK\\n        if len(result) != total_tickets:\\n            return []\\n\\n        # Return the itinerary\\n        return result\\n\\n```\n```\\npackage main\\n\\nimport (\\n\\t\"container/heap\"\\n\\t\"sort\"\\n)\\n\\ntype Solution struct{}\\n\\n// Depth-first search function to find the itinerary\\nfunc (s Solution) dfs(adj map[string]*PriorityQueue, result *[]string, s string) {\\n\\t// While there are destinations connected to the current airport\\n\\tfor adj[s].Len() > 0 {\\n\\t\\t// Get the next destination\\n\\t\\tv := heap.Pop(adj[s]).(string)\\n\\t\\t// Recursively explore this destination\\n\\t\\ts.dfs(adj, result, v)\\n\\t}\\n\\t// Add the current airport to the result\\n\\t*result = append(*result, s)\\n}\\n\\n// Main function to find the itinerary\\nfunc (s Solution) findItinerary(tickets [][]string) []string {\\n\\t// Create an adjacency list to represent the flights\\n\\tadj := make(map[string]*PriorityQueue)\\n\\tfor _, t := range tickets {\\n\\t\\tsrc, dest := t[0], t[1]\\n\\t\\tif _, ok := adj[src]; !ok {\\n\\t\\t\\tadj[src] = &PriorityQueue{}\\n\\t\\t\\theap.Init(adj[src])\\n\\t\\t}\\n\\t\\theap.Push(adj[src], dest)\\n\\t}\\n\\n\\t// Initialize the result slice\\n\\tvar result []string\\n\\t// Start the depth-first search from JFK (John F. Kennedy International Airport)\\n\\ts.dfs(adj, &result, \"JFK\")\\n\\t// Reverse the result to get the correct itinerary\\n\\tsort.Sort(sort.Reverse(sort.StringSlice(result)))\\n\\t// Return the itinerary\\n\\treturn result\\n}\\n\\n// PriorityQueue is a simple priority queue implemented using a slice\\ntype PriorityQueue []string\\n\\nfunc (pq PriorityQueue) Len() int           { return len(pq) }\\nfunc (pq PriorityQueue) Less(i, j int) bool { return pq[i] < pq[j] }\\nfunc (pq PriorityQueue) Swap(i, j int)      { pq[i], pq[j] = pq[j], pq[i] }\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\t*pq = append(*pq, x.(string))\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729185,
                "title": "easy-c-solution-dfs-backtracking-explained",
                "content": "```\\nclass Solution {\\n    //using multiset instead of set because values maybe repeated. Also set/ multiset is sorted so it gets sorted in lexical order itself\\n    unordered_map <string, multiset <string>> maptickets;       \\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        for (vector <string> t: tickets)     //building graph\\n            maptickets[t[0]].insert(t[1]); \\n        \\n        vector <string> result;\\n        dfs (result, \"JFK\");                 //starting from JFK\\n        reverse (result.begin(), result.end());//result is created during return time of recursion thus reverse needed\\n        return result;                       //returning result\\n    }\\n    \\n    void dfs (vector <string> &result, string source) {\\n        while (!maptickets[source].empty()) {\\n            string dest = *maptickets[source].begin();     //declaring iterator for finding dest\\n            maptickets[source].erase (maptickets[source].begin());  //deleting after travelling\\n            dfs (result, dest);                                  \\n        }\\n        result.push_back(source);                                   //pushing into result\\n    }    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    //using multiset instead of set because values maybe repeated. Also set/ multiset is sorted so it gets sorted in lexical order itself\\n    unordered_map <string, multiset <string>> maptickets;       \\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        for (vector <string> t: tickets)     //building graph\\n            maptickets[t[0]].insert(t[1]); \\n        \\n        vector <string> result;\\n        dfs (result, \"JFK\");                 //starting from JFK\\n        reverse (result.begin(), result.end());//result is created during return time of recursion thus reverse needed\\n        return result;                       //returning result\\n    }\\n    \\n    void dfs (vector <string> &result, string source) {\\n        while (!maptickets[source].empty()) {\\n            string dest = *maptickets[source].begin();     //declaring iterator for finding dest\\n            maptickets[source].erase (maptickets[source].begin());  //deleting after travelling\\n            dfs (result, dest);                                  \\n        }\\n        result.push_back(source);                                   //pushing into result\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709877,
                "title": "python3-dfs-solution",
                "content": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph = {}\\n        \\n        tickets.sort(key=lambda x: x[1])\\n\\n        for u, v in tickets:\\n            if u in graph:\\n                graph[u].append(v)\\n            else:\\n                graph[u] = [v]\\n        \\n        itinerary, stack = [], [(\"JFK\")]\\n        \\n        while stack:\\n            curr = stack[-1]\\n            \\n            if curr in graph and len(graph[curr]) > 0:\\n                stack.append(graph[curr].pop(0))\\n            else:\\n                itinerary.append(stack.pop())\\n        return itinerary[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph = {}\\n        \\n        tickets.sort(key=lambda x: x[1])\\n\\n        for u, v in tickets:\\n            if u in graph:\\n                graph[u].append(v)\\n            else:\\n                graph[u] = [v]\\n        \\n        itinerary, stack = [], [(\"JFK\")]\\n        \\n        while stack:\\n            curr = stack[-1]\\n            \\n            if curr in graph and len(graph[curr]) > 0:\\n                stack.append(graph[curr].pop(0))\\n            else:\\n                itinerary.append(stack.pop())\\n        return itinerary[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395765,
                "title": "java-simple-solution-with-comments",
                "content": "\\tclass Solution {\\n\\n\\t\\tHashMap<String, PriorityQueue<String>> map = new HashMap<>();\\n\\t\\tList<String> res = new LinkedList<>();\\n\\n\\t\\tpublic List<String> findItinerary(List<List<String>> tickets) {\\n\\t\\t\\tfor (List<String> ticket : tickets) {\\n\\t\\t\\t\\t// map.putIfAbsent() is to put value if key does not exist, here we setup a pq if we meet the key the first time.\\n\\t\\t\\t\\tmap.putIfAbsent(ticket.get(0), new PriorityQueue<>());\\n\\t\\t\\t\\t// add the \"destination\" to pq for dfs search, in lexical order by default\\n\\t\\t\\t\\tmap.get(ticket.get(0)).offer(ticket.get(1));\\n\\t\\t\\t}\\n\\t\\t\\thelper(\"JFK\");\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tpublic void helper(String departure) {\\n\\t\\t\\t// If destination exists. When arriving the last departure, add it to res directly\\n\\t\\t\\twhile (map.containsKey(departure) && !map.get(departure).isEmpty()) {\\n\\t\\t\\t\\t// get the next destination, departure and iterate\\n\\t\\t\\t\\thelper(map.get(departure).poll());\\n\\t\\t\\t}\\n\\t\\t\\tres.add(0, departure);\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\n\\t\\tHashMap<String, PriorityQueue<String>> map = new HashMap<>();\\n\\t\\tList<String> res = new LinkedList<>();\\n\\n\\t\\tpublic List<String> findItinerary(List<List<String>> tickets) {\\n\\t\\t\\tfor (List<String> ticket : tickets) {\\n\\t\\t\\t\\t// map.putIfAbsent() is to put value if key does not exist, here we setup a pq if we meet the key the first time.\\n\\t\\t\\t\\tmap.putIfAbsent(ticket.get(0), new PriorityQueue<>());\\n\\t\\t\\t\\t// add the \"destination\" to pq for dfs search, in lexical order by default\\n\\t\\t\\t\\tmap.get(ticket.get(0)).offer(ticket.get(1));\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 78843,
                "title": "c-solution-using-dfs",
                "content": "            \\n      class Solution {\\n        public:\\n            vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n                vector<string> ans;\\n                int n = tickets.size();\\n                for(int i = 0; i < n; ++ i){\\n                    g[tickets[i].first].insert(tickets[i].second);\\n                }\\n                dfs(\"JFK\", ans, 1, n);\\n           //     puts(\" -- \");\\n                reverse(ans.begin(), ans.end());\\n                return ans;\\n            }\\n        private:\\n            void dfs(string u, vector<string> &ans, int dep, int tot){\\n                while(g[u].size()){\\n                    string v = *g[u].begin();\\n                    g[u].erase(g[u].begin());\\n                    dfs(v, ans, dep + 1, tot);\\n                }\\n                ans.push_back(u);\\n            }\\n        private:\\n        unordered_map<string, multiset<string> > g;\\n        //unordered_map<string, set<string>::iterator> vis;\\n        };",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n        public:\\n            vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n                vector<string> ans;\\n                int n = tickets.size();\\n                for(int i = 0; i < n; ++ i){\\n                    g[tickets[i].first].insert(tickets[i].second);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4042456,
                "title": "93-short-concise-explanation-with-visualization-dfs",
                "content": "![image.png](https://assets.leetcode.com/users/images/736fb831-a617-41b1-9741-cb1f01e8e186_1694666659.6518433.png)\\n\\n# Approach\\nWe need to find the itirenary such that it has a smallest `lexical` order.\\n\\nSo we start by making a `graph` with the help of a `map`. We do this by pushing destination `ticket[1]` city to every source `Aicket[0]` city.\\n\\nAfter this we need to `sort our destination cities in reverse order so that we visit lexically smaller destinations`.\\n\\nCreate an array of strings `itinerary` to store our answer.\\n\\nCall` dfs `function on our source, i.e `JFK airport`.\\n\\nThe `dfs` function works like this -\\n- It check if there is a destination city to current airport, if there is, it stores the city in `next` variable. We do `graph[airport].back()` so that we get the` lexically smallest destination`, this is why we sorted in reverse order since we can\\'t pop lexically smallest string from front.\\n- After choosing `next`, pop_back() the lexically smallest destination.\\n- Call` dfs` on this `next` city.\\n- After all calls are made,` push_back() `our original city `Airport`.\\n\\nAt last, we `reverse` our `itinerary` and `return` it.\\n\\n# I\\'ve explained the first test case below for better understanding-\\n\\n![image.png](https://assets.leetcode.com/users/images/2889617b-fcb4-4c82-9980-837feb7b582c_1694668292.608793.png)\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(string& airport, unordered_map<string, vector<string>>& graph,vector<string>& itinerary){\\n        while(!graph[airport].empty()){\\n            string next = graph[airport].back();\\n            graph[airport].pop_back();\\n            dfs(next, graph, itinerary);\\n        }\\n        itinerary.push_back(airport);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, vector<string>> graph;\\n\\n        for(auto& ticket : tickets){\\n            graph[ticket[0]].push_back(ticket[1]);\\n        }\\n        for(auto& temp : graph){\\n            sort(temp.second.rbegin(), temp.second.rend());\\n        }\\n\\n        vector<string> itinerary;\\n        string jfk = \"JFK\";\\n        dfs(jfk, graph, itinerary);\\n\\n        reverse(itinerary.begin(), itinerary.end());\\n\\n        return itinerary;\\n        \\n    }\\n};\\n```\\n# JAVA Code\\n```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        \\n        for (List<String> ticket : tickets) {\\n            graph.putIfAbsent(ticket.get(0), new PriorityQueue<>());\\n            graph.get(ticket.get(0)).add(ticket.get(1));\\n        }\\n        \\n        LinkedList<String> itinerary = new LinkedList<>();\\n        \\n        dfs(\"JFK\", graph, itinerary);\\n        \\n        return itinerary;\\n    }\\n    \\n    private void dfs(String airport, Map<String, PriorityQueue<String>> graph, LinkedList<String> itinerary) {\\n        PriorityQueue<String> nextAirports = graph.get(airport);\\n        while (nextAirports != null && !nextAirports.isEmpty()) {\\n            dfs(nextAirports.poll(), graph, itinerary);\\n        }\\n        itinerary.addFirst(airport);\\n    }\\n}\\n```\\nJava code from @vanAmsen",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(string& airport, unordered_map<string, vector<string>>& graph,vector<string>& itinerary){\\n        while(!graph[airport].empty()){\\n            string next = graph[airport].back();\\n            graph[airport].pop_back();\\n            dfs(next, graph, itinerary);\\n        }\\n        itinerary.push_back(airport);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, vector<string>> graph;\\n\\n        for(auto& ticket : tickets){\\n            graph[ticket[0]].push_back(ticket[1]);\\n        }\\n        for(auto& temp : graph){\\n            sort(temp.second.rbegin(), temp.second.rend());\\n        }\\n\\n        vector<string> itinerary;\\n        string jfk = \"JFK\";\\n        dfs(jfk, graph, itinerary);\\n\\n        reverse(itinerary.begin(), itinerary.end());\\n\\n        return itinerary;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        \\n        for (List<String> ticket : tickets) {\\n            graph.putIfAbsent(ticket.get(0), new PriorityQueue<>());\\n            graph.get(ticket.get(0)).add(ticket.get(1));\\n        }\\n        \\n        LinkedList<String> itinerary = new LinkedList<>();\\n        \\n        dfs(\"JFK\", graph, itinerary);\\n        \\n        return itinerary;\\n    }\\n    \\n    private void dfs(String airport, Map<String, PriorityQueue<String>> graph, LinkedList<String> itinerary) {\\n        PriorityQueue<String> nextAirports = graph.get(airport);\\n        while (nextAirports != null && !nextAirports.isEmpty()) {\\n            dfs(nextAirports.poll(), graph, itinerary);\\n        }\\n        itinerary.addFirst(airport);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699214,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        ## RC ##\\n        ## APPROACH : GRAPH DFS ##\\n        ## EDGE CASE : [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n        \\n        def dfs(city):\\n            while(len(graph[city]) > 0):\\n                dfs(graph[city].pop(0))\\n            res.insert(0, city)                  # last airport\\n            \\n        graph = collections.defaultdict(list)\\n        for u, v in (tickets):\\n            graph[u].append(v)\\n            graph[u].sort()\\n        res=[]                \\n        dfs(\"JFK\")\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        ## RC ##\\n        ## APPROACH : GRAPH DFS ##\\n        ## EDGE CASE : [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n        \\n        def dfs(city):\\n            while(len(graph[city]) > 0):\\n                dfs(graph[city].pop(0))\\n            res.insert(0, city)                  # last airport\\n            \\n        graph = collections.defaultdict(list)\\n        for u, v in (tickets):\\n            graph[u].append(v)\\n            graph[u].sort()\\n        res=[]                \\n        dfs(\"JFK\")\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 424365,
                "title": "python-topological-sort",
                "content": "By looking at the question, it must be clear that all the edges have to be visited. (not unlike regular DFS where we visit every node once)\\n```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    \\n    def _DFS(self, graph, node):\\n        neighbors = graph[node]\\n        while neighbors:\\n            nei = neighbors.pop(0)\\n            self._DFS(graph, nei)\\n        self.itinerary.append(node)\\n    \\n    def _makeGraph(self, edges):\\n        graph = defaultdict(list)\\n        for e in edges:\\n            graph[e[0]].append(e[1])\\n        return graph\\n\\n    def findItinerary(self, tickets):\\n        tickets.sort(key= lambda x: x[1])\\n        graph = self._makeGraph(tickets)\\n        self.itinerary = []\\n        self._DFS(graph, \"JFK\")\\n        return self.itinerary[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    \\n    def _DFS(self, graph, node):\\n        neighbors = graph[node]\\n        while neighbors:\\n            nei = neighbors.pop(0)\\n            self._DFS(graph, nei)\\n        self.itinerary.append(node)\\n    \\n    def _makeGraph(self, edges):\\n        graph = defaultdict(list)\\n        for e in edges:\\n            graph[e[0]].append(e[1])\\n        return graph\\n\\n    def findItinerary(self, tickets):\\n        tickets.sort(key= lambda x: x[1])\\n        graph = self._makeGraph(tickets)\\n        self.itinerary = []\\n        self._DFS(graph, \"JFK\")\\n        return self.itinerary[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709951,
                "title": "cpp-bfs-topological-sort",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, multiset<string>> graph;\\n        for (auto ticket : tickets) {\\n            graph[ticket[0]].insert(ticket[1]);\\n        }\\n        vector<string> res;\\n        stack<string> q;\\n        q.push(\"JFK\");\\n        while (!q.empty()) {\\n            auto from = q.top();\\n            if (!graph[from].size()) {\\n                res.push_back(from);\\n                q.pop();\\n            } else {\\n                auto to = graph[from].begin();\\n                q.push(*to);\\n                graph[from].erase(to);\\n            }\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, multiset<string>> graph;\\n        for (auto ticket : tickets) {\\n            graph[ticket[0]].insert(ticket[1]);\\n        }\\n        vector<string> res;\\n        stack<string> q;\\n        q.push(\"JFK\");\\n        while (!q.empty()) {\\n            auto from = q.top();\\n            if (!graph[from].size()) {\\n                res.push_back(from);\\n                q.pop();\\n            } else {\\n                auto to = graph[from].begin();\\n                q.push(*to);\\n                graph[from].erase(to);\\n            }\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020041,
                "title": "detailed-explanation-and-easiest-solution-in-java-upvote-if-you-like-the-explanation-and-the-code",
                "content": "# Approach\\nThe approach used in this code is to find an itinerary that visits all of the destination airports in a given list of tickets using a depth-first search algorithm.\\nThe intuition behind using a depth-first search to find an itinerary is that it is a relatively simple way to explore all of the possible itineraries and return the one that visits all of the destination airports. By sorting the destination airports in lexicographic order and always choosing the destination that comes first in that order, the algorithm is able to find a valid itinerary that is lexicographically smallest.\\n# Complexity\\nThe complexity of this code depends on the size of the input, which is the list of tickets.\\n\\nThe time complexity of the findItinerary method is O(n log n) because it iterates over the list of tickets once to construct the map variable, and it sorts each list of destinations in the map using the Collections.sort method, which has a time complexity of O(n log n).\\n\\nThe time complexity of the findItenaryDFS method is O(n) because it performs a constant amount of work for each destination airport in the destination list.\\n\\nThe space complexity of both methods is O(n) because they both use a hash map and a linked list to store the input data and the result, and the size of these data structures is directly proportional to the size of the input.\\n\\n# why I have used a linked list:\\n LinkedList is used to store the lists of destination airports for each starting airport in the HashMap.The LinkedList was chosen because it allows elements to be added or removed from the beginning or end of the list in constant time. This is useful in the findItenaryDFS method, where we need to efficiently remove the first destination airport from the list and perform a depth-first search starting at that airport.\\nThe LinkedList data structure is also used to store the final itinerary,This allows the final itinerary to be constructed in the correct order without the need to reverse the list at the end.\\n\\n# how do we know that the airport is only visited once:\\nIn this implementation, each destination airport is visited only once because it is removed from the list of destinations for its starting airport as soon as it is visited. This is done using the pollFirst method, which removes and returns the first element of the list.\\nFor example, when the DFS reaches \"SFO\" as the starting airport, it removes \"ATL\" from the list of destinations for \"SFO\" using pollFirst. This ensures that \"ATL\" is not visited again from \"SFO\" during the DFS.\\nThis approach ensures that each airport is visited only once because the DFS will not revisit an airport if it is not present in the list of destinations for any starting airport.\\n\\n# Code\\n```\\nclass Solution {\\n    // map: keys are starting airports and values are lists of destination airports\\n    HashMap<String, LinkedList<String>> map;\\n    // list of airports visited in order\\n    LinkedList<String> result;\\n    // given a list of tickets, returns the itinerary in the form of a list of airports visited\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        result = new LinkedList<>();\\n        map = new HashMap<>();\\n         // for each ticket, add the destination to the list of destinations for the ticket\\'s starting airport\\n        for (List<String> t : tickets) {\\n            String src = t.get(0);\\n            map.putIfAbsent(src, new LinkedList<>());\\n            map.get(src).add(t.get(1));\\n        }\\n        // sort the lists of destinations so they are in lexicographic order\\n        map.forEach((key, value) -> Collections.sort(value));\\n        // start at JFK and find the itinerary using depth-first search\\n        findItenaryDFS(\"JFK\");\\n        return result;\\n    }\\n    // finds the itinerary starting at the given airport using depth-first search\\n    public void findItenaryDFS(String start){\\n        if (map.containsKey(start)){\\n            LinkedList<String> destination = map.get(start);\\n            // for each destination, find the itinerary starting at that destination\\n            while (!destination.isEmpty()) {\\n                String des = destination.pollFirst();\\n                findItenaryDFS(des);\\n            }\\n        }\\n    // once there are no more destinations, add the current airport to the front of the result list\\n        result.offerFirst(start);\\n    }\\n}\\n\\n// findItinerary(tickets)\\n\\n// 1. Create empty result list and map\\n// 2. Add destinations to map for each ticket\\n// 3. Sort destinations for each source airport\\n// 4. Call findItenaryDFS(\"JFK\")\\n\\n// findItenaryDFS(\"JFK\")\\n\\n// 5. If JFK is in map:\\n//     6. Get destinations for JFK from map\\n//     7. While destinations is not empty:\\n//         8. Remove first destination from list\\n//         9. Call findItenaryDFS(first destination)\\n// 10. Add JFK to front of result list\\n// 11. Return\\n\\n// findItenaryDFS(\"ATL\")\\n\\n// 5. If ATL is in map:\\n//     6. Get destinations for ATL from map\\n//     7. While destinations is not empty:\\n//         8. Remove first destination from list\\n//         9. Call findItenaryDFS(first destination)\\n// 10. Add ATL to front of result list\\n// 11. Return\\n\\n// findItenaryDFS(\"SFO\")\\n\\n// 5. If SFO is in map:\\n//     6. Get destinations for SFO from map\\n//     7. While destinations is not empty:\\n//         8. Remove first destination from list\\n//         9. Call findItenaryDFS(first destination)\\n// 10. Add SFO to front of result list\\n// 11. Return\\n\\n// findItenaryDFS(\"SFO\") returns\\n// findItenaryDFS(\"ATL\") returns\\n// findItenaryDFS(\"JFK\") returns\\n\\n// findItinerary(tickets) returns reversed result list\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // map: keys are starting airports and values are lists of destination airports\\n    HashMap<String, LinkedList<String>> map;\\n    // list of airports visited in order\\n    LinkedList<String> result;\\n    // given a list of tickets, returns the itinerary in the form of a list of airports visited\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        result = new LinkedList<>();\\n        map = new HashMap<>();\\n         // for each ticket, add the destination to the list of destinations for the ticket\\'s starting airport\\n        for (List<String> t : tickets) {\\n            String src = t.get(0);\\n            map.putIfAbsent(src, new LinkedList<>());\\n            map.get(src).add(t.get(1));\\n        }\\n        // sort the lists of destinations so they are in lexicographic order\\n        map.forEach((key, value) -> Collections.sort(value));\\n        // start at JFK and find the itinerary using depth-first search\\n        findItenaryDFS(\"JFK\");\\n        return result;\\n    }\\n    // finds the itinerary starting at the given airport using depth-first search\\n    public void findItenaryDFS(String start){\\n        if (map.containsKey(start)){\\n            LinkedList<String> destination = map.get(start);\\n            // for each destination, find the itinerary starting at that destination\\n            while (!destination.isEmpty()) {\\n                String des = destination.pollFirst();\\n                findItenaryDFS(des);\\n            }\\n        }\\n    // once there are no more destinations, add the current airport to the front of the result list\\n        result.offerFirst(start);\\n    }\\n}\\n\\n// findItinerary(tickets)\\n\\n// 1. Create empty result list and map\\n// 2. Add destinations to map for each ticket\\n// 3. Sort destinations for each source airport\\n// 4. Call findItenaryDFS(\"JFK\")\\n\\n// findItenaryDFS(\"JFK\")\\n\\n// 5. If JFK is in map:\\n//     6. Get destinations for JFK from map\\n//     7. While destinations is not empty:\\n//         8. Remove first destination from list\\n//         9. Call findItenaryDFS(first destination)\\n// 10. Add JFK to front of result list\\n// 11. Return\\n\\n// findItenaryDFS(\"ATL\")\\n\\n// 5. If ATL is in map:\\n//     6. Get destinations for ATL from map\\n//     7. While destinations is not empty:\\n//         8. Remove first destination from list\\n//         9. Call findItenaryDFS(first destination)\\n// 10. Add ATL to front of result list\\n// 11. Return\\n\\n// findItenaryDFS(\"SFO\")\\n\\n// 5. If SFO is in map:\\n//     6. Get destinations for SFO from map\\n//     7. While destinations is not empty:\\n//         8. Remove first destination from list\\n//         9. Call findItenaryDFS(first destination)\\n// 10. Add SFO to front of result list\\n// 11. Return\\n\\n// findItenaryDFS(\"SFO\") returns\\n// findItenaryDFS(\"ATL\") returns\\n// findItenaryDFS(\"JFK\") returns\\n\\n// findItinerary(tickets) returns reversed result list\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 897615,
                "title": "c-dfs-euler-walk-o-e-log-e-solution",
                "content": "Runtime: 44 ms, faster than 68.22% of C++ online submissions for Reconstruct Itinerary.\\nMemory Usage: 15 MB, less than 5.01% of C++ online submissions for Reconstruct Itinerary.\\n\\nReconstruct Itinerary solution comes from Euler walk (visit each edge only once) where we choose edge\\nwhose destination node is lexicographically smaller. Push node in to result vector while all its edges are\\nalready visited which insures that lexical smaller nodes are inserted first in to result vector. \\nFinally our itenary order will be the reverse of the result vector as node that finished\\nfirst are inserted first in the result vector and it is lexically smaller.\\n    \\n```\\nExample: [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]] \\n\\nSimulation of DFS Euler Walk for above graph is shown below,\\n\\nBlack edges are unvisited\\nGreen edges are visited \\nBrown edges are backtrack edge\\n\\nRed nodes are backtrack nodes (all edges visited) which are pushed in to stack.\\n\\nItinerary : [\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]\\n```\\n\\n![image](https://assets.leetcode.com/users/images/93deb98f-7e38-4af8-9e82-b1d14e9898f7_1602878480.6458232.png)\\n\\n![image](https://assets.leetcode.com/users/images/8c4e63d6-23f2-4c20-b80e-a87666374c3a_1602878491.4597306.png)\\n\\n\\n```\\n// comparator for sorting tickets based on destination\\nbool comparator(const vector<string>&a,const vector<string>&b)\\n{\\n    return a[1]<b[1];        \\n}\\n\\nclass Solution {\\npublic:\\n\\n    // itenary list\\n    vector<string>result;\\n    \\n    void dfs(string node, map<string,queue<string>>&graph)\\n    {\\n        // process node\\'s edges \\n        if(graph.count(node))\\n        {\\n            // If node has any edge call DFS with the edge destination node\\n            // also remove the edge as we will not visit the edge again (Euler walk)\\n            while(!graph[node].empty())\\n            {\\n                string child = graph[node].front();\\n                graph[node].pop();\\n                dfs(child,graph);\\n            }  \\n        }\\n        \\n        // push node in to result when all its edges are processed\\n        result.push_back(node);        \\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        \\n        // sort tickets based on destination to get lexical smaller desitantion edge first\\n        sort(tickets.begin(),tickets.end(),comparator);\\n        \\n        // graph adjacency list\\n        map<string,queue<string>>graph;\\n\\n        // populate graph adjacency list\\n        for(int i=0;i<tickets.size();i++)      \\n            graph[tickets[i][0]].push(tickets[i][1]);\\n        \\n        // run DFS starting from JFK\\n        dfs(\"JFK\",graph);\\n        \\n        // reverse result vector to get itenary list order\\n        reverse(result.begin(),result.end());\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nExample: [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]] \\n\\nSimulation of DFS Euler Walk for above graph is shown below,\\n\\nBlack edges are unvisited\\nGreen edges are visited \\nBrown edges are backtrack edge\\n\\nRed nodes are backtrack nodes (all edges visited) which are pushed in to stack.\\n\\nItinerary : [\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]\\n```\n```\\n// comparator for sorting tickets based on destination\\nbool comparator(const vector<string>&a,const vector<string>&b)\\n{\\n    return a[1]<b[1];        \\n}\\n\\nclass Solution {\\npublic:\\n\\n    // itenary list\\n    vector<string>result;\\n    \\n    void dfs(string node, map<string,queue<string>>&graph)\\n    {\\n        // process node\\'s edges \\n        if(graph.count(node))\\n        {\\n            // If node has any edge call DFS with the edge destination node\\n            // also remove the edge as we will not visit the edge again (Euler walk)\\n            while(!graph[node].empty())\\n            {\\n                string child = graph[node].front();\\n                graph[node].pop();\\n                dfs(child,graph);\\n            }  \\n        }\\n        \\n        // push node in to result when all its edges are processed\\n        result.push_back(node);        \\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        \\n        // sort tickets based on destination to get lexical smaller desitantion edge first\\n        sort(tickets.begin(),tickets.end(),comparator);\\n        \\n        // graph adjacency list\\n        map<string,queue<string>>graph;\\n\\n        // populate graph adjacency list\\n        for(int i=0;i<tickets.size();i++)      \\n            graph[tickets[i][0]].push(tickets[i][1]);\\n        \\n        // run DFS starting from JFK\\n        dfs(\"JFK\",graph);\\n        \\n        // reverse result vector to get itenary list order\\n        reverse(result.begin(),result.end());\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 587548,
                "title": "dfs-priority-queue-concise",
                "content": "```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        LinkedList<String> result = new LinkedList<>();\\n        Map<String, PriorityQueue<String>> graph = buildGraph(tickets);\\n        dfs(result, graph, \"JFK\");\\n        return result;\\n    }\\n    \\n    void dfs(LinkedList<String> result, Map<String, PriorityQueue<String>> graph, String from) {\\n        PriorityQueue<String> destinations = graph.getOrDefault(from, new PriorityQueue<>());\\n        \\n        while (!destinations.isEmpty()) {\\n            String to = destinations.poll();\\n            dfs(result, graph, to);\\n        }\\n        \\n        result.addFirst(from);\\n    }\\n    \\n    Map<String, PriorityQueue<String>> buildGraph(List<List<String>> tickets) {\\n        Map<String, PriorityQueue<String>> result = new HashMap<>();\\n        \\n        for (List<String> path : tickets) {\\n            String from = path.get(0);\\n            String to   = path.get(1); \\n            \\n            result.putIfAbsent(from, new PriorityQueue<>());\\n            \\n            result.get(from).offer(to);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        LinkedList<String> result = new LinkedList<>();\\n        Map<String, PriorityQueue<String>> graph = buildGraph(tickets);\\n        dfs(result, graph, \"JFK\");\\n        return result;\\n    }\\n    \\n    void dfs(LinkedList<String> result, Map<String, PriorityQueue<String>> graph, String from) {\\n        PriorityQueue<String> destinations = graph.getOrDefault(from, new PriorityQueue<>());\\n        \\n        while (!destinations.isEmpty()) {\\n            String to = destinations.poll();\\n            dfs(result, graph, to);\\n        }\\n        \\n        result.addFirst(from);\\n    }\\n    \\n    Map<String, PriorityQueue<String>> buildGraph(List<List<String>> tickets) {\\n        Map<String, PriorityQueue<String>> result = new HashMap<>();\\n        \\n        for (List<String> path : tickets) {\\n            String from = path.get(0);\\n            String to   = path.get(1); \\n            \\n            result.putIfAbsent(from, new PriorityQueue<>());\\n            \\n            result.get(from).offer(to);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78780,
                "title": "java-stack-solution-hierholzer-u2019s-algorithm",
                "content": "[Here](http://www.graph-magics.com/articles/euler.php)'s the details of finding Euler path using Hierholzer\\u2019s Algorithm. I implemented it in Java. \\n\\nThe main steps are as follows.\\n\\n1. Start with an empty stack and an empty circuit (eulerian path).\\n   - If all vertices have same out-degrees as in-degrees - choose any of them.\\n   - If all but 2 vertices have same out-degree as in-degree, and one of those 2 vertices has out-degree with one greater than its in-degree, and the other has in-degree with one greater than its out-degree - then choose the vertex that has its out-degree with one greater than its in-degree.\\n   - Otherwise no euler circuit or path exists.\\n\\n2. If current vertex has no out-going edges (i.e. neighbors) - add it to circuit, remove the last vertex from the stack and set it as the current one. Otherwise (in case it has out-going edges, i.e. neighbors) - add the vertex to the stack, take any of its neighbors, remove the edge between that vertex and selected neighbor, and set that neighbor as the current vertex.\\n\\n3. Repeat step 2 until the current vertex has no more out-going edges (neighbors) and the stack is empty.\\nNote that obtained circuit will be in reverse order - from end vertex to start vertex.\\n\\nCode:\\n```\\npublic class Solution {\\n    public List<String> findItinerary(String[][] tickets) {\\n        Map<String, PriorityQueue<String>> map = new HashMap<>();\\n        LinkedList<String> route = new LinkedList<>();\\n        Stack<String> stack = new Stack<>();\\n        \\n        for (String[] t : tickets) {\\n            map.putIfAbsent(t[0], new PriorityQueue<>());\\n            map.putIfAbsent(t[1], new PriorityQueue<>()); //construct a queue for every node (even those without neighbors)\\n            map.get(t[0]).add(t[1]);\\n        }\\n        \\n        String cur = \"JFK\";\\n        while (map.get(cur).size() != 0 || !stack.isEmpty()){\\n            if (map.get(cur).size() == 0){\\n                route.add(cur);\\n                cur = stack.pop();\\n            } else {\\n                stack.add(cur);\\n                cur = map.get(cur).poll();\\n            }\\n        }\\n        route.add(cur);\\n        Collections.reverse(route);\\n        return route;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<String> findItinerary(String[][] tickets) {\\n        Map<String, PriorityQueue<String>> map = new HashMap<>();\\n        LinkedList<String> route = new LinkedList<>();\\n        Stack<String> stack = new Stack<>();\\n        \\n        for (String[] t : tickets) {\\n            map.putIfAbsent(t[0], new PriorityQueue<>());\\n            map.putIfAbsent(t[1], new PriorityQueue<>()); //construct a queue for every node (even those without neighbors)\\n            map.get(t[0]).add(t[1]);\\n        }\\n        \\n        String cur = \"JFK\";\\n        while (map.get(cur).size() != 0 || !stack.isEmpty()){\\n            if (map.get(cur).size() == 0){\\n                route.add(cur);\\n                cur = stack.pop();\\n            } else {\\n                stack.add(cur);\\n                cur = map.get(cur).poll();\\n            }\\n        }\\n        route.add(cur);\\n        Collections.reverse(route);\\n        return route;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78851,
                "title": "two-java-solution-dfs-stack-backtrace-recursion-very-easy-to-understand",
                "content": "I have used two method to solve this problem, the first one is a DFS using stack, the second one is backtrace. The backtrace one only uses 14ms, and the one with stack used 25ms. Personally, I prefer to use backtrace methods, because it is easy to understand, and it kind of has a \"template\" which you can apply to almost all backtrace problems.\\n\\nThis is a DFS using stack:\\n\\n    public class Solution {\\n        public List<String> findItinerary(String[][] tickets) {\\n            List<String> result = new ArrayList();\\n            if(tickets == null || tickets.length == 0){\\n                return result;\\n            }\\n            Map<String, ArrayList<String>> graph = new HashMap();\\n        \\n            for(int i=0; i<tickets.length; i++){\\n                if(!graph.containsKey(tickets[i][0])){\\n                    ArrayList<String> adj = new ArrayList();\\n                    adj.add(tickets[i][1]);\\n                    graph.put(tickets[i][0], adj);\\n                }else{\\n                    ArrayList<String> newadj = graph.get(tickets[i][0]);\\n                    newadj.add(tickets[i][1]);\\n                    graph.put(tickets[i][0], newadj);\\n                }\\n            }\\n            for(ArrayList<String> a : graph.values()){\\n                Collections.sort(a);\\n            }\\n            \\n            Stack<String> stack = new Stack();\\n            stack.push(\"JFK\");\\n            \\n            while(!stack.isEmpty()){\\n                \\n                while(graph.containsKey(stack.peek()) && !graph.get(stack.peek()).isEmpty()){\\n                    stack.push(graph.get(stack.peek()).remove(0));\\n                }\\n                result.add(0,stack.pop());\\n            }\\n            return result;\\n        }\\n    }\\n\\nThis one is a backtrace method with recursion:\\n\\n    public class Solution {\\n        public List<String> findItinerary(String[][] tickets) {\\n            List<String> result = new ArrayList();\\n            if(tickets == null || tickets.length == 0){\\n                return result;\\n            }\\n            \\n            Map<String, ArrayList<String>> graph = new HashMap();\\n            for(int i=0; i<tickets.length; i++){\\n                if(!graph.containsKey(tickets[i][0])){\\n                    ArrayList<String> adj = new ArrayList();\\n                    adj.add(tickets[i][1]);\\n                    graph.put(tickets[i][0], adj);\\n                }else{\\n                    ArrayList<String> newadj = graph.get(tickets[i][0]);\\n                    newadj.add(tickets[i][1]);\\n                    graph.put(tickets[i][0], newadj);\\n                }\\n            }\\n            \\n            for(ArrayList<String> a : graph.values()){\\n                Collections.sort(a);\\n            }\\n            \\n            backtracing(result, \"JFK\", graph);\\n            \\n            return result;\\n        }\\n        \\n        public void backtracing(List<String> result, String current, Map<String, ArrayList<String>> graph){\\n            while(graph.containsKey(current) && !graph.get(current).isEmpty()){\\n                String s = graph.get(current).remove(0);\\n                backtracing(result, s, graph);\\n            }\\n            result.add(0,current);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<String> findItinerary(String[][] tickets) {\\n            List<String> result = new ArrayList();\\n            if(tickets == null || tickets.length == 0){\\n                return result;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 838099,
                "title": "javascript-dfs-easy-solution-beats-98",
                "content": "```\\nvar findItinerary = function(tickets) {\\n    let result = [];\\n    let adjacencyList = {};\\n    \\n    //CREATING ADJACENCY LIST\\n    tickets.forEach(ticket => {\\n        if (!adjacencyList[ticket[0]]) {\\n            adjacencyList[ticket[0]] = []\\n        }\\n        adjacencyList[ticket[0]].push(ticket[1])\\n    })\\n    \\n    //SORTING LEXOGRAPHICALLY\\n    for (let ticket in adjacencyList) {\\n        adjacencyList[ticket].sort()\\n    }\\n    \\n    //DFS AND BACKTRACKING\\n    function dfs(ticket){\\n        let destination = adjacencyList[ticket] \\n        while(destination && destination.length){\\n            dfs(destination.shift())\\n        }\\n        result.push(ticket)\\n    }\\n    dfs(\"JFK\")\\n    return result.reverse();\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar findItinerary = function(tickets) {\\n    let result = [];\\n    let adjacencyList = {};\\n    \\n    //CREATING ADJACENCY LIST\\n    tickets.forEach(ticket => {\\n        if (!adjacencyList[ticket[0]]) {\\n            adjacencyList[ticket[0]] = []\\n        }\\n        adjacencyList[ticket[0]].push(ticket[1])\\n    })\\n    \\n    //SORTING LEXOGRAPHICALLY\\n    for (let ticket in adjacencyList) {\\n        adjacencyList[ticket].sort()\\n    }\\n    \\n    //DFS AND BACKTRACKING\\n    function dfs(ticket){\\n        let destination = adjacencyList[ticket] \\n        while(destination && destination.length){\\n            dfs(destination.shift())\\n        }\\n        result.push(ticket)\\n    }\\n    dfs(\"JFK\")\\n    return result.reverse();\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 4042826,
                "title": "c-priority-queue-multiset-dfs-variant-for-hierholzer-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n Solve Eulerian path problem using hash table & priority queue/multiset by DFS. \\n\\nThe method is a variant for Hierholzer\\u2019s algorithm whose standard version solves the following problem:\\n[Leetcode 2097. Valid Arrangement of Pairs](https://leetcode.com/problems/valid-arrangement-of-pairs/solutions/4044209/c-euler-path-dfs-beats-94-74/)\\n\\nThat\\'s Euler\\'s path problem, probably for finding path passing every edge once and only once. There exists an Eulerian path $\\\\iff$\\nThe initial $v_0$ must have $indeg(v_0)+1=outdeg(v_0)$ or $indeg(v_0)=outdeg(v_0)$ (if an Euler cycle) the terminal vertex $v_{n-1}$ has $indeg(v_{n-1})=outdeg(v_{n-1})+1$ or $indeg(v_{n-1})=outdeg(v_{n-1})$ (if an Euler cycle $v_0=v_{n-1}$)\\nFor other vertex $v_i$ has $indeg(v_i)=outdeg(v_i)$\\n\\n# K\\xF6nigsberg  7 bridges problem\\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)\\nFor undirected graph the equivilant condition for the existence of an Eulerian cycle is changed to: Every vertex $v$ has $\\\\deg(v)=0\\\\pmod{0}$. It is surely the graph for K\\xF6nigsberg  7 bridges problem does not satisfy this condition. Neither Eulerian cycle nor Eulerian path does have the graph for K\\xF6nigsberg  7 bridges problem!!!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLC wants the answer following the rule: \"If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\"\\n\\nTherefore, sorting cannot be avoided. Instead of applying sort, the priority queues( MinHeaps )or multisets are used.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n \\\\log k)$$ where k=max(outdegree)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, priority_queue<string, vector<string>, greater<string>>>   \\n    fly; // fly[From] is a MinHeap\\n    void build_graph(vector<vector<string>>& tickets){\\n        for(auto& edge: tickets){\\n            string From=edge[0], To=edge[1];\\n            fly[From].push(To);\\n        }\\n    }\\n    vector<string> ans;\\n    void dfs(string From){\\n        while(!fly[From].empty()){\\n            string To=fly[From].top();\\n            fly[From].pop();\\n            dfs(To);\\n        }\\n        ans.push_back(From);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        build_graph(tickets);\\n        dfs(\"JFK\");\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\\n# Code using deque for ans\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, priority_queue<string, vector<string>, greater<string>>>   \\n    fly; // fly[From] is a MinHeap\\n    //unordered_map<string, int> indeg, outdeg;\\n    void build_graph(vector<vector<string>>& tickets){\\n        for(auto& edge: tickets){\\n            string From=edge[0], To=edge[1];\\n            fly[From].push(To);\\n        }\\n    }\\n    deque<string> ans;\\n    void dfs(string From){\\n        while(!fly[From].empty()){\\n            string To=fly[From].top();\\n            fly[From].pop();\\n            dfs(To);\\n        }\\n        ans.push_front(From);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        build_graph(tickets);\\n        dfs(\"JFK\");\\n        return vector<string>(ans.begin(), ans.end());\\n    }\\n};\\n```\\n# Code using multiset\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, multiset<string>>   \\n    fly; // fly[From] is a MinHeap\\n    //unordered_map<string, int> indeg, outdeg;\\n    void build_graph(vector<vector<string>>& tickets){\\n        for(auto& edge: tickets){\\n            string From=edge[0], To=edge[1];\\n            fly[From].insert(To);\\n        }\\n    }\\n    deque<string> ans;\\n    void dfs(string From){\\n        while(!fly[From].empty()){\\n            auto it=fly[From].begin();\\n            string To=*it;\\n            fly[From].erase(it);\\n            dfs(To);\\n        }\\n        ans.push_front(From);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        build_graph(tickets);\\n        dfs(\"JFK\");\\n        return vector<string>(ans.begin(), ans.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, priority_queue<string, vector<string>, greater<string>>>   \\n    fly; // fly[From] is a MinHeap\\n    void build_graph(vector<vector<string>>& tickets){\\n        for(auto& edge: tickets){\\n            string From=edge[0], To=edge[1];\\n            fly[From].push(To);\\n        }\\n    }\\n    vector<string> ans;\\n    void dfs(string From){\\n        while(!fly[From].empty()){\\n            string To=fly[From].top();\\n            fly[From].pop();\\n            dfs(To);\\n        }\\n        ans.push_back(From);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        build_graph(tickets);\\n        dfs(\"JFK\");\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, priority_queue<string, vector<string>, greater<string>>>   \\n    fly; // fly[From] is a MinHeap\\n    //unordered_map<string, int> indeg, outdeg;\\n    void build_graph(vector<vector<string>>& tickets){\\n        for(auto& edge: tickets){\\n            string From=edge[0], To=edge[1];\\n            fly[From].push(To);\\n        }\\n    }\\n    deque<string> ans;\\n    void dfs(string From){\\n        while(!fly[From].empty()){\\n            string To=fly[From].top();\\n            fly[From].pop();\\n            dfs(To);\\n        }\\n        ans.push_front(From);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        build_graph(tickets);\\n        dfs(\"JFK\");\\n        return vector<string>(ans.begin(), ans.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, multiset<string>>   \\n    fly; // fly[From] is a MinHeap\\n    //unordered_map<string, int> indeg, outdeg;\\n    void build_graph(vector<vector<string>>& tickets){\\n        for(auto& edge: tickets){\\n            string From=edge[0], To=edge[1];\\n            fly[From].insert(To);\\n        }\\n    }\\n    deque<string> ans;\\n    void dfs(string From){\\n        while(!fly[From].empty()){\\n            auto it=fly[From].begin();\\n            string To=*it;\\n            fly[From].erase(it);\\n            dfs(To);\\n        }\\n        ans.push_front(From);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        build_graph(tickets);\\n        dfs(\"JFK\");\\n        return vector<string>(ans.begin(), ans.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473415,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using DFS && Backtracking***\\n\\n* ***Time Complexity :- O(N * N * logN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<string> res;\\n    \\n    // adjacency list\\n    \\n    unordered_map<string, multiset<string>> mp;\\n    \\n    bool dfs(string u, int n)\\n    {\\n        // if we have traversed all the edges, then return 1\\n        \\n        if(res.size() == n + 1)\\n            return true;\\n        \\n        // if if there is no. adjacent of curr node, then return false\\n        \\n        if(mp[u].size() == 0)\\n            return false;\\n        \\n        multiset<string> s = mp[u];\\n        \\n        // check for all the adjacents of curr node\\n       \\n        for(auto v : s)\\n        {   \\n            // find the address of adjacent node\\n            \\n            auto it = mp[u].find(v);\\n            \\n            // erase the adjacent node\\n            \\n            mp[u].erase(it);\\n            \\n            // push the adjacent node into res\\n            \\n            res.push_back(v);\\n            \\n            // if the curr path lead to result then return true\\n            \\n            if(dfs(v, n))\\n                return true;\\n            \\n            // else backtrack\\n            \\n            else\\n            {\\n                res.pop_back();\\n                \\n                mp[u].insert(v);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        \\n        int n = tickets.size();\\n        \\n        // make adjacency list\\n       \\n        for(int i = 0; i < tickets.size(); i++)\\n        {\\n            string u = tickets[i][0];\\n            \\n            string v = tickets[i][1];\\n            \\n            mp[u].insert(v);\\n        }\\n        \\n        // push the initial value\\n        \\n        res.push_back(\"JFK\");\\n        \\n        dfs(\"JFK\", n);\\n       \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> res;\\n    \\n    // adjacency list\\n    \\n    unordered_map<string, multiset<string>> mp;\\n    \\n    bool dfs(string u, int n)\\n    {\\n        // if we have traversed all the edges, then return 1\\n        \\n        if(res.size() == n + 1)\\n            return true;\\n        \\n        // if if there is no. adjacent of curr node, then return false\\n        \\n        if(mp[u].size() == 0)\\n            return false;\\n        \\n        multiset<string> s = mp[u];\\n        \\n        // check for all the adjacents of curr node\\n       \\n        for(auto v : s)\\n        {   \\n            // find the address of adjacent node\\n            \\n            auto it = mp[u].find(v);\\n            \\n            // erase the adjacent node\\n            \\n            mp[u].erase(it);\\n            \\n            // push the adjacent node into res\\n            \\n            res.push_back(v);\\n            \\n            // if the curr path lead to result then return true\\n            \\n            if(dfs(v, n))\\n                return true;\\n            \\n            // else backtrack\\n            \\n            else\\n            {\\n                res.pop_back();\\n                \\n                mp[u].insert(v);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        \\n        int n = tickets.size();\\n        \\n        // make adjacency list\\n       \\n        for(int i = 0; i < tickets.size(); i++)\\n        {\\n            string u = tickets[i][0];\\n            \\n            string v = tickets[i][1];\\n            \\n            mp[u].insert(v);\\n        }\\n        \\n        // push the initial value\\n        \\n        res.push_back(\"JFK\");\\n        \\n        dfs(\"JFK\", n);\\n       \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597192,
                "title": "python-simple-faster-98",
                "content": "```\\nclass Solution(object):\\n    def findItinerary(self, tickets):\\n        \"\"\"\\n        :type tickets: List[List[str]]\\n        :rtype: List[str]\\n        \"\"\"\\n        graph = defaultdict(list)\\n        \\n        for src, dest in tickets:\\n            graph[src].append(dest)\\n        \\n        for key in graph:\\n            graph[key].sort(reverse = True)\\n            \\n        ans = []\\n        \\n        def dfs(node):\\n            \\n            while graph[node]:\\n                dfs(graph[node].pop())\\n            \\n            ans.append(node)\\n        \\n        dfs(\"JFK\")\\n        return ans[::-1]\\n                \\n        \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findItinerary(self, tickets):\\n        \"\"\"\\n        :type tickets: List[List[str]]\\n        :rtype: List[str]\\n        \"\"\"\\n        graph = defaultdict(list)\\n        \\n        for src, dest in tickets:\\n            graph[src].append(dest)\\n        \\n        for key in graph:\\n            graph[key].sort(reverse = True)\\n            \\n        ans = []\\n        \\n        def dfs(node):\\n            \\n            while graph[node]:\\n                dfs(graph[node].pop())\\n            \\n            ans.append(node)\\n        \\n        dfs(\"JFK\")\\n        return ans[::-1]\\n                \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 297787,
                "title": "java-topological-sort",
                "content": "```\\nprivate static final String INITIAL_AIRPORT = \"JFK\";\\n\\n  public List<String> findItinerary(List<List<String>> tickets) {\\n    if (tickets == null || tickets.size() == 0)\\n      return new ArrayList<>();\\n    Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n    for (List<String> ticket : tickets) {\\n      graph.putIfAbsent(ticket.get(0), new PriorityQueue<>(String::compareTo));\\n      graph.get(ticket.get(0)).add(ticket.get(1));\\n    }\\n\\n    LinkedList<String> result = new LinkedList<>();\\n    topologicalSort(INITIAL_AIRPORT, graph, result);\\n\\n    return result;\\n  }\\n\\n  private void topologicalSort(String vertex, Map<String, PriorityQueue<String>> graph, LinkedList<String> result) {\\n    PriorityQueue<String> queue = graph.get(vertex);\\n    while (queue != null && !queue.isEmpty()) {\\n      String adj = queue.poll();\\n      topologicalSort(adj, graph, result);\\n\\n    }\\n    result.addFirst(vertex);\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate static final String INITIAL_AIRPORT = \"JFK\";\\n\\n  public List<String> findItinerary(List<List<String>> tickets) {\\n    if (tickets == null || tickets.size() == 0)\\n      return new ArrayList<>();\\n    Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n    for (List<String> ticket : tickets) {\\n      graph.putIfAbsent(ticket.get(0), new PriorityQueue<>(String::compareTo));\\n      graph.get(ticket.get(0)).add(ticket.get(1));\\n    }\\n\\n    LinkedList<String> result = new LinkedList<>();\\n    topologicalSort(INITIAL_AIRPORT, graph, result);\\n\\n    return result;\\n  }\\n\\n  private void topologicalSort(String vertex, Map<String, PriorityQueue<String>> graph, LinkedList<String> result) {\\n    PriorityQueue<String> queue = graph.get(vertex);\\n    while (queue != null && !queue.isEmpty()) {\\n      String adj = queue.poll();\\n      topologicalSort(adj, graph, result);\\n\\n    }\\n    result.addFirst(vertex);\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 78830,
                "title": "10-ms-short-java-solution-using-dfs-topological-sort-beats-96-well-explained",
                "content": "         /**\\n             * When you run random custom test cases in editor you will get to know that they require a topological sort to be done on the input.\\n             * For ex feeding [[\"JFK\",NRT],[\"JFK\",KUL]] returns [\"JFK\",\"NRT\",\"KUL\"] which seems wrong as per the explanation but since input is not a valid itinerary hence the result.\\n             * This problem needs a topological sort in short. Hence do a topological sort after storing nodes in a sorted order. \\n             * Note :- \\n             **Topological sort is used only for DAGs** hence we need to *remove the edges* once it is visited. Thats why the solution uses a priority queue which sorts the nodes as well as helps in removing it in an efficient way. \\n             */\\n            public List<String> findItinerary(String[][] tickets) {\\n                LinkedList<String> result = new LinkedList<>();\\n                HashMap<String,PriorityQueue<String>> graph = new HashMap<>();\\n                for(String[] edge : tickets){\\n                    if(!graph.containsKey(edge[0]))\\n                        graph.put(edge[0],new PriorityQueue<>());\\n                    graph.get(edge[0]).offer(edge[1]);\\n                }\\n                DFS(\"JFK\",graph,result); // we need to do DFS/topological sort only from \"JFK\"\\n                return result;\\n            }\\n            /*DFS doing topological sort*/\\n            private void DFS(String node,HashMap<String,PriorityQueue<String>> graph,LinkedList<String> result ){\\n                PriorityQueue<String> nodes = graph.get(node);\\n                while(nodes!= null && !nodes.isEmpty())\\n                    DFS(nodes.poll(),graph,result);\\n                result.addFirst(node); // this is the key, instead of reversing add to the head of linkelist.\\n            }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "         /**\\n             * When you run random custom test cases in editor you will get to know that they require a topological sort to be done on the input.\\n             * For ex feeding [[\"JFK\",NRT],[\"JFK\",KUL]] returns [\"JFK\",\"NRT\",\"KUL\"] which seems wrong as per the explanation but since input is not a valid itinerary hence the result.\\n             * This problem needs a topological sort in short. Hence do a topological sort after storing nodes in a sorted order. \\n             * Note :- \\n             **Topological sort is used only for DAGs** hence we need to *remove the edges* once it is visited. Thats why the solution uses a priority queue which sorts the nodes as well as helps in removing it in an efficient way. \\n             */\\n            public List<String> findItinerary(String[][] tickets) {\\n                LinkedList<String> result = new LinkedList<>();\\n                HashMap<String,PriorityQueue<String>> graph = new HashMap<>();\\n                for(String[] edge : tickets){\\n                    if(!graph.containsKey(edge[0]))\\n                        graph.put(edge[0],new PriorityQueue<>());\\n                    graph.get(edge[0]).offer(edge[1]);\\n                }\\n                DFS(\"JFK\",graph,result); // we need to do DFS/topological sort only from \"JFK\"\\n                return result;\\n            }\\n            /*DFS doing topological sort*/\\n            private void DFS(String node,HashMap<String,PriorityQueue<String>> graph,LinkedList<String> result ){\\n                PriorityQueue<String> nodes = graph.get(node);\\n                while(nodes!= null && !nodes.isEmpty())\\n                    DFS(nodes.poll(),graph,result);\\n                result.addFirst(node); // this is the key, instead of reversing add to the head of linkelist.\\n            }",
                "codeTag": "Unknown"
            },
            {
                "id": 78831,
                "title": "short-python-solution-dfs-backtracking",
                "content": "\\n    \\n    class Solution(object):\\n        def findItinerary(self, tickets):\\n    \\n            def build_graph(tickets):\\n                G = {}\\n                for t in tickets:\\n                    S, E = t\\n                    G[S] = G.get(S, []) + [E]\\n                for A in G:\\n                    G[A].sort(reverse=True)\\n                    G[A] = deque(G[A])\\n                return G\\n            \\n            def dfs(G, S):\\n                trip.append(S)\\n                if len(trip) == length:\\n                    return True\\n                if S in G:\\n                    n, i = len(G[S]), 0\\n                    while i < n:\\n                        A = G[S].pop()\\n                        if dfs(G, A):\\n                            return True\\n                        G[S].appendleft(A)\\n                        i += 1\\n                trip.pop()\\n                return False\\n                \\n                \\n            G = build_graph(tickets)\\n            trip, length = [], len(tickets) + 1\\n            dfs(G, \"JFK\")\\n            return trip",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution(object):\\n        def findItinerary(self, tickets):\\n    \\n            def build_graph(tickets):\\n                G = {}",
                "codeTag": "Java"
            },
            {
                "id": 2696171,
                "title": "python-3-7-lines-recursion-w-explanation-t-s-97-88",
                "content": "\\nThe problem reduces to finding the left-most leaf in level `n` (where `n  = len(tickets)`) of an *n*-ary tree. For example,\\n```\\ntickets = [[JFK,SFO],[JFK,ATL],[SFO,ATL],[ATL,JFK],[ATL,SFO]]\\n\\n           d = {JFK:[ATL,SFO], ATL:[JFK,SFO], SFO:[ATL]}\\n\\n                               ________ JFK __\\n                             /          ^     \\\\\\n             ______________ ATL __            SFO \\n            /                ^    \\\\\\n          JFK ________            SFO \\n           ^          \\\\\\n                   __ SFO \\n                  /    ^\\n              ATL __ \\n                ^     \\\\\\n                     SFO \\n                      ^        \\n#                   ```\\n    \\nThe path is [JFK,ATL,JFK,SFO,ATL,SFO].\\n\\n```\\nHere\\' the code:\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        \\n        path, d = [], defaultdict(list)\\n        for a,b in tickets: insort(d[a], b)      # build the graph; insort to return lex-smallest route\\n        \\n        def dfs(loc):                            # check for a path including each flight\\n            while d[loc]: dfs(d[loc].pop(0))     # pop off the flight\\n            path.append(loc)\\n            \\n        dfs(\"JFK\")\\n        return path[::-1]                        # Reverse the path after recursion\\n```\\n[https://leetcode.com/submissions/detail/821202317/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2) and space complexity is *O*(*N*), in which *N* ~ `len(tickets)`.",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\ntickets = [[JFK,SFO],[JFK,ATL],[SFO,ATL],[ATL,JFK],[ATL,SFO]]\\n\\n           d = {JFK:[ATL,SFO], ATL:[JFK,SFO], SFO:[ATL]}\\n\\n                               ________ JFK __\\n                             /          ^     \\\\\\n             ______________ ATL __            SFO \\n            /                ^    \\\\\\n          JFK ________            SFO \\n           ^          \\\\\\n                   __ SFO \\n                  /    ^\\n              ATL __ \\n                ^     \\\\\\n                     SFO \\n                      ^        \\n#                   ```\n```\\nHere\\' the code:\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 709703,
                "title": "euler-path-hierholzer-s-algorithm-c",
                "content": "The problem is an example of euler path finding since we need to traverse each edge exactly once in the graph created lexicographically and since it is always guaranteed that a solution exists then Hierholzer\\'s algorithm will work. \\n\\n**Edit:** The time complexity here is O(E logE) since we require sorting the lists. A better approach would be to use heaps instead of lists and even then pushing each element one by one would require O(E logE) thus Instead we can create a heap for the individual lists using make_heap (STL) function which should reduce the time complexity to O(E).\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(string src,unordered_map<string,vector<string>>& m,vector<string>& ans){\\n        while(!m[src].empty()){\\n            string s=m[src].back();\\n            m[src].pop_back();\\n            dfs(s,m,ans);\\n        }\\n        ans.push_back(src);\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string,vector<string>> m;\\n\\t\\t// Create Graph\\n        for(auto i:tickets)\\n            m[i[0]].push_back(i[1]);\\n\\t\\t// Sorting in descending order since we will be popping elements from the end\\n        for(auto &i:m)\\n            sort(i.second.begin(),i.second.end(),greater<string>());  \\n\\n        vector<string> ans;\\n        dfs(\"JFK\",m,ans);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(string src,unordered_map<string,vector<string>>& m,vector<string>& ans){\\n        while(!m[src].empty()){\\n            string s=m[src].back();\\n            m[src].pop_back();\\n            dfs(s,m,ans);\\n        }\\n        ans.push_back(src);\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string,vector<string>> m;\\n\\t\\t// Create Graph\\n        for(auto i:tickets)\\n            m[i[0]].push_back(i[1]);\\n\\t\\t// Sorting in descending order since we will be popping elements from the end\\n        for(auto &i:m)\\n            sort(i.second.begin(),i.second.end(),greater<string>());  \\n\\n        vector<string> ans;\\n        dfs(\"JFK\",m,ans);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709699,
                "title": "python-by-dfs-and-stack-w-visualization",
                "content": "Python by DFS and stack\\n\\n---\\n\\n**Hint and abstract model**:\\n\\nThink of **DFS**, and **graph traversal** with **all edges visited exactly once**\\n\\nUse a **dictionary** with list to maintain **fly map**(i.e., **source -> destination relationship** )\\n\\n**Airport** <-> **Node**\\n\\n**Airline ticket** <-> **Edge**\\n\\n**From** airport <-> **source node** of Edge\\n\\n**To** airport <-> **destination node** of Edge\\n\\n**Itinerary begin with JFK** <-> Start **DFS from JFK**, under lexical order, with **all edges visited exactly once**.\\n\\nDuring DFS, once current airport has no available flight anymore, add current airport into traversal stack.\\n\\nFinally, the visit order of Itinerary begin with JFK is **reversed traversal stack**.\\n\\n---\\n\\n**Visualization**:\\n\\n![image](https://assets.leetcode.com/users/images/23541f63-275f-476b-bd0e-35d82af0ca6c_1593336685.563326.png)\\n\\n\\n---\\n\\n**Implementation** by DFS and stack\\n\\n```\\n\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        \\n        \\n        # each ticket maps to one source <-> destination flight\\n        src_dest_dict = defaultdict(list)\\n        \\n        # update fly map\\n        for src, dst in tickets:    \\n            src_dest_dict[src].append(dst)\\n\\n        \\n\\t\\t# keep fly map with lexical order in minHeap\\n        for airport in src_dest_dict:\\n            heapq.heapify( src_dest_dict[airport] )\\n        \\n        # record of traversal path\\n        traverse_stack = []\\n\\n        path = [\"JFK\"]\\n\\n        def dfs(fly_map, airport):\\n\\n            while src_dest_dict[airport]:\\n                dest = heapq.heappop( src_dest_dict[airport] )\\n                dfs(fly_map, dest)\\n\\n            traverse_stack.append(airport)\\n\\n        # -------------------------------------------------------\\n        \\n        # Start traverl from JFK with all ticket used exactly once (i.e., all edges visited exactly once)\\n        dfs(fly_map=src_dest_dict, airport=\"JFK\")\\n        \\n        return [*reversed(traverse_stack)]\\n        \\n        \\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official doscs about bisect.insort( ... )](https://docs.python.org/3/library/bisect.html#bisect.insort_left)\\n\\n[2] [Python official docs about defaultdict](https://docs.python.org/3/library/collections.html?highlight=defaultdict#collections.defaultdict)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        \\n        \\n        # each ticket maps to one source <-> destination flight\\n        src_dest_dict = defaultdict(list)\\n        \\n        # update fly map\\n        for src, dst in tickets:    \\n            src_dest_dict[src].append(dst)\\n\\n        \\n\\t\\t# keep fly map with lexical order in minHeap\\n        for airport in src_dest_dict:\\n            heapq.heapify( src_dest_dict[airport] )\\n        \\n        # record of traversal path\\n        traverse_stack = []\\n\\n        path = [\"JFK\"]\\n\\n        def dfs(fly_map, airport):\\n\\n            while src_dest_dict[airport]:\\n                dest = heapq.heappop( src_dest_dict[airport] )\\n                dfs(fly_map, dest)\\n\\n            traverse_stack.append(airport)\\n\\n        # -------------------------------------------------------\\n        \\n        # Start traverl from JFK with all ticket used exactly once (i.e., all edges visited exactly once)\\n        dfs(fly_map=src_dest_dict, airport=\"JFK\")\\n        \\n        return [*reversed(traverse_stack)]\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 624915,
                "title": "c-solution-dfs",
                "content": "```\\nclass Solution {\\n    unordered_map<string, priority_queue<string, vector<string>, greater<string>>>hm;\\n    \\n    void dfs(string v, vector<string>& res) {\\n        \\n        while (hm[v].size() != 0) {\\n            string p = hm[v].top();\\n            hm[v].pop();\\n            dfs(p, res);\\n        }\\n        \\n        res.push_back(v);\\n    }\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        \\n        for (int i = 0; i < tickets.size(); i++) {\\n            hm[tickets[i][0]].push(tickets[i][1]);\\n        }\\n        \\n        vector<string>res;\\n        dfs(\"JFK\", res);\\n        reverse(res.begin(), res.end());\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    unordered_map<string, priority_queue<string, vector<string>, greater<string>>>hm;\\n    \\n    void dfs(string v, vector<string>& res) {\\n        \\n        while (hm[v].size() != 0) {\\n            string p = hm[v].top();\\n            hm[v].pop();\\n            dfs(p, res);\\n        }\\n        \\n        res.push_back(v);\\n    }\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        \\n        for (int i = 0; i < tickets.size(); i++) {\\n            hm[tickets[i][0]].push(tickets[i][1]);\\n        }\\n        \\n        vector<string>res;\\n        dfs(\"JFK\", res);\\n        reverse(res.begin(), res.end());\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 256161,
                "title": "c-94-solution-o-e-time-with-explanation",
                "content": "**Idea**\\n\\nThe idea behind this solution is based on Hierholzer\\'s algorithm (Link below). Learning how the algorithm works is left as an exercise to the reader. (It is very intuitive). \\n\\nhttps://www.geeksforgeeks.org/hierholzers-algorithm-directed-graph/\\n\\nThe algorithm is designed to find an eulerian path, assuming the graph is eulerian. An eulerian path is basically a path that starts on some node and traverses across all the edges exactly once. It requires that the graph is eulerian, which for a directed graph implies that each node has an equal number of ins and outs, or exactly two nodes has an odd degree. \\n\\nThis is very similar to what we need for this problem, which is to find a way to visit all the locations. If we look at the problem, each airport must be either a transitional stop, the start, or the final destination. This corresponds to an eulerian graph with exactly two nodes with an odd degree. We must start from the starting airport, so the start cannot be even (there must be more edges leaving than entering), and we must end at the destination (must be more edges ending than leaving). All other airports must have an even degree, because we cannot stay there (must leave the same number of times we enter). Thus, this problem can be directly reduced to finding an eulerian path from the graph made from the vector of edges.\\n\\nHowever, we are given the condition that for solutions with multiple possible paths, we need to pick the one that puts the lowest by alphabetical name airports first. Thus, we need to modify the algorithm so that when it selects an edge, it selects the edge with the lowest alphabetical name first. \\n\\n**Implementation**\\n\\nThe first thing is the representation of the graph. I opted for an unordered_map because the graph is sparse. Each unordered_map uses a priority queue to keep track of the edges and returns the lowest alphabetical edge. \\n\\nFor the implementation of the algorithm, I opted to insert the elements into the current list by reverse, because if they were inserted normally I would have to start moving and deleting by reverse, and I was not able to find a good method to do that. Inserting in reverse allows me to delete and move using normal iterators, which can be done using normal erase operation.\\n\\n\\n**Runtime**\\n\\nThe run time of this algorithm is the same as that for Hierholzer\\'s algorithm, which is O(E), where E is the number of edges. In this case that would be linear to the input edge vector.\\n\\n\\n```\\nstruct cmp {\\n\\t  bool operator()(const string &lhs, const string &rhs) {\\n\\t\\treturn lhs > rhs;\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    static void dfs(unordered_map<string, priority_queue<string, vector<string>, cmp>>& edges, string start, list<string>& cur) {\\n        auto it = edges.find(start);\\n        while(it != edges.end()) {\\n            string next = it->second.top(); it->second.pop();\\n            if(it->second.empty()) edges.erase(it);\\n            cur.push_front(next);\\n            it = edges.find(next);\\n        }\\n    }\\n\\n    const vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n\\t\\n        unordered_map<string, priority_queue<string, vector<string>, cmp>> edges;\\n        for(auto &edge: tickets) edges[edge.first].push(edge.second);\\n        if(edges.empty()) return {};\\n\\n        list<string> cur{\"JFK\"}, overall;\\n        string next = \"JFK\";\\n        while(!cur.empty()) {\\n            dfs(edges, next, cur);\\n            auto it = cur.begin();\\n            while(it != cur.end() && edges.find(*it) == edges.end()) {\\n                overall.push_front(*it);\\n                cur.erase(it++);\\n            }\\n            if(!cur.empty()) next = *it;\\n        }\\n        return vector<string>(overall.begin(), overall.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct cmp {\\n\\t  bool operator()(const string &lhs, const string &rhs) {\\n\\t\\treturn lhs > rhs;\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    static void dfs(unordered_map<string, priority_queue<string, vector<string>, cmp>>& edges, string start, list<string>& cur) {\\n        auto it = edges.find(start);\\n        while(it != edges.end()) {\\n            string next = it->second.top(); it->second.pop();\\n            if(it->second.empty()) edges.erase(it);\\n            cur.push_front(next);\\n            it = edges.find(next);\\n        }\\n    }\\n\\n    const vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n\\t\\n        unordered_map<string, priority_queue<string, vector<string>, cmp>> edges;\\n        for(auto &edge: tickets) edges[edge.first].push(edge.second);\\n        if(edges.empty()) return {};\\n\\n        list<string> cur{\"JFK\"}, overall;\\n        string next = \"JFK\";\\n        while(!cur.empty()) {\\n            dfs(edges, next, cur);\\n            auto it = cur.begin();\\n            while(it != cur.end() && edges.find(*it) == edges.end()) {\\n                overall.push_front(*it);\\n                cur.erase(it++);\\n            }\\n            if(!cur.empty()) next = *it;\\n        }\\n        return vector<string>(overall.begin(), overall.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772331,
                "title": "c-dfs-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    bool dfs(unordered_map<string,vector<string>>& m, vector<string>& res, string s, int n) {\\n        if(res.size() == n+1) return true;\\n        if(m[s].size() == 0) return false;\\n\\n        for(int i = 0; i < m[s].size(); i++) {\\n            string temp = m[s][i];\\n            res.push_back(temp);\\n            m[s].erase(m[s].begin() + i);\\n            bool x = dfs(m, res, temp, n);\\n\\n            if(x) return true;\\n            m[s].insert(m[s].begin()+i, temp);\\n            res.pop_back();\\n        }\\n        return false;\\n    }\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        int n = tickets.size();\\n        sort(tickets.begin(), tickets.end());\\n        unordered_map<string,vector<string>> m;\\n\\n        for(int i = 0; i < n; i++) {\\n            m[tickets[i][0]].push_back(tickets[i][1]);\\n        }\\n\\n        vector<string> res;\\n        res.push_back(\"JFK\");\\n        bool x = dfs(m, res, \"JFK\", n);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool dfs(unordered_map<string,vector<string>>& m, vector<string>& res, string s, int n) {\\n        if(res.size() == n+1) return true;\\n        if(m[s].size() == 0) return false;\\n\\n        for(int i = 0; i < m[s].size(); i++) {\\n            string temp = m[s][i];\\n            res.push_back(temp);\\n            m[s].erase(m[s].begin() + i);\\n            bool x = dfs(m, res, temp, n);\\n\\n            if(x) return true;\\n            m[s].insert(m[s].begin()+i, temp);\\n            res.pop_back();\\n        }\\n        return false;\\n    }\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        int n = tickets.size();\\n        sort(tickets.begin(), tickets.end());\\n        unordered_map<string,vector<string>> m;\\n\\n        for(int i = 0; i < n; i++) {\\n            m[tickets[i][0]].push_back(tickets[i][1]);\\n        }\\n\\n        vector<string> res;\\n        res.push_back(\"JFK\");\\n        bool x = dfs(m, res, \"JFK\", n);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219170,
                "title": "c-euler-path-dfs-comments",
                "content": "20 ms ,14 MB\\ncopied from \\nhttps://leetcode.com/problems/reconstruct-itinerary/discuss/897615/C%2B%2B-DFS-Euler-Walk-O(E-Log-E)-Solution\\n\\n```\\n// comparator for sorting tickets based on destination\\nbool comparator(const vector<string>&a,const vector<string>&b)\\n{\\n    return a[1]<b[1];        \\n}\\n\\nclass Solution {\\npublic:\\n\\n    // itenary list\\n    vector<string>result;\\n    \\n    void dfs(string node, map<string,queue<string>>&graph)\\n    {\\n        // process node\\'s edges \\n        if(graph.count(node))\\n        {\\n            // If node has any edge call DFS with the edge destination node\\n            // also remove the edge as we will not visit the edge again (Euler walk)\\n            while(!graph[node].empty())\\n            {\\n                string child = graph[node].front();\\n                graph[node].pop();\\n                dfs(child,graph);\\n            }  \\n        }\\n        \\n        // push node in to result when all its edges are processed\\n        result.push_back(node);        \\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        \\n        // sort tickets based on destination to get lexical smaller desitantion edge first\\n        sort(tickets.begin(),tickets.end(),comparator);\\n        \\n        // graph adjacency list\\n        map<string,queue<string>>graph;\\n\\n        // populate graph adjacency list\\n        for(int i=0;i<tickets.size();i++)      \\n            graph[tickets[i][0]].push(tickets[i][1]);\\n        \\n        // run DFS starting from JFK\\n        dfs(\"JFK\",graph);\\n        \\n        // reverse result vector to get itenary list order\\n        reverse(result.begin(),result.end());\\n        \\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    // itenary list\\n    vector<string>result;\\n    \\n    void dfs(string node, map<string,queue<string>>&graph)\\n    {\\n        // process node\\'s edges \\n        if(graph.count(node))\\n        {\\n            // If node has any edge call DFS with the edge destination node\\n            // also remove the edge as we will not visit the edge again (Euler walk)\\n            while(!graph[node].empty())\\n            {\\n                string child = graph[node].front();\\n                graph[node].pop();\\n                dfs(child,graph);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 989535,
                "title": "simple-python-solutions-dfs-solution-and-iterative-solution-with-stack",
                "content": "#DFS\\n\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n\\t\\n        def _visit(stop):\\n            while flights[stop]:\\n                _visit(flights[stop].pop())\\n            result.append(stop)\\n\\t\\t\\t\\n        flights = defaultdict(list)\\n        for fr, to in sorted(tickets, reverse=True):\\n            flights[fr].append(to)\\n        result = []\\n        _visit(\"JFK\")\\n        return result[::-1]\\n\\t\\t\\n#Iterative with stack\\n\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        flights = defaultdict(list)\\n        for t in sorted(tickets, reverse=True):\\n            flights[t[0]].append(t[1])\\n\\n        stack, result = [], []\\n        stop = \"JFK\"\\n        while stop:\\n            if not flights[stop]:\\n                result.append(stop)\\n                stop = None if not stack else stack.pop()\\n            else:\\n                stack.append(stop)\\n                stop = flights[stop].pop()\\n        return result[::-1]",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "#DFS\\n\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n\\t\\n        def _visit(stop):\\n            while flights[stop]:\\n                _visit(flights[stop].pop())\\n            result.append(stop)\\n\\t\\t\\t\\n        flights = defaultdict(list)\\n        for fr, to in sorted(tickets, reverse=True):\\n            flights[fr].append(to)\\n        result = []\\n        _visit(\"JFK\")\\n        return result[::-1]\\n\\t\\t\\n#Iterative with stack\\n\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        flights = defaultdict(list)\\n        for t in sorted(tickets, reverse=True):\\n            flights[t[0]].append(t[1])\\n\\n        stack, result = [], []\\n        stop = \"JFK\"\\n        while stop:\\n            if not flights[stop]:\\n                result.append(stop)\\n                stop = None if not stack else stack.pop()\\n            else:\\n                stack.append(stop)\\n                stop = flights[stop].pop()\\n        return result[::-1]",
                "codeTag": "Python3"
            },
            {
                "id": 645501,
                "title": "simple-and-clean-c-solution-with-comments",
                "content": "```cpp\\nusing graph = unordered_map<string, priority_queue<string, vector<string>, greater<>>>;\\n\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        graph flights;\\n        for (const auto& ticket : tickets) {\\n            // build the graph. note there we\\'re using\\n            // a min heap so the destinations will be\\n            // sorted in lexicographical order\\n            flights[ticket[0]].emplace(ticket[1]);\\n        }\\n        vector<string> itinerary;\\n        buildItinerary(\"JFK\", &flights, &itinerary);\\n        reverse(itinerary.begin(), itinerary.end());\\n        return itinerary;\\n    }\\nprivate:\\n    \\n    void buildItinerary(const string& airport, graph* flights_ptr, vector<string>* itinerary_ptr) {\\n        auto& flights = *flights_ptr;\\n\\t\\t// the point that we got stuck would be the last airport that we visit\\n        while (!empty(flights[airport])) {\\n            auto destination = flights[airport].top();\\n            flights[airport].pop();\\n            buildItinerary(destination, flights_ptr, itinerary_ptr);\\n        }\\n        itinerary_ptr->emplace_back(airport);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nusing graph = unordered_map<string, priority_queue<string, vector<string>, greater<>>>;\\n\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        graph flights;\\n        for (const auto& ticket : tickets) {\\n            // build the graph. note there we\\'re using\\n            // a min heap so the destinations will be\\n            // sorted in lexicographical order\\n            flights[ticket[0]].emplace(ticket[1]);\\n        }\\n        vector<string> itinerary;\\n        buildItinerary(\"JFK\", &flights, &itinerary);\\n        reverse(itinerary.begin(), itinerary.end());\\n        return itinerary;\\n    }\\nprivate:\\n    \\n    void buildItinerary(const string& airport, graph* flights_ptr, vector<string>* itinerary_ptr) {\\n        auto& flights = *flights_ptr;\\n\\t\\t// the point that we got stuck would be the last airport that we visit\\n        while (!empty(flights[airport])) {\\n            auto destination = flights[airport].top();\\n            flights[airport].pop();\\n            buildItinerary(destination, flights_ptr, itinerary_ptr);\\n        }\\n        itinerary_ptr->emplace_back(airport);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509936,
                "title": "c-solution-find-the-eulerian-path",
                "content": "Each ticket is essentially a directed edge in our graph of airports.\\nTo reconstruct the person\\'s itinerary, we need to ensure that our path through the airports passes through all of these edges (takes all of the flights represented by tickets).\\nThis is essentially trying to find an Eulerian path in the graph, which can be solved using Hierholzer\\'s algorithm.\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<string, vector<string>> graph;\\n    unordered_map<string, int> outgoing;\\n    \\n    void hierholzer(const string& curr, vector<string>& itinerary) {\\n        while (outgoing[curr] > 0) {\\n            hierholzer(graph[curr][--outgoing[curr]], itinerary);\\n        }\\n        \\n        itinerary.push_back(curr);\\n    }\\n    \\npublic:\\n    vector<string> findItinerary(const vector<vector<string>>& tickets) {\\n        for (const auto& ticket : tickets) {\\n            graph[ticket[0]].push_back(ticket[1]);\\n            ++outgoing[ticket[0]];\\n        }\\n        \\n        // Ensure smallest lexical eulerian path is found\\n        for (auto& kv : graph) {\\n            sort(kv.second.begin(), kv.second.end(), greater<string>());\\n        }\\n        \\n        vector<string> itinerary;\\n        hierholzer(\"JFK\", itinerary);\\n        \\n        reverse(itinerary.begin(), itinerary.end());\\n        \\n        return itinerary;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_map<string, vector<string>> graph;\\n    unordered_map<string, int> outgoing;\\n    \\n    void hierholzer(const string& curr, vector<string>& itinerary) {\\n        while (outgoing[curr] > 0) {\\n            hierholzer(graph[curr][--outgoing[curr]], itinerary);\\n        }\\n        \\n        itinerary.push_back(curr);\\n    }\\n    \\npublic:\\n    vector<string> findItinerary(const vector<vector<string>>& tickets) {\\n        for (const auto& ticket : tickets) {\\n            graph[ticket[0]].push_back(ticket[1]);\\n            ++outgoing[ticket[0]];\\n        }\\n        \\n        // Ensure smallest lexical eulerian path is found\\n        for (auto& kv : graph) {\\n            sort(kv.second.begin(), kv.second.end(), greater<string>());\\n        }\\n        \\n        vector<string> itinerary;\\n        hierholzer(\"JFK\", itinerary);\\n        \\n        reverse(itinerary.begin(), itinerary.end());\\n        \\n        return itinerary;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446479,
                "title": "javascript-topological-sorting",
                "content": "```\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n  const graph =  buildGraph(tickets);\\n  const ans = [];\\n  \\n  topoSorting(\"JFK\", graph, ans)\\n     \\n  return ans.reverse();\\n};\\n\\nconst topoSorting = (airport, graph, ans) => {  \\n  let stops =  graph[airport];\\n  \\n  while (stops.length) {\\n    topoSorting(stops.shift(), graph, ans);\\n  }\\n  \\n  ans.push(airport);\\n}\\n\\n\\nconst buildGraph = (tickets) => {\\n  const graph = {};\\n  \\n  tickets.forEach((it) => { \\n    graph[it[0]] = graph[it[0]] || [];\\n    graph[it[1]] = graph[it[1]] || [];\\n    \\n    graph[it[0]].push(it[1]);         \\n  });\\n  \\n  for (let key of Object.keys(graph)) {\\n    graph[key].sort();\\n  }\\n\\n  return graph;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n  const graph =  buildGraph(tickets);\\n  const ans = [];\\n  \\n  topoSorting(\"JFK\", graph, ans)\\n     \\n  return ans.reverse();\\n};\\n\\nconst topoSorting = (airport, graph, ans) => {  \\n  let stops =  graph[airport];\\n  \\n  while (stops.length) {\\n    topoSorting(stops.shift(), graph, ans);\\n  }\\n  \\n  ans.push(airport);\\n}\\n\\n\\nconst buildGraph = (tickets) => {\\n  const graph = {};\\n  \\n  tickets.forEach((it) => { \\n    graph[it[0]] = graph[it[0]] || [];\\n    graph[it[1]] = graph[it[1]] || [];\\n    \\n    graph[it[0]].push(it[1]);         \\n  });\\n  \\n  for (let key of Object.keys(graph)) {\\n    graph[key].sort();\\n  }\\n\\n  return graph;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252980,
                "title": "python-dfs-with-comments",
                "content": "```\\nclass Solution(object):\\n    def __init__(self):\\n        self.valid_length = -1\\n        \\n    def buildMap(self, tickets):\\n        # first lets put everything into a dict for easy lookup\\n        # format is start as key and [ends] as value\\n        ticket_map = {}\\n        for ticket in tickets:\\n            #print(ticket)\\n            start = ticket[0]\\n            dest = ticket[1]\\n            if not start in ticket_map:\\n                ticket_map[start] = [dest]\\n            else:\\n                ticket_map[start].append(dest)\\n                \\n        self.valid_length = len(tickets) + 1\\n        return ticket_map\\n        \\n    def findItinerary(self, tickets):\\n        \\n        if tickets == None or len(tickets) == 0:\\n            return None\\n        \\n        # First make an adjacency map out of the tickets\\n        ticket_map = self.buildMap(tickets)\\n        #print(ticket_map)\\n        \\n        # Add the root and start the DFS\\n        route = [\\'JFK\\']\\n        self.dfs(\\'JFK\\', route, ticket_map)\\n        \\n        return route\\n        \\n    def dfs(self, node, route, ticket_map):\\n        \\n        if node in ticket_map and len(ticket_map[node]) > 0:\\n            # Sort them so we\\'ll pick the first lexographic path if there are several results\\n            children = sorted(ticket_map[node])\\n\\n            for child in children:\\n                route.append(child)                \\n                \\n                # first remove this path from the map\\n                ticket_map[node].remove(child)\\n                # Now go down to the next level\\n                result = self.dfs(child, route, ticket_map)\\n                \\n                # See if the DFS on that child produced a valid result, if so return it\\n                if len(result) == self.valid_length:\\n                    return result\\n                \\n                # The DFS did not produce the result, so undo the changes and try the next child\\n                else:\\n                    del route[-1]\\n                    ticket_map[node].append(child)\\n            \\n        return route\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def __init__(self):\\n        self.valid_length = -1\\n        \\n    def buildMap(self, tickets):\\n        # first lets put everything into a dict for easy lookup\\n        # format is start as key and [ends] as value\\n        ticket_map = {}\\n        for ticket in tickets:\\n            #print(ticket)\\n            start = ticket[0]\\n            dest = ticket[1]\\n            if not start in ticket_map:\\n                ticket_map[start] = [dest]\\n            else:\\n                ticket_map[start].append(dest)\\n                \\n        self.valid_length = len(tickets) + 1\\n        return ticket_map\\n        \\n    def findItinerary(self, tickets):\\n        \\n        if tickets == None or len(tickets) == 0:\\n            return None\\n        \\n        # First make an adjacency map out of the tickets\\n        ticket_map = self.buildMap(tickets)\\n        #print(ticket_map)\\n        \\n        # Add the root and start the DFS\\n        route = [\\'JFK\\']\\n        self.dfs(\\'JFK\\', route, ticket_map)\\n        \\n        return route\\n        \\n    def dfs(self, node, route, ticket_map):\\n        \\n        if node in ticket_map and len(ticket_map[node]) > 0:\\n            # Sort them so we\\'ll pick the first lexographic path if there are several results\\n            children = sorted(ticket_map[node])\\n\\n            for child in children:\\n                route.append(child)                \\n                \\n                # first remove this path from the map\\n                ticket_map[node].remove(child)\\n                # Now go down to the next level\\n                result = self.dfs(child, route, ticket_map)\\n                \\n                # See if the DFS on that child produced a valid result, if so return it\\n                if len(result) == self.valid_length:\\n                    return result\\n                \\n                # The DFS did not produce the result, so undo the changes and try the next child\\n                else:\\n                    del route[-1]\\n                    ticket_map[node].append(child)\\n            \\n        return route\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186273,
                "title": "python3-eulerian-path",
                "content": "``` python\\nclass Solution:\\n    def findItinerary(self, tickets):\\n        \"\"\"\\n        :type tickets: List[List[str]]\\n        :rtype: List[str]\\n        \"\"\"\\n        G = collections.defaultdict(list)\\n        for u, v in tickets: G[u].append(v)\\n        for u in G: G[u].sort()        \\n        \\n        route = []\\n        def dfs(at):\\n            while G[at]:\\n                to = G[at].pop(0)\\n                dfs(to)\\n            route.append(at)\\n\\n        dfs(\"JFK\")\\n        return route[::-1]\\n```",
                "solutionTags": [],
                "code": "``` python\\nclass Solution:\\n    def findItinerary(self, tickets):\\n        \"\"\"\\n        :type tickets: List[List[str]]\\n        :rtype: List[str]\\n        \"\"\"\\n        G = collections.defaultdict(list)\\n        for u, v in tickets: G[u].append(v)\\n        for u in G: G[u].sort()        \\n        \\n        route = []\\n        def dfs(at):\\n            while G[at]:\\n                to = G[at].pop(0)\\n                dfs(to)\\n            route.append(at)\\n\\n        dfs(\"JFK\")\\n        return route[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78771,
                "title": "c-min-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n        unordered_map<string, priority_queue<string, vector<string>, greater<string>>>m;\\n        vector<string>res;\\n        for(auto x: tickets) m[x.first].push(x.second);\\n        DFS(\"JFK\", res, m);\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    \\n    void DFS(string cur, vector<string>& res, unordered_map<string, priority_queue<string, vector<string>, greater<string>>>& m){\\n        while(!m[cur].empty()){\\n            string s = m[cur].top();\\n            m[cur].pop();\\n            DFS(s, res, m);\\n        }\\n        res.push_back(cur);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n        unordered_map<string, priority_queue<string, vector<string>, greater<string>>>m;\\n        vector<string>res;\\n        for(auto x: tickets) m[x.first].push(x.second);\\n        DFS(\"JFK\", res, m);\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    \\n    void DFS(string cur, vector<string>& res, unordered_map<string, priority_queue<string, vector<string>, greater<string>>>& m){\\n        while(!m[cur].empty()){\\n            string s = m[cur].top();\\n            m[cur].pop();\\n            DFS(s, res, m);\\n        }\\n        res.push_back(cur);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78791,
                "title": "c-iterative-version-with-detail-comments",
                "content": "this solution will be shorter if C# has built-in priority queue library.....\\n\\nInspired by @StefanPochmann approach, basically it's his idea in C# verison. \\n\\nIt works well and can handle test cases that contains invalid itineraries. Like [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"]] .\\n\\nTime: Assume we have N itineraries, each itinerary has two string=> 2N strings. \\n\\n1. we build hashtable for all itineraries. O(N) time\\n2. we sort values string for each key. O(N* NlogN) time\\n3. we backtracking to find the next city we want, until all city has added. Since we use hashtable in the searching so it's O(N).\\n4.Convert out result linkedlist to a list, not sure if it's O(N) or O(1) in C# but can never greater than O(N).\\n\\nAdding together it\\u2019s O(N*logN) time.\\n\\nSpace: we use a hash table and a stack, so it's O(2N)=>O(N) space\\n\\n```\\n           public IList<string> FindItinerary(string[,] tickets)\\n            {\\n                LinkedList<string> res= new LinkedList<string>();\\n                //invalid input\\n                if (tickets == null || tickets.Length == 0) return res.ToList();\\n                //Build a hashtable/dict for route. \\n                //key is the source city, value are all the destination city from source city.\\n                var routeDict = new Dictionary<string, List<string>>();\\n                \\n                int count = tickets.GetLength(0);   //tickets number\\n                for (int i = 0; i < count; i++)\\n                {\\n                    var source = tickets[i, 0];\\n                    var dest = tickets[i, 1];\\n\\n                    if(!routeDict.ContainsKey(source))\\n                        routeDict.Add(source, new List<string>());\\n\\n                    routeDict[source].Add(dest);\\n                }\\n                //keep asce order \\n                foreach (var list in routeDict.Values)  list.Sort();\\n\\n                //need a stack as like a backtracking route from final.\\n                Stack<string> stack = new Stack<string>();\\n                stack.Push(\"JFK\");    //Add start city\\n                while (stack.Any())\\n                {\\n                    while (routeDict.ContainsKey(stack.Peek()) && routeDict[stack.Peek()].Any())\\n                    {\\n                        var next = routeDict[stack.Peek()].First();  //the next city from the source city in lexical order\\n                        routeDict[stack.Peek()].RemoveAt(0);         //remove the next city from the hash table.(since List<T> doesn't has Poll/Pop/Dequeue)\\n                        stack.Push(next);                            //push next city into the stack\\n                    }\\n                    res.AddFirst(stack.Pop());                      //Pop all the city from stack, Add them in the head of res.\\n                }\\n                return res.ToList();\\n            }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n           public IList<string> FindItinerary(string[,] tickets)\\n            {\\n                LinkedList<string> res= new LinkedList<string>();\\n                //invalid input\\n                if (tickets == null || tickets.Length == 0) return res.ToList();\\n                //Build a hashtable/dict for route. \\n                //key is the source city, value are all the destination city from source city.\\n                var routeDict = new Dictionary<string, List<string>>();\\n                \\n                int count = tickets.GetLength(0);   //tickets number\\n                for (int i = 0; i < count; i++)\\n                {\\n                    var source = tickets[i, 0];\\n                    var dest = tickets[i, 1];\\n\\n                    if(!routeDict.ContainsKey(source))\\n                        routeDict.Add(source, new List<string>());\\n\\n                    routeDict[source].Add(dest);\\n                }\\n                //keep asce order \\n                foreach (var list in routeDict.Values)  list.Sort();\\n\\n                //need a stack as like a backtracking route from final.\\n                Stack<string> stack = new Stack<string>();\\n                stack.Push(\"JFK\");    //Add start city\\n                while (stack.Any())\\n                {\\n                    while (routeDict.ContainsKey(stack.Peek()) && routeDict[stack.Peek()].Any())\\n                    {\\n                        var next = routeDict[stack.Peek()].First();  //the next city from the source city in lexical order\\n                        routeDict[stack.Peek()].RemoveAt(0);         //remove the next city from the hash table.(since List<T> doesn't has Poll/Pop/Dequeue)\\n                        stack.Push(next);                            //push next city into the stack\\n                    }\\n                    res.AddFirst(stack.Pop());                      //Pop all the city from stack, Add them in the head of res.\\n                }\\n                return res.ToList();\\n            }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 78811,
                "title": "sharing-my-44ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n            unordered_map<string, multiset<string>> myGraph;\\n            int i, n = tickets.size();\\n            string first, second;\\n            for(i=0; i<n; i++)\\n            {\\n                first  = tickets[i].first;\\n                second = tickets[i].second;\\n                myGraph[first].insert(second);\\n            }\\n            \\n            vector<string> marching;\\n            vector<string> itinerary;\\n            marching.push_back(\"JFK\");\\n            \\n            while(marching.size()>0)\\n            {\\n                string from = marching.back();\\n                if(myGraph.count(from)>0 && myGraph[from].size()>0)\\n                {\\n                    multiset<string>& to = myGraph[from];\\n                    marching.push_back(*to.begin());\\n                    to.erase(to.begin());\\n                }\\n                else\\n                {\\n                    itinerary.push_back(from);\\n                    marching.pop_back();\\n                }\\n            }\\n            \\n            reverse(itinerary.begin(), itinerary.end());\\n            return itinerary;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n            unordered_map<string, multiset<string>> myGraph;\\n            int i, n = tickets.size();\\n            string first, second;\\n            for(i=0; i<n; i++)\\n            {\\n                first  = tickets[i].first;\\n                second = tickets[i].second;\\n                myGraph[first].insert(second);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3244732,
                "title": "332-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe first create a heap for each source vertex, containing the destinations in lexicographical order. Then, during the DFS traversal, we pop the smallest destination from the heap instead of sorting the destinations each time. This small optimization reduces the time complexity of sorting destinations from O(NlogN) to O(NlogM), where N is the total number of tickets and M is the average number of destinations per source vertex.\\n\\n# Complexity\\n- Time complexity:\\n61.24%\\n\\n- Space complexity:\\n83.91%\\n\\n# Code\\n```\\nimport collections\\nimport heapq\\n\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        ans = []\\n        graph = collections.defaultdict(list)\\n\\n        for a, b in tickets:\\n            graph[a].append(b)\\n\\n        for u in graph:\\n            heapq.heapify(graph[u])\\n\\n        def dfs(u: str) -> None:\\n            while u in graph and graph[u]:\\n                dfs(heapq.heappop(graph[u]))\\n            ans.append(u)\\n\\n        dfs(\\'JFK\\')\\n        return ans[::-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph",
                    "Eulerian Circuit"
                ],
                "code": "```\\nimport collections\\nimport heapq\\n\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        ans = []\\n        graph = collections.defaultdict(list)\\n\\n        for a, b in tickets:\\n            graph[a].append(b)\\n\\n        for u in graph:\\n            heapq.heapify(graph[u])\\n\\n        def dfs(u: str) -> None:\\n            while u in graph and graph[u]:\\n                dfs(heapq.heappop(graph[u]))\\n            ans.append(u)\\n\\n        dfs(\\'JFK\\')\\n        return ans[::-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188293,
                "title": "c-easiest-explanation-ever-guaranteed-beginner-friendly-detailed-iterative-dfs",
                "content": "**CONCEPT:** The idea here is to use DFS and Eulerian Paths concept to solve the problem. Why? Because in the question, we\\'re basically asked to visit all the nodes in a graph only once even when there\\'s a cycle in the graph.\\n\\nSo the question boils down to visiting each node once (printing them) and all nodes must be visited.\\n\\n**OBSERVATIONS:** Here, we\\'re asked to generate a path such that we only traverse in lexical order (remember that priority_queue and set can be used for this, they store things in sorted order) and no edge should be traversed more than once (just like the condition for semi-eulerian paths).\\n\\nBut now you\\'ll ask, how can we not traverse an edge more than once? Aren\\'t we having an undirected graph? And you\\'ll be right but remember, an undirected graph is just a directed graph with an edge from source to target and target to source.\\n\\nSo, it\\'s obvious that we\\'re going to start from the node called \"JFK\" (as asked in the question). Then we\\'re going to choose a node that is a neighbor of/adjacent to the node \"JFK\". We\\'re treating airports as nodes here. When we choose a neighbor of JFK, we\\'ll choose the one that\\'s on top in lexical ordering. Then we\\'ll go to that node and find the top lexical ordering neighbor of that node. So all we\\'re doing is hopping from one node to its neighbor and then to that neighbor\\'s neighbor and so on.\\n\\n**SOLUTION:** We can use simple iterative DFS for this. In DFS, we pick a node, take its neighbor, then go there, then find that neighbor\\'s neighbor and go there and just like that, we\\'ll have a solved problem.\\n\\nSo first, we know that we don\\'t have integers as nodes here, we have strings. So we cannot really use a vector to identify nodes with an index. So we can use a map, specifically unordered_map since we don\\'t need to sort these nodes (only their neighbors). So the map will take a node (string) and have a multiset ready for it as its neighbors (multiset because there can be duplicate nodes).\\n\\nNow we\\'ll fill the neighbors according to what we\\'re given. Loop through all the tickets and extract the source and target node first, then set the target node as a neighbor of source node in the map.\\n\\nNext, ready an empty stack. This stack is used for iterative DFS, we\\'re following the standard process of DFS algorithm. Now we know we have to start with the node \"JFK\" so we push it into the stack (starting point of DFS). Also create an ans vector, we\\'ll return this as our answer.\\n\\nStart the DFS, while stack is not empty, run a loop.\\nTake the top of the stack, this is our current node.\\nNow, if current node has no neighbors, meaning that the map value (multiset) of current node has size equal to 0, we will stop the DFS by pushing the current node into the ans and popping the stack\\'s top.\\n\\nIf current node has neighbors, we\\'ll first select the top neighbor that\\'s supposedly already in the lexical order, and push it into the stack (meaning that we\\'ll visit it next). Since we\\'re visiting this neighbor, eulerian path requires us to never visit this edge again, so we\\'ll remove neighbor from current node\\'s neighbors list.\\n\\nDuring this process, we\\'ll be picking a node, traverse its first neighbor (top of lexical ordering), delete this edge (remove this neighbor from neighbors list) and repeat these 3 steps until we arrive at a node that has no more neighbors. Once we find a node with no neighbors, we add this node in our answer vector and return to its parent, if the parent again has no more neighbors, we add the parent in our answer vector and this process goes on and on till no more nodes are left in the DFS stack.\\n\\nDuring this process, note that whatever path we were taking, we were pushing the last node before its parent, which means our answer vector will contain the correct path but in reverse order. This is a thing to remember about DFS, we traverse the nodes in reverse order when returning.\\n\\nSo, that\\'s all, just reverse the answer vector and return it. Problem solved :)\\nCode with comments: https://leetcode.com/submissions/detail/736548077/\\n\\nHere\\'s the code, I hope you liked the explanation :)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, multiset<string>> neighbors;\\n        \\n        for(auto ticket: tickets){\\n            string node1 = ticket[0];\\n            string node2 = ticket[1];\\n            \\n            neighbors[node1].insert(node2);\\n        }\\n        \\n        stack<string> q;\\n        q.push(\"JFK\");\\n        \\n        vector<string> ans;\\n        while(!q.empty()){\\n            string curr = q.top();\\n            \\n            if(neighbors[curr].size() == 0){\\n                ans.push_back(curr);\\n                q.pop();\\n            } else {\\n                auto neighborPointer = neighbors[curr].begin();\\n                q.push(*neighborPointer);\\n                neighbors[curr].erase(neighborPointer);\\n            }\\n        }\\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, multiset<string>> neighbors;\\n        \\n        for(auto ticket: tickets){\\n            string node1 = ticket[0];\\n            string node2 = ticket[1];\\n            \\n            neighbors[node1].insert(node2);\\n        }\\n        \\n        stack<string> q;\\n        q.push(\"JFK\");\\n        \\n        vector<string> ans;\\n        while(!q.empty()){\\n            string curr = q.top();\\n            \\n            if(neighbors[curr].size() == 0){\\n                ans.push_back(curr);\\n                q.pop();\\n            } else {\\n                auto neighborPointer = neighbors[curr].begin();\\n                q.push(*neighborPointer);\\n                neighbors[curr].erase(neighborPointer);\\n            }\\n        }\\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032136,
                "title": "c-euler-path-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/reconstruct-itinerary/\\n    \\n    This problem is about finding the Euler path. Euler path is a path\\n    which involves traversing all the edges only once.\\n    The way the algo works is, we start with a source and start traversing the outward\\n    edges it has, each time we remove that edge so that we don\\'t process that edge even if come \\n    back to this node again. We keep traversing till we hit a node, from where we can\\'t move forward\\n    either due to all the outward edges being used already or lack of outward edges.\\n    When we hit a terminal node, we know that this is a node that should come after any remaining unvisited nodes.\\n    because we pick an edge without any core logic, we might traverse a path that skips other nodes,\\n    so when in this path we hit a roadblock we need to store that node in such a way that this comes after \\n    the nodes that are yet to traversed. \\n    So we save the node in a stack, return to the previous node. There check if there are any other edges are yet\\n    not traversed, if yes then traverse else add this node as well and return to the previous stack call.\\n    Since all the nodes are stored in a stack manner, path starts from the top element.\\n    \\n    TC: O(V + E) + O(ElogE) + O(E) // graph construction + sorting + Euler traversal\\n    SC: O(V + E)\\n*/\\nclass Solution {\\npublic:\\n    void eulerPath(string curr, \\n               unordered_map<string, deque<string>>& g,\\n               vector<string>& order) {\\n        // traverse the neighboring edges\\n        while(!g[curr].empty()) {\\n            // use the current edge, since in a euler path\\n            // each edge is used only once, remove it\\n            auto edge = g[curr].front();\\n            g[curr].pop_front();\\n            eulerPath(edge, g, order);\\n        }\\n        // add the curr node, as there is no other way from here\\n        order.emplace_back(curr);\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // create the graph, all the edges need to be sorted lexographically\\n        unordered_map<string, deque<string>> g;\\n        for(auto edge: tickets)\\n            g[edge[0]].emplace_back(edge[1]);\\n        \\n        // sort the edges lexographically\\n        for(auto [vertex, edges]: g)\\n            sort(g[vertex].begin(), g[vertex].end());\\n        \\n        vector<string> order;\\n        eulerPath(\"JFK\", g, order);\\n        // During finding the Euler path, the nodes which should be visited\\n        // later can be found in front of order vector, so reverse it\\n        reverse(order.begin(), order.end());\\n        return order;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/reconstruct-itinerary/\\n    \\n    This problem is about finding the Euler path. Euler path is a path\\n    which involves traversing all the edges only once.\\n    The way the algo works is, we start with a source and start traversing the outward\\n    edges it has, each time we remove that edge so that we don\\'t process that edge even if come \\n    back to this node again. We keep traversing till we hit a node, from where we can\\'t move forward\\n    either due to all the outward edges being used already or lack of outward edges.\\n    When we hit a terminal node, we know that this is a node that should come after any remaining unvisited nodes.\\n    because we pick an edge without any core logic, we might traverse a path that skips other nodes,\\n    so when in this path we hit a roadblock we need to store that node in such a way that this comes after \\n    the nodes that are yet to traversed. \\n    So we save the node in a stack, return to the previous node. There check if there are any other edges are yet\\n    not traversed, if yes then traverse else add this node as well and return to the previous stack call.\\n    Since all the nodes are stored in a stack manner, path starts from the top element.\\n    \\n    TC: O(V + E) + O(ElogE) + O(E) // graph construction + sorting + Euler traversal\\n    SC: O(V + E)\\n*/\\nclass Solution {\\npublic:\\n    void eulerPath(string curr, \\n               unordered_map<string, deque<string>>& g,\\n               vector<string>& order) {\\n        // traverse the neighboring edges\\n        while(!g[curr].empty()) {\\n            // use the current edge, since in a euler path\\n            // each edge is used only once, remove it\\n            auto edge = g[curr].front();\\n            g[curr].pop_front();\\n            eulerPath(edge, g, order);\\n        }\\n        // add the curr node, as there is no other way from here\\n        order.emplace_back(curr);\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // create the graph, all the edges need to be sorted lexographically\\n        unordered_map<string, deque<string>> g;\\n        for(auto edge: tickets)\\n            g[edge[0]].emplace_back(edge[1]);\\n        \\n        // sort the edges lexographically\\n        for(auto [vertex, edges]: g)\\n            sort(g[vertex].begin(), g[vertex].end());\\n        \\n        vector<string> order;\\n        eulerPath(\"JFK\", g, order);\\n        // During finding the Euler path, the nodes which should be visited\\n        // later can be found in front of order vector, so reverse it\\n        reverse(order.begin(), order.end());\\n        return order;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372618,
                "title": "c-dfs-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    \\n    void solve(string curNode, unordered_map<string, priority_queue<string,vector<string>,greater<string>>> &graph){\\n        priority_queue<string,vector<string>,greater<string>> &pq = graph[curNode];\\n        while(!pq.empty()){\\n            string childNode = pq.top();\\n            pq.pop();\\n            solve(childNode, graph);\\n        }\\n        ans.insert(ans.begin()+0,curNode);\\n        return;\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, priority_queue<string,vector<string>,greater<string>>> graph;\\n        for(auto &t : tickets){\\n            graph[t[0]].push(t[1]);\\n        }\\n        solve(\"JFK\",graph);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    \\n    void solve(string curNode, unordered_map<string, priority_queue<string,vector<string>,greater<string>>> &graph){\\n        priority_queue<string,vector<string>,greater<string>> &pq = graph[curNode];\\n        while(!pq.empty()){\\n            string childNode = pq.top();\\n            pq.pop();\\n            solve(childNode, graph);\\n        }\\n        ans.insert(ans.begin()+0,curNode);\\n        return;\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, priority_queue<string,vector<string>,greater<string>>> graph;\\n        for(auto &t : tickets){\\n            graph[t[0]].push(t[1]);\\n        }\\n        solve(\"JFK\",graph);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1264208,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution \\n{\\n    int flights = 0;\\n    Dictionary<string,List<string>> adjList = new Dictionary<string,List<string>>();\\n    Dictionary<string,int[]> visitedBits = new Dictionary<string,int[]>();\\n    \\n    public IList<string> FindItinerary(IList<IList<string>> tickets) \\n    {\\n        foreach(var tkt in tickets)\\n        {\\n            adjList.TryAdd(tkt[0],new List<string>());\\n            adjList[tkt[0]].Add(tkt[1]);\\n        }\\n        \\n        foreach(var kv in adjList)\\n        {\\n            kv.Value.Sort((x,y)=>x.CompareTo(y));\\n            visitedBits.Add(kv.Key,new int[kv.Value.Count]);\\n        }\\n        \\n        flights = tickets.Count+1;\\n        \\n        IList<string> path = new List<string>(){\"JFK\"};\\n        Backtrack(\"JFK\", path);\\n        return path;\\n        \\n    }\\n    \\n    private bool Backtrack(string city, IList<string> path)\\n    {\\n        if(path.Count==flights)\\n            return true;\\n        \\n        if(!adjList.ContainsKey(city))\\n            return false;\\n        \\n        int[] vBits = visitedBits[city];\\n        List<string> cities = adjList[city];\\n        \\n        for(int i=0;i<cities.Count;i++)\\n        {\\n            \\n            if(vBits[i]==0)\\n            {\\n                vBits[i] = 1;\\n                path.Add(cities[i]);\\n                if(Backtrack(cities[i],path))\\n                    return true;\\n                vBits[i] = 0;\\n                path.RemoveAt(path.Count-1);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    int flights = 0;\\n    Dictionary<string,List<string>> adjList = new Dictionary<string,List<string>>();\\n    Dictionary<string,int[]> visitedBits = new Dictionary<string,int[]>();\\n    \\n    public IList<string> FindItinerary(IList<IList<string>> tickets) \\n    {\\n        foreach(var tkt in tickets)\\n        {\\n            adjList.TryAdd(tkt[0],new List<string>());\\n            adjList[tkt[0]].Add(tkt[1]);\\n        }\\n        \\n        foreach(var kv in adjList)\\n        {\\n            kv.Value.Sort((x,y)=>x.CompareTo(y));\\n            visitedBits.Add(kv.Key,new int[kv.Value.Count]);\\n        }\\n        \\n        flights = tickets.Count+1;\\n        \\n        IList<string> path = new List<string>(){\"JFK\"};\\n        Backtrack(\"JFK\", path);\\n        return path;\\n        \\n    }\\n    \\n    private bool Backtrack(string city, IList<string> path)\\n    {\\n        if(path.Count==flights)\\n            return true;\\n        \\n        if(!adjList.ContainsKey(city))\\n            return false;\\n        \\n        int[] vBits = visitedBits[city];\\n        List<string> cities = adjList[city];\\n        \\n        for(int i=0;i<cities.Count;i++)\\n        {\\n            \\n            if(vBits[i]==0)\\n            {\\n                vBits[i] = 1;\\n                path.Add(cities[i]);\\n                if(Backtrack(cities[i],path))\\n                    return true;\\n                vBits[i] = 0;\\n                path.RemoveAt(path.Count-1);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114799,
                "title": "very-simple-java-solution",
                "content": "\\n\\tprivate Map<String, PriorityQueue<String>> map;\\n    private LinkedList<String> result;\\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        this.map = new HashMap<>();\\n        this.result = new LinkedList<>();\\n        \\n        for (List<String> ticket: tickets) {\\n            String from = ticket.get(0);\\n            String to = ticket.get(1);\\n            \\n            PriorityQueue<String> destinations = map.get(from);\\n            \\n            if (destinations == null) {\\n                destinations = new PriorityQueue<String>();\\n                map.put(from, destinations);\\n            }\\n            \\n            destinations.add(to);\\n        }\\n        \\n        dfs(\"JFK\");\\n        return result;\\n    }\\n    \\n    private void dfs(String from) {\\n        PriorityQueue<String> arrivals = map.get(from);\\n        \\n        while (arrivals != null && !arrivals.isEmpty()) \\n            dfs(arrivals.remove());\\n        \\n        result.addFirst(from);\\n    }",
                "solutionTags": [],
                "code": "\\n\\tprivate Map<String, PriorityQueue<String>> map;\\n    private LinkedList<String> result;\\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        this.map = new HashMap<>();\\n        this.result = new LinkedList<>();\\n        \\n        for (List<String> ticket: tickets) {\\n            String from = ticket.get(0);\\n            String to = ticket.get(1);\\n            \\n            PriorityQueue<String> destinations = map.get(from);\\n            \\n            if (destinations == null) {\\n                destinations = new PriorityQueue<String>();\\n                map.put(from, destinations);\\n            }\\n            \\n            destinations.add(to);\\n        }\\n        \\n        dfs(\"JFK\");\\n        return result;\\n    }\\n    \\n    private void dfs(String from) {\\n        PriorityQueue<String> arrivals = map.get(from);\\n        \\n        while (arrivals != null && !arrivals.isEmpty()) \\n            dfs(arrivals.remove());\\n        \\n        result.addFirst(from);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1018032,
                "title": "c-beats-98-easy-and-concise-solution-using-multimap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, multimap<string, bool>> graph;\\n        for (vector<string> data : tickets)\\n            graph[data[0]].insert({data[1], false});\\n        \\n        vector<string> out;\\n        \\n        dfs(out, {\"JFK\", 0}, graph);\\n        \\n        reverse(out.begin(), out.end());\\n        return out;\\n    }\\n    \\n    void dfs(vector<string>& out, pair<string, bool> node, unordered_map<string, multimap<string, bool>>& graph) {  \\n        for (auto& data : graph[node.first]) {\\n            if (!data.second) {\\n                data.second = true;\\n                dfs(out, data, graph);\\n            }\\n        }\\n        out.push_back(node.first);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, multimap<string, bool>> graph;\\n        for (vector<string> data : tickets)\\n            graph[data[0]].insert({data[1], false});\\n        \\n        vector<string> out;\\n        \\n        dfs(out, {\"JFK\", 0}, graph);\\n        \\n        reverse(out.begin(), out.end());\\n        return out;\\n    }\\n    \\n    void dfs(vector<string>& out, pair<string, bool> node, unordered_map<string, multimap<string, bool>>& graph) {  \\n        for (auto& data : graph[node.first]) {\\n            if (!data.second) {\\n                data.second = true;\\n                dfs(out, data, graph);\\n            }\\n        }\\n        out.push_back(node.first);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798737,
                "title": "java-solution-using-priority-queue-and-stack",
                "content": "```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, PriorityQueue<String>> mapEdges = new HashMap<>();\\n        \\n        for(List<String> ticket : tickets) {\\n            PriorityQueue<String> q = mapEdges.getOrDefault(ticket.get(0), new PriorityQueue<String>( (s1, s2) -> s1.compareTo(s2) )) ;\\n            q.offer(ticket.get(1));\\n            mapEdges.put(ticket.get(0), q);\\n        }\\n        \\n        \\n        Stack<String> s = new Stack<>();\\n        s.push(\"JFK\"); // Starting point is JFK\\n        \\n        List<String> finalIternary = new ArrayList<>();\\n        while(!s.isEmpty()) {\\n\\n            String source = s.peek();\\n            PriorityQueue<String> q = mapEdges.get(source);\\n            \\n            if(q == null || q.isEmpty()) {\\n                finalIternary.add(s.pop());\\n            } else {\\n                s.push(q.poll());\\n            }\\n        }\\n        \\n        Collections.reverse(finalIternary);      \\n        return finalIternary;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, PriorityQueue<String>> mapEdges = new HashMap<>();\\n        \\n        for(List<String> ticket : tickets) {\\n            PriorityQueue<String> q = mapEdges.getOrDefault(ticket.get(0), new PriorityQueue<String>( (s1, s2) -> s1.compareTo(s2) )) ;\\n            q.offer(ticket.get(1));\\n            mapEdges.put(ticket.get(0), q);\\n        }\\n        \\n        \\n        Stack<String> s = new Stack<>();\\n        s.push(\"JFK\"); // Starting point is JFK\\n        \\n        List<String> finalIternary = new ArrayList<>();\\n        while(!s.isEmpty()) {\\n\\n            String source = s.peek();\\n            PriorityQueue<String> q = mapEdges.get(source);\\n            \\n            if(q == null || q.isEmpty()) {\\n                finalIternary.add(s.pop());\\n            } else {\\n                s.push(q.poll());\\n            }\\n        }\\n        \\n        Collections.reverse(finalIternary);      \\n        return finalIternary;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711550,
                "title": "rust-solution",
                "content": "```rust\\nuse std::cmp::Reverse;\\nuse std::collections::{BinaryHeap, HashMap};\\n\\nimpl Solution {\\n    pub fn find_itinerary(tickets: Vec<Vec<String>>) -> Vec<String> {\\n        let mut graph: HashMap<&str, BinaryHeap<Reverse<&str>>> = HashMap::new();\\n        for ticket in tickets.iter() {\\n            graph\\n                .entry(&ticket[0])\\n                .or_insert_with(BinaryHeap::new)\\n                .push(Reverse(&ticket[1]));\\n        }\\n        let mut answer: Vec<String> = Vec::with_capacity(tickets.len() + 1);\\n        let mut stack: Vec<&str> = vec![\"JFK\"];\\n        while let Some(src) = stack.last() {\\n            if let Some(dsts) = graph.get_mut(src) {\\n                if !dsts.is_empty() {\\n                    if let Some(dst) = dsts.pop() {\\n                        stack.push(dst.0);\\n                    }\\n                    continue;\\n                }\\n            }\\n            if let Some(last) = stack.pop() {\\n                answer.push(last.to_string());\\n            }\\n        }\\n        answer.reverse();\\n        answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::cmp::Reverse;\\nuse std::collections::{BinaryHeap, HashMap};\\n\\nimpl Solution {\\n    pub fn find_itinerary(tickets: Vec<Vec<String>>) -> Vec<String> {\\n        let mut graph: HashMap<&str, BinaryHeap<Reverse<&str>>> = HashMap::new();\\n        for ticket in tickets.iter() {\\n            graph\\n                .entry(&ticket[0])\\n                .or_insert_with(BinaryHeap::new)\\n                .push(Reverse(&ticket[1]));\\n        }\\n        let mut answer: Vec<String> = Vec::with_capacity(tickets.len() + 1);\\n        let mut stack: Vec<&str> = vec![\"JFK\"];\\n        while let Some(src) = stack.last() {\\n            if let Some(dsts) = graph.get_mut(src) {\\n                if !dsts.is_empty() {\\n                    if let Some(dst) = dsts.pop() {\\n                        stack.push(dst.0);\\n                    }\\n                    continue;\\n                }\\n            }\\n            if let Some(last) = stack.pop() {\\n                answer.push(last.to_string());\\n            }\\n        }\\n        answer.reverse();\\n        answer\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 710763,
                "title": "c-dfs-with-priority-queue",
                "content": "```\\nclass Solution {\\n    vector<string> ans;\\n    unordered_map<string, priority_queue<string, vector<string>, greater<string>>> mp;\\n    \\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        for (auto& ticket : tickets) {\\n            mp[ticket[0]].push(ticket[1]);\\n        }\\n        \\n        dfs(\"JFK\");\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n    \\n    void dfs(string src) {\\n        while (!mp[src].empty()) {\\n            string dst = mp[src].top();\\n            mp[src].pop();\\n            \\n            dfs(dst);\\n        }\\n        \\n        ans.push_back(src);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    vector<string> ans;\\n    unordered_map<string, priority_queue<string, vector<string>, greater<string>>> mp;\\n    \\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        for (auto& ticket : tickets) {\\n            mp[ticket[0]].push(ticket[1]);\\n        }\\n        \\n        dfs(\"JFK\");\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n    \\n    void dfs(string src) {\\n        while (!mp[src].empty()) {\\n            string dst = mp[src].top();\\n            mp[src].pop();\\n            \\n            dfs(dst);\\n        }\\n        \\n        ans.push_back(src);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520274,
                "title": "good-problem-terrible-description",
                "content": "It\\'s a shame this problem was writen so poorly. It could be a good problem had the intention been clearer. As a result of the shoddy explanation, this one had me going around in circles until I finally checked some of the solutions. Pointless frustration, as it turns out, as the missing information made the problem requirements seem a lot more difficult than they actually are. And the \"accepted\" solution (taken after others posted) gives nonsensical answers in a number of cases.\\n\\nFor example, if I set up a graph that looks like this:\\n```\\nJFK->[SFO, DUB]\\n```\\nthe solution my \"correct\" answer gives me is ` JFK SFO DUB.` Which is actually impossible. In a production environment, an impossible state should give null or an error. The instructions neglect to mention any error state. \\n\\nHere\\'s another:\\n```\\nDUB->[SFO] JFK->[SFO, DUB] SFO->[DUB]\\n```\\nThe order called for by the instructions (i.e. the lexically smallest) would be `JFK DUB SFO DUB` (with one leg impossible to reach). What it actually gives is `JFK SFO DUB SFO DUB` which is incorrect because it\\'s not lexically the smallest, and it lists the trip from SFO to DUB that doesn\\'t exist in the tickets. \\n\\nSo apparently there is some kind of guarantee that the data has an unspecified shape that\\'s key to solving the problem, but you\\'re going to make us just guess? That\\'s not a very worthwhile game. Edge cases should be important, but the way this problem is written, it ignores all of them. A good programmer should worry about them, but that makes the problem ridiculously difficult, because the real requirements were not clearly stated. \\n\\nThere are a lot of well-written problems on Leetcode. This is not one of them. \\n\\n```java\\n    void dfs(Map<String, List<String>> graph, List<String> rs, String here) {\\n        List<String> adj=graph.computeIfAbsent(here, e-> new ArrayList<>() );\\n        while (!adj.isEmpty())\\n            dfs(graph, rs, adj.remove(adj.size()-1));\\n        rs.add(here);\\n    }\\n\\n    public List<String> findItinerary(List<List<String>> tix) {\\n        tix.sort(Comparator\\n            .comparing((List<String> a) -> (a.get(0) + a.get(1)))\\n            .reversed());\\n        Map<String, List<String>> graph = new HashMap<>();\\n        tix.forEach( t -> graph\\n            .computeIfAbsent(t.get(0), (e -> new ArrayList<>()))\\n            .add(t.get(1)) );\\n\\n        List<String> rs=new ArrayList<>();\\n        dfs(graph, rs, \"JFK\");\\n        Collections.reverse(rs);\\n        return rs;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\nJFK->[SFO, DUB]\\n```\n```\\nDUB->[SFO] JFK->[SFO, DUB] SFO->[DUB]\\n```\n```java\\n    void dfs(Map<String, List<String>> graph, List<String> rs, String here) {\\n        List<String> adj=graph.computeIfAbsent(here, e-> new ArrayList<>() );\\n        while (!adj.isEmpty())\\n            dfs(graph, rs, adj.remove(adj.size()-1));\\n        rs.add(here);\\n    }\\n\\n    public List<String> findItinerary(List<List<String>> tix) {\\n        tix.sort(Comparator\\n            .comparing((List<String> a) -> (a.get(0) + a.get(1)))\\n            .reversed());\\n        Map<String, List<String>> graph = new HashMap<>();\\n        tix.forEach( t -> graph\\n            .computeIfAbsent(t.get(0), (e -> new ArrayList<>()))\\n            .add(t.get(1)) );\\n\\n        List<String> rs=new ArrayList<>();\\n        dfs(graph, rs, \"JFK\");\\n        Collections.reverse(rs);\\n        return rs;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 424837,
                "title": "python-recursive-dfs-beats-95",
                "content": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        adjMap = self.makeAdjMap(tickets)\\n        res = []\\n        self.dfs(adjMap, \"JFK\", res)\\n        return res[::-1]\\n    \\n    def dfs(self, adjMap, airport, res):\\n        if airport in adjMap and len(adjMap[airport]) > 0:        \\n            while len(adjMap[airport]) > 0:\\n                destination = adjMap[airport].pop()\\n                self.dfs(adjMap, destination, res)\\n        res.append(airport)\\n        \\n    def makeAdjMap(self, tickets):\\n        adjMap = {}\\n        for ticket in tickets:\\n            if ticket[0] not in adjMap:\\n                adjMap[ticket[0]] = [ticket[1]]\\n            else:\\n                adjMap[ticket[0]].append(ticket[1])\\n        for ticket in tickets:\\n            adjMap[ticket[0]].sort(reverse=True)\\n        return adjMap    \\n        \\n        \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        adjMap = self.makeAdjMap(tickets)\\n        res = []\\n        self.dfs(adjMap, \"JFK\", res)\\n        return res[::-1]\\n    \\n    def dfs(self, adjMap, airport, res):\\n        if airport in adjMap and len(adjMap[airport]) > 0:        \\n            while len(adjMap[airport]) > 0:\\n                destination = adjMap[airport].pop()\\n                self.dfs(adjMap, destination, res)\\n        res.append(airport)\\n        \\n    def makeAdjMap(self, tickets):\\n        adjMap = {}\\n        for ticket in tickets:\\n            if ticket[0] not in adjMap:\\n                adjMap[ticket[0]] = [ticket[1]]\\n            else:\\n                adjMap[ticket[0]].append(ticket[1])\\n        for ticket in tickets:\\n            adjMap[ticket[0]].sort(reverse=True)\\n        return adjMap    \\n        \\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 420174,
                "title": "python-easy-to-understand-with-explanation",
                "content": "```\\nclass Solution(object):\\n    def findItinerary(self, tickets):\\n        \"\"\"\\n        :type tickets: List[List[str]]\\n        :rtype: List[str]\\n        \"\"\"\\n        result=[]\\n        graph = collections.defaultdict(list)\\n        for frm, to in tickets:     #create a graph\\n            graph[frm].append(to)   #rearrange the destination of same start together\\n                        \\n        for frm, tos in graph.items():      #get key and value from dictionary #sort the destination\\n            tos.sort(reverse=True)          #we want small to large order\\n        \\n        def dfs(graph, source, result):\\n            while graph[source]:                #when the destination is not empty\\n                new_source = graph[source].pop()         #let the destination empty if we choose it to pop (pop() means the right one)\\n                dfs(graph, new_source, result)\\n            result.append(source)\\n            \\n        dfs(graph, \"JFK\", result)         \\n        return result[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findItinerary(self, tickets):\\n        \"\"\"\\n        :type tickets: List[List[str]]\\n        :rtype: List[str]\\n        \"\"\"\\n        result=[]\\n        graph = collections.defaultdict(list)\\n        for frm, to in tickets:     #create a graph\\n            graph[frm].append(to)   #rearrange the destination of same start together\\n                        \\n        for frm, tos in graph.items():      #get key and value from dictionary #sort the destination\\n            tos.sort(reverse=True)          #we want small to large order\\n        \\n        def dfs(graph, source, result):\\n            while graph[source]:                #when the destination is not empty\\n                new_source = graph[source].pop()         #let the destination empty if we choose it to pop (pop() means the right one)\\n                dfs(graph, new_source, result)\\n            result.append(source)\\n            \\n        dfs(graph, \"JFK\", result)         \\n        return result[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348511,
                "title": "java-dfs",
                "content": "```\\n\\nclass Solution {\\n    \\n    Map<String, PriorityQueue<String>> map = new HashMap<>();\\n    List<String> route = new ArrayList<>();\\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        for(List<String> ticket: tickets) {\\n            if(!map.containsKey(ticket.get(0))) {\\n                PriorityQueue<String> pq = new PriorityQueue<>();\\n                pq.add(ticket.get(1));\\n                map.put(ticket.get(0),pq);\\n            }\\n            else {\\n                map.get(ticket.get(0)).add(ticket.get(1));\\n            }\\n        }  \\n        visit(\"JFK\");\\n        return route;\\n    }\\n    \\n    public void visit(String airport) {\\n        while(map.containsKey(airport) && !map.get(airport).isEmpty()) {\\n            PriorityQueue<String> dests = map.get(airport);\\n            String dest = dests.poll();\\n            visit(dest);\\n        }\\n        route.add(0,airport); \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    Map<String, PriorityQueue<String>> map = new HashMap<>();\\n    List<String> route = new ArrayList<>();\\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        for(List<String> ticket: tickets) {\\n            if(!map.containsKey(ticket.get(0))) {\\n                PriorityQueue<String> pq = new PriorityQueue<>();\\n                pq.add(ticket.get(1));\\n                map.put(ticket.get(0),pq);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 185738,
                "title": "leetcode-bug-memory-limit-exceeded-when-i-try-submit-following-code",
                "content": "It\\'s weird that I can pass the test case \\n[[\"JFK\",\"SFO\"]]\\nfrom customize test case.\\n\\nBut when I try to submit my code, it always reporting \"Memory Limit Exceeded\":\\n\\nI didn\\'t see my code has problem for test case [[\"JFK\",\"SFO\"]].\\n\\nAny Master can give me a help on this? Or it\\'s a leetcode\\'s bug?\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n        unordered_map < string, priority_queue<string, vector<string>, greater<string>>> f2tos;\\n        for (auto ft : tickets) {\\n            f2tos[ft.first].push(ft.second);\\n        }\\n\\n        vector<string> result;\\n        if (tickets.empty() || f2tos.find(\"JFK\") == f2tos.end()) {\\n            return result;\\n        }\\n\\n        string start = \"JFK\";\\n        while (!f2tos.empty()) {\\n            auto pq2 = f2tos[start];\\n            result.push_back(start);\\n            auto next = pq2.top();\\n            pq2.pop();\\n            if (pq2.empty()) {\\n                f2tos.erase(start);\\n            }\\n\\n            start = next;\\n        }\\n\\n        result.push_back(start);\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n        unordered_map < string, priority_queue<string, vector<string>, greater<string>>> f2tos;\\n        for (auto ft : tickets) {\\n            f2tos[ft.first].push(ft.second);\\n        }\\n\\n        vector<string> result;\\n        if (tickets.empty() || f2tos.find(\"JFK\") == f2tos.end()) {\\n            return result;\\n        }\\n\\n        string start = \"JFK\";\\n        while (!f2tos.empty()) {\\n            auto pq2 = f2tos[start];\\n            result.push_back(start);\\n            auto next = pq2.top();\\n            pq2.pop();\\n            if (pq2.empty()) {\\n                f2tos.erase(start);\\n            }\\n\\n            start = next;\\n        }\\n\\n        result.push_back(start);\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78797,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution with detailed explanation** https://discuss.leetcode.com/topic/76788/python-solution-with-detailed-explanation\\n\\n**Reconstruct Itinerary** https://leetcode.com/problems/reconstruct-itinerary/\\n\\nAn Euler path is a path that uses every edge of a graph exactly once. An Euler path starts and ends at different vertices.\\n* First build a graph as a dictionary with key as vertex and value as list of edges with edge_id.\\n* Now the algorithm to find the Euler path is simple backtracking DFS.\\n* Note the Euler path may have cycles - Example 2 shows that. And Euler path allows an edge to be visited just once. Hence we will use edge_seen set to mark the edges visited. We will not mark vertices since we can visit vertices multiple times - cycles are allowed.\\n* We start with the first departure - JFK. \\n* We then find all the nbr,edge_id we can go to. We choose an edge that has not been visited before.\\n* Before we do a DFS, we add this to an edge_seen set and add to so_far\\n* touw - implements DFS and returns True when a path is found. We prune out search at that point.\\n\\n```\\nclass Solution(object):\\n    def build_graph(self, tickets):\\n        g, ticket_id = {}, 0\\n        for trip in tickets:\\n            v, w = trip[0], trip[1]\\n            g.setdefault(v, [])\\n            g[v].append((w, ticket_id))\\n            ticket_id = ticket_id + 1\\n        for k in g:\\n            g[k].sort(key=lambda x:x[0])\\n        return g\\n    \\n    def findItinerary(self, tickets):\\n        \"\"\"\\n        :type tickets: List[List[str]]\\n        :rtype: List[str]\\n        \"\"\"\\n        g = self.build_graph(tickets)\\n        tickets_used, itenary = set([]), [\"JFK\"]\\n        self.tour(g, itenary, tickets_used, len(tickets)+1)\\n        return itenary\\n    \\n    def tour(self, g, itenary, tickets_used, N):\\n        if len(itenary) == N:\\n            return True\\n        else:\\n            s = itenary[-1]\\n            if s in g:\\n                candidates = ((nbr, ticket_id) for nbr, ticket_id in g[s] if ticket_id not in tickets_used)\\n                for nbr, ticket_id in candidates:\\n                    tickets_used.add(ticket_id)\\n                    itenary.append(nbr)\\n                    if self.tour(g, itenary, tickets_used, N):\\n                        return True\\n                    itenary.pop()\\n                    tickets_used.remove(ticket_id)\\n            return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def build_graph(self, tickets):\\n        g, ticket_id = {}, 0\\n        for trip in tickets:\\n            v, w = trip[0], trip[1]\\n            g.setdefault(v, [])\\n            g[v].append((w, ticket_id))\\n            ticket_id = ticket_id + 1\\n        for k in g:\\n            g[k].sort(key=lambda x:x[0])\\n        return g\\n    \\n    def findItinerary(self, tickets):\\n        \"\"\"\\n        :type tickets: List[List[str]]\\n        :rtype: List[str]\\n        \"\"\"\\n        g = self.build_graph(tickets)\\n        tickets_used, itenary = set([]), [\"JFK\"]\\n        self.tour(g, itenary, tickets_used, len(tickets)+1)\\n        return itenary\\n    \\n    def tour(self, g, itenary, tickets_used, N):\\n        if len(itenary) == N:\\n            return True\\n        else:\\n            s = itenary[-1]\\n            if s in g:\\n                candidates = ((nbr, ticket_id) for nbr, ticket_id in g[s] if ticket_id not in tickets_used)\\n                for nbr, ticket_id in candidates:\\n                    tickets_used.add(ticket_id)\\n                    itenary.append(nbr)\\n                    if self.tour(g, itenary, tickets_used, N):\\n                        return True\\n                    itenary.pop()\\n                    tickets_used.remove(ticket_id)\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78802,
                "title": "javascript-122ms-recursive-solution",
                "content": "I have a JS solution that runs at 122ms (beating 100% of JS solutions yet). Any improvements or suggestions, please feel free to comment.\\n\\n```\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n    \\n    var length = tickets.length;\\n    \\n    var map = {\\n        JFK: []\\n    };\\n    \\n    var result = [];\\n    \\n    for(var i=0; i<length; i++){\\n        \\n        var from = tickets[i][0];\\n        var to = tickets[i][1];\\n        \\n        if(!map[from]){\\n            map[from] = [];\\n            map[from].push(to);\\n        } else {\\n            map[from].push(to);\\n        }\\n    }\\n    \\n    for(var prop in map){\\n        map[prop].sort();\\n    }    \\n    \\n    makeItinerary(\"JFK\");    // dfs\\n    \\n    function makeItinerary(from){        \\n        var tos = map[from];        \\n        while(tos && tos.length > 0){\\n            makeItinerary(tos.shift()); \\n        }        \\n        result.unshift(from);\\n    }\\n    \\n    return result;    \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n    \\n    var length = tickets.length;\\n    \\n    var map = {\\n        JFK: []\\n    };\\n    \\n    var result = [];\\n    \\n    for(var i=0; i<length; i++){\\n        \\n        var from = tickets[i][0];\\n        var to = tickets[i][1];\\n        \\n        if(!map[from]){\\n            map[from] = [];\\n            map[from].push(to);\\n        } else {\\n            map[from].push(to);\\n        }\\n    }\\n    \\n    for(var prop in map){\\n        map[prop].sort();\\n    }    \\n    \\n    makeItinerary(\"JFK\");    // dfs\\n    \\n    function makeItinerary(from){        \\n        var tos = map[from];        \\n        while(tos && tos.length > 0){\\n            makeItinerary(tos.shift()); \\n        }        \\n        result.unshift(from);\\n    }\\n    \\n    return result;    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2769245,
                "title": "c-easy-solution-min-heap-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(string curr, unordered_map<string, priority_queue<string, vector<string>, greater<string>>> &adj, vector<string> &ans) {\\n        while(adj[curr].size()) {\\n            string temp=adj[curr].top(); adj[curr].pop();\\n            dfs(temp, adj, ans);\\n        }\\n        ans.push_back(curr);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        vector<string> ans;\\n        unordered_map<string, priority_queue<string, vector<string>, greater<string>>> adj;\\n        for(auto x: tickets) {\\n            adj[x[0]].push(x[1]);\\n        }\\n        dfs(\"JFK\", adj, ans);\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(string curr, unordered_map<string, priority_queue<string, vector<string>, greater<string>>> &adj, vector<string> &ans) {\\n        while(adj[curr].size()) {\\n            string temp=adj[curr].top(); adj[curr].pop();\\n            dfs(temp, adj, ans);\\n        }\\n        ans.push_back(curr);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        vector<string> ans;\\n        unordered_map<string, priority_queue<string, vector<string>, greater<string>>> adj;\\n        for(auto x: tickets) {\\n            adj[x[0]].push(x[1]);\\n        }\\n        dfs(\"JFK\", adj, ans);\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370916,
                "title": "c-concise-straightfoward-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // Build the directed graph\\n        unordered_map<string, vector<string>> graph;\\n        int numOfEdges = tickets.size();\\n        for (vector<string> &ticket : tickets) {\\n            graph[ticket[0]].push_back(ticket[1]);\\n        }\\n        \\n        for (auto &it : graph) {\\n            sort(begin(it.second), end(it.second));\\n        }\\n        \\n        vector<string> result;\\n        vector<string> path = { \"JFK\" };\\n        dfs(\"JFK\", path, result, graph, numOfEdges);\\n        return result;\\n    }\\n    \\n    void dfs(string cur, vector<string> &path, vector<string> &result, unordered_map<string, vector<string>> &graph, int numOfEdges) {\\n        if (result.empty() == false) {\\n            return;\\n        }\\n        if (numOfEdges == 0) {\\n            result = path;\\n            return;\\n        }\\n        for (int i = 0; i < graph[cur].size(); i++) {\\n            string neighbor = graph[cur][i];\\n            if (neighbor != \"#\") {\\n                // Mark the edge\\n                graph[cur][i] = \"#\";\\n                path.push_back(neighbor);\\n                dfs(neighbor, path, result, graph, numOfEdges - 1);\\n                // Backtrack\\n                graph[cur][i] = neighbor;\\n                path.pop_back();\\n            }   \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // Build the directed graph\\n        unordered_map<string, vector<string>> graph;\\n        int numOfEdges = tickets.size();\\n        for (vector<string> &ticket : tickets) {\\n            graph[ticket[0]].push_back(ticket[1]);\\n        }\\n        \\n        for (auto &it : graph) {\\n            sort(begin(it.second), end(it.second));\\n        }\\n        \\n        vector<string> result;\\n        vector<string> path = { \"JFK\" };\\n        dfs(\"JFK\", path, result, graph, numOfEdges);\\n        return result;\\n    }\\n    \\n    void dfs(string cur, vector<string> &path, vector<string> &result, unordered_map<string, vector<string>> &graph, int numOfEdges) {\\n        if (result.empty() == false) {\\n            return;\\n        }\\n        if (numOfEdges == 0) {\\n            result = path;\\n            return;\\n        }\\n        for (int i = 0; i < graph[cur].size(); i++) {\\n            string neighbor = graph[cur][i];\\n            if (neighbor != \"#\") {\\n                // Mark the edge\\n                graph[cur][i] = \"#\";\\n                path.push_back(neighbor);\\n                dfs(neighbor, path, result, graph, numOfEdges - 1);\\n                // Backtrack\\n                graph[cur][i] = neighbor;\\n                path.pop_back();\\n            }   \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357384,
                "title": "euler-path-template-c",
                "content": "A Euler Path in a graph is a path which visits all the edges. A Eulerian Circuit is a Eulerian Path with the same Start and End node.\\nHere are the conditions to check if a graph contains a Euler Path or not.\\n\\n![image](https://assets.leetcode.com/users/images/15396511-dab4-4f26-b1af-96470ad6fce8_1627049659.1972127.png)\\n\\nIf we know that a graph has a Eulerian Path or Circuit, then for graph that satisfies Eulerian Circuit conditions we may begin with any node. But for a directed graph with two odd degree nodes we must begin with the node having outdegree > indegree and end at node having indegree > outdegree. And for undirected graph with two odd degree nodes Start at any of the 2 odd degree nodes.\\n\\nThis is the Hierholzer\\'s algorithm to find a Eulerian Path ( Knowing that the graph has one ). \\nThe algorithm is to perform dfs and keep removing edges traversed from the graph until we get stuck. Now the intuition is that we have missed the Eulerian path because we might have missed some edges in between which will be forming some sort of a cycle to bring us back to some middle node. Anyhow, the node which we are stuck on will be coming at last. So push it and backtrack to completely visit those leftover cycles.\\n\\t\\n\\tvector<int> path;\\n    \\n    void F(int u, vector<vector<int>>& G){\\n        \\n        while(!G[u].empty()){\\n            int v = G[u].top();\\n            G[u].pop();\\n            F(v, G);\\n        }\\n        path.push_back(u);\\n        \\n    }\\n    \\n    vector<int> eulerPath(int src, vector<vector<int>>& G){\\n        \\n        F(src, G);\\n        \\n        reverse(path.begin(), path.end());\\n        return path;\\n        \\n    }",
                "solutionTags": [],
                "code": "A Euler Path in a graph is a path which visits all the edges. A Eulerian Circuit is a Eulerian Path with the same Start and End node.\\nHere are the conditions to check if a graph contains a Euler Path or not.\\n\\n![image](https://assets.leetcode.com/users/images/15396511-dab4-4f26-b1af-96470ad6fce8_1627049659.1972127.png)\\n\\nIf we know that a graph has a Eulerian Path or Circuit, then for graph that satisfies Eulerian Circuit conditions we may begin with any node. But for a directed graph with two odd degree nodes we must begin with the node having outdegree > indegree and end at node having indegree > outdegree. And for undirected graph with two odd degree nodes Start at any of the 2 odd degree nodes.\\n\\nThis is the Hierholzer\\'s algorithm to find a Eulerian Path ( Knowing that the graph has one ). \\nThe algorithm is to perform dfs and keep removing edges traversed from the graph until we get stuck. Now the intuition is that we have missed the Eulerian path because we might have missed some edges in between which will be forming some sort of a cycle to bring us back to some middle node. Anyhow, the node which we are stuck on will be coming at last. So push it and backtrack to completely visit those leftover cycles.\\n\\t\\n\\tvector<int> path;\\n    \\n    void F(int u, vector<vector<int>>& G){\\n        \\n        while(!G[u].empty()){\\n            int v = G[u].top();\\n            G[u].pop();\\n            F(v, G);\\n        }\\n        path.push_back(u);\\n        \\n    }\\n    \\n    vector<int> eulerPath(int src, vector<vector<int>>& G){\\n        \\n        F(src, G);\\n        \\n        reverse(path.begin(), path.end());\\n        return path;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1311284,
                "title": "20ms-c-solution-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    unordered_map<string,priority_queue<string, vector<string>, greater<string>>> mp;\\n    void dfs(string str)\\n    {\\n        while(!mp[str].empty())\\n        {\\n        auto tp = mp[str].top();\\n        mp[str].pop();\\n        dfs(tp);\\n        }\\n        ans.push_back(str);\\n        return;\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) \\n    {\\n        for(auto x: tickets)\\n        {\\n            mp[x[0]].push(x[1]);\\n        }\\n        string str = \"JFK\";\\n        dfs(str);\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    unordered_map<string,priority_queue<string, vector<string>, greater<string>>> mp;\\n    void dfs(string str)\\n    {\\n        while(!mp[str].empty())\\n        {\\n        auto tp = mp[str].top();\\n        mp[str].pop();\\n        dfs(tp);\\n        }\\n        ans.push_back(str);\\n        return;\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) \\n    {\\n        for(auto x: tickets)\\n        {\\n            mp[x[0]].push(x[1]);\\n        }\\n        string str = \"JFK\";\\n        dfs(str);\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309356,
                "title": "explained-golang-backtrack-dfs-12ms",
                "content": "```go\\nimport \"sort\"\\n\\nfunc findItinerary(tickets [][]string) []string {\\n    // make a graph, map to keep tickets from source => []destinations\\n\\tadjancency := make(map[string][]string)\\n\\tfor i := 0; i < len(tickets); i++ {\\n\\t\\tadjancency[tickets[i][0]] = append(adjancency[tickets[i][0]], tickets[i][1])\\n\\t}\\n   \\n   // constraint is to give preferrence to lexicographically sorted solution, lets sort all destinations in asc order\\n   // we do it in a separate loop and not the above loop because we should call sort once for a list of destinations\\n\\tfor i := 0; i < len(tickets); i++ {\\n\\t\\tsort.Strings(adjancency[tickets[i][0]])\\n\\t}\\n\\n\\titinerary := []string{}\\n\\t\\n\\t// dfs function made inside this function only because, it is much cleaner this way\\n\\t// you need to pass less variables around with the recursive DFS calls\\n\\tvar dfs func(source string) bool\\n\\tdfs = func(source string) bool {\\n\\t\\titinerary = append(itinerary, source)\\n\\n        // we only want to check solutions only for totalChances, if solution\\n\\t\\t// is not found in that, means the solution is somewhere else and we backtrack!\\n\\t\\ttotalChances := len(adjancency[source])\\n\\t\\tchances := 0\\n\\t\\t\\n\\t\\t// find all the other possible destinations\\n\\t\\tfor len(adjancency[source]) > 0 && chances < totalChances {\\n\\t\\t\\tdestination := adjancency[source][0]\\n\\t\\t\\tadjancency[source] = adjancency[source][1:]\\n\\t\\t\\tif !dfs(destination) { // backtrack, destination is not a possible destination\\n\\t\\t\\t\\tchances += 1\\n\\t\\t\\t\\titinerary = itinerary[:len(itinerary)-1]\\n\\t\\t\\t\\tadjancency[source] = append(adjancency[source], destination)\\n\\t\\t\\t} else { // hurrah! we found our solution\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// so when the iteneary is made up of all tickets we have found our solution else not\\n\\t\\t// if not we trigger backtrack!\\n\\t\\tif len(itinerary)-1 != len(tickets) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n         // solution found\\n\\t\\treturn true\\n\\t}\\n\\n\\tdfs(\"JFK\")\\n\\n\\treturn itinerary\\n}\\n```\\n\\nLet me know if you have any questions",
                "solutionTags": [
                    "Go",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```go\\nimport \"sort\"\\n\\nfunc findItinerary(tickets [][]string) []string {\\n    // make a graph, map to keep tickets from source => []destinations\\n\\tadjancency := make(map[string][]string)\\n\\tfor i := 0; i < len(tickets); i++ {\\n\\t\\tadjancency[tickets[i][0]] = append(adjancency[tickets[i][0]], tickets[i][1])\\n\\t}\\n   \\n   // constraint is to give preferrence to lexicographically sorted solution, lets sort all destinations in asc order\\n   // we do it in a separate loop and not the above loop because we should call sort once for a list of destinations\\n\\tfor i := 0; i < len(tickets); i++ {\\n\\t\\tsort.Strings(adjancency[tickets[i][0]])\\n\\t}\\n\\n\\titinerary := []string{}\\n\\t\\n\\t// dfs function made inside this function only because, it is much cleaner this way\\n\\t// you need to pass less variables around with the recursive DFS calls\\n\\tvar dfs func(source string) bool\\n\\tdfs = func(source string) bool {\\n\\t\\titinerary = append(itinerary, source)\\n\\n        // we only want to check solutions only for totalChances, if solution\\n\\t\\t// is not found in that, means the solution is somewhere else and we backtrack!\\n\\t\\ttotalChances := len(adjancency[source])\\n\\t\\tchances := 0\\n\\t\\t\\n\\t\\t// find all the other possible destinations\\n\\t\\tfor len(adjancency[source]) > 0 && chances < totalChances {\\n\\t\\t\\tdestination := adjancency[source][0]\\n\\t\\t\\tadjancency[source] = adjancency[source][1:]\\n\\t\\t\\tif !dfs(destination) { // backtrack, destination is not a possible destination\\n\\t\\t\\t\\tchances += 1\\n\\t\\t\\t\\titinerary = itinerary[:len(itinerary)-1]\\n\\t\\t\\t\\tadjancency[source] = append(adjancency[source], destination)\\n\\t\\t\\t} else { // hurrah! we found our solution\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// so when the iteneary is made up of all tickets we have found our solution else not\\n\\t\\t// if not we trigger backtrack!\\n\\t\\tif len(itinerary)-1 != len(tickets) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n         // solution found\\n\\t\\treturn true\\n\\t}\\n\\n\\tdfs(\"JFK\")\\n\\n\\treturn itinerary\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1265296,
                "title": "simple-python",
                "content": "```class Solution:\\n    def findItinerary(self, tickets):\\n        graph = defaultdict(list)\\n\\n        tickets.sort(key=lambda x: x[1])\\n\\n        for u, v in tickets:\\n            graph[u].append(v)\\n\\n        itinerary, stack = [], [\"JFK\"]\\n\\n        while stack:\\n            curr = stack[-1]\\n\\n            if curr in graph and len(graph[curr]) > 0:\\n                stack.append(graph[curr].pop(0))\\n            else:\\n                itinerary.append(stack.pop())\\n        return itinerary[::-1]\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution:\\n    def findItinerary(self, tickets):\\n        graph = defaultdict(list)\\n\\n        tickets.sort(key=lambda x: x[1])\\n\\n        for u, v in tickets:\\n            graph[u].append(v)\\n\\n        itinerary, stack = [], [\"JFK\"]\\n\\n        while stack:\\n            curr = stack[-1]\\n\\n            if curr in graph and len(graph[curr]) > 0:\\n                stack.append(graph[curr].pop(0))\\n            else:\\n                itinerary.append(stack.pop())\\n        return itinerary[::-1]\\n",
                "codeTag": "Java"
            },
            {
                "id": 1146076,
                "title": "dfs-with-priority-queue",
                "content": "```\\nclass Solution {\\n    HashMap<String, PriorityQueue<String>>  graph = new HashMap<>();\\n    LinkedList<String> result  = new LinkedList<>();\\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        this.buildGraph(tickets);\\n        this.dfs(\"JFK\");\\n        return this.result;\\n    }\\n    \\n    private void dfs(String origin) {\\n        if (this.graph.containsKey(origin)) {\\n          PriorityQueue<String> set = this.graph.get(origin);\\n          while (!set.isEmpty()) {\\n            this.dfs(set.poll());\\n          }\\n        }\\n        this.result.offerFirst(origin);\\n    }\\n    \\n    private void buildGraph(List<List<String>> tickets) {\\n        for(List<String> list: tickets) {\\n            PriorityQueue<String> set = graph.getOrDefault(list.get(0), new PriorityQueue<String>());\\n            set.add(list.get(1));\\n            graph.put(list.get(0), set);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    HashMap<String, PriorityQueue<String>>  graph = new HashMap<>();\\n    LinkedList<String> result  = new LinkedList<>();\\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        this.buildGraph(tickets);\\n        this.dfs(\"JFK\");\\n        return this.result;\\n    }\\n    \\n    private void dfs(String origin) {\\n        if (this.graph.containsKey(origin)) {\\n          PriorityQueue<String> set = this.graph.get(origin);\\n          while (!set.isEmpty()) {\\n            this.dfs(set.poll());\\n          }\\n        }\\n        this.result.offerFirst(origin);\\n    }\\n    \\n    private void buildGraph(List<List<String>> tickets) {\\n        for(List<String> list: tickets) {\\n            PriorityQueue<String> set = graph.getOrDefault(list.get(0), new PriorityQueue<String>());\\n            set.add(list.get(1));\\n            graph.put(list.get(0), set);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 811482,
                "title": "java-simple-solution-using-dfs",
                "content": "```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) { \\n        Map<String,PriorityQueue<String>> map = new HashMap<>();\\n        \\n        for(List<String> l : tickets) {\\n            if(map.containsKey(l.get(0)))\\n                map.get(l.get(0)).add(l.get(1));\\n            else {\\n                PriorityQueue<String> pq = new PriorityQueue<>();\\n                pq.add(l.get(1));\\n                map.put(l.get(0),pq);\\n            }\\n        }\\n        \\n        List<String> ans = new ArrayList<>();\\n        dfs(map, ans, \"JFK\");\\n        \\n        Collections.reverse(ans);\\n        \\n        return ans;\\n    }\\n    \\n    public static void dfs(Map<String,PriorityQueue<String>> map, List<String> ans, String index) {\\n        PriorityQueue<String> pq = map.get(index);\\n        \\n        while(pq != null && !pq.isEmpty()) {\\n            String i = pq.poll();\\n            dfs(map,ans,i);\\n        }\\n        \\n        ans.add(index);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) { \\n        Map<String,PriorityQueue<String>> map = new HashMap<>();\\n        \\n        for(List<String> l : tickets) {\\n            if(map.containsKey(l.get(0)))\\n                map.get(l.get(0)).add(l.get(1));\\n            else {\\n                PriorityQueue<String> pq = new PriorityQueue<>();\\n                pq.add(l.get(1));\\n                map.put(l.get(0),pq);\\n            }\\n        }\\n        \\n        List<String> ans = new ArrayList<>();\\n        dfs(map, ans, \"JFK\");\\n        \\n        Collections.reverse(ans);\\n        \\n        return ans;\\n    }\\n    \\n    public static void dfs(Map<String,PriorityQueue<String>> map, List<String> ans, String index) {\\n        PriorityQueue<String> pq = map.get(index);\\n        \\n        while(pq != null && !pq.isEmpty()) {\\n            String i = pq.poll();\\n            dfs(map,ans,i);\\n        }\\n        \\n        ans.add(index);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797507,
                "title": "python-east-to-read-explanation-w-graph-stacks",
                "content": "```\\n\"\"\"\\nMultiple Iternaries\\n\\nDeparts from JFK\\n\\nJFK: [SFO,ATL]\\nSFO: [ATL]\\nATL: [JFK]\\n\\nJFK: [xxx,xxx]  -> [ATL,SFO]\\nSFO: [xxx]      --> [ATL]\\nATL: [xxx,xxx]  --> [JFK,SFO]\\n** key is only visit once\\n\\nstack: [JFK,ATL,JFK,SFO,ATL,SFO]\\nwhen we see nothing is in graph -> pop it!\\n\\nIdea:\\nGRAPH + conditional Stack:\\n\\n- create directed graph start to ending locations\\n- sort the arrays lexicographically\\n- create a stack and evaulate last item on stack\\n  - get one of its edges from graph, if non exists pop it out of stack and add to output\\n  - when evaulating an edge, pop it from the graph so it doesnt get reevaluated\\n- eventually you will have empty edge for location (exhausted places to visit) and pop to output from stack.\\n- return reverse output\\n\\n\"\"\"\\n\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        \\n        if not tickets: return []\\n        \\n        graph = defaultdict(list)\\n        \\n        for ticket in tickets:\\n            t1 = ticket[0]\\n            t2 = ticket[1]\\n            graph[t1].append(t2)\\n            if t2 not in graph:\\n                graph[t2] = []\\n        \\n        for v in graph.values():\\n            v = v.sort(reverse=True)\\n        \\n        # use stack to evaluate\\n        stack = []\\n        stack.append(\\'JFK\\')\\n        \\n        output = []\\n        while stack:\\n            curr = stack[-1]\\n            # print(\\'curr\\',curr,\\'stack\\',stack,\\'graph\\',graph[curr])\\n            if len(graph[curr]) == 0:\\n                \\n                output.append(stack.pop())\\n            else:\\n                nbr = graph[curr].pop()\\n                stack.append(nbr)\\n        # print(output)\\n        return output[::-1]\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph"
                ],
                "code": "```\\n\"\"\"\\nMultiple Iternaries\\n\\nDeparts from JFK\\n\\nJFK: [SFO,ATL]\\nSFO: [ATL]\\nATL: [JFK]\\n\\nJFK: [xxx,xxx]  -> [ATL,SFO]\\nSFO: [xxx]      --> [ATL]\\nATL: [xxx,xxx]  --> [JFK,SFO]\\n** key is only visit once\\n\\nstack: [JFK,ATL,JFK,SFO,ATL,SFO]\\nwhen we see nothing is in graph -> pop it!\\n\\nIdea:\\nGRAPH + conditional Stack:\\n\\n- create directed graph start to ending locations\\n- sort the arrays lexicographically\\n- create a stack and evaulate last item on stack\\n  - get one of its edges from graph, if non exists pop it out of stack and add to output\\n  - when evaulating an edge, pop it from the graph so it doesnt get reevaluated\\n- eventually you will have empty edge for location (exhausted places to visit) and pop to output from stack.\\n- return reverse output\\n\\n\"\"\"\\n\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        \\n        if not tickets: return []\\n        \\n        graph = defaultdict(list)\\n        \\n        for ticket in tickets:\\n            t1 = ticket[0]\\n            t2 = ticket[1]\\n            graph[t1].append(t2)\\n            if t2 not in graph:\\n                graph[t2] = []\\n        \\n        for v in graph.values():\\n            v = v.sort(reverse=True)\\n        \\n        # use stack to evaluate\\n        stack = []\\n        stack.append(\\'JFK\\')\\n        \\n        output = []\\n        while stack:\\n            curr = stack[-1]\\n            # print(\\'curr\\',curr,\\'stack\\',stack,\\'graph\\',graph[curr])\\n            if len(graph[curr]) == 0:\\n                \\n                output.append(stack.pop())\\n            else:\\n                nbr = graph[curr].pop()\\n                stack.append(nbr)\\n        # print(output)\\n        return output[::-1]\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 741820,
                "title": "python-solution-faster-than-99-53-solutions-memory-usage-less-than-94-12-solutions",
                "content": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph=collections.defaultdict(list)\\n        for edge in tickets:\\n            graph[edge[0]].append(edge[1])\\n        for i in graph:\\n            graph[i].sort(reverse=True)\\n        ans=[]\\n        def visit(current):\\n            while graph[current]:\\n                visit(graph[current].pop())\\n            ans.append(current)\\n        visit(\"JFK\")\\n        return ans[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph=collections.defaultdict(list)\\n        for edge in tickets:\\n            graph[edge[0]].append(edge[1])\\n        for i in graph:\\n            graph[i].sort(reverse=True)\\n        ans=[]\\n        def visit(current):\\n            while graph[current]:\\n                visit(graph[current].pop())\\n            ans.append(current)\\n        visit(\"JFK\")\\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711795,
                "title": "c-post-order-traversal-explained",
                "content": "```\\nclass Solution {//BEST1: post-order traversal + ordered set\\npublic: // Time/Space: O(NlogN), O(N)\\n    vector<string> findItinerary(vector<vector<string> > tickets) {\\n        vector<string> res;\\n        unordered_map<string, multiset<string> > m;  //this is how to represent the graph        \\n        for (auto& a : tickets)  m[a[0]].insert(a[1]);\\n        string start(\"JFK\");\\n        dfs(m, start, res);  //post-order traversal\\n        //return vector<string> (res.rbegin(), res.rend()); // ok\\n        return {res.rbegin(), res.rend()}; // better\\n    }\\n    \\n    void dfs(unordered_map<string, multiset<string> > &m, string& s, vector<string> &res) {    \\n        while (m[s].size()) {\\n            auto cur = m[s].begin();\\n            string t = *cur;\\n            m[s].erase(cur);  //cur ticket is used, so need to be removed\\n            dfs(m, t, res);\\n        }\\n        res.emplace_back(s); // since the root info is consumed in the last, so this is post-order traversal\\n    }\\n};\\n\\n```\\n\\nPython\\n```\\nfrom collections import defaultdict\\nfrom typing import List\\n\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        # Representing the graph as an ordered set (which is a dictionary in Python)\\n        m = defaultdict(list)\\n        \\n        # Sorting the tickets so that we can pop from the end (smallest lexical order) in O(1) time.\\n        tickets.sort(reverse=True)\\n        \\n        # Filling the dictionary\\n        for a, b in tickets:\\n            m[a].append(b)\\n        \\n        # List to store the result\\n        res = []\\n        \\n        # Post-order traversal\\n        self.dfs(m, \"JFK\", res)\\n        \\n        return res[::-1]  # Reversing to get the result\\n    \\n    def dfs(self, m: dict, s: str, res: List[str]):\\n        while m[s]:\\n            # pop() gives us the smallest lexical order while removing the ticket\\n            self.dfs(m, m[s].pop(), res)\\n        \\n        res.append(s)\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nclass Solution {//BEST1: post-order traversal + ordered set\\npublic: // Time/Space: O(NlogN), O(N)\\n    vector<string> findItinerary(vector<vector<string> > tickets) {\\n        vector<string> res;\\n        unordered_map<string, multiset<string> > m;  //this is how to represent the graph        \\n        for (auto& a : tickets)  m[a[0]].insert(a[1]);\\n        string start(\"JFK\");\\n        dfs(m, start, res);  //post-order traversal\\n        //return vector<string> (res.rbegin(), res.rend()); // ok\\n        return {res.rbegin(), res.rend()}; // better\\n    }\\n    \\n    void dfs(unordered_map<string, multiset<string> > &m, string& s, vector<string> &res) {    \\n        while (m[s].size()) {\\n            auto cur = m[s].begin();\\n            string t = *cur;\\n            m[s].erase(cur);  //cur ticket is used, so need to be removed\\n            dfs(m, t, res);\\n        }\\n        res.emplace_back(s); // since the root info is consumed in the last, so this is post-order traversal\\n    }\\n};\\n\\n```\n```\\nfrom collections import defaultdict\\nfrom typing import List\\n\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        # Representing the graph as an ordered set (which is a dictionary in Python)\\n        m = defaultdict(list)\\n        \\n        # Sorting the tickets so that we can pop from the end (smallest lexical order) in O(1) time.\\n        tickets.sort(reverse=True)\\n        \\n        # Filling the dictionary\\n        for a, b in tickets:\\n            m[a].append(b)\\n        \\n        # List to store the result\\n        res = []\\n        \\n        # Post-order traversal\\n        self.dfs(m, \"JFK\", res)\\n        \\n        return res[::-1]  # Reversing to get the result\\n    \\n    def dfs(self, m: dict, s: str, res: List[str]):\\n        while m[s]:\\n            # pop() gives us the smallest lexical order while removing the ticket\\n            self.dfs(m, m[s].pop(), res)\\n        \\n        res.append(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710205,
                "title": "python-solution-dfs-using-stack",
                "content": "```\\n\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        result, map_ = [], {}\\n        stack = [\"JFK\"]\\n\\n        for i in tickets:\\n            if i[0] in map_:\\n                map_[i[0]].append(i[1])\\n            else:\\n                map_[i[0]] = [i[1]]\\n        \\n        for i in map_:\\n            map_[i].sort()\\n\\n        while(stack):\\n            curr = stack[-1]\\n            if curr in map_ and len(map_[curr]) > 0:\\n                stack.append(map_[curr].pop(0))\\n            else:\\n                result.append(stack.pop())\\n        \\n        return result[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        result, map_ = [], {}\\n        stack = [\"JFK\"]\\n\\n        for i in tickets:\\n            if i[0] in map_:\\n                map_[i[0]].append(i[1])\\n            else:\\n                map_[i[0]] = [i[1]]\\n        \\n        for i in map_:\\n            map_[i].sort()\\n\\n        while(stack):\\n            curr = stack[-1]\\n            if curr in map_ and len(map_[curr]) > 0:\\n                stack.append(map_[curr].pop(0))\\n            else:\\n                result.append(stack.pop())\\n        \\n        return result[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 677867,
                "title": "c-euler-s-path",
                "content": "Request you to visit the 15 minute video (link below) to get the clear picture of what\\'s happening.\\n```\\n//https://www.youtube.com/watch?v=8MpoO2zA2l4\\n//watch this video, everthing will sort out in your mind :-)\\nclass Solution{\\npublic:\\n    map<string,multiset<string>> graph;\\n    vector<string> res;\\n    void go(string d){\\n        while(graph[d].size()){\\n            auto next = *graph[d].begin();\\n            graph[d].erase(graph[d].begin());\\n            go(next);\\n        } \\n        res.push_back(d);\\n    }\\n    vector<string> findItinerary(vector<vector<string>> tickets) {\\n        for(auto& t: tickets) graph[t[0]].insert(t[1]);\\n        go(\"JFK\");\\n        return vector<string>(res.rbegin(),res.rend());\\n    }   \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//https://www.youtube.com/watch?v=8MpoO2zA2l4\\n//watch this video, everthing will sort out in your mind :-)\\nclass Solution{\\npublic:\\n    map<string,multiset<string>> graph;\\n    vector<string> res;\\n    void go(string d){\\n        while(graph[d].size()){\\n            auto next = *graph[d].begin();\\n            graph[d].erase(graph[d].begin());\\n            go(next);\\n        } \\n        res.push_back(d);\\n    }\\n    vector<string> findItinerary(vector<vector<string>> tickets) {\\n        for(auto& t: tickets) graph[t[0]].insert(t[1]);\\n        go(\"JFK\");\\n        return vector<string>(res.rbegin(),res.rend());\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373897,
                "title": "java-solution",
                "content": "```\\nMap<String, Queue<String>> graph = new HashMap<>();\\nList<String> ans = new LinkedList<>();\\npublic List<String> findItinerary(List<List<String>> tickets) {\\n\\tfor (List<String> ticket :\\n\\t\\t\\ttickets) {\\n\\t\\tgraph.putIfAbsent(ticket.get(0), new PriorityQueue<>(Comparator.naturalOrder()));\\n\\t\\tgraph.get(ticket.get(0)).add(ticket.get(1));\\n\\t}\\n\\n\\tdfs(\"JFK\");\\n\\treturn ans;\\n}\\n\\nprivate void dfs(String departure) {\\n\\tQueue<String> destinations = graph.get(departure);\\n\\twhile (destinations != null && !destinations.isEmpty())\\n\\t\\tdfs(destinations.poll());\\n\\tans.add(0, departure);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nMap<String, Queue<String>> graph = new HashMap<>();\\nList<String> ans = new LinkedList<>();\\npublic List<String> findItinerary(List<List<String>> tickets) {\\n\\tfor (List<String> ticket :\\n\\t\\t\\ttickets) {\\n\\t\\tgraph.putIfAbsent(ticket.get(0), new PriorityQueue<>(Comparator.naturalOrder()));\\n\\t\\tgraph.get(ticket.get(0)).add(ticket.get(1));\\n\\t}\\n\\n\\tdfs(\"JFK\");\\n\\treturn ans;\\n}\\n\\nprivate void dfs(String departure) {\\n\\tQueue<String> destinations = graph.get(departure);\\n\\twhile (destinations != null && !destinations.isEmpty())\\n\\t\\tdfs(destinations.poll());\\n\\tans.add(0, departure);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 219121,
                "title": "java-very-short-iterative-solution-using-stack-and-hashmap",
                "content": "```\\npublic List<String> findItinerary(String[][] tickets) {\\n        LinkedList<String> res = new LinkedList<>();\\n        if (tickets.length == 0) return res;\\n        \\n        Map<String, PriorityQueue<String>> map = new HashMap<>();\\n        \\n        for (String[] ticket : tickets) {\\n            if (!map.containsKey(ticket[0])) {\\n                map.put(ticket[0], new PriorityQueue<>());\\n            }\\n            map.get(ticket[0]).offer(ticket[1]);\\n        }\\n        \\n        Stack<String> stack = new Stack<>();\\n        stack.push(\"JFK\");\\n        while (!stack.isEmpty()) {\\n            String top = stack.peek();\\n            if (!map.containsKey(top) || map.get(top).isEmpty()) {\\n                res.addFirst(stack.pop());\\n            } else {\\n                stack.push(map.get(top).poll());\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> findItinerary(String[][] tickets) {\\n        LinkedList<String> res = new LinkedList<>();\\n        if (tickets.length == 0) return res;\\n        \\n        Map<String, PriorityQueue<String>> map = new HashMap<>();\\n        \\n        for (String[] ticket : tickets) {\\n            if (!map.containsKey(ticket[0])) {\\n                map.put(ticket[0], new PriorityQueue<>());\\n            }\\n            map.get(ticket[0]).offer(ticket[1]);\\n        }\\n        \\n        Stack<String> stack = new Stack<>();\\n        stack.push(\"JFK\");\\n        while (!stack.isEmpty()) {\\n            String top = stack.peek();\\n            if (!map.containsKey(top) || map.get(top).isEmpty()) {\\n                res.addFirst(stack.pop());\\n            } else {\\n                stack.push(map.get(top).poll());\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 188260,
                "title": "java-using-iteration-by-stack",
                "content": "```\\n/**\\n\\u975E\\u9012\\u5F52---\\u8FED\\u4EE3\\u7684\\u65B9\\u6CD5\\uFF0C\\u4F7F\\u7528\\u6808\\n*/\\n\\nclass Solution {\\n    public List<String> findItinerary(String[][] tickets) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String[] ticket : tickets) {\\n            String start = ticket[0];\\n            String end = ticket[1];\\n            if (!map.containsKey(start)) {\\n                map.put(start, new ArrayList<>());\\n            }\\n            map.get(start).add(end);\\n        }\\n        for (String node : map.keySet()) {\\n            Collections.sort(map.get(node));\\n        }\\n        List<String> res = new ArrayList<>();\\n        Stack<String> stack = new Stack<>();\\n        stack.push(\"JFK\");\\n        while (!stack.isEmpty()) {\\n            String cur = stack.peek();\\n            if (map.containsKey(cur) && map.get(cur).size() > 0) {  //\\u8FD8\\u80FD\\u524D\\u8FDB\\n                String next = map.get(cur).get(0);\\n                map.get(cur).remove(0);\\n                stack.push(next);\\n            } else {  //\\u4E0D\\u80FD\\u524D\\u8FDB\\u4E86\\uFF0C\\u5219\\u51FA\\u6808\\uFF0C\\u52A0\\u5165\\u7ED3\\u679C\\n                res.add(cur);\\n                stack.pop();\\n            }\\n        }\\n        Collections.reverse(res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n\\u975E\\u9012\\u5F52---\\u8FED\\u4EE3\\u7684\\u65B9\\u6CD5\\uFF0C\\u4F7F\\u7528\\u6808\\n*/\\n\\nclass Solution {\\n    public List<String> findItinerary(String[][] tickets) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String[] ticket : tickets) {\\n            String start = ticket[0];\\n            String end = ticket[1];\\n            if (!map.containsKey(start)) {\\n                map.put(start, new ArrayList<>());\\n            }\\n            map.get(start).add(end);\\n        }\\n        for (String node : map.keySet()) {\\n            Collections.sort(map.get(node));\\n        }\\n        List<String> res = new ArrayList<>();\\n        Stack<String> stack = new Stack<>();\\n        stack.push(\"JFK\");\\n        while (!stack.isEmpty()) {\\n            String cur = stack.peek();\\n            if (map.containsKey(cur) && map.get(cur).size() > 0) {  //\\u8FD8\\u80FD\\u524D\\u8FDB\\n                String next = map.get(cur).get(0);\\n                map.get(cur).remove(0);\\n                stack.push(next);\\n            } else {  //\\u4E0D\\u80FD\\u524D\\u8FDB\\u4E86\\uFF0C\\u5219\\u51FA\\u6808\\uFF0C\\u52A0\\u5165\\u7ED3\\u679C\\n                res.add(cur);\\n                stack.pop();\\n            }\\n        }\\n        Collections.reverse(res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044248,
                "title": "easy-beginner-solution-c-98-users-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, priority_queue<string, vector<string>, greater<string>>> graph;\\n        for (const auto& ticket : tickets) {\\n            graph[ticket[0]].push(ticket[1]);\\n        }\\n        vector<string> newItinerary;\\n        stack<string> st;\\n        st.push(\"JFK\");\\n        while (!st.empty()){\\n            string currentAirport = st.top();\\n            if (graph.find(currentAirport) != graph.end() && !graph[currentAirport].empty()) {\\n                st.push(graph[currentAirport].top());\\n                graph[currentAirport].pop();\\n            } else {\\n                newItinerary.push_back(st.top());\\n                st.pop();\\n            }\\n        }\\n        reverse(newItinerary.begin(), newItinerary.end());\\n        return newItinerary;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, priority_queue<string, vector<string>, greater<string>>> graph;\\n        for (const auto& ticket : tickets) {\\n            graph[ticket[0]].push(ticket[1]);\\n        }\\n        vector<string> newItinerary;\\n        stack<string> st;\\n        st.push(\"JFK\");\\n        while (!st.empty()){\\n            string currentAirport = st.top();\\n            if (graph.find(currentAirport) != graph.end() && !graph[currentAirport].empty()) {\\n                st.push(graph[currentAirport].top());\\n                graph[currentAirport].pop();\\n            } else {\\n                newItinerary.push_back(st.top());\\n                st.pop();\\n            }\\n        }\\n        reverse(newItinerary.begin(), newItinerary.end());\\n        return newItinerary;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043058,
                "title": "priority-queue-c-o-n-fastest-and-simplest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to construct a graph where each airport is a node, and there\\'s a directed edge from one airport to another if there is a valid flight ticket from the first airport to the second. The goal is to find a valid itinerary that visits all the airports exactly once and returns it in lexical order.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the code is **Depth-First Search (DFS)** to explore possible routes. The flight function builds a graph representation of the tickets, and the dfs function performs the **DFS traversal starting from the \"JFK\" airport**. During the traversal, it keeps picking the **smallest lexical airport (due to the use of a priority queue)** from the available options and continues exploring until there are no more options. This ensures that the final ans vector will contain a **valid itinerary in lexical order**.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n1. Constructing the graph (in the flight function) takes **O(n)**, where n is the number of flight tickets.\\n1. The **DFS traversal** (in the dfs function) explores each airport at most once, so it takes **O(n)** time as well.\\n1. Reversing the ans vector takes **O(n)**.\\n1. Overall, the time complexity of the code is **O(n)**.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. The code uses an **unordered map f** to store the graph representation, which can take up to **O(n)** space since there can be a ticket for each unique airport.\\n1. The **priority queue** for each airport can have a maximum of n entries (in the worst case), so the space complexity of the priority queues is also **O(n)**.\\n1. The **ans vector** can also take up to **O(n)** space.\\n1. Overall, the space complexity of the code is **O(n)**.\\n\\n**In summary, the code efficiently finds a valid itinerary in lexical order using a graph representation and DFS traversal. It has a time complexity of O(n) and a space complexity of O(n).**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,priority_queue<string,vector<string>,greater<string>>>f;\\n    vector<string>ans;\\n\\n    void dfs(string dept){\\n        while(!f[dept].empty()){\\n            string to=f[dept].top();\\n            f[dept].pop();\\n            dfs(to);\\n        }\\n        ans.push_back(dept);\\n    }\\n\\n    void flight(vector<vector<string>> &tickets){\\n        for(auto &it: tickets){\\n            string from=it[0];\\n            string to=it[1];\\n            f[from].push(to);\\n        }\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        flight(tickets);\\n        dfs(\"JFK\");\\n        reverse(ans.begin(),ans.end());\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,priority_queue<string,vector<string>,greater<string>>>f;\\n    vector<string>ans;\\n\\n    void dfs(string dept){\\n        while(!f[dept].empty()){\\n            string to=f[dept].top();\\n            f[dept].pop();\\n            dfs(to);\\n        }\\n        ans.push_back(dept);\\n    }\\n\\n    void flight(vector<vector<string>> &tickets){\\n        for(auto &it: tickets){\\n            string from=it[0];\\n            string to=it[1];\\n            f[from].push(to);\\n        }\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        flight(tickets);\\n        dfs(\"JFK\");\\n        reverse(ans.begin(),ans.end());\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042259,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private void dfs(String s, Map<String, PriorityQueue<String>> map, LinkedList<String> list){\\n\\n        PriorityQueue<String> pq = map.get(s);\\n\\n        while(pq!=null && !pq.isEmpty()){\\n\\n            dfs(pq.poll(), map, list);\\n\\n        }\\n\\n        list.addFirst(s);\\n\\n    }\\n\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n\\n        HashMap<String, PriorityQueue<String>> map = new HashMap<>();\\n\\n        for(int i=0; i<tickets.size(); i++){\\n\\n            if(!map.containsKey(tickets.get(i).get(0))){\\n\\n                PriorityQueue<String> pq = new PriorityQueue<>();\\n\\n                map.put(tickets.get(i).get(0), pq);\\n\\n            }\\n\\n            map.get(tickets.get(i).get(0)).add(tickets.get(i).get(1));\\n\\n        } \\n\\n        LinkedList<String> list = new LinkedList<>();\\n\\n        dfs(\"JFK\", map, list);\\n\\n        return list;\\n\\n    }\\n\\n}\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    private void dfs(String s, Map<String, PriorityQueue<String>> map, LinkedList<String> list){\\n\\n        PriorityQueue<String> pq = map.get(s);\\n\\n        while(pq!=null && !pq.isEmpty()){\\n\\n            dfs(pq.poll(), map, list);\\n\\n        }\\n\\n        list.addFirst(s);\\n\\n    }\\n\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n\\n        HashMap<String, PriorityQueue<String>> map = new HashMap<>();\\n\\n        for(int i=0; i<tickets.size(); i++){\\n\\n            if(!map.containsKey(tickets.get(i).get(0))){\\n\\n                PriorityQueue<String> pq = new PriorityQueue<>();\\n\\n                map.put(tickets.get(i).get(0), pq);\\n\\n            }\\n\\n            map.get(tickets.get(i).get(0)).add(tickets.get(i).get(1));\\n\\n        } \\n\\n        LinkedList<String> list = new LinkedList<>();\\n\\n        dfs(\"JFK\", map, list);\\n\\n        return list;\\n\\n    }\\n\\n}\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973238,
                "title": "c-fast-code-18ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define pq priority_queue<string,vector<string>,greater<string>>\\n    map<string,pq>mp;\\n    vector<string>ans;\\n    void dfs(string start){\\n        if(mp[start].size()==0){\\n            ans.push_back(start);\\n            return;\\n        }\\n\\n        auto &s=mp[start];\\n\\n        while(!s.empty()){\\n            auto temp=s.top();\\n            s.pop();\\n\\n            dfs(temp);\\n        }   \\n        ans.push_back(start);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        mp.clear();\\n        ans.clear();\\n        \\n        for(auto i:tickets){\\n            mp[i[0]].push(i[1]);\\n        }\\n\\n        dfs(\"JFK\");\\n\\n        reverse(ans.begin(),end(ans));\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Ordered Set",
                    "Eulerian Circuit"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define pq priority_queue<string,vector<string>,greater<string>>\\n    map<string,pq>mp;\\n    vector<string>ans;\\n    void dfs(string start){\\n        if(mp[start].size()==0){\\n            ans.push_back(start);\\n            return;\\n        }\\n\\n        auto &s=mp[start];\\n\\n        while(!s.empty()){\\n            auto temp=s.top();\\n            s.pop();\\n\\n            dfs(temp);\\n        }   \\n        ans.push_back(start);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        mp.clear();\\n        ans.clear();\\n        \\n        for(auto i:tickets){\\n            mp[i[0]].push(i[1]);\\n        }\\n\\n        dfs(\"JFK\");\\n\\n        reverse(ans.begin(),end(ans));\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490774,
                "title": "easiest-more-optimized-javascript-solution-with-full-explanation",
                "content": "```\\nPlease Up-Vote If This Helps You. Thanks In Advance .\\n```\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code implements a solution to find the itinerary of a traveler given a list of flight tickets represented as a two-dimensional array, where each element of the array represents a flight ticket from one airport to another.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the code is to first build a map of all the possible destinations for each airport. Then, starting from the initial airport JFK, the code performs a depth-first search (DFS) to visit all the airports in the itinerary in a lexicographically sorted order, i.e., if there are multiple destinations available from an airport, then the code picks the one that comes first in alphabetical order. The itinerary is stored in the res array, which is then reversed and returned as the final answer.\\n\\n# Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- The first for-loop runs through all the tickets once, therefore takes `O(n)` time where n is the number of tickets.\\n- The second for-loop iterates through each airport in the map and sorts the destinations. The time complexity of the sorting operation is `O(m log m)` where m is the number of destinations for an airport. Since the total number of destinations across all airports is equal to n-1 (where n is the total number of tickets), the time complexity of this loop is `O(n log n)`.\\n- The DFS function is called once for each airport in the map, which takes `O(m)` time where m is the number of destinations for an airport. Since the total number of destinations across all airports is equal to n-1, the time complexity of this function is `O(n)`.\\n- Finally, reversing the res array takes `O(n)` time.\\n\\n\\nTherefore, the overall time complexity of the code is **`O(n log n)`**, where n is the number of tickets.\\n\\n# Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- The space complexity of the code is dominated by the map object, which stores the destinations for each airport. Since there are n distinct airports, the space complexity of the map is `O(n).`\\n- The DFS function uses a recursive call stack, which can have a depth of up to n, therefore the space complexity of the DFS function is `O(n)`.\\n- The res array stores the itinerary, which can have a maximum size of n+1, therefore the space complexity of the res array is also `O(n)`.\\n- The rest of the variables used in the code have constant space complexity.\\n\\nTherefore, the overall space complexity of the code is `O(n)`.\\n\\n# JavaScript Code\\n```\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n    var map = {};\\n    var res = [];\\n    for(var i=0; i<tickets.length; i++) {\\n        var dep = tickets[i][0];\\n        var des = tickets[i][1];\\n        if(map[dep]) {\\n            map[dep].push(des);\\n        } else {\\n            map[dep] = [des];\\n        }\\n    }\\n    for(let loc in map) {\\n        map[loc].sort();\\n    }  \\n    var dfs = function(node) {\\n        var des = map[node];\\n        while(des && des.length>0) {\\n            dfs(des.shift());\\n        }\\n        res.push(node);\\n    }\\n    dfs(\\'JFK\\');\\n    return res.reverse();\\n};\\n```\\n\\n\\n> # My Section\\n```\\nThanks For Reading This Solution . \\n\\nNow You Can Solve This Problem .\\n \\nHope You Will Give A Up-Vote To My Solution .\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nPlease Up-Vote If This Helps You. Thanks In Advance .\\n```\n```\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n    var map = {};\\n    var res = [];\\n    for(var i=0; i<tickets.length; i++) {\\n        var dep = tickets[i][0];\\n        var des = tickets[i][1];\\n        if(map[dep]) {\\n            map[dep].push(des);\\n        } else {\\n            map[dep] = [des];\\n        }\\n    }\\n    for(let loc in map) {\\n        map[loc].sort();\\n    }  \\n    var dfs = function(node) {\\n        var des = map[node];\\n        while(des && des.length>0) {\\n            dfs(des.shift());\\n        }\\n        res.push(node);\\n    }\\n    dfs(\\'JFK\\');\\n    return res.reverse();\\n};\\n```\n```\\nThanks For Reading This Solution . \\n\\nNow You Can Solve This Problem .\\n \\nHope You Will Give A Up-Vote To My Solution .\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2817769,
                "title": "c-dfs-19ms-beats-98-8-13-6-beats-97-12",
                "content": "[@ayush_gupta4](https://leetcode.com/ayush_gupta4/) proposed this [method](https://leetcode.com/problems/reconstruct-itinerary/solutions/2769245/c-easy-solution-min-heap-dfs/) and I refactor the code.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static vector<string> findItinerary(const vector<vector<string>>& tickets) {\\n        vector<string> ret;\\n        unordered_map<string_view, priority_queue<string_view, vector<string_view>, greater<>>> adj;\\n        for (auto& x : tickets)\\n            adj[x[0]].emplace(x[1]);\\n        \\n        function<void(string_view)> dfs = [&] (string_view curr) {\\n            auto& adj_nodes = adj[curr];\\n            while (!adj_nodes.empty()) {\\n                auto temp = adj_nodes.top();\\n                adj_nodes.pop();\\n                dfs(temp);\\n            }\\n            ret.emplace_back(curr);\\n        };\\n\\n        dfs(\"JFK\");\\n        reverse(begin(ret), end(ret));\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static vector<string> findItinerary(const vector<vector<string>>& tickets) {\\n        vector<string> ret;\\n        unordered_map<string_view, priority_queue<string_view, vector<string_view>, greater<>>> adj;\\n        for (auto& x : tickets)\\n            adj[x[0]].emplace(x[1]);\\n        \\n        function<void(string_view)> dfs = [&] (string_view curr) {\\n            auto& adj_nodes = adj[curr];\\n            while (!adj_nodes.empty()) {\\n                auto temp = adj_nodes.top();\\n                adj_nodes.pop();\\n                dfs(temp);\\n            }\\n            ret.emplace_back(curr);\\n        };\\n\\n        dfs(\"JFK\");\\n        reverse(begin(ret), end(ret));\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2360823,
                "title": "hierholzer-algorithm-short-implementation-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    stack<string> s;\\n    map<string, queue<string>> adj;\\n    \\n    void hierthing(string &src){\\n        // pushing to stack\\n        s.push(src);\\n        \\n        // recursing till outdegree is 0\\n        while (!adj[src].empty()){\\n            string v = adj[src].front();\\n            adj[src].pop();\\n            hierthing(v);\\n        }\\n        \\n        // popping from stack and adding to the answer\\n        ans.push_back(s.top());\\n        s.pop();\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // sorting to ensure lexical order\\n        sort(tickets.begin(), tickets.end());\\n        \\n        for (auto trip: tickets){\\n            // pushing destination to a queue\\n            adj[trip[0]].push(trip[1]);\\n        }\\n        \\n        string s = \"JFK\";\\n        hierthing(s);\\n        \\n        // reversed answer\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    stack<string> s;\\n    map<string, queue<string>> adj;\\n    \\n    void hierthing(string &src){\\n        // pushing to stack\\n        s.push(src);\\n        \\n        // recursing till outdegree is 0\\n        while (!adj[src].empty()){\\n            string v = adj[src].front();\\n            adj[src].pop();\\n            hierthing(v);\\n        }\\n        \\n        // popping from stack and adding to the answer\\n        ans.push_back(s.top());\\n        s.pop();\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // sorting to ensure lexical order\\n        sort(tickets.begin(), tickets.end());\\n        \\n        for (auto trip: tickets){\\n            // pushing destination to a queue\\n            adj[trip[0]].push(trip[1]);\\n        }\\n        \\n        string s = \"JFK\";\\n        hierthing(s);\\n        \\n        // reversed answer\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607024,
                "title": "neetcode-video-translation",
                "content": "```\\nclass Solution {\\n    bool dfs(string src, unordered_map<string, multiset<string>>& adj, vector<string>& res, const int num_tickets)\\n    {\\n        if(res.size() == (num_tickets + 1))\\n        {\\n            return true;\\n        }\\n        if (!adj.count(src)) return false;\\n        multiset<string> temp = adj[src];\\n        for(auto v: temp){\\n            adj[src].erase(adj[src].find(v));\\n            res.push_back(v);\\n            if(dfs(v, adj, res, num_tickets))\\n               return true;\\n            adj[src].insert(v);\\n            res.pop_back();\\n        }\\n        \\n        return false;  \\n    }\\n    \\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, multiset<string>> adj;\\n        for(auto ticket: tickets)\\n        {\\n            adj[ticket[0]].insert(ticket[1]);\\n        }\\n        vector<string> res;\\n        res.push_back(\"JFK\");\\n        dfs(\"JFK\", adj, res, tickets.size());\\n        return res;        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    bool dfs(string src, unordered_map<string, multiset<string>>& adj, vector<string>& res, const int num_tickets)\\n    {\\n        if(res.size() == (num_tickets + 1))\\n        {\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1478509,
                "title": "straight-forward-dfs-solution-without-a-separate-visited-array",
                "content": "I have explained in comments on almost each line explaining why I am doing that.\\nThe basic logic is to DFS from all points, starting from JFK and find an itinerary where all tickets are exhausted, (visited all edges in other words).  \\nBut since there could be multiple answers, and we need return the intinerary that occurs first in lexical order, I have sorted that tickets in adjaceny list before starting the DFS and hence at every point when we decide the next stop, we always choose the destination that occurs first in lexical order greedily, and once we get the first solution, that will be the first one.\\nA small optimization I did instead of having a seperate visited array is to alter the adjacency list once we use a ticket, and fix it back once checking the possibility for exploring other possibilities, while backtracking.\\n\\n```\\nclass Solution:\\n    def checkPaths(self, adjList,start, res, totalTickets, stack = []):\\n        stack.append(start)\\n        if len(stack) == totalTickets and not res:  # if no itenerary has been found yet and if len is number of tickets.\\n            res.append(stack) \\n            return  # we got the answer.\\n        for i, nextPoint in enumerate(adjList[start]):\\n            if nextPoint != -1:\\n                adjList[start][i] = -1 # ticket has been used\\n                self.checkPaths(adjList, nextPoint, res, totalTickets, stack)\\n                adjList[start][i] = nextPoint # add it back after exploring if that option worked.\\n            if res: return  # if we found the route, then return no need to check for more possibilities.\\n        stack.pop()\\n            \\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        # build adjacency list in sorted order. It always helps us select the lexical order, \\n        # and if we exhaust all ticket, thats the itinerary first in lexical order.\\n        tickets.sort() # O(ELOGE)\\n        adjList = collections.defaultdict(list)\\n        for s,d in tickets: adjList[s].append(d)\\n        res = []\\n        totalTickets = len(tickets) + 1\\n        start = \\'JFK\\'\\n        self.checkPaths(adjList, start, res, totalTickets, []) # DFS from JFK to all destination.\\n        return res[0]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def checkPaths(self, adjList,start, res, totalTickets, stack = []):\\n        stack.append(start)\\n        if len(stack) == totalTickets and not res:  # if no itenerary has been found yet and if len is number of tickets.\\n            res.append(stack) \\n            return  # we got the answer.\\n        for i, nextPoint in enumerate(adjList[start]):\\n            if nextPoint != -1:\\n                adjList[start][i] = -1 # ticket has been used\\n                self.checkPaths(adjList, nextPoint, res, totalTickets, stack)\\n                adjList[start][i] = nextPoint # add it back after exploring if that option worked.\\n            if res: return  # if we found the route, then return no need to check for more possibilities.\\n        stack.pop()\\n            \\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        # build adjacency list in sorted order. It always helps us select the lexical order, \\n        # and if we exhaust all ticket, thats the itinerary first in lexical order.\\n        tickets.sort() # O(ELOGE)\\n        adjList = collections.defaultdict(list)\\n        for s,d in tickets: adjList[s].append(d)\\n        res = []\\n        totalTickets = len(tickets) + 1\\n        start = \\'JFK\\'\\n        self.checkPaths(adjList, start, res, totalTickets, []) # DFS from JFK to all destination.\\n        return res[0]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1477207,
                "title": "c-solution-for-332-reconstruct-itinerary",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    unordered_map<string,priority_queue<string, vector<string>, greater<string>>> umap;\\n    \\n    void dfs(string s)\\n    {\\n        while(!umap[s].empty())\\n        {\\n            auto node = umap[s].top();// cout<<node<<endl;\\n            umap[s].pop();\\n            dfs(node);\\n        }\\n        ans.push_back(s);\\n        return;\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) \\n    {\\n        for(auto str : tickets)\\n        {\\n            umap[str[0]].push(str[1]);\\n        }\\n        string src = \"JFK\" ;\\n        dfs(src);\\n        reverse(ans.begin(), ans.end());\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    unordered_map<string,priority_queue<string, vector<string>, greater<string>>> umap;\\n    \\n    void dfs(string s)\\n    {\\n        while(!umap[s].empty())\\n        {\\n            auto node = umap[s].top();// cout<<node<<endl;\\n            umap[s].pop();\\n            dfs(node);\\n        }\\n        ans.push_back(s);\\n        return;\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) \\n    {\\n        for(auto str : tickets)\\n        {\\n            umap[str[0]].push(str[1]);\\n        }\\n        string src = \"JFK\" ;\\n        dfs(src);\\n        reverse(ans.begin(), ans.end());\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1394684,
                "title": "a-solution-dfs-in-python",
                "content": "```\\n\\ndef findItinerary(tickets):\\n    graph = {}\\n\\n    tickets.sort(key=lambda x: x[1])\\n    expected = len(tickets) + 1\\n\\n    for index in range(len(tickets)):\\n        ticket = tickets[index]\\n        frm = ticket[0]\\n        to = ticket[1]\\n\\n        if frm not in graph:\\n            graph[frm] = []\\n        if to not in graph:\\n            graph[to] = []\\n        graph[frm].append((to, \\'{}{}\\'.format(index,to)))\\n\\n    def dfs(node, path, visited):\\n\\n        if len(path) == expected:\\n\\n            return path\\n\\n        for info in graph[node]:\\n            neighbor, _id = info\\n\\n            edge = (node, _id)\\n            if edge not in visited:\\n                visited.add(edge)\\n                path.append(neighbor)\\n                potential = dfs(neighbor, path, visited)\\n\\n                if potential:\\n                    return potential\\n\\n                visited.remove(edge)\\n                path.pop()\\n\\n        return None\\n\\n    return dfs(\"JFK\", [\"JFK\"], set())\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\ndef findItinerary(tickets):\\n    graph = {}\\n\\n    tickets.sort(key=lambda x: x[1])\\n    expected = len(tickets) + 1\\n\\n    for index in range(len(tickets)):\\n        ticket = tickets[index]\\n        frm = ticket[0]\\n        to = ticket[1]\\n\\n        if frm not in graph:\\n            graph[frm] = []\\n        if to not in graph:\\n            graph[to] = []\\n        graph[frm].append((to, \\'{}{}\\'.format(index,to)))\\n\\n    def dfs(node, path, visited):\\n\\n        if len(path) == expected:\\n\\n            return path\\n\\n        for info in graph[node]:\\n            neighbor, _id = info\\n\\n            edge = (node, _id)\\n            if edge not in visited:\\n                visited.add(edge)\\n                path.append(neighbor)\\n                potential = dfs(neighbor, path, visited)\\n\\n                if potential:\\n                    return potential\\n\\n                visited.remove(edge)\\n                path.pop()\\n\\n        return None\\n\\n    return dfs(\"JFK\", [\"JFK\"], set())\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1316171,
                "title": "using-hierholzer-s-algorithm-for-euler-path-in-python",
                "content": "Eulerian path/circuit: a path in a graph that traverse every edge exactly once. This is what the question is asking for. Only twist is that you need to ensure lexicographical order (which we do by sorting the adjacency list).\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        # 206-219 (13min)\\n\\t\\t# starts at JFK\\n        # if multiple, return one with smallest lexographical order\\n        \\n        # 1. Create digraph where edge (u,v) represents flight from u->v\\n        # 2. Find a path that goes along every edge (Eulerian path/circuit)\\n            # use Hierholzer\\'s algorithm\\n            # if multiple options, choose lexo smallest (i.e. ATL over SFO)\\n            \\n            \\n        #1\\n        \\n        adj_list = {} # rly a map\\n        \\n        for t in tickets:\\n            if t[0] in adj_list:\\n                adj_list[t[0]].append(t[1])\\n            else:\\n                adj_list[t[0]] = [t[1]]\\n                \\n        for airport in adj_list:\\n            adj_list[airport].sort(reverse=True)\\n            \\n        #2 Hierholzer\\n        \\n        stack = [\"JFK\"]\\n        path = []\\n        while len(stack) > 0:\\n            t = stack[-1]\\n            if t not in adj_list or len(adj_list[t]) == 0:\\n                path.append(t)\\n                stack.pop()\\n            else:\\n                stack.append(adj_list[t][-1])\\n                adj_list[t].pop()                \\n        \\n        path.reverse()\\n        return path\\n    \\n```\\n        \\n\\t`",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        # 206-219 (13min)\\n\\t\\t# starts at JFK\\n        # if multiple, return one with smallest lexographical order\\n        \\n        # 1. Create digraph where edge (u,v) represents flight from u->v\\n        # 2. Find a path that goes along every edge (Eulerian path/circuit)\\n            # use Hierholzer\\'s algorithm\\n            # if multiple options, choose lexo smallest (i.e. ATL over SFO)\\n            \\n            \\n        #1\\n        \\n        adj_list = {} # rly a map\\n        \\n        for t in tickets:\\n            if t[0] in adj_list:\\n                adj_list[t[0]].append(t[1])\\n            else:\\n                adj_list[t[0]] = [t[1]]\\n                \\n        for airport in adj_list:\\n            adj_list[airport].sort(reverse=True)\\n            \\n        #2 Hierholzer\\n        \\n        stack = [\"JFK\"]\\n        path = []\\n        while len(stack) > 0:\\n            t = stack[-1]\\n            if t not in adj_list or len(adj_list[t]) == 0:\\n                path.append(t)\\n                stack.pop()\\n            else:\\n                stack.append(adj_list[t][-1])\\n                adj_list[t].pop()                \\n        \\n        path.reverse()\\n        return path\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257561,
                "title": "hashmap-solution-in-java-and-c-with-explanation",
                "content": "**Explanation**\\n```\\nThis is the variation of dfs.\\nThe way to tweak the dfs is to not to put a base condition and let the dfs fill and tsack and empty itslef\\nWhat i mean by this is \\n\\nInput: [[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]]\\nLets say we built a graph of this and its adjacenecy list look like this:-\\nJFK - MUC\\nMUC - LHR\\nLHR - SFO\\nSFO - SJC\\n\\nSo when we perform a dfs on JFK\\n\\n|        |\\n|        |\\n|        |   <-----Recursion Stack\\n|        |\\n|__JFK___|\\n\\nWe explore JFKs neighbors \\n\\n|        |\\n|        |\\n|        |\\n|  MUC   |\\n|__JFK___|\\n\\nWe explore Muc neighbors\\n\\n|        |\\n|        |\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|        |\\n|  SFO   |\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|  SJC   |\\n|  SFO   |\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\nSince SJC has no neighbors we pus it back to the answer\\n\\n|        |\\n|  SFO   |      ans=SJC\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|        |\\n|        |      ans=SJC,SFO\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|        |\\n|        |      ans=SJC,SFO,LHR\\n|        |\\n|  MUC   |\\n|__JFK___|\\n\\n\\n|        |\\n|        |      ans=SJC,SFO,LHR,MUC \\n|        |\\n|        |\\n|__JFK___|\\n\\n|        |\\n|        |      ans=SJC,SFO,LHR,MUC,JFK \\n|        |\\n|        |\\n|________|\\n\\n```\\n**Java**\\n```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        HashMap<String, PriorityQueue<String>> map = new HashMap<>();\\n        for (List<String> i: tickets)\\n            map.computeIfAbsent(i.get(0), k -> new PriorityQueue<>()).add(i.get(1));\\n        Stack<String> st = new Stack<>();\\n        List<String> ans = new ArrayList<>();\\n        st.add(\"JFK\");\\n        while (!st.empty()) {\\n            while ( map.containsKey(st.peek()) && !map.get(st.peek()).isEmpty() ) {\\n                st.push(map.get(st.peek()).poll());\\n            }\\n            ans.add(0, st.pop());\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, priority_queue<string, vector<string>, greater<string>>> map;\\n    vector<string> ans;\\n    void dfs(string s) {\\n        auto &x = map[s];\\n        while (!x.empty()) {\\n            string val = x.top();\\n            x.pop();\\n            dfs(val);\\n        }\\n        ans.insert(ans.begin(), s);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        for (auto &i: tickets)\\n            map[i[0]].push(i[1]);\\n        dfs(\"JFK\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nThis is the variation of dfs.\\nThe way to tweak the dfs is to not to put a base condition and let the dfs fill and tsack and empty itslef\\nWhat i mean by this is \\n\\nInput: [[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]]\\nLets say we built a graph of this and its adjacenecy list look like this:-\\nJFK - MUC\\nMUC - LHR\\nLHR - SFO\\nSFO - SJC\\n\\nSo when we perform a dfs on JFK\\n\\n|        |\\n|        |\\n|        |   <-----Recursion Stack\\n|        |\\n|__JFK___|\\n\\nWe explore JFKs neighbors \\n\\n|        |\\n|        |\\n|        |\\n|  MUC   |\\n|__JFK___|\\n\\nWe explore Muc neighbors\\n\\n|        |\\n|        |\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|        |\\n|  SFO   |\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|  SJC   |\\n|  SFO   |\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\nSince SJC has no neighbors we pus it back to the answer\\n\\n|        |\\n|  SFO   |      ans=SJC\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|        |\\n|        |      ans=SJC,SFO\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|        |\\n|        |      ans=SJC,SFO,LHR\\n|        |\\n|  MUC   |\\n|__JFK___|\\n\\n\\n|        |\\n|        |      ans=SJC,SFO,LHR,MUC \\n|        |\\n|        |\\n|__JFK___|\\n\\n|        |\\n|        |      ans=SJC,SFO,LHR,MUC,JFK \\n|        |\\n|        |\\n|________|\\n\\n```\n```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        HashMap<String, PriorityQueue<String>> map = new HashMap<>();\\n        for (List<String> i: tickets)\\n            map.computeIfAbsent(i.get(0), k -> new PriorityQueue<>()).add(i.get(1));\\n        Stack<String> st = new Stack<>();\\n        List<String> ans = new ArrayList<>();\\n        st.add(\"JFK\");\\n        while (!st.empty()) {\\n            while ( map.containsKey(st.peek()) && !map.get(st.peek()).isEmpty() ) {\\n                st.push(map.get(st.peek()).poll());\\n            }\\n            ans.add(0, st.pop());\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, priority_queue<string, vector<string>, greater<string>>> map;\\n    vector<string> ans;\\n    void dfs(string s) {\\n        auto &x = map[s];\\n        while (!x.empty()) {\\n            string val = x.top();\\n            x.pop();\\n            dfs(val);\\n        }\\n        ans.insert(ans.begin(), s);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        for (auto &i: tickets)\\n            map[i[0]].push(i[1]);\\n        dfs(\"JFK\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212542,
                "title": "python-3-simple-using-hierholzer-s-algorithm-with-comments",
                "content": "```python\\ndef findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph = defaultdict(list)\\n        res = deque()\\n        \\n\\t\\t# build graph\\n        for u,v in tickets:\\n            graph[u].append(v)\\n        \\n\\t\\t# sort outgoing edges in order to process in lexicographical order\\n        for u in graph:\\n            graph[u].sort(reverse=True)\\n        \\n\\t\\t# start from \\'JFK\\', dfs on outgoing edges and append current when there are no more outgoing edges\\n        def dfs(u=\\'JFK\\'):\\n            while graph[u]:\\n                dfs(graph[u].pop())\\n            res.appendleft(u)\\n              \\n        dfs()\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph = defaultdict(list)\\n        res = deque()\\n        \\n\\t\\t# build graph\\n        for u,v in tickets:\\n            graph[u].append(v)\\n        \\n\\t\\t# sort outgoing edges in order to process in lexicographical order\\n        for u in graph:\\n            graph[u].sort(reverse=True)\\n        \\n\\t\\t# start from \\'JFK\\', dfs on outgoing edges and append current when there are no more outgoing edges\\n        def dfs(u=\\'JFK\\'):\\n            while graph[u]:\\n                dfs(graph[u].pop())\\n            res.appendleft(u)\\n              \\n        dfs()\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1204313,
                "title": "c-dfs-explained",
                "content": "It is understood that we have a directed graph. The basic requirement of the question is a **path that traverses all the edges** and it should be **lexographically smallest path.**\\nThus we would be using DFS based approach. We should start from the starting node \"JFK\" and keep moving deep into the graph until we encounter a **DEAD END**\\nBy DEAD END we mean a node which either has no edges directing out from it ( *outDegree = 0* ) or it has no edges directing out from it which havent been included in the path already.\\nIn both the case, this very node would be our last node in the itinerary and thus we would push it in the stack. \\nFollowing the recursive approach, we do this for the entire path from that node onwards. \\nFinally we reverse the stack and output the path.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // build graph (mapping each string node to an interger)\\n        unordered_map<string,int> umap; //mapping: string node -> int node\\n        vector<string> mapping; // stores all the nodes as strings\\n        for(int i = 0; i<tickets.size(); i++){\\n            if(umap.find(tickets[i][0])==umap.end()){// using umap to check if the node has been added already\\n                umap[tickets[i][0]]=1;\\n                mapping.push_back(tickets[i][0]);\\n            }\\n            if(umap.find(tickets[i][1])==umap.end()){// using umap to check if the node has been added already\\n                umap[tickets[i][1]]=1;\\n                mapping.push_back(tickets[i][1]);\\n            }\\n        }\\n        // now mapping stores all the DISTINCT nodes as strings\\n        sort(mapping.begin(), mapping.end()); // sorting the nodes lexographically\\n        int n = mapping.size(); // n = number of nodes\\n        unordered_map<int,string> umap1; // mapping: int node -> string node\\n        for(int i = 0; i<n; i++){ //generating the map\\n            umap[mapping[i]]=i;\\n            umap1[i]=mapping[i];\\n        }\\n        int startNode = umap[\"JFK\"];// declaring the starting node (mapping it from string to int)\\n        vector<pair<int,int> > adj[n]; // pair<int, int> = pair<next node, visited/notvisited (1/0)>\\n        // building the graph\\n        for(int i = 0; i<tickets.size(); i++){\\n            int u = umap[tickets[i][0]];\\n            int v = umap[tickets[i][1]];\\n            adj[u].push_back(make_pair(v,1));\\n        }\\n        // sorting all adjacent nodes lexographically\\n        for(int i = 0; i<n; i++){\\n            sort(adj[i].begin(),adj[i].end());\\n        }\\n        stack<int> ans; // to store the path\\n        dfs(startNode,adj,ans);\\n        vector<string> an;\\n        while(!ans.empty()){\\n            an.push_back(umap1[ans.top()]);\\n            ans.pop();\\n        }\\n        return an;\\n    }\\nprivate:\\n    void dfs(int node, vector<pair<int,int> > adj[], stack<int> &ans){\\n        for(int i = 0; i<adj[node].size(); i++){\\n            if(adj[node][i].second){\\n                adj[node][i].second=0; //marking the edge visited\\n                dfs(adj[node][i].first,adj,ans);\\n            }\\n        }\\n        ans.push(node);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // build graph (mapping each string node to an interger)\\n        unordered_map<string,int> umap; //mapping: string node -> int node\\n        vector<string> mapping; // stores all the nodes as strings\\n        for(int i = 0; i<tickets.size(); i++){\\n            if(umap.find(tickets[i][0])==umap.end()){// using umap to check if the node has been added already\\n                umap[tickets[i][0]]=1;\\n                mapping.push_back(tickets[i][0]);\\n            }\\n            if(umap.find(tickets[i][1])==umap.end()){// using umap to check if the node has been added already\\n                umap[tickets[i][1]]=1;\\n                mapping.push_back(tickets[i][1]);\\n            }\\n        }\\n        // now mapping stores all the DISTINCT nodes as strings\\n        sort(mapping.begin(), mapping.end()); // sorting the nodes lexographically\\n        int n = mapping.size(); // n = number of nodes\\n        unordered_map<int,string> umap1; // mapping: int node -> string node\\n        for(int i = 0; i<n; i++){ //generating the map\\n            umap[mapping[i]]=i;\\n            umap1[i]=mapping[i];\\n        }\\n        int startNode = umap[\"JFK\"];// declaring the starting node (mapping it from string to int)\\n        vector<pair<int,int> > adj[n]; // pair<int, int> = pair<next node, visited/notvisited (1/0)>\\n        // building the graph\\n        for(int i = 0; i<tickets.size(); i++){\\n            int u = umap[tickets[i][0]];\\n            int v = umap[tickets[i][1]];\\n            adj[u].push_back(make_pair(v,1));\\n        }\\n        // sorting all adjacent nodes lexographically\\n        for(int i = 0; i<n; i++){\\n            sort(adj[i].begin(),adj[i].end());\\n        }\\n        stack<int> ans; // to store the path\\n        dfs(startNode,adj,ans);\\n        vector<string> an;\\n        while(!ans.empty()){\\n            an.push_back(umap1[ans.top()]);\\n            ans.pop();\\n        }\\n        return an;\\n    }\\nprivate:\\n    void dfs(int node, vector<pair<int,int> > adj[], stack<int> &ans){\\n        for(int i = 0; i<adj[node].size(); i++){\\n            if(adj[node][i].second){\\n                adj[node][i].second=0; //marking the edge visited\\n                dfs(adj[node][i].first,adj,ans);\\n            }\\n        }\\n        ans.push(node);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069543,
                "title": "java-hierholzer-algorithm-beats-99-64-4ms-o-tickets-length-log-tickets-length",
                "content": "\\n    \\n    // O(tickets.length*log(tickets.length))\\n\\tpublic List<String> findItinerary(List<List<String>> tickets) {\\n\\n\\t\\tHashMap<String, PriorityQueue<String>> graph = new HashMap<String, PriorityQueue<String>>();\\n\\t\\tfor (List<String> ticket : tickets) {\\n\\t\\t\\tString from = ticket.get(0);\\n\\t\\t\\tString to = ticket.get(1);\\n\\t\\t\\tif (!graph.containsKey(from))\\n\\t\\t\\t\\tgraph.put(from, new PriorityQueue<String>());\\n\\t\\t\\tgraph.get(from).add(to);\\n\\t\\t}\\n\\t\\tLinkedList<String> eularianPath = new LinkedList<String>();\\n\\t\\tHierHolzer(graph, \"JFK\", eularianPath);\\n\\t\\treturn eularianPath;\\n\\t}\\n\\n\\t// O(tickets.length*log(tickets.length))\\n\\tpublic void HierHolzer(HashMap<String, PriorityQueue<String>> graph, String curr, LinkedList<String> eularianPath) {\\n\\n\\t\\tPriorityQueue<String> heap = graph.get(curr);\\n\\t\\twhile (heap != null && heap.size() != 0) {\\n\\t\\t\\tString temp = heap.poll();\\n\\t\\t\\tHierHolzer(graph, temp, eularianPath);\\n\\t\\t}\\n\\t\\teularianPath.addFirst(curr);\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    \\n    // O(tickets.length*log(tickets.length))\\n\\tpublic List<String> findItinerary(List<List<String>> tickets) {\\n\\n\\t\\tHashMap<String, PriorityQueue<String>> graph = new HashMap<String, PriorityQueue<String>>();\\n\\t\\tfor (List<String> ticket : tickets) {\\n\\t\\t\\tString from = ticket.get(0);\\n\\t\\t\\tString to = ticket.get(1);\\n\\t\\t\\tif (!graph.containsKey(from))\\n\\t\\t\\t\\tgraph.put(from, new PriorityQueue<String>());\\n\\t\\t\\tgraph.get(from).add(to);\\n\\t\\t}\\n\\t\\tLinkedList<String> eularianPath = new LinkedList<String>();\\n\\t\\tHierHolzer(graph, \"JFK\", eularianPath);\\n\\t\\treturn eularianPath;\\n\\t}\\n\\n\\t// O(tickets.length*log(tickets.length))\\n\\tpublic void HierHolzer(HashMap<String, PriorityQueue<String>> graph, String curr, LinkedList<String> eularianPath) {\\n\\n\\t\\tPriorityQueue<String> heap = graph.get(curr);\\n\\t\\twhile (heap != null && heap.size() != 0) {\\n\\t\\t\\tString temp = heap.poll();\\n\\t\\t\\tHierHolzer(graph, temp, eularianPath);\\n\\t\\t}\\n\\t\\teularianPath.addFirst(curr);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1036205,
                "title": "topological-sort",
                "content": "```\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n//1.to have the adjacency list in sorted order we have used a priority queue.. this will resolve the problem of     lexographical order. you can dry run any tc in you will get it.\\n        HashMap<String,PriorityQueue<String>> map=new HashMap<>();\\n   \\n  //2. I have make the adjaceny list. I have add all the from(source) in my hashmap and corrosponding to that added to(destination) also..     \\n       for(List<String> ticket:tickets){\\n           String from=ticket.get(0);\\n           String to=ticket.get(1);\\n           \\n           if(map.containsKey(from)){\\n               map.get(from).add(to);\\n           }else{\\n               PriorityQueue<String> pq=new PriorityQueue<>();\\n               pq.add(to);\\n               map.put(from,pq);\\n           }\\n       }\\n        \\n      //3. I have used ArrayList here to return the list. can use linkedlist also to avoid the collection.reverse in line after topological sort(can use addFirst in linkedlist to avoid reverse).. but i have used arraylist here\\n        List<String> list=new ArrayList<>();\\n        topological_sort(map,\"JFK\",list);\\n        \\n        Collections.reverse(list);\\n        return list;\\n    }\\n    \\n    public static void topological_sort(HashMap<String,PriorityQueue<String>> map,String src,List<String> list){\\n  \\n            PriorityQueue<String> pq=map.get(src);\\n //4. we know that if there is something not present in map then map return null value.. so i have used pq!=null and if the size==0 means we have iterated all the neighbours..      \\n            while(pq!=null && pq.size()>0){\\n                String nbr=pq.remove();\\n                topological_sort(map,nbr,list);\\n            }\\n   //5.adding here (in post area of code ==> read topological sort if u not got it) because know i cannot visit anyplace from here.\\n         list.add(src);\\n    }\\n```\\n",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n//1.to have the adjacency list in sorted order we have used a priority queue.. this will resolve the problem of     lexographical order. you can dry run any tc in you will get it.\\n        HashMap<String,PriorityQueue<String>> map=new HashMap<>();\\n   \\n  //2. I have make the adjaceny list. I have add all the from(source) in my hashmap and corrosponding to that added to(destination) also..     \\n       for(List<String> ticket:tickets){\\n           String from=ticket.get(0);\\n           String to=ticket.get(1);\\n           \\n           if(map.containsKey(from)){\\n               map.get(from).add(to);\\n           }else{\\n               PriorityQueue<String> pq=new PriorityQueue<>();\\n               pq.add(to);\\n               map.put(from,pq);\\n           }\\n       }\\n        \\n      //3. I have used ArrayList here to return the list. can use linkedlist also to avoid the collection.reverse in line after topological sort(can use addFirst in linkedlist to avoid reverse).. but i have used arraylist here\\n        List<String> list=new ArrayList<>();\\n        topological_sort(map,\"JFK\",list);\\n        \\n        Collections.reverse(list);\\n        return list;\\n    }\\n    \\n    public static void topological_sort(HashMap<String,PriorityQueue<String>> map,String src,List<String> list){\\n  \\n            PriorityQueue<String> pq=map.get(src);\\n //4. we know that if there is something not present in map then map return null value.. so i have used pq!=null and if the size==0 means we have iterated all the neighbours..      \\n            while(pq!=null && pq.size()>0){\\n                String nbr=pq.remove();\\n                topological_sort(map,nbr,list);\\n            }\\n   //5.adding here (in post area of code ==> read topological sort if u not got it) because know i cannot visit anyplace from here.\\n         list.add(src);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 885386,
                "title": "java-dfs-solutions-using-stack-and-map",
                "content": "\\n```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        HashMap<String , PriorityQueue<String>> graph = new HashMap<>();\\n        \\n        for(List<String> ll : tickets){\\n           if(!graph.containsKey(ll.get(0))){\\n               graph.put(ll.get(0) , new PriorityQueue<>());\\n           }\\n           graph.get(ll.get(0)).add(ll.get(1));\\n        }\\n        Stack<String> st = new Stack<>();\\n        List<String> res = new ArrayList<>();\\n        dfs(graph , \"JFK\" , st);\\n        while(st.size()!=0){\\n          res.add(st.pop());\\n        }\\n        return res;\\n    }\\n   public void dfs(HashMap<String , PriorityQueue<String>> graph , String src , Stack<String> st){\\n      \\n        \\n        while(graph.containsKey(src) && graph.get(src).size()!=0){\\n          String nbr = graph.get(src).remove();\\n          dfs(graph , nbr , st);\\n        }\\n       st.push(src);\\n   }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        HashMap<String , PriorityQueue<String>> graph = new HashMap<>();\\n        \\n        for(List<String> ll : tickets){\\n           if(!graph.containsKey(ll.get(0))){\\n               graph.put(ll.get(0) , new PriorityQueue<>());\\n           }\\n           graph.get(ll.get(0)).add(ll.get(1));\\n        }\\n        Stack<String> st = new Stack<>();\\n        List<String> res = new ArrayList<>();\\n        dfs(graph , \"JFK\" , st);\\n        while(st.size()!=0){\\n          res.add(st.pop());\\n        }\\n        return res;\\n    }\\n   public void dfs(HashMap<String , PriorityQueue<String>> graph , String src , Stack<String> st){\\n      \\n        \\n        while(graph.containsKey(src) && graph.get(src).size()!=0){\\n          String nbr = graph.get(src).remove();\\n          dfs(graph , nbr , st);\\n        }\\n       st.push(src);\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843252,
                "title": "c-dfs-with-recursion",
                "content": "```csharp\\npublic class Solution {\\n    public IList<string> FindItinerary(IList<IList<string>> tickets) {\\n        var map = new Dictionary<string, List<string>>();\\n        foreach (var ticket in tickets) {\\n            if (!map.TryGetValue(ticket[0], out var adj))  {\\n                adj = new List<string>();\\n                map.Add(ticket[0], adj);\\n            }\\n            adj.Add(ticket[1]);\\n        }\\n        \\n        foreach (var adj in map.Values) {\\n            adj.Sort(Comparer<string>.Create((a, b) => string.Compare(b, a)));\\n        }\\n        \\n        var ans = new Stack<string>();\\n        Visit(map, \"JFK\", ans);\\n        return ans.ToList();\\n    }\\n    \\n    private void Visit(Dictionary<string, List<string>> map, string src, Stack<string> ans) {\\n        if (map.TryGetValue(src, out var adj)) {\\n            while (adj.Count > 0) {\\n                var next = adj.Last();\\n                adj.RemoveAt(adj.Count - 1);\\n                Visit(map, next, ans);\\n            }\\n        }\\n        ans.Push(src);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution {\\n    public IList<string> FindItinerary(IList<IList<string>> tickets) {\\n        var map = new Dictionary<string, List<string>>();\\n        foreach (var ticket in tickets) {\\n            if (!map.TryGetValue(ticket[0], out var adj))  {\\n                adj = new List<string>();\\n                map.Add(ticket[0], adj);\\n            }\\n            adj.Add(ticket[1]);\\n        }\\n        \\n        foreach (var adj in map.Values) {\\n            adj.Sort(Comparer<string>.Create((a, b) => string.Compare(b, a)));\\n        }\\n        \\n        var ans = new Stack<string>();\\n        Visit(map, \"JFK\", ans);\\n        return ans.ToList();\\n    }\\n    \\n    private void Visit(Dictionary<string, List<string>> map, string src, Stack<string> ans) {\\n        if (map.TryGetValue(src, out var adj)) {\\n            while (adj.Count > 0) {\\n                var next = adj.Last();\\n                adj.RemoveAt(adj.Count - 1);\\n                Visit(map, next, ans);\\n            }\\n        }\\n        ans.Push(src);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747113,
                "title": "c-dfs-and-backtracking",
                "content": "Naive Recursive Dfs + Backtracking solution. However the stack approach solution would be better/ easier.\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(unordered_map<string, vector<pair<string,int>>>&hash, int e, string index, vector<string>&ans, int count, vector<string>&fin){\\n        ans.push_back(index);\\n        if(count == e){\\n            fin = ans;\\n            return;\\n        }\\n        //vector<pair<string, int>> t = hash[index];\\n        for(int i = 0 ; i  < hash[index].size(); i++){\\n            if(!hash[index][i].second){\\n                hash[index][i].second = 1;\\n                dfs(hash,e,hash[index][i].first, ans, count+1,fin);\\n                if(fin == ans){\\n                    return;\\n                }\\n                hash[index][i].second = 0;\\n            }\\n        }\\n        ans.pop_back();\\n        return;\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& A) {\\n        int n = A.size();\\n        unordered_map<string, vector<pair<string,int>>>hash;\\n        for(int i = 0 ; i  < n ; i++){\\n            hash[A[i][0]].push_back({A[i][1], 0});\\n        }\\n        unordered_map<string, vector<pair<string,int>>>:: iterator it;\\n        for(it = hash.begin(); it !=hash.end(); it++){\\n            sort(it->second.begin(), it->second.end());\\n        }\\n        vector<string>ans;\\n        string src = \"JFK\";\\n        vector<string>fin;\\n        dfs(hash,n,src,ans,0,fin);\\n        return fin;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(unordered_map<string, vector<pair<string,int>>>&hash, int e, string index, vector<string>&ans, int count, vector<string>&fin){\\n        ans.push_back(index);\\n        if(count == e){\\n            fin = ans;\\n            return;\\n        }\\n        //vector<pair<string, int>> t = hash[index];\\n        for(int i = 0 ; i  < hash[index].size(); i++){\\n            if(!hash[index][i].second){\\n                hash[index][i].second = 1;\\n                dfs(hash,e,hash[index][i].first, ans, count+1,fin);\\n                if(fin == ans){\\n                    return;\\n                }\\n                hash[index][i].second = 0;\\n            }\\n        }\\n        ans.pop_back();\\n        return;\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& A) {\\n        int n = A.size();\\n        unordered_map<string, vector<pair<string,int>>>hash;\\n        for(int i = 0 ; i  < n ; i++){\\n            hash[A[i][0]].push_back({A[i][1], 0});\\n        }\\n        unordered_map<string, vector<pair<string,int>>>:: iterator it;\\n        for(it = hash.begin(); it !=hash.end(); it++){\\n            sort(it->second.begin(), it->second.end());\\n        }\\n        vector<string>ans;\\n        string src = \"JFK\";\\n        vector<string>fin;\\n        dfs(hash,n,src,ans,0,fin);\\n        return fin;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712324,
                "title": "aggregating-understandings-of-discussion-with-code",
                "content": "Before going into details about the problem some pre-requiste \\n\\n-Euler path:- It is a path in a graph which visists each edges exactly onces.\\n\\t\\t\\t\\t\\texample:- A->B,B->C,C->D,D->E,E->C\\n-Euler Circuit-> it is a Euler Path , where starting and end nodes are same.\\n\\t\\t\\t\\t\\texample:- A->B,B->C,C->D,D->E,E->C,C->A.\\n\\n\\nThe problem is  exactly printing the Euler path/Circuit.\\nExample:- A->B,A->C,C->D,D->E,E->C,C->A.\\n\\t\\t\\t\\t\\t![image](https://assets.leetcode.com/users/images/dc8e312f-b06e-4845-8356-17ee02810722_1593480106.6716752.png)\\n\\n\\nBecause the Euler Path for above graph is only one :- A->C->D->E->C->A->B.\\n\\nIf we carefully look into the above graph, the problem seems very similar to topological sort in reverse order(topological sort can be applied to only acylic DAG).To overcome the cyclic nature that can be present in this question, we will remove the edge once visited(making it acyclic).\\nNow we kinda do a topological sort and add nodes to result list in reverse.\\nTime complexity will remain O(V+E) and space as O(E)\\n\\n\\nInspired from @StefanPochmann soln , \\n\\n1st Solution is Recursive \\n2nd Soltuion is Stack based Iterative\\n```\\nclass Solution {\\n    Map<String, PriorityQueue<String>> targetMap = new HashMap<>();\\n    List<String> ans = new ArrayList<>();\\n    \\n    public List<String> findOrderRec(List<List<String>> tickets) {\\n      \\n        for(List<String> tick : tickets) {\\n            if(targetMap.get(tick.get(0)) == null) {\\n                targetMap.put(tick.get(0), new PriorityQueue<String>());\\n            } \\n            targetMap.get(tick.get(0)).add(tick.get(1));\\n        }\\n        visitDFS(\"JFK\");\\n        return ans;\\n    }\\n    \\n    public void visitDFS(String airport) {\\n        \\n        while(targetMap.get(airport) != null && targetMap.get(airport).size() > 0) {\\n            String nextAirport = targetMap.get(airport).poll();\\n            visitDFS(nextAirport);\\n        }\\n        \\n        ans.add(0, airport);\\n    }\\n    \\n    \\n    public List<String> findOrderIter(List<List<String>> tickets) {\\n        \\n        Map<String, PriorityQueue<String>> mapIter = new HashMap<>();\\n        List<String> resIter = new ArrayList<>();\\n        \\n        for(int i =0;i<tickets.size();i++) {\\n            \\n            if(mapIter.get(tickets.get(i).get(0)) == null) {\\n                mapIter.put(tickets.get(i).get(0), new PriorityQueue<String>());\\n            }\\n            mapIter.get(tickets.get(i).get(0)).add(tickets.get(i).get(1));\\n        }\\n        \\n        Stack<String> stack = new Stack<String> ();\\n        stack.push(\"JFK\");\\n        while(!stack.isEmpty()) {\\n            \\n            while(mapIter.get(stack.peek()) != null && mapIter.get(stack.peek()).size() > 0) {\\n                String nextAirport = mapIter.get(stack.peek()).poll();\\n                stack.push(nextAirport);\\n            }\\n            resIter.add(0, stack.pop());\\n            \\n        }\\n        return resIter;\\n    }\\n    \\n    \\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n//         O(V+E) time complexity and O(V) Space complexity\\n        // return findOrderRec(tickets);\\n        \\n        \\n//         Iterative Appraoch using Stack Based Approach\\n        return findOrderIter(tickets);\\n        \\n    }\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<String, PriorityQueue<String>> targetMap = new HashMap<>();\\n    List<String> ans = new ArrayList<>();\\n    \\n    public List<String> findOrderRec(List<List<String>> tickets) {\\n      \\n        for(List<String> tick : tickets) {\\n            if(targetMap.get(tick.get(0)) == null) {\\n                targetMap.put(tick.get(0), new PriorityQueue<String>());\\n            } \\n            targetMap.get(tick.get(0)).add(tick.get(1));\\n        }\\n        visitDFS(\"JFK\");\\n        return ans;\\n    }\\n    \\n    public void visitDFS(String airport) {\\n        \\n        while(targetMap.get(airport) != null && targetMap.get(airport).size() > 0) {\\n            String nextAirport = targetMap.get(airport).poll();\\n            visitDFS(nextAirport);\\n        }\\n        \\n        ans.add(0, airport);\\n    }\\n    \\n    \\n    public List<String> findOrderIter(List<List<String>> tickets) {\\n        \\n        Map<String, PriorityQueue<String>> mapIter = new HashMap<>();\\n        List<String> resIter = new ArrayList<>();\\n        \\n        for(int i =0;i<tickets.size();i++) {\\n            \\n            if(mapIter.get(tickets.get(i).get(0)) == null) {\\n                mapIter.put(tickets.get(i).get(0), new PriorityQueue<String>());\\n            }\\n            mapIter.get(tickets.get(i).get(0)).add(tickets.get(i).get(1));\\n        }\\n        \\n        Stack<String> stack = new Stack<String> ();\\n        stack.push(\"JFK\");\\n        while(!stack.isEmpty()) {\\n            \\n            while(mapIter.get(stack.peek()) != null && mapIter.get(stack.peek()).size() > 0) {\\n                String nextAirport = mapIter.get(stack.peek()).poll();\\n                stack.push(nextAirport);\\n            }\\n            resIter.add(0, stack.pop());\\n            \\n        }\\n        return resIter;\\n    }\\n    \\n    \\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n//         O(V+E) time complexity and O(V) Space complexity\\n        // return findOrderRec(tickets);\\n        \\n        \\n//         Iterative Appraoch using Stack Based Approach\\n        return findOrderIter(tickets);\\n        \\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 712050,
                "title": "java-clean-concise-optimal-code-depth-first-search-algorithm-100-faster-solution",
                "content": "```\\nclass Solution {\\n \\n\\tHashMap<String, PriorityQueue<String>> map = new HashMap<>();\\n\\tList<String> ans = new LinkedList<>();\\n\\t\\n\\tprivate void itineraryHelper (String s) {\\n\\t\\t\\n\\t\\tPriorityQueue<String> queue = map.get (s);\\n        \\n\\t\\twhile (queue != null && !queue.isEmpty ()) {\\n\\t\\t\\titineraryHelper (queue.poll ());\\n\\t\\t}\\n\\t\\t\\n\\t\\tans.add (0, s);\\n\\t}\\n\\t\\n\\tpublic List<String> findItinerary (List<List<String>> tickets) {\\n \\n\\t\\tfor (List<String> ticket : tickets) {\\n            if (!map.containsKey (ticket.get (0))) {\\n                map.put (ticket.get (0), new PriorityQueue<> ());\\n            }\\n            \\n            map.get (ticket.get (0)).offer (ticket.get (1));\\n\\t\\t}\\n\\t\\n\\t\\titineraryHelper (\"JFK\");\\n\\t\\treturn ans;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n \\n\\tHashMap<String, PriorityQueue<String>> map = new HashMap<>();\\n\\tList<String> ans = new LinkedList<>();\\n\\t\\n\\tprivate void itineraryHelper (String s) {\\n\\t\\t\\n\\t\\tPriorityQueue<String> queue = map.get (s);\\n        \\n\\t\\twhile (queue != null && !queue.isEmpty ()) {\\n\\t\\t\\titineraryHelper (queue.poll ());\\n\\t\\t}\\n\\t\\t\\n\\t\\tans.add (0, s);\\n\\t}\\n\\t\\n\\tpublic List<String> findItinerary (List<List<String>> tickets) {\\n \\n\\t\\tfor (List<String> ticket : tickets) {\\n            if (!map.containsKey (ticket.get (0))) {\\n                map.put (ticket.get (0), new PriorityQueue<> ());\\n            }\\n            \\n            map.get (ticket.get (0)).offer (ticket.get (1));\\n\\t\\t}\\n\\t\\n\\t\\titineraryHelper (\"JFK\");\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710861,
                "title": "python-another-greedy-dfs-explained-beats-97",
                "content": "The logic of this solution is very straight forward and efficient:\\n\\n1. Greedy Travel to get a **main path**, probably miss couple of sites.\\n2. Backtrack all **crossing sites**(`departure` with multiple `arrive`), from which we choose the smallest `arrive` thus miss others.\\n\\t-  We use `stack` here so that the last crossing site pop out first (LIFO).\\n3. Redo greedy travel beginning at crossing site.\\n4. Insert the missing travel **cycle path** into **main path**.\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        \\n        # Store all tickets into dict and sort\\n        self.path = collections.defaultdict(list)\\n        for depart, arrive in tickets:\\n            heapq.heappush(self.path[depart], arrive)\\n        \\n        return self.dfs(\\'JFK\\', [\\'JFK\\'], [])\\n        \\n    def dfs(self, depart, pre_path, cross):\\n        \"\"\"\\n        Greedy Travel!\\n        \\n        For each depart, start travelling with lexical order.\\n        For each cross point, add the point index into stack.\\n        After main path finished, backtrack each cross point and insert previously missing cycle branch path into main path.\\n        \\n        Args:\\n            depart: String, departure airport \\n            pre_path: List, visited path\\n            cross: List, stack to store crossings\\n        \\n        Returns: List, travel path\\n            \\n        \"\"\"\\n        while self.path[depart]:\\n            \\n            # Meet crossing, add index into cross\\n            if len(self.path[depart]) > 1:\\n                cross.append(len(pre_path) - 1)\\n            \\n            # Travel with the lexcial smallest airport\\n            depart = heapq.heappop(self.path[depart])\\n            pre_path.append(depart)\\n            \\n        # Check if there\\'s any crossing\\n        while cross:\\n            cross_idx = cross.pop()\\n            cross_depart = pre_path[cross_idx]\\n            \\n            # Insert the circle path into the crossing point\\n            pre_path[cross_idx:cross_idx + 1] = self.dfs(cross_depart, [cross_depart], [])\\n        return pre_path\\n```\\nPlease **Upvote** if it helps! \\uD83D\\uDE00",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        \\n        # Store all tickets into dict and sort\\n        self.path = collections.defaultdict(list)\\n        for depart, arrive in tickets:\\n            heapq.heappush(self.path[depart], arrive)\\n        \\n        return self.dfs(\\'JFK\\', [\\'JFK\\'], [])\\n        \\n    def dfs(self, depart, pre_path, cross):\\n        \"\"\"\\n        Greedy Travel!\\n        \\n        For each depart, start travelling with lexical order.\\n        For each cross point, add the point index into stack.\\n        After main path finished, backtrack each cross point and insert previously missing cycle branch path into main path.\\n        \\n        Args:\\n            depart: String, departure airport \\n            pre_path: List, visited path\\n            cross: List, stack to store crossings\\n        \\n        Returns: List, travel path\\n            \\n        \"\"\"\\n        while self.path[depart]:\\n            \\n            # Meet crossing, add index into cross\\n            if len(self.path[depart]) > 1:\\n                cross.append(len(pre_path) - 1)\\n            \\n            # Travel with the lexcial smallest airport\\n            depart = heapq.heappop(self.path[depart])\\n            pre_path.append(depart)\\n            \\n        # Check if there\\'s any crossing\\n        while cross:\\n            cross_idx = cross.pop()\\n            cross_depart = pre_path[cross_idx]\\n            \\n            # Insert the circle path into the crossing point\\n            pre_path[cross_idx:cross_idx + 1] = self.dfs(cross_depart, [cross_depart], [])\\n        return pre_path\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709649,
                "title": "c-dfs-detailed-explanation",
                "content": "The question is simple to understand. We just need to form an itinerary which will contain the names of airports which the person will visit in the same order. Our job is to find the order in which the person will visit the airport.\\n\\nWe will first create the adjacency list which will contain the information about the source and destination airports. One source airport may have multiple destinations in `tickets`; for example `[[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"ATL\", \"JFK\"]]`. We have to print the lexicographically smallest order. That is, our output for the above example should be `[\"JFK\", \"ATL\", \"JFK\", \"SFO\"]`. We can create a map of vector and sort for each key in the map.\\n\\nHowever, we can ease our pain by using a map of min heap instead. It will give us the lexicographically smallest airport. \\n\\nAfter reaching one destination, we have to reach the next destination according to our ticket, so it is better to use DFS instead of BFS. \\n\\nFor each visited node (airport), pop it from the priority_queue and perform dfs on the popped node. The implementation is as follows.\\n\\nPlease let me know in case you need any clarifications or if you find any mistake.\\n\\n```\\nclass Solution {\\nprivate:\\n\\tmap<string, priority_queue<string, vector<string>, greater<string>>> adj;\\n\\tvector<string> ans;\\n\\tvoid dfs(string src)\\n\\t{\\n\\t\\twhile(!adj[src].empty())\\n\\t\\t{\\n\\t\\t\\tstring s = adj[src].top();\\n\\t\\t\\tadj[src].pop();\\n\\t\\t\\tdfs(s);\\n\\t\\t}\\n\\t\\tans.insert(ans.begin(), src);\\n\\t}\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        \\n        adj.clear(), ans.clear();\\n        for(auto v : tickets)\\n            adj[v[0]].push(v[1]);\\n        dfs(\"JFK\"); // We have to start with JFK\\n        return ans;\\n    }\\n};\\n```\\n\\nIf you liked my explanation, could you please upvote? It gives me motivation to explain more problems in a simple way so that everyone can understand.",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\tmap<string, priority_queue<string, vector<string>, greater<string>>> adj;\\n\\tvector<string> ans;\\n\\tvoid dfs(string src)\\n\\t{\\n\\t\\twhile(!adj[src].empty())\\n\\t\\t{\\n\\t\\t\\tstring s = adj[src].top();\\n\\t\\t\\tadj[src].pop();\\n\\t\\t\\tdfs(s);\\n\\t\\t}\\n\\t\\tans.insert(ans.begin(), src);\\n\\t}\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        \\n        adj.clear(), ans.clear();\\n        for(auto v : tickets)\\n            adj[v[0]].push(v[1]);\\n        dfs(\"JFK\"); // We have to start with JFK\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 537998,
                "title": "java-dfs-backtracking",
                "content": "Full Detail:  https://medium.com/@hch.hkcontact/goldman-sachs-top-50-leetcode-questions-q25-reconstruct-itinerary-53130444b672\\n\\nSteps:\\nLoop over tickets,\\n- store the source position as a key and a sorted linked list of destination position as value in a hashmap\\n\\nWe need to backtrack all possible route\\n- the parameters are result list, the original map & a map contains boolean array to mark down which destination visited\\n- in each iteration, add the current point to the result list, mark down that it is visited in the map. After that, mark it back as not visited\\n- Recursion until the length of linked list = total flight + 1\\n\\n\\n```\\nclass Solution {\\n    List<String> rl;\\n    boolean found;\\n    \\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        HashMap<String, LinkedList<String>> map = new HashMap<>();\\n        HashMap<String, boolean[]> vedMap = new HashMap<String, boolean[]>();\\n        \\n        for(List<String> ticket:tickets){\\n            String from = ticket.get(0);\\n            String to = ticket.get(1);\\n            LinkedList<String> ls = map.getOrDefault(from, new LinkedList<String>());\\n            ls.add(to);\\n            map.put(from, ls);\\n        }\\n        \\n        for(String key:map.keySet()){\\n            int size = map.get(key).size();\\n            vedMap.put(key, new boolean[size]);\\n            Collections.sort(map.get(key), (a,b)->{\\n                return a.compareTo(b);\\n            });\\n        }\\n        \\n        // System.out.println(map);\\n        // System.out.println(vedMap);\\n                \\n        found=false;\\n        rl = new ArrayList<String>();\\n        List<String> ol = new ArrayList<String>(Arrays.asList(\"JFK\"));\\n        \\n        backTrack(map, vedMap, ol, \"JFK\", tickets.size()+1);\\n        \\n        return rl;\\n        \\n    }\\n    \\n    private void backTrack(HashMap<String, LinkedList<String>> map, HashMap<String, boolean[]> vedMap, List<String> result, String cur, int n){\\n        if(found) return;\\n        if(result.size()==n){\\n            rl= new ArrayList<>(result);\\n            found=true;\\n            return;\\n        }\\n        \\n        List<String> nextLs = map.get(cur);\\n        if(nextLs==null){\\n            return;\\n        }\\n        boolean[] ved = vedMap.get(cur);\\n        for(int i=0;i<nextLs.size();i++){\\n            if(ved[i]==true) continue;\\n            String to = nextLs.get(i);\\n            result.add(to);\\n            // System.out.println(result);\\n            vedMap.get(cur)[i]=true;\\n            \\n            backTrack(map, vedMap, result, to, n);\\n            \\n            result.remove(result.size()-1);\\n            vedMap.get(cur)[i]=false;\\n            \\n        }\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<String> rl;\\n    boolean found;\\n    \\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        HashMap<String, LinkedList<String>> map = new HashMap<>();\\n        HashMap<String, boolean[]> vedMap = new HashMap<String, boolean[]>();\\n        \\n        for(List<String> ticket:tickets){\\n            String from = ticket.get(0);\\n            String to = ticket.get(1);\\n            LinkedList<String> ls = map.getOrDefault(from, new LinkedList<String>());\\n            ls.add(to);\\n            map.put(from, ls);\\n        }\\n        \\n        for(String key:map.keySet()){\\n            int size = map.get(key).size();\\n            vedMap.put(key, new boolean[size]);\\n            Collections.sort(map.get(key), (a,b)->{\\n                return a.compareTo(b);\\n            });\\n        }\\n        \\n        // System.out.println(map);\\n        // System.out.println(vedMap);\\n                \\n        found=false;\\n        rl = new ArrayList<String>();\\n        List<String> ol = new ArrayList<String>(Arrays.asList(\"JFK\"));\\n        \\n        backTrack(map, vedMap, ol, \"JFK\", tickets.size()+1);\\n        \\n        return rl;\\n        \\n    }\\n    \\n    private void backTrack(HashMap<String, LinkedList<String>> map, HashMap<String, boolean[]> vedMap, List<String> result, String cur, int n){\\n        if(found) return;\\n        if(result.size()==n){\\n            rl= new ArrayList<>(result);\\n            found=true;\\n            return;\\n        }\\n        \\n        List<String> nextLs = map.get(cur);\\n        if(nextLs==null){\\n            return;\\n        }\\n        boolean[] ved = vedMap.get(cur);\\n        for(int i=0;i<nextLs.size();i++){\\n            if(ved[i]==true) continue;\\n            String to = nextLs.get(i);\\n            result.add(to);\\n            // System.out.println(result);\\n            vedMap.get(cur)[i]=true;\\n            \\n            backTrack(map, vedMap, result, to, n);\\n            \\n            result.remove(result.size()-1);\\n            vedMap.get(cur)[i]=false;\\n            \\n        }\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515336,
                "title": "java-simple-topological-sort-using-priority-queue",
                "content": "Solved it thinking its Topological Sort. Apparently its some fancy Algo :-/\\n\\n```\\npublic List<String> findItinerary(List<List<String>> tickets) {\\n        \\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        for(List<String> t : tickets) {\\n            String src = t.get(0);\\n            String dest = t.get(1);\\n            PriorityQueue<String> queue = new PriorityQueue<>();\\n            if(graph.containsKey(src)){\\n                queue = graph.get(src);\\n            }\\n            queue.offer(dest);\\n            graph.put(src, queue);\\n        }\\n        \\n        List<String> path = new ArrayList<>(); \\n        dfs(graph, path, \"JFK\");\\n        return path;\\n        \\n    }\\n    \\n    public static void dfs(Map<String, PriorityQueue<String>> graph, List<String> path, String cur) {\\n            PriorityQueue<String> queue = graph.get(cur);\\n            while(queue != null && !queue.isEmpty()) {\\n                String next = queue.poll();\\n                dfs(graph, path, next);\\n            }\\n            path.add(0,cur);\\n        }",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "Solved it thinking its Topological Sort. Apparently its some fancy Algo :-/\\n\\n```\\npublic List<String> findItinerary(List<List<String>> tickets) {\\n        \\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        for(List<String> t : tickets) {\\n            String src = t.get(0);\\n            String dest = t.get(1);\\n            PriorityQueue<String> queue = new PriorityQueue<>();\\n            if(graph.containsKey(src)){\\n                queue = graph.get(src);\\n            }\\n            queue.offer(dest);\\n            graph.put(src, queue);\\n        }\\n        \\n        List<String> path = new ArrayList<>(); \\n        dfs(graph, path, \"JFK\");\\n        return path;\\n        \\n    }\\n    \\n    public static void dfs(Map<String, PriorityQueue<String>> graph, List<String> path, String cur) {\\n            PriorityQueue<String> queue = graph.get(cur);\\n            while(queue != null && !queue.isEmpty()) {\\n                String next = queue.poll();\\n                dfs(graph, path, next);\\n            }\\n            path.add(0,cur);\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 471849,
                "title": "java-dfs-and-why-it-is-medium",
                "content": "//Need to explain this, since we have to loop all the edges, that means dfs will have to loop all arrivals until arrive the destination.\\n    //This is a perfect solvable graph, that is why it is medium question. If not perfect, we can return null, it becomes hard.\\n\\t\\n```\\nclass Solution {\\n    private Map<String, PriorityQueue<String>> m = new HashMap<>();\\n    private List<String> res =  new ArrayList<>();\\n    \\n    public List<String> findItinerary(List<List<String>> t) {\\n        int l = t.size();\\n        \\n        if (l == 0) return res;\\n        if (l == 1) return t.get(0);\\n        \\n        for (List<String> trip : t){\\n            String dep = trip.get(0);\\n            String arr = trip.get(1);\\n            PriorityQueue<String> q = new PriorityQueue<String>();\\n            if (m.containsKey(dep)){\\n                q = m.get(dep);\\n            }\\n            q.add(arr);\\n            m.put(dep, q);\\n        }\\n        \\n        dfs(\"JFK\");\\n        return res;\\n    }\\n\\n    private void dfs(String dep){\\n        PriorityQueue<String> q = m.get(dep);\\n        while(q != null && !q.isEmpty()){\\n            dfs(q.poll());\\n        }\\n        res.add(0, dep);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private Map<String, PriorityQueue<String>> m = new HashMap<>();\\n    private List<String> res =  new ArrayList<>();\\n    \\n    public List<String> findItinerary(List<List<String>> t) {\\n        int l = t.size();\\n        \\n        if (l == 0) return res;\\n        if (l == 1) return t.get(0);\\n        \\n        for (List<String> trip : t){\\n            String dep = trip.get(0);\\n            String arr = trip.get(1);\\n            PriorityQueue<String> q = new PriorityQueue<String>();\\n            if (m.containsKey(dep)){\\n                q = m.get(dep);\\n            }\\n            q.add(arr);\\n            m.put(dep, q);\\n        }\\n        \\n        dfs(\"JFK\");\\n        return res;\\n    }\\n\\n    private void dfs(String dep){\\n        PriorityQueue<String> q = m.get(dep);\\n        while(q != null && !q.isEmpty()){\\n            dfs(q.poll());\\n        }\\n        res.add(0, dep);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 457815,
                "title": "javascript-solution-dfs-backtracking",
                "content": "### The idea\\n1. Use DFS to explore every possible path, use backtracking to reset values during invalid paths.\\n``` javascript\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n    tickets.sort()\\n    let hash = {};\\n    for (let ticket of tickets) {\\n        if (!hash[ticket[0]]) hash[ticket[0]] = []; // \"from\" key\\n        if (!hash[ticket[1]]) hash[ticket[1]] = []; // \"to\" key\\n        hash[ticket[0]].push(ticket[1]);\\n    }\\n\\n    let res = [];\\n    let dfs = function(from, itinerary) {\\n        if (itinerary.length == tickets.length + 1) {\\n            res = itinerary;\\n            return true;\\n        }\\n        let len = hash[from].length;\\n        for (let i=0;i<len;i++) {\\n            let to = hash[from].shift();\\n            if (dfs(to, [...itinerary, to])) return itinerary;\\n            hash[from].push(to);\\n        }\\n        return false\\n    }\\n\\n    dfs(\"JFK\", [\"JFK\"]);\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n    tickets.sort()\\n    let hash = {};\\n    for (let ticket of tickets) {\\n        if (!hash[ticket[0]]) hash[ticket[0]] = []; // \"from\" key\\n        if (!hash[ticket[1]]) hash[ticket[1]] = []; // \"to\" key\\n        hash[ticket[0]].push(ticket[1]);\\n    }\\n\\n    let res = [];\\n    let dfs = function(from, itinerary) {\\n        if (itinerary.length == tickets.length + 1) {\\n            res = itinerary;\\n            return true;\\n        }\\n        let len = hash[from].length;\\n        for (let i=0;i<len;i++) {\\n            let to = hash[from].shift();\\n            if (dfs(to, [...itinerary, to])) return itinerary;\\n            hash[from].push(to);\\n        }\\n        return false\\n    }\\n\\n    dfs(\"JFK\", [\"JFK\"]);\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 449355,
                "title": "java-backtrack",
                "content": "```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        List<String> ans = new ArrayList<>();\\n        Map<String, List<String>> graph = new HashMap<>();\\n        for (List<String> ticket : tickets) {\\n            String s1 = ticket.get(0);\\n            String s2 = ticket.get(1);\\n            graph.putIfAbsent(s1, new ArrayList<>());\\n            graph.get(s1).add(s2);\\n        }\\n        for (List<String> neibs : graph.values()) {\\n            Collections.sort(neibs);\\n        }\\n        ans.add(\"JFK\");\\n        backTrack(\"JFK\", graph, ans, tickets.size() + 1);\\n        return ans;\\n    }\\n    public boolean backTrack(String cur, Map<String, List<String>> graph, List<String> ans, int n) {\\n        if (ans.size() == n) return true;\\n        List<String> neibs = graph.get(cur);\\n        if (neibs == null || neibs.isEmpty()) return false;\\n        int size = neibs.size();\\n        for (int i = 0; i < size; i++) {\\n            String neib = neibs.remove(i);\\n            ans.add(neib);\\n            if (backTrack(neib, graph, ans, n)) return true;\\n            ans.remove(ans.size() - 1);\\n            neibs.add(i, neib);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        List<String> ans = new ArrayList<>();\\n        Map<String, List<String>> graph = new HashMap<>();\\n        for (List<String> ticket : tickets) {\\n            String s1 = ticket.get(0);\\n            String s2 = ticket.get(1);\\n            graph.putIfAbsent(s1, new ArrayList<>());\\n            graph.get(s1).add(s2);\\n        }\\n        for (List<String> neibs : graph.values()) {\\n            Collections.sort(neibs);\\n        }\\n        ans.add(\"JFK\");\\n        backTrack(\"JFK\", graph, ans, tickets.size() + 1);\\n        return ans;\\n    }\\n    public boolean backTrack(String cur, Map<String, List<String>> graph, List<String> ans, int n) {\\n        if (ans.size() == n) return true;\\n        List<String> neibs = graph.get(cur);\\n        if (neibs == null || neibs.isEmpty()) return false;\\n        int size = neibs.size();\\n        for (int i = 0; i < size; i++) {\\n            String neib = neibs.remove(i);\\n            ans.add(neib);\\n            if (backTrack(neib, graph, ans, n)) return true;\\n            ans.remove(ans.size() - 1);\\n            neibs.add(i, neib);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 447582,
                "title": "java-clean-code-dfs-hierholzer-s-algorithm",
                "content": "``` \\npublic List<String> findItinerary(List<List<String>> tickets) {\\n        \\n        if (tickets == null || tickets.size() == 0) return null;\\n        \\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        \\n        for (List<String> ticket : tickets) {\\n            graph.putIfAbsent(ticket.get(0), new PriorityQueue<>());    \\n            graph.get(ticket.get(0)).offer(ticket.get(1));  // Assumption : The edge is [from, to] format\\n        }\\n        \\n        List<String> itinerary = new ArrayList<>();\\n        \\n        dfs(graph, \"JFK\", itinerary);\\n        \\n        return itinerary;\\n    }\\n    \\n    private void dfs(Map<String, PriorityQueue<String>> graph, \\n                     String from, List<String> itinerary) {\\n     \\n        PriorityQueue<String> adjacents = graph.getOrDefault(from, new PriorityQueue<>());\\n        \\n        while (!adjacents.isEmpty()) \\n            dfs(graph, adjacents.poll(), itinerary);\\n        \\n        itinerary.add(0, from); // Once all adjacents are traversed, add the graph node into itinerary\\n    }",
                "solutionTags": [],
                "code": "``` \\npublic List<String> findItinerary(List<List<String>> tickets) {\\n        \\n        if (tickets == null || tickets.size() == 0) return null;\\n        \\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        \\n        for (List<String> ticket : tickets) {\\n            graph.putIfAbsent(ticket.get(0), new PriorityQueue<>());    \\n            graph.get(ticket.get(0)).offer(ticket.get(1));  // Assumption : The edge is [from, to] format\\n        }\\n        \\n        List<String> itinerary = new ArrayList<>();\\n        \\n        dfs(graph, \"JFK\", itinerary);\\n        \\n        return itinerary;\\n    }\\n    \\n    private void dfs(Map<String, PriorityQueue<String>> graph, \\n                     String from, List<String> itinerary) {\\n     \\n        PriorityQueue<String> adjacents = graph.getOrDefault(from, new PriorityQueue<>());\\n        \\n        while (!adjacents.isEmpty()) \\n            dfs(graph, adjacents.poll(), itinerary);\\n        \\n        itinerary.add(0, from); // Once all adjacents are traversed, add the graph node into itinerary\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 445833,
                "title": "java-dfs-beats-100-map-with-priorityqueue",
                "content": "```\\nclass Solution {\\n    HashMap<String, PriorityQueue<String>> map;\\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        List<String> res = new ArrayList<>();\\n        if(tickets == null || tickets.size() == 0) return res;\\n\\n        map = new HashMap<>();\\n        for(List<String> ticket: tickets) {\\n            map.putIfAbsent(ticket.get(0), new PriorityQueue<String>());\\n            map.get(ticket.get(0)).add(ticket.get(1));\\n        }\\n        if(!map.containsKey(\"JFK\")) return res;\\n        dfs(\"JFK\", res);\\n        return res;\\n    }\\n    \\n    private void dfs(String start, List<String> res) {\\n        PriorityQueue<String> pq = map.get(start);\\n        while(pq != null && !pq.isEmpty()) {\\n            dfs(pq.poll(), res);\\n        }\\n        res.add(0, start);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<String, PriorityQueue<String>> map;\\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        List<String> res = new ArrayList<>();\\n        if(tickets == null || tickets.size() == 0) return res;\\n\\n        map = new HashMap<>();\\n        for(List<String> ticket: tickets) {\\n            map.putIfAbsent(ticket.get(0), new PriorityQueue<String>());\\n            map.get(ticket.get(0)).add(ticket.get(1));\\n        }\\n        if(!map.containsKey(\"JFK\")) return res;\\n        dfs(\"JFK\", res);\\n        return res;\\n    }\\n    \\n    private void dfs(String start, List<String> res) {\\n        PriorityQueue<String> pq = map.get(start);\\n        while(pq != null && !pq.isEmpty()) {\\n            dfs(pq.poll(), res);\\n        }\\n        res.add(0, start);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 438846,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n     \\n        length= len(tickets)+1\\n        graph= collections.defaultdict(list)\\n        \\n        for ticket in tickets:\\n            graph[ticket[0]].append(ticket[1])\\n        \\n        for g in graph:\\n            graph[g].sort()\\n            \\n        self.answer=[]\\n        def dfs(node, result):\\n            if len(result)== length:\\n                self.answer= result\\n                return True\\n            res= False\\n            for i,n in enumerate(graph[node]):\\n                if n!= \\'#\\':\\n                    city= n\\n                    graph[node][i]= \\'#\\'\\n                    result.append(city)\\n                    res= dfs(city, result)\\n                    if res:\\n                        return res\\n                    graph[node][i]= city\\n                    result.pop()\\n            return res\\n            \\n        dfs(\\'JFK\\', [\\'JFK\\'])\\n        \\n        return self.answer\\n            \\n        \\n        \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n     \\n        length= len(tickets)+1\\n        graph= collections.defaultdict(list)\\n        \\n        for ticket in tickets:\\n            graph[ticket[0]].append(ticket[1])\\n        \\n        for g in graph:\\n            graph[g].sort()\\n            \\n        self.answer=[]\\n        def dfs(node, result):\\n            if len(result)== length:\\n                self.answer= result\\n                return True\\n            res= False\\n            for i,n in enumerate(graph[node]):\\n                if n!= \\'#\\':\\n                    city= n\\n                    graph[node][i]= \\'#\\'\\n                    result.append(city)\\n                    res= dfs(city, result)\\n                    if res:\\n                        return res\\n                    graph[node][i]= city\\n                    result.pop()\\n            return res\\n            \\n        dfs(\\'JFK\\', [\\'JFK\\'])\\n        \\n        return self.answer\\n            \\n        \\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 389327,
                "title": "super-short-clear-c-dfs-with-priority-queue-95",
                "content": "```\\nclass Solution {\\n    typedef unordered_map<string, priority_queue<string, vector<string>, greater<string>>> GraphType;\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        \\n        GraphType graph;\\n        vector<string> res;\\n        \\n        for (auto t : tickets)\\n            graph[t[0]].push(t[1]);\\n        \\n        dfs(\"JFK\", graph, res);\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    \\n    void dfs(string str, GraphType& graph, vector<string>& res) {\\n        \\n        auto & v = graph[str];\\n        while (!v.empty()) {\\n            \\n            auto cur = v.top();\\n            v.pop();\\n            dfs(cur, graph, res);\\n        }\\n        \\n        res.push_back(str);\\n     }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    typedef unordered_map<string, priority_queue<string, vector<string>, greater<string>>> GraphType;\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        \\n        GraphType graph;\\n        vector<string> res;\\n        \\n        for (auto t : tickets)\\n            graph[t[0]].push(t[1]);\\n        \\n        dfs(\"JFK\", graph, res);\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    \\n    void dfs(string str, GraphType& graph, vector<string>& res) {\\n        \\n        auto & v = graph[str];\\n        while (!v.empty()) {\\n            \\n            auto cur = v.top();\\n            v.pop();\\n            dfs(cur, graph, res);\\n        }\\n        \\n        res.push_back(str);\\n     }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352144,
                "title": "python3-simple-stack-solution",
                "content": "1, sort from/to pairs in lexical order, and store them in dict.\\n2, start the route with current city in the smallest lexical order, it may not cover all the cities, but it is still a valid route because eventually you will go through.\\n3, append the last city to the end, and loop 2 -> 3 till all cities are visited.\\n \\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph = collections.defaultdict(collections.deque)\\n        for i, j in sorted(tickets):\\n            graph[i].append(j)\\n        route, stack = [], [\\'JFK\\']\\n        while stack:\\n            while graph[stack[-1]]:\\n                stack.append(graph[stack[-1]].popleft())\\n            route += stack.pop(),\\n        return route[::-1]",
                "solutionTags": [],
                "code": "1, sort from/to pairs in lexical order, and store them in dict.\\n2, start the route with current city in the smallest lexical order, it may not cover all the cities, but it is still a valid route because eventually you will go through.\\n3, append the last city to the end, and loop 2 -> 3 till all cities are visited.\\n \\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph = collections.defaultdict(collections.deque)\\n        for i, j in sorted(tickets):\\n            graph[i].append(j)\\n        route, stack = [], [\\'JFK\\']\\n        while stack:\\n            while graph[stack[-1]]:\\n                stack.append(graph[stack[-1]].popleft())\\n            route += stack.pop(),\\n        return route[::-1]",
                "codeTag": "Java"
            },
            {
                "id": 335448,
                "title": "python3-dfs",
                "content": "```\\nfrom collections import defaultdict, deque\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        \\n        def make_graph():\\n            for depart, arrival in tickets:\\n                tickets_graph[depart].append(arrival)\\n            return tickets_graph\\n                \\n        def dfs_helper(curr_city = \"JFK\", temp_itenary = []):\\n            \\n            if len(temp_itenary) == len_itenary:\\n                return temp_itenary + [curr_city]\\n            \\n            if curr_city not in tickets_graph: # we have reached a deadend\\n                return None\\n            \\n            for next_city in sorted(tickets_graph[curr_city]):\\n                tickets_graph[curr_city].remove(next_city) #to avoid indefinite cycles\\n                solution = dfs_helper(next_city, temp_itenary+[curr_city])\\n                if solution: return solution #return as soon as path found\\n                tickets_graph[curr_city].append(next_city)\\n            \\n        tickets_graph = defaultdict(list)\\n        make_graph()\\n        len_itenary = len(tickets)\\n        return dfs_helper()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict, deque\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        \\n        def make_graph():\\n            for depart, arrival in tickets:\\n                tickets_graph[depart].append(arrival)\\n            return tickets_graph\\n                \\n        def dfs_helper(curr_city = \"JFK\", temp_itenary = []):\\n            \\n            if len(temp_itenary) == len_itenary:\\n                return temp_itenary + [curr_city]\\n            \\n            if curr_city not in tickets_graph: # we have reached a deadend\\n                return None\\n            \\n            for next_city in sorted(tickets_graph[curr_city]):\\n                tickets_graph[curr_city].remove(next_city) #to avoid indefinite cycles\\n                solution = dfs_helper(next_city, temp_itenary+[curr_city])\\n                if solution: return solution #return as soon as path found\\n                tickets_graph[curr_city].append(next_city)\\n            \\n        tickets_graph = defaultdict(list)\\n        make_graph()\\n        len_itenary = len(tickets)\\n        return dfs_helper()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327635,
                "title": "python3-hierholzer-s-algorithm",
                "content": "Following this article: https://www.geeksforgeeks.org/hierholzers-algorithm-directed-graph/\\nAnd find a circuit. Hmm maybe to get this optimal solution in an interview I need to memorize this.\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        tickets.sort(key=lambda x: x[1], reverse=True)\\n        m = {}\\n        for t in tickets:\\n            if t[0] not in m:\\n                m[t[0]] = [t[1]]\\n            else:\\n                m[t[0]].append(t[1])\\n        \\n        circuit = []\\n        curpath = [\\'JFK\\']\\n        while curpath:\\n            if curpath[-1] in m and m[curpath[-1]]:\\n                next = m[curpath[-1]].pop()\\n                curpath.append(next)\\n            else:\\n                circuit.append(curpath[-1])\\n                curpath.pop()\\n        return circuit[::-1]\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        tickets.sort(key=lambda x: x[1], reverse=True)\\n        m = {}\\n        for t in tickets:\\n            if t[0] not in m:\\n                m[t[0]] = [t[1]]\\n            else:\\n                m[t[0]].append(t[1])\\n        \\n        circuit = []\\n        curpath = [\\'JFK\\']\\n        while curpath:\\n            if curpath[-1] in m and m[curpath[-1]]:\\n                next = m[curpath[-1]].pop()\\n                curpath.append(next)\\n            else:\\n                circuit.append(curpath[-1])\\n                curpath.pop()\\n        return circuit[::-1]\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 322050,
                "title": "javascript-solution",
                "content": "https://github.com/bobwei/leetcode-v7/blob/master/src/leetcode/reconstruct-itinerary/index.js\\n\\n```js\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n  const graph = createGraph(tickets);\\n  const output = dfs(graph, \\'JFK\\');\\n  return output.reverse();\\n};\\n\\nfunction dfs(graph, u, output = []) {\\n  const neighbors = graph[u] || [];\\n  while (neighbors.length) {\\n    const v = neighbors.shift();\\n    dfs(graph, v, output);\\n  }\\n  output.push(u);\\n  return output;\\n}\\n\\nfunction createGraph(tickets) {\\n  const graph = {};\\n  for (const [from, to] of tickets) {\\n    if (!(from in graph)) graph[from] = [];\\n    graph[from].push(to);\\n  }\\n  for (const key in graph) {\\n    graph[key].sort();\\n  }\\n  return graph;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n  const graph = createGraph(tickets);\\n  const output = dfs(graph, \\'JFK\\');\\n  return output.reverse();\\n};\\n\\nfunction dfs(graph, u, output = []) {\\n  const neighbors = graph[u] || [];\\n  while (neighbors.length) {\\n    const v = neighbors.shift();\\n    dfs(graph, v, output);\\n  }\\n  output.push(u);\\n  return output;\\n}\\n\\nfunction createGraph(tickets) {\\n  const graph = {};\\n  for (const [from, to] of tickets) {\\n    if (!(from in graph)) graph[from] = [];\\n    graph[from].push(to);\\n  }\\n  for (const key in graph) {\\n    graph[key].sort();\\n  }\\n  return graph;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 308872,
                "title": "c-dfs-add-result-after-go-through-all-paths-remove-node-for-circular",
                "content": "```\\npublic class Solution {\\n    public IList<string> FindItinerary(IList<IList<string>> tickets) {\\n        var adjacencyMatrix = new Dictionary<string, List<string>>();\\n\\n        var result = new List<string>();\\n\\n        foreach (var ticket in tickets) {\\n            var from = ticket[0];\\n            var to = ticket[1];\\n\\n            if (!adjacencyMatrix.ContainsKey(from)) {\\n                adjacencyMatrix[from] = new List<string>();\\n            }\\n\\n            if (!adjacencyMatrix.ContainsKey(to)) {\\n                adjacencyMatrix[to] = new List<string>();\\n            }\\n\\n            adjacencyMatrix[from].Add(to);\\n        }\\n\\n        // Sort all lists\\n        foreach (var value in adjacencyMatrix.Values) {\\n            value.Sort();\\n        }\\n\\n        DFS(adjacencyMatrix, \"JFK\", result);\\n\\n        result.Reverse();\\n\\n        return result;\\n    }\\n\\n    private void DFS(Dictionary<string, List<string>> adjacencyMatrix, string cur, IList<string> result) {\\n        while (adjacencyMatrix[cur].Any()) {\\n            var next = adjacencyMatrix[cur].First();\\n            adjacencyMatrix[cur].Remove(next);\\n            DFS(adjacencyMatrix, next, result);\\n        }\\n        result.Add(cur);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> FindItinerary(IList<IList<string>> tickets) {\\n        var adjacencyMatrix = new Dictionary<string, List<string>>();\\n\\n        var result = new List<string>();\\n\\n        foreach (var ticket in tickets) {\\n            var from = ticket[0];\\n            var to = ticket[1];\\n\\n            if (!adjacencyMatrix.ContainsKey(from)) {\\n                adjacencyMatrix[from] = new List<string>();\\n            }\\n\\n            if (!adjacencyMatrix.ContainsKey(to)) {\\n                adjacencyMatrix[to] = new List<string>();\\n            }\\n\\n            adjacencyMatrix[from].Add(to);\\n        }\\n\\n        // Sort all lists\\n        foreach (var value in adjacencyMatrix.Values) {\\n            value.Sort();\\n        }\\n\\n        DFS(adjacencyMatrix, \"JFK\", result);\\n\\n        result.Reverse();\\n\\n        return result;\\n    }\\n\\n    private void DFS(Dictionary<string, List<string>> adjacencyMatrix, string cur, IList<string> result) {\\n        while (adjacencyMatrix[cur].Any()) {\\n            var next = adjacencyMatrix[cur].First();\\n            adjacencyMatrix[cur].Remove(next);\\n            DFS(adjacencyMatrix, next, result);\\n        }\\n        result.Add(cur);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 298491,
                "title": "treeset-vs-priorityqueue-can-someone-explain",
                "content": "I don\\'t understand why this code doesn\\'t work. TreeSet is sorted so as PriorityQueue, to me it looks the same, if I replace TreeSet with PriorityQueue everything works just fine and pass all the tests. I\\'m stuck.\\n\\n```\\nprivate Map<String, TreeSet<String>> graph;\\n\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        graph = new HashMap<>();\\n\\n        for (List<String> pair : tickets) {\\n            if (!graph.containsKey(pair.get(0)))\\n                graph.put(pair.get(0), new TreeSet<String>());\\n\\n            graph.get(pair.get(0)).add(pair.get(1));\\n        }\\n\\n        List<String> result = new ArrayList<>();\\n\\n        dfs(\"JFK\", graph, result);\\n\\n        return result;\\n    }\\n\\n    private void dfs(String origin, Map<String, TreeSet<String>> graph, List<String> result) {\\n        while (graph.containsKey(origin) && !graph.get(origin).isEmpty()) {\\n            String destination = graph.get(origin).pollFirst();\\n            dfs(destination, graph, result);\\n        }\\n\\n        result.add(0, origin);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate Map<String, TreeSet<String>> graph;\\n\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        graph = new HashMap<>();\\n\\n        for (List<String> pair : tickets) {\\n            if (!graph.containsKey(pair.get(0)))\\n                graph.put(pair.get(0), new TreeSet<String>());\\n\\n            graph.get(pair.get(0)).add(pair.get(1));\\n        }\\n\\n        List<String> result = new ArrayList<>();\\n\\n        dfs(\"JFK\", graph, result);\\n\\n        return result;\\n    }\\n\\n    private void dfs(String origin, Map<String, TreeSet<String>> graph, List<String> result) {\\n        while (graph.containsKey(origin) && !graph.get(origin).isEmpty()) {\\n            String destination = graph.get(origin).pollFirst();\\n            dfs(destination, graph, result);\\n        }\\n\\n        result.add(0, origin);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 293270,
                "title": "assumption-3-makes-this-problem-no-brainer",
                "content": "Shouldn\\'t have assumption 3 there. \\n\\n```\\nYou may assume all tickets form at least one valid itinerary.\\n```\\n\\nI don\\'t see any \\'backtracking\\' operation with this assumpt being there. \\n\\nIt should say\\n\\n```\\nAll tickets should be used. \\nReturn the itinerary with smallest lexical order, or null if we cannot find a valid itinerary\\n```",
                "solutionTags": [],
                "code": "```\\nYou may assume all tickets form at least one valid itinerary.\\n```\n```\\nAll tickets should be used. \\nReturn the itinerary with smallest lexical order, or null if we cannot find a valid itinerary\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 180895,
                "title": "swift-solution-100ms",
                "content": "```\\nclass Solution {\\n    var targets = [String : [String]]()\\n    var route = [String]()\\n   \\n    func findItinerary(_ tickets: [[String]]) -> [String] {\\n        for ticket in tickets {\\n            if targets[ticket[0]] == nil {\\n                targets[ticket[0]] = [ticket[1]]\\n            } else {\\n                targets[ticket[0]]!.append(ticket[1])\\n            }\\n        }\\n        for ticket in tickets {\\n            targets[ticket[0]] = targets[ticket[0]]!.sorted()\\n        }\\n        visit(\"JFK\")\\n        return route.reversed()\\n    }\\n    \\n    func visit(_ airport: String) {\\n        if targets[airport] != nil {\\n            while targets[airport]!.count > 0 {\\n                if let next = targets[airport]!.first {\\n                    targets[airport]!.removeFirst()\\n                    visit(next)\\n                }\\n            }\\n        }\\n        route.append(airport)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var targets = [String : [String]]()\\n    var route = [String]()\\n   \\n    func findItinerary(_ tickets: [[String]]) -> [String] {\\n        for ticket in tickets {\\n            if targets[ticket[0]] == nil {\\n                targets[ticket[0]] = [ticket[1]]\\n            } else {\\n                targets[ticket[0]]!.append(ticket[1])\\n            }\\n        }\\n        for ticket in tickets {\\n            targets[ticket[0]] = targets[ticket[0]]!.sorted()\\n        }\\n        visit(\"JFK\")\\n        return route.reversed()\\n    }\\n    \\n    func visit(_ airport: String) {\\n        if targets[airport] != nil {\\n            while targets[airport]!.count > 0 {\\n                if let next = targets[airport]!.first {\\n                    targets[airport]!.removeFirst()\\n                    visit(next)\\n                }\\n            }\\n        }\\n        route.append(airport)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148387,
                "title": "python-easy-to-understand-solution-with-no-dfs-just-sort-and-hash-table",
                "content": "I think this is more intuitive. You process all the tickets then sort the destinations by lexical order. Afterwards you process each itinerary one by one using your sorted destinations. The end array is for processing final destinations in the end.\\n```\\nclass Solution:\\n    def findItinerary(self, tickets):\\n        d = {}\\n        for ticket in tickets:\\n            if ticket[0] not in d:\\n                d[ticket[0]] = [ticket[1]]\\n            else:\\n                d[ticket[0]].append(ticket[1])\\n                \\n        for ticket in d:\\n            d[ticket].sort()\\n        \\n        res = [\\'JFK\\']\\n        end = []\\n        while d:\\n            if res[-1] not in d:\\n                end.append(res[-1])\\n                res.pop()\\n                continue\\n            fr, to = res[-1], d[res[-1]].pop(0)\\n            res.append(to)\\n            if len(d[fr]) == 0:\\n                d.pop(fr)\\n        \\n        if end:\\n            res += end[::-1]\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findItinerary(self, tickets):\\n        d = {}\\n        for ticket in tickets:\\n            if ticket[0] not in d:\\n                d[ticket[0]] = [ticket[1]]\\n            else:\\n                d[ticket[0]].append(ticket[1])\\n                \\n        for ticket in d:\\n            d[ticket].sort()\\n        \\n        res = [\\'JFK\\']\\n        end = []\\n        while d:\\n            if res[-1] not in d:\\n                end.append(res[-1])\\n                res.pop()\\n                continue\\n            fr, to = res[-1], d[res[-1]].pop(0)\\n            res.append(to)\\n            if len(d[fr]) == 0:\\n                d.pop(fr)\\n        \\n        if end:\\n            res += end[::-1]\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126087,
                "title": "i-don-t-understand-this-test-case-output",
                "content": "For the given input\\n\\n```[[\"EZE\",\"TIA\"],[\"EZE\",\"HBA\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AXA\"],[\"ANU\",\"JFK\"],[\"ADL\",\"ANU\"],[\"TIA\",\"AUA\"],[\"ANU\",\"AUA\"],[\"ADL\",\"EZE\"],[\"ADL\",\"EZE\"],[\"EZE\",\"ADL\"],[\"AXA\",\"EZE\"],[\"AUA\",\"AXA\"],[\"JFK\",\"AXA\"],[\"AXA\",\"AUA\"],[\"AUA\",\"ADL\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ADL\"],[\"EZE\",\"ANU\"],[\"AUA\",\"ANU\"]]```\\n\\nhere\\'s the expected output\\n```[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"AUA\",\"AXA\",\"TIA\",\"ADL\",\"EZE\",\"HBA\"]```\\n\\nhere\\'s my output\\n```[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"ADL\",\"EZE\",\"AUA\",\"AXA\",\"TIA\",\"HBA\"]```\\n\\nmy output divert from the expected output at ```TIA -> ADL``` vs. ```TIA -> AUA```. From lexical order, isn\\'t my output is smaller than the expected output?",
                "solutionTags": [],
                "code": "```[[\"EZE\",\"TIA\"],[\"EZE\",\"HBA\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AXA\"],[\"ANU\",\"JFK\"],[\"ADL\",\"ANU\"],[\"TIA\",\"AUA\"],[\"ANU\",\"AUA\"],[\"ADL\",\"EZE\"],[\"ADL\",\"EZE\"],[\"EZE\",\"ADL\"],[\"AXA\",\"EZE\"],[\"AUA\",\"AXA\"],[\"JFK\",\"AXA\"],[\"AXA\",\"AUA\"],[\"AUA\",\"ADL\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ADL\"],[\"EZE\",\"ANU\"],[\"AUA\",\"ANU\"]]```\n```[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"AUA\",\"AXA\",\"TIA\",\"ADL\",\"EZE\",\"HBA\"]```\n```[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"ADL\",\"EZE\",\"AUA\",\"AXA\",\"TIA\",\"HBA\"]```\n```TIA -> ADL```\n```TIA -> AUA```",
                "codeTag": "Unknown"
            },
            {
                "id": 78844,
                "title": "javascript-solution-160ms-inspired-by-java-greedy-solution",
                "content": "Inspired by [Java Greedy Solution][1] , here is the javascript code. Here is the thought:\\n\\n1. Sort the tickets with alphabetical, then generate a \"hash map\" to store all tickets with key-value.\\n\\n2. After got the alphabetical hash map, get the results with greedy strategy. This is like the DFS.\\n \\n3. Once got one best way and there are still tickets left, need to go back (say point x) and find another way. Since there always a way to have all tickets, so at point x, there wil be one or more circles. \\n\\n`\\n\\n    var findItinerary = function(tickets) {\\n        if (tickets == null || tickets.length == 0) return [];\\n        var map = {};\\n        var result = [];\\n        \\n        tickets.sort(sortArray);\\n        for(var i = 0; i < tickets.length; i++) {\\n            if(tickets[i][0] in map) map[tickets[i][0]].push(tickets[i][1]);\\n            else map[tickets[i][0]] = [tickets[i][1]];\\n        }\\n        \\n        var key = 'JFK';\\n        var drawback = [];\\n        for(var i = 0; i < tickets.length; i++) {\\n            while(!(key in map) || map[key].length == 0) {\\n                drawback.push(key);\\n                key = result.pop();\\n            }\\n            result.push(key);\\n            key = map[key].shift();\\n        }\\n        result.push(key);\\n        while(drawback.length > 0) result.push(drawback.pop());\\n    \\n        return result;\\n        \\n                        \\n    };\\n    \\n    function sortArray(a,b) {\\n        if(a[0] == b[0]) return (a[1] < b[1] ? -1: (a[1] > b[1] ? 1: 0));\\n    \\n        return (a[0] < b[0] ? -1 : 1);\\n    }\\n\\n\\n\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/84706/share-solution-java-greedy-stack-15ms-with-explanation",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "Inspired by [Java Greedy Solution][1] , here is the javascript code. Here is the thought:\\n\\n1. Sort the tickets with alphabetical, then generate a \"hash map\" to store all tickets with key-value.\\n\\n2. After got the alphabetical hash map, get the results with greedy strategy. This is like the DFS.\\n \\n3. Once got one best way and there are still tickets left, need to go back (say point x) and find another way. Since there always a way to have all tickets, so at point x, there wil be one or more circles. \\n\\n`\\n\\n    var findItinerary = function(tickets) {\\n        if (tickets == null || tickets.length == 0) return [];\\n        var map = {};\\n        var result = [];\\n        \\n        tickets.sort(sortArray);\\n        for(var i = 0; i < tickets.length; i++) {\\n            if(tickets[i][0] in map) map[tickets[i][0]].push(tickets[i][1]);\\n            else map[tickets[i][0]] = [tickets[i][1]];\\n        }\\n        \\n        var key = 'JFK';\\n        var drawback = [];\\n        for(var i = 0; i < tickets.length; i++) {\\n            while(!(key in map) || map[key].length == 0) {\\n                drawback.push(key);\\n                key = result.pop();\\n            }\\n            result.push(key);\\n            key = map[key].shift();\\n        }\\n        result.push(key);\\n        while(drawback.length > 0) result.push(drawback.pop());\\n    \\n        return result;\\n        \\n                        \\n    };\\n    \\n    function sortArray(a,b) {\\n        if(a[0] == b[0]) return (a[1] < b[1] ? -1: (a[1] > b[1] ? 1: 0));\\n    \\n        return (a[0] < b[0] ? -1 : 1);\\n    }\\n\\n\\n\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/84706/share-solution-java-greedy-stack-15ms-with-explanation",
                "codeTag": "Unknown"
            },
            {
                "id": 78866,
                "title": "share-my-clean-java-code-with-comments-standard-dfs",
                "content": "    /*\\n        -- dfs\\n        -- JFK -- ATL\\n               |\\n               |- SFO\\n               |\\n               --\\n           hashmap <from, list_of_to>, and list_of_to should be sorted.\\n        -- \\u53ea\\u8981\\u641c\\u7d22\\u5230\\u90a3\\u4e2a\\u6700\\u5c0f\\u7684\\u7ed3\\u679c\\u5373\\u53ef\\u505c\\u6b62\\n    */\\n    public class Solution {\\n        public List<String> findItinerary(String[][] tickets) {\\n            Map<String, List<String>> ticketInfo = new HashMap<>();\\n            for (String[] ticket: tickets) {\\n                List<String> destList = ticketInfo.get(ticket[0]);\\n                if (destList == null) {\\n                    destList = new ArrayList<String>();\\n                    ticketInfo.put(ticket[0], destList);\\n                }\\n                destList.add(ticket[1]);\\n            }\\n            for (List<String> destList: ticketInfo.values()) {\\n                Collections.sort(destList);\\n            }\\n            List<String> ans = new ArrayList<>();\\n            ans.add(\"JFK\");\\n            dfs(ans, new ArrayList<String>(), ticketInfo, \"JFK\", tickets.length);\\n            return ans;\\n        }\\n        \\n        private void dfs(List<String> ans, List<String> cur, Map<String, List<String>> ticketInfo, String src, int targetSize) {\\n            if (ans.size() > 1) { return; }  // only need to find the smallest answer\\n            if (cur.size() == targetSize) {  // the smallest answer found\\n                ans.addAll(cur);\\n                return;\\n            }\\n            List<String> destList = ticketInfo.get(src);\\n            if (destList != null) {\\n                for (int i = 0; i < destList.size(); ++i) {\\n                    String dest = destList.remove(i);  // remove this dest so that it will not be visited again\\n                    cur.add(dest);\\n                    dfs(ans, cur, ticketInfo, dest, targetSize);\\n                    cur.remove(cur.size() - 1);\\n                    destList.add(i, dest);  // add this dest back in the list, at its original position\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<String> findItinerary(String[][] tickets) {\\n            Map<String, List<String>> ticketInfo = new HashMap<>();\\n            for (String[] ticket: tickets) {\\n                List<String> destList = ticketInfo.get(ticket[0]);\\n                if (destList == null) {\\n                    destList = new ArrayList<String>();\\n                    ticketInfo.put(ticket[0], destList);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4043426,
                "title": "graph-java-easy-arraylist-map",
                "content": "This qus is basically the extension of the graph qus **where we have to find the path from the given  virteces  to the whole virteces in directed graph ... **\\n\\nThere we deal with the integer here we are dealing with the string .. \\nOne thing to check is the we have to use backtraking first delete that node from the list and then add after that in dfs .. **Why ?**\\nBcz if we have adjList like  = \"jfk\" - {\"atl\",\"now\"} , \"atl\" - {\"jfk\"} \\nfirst we go the jfk as given in the qus and then will go the atl as lexically smaller and when we go the adjList of atl it will go the jfk and then again we call the atl .. So , this will create a cycle and will trap into it .. so to get out of that trap we have to remove the \"atl\" from the \"jfk\" adjList .. \\n\\n```\\nclass Solution {\\n    \\n    Map<String ,List<String>> h = new HashMap<>();\\n    \\n    List<String > ans = new ArrayList<>();\\n    int totalticket =0;\\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        \\n        \\n        int n = tickets.size();\\n        \\n        totalticket = n+1;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            String u = tickets.get(i).get(0);\\n            String v = tickets.get(i).get(1);\\n            \\n            if(h.containsKey(u)){\\n                \\n                h.get(u).add(v);\\n            }else{\\n                \\n                h.put(u,new ArrayList<>());\\n                h.get(u).add(v);\\n            }\\n            \\n        }\\n        \\n        for(List<String> i : h.values()){\\n            \\n            Collections.sort(i);\\n            System.out.println(i);\\n        }\\n        \\n        \\n        dfs(\"JFK\",new ArrayList<String>());\\n        \\n        return ans;\\n        \\n    }\\n    \\n    public boolean dfs(String from, List<String> path){\\n        \\n        path.add(from);\\n        \\n        if(path.size()==totalticket){\\n            ans.addAll(path);\\n            return true;\\n        }\\n        \\n        List<String> neigh = h.get(from);\\n        \\n        if(neigh==null){\\n            \\n            path.remove(from);\\n            return false;\\n        }\\n            \\n        \\n        for(int i=0;i<neigh.size();i++){\\n            \\n            String to = neigh.get(i);\\n            neigh.remove(i);\\n            \\n            if(dfs(to,path)){\\n                return true;\\n            }\\n            \\n            neigh.add(i,to);\\n            \\n        }\\n        \\n        path.remove(path.size()-1);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Map<String ,List<String>> h = new HashMap<>();\\n    \\n    List<String > ans = new ArrayList<>();\\n    int totalticket =0;\\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        \\n        \\n        int n = tickets.size();\\n        \\n        totalticket = n+1;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            String u = tickets.get(i).get(0);\\n            String v = tickets.get(i).get(1);\\n            \\n            if(h.containsKey(u)){\\n                \\n                h.get(u).add(v);\\n            }else{\\n                \\n                h.put(u,new ArrayList<>());\\n                h.get(u).add(v);\\n            }\\n            \\n        }\\n        \\n        for(List<String> i : h.values()){\\n            \\n            Collections.sort(i);\\n            System.out.println(i);\\n        }\\n        \\n        \\n        dfs(\"JFK\",new ArrayList<String>());\\n        \\n        return ans;\\n        \\n    }\\n    \\n    public boolean dfs(String from, List<String> path){\\n        \\n        path.add(from);\\n        \\n        if(path.size()==totalticket){\\n            ans.addAll(path);\\n            return true;\\n        }\\n        \\n        List<String> neigh = h.get(from);\\n        \\n        if(neigh==null){\\n            \\n            path.remove(from);\\n            return false;\\n        }\\n            \\n        \\n        for(int i=0;i<neigh.size();i++){\\n            \\n            String to = neigh.get(i);\\n            neigh.remove(i);\\n            \\n            if(dfs(to,path)){\\n                return true;\\n            }\\n            \\n            neigh.add(i,to);\\n            \\n        }\\n        \\n        path.remove(path.size()-1);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043338,
                "title": "python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        hashm=defaultdict(list)\\n        for i in tickets:\\n            if i[0] in hashm:\\n                hashm[i[0]].append(i[1])\\n            else:\\n                hashm[i[0]]=[i[1]]\\n        for i in hashm:\\n            hashm[i]=sorted(hashm[i], reverse=True)\\n        res=[]\\n        \\n        def dfs(i):\\n            while hashm[i]:\\n                dfs(hashm[i].pop())\\n            res.append(i)\\n            \\n        dfs(\\'JFK\\')\\n        return res[::-1]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        hashm=defaultdict(list)\\n        for i in tickets:\\n            if i[0] in hashm:\\n                hashm[i[0]].append(i[1])\\n            else:\\n                hashm[i[0]]=[i[1]]\\n        for i in hashm:\\n            hashm[i]=sorted(hashm[i], reverse=True)\\n        res=[]\\n        \\n        def dfs(i):\\n            while hashm[i]:\\n                dfs(hashm[i].pop())\\n            res.append(i)\\n            \\n        dfs(\\'JFK\\')\\n        return res[::-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043296,
                "title": "video-solution-explanation-with-drawings-in-depth-c-java",
                "content": "# Intuition and approach discussed in detail in video solution:\\nhttps://youtu.be/jgds9O1RSas\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, multiset<string>> graph;\\n        for (auto ticket : tickets){\\n            graph[ticket[0]].insert(ticket[1]);\\n        }\\n        vector<string> path;\\n        builtItn(\"JFK\", graph, path);\\n        return vector<string>(path.rbegin(), path.rend());\\n    }\\n\\n    \\nprivate:\\n    void builtItn(string src, unordered_map<string, multiset<string>> & graph, vector<string> & path) {\\n        while (graph[src].size()) {\\n            string next = *graph[src].begin();\\n            graph[src].erase(graph[src].begin());\\n            builtItn(next, graph, path);\\n        }\\n        path.push_back(src);\\n    }    \\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n      HashMap<String, PriorityQueue<String>> graph = new HashMap<>();\\n        for (var ticket : tickets){\\n            graph.putIfAbsent(ticket.get(0), new PriorityQueue<>());\\n            graph.get(ticket.get(0)).offer(ticket.get(1));\\n        }\\n        List<String> path = new ArrayList<>();\\n        builtItn(\"JFK\", graph, path);\\n        return path;\\n    }\\n\\n   \\n    void builtItn(String src, HashMap<String, PriorityQueue<String>> graph, List<String> path) {\\n        PriorityQueue<String> airports = graph.get(src);\\n\\n        while (airports != null && !airports.isEmpty()) {\\n            builtItn(airports.poll(), graph, path);\\n        }\\n        path.add(0, src);\\n    }    \\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, multiset<string>> graph;\\n        for (auto ticket : tickets){\\n            graph[ticket[0]].insert(ticket[1]);\\n        }\\n        vector<string> path;\\n        builtItn(\"JFK\", graph, path);\\n        return vector<string>(path.rbegin(), path.rend());\\n    }\\n\\n    \\nprivate:\\n    void builtItn(string src, unordered_map<string, multiset<string>> & graph, vector<string> & path) {\\n        while (graph[src].size()) {\\n            string next = *graph[src].begin();\\n            graph[src].erase(graph[src].begin());\\n            builtItn(next, graph, path);\\n        }\\n        path.push_back(src);\\n    }    \\n};\\n```\n```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n      HashMap<String, PriorityQueue<String>> graph = new HashMap<>();\\n        for (var ticket : tickets){\\n            graph.putIfAbsent(ticket.get(0), new PriorityQueue<>());\\n            graph.get(ticket.get(0)).offer(ticket.get(1));\\n        }\\n        List<String> path = new ArrayList<>();\\n        builtItn(\"JFK\", graph, path);\\n        return path;\\n    }\\n\\n   \\n    void builtItn(String src, HashMap<String, PriorityQueue<String>> graph, List<String> path) {\\n        PriorityQueue<String> airports = graph.get(src);\\n\\n        while (airports != null && !airports.isEmpty()) {\\n            builtItn(airports.poll(), graph, path);\\n        }\\n        path.add(0, src);\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043091,
                "title": "this-isn-t-hard-really-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to **build a directed graph representing airport connections** and **use a depth-first search to traverse the graph while ensuring that destinations are visited in lexicographically smallest order**. The reverse order of traversal is corrected by reversing the result list at the end. This approach guarantees the lexicographically smallest itinerary, which is the key requirement of the problem.\\n# Upvote if it helps \\uD83D\\uDE0A\\n1. **LexiSmallerComparator**: This is a custom comparator class that implements the `Comparator` interface. It is used to compare two strings (`s1` and `s2`) lexicographically. The `compare` method returns the result of the `compareTo` method, which uses the natural ordering of strings to determine their lexicographic order. **This comparator is used to order destinations for each airport**.\\n\\n2. **dfs Method**: This is a depth-first search (DFS) traversal method. It takes three parameters: `graph` (a map representing the directed graph of airports), `curr` (the current airport being visited), and `ans` (a list to store the itinerary).\\n\\n   - Inside the method, it checks if the `graph` contains the current airport (`curr`) and if its priority queue (representing destinations) is not empty.\\n   - If the conditions are met, it dequeues the next airport `next` from the priority queue of the current airport.\\n   - Then, it recursively calls `dfs` with the `next` airport as the current one.\\n   - This process continues until there are no more destinations from the current airport.\\n   - Finally, the current airport `curr` is added to the `ans` list, effectively reversing the order of the itinerary (as it\\'s added in a depth-first manner).\\n\\n3. **findItinerary Method**: \\n   - It starts by initializing an empty `graph`, which is a map where each **airport is a key, and the value is a priority queue of destinations (sorted lexicographically)**.\\n   - It then iterates through the `tickets` list, extracting the \"from\" and \"to\" airports from each ticket.\\n   - For each ticket, it checks if the `from` airport is already in the `graph`. If not, it adds an entry with an empty priority queue.\\n   - It then adds the \"to\" airport to the priority queue of the \"from\" airport, ensuring that destinations are sorted lexicographically.\\n   - Next, it initializes an empty `ans` list to store the itinerary.\\n   - It starts the DFS traversal by calling `dfs` with \"JFK\" (the starting airport) as the current airport.\\n   - After the DFS traversal is complete, the `ans` list contains the itinerary in reverse order (due to the depth-first traversal).\\n   - To obtain the correct order, it reverses the `ans` list using `Collections.reverse`.\\n\\n4. Finally, it returns the lexicographically smallest itinerary as a list of strings.\\n\\n# DFS Handles dead-end cases \\nDepth-First Search (DFS) handles dead-end cases by backtracking to the previous valid choice when there are no more unvisited options from the current state. This is achieved through recursion, and in the context of finding an itinerary with the given problem, it means that if there\\'s a dead-end at an airport, the DFS will backtrack to the previous airport where there are unvisited destinations and continue the exploration from there.\\n\\nLet\\'s illustrate this with the provided `tickets` example: ` [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]`.\\n\\n1. The DFS starts from \"JFK,\" which is the initial airport.\\n2. From \"JFK,\" there are two options: \"KUL\" and \"NRT.\"\\n   - It chooses \"KUL\" because it\\'s lexicographically smaller and marks it as visited.\\n   - The DFS continues from \"KUL,\" but there are no more unvisited destinations from \"KUL.\"\\n   - At this point, it backtracks to the previous airport, which is \"JFK,\" and checks if there are other unvisited destinations.\\n3. From \"JFK,\" there is still an unvisited option, \"NRT.\"\\n   - It chooses \"NRT\" because it\\'s the only remaining option and marks it as visited.\\n   - The DFS continues from \"NRT,\" but again, there are no more unvisited destinations from \"NRT.\"\\n   - It backtracks to \"JFK\" once more.\\n4. Now, from \"JFK,\" there are no more unvisited destinations.\\n   - It backtracks again, but this time, there\\'s no previous airport to backtrack to because \"JFK\" is the starting point.\\n   - At this point, the DFS traversal ends.\\n\\nThe key point to understand is that when a dead-end is encountered (i.e., no more unvisited destinations from the current airport), the DFS algorithm automatically backtracks to the previous airport where there are unvisited destinations. It keeps doing this until it reaches an airport with unvisited destinations or returns to the starting airport. In this way, it explores all possible routes through the airports to find the lexicographically smallest itinerary.\\n\\nIn the example provided, the algorithm explores all available routes and returns the itinerary: `[\"JFK\", \"NRT\", \"JFK\", \"KUL\"]`, which is the lexicographically smallest valid itinerary for the given tickets.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N * log N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N * log N)\\n# Code\\n```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n\\n        //directed graph mapping \"from\" airport to all its \"to\" airport according to tickets\\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        for(List<String>t :tickets){\\n            String from = t.get(0), to = t.get(1);\\n            if(!graph.containsKey(from)){\\n                graph.put(from, new PriorityQueue<>(new LexiSmallerComparator()));\\n            }\\n            graph.get(from).add(to);\\n        }\\n\\n        List<String> ans = new ArrayList<>();\\n        dfs(graph, \"JFK\", ans);//depart from JFK\\n        \\n        //reverse to get correct order\\n        Collections.reverse(ans);\\n\\n        return ans;\\n    }\\n\\n\\n    // Custom comparator for lexicographically smaller strings\\n    static class LexiSmallerComparator implements Comparator<String> {\\n        @Override\\n        public int compare(String s1, String s2) {\\n            return s1.compareTo(s2); // Use the natural ordering of strings\\n        }\\n    }\\n\\n    // Helper method for DFS traversal\\n    private void dfs(Map<String, PriorityQueue<String>> graph, String curr, List<String> ans) {\\n        while (graph.containsKey(curr) && !graph.get(curr).isEmpty()) {\\n            String next = graph.get(curr).poll();\\n            dfs(graph, next, ans);\\n        }\\n        ans.add(curr);\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n\\n        //directed graph mapping \"from\" airport to all its \"to\" airport according to tickets\\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        for(List<String>t :tickets){\\n            String from = t.get(0), to = t.get(1);\\n            if(!graph.containsKey(from)){\\n                graph.put(from, new PriorityQueue<>(new LexiSmallerComparator()));\\n            }\\n            graph.get(from).add(to);\\n        }\\n\\n        List<String> ans = new ArrayList<>();\\n        dfs(graph, \"JFK\", ans);//depart from JFK\\n        \\n        //reverse to get correct order\\n        Collections.reverse(ans);\\n\\n        return ans;\\n    }\\n\\n\\n    // Custom comparator for lexicographically smaller strings\\n    static class LexiSmallerComparator implements Comparator<String> {\\n        @Override\\n        public int compare(String s1, String s2) {\\n            return s1.compareTo(s2); // Use the natural ordering of strings\\n        }\\n    }\\n\\n    // Helper method for DFS traversal\\n    private void dfs(Map<String, PriorityQueue<String>> graph, String curr, List<String> ans) {\\n        while (graph.containsKey(curr) && !graph.get(curr).isEmpty()) {\\n            String next = graph.get(curr).poll();\\n            dfs(graph, next, ans);\\n        }\\n        ans.add(curr);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042919,
                "title": "reconstruct-itinerary-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(string& airport, unordered_map<string, vector<string>>& graph,vector<string>& itinerary){\\n        while(!graph[airport].empty()){\\n            string next = graph[airport].back();\\n            graph[airport].pop_back();\\n            dfs(next, graph, itinerary);\\n        }\\n        itinerary.push_back(airport);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, vector<string>> graph;\\n\\n        for(auto& ticket : tickets){\\n            graph[ticket[0]].push_back(ticket[1]);\\n        }\\n        for(auto& temp : graph){\\n            sort(temp.second.rbegin(), temp.second.rend());\\n        }\\n\\n        vector<string> itinerary;\\n        string jfk = \"JFK\";\\n        dfs(jfk, graph, itinerary);\\n\\n        reverse(itinerary.begin(), itinerary.end());\\n\\n        return itinerary;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Eulerian Circuit"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(string& airport, unordered_map<string, vector<string>>& graph,vector<string>& itinerary){\\n        while(!graph[airport].empty()){\\n            string next = graph[airport].back();\\n            graph[airport].pop_back();\\n            dfs(next, graph, itinerary);\\n        }\\n        itinerary.push_back(airport);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, vector<string>> graph;\\n\\n        for(auto& ticket : tickets){\\n            graph[ticket[0]].push_back(ticket[1]);\\n        }\\n        for(auto& temp : graph){\\n            sort(temp.second.rbegin(), temp.second.rend());\\n        }\\n\\n        vector<string> itinerary;\\n        string jfk = \"JFK\";\\n        dfs(jfk, graph, itinerary);\\n\\n        reverse(itinerary.begin(), itinerary.end());\\n\\n        return itinerary;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042807,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        adj={}\\n        for ticket in tickets:\\n            adj[ticket[0]]=[]\\n            adj[ticket[1]]=[]\\n\\n        for ticket in tickets:\\n            adj[ticket[0]].append(ticket[1])\\n\\n        for l in adj.values():\\n            l.sort()\\n\\n        ans=[]\\n        def helper(node):\\n            while adj[node]:\\n                helper(adj[node].pop(0))\\n\\n            ans.append(node)\\n        helper(\"JFK\")\\n        return reversed(ans)                   \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        adj={}\\n        for ticket in tickets:\\n            adj[ticket[0]]=[]\\n            adj[ticket[1]]=[]\\n\\n        for ticket in tickets:\\n            adj[ticket[0]].append(ticket[1])\\n\\n        for l in adj.values():\\n            l.sort()\\n\\n        ans=[]\\n        def helper(node):\\n            while adj[node]:\\n                helper(adj[node].pop(0))\\n\\n            ans.append(node)\\n        helper(\"JFK\")\\n        return reversed(ans)                   \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042764,
                "title": "simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        # Create a graph for each airport and keep list of airport reachable from it\\n        graph = defaultdict(list)\\n        for src, dst in sorted(tickets)[::-1]:\\n            graph[src].append(dst)\\n\\n        route, stack = [], [\\'JFK\\']\\n        while stack:\\n            while graph[stack[-1]]:\\n                stack.append(graph[stack[-1]].pop())\\n            route.append(stack.pop())\\n\\n        return route[::-1]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        # Create a graph for each airport and keep list of airport reachable from it\\n        graph = defaultdict(list)\\n        for src, dst in sorted(tickets)[::-1]:\\n            graph[src].append(dst)\\n\\n        route, stack = [], [\\'JFK\\']\\n        while stack:\\n            while graph[stack[-1]]:\\n                stack.append(graph[stack[-1]].pop())\\n            route.append(stack.pop())\\n\\n        return route[::-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042221,
                "title": "c-solution-for-reconstruct-itinerary-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to construct a graph where airports are nodes, and directed edges represent flight routes. Then, perform a depth-first search (DFS) starting from the \\u201CJFK\\u201D airport while ensuring that you use all the given tickets and choose the lexicographically smallest path when multiple options are available.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.\\tBuild a directed graph where the keys are departure airports, and values are lists of arrival airports. Sort these lists lexicographically.\\n2.\\tInitialize an empty list for the itinerary.\\n3.\\tStart the DFS from \\u201CJFK\\u201D, repeatedly choosing the smallest lexicographically destination while removing edges as you go.\\n4.\\tReverse the final itinerary since DFS appends nodes in reverse order.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\u2022\\tConstructing the graph takes O(NlogN), where N is the number of tickets. Sorting the destinations for each airport takes O(NlogN) in total.\\n\\u2022\\tThe DFS traversal explores each edge exactly once, taking O(N) time.\\n\\u2022\\tOverall, the time complexity is O(NlogN) for graph construction and O(N) for DFS, resulting in O(NlogN) in total.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\u2022\\tThe space complexity is dominated by the graph data structure, which requires O(N) space for storing the airport nodes and their destinations.\\n\\u2022\\tAdditionally, the DFS call stack can go as deep as the number of tickets, resulting in a space complexity of O(N).\\n\\u2022\\tOverall, the space complexity is O(N).\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<string> FindItinerary(IList<IList<string>> tickets) {\\n        Dictionary<string, List<string>> graph = new Dictionary<string, List<string>>();\\n        List<string> itinerary = new List<string>();\\n\\n        // Build the graph from the given tickets\\n        foreach (var ticket in tickets) {\\n            string from = ticket[0];\\n            string to = ticket[1];\\n            if (!graph.ContainsKey(from)) {\\n                graph[from] = new List<string>();\\n            }\\n            graph[from].Add(to);\\n        }\\n\\n        // Sort the destinations in lexical order\\n        foreach (var key in graph.Keys) {\\n            graph[key].Sort();\\n        }\\n\\n        // Start the DFS from JFK\\n        DFS(graph, \"JFK\", itinerary);\\n\\n        // Reverse the itinerary since DFS appends in reverse order\\n        itinerary.Reverse();\\n        return itinerary;\\n    }\\n\\n    private void DFS(Dictionary<string, List<string>> graph, string airport, List<string> itinerary) {\\n        if (graph.ContainsKey(airport) && graph[airport].Count > 0) {\\n            List<string> destinations = graph[airport];\\n            while (destinations.Count > 0) {\\n                string nextAirport = destinations[0];\\n                destinations.RemoveAt(0);\\n                DFS(graph, nextAirport, itinerary);\\n            }\\n        }\\n        itinerary.Add(airport);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> FindItinerary(IList<IList<string>> tickets) {\\n        Dictionary<string, List<string>> graph = new Dictionary<string, List<string>>();\\n        List<string> itinerary = new List<string>();\\n\\n        // Build the graph from the given tickets\\n        foreach (var ticket in tickets) {\\n            string from = ticket[0];\\n            string to = ticket[1];\\n            if (!graph.ContainsKey(from)) {\\n                graph[from] = new List<string>();\\n            }\\n            graph[from].Add(to);\\n        }\\n\\n        // Sort the destinations in lexical order\\n        foreach (var key in graph.Keys) {\\n            graph[key].Sort();\\n        }\\n\\n        // Start the DFS from JFK\\n        DFS(graph, \"JFK\", itinerary);\\n\\n        // Reverse the itinerary since DFS appends in reverse order\\n        itinerary.Reverse();\\n        return itinerary;\\n    }\\n\\n    private void DFS(Dictionary<string, List<string>> graph, string airport, List<string> itinerary) {\\n        if (graph.ContainsKey(airport) && graph[airport].Count > 0) {\\n            List<string> destinations = graph[airport];\\n            while (destinations.Count > 0) {\\n                string nextAirport = destinations[0];\\n                destinations.RemoveAt(0);\\n                DFS(graph, nextAirport, itinerary);\\n            }\\n        }\\n        itinerary.Add(airport);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023548,
                "title": "eulerian-path-easy-implementation-c",
                "content": "# Intuition\\nRefer This Video By PepCoding\\n\\nhttps://www.youtube.com/watch?v=U33blOQRaJ0\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    vector<string> findItinerary(vector<vector<string>> &tickets)\\n    {\\n        unordered_map<string,vector<string>>graph;\\n\\n        for (const auto ticket : tickets){\\n            string departure = ticket[0];\\n            string arrival = ticket[1];\\n            graph[departure].push_back(arrival);\\n        }\\n\\n        for (auto &destinations : graph){\\n            sort(destinations.second.begin() , destinations.second.end());\\n        }\\n\\n        stack<string>st;\\n        vector<string>circuit;\\n        st.push(\"JFK\");\\n\\n        while(!st.empty()){\\n            auto curr = st.top();\\n\\n            if(graph.find(curr) == graph.end() || graph[curr].empty()){ // if we have reached a dead end or we have no more outgoing edges\\n                circuit.push_back(curr);\\n                st.pop();\\n            } else {\\n                string next = graph[curr][0];   // take the first edge\\n                graph[curr].erase(graph[curr].begin()); // remove the edge\\n                st.push(next);\\n            }\\n        }\\n        reverse(circuit.begin() , circuit.end());\\n        return circuit;\\n    }\\n};\\n\\n/*\\n\\nEulerian Circuit {\\n    src -> extra outdegree  \\n    dest -> extra indegree\\n    other nodes -> indegree == outdegree\\n\\n    Eulerian Path is a path in a graph that visits every edge exactly once. Eulerian Circuit is an Eulerian Path that starts and ends on the same vertex\\n}\\n\\ncharacteristics of Eulerian Path {\\n    1. Undirected graph\\n    2. All vertices with non-zero degree are connected\\n    3. All vertices have even degree\\n}\\n \\nAlgorithm {\\n    1. Find the number of vertices with odd degree. Let this number be n.\\n    2. If n is greater than 2, then no Eulerian path exists. If n is 0, then all Eulerian cycles and paths are possible. If n is 2, then a Eulerian path exists\\n    3. If n is 1, then there is no Eulerian path\\n    4. Let u be one vertex with odd degree. If u is connected to all other vertices, then print Eulerian Path starts with u. Else print Eulerian Path starts with v\\n}\\n\\nConnect Me - Avijit Sen\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    vector<string> findItinerary(vector<vector<string>> &tickets)\\n    {\\n        unordered_map<string,vector<string>>graph;\\n\\n        for (const auto ticket : tickets){\\n            string departure = ticket[0];\\n            string arrival = ticket[1];\\n            graph[departure].push_back(arrival);\\n        }\\n\\n        for (auto &destinations : graph){\\n            sort(destinations.second.begin() , destinations.second.end());\\n        }\\n\\n        stack<string>st;\\n        vector<string>circuit;\\n        st.push(\"JFK\");\\n\\n        while(!st.empty()){\\n            auto curr = st.top();\\n\\n            if(graph.find(curr) == graph.end() || graph[curr].empty()){ // if we have reached a dead end or we have no more outgoing edges\\n                circuit.push_back(curr);\\n                st.pop();\\n            } else {\\n                string next = graph[curr][0];   // take the first edge\\n                graph[curr].erase(graph[curr].begin()); // remove the edge\\n                st.push(next);\\n            }\\n        }\\n        reverse(circuit.begin() , circuit.end());\\n        return circuit;\\n    }\\n};\\n\\n/*\\n\\nEulerian Circuit {\\n    src -> extra outdegree  \\n    dest -> extra indegree\\n    other nodes -> indegree == outdegree\\n\\n    Eulerian Path is a path in a graph that visits every edge exactly once. Eulerian Circuit is an Eulerian Path that starts and ends on the same vertex\\n}\\n\\ncharacteristics of Eulerian Path {\\n    1. Undirected graph\\n    2. All vertices with non-zero degree are connected\\n    3. All vertices have even degree\\n}\\n \\nAlgorithm {\\n    1. Find the number of vertices with odd degree. Let this number be n.\\n    2. If n is greater than 2, then no Eulerian path exists. If n is 0, then all Eulerian cycles and paths are possible. If n is 2, then a Eulerian path exists\\n    3. If n is 1, then there is no Eulerian path\\n    4. Let u be one vertex with odd degree. If u is connected to all other vertices, then print Eulerian Path starts with u. Else print Eulerian Path starts with v\\n}\\n\\nConnect Me - Avijit Sen\\n*/\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3576873,
                "title": "using-eulerian-circuit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve the problem using Eulerian Circuit, we can follow these steps:\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n 1. Create a graph using the given tickets, where each airport is represented as a node, and the flights between airports are represented as edges.\\n\\n 2. Sort the destinations (arrival airports) in lexicographic order for each departure airport. This ensures that we visit the smaller destination\\n first in case of multiple flights from the same departure airport.\\n\\n 3. Initialize an empty stack and push the starting airport, \"JFK\", onto the stack.\\n\\n 4. While the stack is not empty, do the following:\\n - Peek the top airport from the stack.\\n - If the airport has any remaining destinations, select the smallest lexicographic destination and push it onto the stack.\\n - If the airport has no remaining destinations, pop the airport from the stack and add it to the itinerary list.\\n\\n 5. Reverse the itinerary list to get the correct order of airports visited.\\n\\n 6. Return the itinerary list.\\n\\n For the given example:\\n\\n Input: tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]\\n\\n The itinerary using Eulerian Circuit will be:\\n\\n 1. Create a graph: JFK -> MUC -> LHR -> SFO -> SJC\\n 2. Sort destinations: JFK -> MUC -> LHR -> SFO -> SJC\\n 3. Start with JFK, push JFK onto the stack.\\n 4. Stack: [JFK]\\n 5. JFK has destinations MUC. Push MUC onto the stack.\\n 6. Stack: [JFK, MUC]\\n 7. MUC has destinations LHR. Push LHR onto the stack.\\n 8. Stack: [JFK, MUC, LHR]\\n 9. LHR has destinations SFO. Push SFO onto the stack.\\n 10. Stack: [JFK, MUC, LHR, SFO]\\n 11. SFO has destination SJC. Push SJC onto the stack.\\n 12. Stack: [JFK, MUC, LHR, SFO, SJC]\\n 13. SJC has no remaining destinations. Pop SJC from the stack and add it to the itinerary list.\\n 14. Stack: [JFK, MUC, LHR, SFO]\\n 15. SFO has no remaining destinations. Pop SFO from the stack and add it to the itinerary list.\\n 16. Stack: [JFK, MUC, LHR]\\n 17. LHR has no remaining destinations. Pop LHR from the stack and add it to the itinerary list.\\n 18. Stack: [JFK, MUC]\\n 19. MUC has no remaining destinations. Pop MUC from the stack and add it to the itinerary list.\\n 20. Stack: [JFK]\\n 21. JFK has no remaining destinations. Pop JFK from the stack and add it to the itinerary list.\\n 22. Stack: []\\n\\n Reverse the itinerary list: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]\\n\\n Return the itinerary list: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]\\n\\n# Complexity\\n- Time complexity:O(E log E).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nimport java.util.*;\\n\\npublic class ReconstructItineraryUsingEulerianCircuit2 {\\n\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, List<String>> graph = new HashMap<>();\\n\\n        // Step 1: Construct the graph\\n        for (List<String> ticket : tickets) {\\n            String departure = ticket.get(0);\\n            String arrival = ticket.get(1);\\n\\n            graph.putIfAbsent(departure, new ArrayList<>());\\n            graph.get(departure).add(arrival);\\n        }\\n\\n        // Step 3: Sort the lists of destinations\\n        for (List<String> destinations : graph.values()) {\\n            Collections.sort(destinations);\\n        }\\n\\n        Stack<String> stack = new Stack<>();\\n        List<String> circuit = new ArrayList<>();\\n\\n        // Step 6: Push the starting airport to the stack\\n        stack.push(\"JFK\");\\n\\n        // Step 7: Perform DFS using stack\\n        while (!stack.isEmpty()) {\\n            String current = stack.peek();\\n\\n            // Step 7b: If current airport has no outgoing edges, add it to the circuit\\n            if (!graph.containsKey(current) || graph.get(current).isEmpty()) {\\n                circuit.add(stack.pop());\\n            } else {\\n                // Step 7c: Push the next unvisited destination to the stack and remove the edge from the graph\\n                stack.push(graph.get(current).remove(0));\\n            }\\n        }\\n\\n        // Step 8: Reverse the circuit to get the correct order\\n        Collections.reverse(circuit);\\n\\n        return circuit;\\n    }\\n    public static void main(String[] args) {\\n        List<List<String>> tickets = new ArrayList<>();\\n//        tickets.add(Arrays.asList(\"MUC\", \"LHR\"));\\n//        tickets.add(Arrays.asList(\"JFK\", \"MUC\"));\\n//        tickets.add(Arrays.asList(\"SFO\", \"SJC\"));\\n//        tickets.add(Arrays.asList(\"LHR\", \"SFO\"));\\n\\n        tickets.add(Arrays.asList(\"JFK\",\"SFO\"));\\n        tickets.add(Arrays.asList(\"JFK\",\"ATL\"));\\n        tickets.add(Arrays.asList(\"SFO\",\"ATL\"));\\n        tickets.add(Arrays.asList(\"ATL\",\"JFK\"));\\n        tickets.add(Arrays.asList(\"ATL\",\"SFO\"));\\n\\n\\n        ReconstructItineraryUsingEulerianCircuit solution = new ReconstructItineraryUsingEulerianCircuit();\\n        List<String> itinerary = solution.findItinerary(tickets);\\n        System.out.println(itinerary);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Eulerian Circuit"
                ],
                "code": "```\\n\\nimport java.util.*;\\n\\npublic class ReconstructItineraryUsingEulerianCircuit2 {\\n\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, List<String>> graph = new HashMap<>();\\n\\n        // Step 1: Construct the graph\\n        for (List<String> ticket : tickets) {\\n            String departure = ticket.get(0);\\n            String arrival = ticket.get(1);\\n\\n            graph.putIfAbsent(departure, new ArrayList<>());\\n            graph.get(departure).add(arrival);\\n        }\\n\\n        // Step 3: Sort the lists of destinations\\n        for (List<String> destinations : graph.values()) {\\n            Collections.sort(destinations);\\n        }\\n\\n        Stack<String> stack = new Stack<>();\\n        List<String> circuit = new ArrayList<>();\\n\\n        // Step 6: Push the starting airport to the stack\\n        stack.push(\"JFK\");\\n\\n        // Step 7: Perform DFS using stack\\n        while (!stack.isEmpty()) {\\n            String current = stack.peek();\\n\\n            // Step 7b: If current airport has no outgoing edges, add it to the circuit\\n            if (!graph.containsKey(current) || graph.get(current).isEmpty()) {\\n                circuit.add(stack.pop());\\n            } else {\\n                // Step 7c: Push the next unvisited destination to the stack and remove the edge from the graph\\n                stack.push(graph.get(current).remove(0));\\n            }\\n        }\\n\\n        // Step 8: Reverse the circuit to get the correct order\\n        Collections.reverse(circuit);\\n\\n        return circuit;\\n    }\\n    public static void main(String[] args) {\\n        List<List<String>> tickets = new ArrayList<>();\\n//        tickets.add(Arrays.asList(\"MUC\", \"LHR\"));\\n//        tickets.add(Arrays.asList(\"JFK\", \"MUC\"));\\n//        tickets.add(Arrays.asList(\"SFO\", \"SJC\"));\\n//        tickets.add(Arrays.asList(\"LHR\", \"SFO\"));\\n\\n        tickets.add(Arrays.asList(\"JFK\",\"SFO\"));\\n        tickets.add(Arrays.asList(\"JFK\",\"ATL\"));\\n        tickets.add(Arrays.asList(\"SFO\",\"ATL\"));\\n        tickets.add(Arrays.asList(\"ATL\",\"JFK\"));\\n        tickets.add(Arrays.asList(\"ATL\",\"SFO\"));\\n\\n\\n        ReconstructItineraryUsingEulerianCircuit solution = new ReconstructItineraryUsingEulerianCircuit();\\n        List<String> itinerary = solution.findItinerary(tickets);\\n        System.out.println(itinerary);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756709,
                "title": "java-solution-short-and-concise",
                "content": "class Solution {\\n    List<String> res= new ArrayList<>();\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n     \\n        HashMap<String,PriorityQueue<String>> map = new HashMap<>();\\n        \\n        for(int i=0;i<tickets.size();i++){\\n            String to = tickets.get(i).get(0);\\n            String from = tickets.get(i).get(1);\\n            \\n            if(!map.containsKey(to)){\\n                map.put(to,new PriorityQueue<>());\\n            }\\n            map.get(to).add(from);\\n        }\\n        \\n        dfs(map,\"JFK\");\\n        Collections.reverse(res);\\n        return res;\\n    }\\n    private void dfs(HashMap<String,PriorityQueue<String>> map,String source){\\n        \\n        PriorityQueue<String> temp = map.get(source);\\n        if(temp != null){\\n            while(!temp.isEmpty()){\\n                dfs(map,temp.poll());\\n            }\\n        }\\n        res.add(source);\\n    }\\n}\\n\\n// For faster approach you can also use linkedList instead of PriorityQueue As remove will change to 0(1) time complexity But first you will have to sort the linkedList in the map.",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    List<String> res= new ArrayList<>();\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n     \\n        HashMap<String,PriorityQueue<String>> map = new HashMap<>();\\n        \\n        for(int i=0;i<tickets.size();i++){\\n            String to = tickets.get(i).get(0);\\n            String from = tickets.get(i).get(1);\\n            \\n            if(!map.containsKey(to)){\\n                map.put(to,new PriorityQueue<>());\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2412359,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> t) {\\n        Stack<String> kk=new Stack<>();\\n        Map<String,PriorityQueue<String>> nm=new HashMap<>();\\n        for(int i=0;i<t.size();i++)\\n        {\\n            String k=t.get(i).get(0);\\n            if(!nm.containsKey(k))\\n                nm.put(k, new PriorityQueue<String>());\\n            nm.get(k).offer(t.get(i).get(1));\\n        }\\n        List<String> p=new ArrayList<>();\\n        kk.push(\"JFK\");\\n        while(!kk.isEmpty())\\n        {\\n            String f=kk.peek();\\n            if(nm.containsKey(f) && nm.get(f).size()>0)\\n                kk.push(nm.get(f).poll());\\n            else\\n                p.add(0,kk.pop());\\n        }\\n        return p;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public List<String> findItinerary(List<List<String>> t) {\\n        Stack<String> kk=new Stack<>();\\n        Map<String,PriorityQueue<String>> nm=new HashMap<>();\\n        for(int i=0;i<t.size();i++)\\n        {\\n            String k=t.get(i).get(0);\\n            if(!nm.containsKey(k))\\n                nm.put(k, new PriorityQueue<String>());\\n            nm.get(k).offer(t.get(i).get(1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2299450,
                "title": "c-simple-code-but-hard-question",
                "content": "```\\n#include <bits/stdc++.h>\\n#define mp unordered_map<string, priority_queue<string, vector<string>, greater<string>>>\\n\\nclass Solution {\\npublic:\\n    \\n    void dfs(string start, mp& adj, stack<string>& stk ){\\n        auto& minPQ= adj[start];\\n    \\n        while(!minPQ.empty()){\\n            string baccha= minPQ.top(); // lexixographical chota baccha\\n            minPQ.pop(); // after using edge, delete it so that we can ever use it again\\n\\n            dfs(baccha, adj, stk);\\n        }\\n\\n        stk.push(start);\\n        return;\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& ticket) {\\n        mp adj;\\n        \\n        for(int i=0; i<ticket.size(); i++){\\n            string u= ticket[i][0];  string v= ticket[i][1];\\n            adj[u].push(v);\\n        }\\n        \\n        stack<string> stk;\\n        // no need of visited array. As we can visit node multiple time. We just need to visit every edge only once\\n        dfs(\"JFK\", adj, stk); \\n        \\n        vector<string> ans; \\n        while(!stk.empty()){  ans.push_back(stk.top());  stk.pop();  }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\n#define mp unordered_map<string, priority_queue<string, vector<string>, greater<string>>>\\n\\nclass Solution {\\npublic:\\n    \\n    void dfs(string start, mp& adj, stack<string>& stk ){\\n        auto& minPQ= adj[start];\\n    \\n        while(!minPQ.empty()){\\n            string baccha= minPQ.top(); // lexixographical chota baccha\\n            minPQ.pop(); // after using edge, delete it so that we can ever use it again\\n\\n            dfs(baccha, adj, stk);\\n        }\\n\\n        stk.push(start);\\n        return;\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& ticket) {\\n        mp adj;\\n        \\n        for(int i=0; i<ticket.size(); i++){\\n            string u= ticket[i][0];  string v= ticket[i][1];\\n            adj[u].push(v);\\n        }\\n        \\n        stack<string> stk;\\n        // no need of visited array. As we can visit node multiple time. We just need to visit every edge only once\\n        dfs(\"JFK\", adj, stk); \\n        \\n        vector<string> ans; \\n        while(!stk.empty()){  ans.push_back(stk.top());  stk.pop();  }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 2056751,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 2056733,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1564686,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1564987,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 2056771,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1573824,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1567957,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1568233,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1568031,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1567323,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 2056751,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 2056733,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1564686,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1564987,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 2056771,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1573824,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1567957,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1568233,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1568031,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1567323,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1568657,
                "content": [
                    {
                        "username": "phaniram28",
                        "content": "Could anyone help me understand why does Hierholzer\\'s algorithm work in this problem??\\nI see that the problme mentions there exists an answer, is that the valid reason, why if we keep traversing and backtracking on a dead end, would give us a valid answer??\\n\\nI\\'m looking for more formal explaination/logic than simple words, could anyone help??\\n\\n\\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@bparanj](/bparanj) Can u please tell what would be the time complexity of backtracking approach ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Hierholzer\\'s algorithm is typically used to find an Eulerian path or circuit in a graph. An Eulerian path is a trail in a graph that visits every edge exactly once. The algorithm works well in this problem because of a few key properties:\\n\\n1. **Existence of Eulerian Path**: The problem guarantees that an Eulerian path exists, i.e., you can travel every \\'ticket\\' exactly once. This is confirmed by the problem\\'s condition that an answer always exists.\\n\\n2. **Directed Graph**: The tickets can be considered as directed edges in a graph. You can only go from the \"from\" airport to the \"to\" airport as specified on each ticket. Hierholzer\\'s algorithm can easily adapt to directed graphs.\\n\\n3. **Degree of Vertices**: In an Eulerian path, each vertex (except possibly for the start and end vertex) has an equal in-degree and out-degree. This means you can \\'enter\\' and \\'leave\\' each vertex the same number of times. In the problem, the number of tickets to enter an airport would be the same as the number to leave, except for JFK (the start) and possibly another airport if the path is not a circuit.\\n\\n4. **Dead Ends and Backtracking**: Hierholzer\\'s algorithm naturally handles dead ends via backtracking. When you hit a dead-end, you know you\\'ve traversed all outgoing edges (tickets) for that vertex (airport). You can then backtrack and continue traversing other unexplored edges, eventually forming the Eulerian path.\\n\\n5. **Lexicographic Ordering**: While Hierholzer\\'s doesn\\'t inherently give a lexicographically minimal path, you can achieve this by always choosing the smallest available vertex to visit next, which aligns well with the problem\\'s constraints.\\n\\nThe formal reasoning behind why Hierholzer\\'s works is fundamentally based on the properties of Eulerian paths and the constraints of the problem. Given the existence of an Eulerian path and the balanced in-degree and out-degree for each vertex, Hierholzer\\'s will construct the path by traversing each edge exactly once, thus providing a valid answer."
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Hint : Use DFS with a stack, sort destinations, and mark used tickets to find the itinerary!"
                    },
                    {
                        "username": "c910335",
                        "content": "Whoever wrote the program that produces the expected answer, well done!\\n\\n```rb\\n[[\"JFK\",\"YZZ\"], [\"YZZ\", \"JFK\"], [\"JFK\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"]]\\n```\\n\\n![](https://i.imgur.com/UMAEfvY.png)"
                    },
                    {
                        "username": "c910335",
                        "content": "[@lucasscodes](/lucasscodes) 100% reproducible"
                    },
                    {
                        "username": "kenlau",
                        "content": "Looks like the online judge got TLE ..."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "cannot reproduce?"
                    },
                    {
                        "username": "advfeature",
                        "content": "That means you might have to visit certain edges multiple times. That broke my first submission!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "yes you have to use all the ticket even revisiting it \\nknow more about from here  - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "kwonkyu",
                        "content": "At 29th test case, \\n[[\"EZE\",\"TIA\"],[\"EZE\",\"HBA\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AXA\"],[\"ANU\",\"JFK\"],[\"ADL\",\"ANU\"],**[\"TIA\",\"AUA\"]**,[\"ANU\",\"AUA\"],[\"ADL\",\"EZE\"],[\"ADL\",\"EZE\"],[\"EZE\",\"ADL\"],[\"AXA\",\"EZE\"],[\"AUA\",\"AXA\"],[\"JFK\",\"AXA\"],[\"AXA\",\"AUA\"],[\"AUA\",\"ADL\"],[\"ANU\",\"EZE\"],**[\"TIA\",\"ADL\"]**,[\"EZE\",\"ANU\"],[\"AUA\",\"ANU\"]]\\n\\nThere\\'re two destinations from \"TIA\", which are \"ADL\" and \"AUA\".\\nSo I thought the result should be like [..., \"TIA\", \"ADL\", ..., \"TIA\", \"AUA\", ...] but test case shows [..., \"TIA\", \"AUA\", ..., \"TIA\", \"ADL\", ...].\\n~~Isn\\'t \"ADL\" is prior to \"AUA\" in lexical order? Or should I manually select ticket to use all of my tickets even if it\\'s not in lexical order?~~\\n\\n~~I\\'m not native speaker so I may missed some points but I can\\'t tell what it is. Does anyone know?~~\\n\\nOh I was stupid\\uD83D\\uDE05 Description said \"You must use all tickets\" so...\\ngotta get some sleep. my brain\\'s not working."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@user5400vw](/user5400vw)  I got this and solved it too, then got stuck at the 33rd testcase."
                    },
                    {
                        "username": "user5400vw",
                        "content": "if u guys get this test case you\\'re halfway there."
                    },
                    {
                        "username": "segfz",
                        "content": "Consider test case [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nexpected result: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\nI expect the result to be : [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\nAm I correct to say \"NRT\" is lexically larger than \"KUL\"?\\n\\nI am sure I have gotten it wrong but what is it?\\n\\nThank you so much"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "but after selecting jul you get dead end you cannot go anywhere \\nknow more about this here - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "The answer should be: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] since there is no path from KUL to NRT, so [\"JFK\",\"KUL\",\"NRT\",\"JFK\"] cannot be a valid answer. We need to return the lexicographically smallest VALID answer."
                    },
                    {
                        "username": "mohitgupta1194",
                        "content": "Are there questions similar to this problem i.e. which uses this eulerian path algorithm?"
                    },
                    {
                        "username": "Kajal_Joshi",
                        "content": "As per the problem, smaller lexical value string should come before in itinerary sequence.\\n\\nso [\"JFK\",\"KUL\"] is smaller than [\"JFK\",\"NRT\"],\\nso ouput should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\n\\nbut expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nPlease someone explain how this output is calculated?"
                    },
                    {
                        "username": "90K2",
                        "content": "The test case is [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nAnd the expected answer is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] but why? If [JFK, KUL] < [JFK, NRT]"
                    },
                    {
                        "username": "ysingh",
                        "content": "I tried [[\"JFK\", \"LGA\"],[\"JFK\", \"LGB\"]] as a test case and got this as expected answer:\\n[\"JFK\",\"LGB\",\"LGA\"].\\n\\nTwo concerns regarding the expected answer:\\n1) How could this be valid answer when there is no flight between LGB->LGA? \\nDoes the itinerary [\"JFK\",\"LGB\",\"LGA\"] implies that there should be a valid flight between \"JFK\"->\"LGB\" &  \"LGB\" ->\"LGA\".\\n2) Also shouldn't LGA come before LGB as per lexical ordering?"
                    }
                ]
            },
            {
                "id": 2056820,
                "content": [
                    {
                        "username": "phaniram28",
                        "content": "Could anyone help me understand why does Hierholzer\\'s algorithm work in this problem??\\nI see that the problme mentions there exists an answer, is that the valid reason, why if we keep traversing and backtracking on a dead end, would give us a valid answer??\\n\\nI\\'m looking for more formal explaination/logic than simple words, could anyone help??\\n\\n\\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@bparanj](/bparanj) Can u please tell what would be the time complexity of backtracking approach ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Hierholzer\\'s algorithm is typically used to find an Eulerian path or circuit in a graph. An Eulerian path is a trail in a graph that visits every edge exactly once. The algorithm works well in this problem because of a few key properties:\\n\\n1. **Existence of Eulerian Path**: The problem guarantees that an Eulerian path exists, i.e., you can travel every \\'ticket\\' exactly once. This is confirmed by the problem\\'s condition that an answer always exists.\\n\\n2. **Directed Graph**: The tickets can be considered as directed edges in a graph. You can only go from the \"from\" airport to the \"to\" airport as specified on each ticket. Hierholzer\\'s algorithm can easily adapt to directed graphs.\\n\\n3. **Degree of Vertices**: In an Eulerian path, each vertex (except possibly for the start and end vertex) has an equal in-degree and out-degree. This means you can \\'enter\\' and \\'leave\\' each vertex the same number of times. In the problem, the number of tickets to enter an airport would be the same as the number to leave, except for JFK (the start) and possibly another airport if the path is not a circuit.\\n\\n4. **Dead Ends and Backtracking**: Hierholzer\\'s algorithm naturally handles dead ends via backtracking. When you hit a dead-end, you know you\\'ve traversed all outgoing edges (tickets) for that vertex (airport). You can then backtrack and continue traversing other unexplored edges, eventually forming the Eulerian path.\\n\\n5. **Lexicographic Ordering**: While Hierholzer\\'s doesn\\'t inherently give a lexicographically minimal path, you can achieve this by always choosing the smallest available vertex to visit next, which aligns well with the problem\\'s constraints.\\n\\nThe formal reasoning behind why Hierholzer\\'s works is fundamentally based on the properties of Eulerian paths and the constraints of the problem. Given the existence of an Eulerian path and the balanced in-degree and out-degree for each vertex, Hierholzer\\'s will construct the path by traversing each edge exactly once, thus providing a valid answer."
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Hint : Use DFS with a stack, sort destinations, and mark used tickets to find the itinerary!"
                    },
                    {
                        "username": "c910335",
                        "content": "Whoever wrote the program that produces the expected answer, well done!\\n\\n```rb\\n[[\"JFK\",\"YZZ\"], [\"YZZ\", \"JFK\"], [\"JFK\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"]]\\n```\\n\\n![](https://i.imgur.com/UMAEfvY.png)"
                    },
                    {
                        "username": "c910335",
                        "content": "[@lucasscodes](/lucasscodes) 100% reproducible"
                    },
                    {
                        "username": "kenlau",
                        "content": "Looks like the online judge got TLE ..."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "cannot reproduce?"
                    },
                    {
                        "username": "advfeature",
                        "content": "That means you might have to visit certain edges multiple times. That broke my first submission!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "yes you have to use all the ticket even revisiting it \\nknow more about from here  - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "kwonkyu",
                        "content": "At 29th test case, \\n[[\"EZE\",\"TIA\"],[\"EZE\",\"HBA\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AXA\"],[\"ANU\",\"JFK\"],[\"ADL\",\"ANU\"],**[\"TIA\",\"AUA\"]**,[\"ANU\",\"AUA\"],[\"ADL\",\"EZE\"],[\"ADL\",\"EZE\"],[\"EZE\",\"ADL\"],[\"AXA\",\"EZE\"],[\"AUA\",\"AXA\"],[\"JFK\",\"AXA\"],[\"AXA\",\"AUA\"],[\"AUA\",\"ADL\"],[\"ANU\",\"EZE\"],**[\"TIA\",\"ADL\"]**,[\"EZE\",\"ANU\"],[\"AUA\",\"ANU\"]]\\n\\nThere\\'re two destinations from \"TIA\", which are \"ADL\" and \"AUA\".\\nSo I thought the result should be like [..., \"TIA\", \"ADL\", ..., \"TIA\", \"AUA\", ...] but test case shows [..., \"TIA\", \"AUA\", ..., \"TIA\", \"ADL\", ...].\\n~~Isn\\'t \"ADL\" is prior to \"AUA\" in lexical order? Or should I manually select ticket to use all of my tickets even if it\\'s not in lexical order?~~\\n\\n~~I\\'m not native speaker so I may missed some points but I can\\'t tell what it is. Does anyone know?~~\\n\\nOh I was stupid\\uD83D\\uDE05 Description said \"You must use all tickets\" so...\\ngotta get some sleep. my brain\\'s not working."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@user5400vw](/user5400vw)  I got this and solved it too, then got stuck at the 33rd testcase."
                    },
                    {
                        "username": "user5400vw",
                        "content": "if u guys get this test case you\\'re halfway there."
                    },
                    {
                        "username": "segfz",
                        "content": "Consider test case [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nexpected result: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\nI expect the result to be : [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\nAm I correct to say \"NRT\" is lexically larger than \"KUL\"?\\n\\nI am sure I have gotten it wrong but what is it?\\n\\nThank you so much"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "but after selecting jul you get dead end you cannot go anywhere \\nknow more about this here - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "The answer should be: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] since there is no path from KUL to NRT, so [\"JFK\",\"KUL\",\"NRT\",\"JFK\"] cannot be a valid answer. We need to return the lexicographically smallest VALID answer."
                    },
                    {
                        "username": "mohitgupta1194",
                        "content": "Are there questions similar to this problem i.e. which uses this eulerian path algorithm?"
                    },
                    {
                        "username": "Kajal_Joshi",
                        "content": "As per the problem, smaller lexical value string should come before in itinerary sequence.\\n\\nso [\"JFK\",\"KUL\"] is smaller than [\"JFK\",\"NRT\"],\\nso ouput should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\n\\nbut expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nPlease someone explain how this output is calculated?"
                    },
                    {
                        "username": "90K2",
                        "content": "The test case is [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nAnd the expected answer is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] but why? If [JFK, KUL] < [JFK, NRT]"
                    },
                    {
                        "username": "ysingh",
                        "content": "I tried [[\"JFK\", \"LGA\"],[\"JFK\", \"LGB\"]] as a test case and got this as expected answer:\\n[\"JFK\",\"LGB\",\"LGA\"].\\n\\nTwo concerns regarding the expected answer:\\n1) How could this be valid answer when there is no flight between LGB->LGA? \\nDoes the itinerary [\"JFK\",\"LGB\",\"LGA\"] implies that there should be a valid flight between \"JFK\"->\"LGB\" &  \"LGB\" ->\"LGA\".\\n2) Also shouldn't LGA come before LGB as per lexical ordering?"
                    }
                ]
            },
            {
                "id": 2057491,
                "content": [
                    {
                        "username": "phaniram28",
                        "content": "Could anyone help me understand why does Hierholzer\\'s algorithm work in this problem??\\nI see that the problme mentions there exists an answer, is that the valid reason, why if we keep traversing and backtracking on a dead end, would give us a valid answer??\\n\\nI\\'m looking for more formal explaination/logic than simple words, could anyone help??\\n\\n\\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@bparanj](/bparanj) Can u please tell what would be the time complexity of backtracking approach ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Hierholzer\\'s algorithm is typically used to find an Eulerian path or circuit in a graph. An Eulerian path is a trail in a graph that visits every edge exactly once. The algorithm works well in this problem because of a few key properties:\\n\\n1. **Existence of Eulerian Path**: The problem guarantees that an Eulerian path exists, i.e., you can travel every \\'ticket\\' exactly once. This is confirmed by the problem\\'s condition that an answer always exists.\\n\\n2. **Directed Graph**: The tickets can be considered as directed edges in a graph. You can only go from the \"from\" airport to the \"to\" airport as specified on each ticket. Hierholzer\\'s algorithm can easily adapt to directed graphs.\\n\\n3. **Degree of Vertices**: In an Eulerian path, each vertex (except possibly for the start and end vertex) has an equal in-degree and out-degree. This means you can \\'enter\\' and \\'leave\\' each vertex the same number of times. In the problem, the number of tickets to enter an airport would be the same as the number to leave, except for JFK (the start) and possibly another airport if the path is not a circuit.\\n\\n4. **Dead Ends and Backtracking**: Hierholzer\\'s algorithm naturally handles dead ends via backtracking. When you hit a dead-end, you know you\\'ve traversed all outgoing edges (tickets) for that vertex (airport). You can then backtrack and continue traversing other unexplored edges, eventually forming the Eulerian path.\\n\\n5. **Lexicographic Ordering**: While Hierholzer\\'s doesn\\'t inherently give a lexicographically minimal path, you can achieve this by always choosing the smallest available vertex to visit next, which aligns well with the problem\\'s constraints.\\n\\nThe formal reasoning behind why Hierholzer\\'s works is fundamentally based on the properties of Eulerian paths and the constraints of the problem. Given the existence of an Eulerian path and the balanced in-degree and out-degree for each vertex, Hierholzer\\'s will construct the path by traversing each edge exactly once, thus providing a valid answer."
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Hint : Use DFS with a stack, sort destinations, and mark used tickets to find the itinerary!"
                    },
                    {
                        "username": "c910335",
                        "content": "Whoever wrote the program that produces the expected answer, well done!\\n\\n```rb\\n[[\"JFK\",\"YZZ\"], [\"YZZ\", \"JFK\"], [\"JFK\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"]]\\n```\\n\\n![](https://i.imgur.com/UMAEfvY.png)"
                    },
                    {
                        "username": "c910335",
                        "content": "[@lucasscodes](/lucasscodes) 100% reproducible"
                    },
                    {
                        "username": "kenlau",
                        "content": "Looks like the online judge got TLE ..."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "cannot reproduce?"
                    },
                    {
                        "username": "advfeature",
                        "content": "That means you might have to visit certain edges multiple times. That broke my first submission!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "yes you have to use all the ticket even revisiting it \\nknow more about from here  - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "kwonkyu",
                        "content": "At 29th test case, \\n[[\"EZE\",\"TIA\"],[\"EZE\",\"HBA\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AXA\"],[\"ANU\",\"JFK\"],[\"ADL\",\"ANU\"],**[\"TIA\",\"AUA\"]**,[\"ANU\",\"AUA\"],[\"ADL\",\"EZE\"],[\"ADL\",\"EZE\"],[\"EZE\",\"ADL\"],[\"AXA\",\"EZE\"],[\"AUA\",\"AXA\"],[\"JFK\",\"AXA\"],[\"AXA\",\"AUA\"],[\"AUA\",\"ADL\"],[\"ANU\",\"EZE\"],**[\"TIA\",\"ADL\"]**,[\"EZE\",\"ANU\"],[\"AUA\",\"ANU\"]]\\n\\nThere\\'re two destinations from \"TIA\", which are \"ADL\" and \"AUA\".\\nSo I thought the result should be like [..., \"TIA\", \"ADL\", ..., \"TIA\", \"AUA\", ...] but test case shows [..., \"TIA\", \"AUA\", ..., \"TIA\", \"ADL\", ...].\\n~~Isn\\'t \"ADL\" is prior to \"AUA\" in lexical order? Or should I manually select ticket to use all of my tickets even if it\\'s not in lexical order?~~\\n\\n~~I\\'m not native speaker so I may missed some points but I can\\'t tell what it is. Does anyone know?~~\\n\\nOh I was stupid\\uD83D\\uDE05 Description said \"You must use all tickets\" so...\\ngotta get some sleep. my brain\\'s not working."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@user5400vw](/user5400vw)  I got this and solved it too, then got stuck at the 33rd testcase."
                    },
                    {
                        "username": "user5400vw",
                        "content": "if u guys get this test case you\\'re halfway there."
                    },
                    {
                        "username": "segfz",
                        "content": "Consider test case [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nexpected result: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\nI expect the result to be : [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\nAm I correct to say \"NRT\" is lexically larger than \"KUL\"?\\n\\nI am sure I have gotten it wrong but what is it?\\n\\nThank you so much"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "but after selecting jul you get dead end you cannot go anywhere \\nknow more about this here - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "The answer should be: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] since there is no path from KUL to NRT, so [\"JFK\",\"KUL\",\"NRT\",\"JFK\"] cannot be a valid answer. We need to return the lexicographically smallest VALID answer."
                    },
                    {
                        "username": "mohitgupta1194",
                        "content": "Are there questions similar to this problem i.e. which uses this eulerian path algorithm?"
                    },
                    {
                        "username": "Kajal_Joshi",
                        "content": "As per the problem, smaller lexical value string should come before in itinerary sequence.\\n\\nso [\"JFK\",\"KUL\"] is smaller than [\"JFK\",\"NRT\"],\\nso ouput should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\n\\nbut expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nPlease someone explain how this output is calculated?"
                    },
                    {
                        "username": "90K2",
                        "content": "The test case is [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nAnd the expected answer is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] but why? If [JFK, KUL] < [JFK, NRT]"
                    },
                    {
                        "username": "ysingh",
                        "content": "I tried [[\"JFK\", \"LGA\"],[\"JFK\", \"LGB\"]] as a test case and got this as expected answer:\\n[\"JFK\",\"LGB\",\"LGA\"].\\n\\nTwo concerns regarding the expected answer:\\n1) How could this be valid answer when there is no flight between LGB->LGA? \\nDoes the itinerary [\"JFK\",\"LGB\",\"LGA\"] implies that there should be a valid flight between \"JFK\"->\"LGB\" &  \"LGB\" ->\"LGA\".\\n2) Also shouldn't LGA come before LGB as per lexical ordering?"
                    }
                ]
            },
            {
                "id": 1570775,
                "content": [
                    {
                        "username": "phaniram28",
                        "content": "Could anyone help me understand why does Hierholzer\\'s algorithm work in this problem??\\nI see that the problme mentions there exists an answer, is that the valid reason, why if we keep traversing and backtracking on a dead end, would give us a valid answer??\\n\\nI\\'m looking for more formal explaination/logic than simple words, could anyone help??\\n\\n\\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@bparanj](/bparanj) Can u please tell what would be the time complexity of backtracking approach ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Hierholzer\\'s algorithm is typically used to find an Eulerian path or circuit in a graph. An Eulerian path is a trail in a graph that visits every edge exactly once. The algorithm works well in this problem because of a few key properties:\\n\\n1. **Existence of Eulerian Path**: The problem guarantees that an Eulerian path exists, i.e., you can travel every \\'ticket\\' exactly once. This is confirmed by the problem\\'s condition that an answer always exists.\\n\\n2. **Directed Graph**: The tickets can be considered as directed edges in a graph. You can only go from the \"from\" airport to the \"to\" airport as specified on each ticket. Hierholzer\\'s algorithm can easily adapt to directed graphs.\\n\\n3. **Degree of Vertices**: In an Eulerian path, each vertex (except possibly for the start and end vertex) has an equal in-degree and out-degree. This means you can \\'enter\\' and \\'leave\\' each vertex the same number of times. In the problem, the number of tickets to enter an airport would be the same as the number to leave, except for JFK (the start) and possibly another airport if the path is not a circuit.\\n\\n4. **Dead Ends and Backtracking**: Hierholzer\\'s algorithm naturally handles dead ends via backtracking. When you hit a dead-end, you know you\\'ve traversed all outgoing edges (tickets) for that vertex (airport). You can then backtrack and continue traversing other unexplored edges, eventually forming the Eulerian path.\\n\\n5. **Lexicographic Ordering**: While Hierholzer\\'s doesn\\'t inherently give a lexicographically minimal path, you can achieve this by always choosing the smallest available vertex to visit next, which aligns well with the problem\\'s constraints.\\n\\nThe formal reasoning behind why Hierholzer\\'s works is fundamentally based on the properties of Eulerian paths and the constraints of the problem. Given the existence of an Eulerian path and the balanced in-degree and out-degree for each vertex, Hierholzer\\'s will construct the path by traversing each edge exactly once, thus providing a valid answer."
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Hint : Use DFS with a stack, sort destinations, and mark used tickets to find the itinerary!"
                    },
                    {
                        "username": "c910335",
                        "content": "Whoever wrote the program that produces the expected answer, well done!\\n\\n```rb\\n[[\"JFK\",\"YZZ\"], [\"YZZ\", \"JFK\"], [\"JFK\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"]]\\n```\\n\\n![](https://i.imgur.com/UMAEfvY.png)"
                    },
                    {
                        "username": "c910335",
                        "content": "[@lucasscodes](/lucasscodes) 100% reproducible"
                    },
                    {
                        "username": "kenlau",
                        "content": "Looks like the online judge got TLE ..."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "cannot reproduce?"
                    },
                    {
                        "username": "advfeature",
                        "content": "That means you might have to visit certain edges multiple times. That broke my first submission!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "yes you have to use all the ticket even revisiting it \\nknow more about from here  - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "kwonkyu",
                        "content": "At 29th test case, \\n[[\"EZE\",\"TIA\"],[\"EZE\",\"HBA\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AXA\"],[\"ANU\",\"JFK\"],[\"ADL\",\"ANU\"],**[\"TIA\",\"AUA\"]**,[\"ANU\",\"AUA\"],[\"ADL\",\"EZE\"],[\"ADL\",\"EZE\"],[\"EZE\",\"ADL\"],[\"AXA\",\"EZE\"],[\"AUA\",\"AXA\"],[\"JFK\",\"AXA\"],[\"AXA\",\"AUA\"],[\"AUA\",\"ADL\"],[\"ANU\",\"EZE\"],**[\"TIA\",\"ADL\"]**,[\"EZE\",\"ANU\"],[\"AUA\",\"ANU\"]]\\n\\nThere\\'re two destinations from \"TIA\", which are \"ADL\" and \"AUA\".\\nSo I thought the result should be like [..., \"TIA\", \"ADL\", ..., \"TIA\", \"AUA\", ...] but test case shows [..., \"TIA\", \"AUA\", ..., \"TIA\", \"ADL\", ...].\\n~~Isn\\'t \"ADL\" is prior to \"AUA\" in lexical order? Or should I manually select ticket to use all of my tickets even if it\\'s not in lexical order?~~\\n\\n~~I\\'m not native speaker so I may missed some points but I can\\'t tell what it is. Does anyone know?~~\\n\\nOh I was stupid\\uD83D\\uDE05 Description said \"You must use all tickets\" so...\\ngotta get some sleep. my brain\\'s not working."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@user5400vw](/user5400vw)  I got this and solved it too, then got stuck at the 33rd testcase."
                    },
                    {
                        "username": "user5400vw",
                        "content": "if u guys get this test case you\\'re halfway there."
                    },
                    {
                        "username": "segfz",
                        "content": "Consider test case [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nexpected result: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\nI expect the result to be : [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\nAm I correct to say \"NRT\" is lexically larger than \"KUL\"?\\n\\nI am sure I have gotten it wrong but what is it?\\n\\nThank you so much"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "but after selecting jul you get dead end you cannot go anywhere \\nknow more about this here - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "The answer should be: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] since there is no path from KUL to NRT, so [\"JFK\",\"KUL\",\"NRT\",\"JFK\"] cannot be a valid answer. We need to return the lexicographically smallest VALID answer."
                    },
                    {
                        "username": "mohitgupta1194",
                        "content": "Are there questions similar to this problem i.e. which uses this eulerian path algorithm?"
                    },
                    {
                        "username": "Kajal_Joshi",
                        "content": "As per the problem, smaller lexical value string should come before in itinerary sequence.\\n\\nso [\"JFK\",\"KUL\"] is smaller than [\"JFK\",\"NRT\"],\\nso ouput should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\n\\nbut expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nPlease someone explain how this output is calculated?"
                    },
                    {
                        "username": "90K2",
                        "content": "The test case is [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nAnd the expected answer is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] but why? If [JFK, KUL] < [JFK, NRT]"
                    },
                    {
                        "username": "ysingh",
                        "content": "I tried [[\"JFK\", \"LGA\"],[\"JFK\", \"LGB\"]] as a test case and got this as expected answer:\\n[\"JFK\",\"LGB\",\"LGA\"].\\n\\nTwo concerns regarding the expected answer:\\n1) How could this be valid answer when there is no flight between LGB->LGA? \\nDoes the itinerary [\"JFK\",\"LGB\",\"LGA\"] implies that there should be a valid flight between \"JFK\"->\"LGB\" &  \"LGB\" ->\"LGA\".\\n2) Also shouldn't LGA come before LGB as per lexical ordering?"
                    }
                ]
            },
            {
                "id": 1575083,
                "content": [
                    {
                        "username": "phaniram28",
                        "content": "Could anyone help me understand why does Hierholzer\\'s algorithm work in this problem??\\nI see that the problme mentions there exists an answer, is that the valid reason, why if we keep traversing and backtracking on a dead end, would give us a valid answer??\\n\\nI\\'m looking for more formal explaination/logic than simple words, could anyone help??\\n\\n\\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@bparanj](/bparanj) Can u please tell what would be the time complexity of backtracking approach ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Hierholzer\\'s algorithm is typically used to find an Eulerian path or circuit in a graph. An Eulerian path is a trail in a graph that visits every edge exactly once. The algorithm works well in this problem because of a few key properties:\\n\\n1. **Existence of Eulerian Path**: The problem guarantees that an Eulerian path exists, i.e., you can travel every \\'ticket\\' exactly once. This is confirmed by the problem\\'s condition that an answer always exists.\\n\\n2. **Directed Graph**: The tickets can be considered as directed edges in a graph. You can only go from the \"from\" airport to the \"to\" airport as specified on each ticket. Hierholzer\\'s algorithm can easily adapt to directed graphs.\\n\\n3. **Degree of Vertices**: In an Eulerian path, each vertex (except possibly for the start and end vertex) has an equal in-degree and out-degree. This means you can \\'enter\\' and \\'leave\\' each vertex the same number of times. In the problem, the number of tickets to enter an airport would be the same as the number to leave, except for JFK (the start) and possibly another airport if the path is not a circuit.\\n\\n4. **Dead Ends and Backtracking**: Hierholzer\\'s algorithm naturally handles dead ends via backtracking. When you hit a dead-end, you know you\\'ve traversed all outgoing edges (tickets) for that vertex (airport). You can then backtrack and continue traversing other unexplored edges, eventually forming the Eulerian path.\\n\\n5. **Lexicographic Ordering**: While Hierholzer\\'s doesn\\'t inherently give a lexicographically minimal path, you can achieve this by always choosing the smallest available vertex to visit next, which aligns well with the problem\\'s constraints.\\n\\nThe formal reasoning behind why Hierholzer\\'s works is fundamentally based on the properties of Eulerian paths and the constraints of the problem. Given the existence of an Eulerian path and the balanced in-degree and out-degree for each vertex, Hierholzer\\'s will construct the path by traversing each edge exactly once, thus providing a valid answer."
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Hint : Use DFS with a stack, sort destinations, and mark used tickets to find the itinerary!"
                    },
                    {
                        "username": "c910335",
                        "content": "Whoever wrote the program that produces the expected answer, well done!\\n\\n```rb\\n[[\"JFK\",\"YZZ\"], [\"YZZ\", \"JFK\"], [\"JFK\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"]]\\n```\\n\\n![](https://i.imgur.com/UMAEfvY.png)"
                    },
                    {
                        "username": "c910335",
                        "content": "[@lucasscodes](/lucasscodes) 100% reproducible"
                    },
                    {
                        "username": "kenlau",
                        "content": "Looks like the online judge got TLE ..."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "cannot reproduce?"
                    },
                    {
                        "username": "advfeature",
                        "content": "That means you might have to visit certain edges multiple times. That broke my first submission!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "yes you have to use all the ticket even revisiting it \\nknow more about from here  - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "kwonkyu",
                        "content": "At 29th test case, \\n[[\"EZE\",\"TIA\"],[\"EZE\",\"HBA\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AXA\"],[\"ANU\",\"JFK\"],[\"ADL\",\"ANU\"],**[\"TIA\",\"AUA\"]**,[\"ANU\",\"AUA\"],[\"ADL\",\"EZE\"],[\"ADL\",\"EZE\"],[\"EZE\",\"ADL\"],[\"AXA\",\"EZE\"],[\"AUA\",\"AXA\"],[\"JFK\",\"AXA\"],[\"AXA\",\"AUA\"],[\"AUA\",\"ADL\"],[\"ANU\",\"EZE\"],**[\"TIA\",\"ADL\"]**,[\"EZE\",\"ANU\"],[\"AUA\",\"ANU\"]]\\n\\nThere\\'re two destinations from \"TIA\", which are \"ADL\" and \"AUA\".\\nSo I thought the result should be like [..., \"TIA\", \"ADL\", ..., \"TIA\", \"AUA\", ...] but test case shows [..., \"TIA\", \"AUA\", ..., \"TIA\", \"ADL\", ...].\\n~~Isn\\'t \"ADL\" is prior to \"AUA\" in lexical order? Or should I manually select ticket to use all of my tickets even if it\\'s not in lexical order?~~\\n\\n~~I\\'m not native speaker so I may missed some points but I can\\'t tell what it is. Does anyone know?~~\\n\\nOh I was stupid\\uD83D\\uDE05 Description said \"You must use all tickets\" so...\\ngotta get some sleep. my brain\\'s not working."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@user5400vw](/user5400vw)  I got this and solved it too, then got stuck at the 33rd testcase."
                    },
                    {
                        "username": "user5400vw",
                        "content": "if u guys get this test case you\\'re halfway there."
                    },
                    {
                        "username": "segfz",
                        "content": "Consider test case [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nexpected result: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\nI expect the result to be : [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\nAm I correct to say \"NRT\" is lexically larger than \"KUL\"?\\n\\nI am sure I have gotten it wrong but what is it?\\n\\nThank you so much"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "but after selecting jul you get dead end you cannot go anywhere \\nknow more about this here - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "The answer should be: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] since there is no path from KUL to NRT, so [\"JFK\",\"KUL\",\"NRT\",\"JFK\"] cannot be a valid answer. We need to return the lexicographically smallest VALID answer."
                    },
                    {
                        "username": "mohitgupta1194",
                        "content": "Are there questions similar to this problem i.e. which uses this eulerian path algorithm?"
                    },
                    {
                        "username": "Kajal_Joshi",
                        "content": "As per the problem, smaller lexical value string should come before in itinerary sequence.\\n\\nso [\"JFK\",\"KUL\"] is smaller than [\"JFK\",\"NRT\"],\\nso ouput should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\n\\nbut expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nPlease someone explain how this output is calculated?"
                    },
                    {
                        "username": "90K2",
                        "content": "The test case is [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nAnd the expected answer is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] but why? If [JFK, KUL] < [JFK, NRT]"
                    },
                    {
                        "username": "ysingh",
                        "content": "I tried [[\"JFK\", \"LGA\"],[\"JFK\", \"LGB\"]] as a test case and got this as expected answer:\\n[\"JFK\",\"LGB\",\"LGA\"].\\n\\nTwo concerns regarding the expected answer:\\n1) How could this be valid answer when there is no flight between LGB->LGA? \\nDoes the itinerary [\"JFK\",\"LGB\",\"LGA\"] implies that there should be a valid flight between \"JFK\"->\"LGB\" &  \"LGB\" ->\"LGA\".\\n2) Also shouldn't LGA come before LGB as per lexical ordering?"
                    }
                ]
            },
            {
                "id": 1570329,
                "content": [
                    {
                        "username": "phaniram28",
                        "content": "Could anyone help me understand why does Hierholzer\\'s algorithm work in this problem??\\nI see that the problme mentions there exists an answer, is that the valid reason, why if we keep traversing and backtracking on a dead end, would give us a valid answer??\\n\\nI\\'m looking for more formal explaination/logic than simple words, could anyone help??\\n\\n\\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@bparanj](/bparanj) Can u please tell what would be the time complexity of backtracking approach ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Hierholzer\\'s algorithm is typically used to find an Eulerian path or circuit in a graph. An Eulerian path is a trail in a graph that visits every edge exactly once. The algorithm works well in this problem because of a few key properties:\\n\\n1. **Existence of Eulerian Path**: The problem guarantees that an Eulerian path exists, i.e., you can travel every \\'ticket\\' exactly once. This is confirmed by the problem\\'s condition that an answer always exists.\\n\\n2. **Directed Graph**: The tickets can be considered as directed edges in a graph. You can only go from the \"from\" airport to the \"to\" airport as specified on each ticket. Hierholzer\\'s algorithm can easily adapt to directed graphs.\\n\\n3. **Degree of Vertices**: In an Eulerian path, each vertex (except possibly for the start and end vertex) has an equal in-degree and out-degree. This means you can \\'enter\\' and \\'leave\\' each vertex the same number of times. In the problem, the number of tickets to enter an airport would be the same as the number to leave, except for JFK (the start) and possibly another airport if the path is not a circuit.\\n\\n4. **Dead Ends and Backtracking**: Hierholzer\\'s algorithm naturally handles dead ends via backtracking. When you hit a dead-end, you know you\\'ve traversed all outgoing edges (tickets) for that vertex (airport). You can then backtrack and continue traversing other unexplored edges, eventually forming the Eulerian path.\\n\\n5. **Lexicographic Ordering**: While Hierholzer\\'s doesn\\'t inherently give a lexicographically minimal path, you can achieve this by always choosing the smallest available vertex to visit next, which aligns well with the problem\\'s constraints.\\n\\nThe formal reasoning behind why Hierholzer\\'s works is fundamentally based on the properties of Eulerian paths and the constraints of the problem. Given the existence of an Eulerian path and the balanced in-degree and out-degree for each vertex, Hierholzer\\'s will construct the path by traversing each edge exactly once, thus providing a valid answer."
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Hint : Use DFS with a stack, sort destinations, and mark used tickets to find the itinerary!"
                    },
                    {
                        "username": "c910335",
                        "content": "Whoever wrote the program that produces the expected answer, well done!\\n\\n```rb\\n[[\"JFK\",\"YZZ\"], [\"YZZ\", \"JFK\"], [\"JFK\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"]]\\n```\\n\\n![](https://i.imgur.com/UMAEfvY.png)"
                    },
                    {
                        "username": "c910335",
                        "content": "[@lucasscodes](/lucasscodes) 100% reproducible"
                    },
                    {
                        "username": "kenlau",
                        "content": "Looks like the online judge got TLE ..."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "cannot reproduce?"
                    },
                    {
                        "username": "advfeature",
                        "content": "That means you might have to visit certain edges multiple times. That broke my first submission!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "yes you have to use all the ticket even revisiting it \\nknow more about from here  - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "kwonkyu",
                        "content": "At 29th test case, \\n[[\"EZE\",\"TIA\"],[\"EZE\",\"HBA\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AXA\"],[\"ANU\",\"JFK\"],[\"ADL\",\"ANU\"],**[\"TIA\",\"AUA\"]**,[\"ANU\",\"AUA\"],[\"ADL\",\"EZE\"],[\"ADL\",\"EZE\"],[\"EZE\",\"ADL\"],[\"AXA\",\"EZE\"],[\"AUA\",\"AXA\"],[\"JFK\",\"AXA\"],[\"AXA\",\"AUA\"],[\"AUA\",\"ADL\"],[\"ANU\",\"EZE\"],**[\"TIA\",\"ADL\"]**,[\"EZE\",\"ANU\"],[\"AUA\",\"ANU\"]]\\n\\nThere\\'re two destinations from \"TIA\", which are \"ADL\" and \"AUA\".\\nSo I thought the result should be like [..., \"TIA\", \"ADL\", ..., \"TIA\", \"AUA\", ...] but test case shows [..., \"TIA\", \"AUA\", ..., \"TIA\", \"ADL\", ...].\\n~~Isn\\'t \"ADL\" is prior to \"AUA\" in lexical order? Or should I manually select ticket to use all of my tickets even if it\\'s not in lexical order?~~\\n\\n~~I\\'m not native speaker so I may missed some points but I can\\'t tell what it is. Does anyone know?~~\\n\\nOh I was stupid\\uD83D\\uDE05 Description said \"You must use all tickets\" so...\\ngotta get some sleep. my brain\\'s not working."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@user5400vw](/user5400vw)  I got this and solved it too, then got stuck at the 33rd testcase."
                    },
                    {
                        "username": "user5400vw",
                        "content": "if u guys get this test case you\\'re halfway there."
                    },
                    {
                        "username": "segfz",
                        "content": "Consider test case [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nexpected result: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\nI expect the result to be : [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\nAm I correct to say \"NRT\" is lexically larger than \"KUL\"?\\n\\nI am sure I have gotten it wrong but what is it?\\n\\nThank you so much"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "but after selecting jul you get dead end you cannot go anywhere \\nknow more about this here - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "The answer should be: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] since there is no path from KUL to NRT, so [\"JFK\",\"KUL\",\"NRT\",\"JFK\"] cannot be a valid answer. We need to return the lexicographically smallest VALID answer."
                    },
                    {
                        "username": "mohitgupta1194",
                        "content": "Are there questions similar to this problem i.e. which uses this eulerian path algorithm?"
                    },
                    {
                        "username": "Kajal_Joshi",
                        "content": "As per the problem, smaller lexical value string should come before in itinerary sequence.\\n\\nso [\"JFK\",\"KUL\"] is smaller than [\"JFK\",\"NRT\"],\\nso ouput should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\n\\nbut expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nPlease someone explain how this output is calculated?"
                    },
                    {
                        "username": "90K2",
                        "content": "The test case is [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nAnd the expected answer is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] but why? If [JFK, KUL] < [JFK, NRT]"
                    },
                    {
                        "username": "ysingh",
                        "content": "I tried [[\"JFK\", \"LGA\"],[\"JFK\", \"LGB\"]] as a test case and got this as expected answer:\\n[\"JFK\",\"LGB\",\"LGA\"].\\n\\nTwo concerns regarding the expected answer:\\n1) How could this be valid answer when there is no flight between LGB->LGA? \\nDoes the itinerary [\"JFK\",\"LGB\",\"LGA\"] implies that there should be a valid flight between \"JFK\"->\"LGB\" &  \"LGB\" ->\"LGA\".\\n2) Also shouldn't LGA come before LGB as per lexical ordering?"
                    }
                ]
            },
            {
                "id": 1573546,
                "content": [
                    {
                        "username": "phaniram28",
                        "content": "Could anyone help me understand why does Hierholzer\\'s algorithm work in this problem??\\nI see that the problme mentions there exists an answer, is that the valid reason, why if we keep traversing and backtracking on a dead end, would give us a valid answer??\\n\\nI\\'m looking for more formal explaination/logic than simple words, could anyone help??\\n\\n\\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@bparanj](/bparanj) Can u please tell what would be the time complexity of backtracking approach ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Hierholzer\\'s algorithm is typically used to find an Eulerian path or circuit in a graph. An Eulerian path is a trail in a graph that visits every edge exactly once. The algorithm works well in this problem because of a few key properties:\\n\\n1. **Existence of Eulerian Path**: The problem guarantees that an Eulerian path exists, i.e., you can travel every \\'ticket\\' exactly once. This is confirmed by the problem\\'s condition that an answer always exists.\\n\\n2. **Directed Graph**: The tickets can be considered as directed edges in a graph. You can only go from the \"from\" airport to the \"to\" airport as specified on each ticket. Hierholzer\\'s algorithm can easily adapt to directed graphs.\\n\\n3. **Degree of Vertices**: In an Eulerian path, each vertex (except possibly for the start and end vertex) has an equal in-degree and out-degree. This means you can \\'enter\\' and \\'leave\\' each vertex the same number of times. In the problem, the number of tickets to enter an airport would be the same as the number to leave, except for JFK (the start) and possibly another airport if the path is not a circuit.\\n\\n4. **Dead Ends and Backtracking**: Hierholzer\\'s algorithm naturally handles dead ends via backtracking. When you hit a dead-end, you know you\\'ve traversed all outgoing edges (tickets) for that vertex (airport). You can then backtrack and continue traversing other unexplored edges, eventually forming the Eulerian path.\\n\\n5. **Lexicographic Ordering**: While Hierholzer\\'s doesn\\'t inherently give a lexicographically minimal path, you can achieve this by always choosing the smallest available vertex to visit next, which aligns well with the problem\\'s constraints.\\n\\nThe formal reasoning behind why Hierholzer\\'s works is fundamentally based on the properties of Eulerian paths and the constraints of the problem. Given the existence of an Eulerian path and the balanced in-degree and out-degree for each vertex, Hierholzer\\'s will construct the path by traversing each edge exactly once, thus providing a valid answer."
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Hint : Use DFS with a stack, sort destinations, and mark used tickets to find the itinerary!"
                    },
                    {
                        "username": "c910335",
                        "content": "Whoever wrote the program that produces the expected answer, well done!\\n\\n```rb\\n[[\"JFK\",\"YZZ\"], [\"YZZ\", \"JFK\"], [\"JFK\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"]]\\n```\\n\\n![](https://i.imgur.com/UMAEfvY.png)"
                    },
                    {
                        "username": "c910335",
                        "content": "[@lucasscodes](/lucasscodes) 100% reproducible"
                    },
                    {
                        "username": "kenlau",
                        "content": "Looks like the online judge got TLE ..."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "cannot reproduce?"
                    },
                    {
                        "username": "advfeature",
                        "content": "That means you might have to visit certain edges multiple times. That broke my first submission!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "yes you have to use all the ticket even revisiting it \\nknow more about from here  - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "kwonkyu",
                        "content": "At 29th test case, \\n[[\"EZE\",\"TIA\"],[\"EZE\",\"HBA\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AXA\"],[\"ANU\",\"JFK\"],[\"ADL\",\"ANU\"],**[\"TIA\",\"AUA\"]**,[\"ANU\",\"AUA\"],[\"ADL\",\"EZE\"],[\"ADL\",\"EZE\"],[\"EZE\",\"ADL\"],[\"AXA\",\"EZE\"],[\"AUA\",\"AXA\"],[\"JFK\",\"AXA\"],[\"AXA\",\"AUA\"],[\"AUA\",\"ADL\"],[\"ANU\",\"EZE\"],**[\"TIA\",\"ADL\"]**,[\"EZE\",\"ANU\"],[\"AUA\",\"ANU\"]]\\n\\nThere\\'re two destinations from \"TIA\", which are \"ADL\" and \"AUA\".\\nSo I thought the result should be like [..., \"TIA\", \"ADL\", ..., \"TIA\", \"AUA\", ...] but test case shows [..., \"TIA\", \"AUA\", ..., \"TIA\", \"ADL\", ...].\\n~~Isn\\'t \"ADL\" is prior to \"AUA\" in lexical order? Or should I manually select ticket to use all of my tickets even if it\\'s not in lexical order?~~\\n\\n~~I\\'m not native speaker so I may missed some points but I can\\'t tell what it is. Does anyone know?~~\\n\\nOh I was stupid\\uD83D\\uDE05 Description said \"You must use all tickets\" so...\\ngotta get some sleep. my brain\\'s not working."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@user5400vw](/user5400vw)  I got this and solved it too, then got stuck at the 33rd testcase."
                    },
                    {
                        "username": "user5400vw",
                        "content": "if u guys get this test case you\\'re halfway there."
                    },
                    {
                        "username": "segfz",
                        "content": "Consider test case [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nexpected result: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\nI expect the result to be : [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\nAm I correct to say \"NRT\" is lexically larger than \"KUL\"?\\n\\nI am sure I have gotten it wrong but what is it?\\n\\nThank you so much"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "but after selecting jul you get dead end you cannot go anywhere \\nknow more about this here - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "The answer should be: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] since there is no path from KUL to NRT, so [\"JFK\",\"KUL\",\"NRT\",\"JFK\"] cannot be a valid answer. We need to return the lexicographically smallest VALID answer."
                    },
                    {
                        "username": "mohitgupta1194",
                        "content": "Are there questions similar to this problem i.e. which uses this eulerian path algorithm?"
                    },
                    {
                        "username": "Kajal_Joshi",
                        "content": "As per the problem, smaller lexical value string should come before in itinerary sequence.\\n\\nso [\"JFK\",\"KUL\"] is smaller than [\"JFK\",\"NRT\"],\\nso ouput should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\n\\nbut expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nPlease someone explain how this output is calculated?"
                    },
                    {
                        "username": "90K2",
                        "content": "The test case is [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nAnd the expected answer is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] but why? If [JFK, KUL] < [JFK, NRT]"
                    },
                    {
                        "username": "ysingh",
                        "content": "I tried [[\"JFK\", \"LGA\"],[\"JFK\", \"LGB\"]] as a test case and got this as expected answer:\\n[\"JFK\",\"LGB\",\"LGA\"].\\n\\nTwo concerns regarding the expected answer:\\n1) How could this be valid answer when there is no flight between LGB->LGA? \\nDoes the itinerary [\"JFK\",\"LGB\",\"LGA\"] implies that there should be a valid flight between \"JFK\"->\"LGB\" &  \"LGB\" ->\"LGA\".\\n2) Also shouldn't LGA come before LGB as per lexical ordering?"
                    }
                ]
            },
            {
                "id": 1569752,
                "content": [
                    {
                        "username": "phaniram28",
                        "content": "Could anyone help me understand why does Hierholzer\\'s algorithm work in this problem??\\nI see that the problme mentions there exists an answer, is that the valid reason, why if we keep traversing and backtracking on a dead end, would give us a valid answer??\\n\\nI\\'m looking for more formal explaination/logic than simple words, could anyone help??\\n\\n\\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@bparanj](/bparanj) Can u please tell what would be the time complexity of backtracking approach ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Hierholzer\\'s algorithm is typically used to find an Eulerian path or circuit in a graph. An Eulerian path is a trail in a graph that visits every edge exactly once. The algorithm works well in this problem because of a few key properties:\\n\\n1. **Existence of Eulerian Path**: The problem guarantees that an Eulerian path exists, i.e., you can travel every \\'ticket\\' exactly once. This is confirmed by the problem\\'s condition that an answer always exists.\\n\\n2. **Directed Graph**: The tickets can be considered as directed edges in a graph. You can only go from the \"from\" airport to the \"to\" airport as specified on each ticket. Hierholzer\\'s algorithm can easily adapt to directed graphs.\\n\\n3. **Degree of Vertices**: In an Eulerian path, each vertex (except possibly for the start and end vertex) has an equal in-degree and out-degree. This means you can \\'enter\\' and \\'leave\\' each vertex the same number of times. In the problem, the number of tickets to enter an airport would be the same as the number to leave, except for JFK (the start) and possibly another airport if the path is not a circuit.\\n\\n4. **Dead Ends and Backtracking**: Hierholzer\\'s algorithm naturally handles dead ends via backtracking. When you hit a dead-end, you know you\\'ve traversed all outgoing edges (tickets) for that vertex (airport). You can then backtrack and continue traversing other unexplored edges, eventually forming the Eulerian path.\\n\\n5. **Lexicographic Ordering**: While Hierholzer\\'s doesn\\'t inherently give a lexicographically minimal path, you can achieve this by always choosing the smallest available vertex to visit next, which aligns well with the problem\\'s constraints.\\n\\nThe formal reasoning behind why Hierholzer\\'s works is fundamentally based on the properties of Eulerian paths and the constraints of the problem. Given the existence of an Eulerian path and the balanced in-degree and out-degree for each vertex, Hierholzer\\'s will construct the path by traversing each edge exactly once, thus providing a valid answer."
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Hint : Use DFS with a stack, sort destinations, and mark used tickets to find the itinerary!"
                    },
                    {
                        "username": "c910335",
                        "content": "Whoever wrote the program that produces the expected answer, well done!\\n\\n```rb\\n[[\"JFK\",\"YZZ\"], [\"YZZ\", \"JFK\"], [\"JFK\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"]]\\n```\\n\\n![](https://i.imgur.com/UMAEfvY.png)"
                    },
                    {
                        "username": "c910335",
                        "content": "[@lucasscodes](/lucasscodes) 100% reproducible"
                    },
                    {
                        "username": "kenlau",
                        "content": "Looks like the online judge got TLE ..."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "cannot reproduce?"
                    },
                    {
                        "username": "advfeature",
                        "content": "That means you might have to visit certain edges multiple times. That broke my first submission!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "yes you have to use all the ticket even revisiting it \\nknow more about from here  - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "kwonkyu",
                        "content": "At 29th test case, \\n[[\"EZE\",\"TIA\"],[\"EZE\",\"HBA\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AXA\"],[\"ANU\",\"JFK\"],[\"ADL\",\"ANU\"],**[\"TIA\",\"AUA\"]**,[\"ANU\",\"AUA\"],[\"ADL\",\"EZE\"],[\"ADL\",\"EZE\"],[\"EZE\",\"ADL\"],[\"AXA\",\"EZE\"],[\"AUA\",\"AXA\"],[\"JFK\",\"AXA\"],[\"AXA\",\"AUA\"],[\"AUA\",\"ADL\"],[\"ANU\",\"EZE\"],**[\"TIA\",\"ADL\"]**,[\"EZE\",\"ANU\"],[\"AUA\",\"ANU\"]]\\n\\nThere\\'re two destinations from \"TIA\", which are \"ADL\" and \"AUA\".\\nSo I thought the result should be like [..., \"TIA\", \"ADL\", ..., \"TIA\", \"AUA\", ...] but test case shows [..., \"TIA\", \"AUA\", ..., \"TIA\", \"ADL\", ...].\\n~~Isn\\'t \"ADL\" is prior to \"AUA\" in lexical order? Or should I manually select ticket to use all of my tickets even if it\\'s not in lexical order?~~\\n\\n~~I\\'m not native speaker so I may missed some points but I can\\'t tell what it is. Does anyone know?~~\\n\\nOh I was stupid\\uD83D\\uDE05 Description said \"You must use all tickets\" so...\\ngotta get some sleep. my brain\\'s not working."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@user5400vw](/user5400vw)  I got this and solved it too, then got stuck at the 33rd testcase."
                    },
                    {
                        "username": "user5400vw",
                        "content": "if u guys get this test case you\\'re halfway there."
                    },
                    {
                        "username": "segfz",
                        "content": "Consider test case [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nexpected result: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\nI expect the result to be : [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\nAm I correct to say \"NRT\" is lexically larger than \"KUL\"?\\n\\nI am sure I have gotten it wrong but what is it?\\n\\nThank you so much"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "but after selecting jul you get dead end you cannot go anywhere \\nknow more about this here - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "The answer should be: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] since there is no path from KUL to NRT, so [\"JFK\",\"KUL\",\"NRT\",\"JFK\"] cannot be a valid answer. We need to return the lexicographically smallest VALID answer."
                    },
                    {
                        "username": "mohitgupta1194",
                        "content": "Are there questions similar to this problem i.e. which uses this eulerian path algorithm?"
                    },
                    {
                        "username": "Kajal_Joshi",
                        "content": "As per the problem, smaller lexical value string should come before in itinerary sequence.\\n\\nso [\"JFK\",\"KUL\"] is smaller than [\"JFK\",\"NRT\"],\\nso ouput should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\n\\nbut expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nPlease someone explain how this output is calculated?"
                    },
                    {
                        "username": "90K2",
                        "content": "The test case is [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nAnd the expected answer is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] but why? If [JFK, KUL] < [JFK, NRT]"
                    },
                    {
                        "username": "ysingh",
                        "content": "I tried [[\"JFK\", \"LGA\"],[\"JFK\", \"LGB\"]] as a test case and got this as expected answer:\\n[\"JFK\",\"LGB\",\"LGA\"].\\n\\nTwo concerns regarding the expected answer:\\n1) How could this be valid answer when there is no flight between LGB->LGA? \\nDoes the itinerary [\"JFK\",\"LGB\",\"LGA\"] implies that there should be a valid flight between \"JFK\"->\"LGB\" &  \"LGB\" ->\"LGA\".\\n2) Also shouldn't LGA come before LGB as per lexical ordering?"
                    }
                ]
            },
            {
                "id": 1569501,
                "content": [
                    {
                        "username": "phaniram28",
                        "content": "Could anyone help me understand why does Hierholzer\\'s algorithm work in this problem??\\nI see that the problme mentions there exists an answer, is that the valid reason, why if we keep traversing and backtracking on a dead end, would give us a valid answer??\\n\\nI\\'m looking for more formal explaination/logic than simple words, could anyone help??\\n\\n\\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@bparanj](/bparanj) Can u please tell what would be the time complexity of backtracking approach ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Hierholzer\\'s algorithm is typically used to find an Eulerian path or circuit in a graph. An Eulerian path is a trail in a graph that visits every edge exactly once. The algorithm works well in this problem because of a few key properties:\\n\\n1. **Existence of Eulerian Path**: The problem guarantees that an Eulerian path exists, i.e., you can travel every \\'ticket\\' exactly once. This is confirmed by the problem\\'s condition that an answer always exists.\\n\\n2. **Directed Graph**: The tickets can be considered as directed edges in a graph. You can only go from the \"from\" airport to the \"to\" airport as specified on each ticket. Hierholzer\\'s algorithm can easily adapt to directed graphs.\\n\\n3. **Degree of Vertices**: In an Eulerian path, each vertex (except possibly for the start and end vertex) has an equal in-degree and out-degree. This means you can \\'enter\\' and \\'leave\\' each vertex the same number of times. In the problem, the number of tickets to enter an airport would be the same as the number to leave, except for JFK (the start) and possibly another airport if the path is not a circuit.\\n\\n4. **Dead Ends and Backtracking**: Hierholzer\\'s algorithm naturally handles dead ends via backtracking. When you hit a dead-end, you know you\\'ve traversed all outgoing edges (tickets) for that vertex (airport). You can then backtrack and continue traversing other unexplored edges, eventually forming the Eulerian path.\\n\\n5. **Lexicographic Ordering**: While Hierholzer\\'s doesn\\'t inherently give a lexicographically minimal path, you can achieve this by always choosing the smallest available vertex to visit next, which aligns well with the problem\\'s constraints.\\n\\nThe formal reasoning behind why Hierholzer\\'s works is fundamentally based on the properties of Eulerian paths and the constraints of the problem. Given the existence of an Eulerian path and the balanced in-degree and out-degree for each vertex, Hierholzer\\'s will construct the path by traversing each edge exactly once, thus providing a valid answer."
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Hint : Use DFS with a stack, sort destinations, and mark used tickets to find the itinerary!"
                    },
                    {
                        "username": "c910335",
                        "content": "Whoever wrote the program that produces the expected answer, well done!\\n\\n```rb\\n[[\"JFK\",\"YZZ\"], [\"YZZ\", \"JFK\"], [\"JFK\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"]]\\n```\\n\\n![](https://i.imgur.com/UMAEfvY.png)"
                    },
                    {
                        "username": "c910335",
                        "content": "[@lucasscodes](/lucasscodes) 100% reproducible"
                    },
                    {
                        "username": "kenlau",
                        "content": "Looks like the online judge got TLE ..."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "cannot reproduce?"
                    },
                    {
                        "username": "advfeature",
                        "content": "That means you might have to visit certain edges multiple times. That broke my first submission!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "yes you have to use all the ticket even revisiting it \\nknow more about from here  - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "kwonkyu",
                        "content": "At 29th test case, \\n[[\"EZE\",\"TIA\"],[\"EZE\",\"HBA\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AXA\"],[\"ANU\",\"JFK\"],[\"ADL\",\"ANU\"],**[\"TIA\",\"AUA\"]**,[\"ANU\",\"AUA\"],[\"ADL\",\"EZE\"],[\"ADL\",\"EZE\"],[\"EZE\",\"ADL\"],[\"AXA\",\"EZE\"],[\"AUA\",\"AXA\"],[\"JFK\",\"AXA\"],[\"AXA\",\"AUA\"],[\"AUA\",\"ADL\"],[\"ANU\",\"EZE\"],**[\"TIA\",\"ADL\"]**,[\"EZE\",\"ANU\"],[\"AUA\",\"ANU\"]]\\n\\nThere\\'re two destinations from \"TIA\", which are \"ADL\" and \"AUA\".\\nSo I thought the result should be like [..., \"TIA\", \"ADL\", ..., \"TIA\", \"AUA\", ...] but test case shows [..., \"TIA\", \"AUA\", ..., \"TIA\", \"ADL\", ...].\\n~~Isn\\'t \"ADL\" is prior to \"AUA\" in lexical order? Or should I manually select ticket to use all of my tickets even if it\\'s not in lexical order?~~\\n\\n~~I\\'m not native speaker so I may missed some points but I can\\'t tell what it is. Does anyone know?~~\\n\\nOh I was stupid\\uD83D\\uDE05 Description said \"You must use all tickets\" so...\\ngotta get some sleep. my brain\\'s not working."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@user5400vw](/user5400vw)  I got this and solved it too, then got stuck at the 33rd testcase."
                    },
                    {
                        "username": "user5400vw",
                        "content": "if u guys get this test case you\\'re halfway there."
                    },
                    {
                        "username": "segfz",
                        "content": "Consider test case [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nexpected result: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\nI expect the result to be : [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\nAm I correct to say \"NRT\" is lexically larger than \"KUL\"?\\n\\nI am sure I have gotten it wrong but what is it?\\n\\nThank you so much"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "but after selecting jul you get dead end you cannot go anywhere \\nknow more about this here - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "The answer should be: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] since there is no path from KUL to NRT, so [\"JFK\",\"KUL\",\"NRT\",\"JFK\"] cannot be a valid answer. We need to return the lexicographically smallest VALID answer."
                    },
                    {
                        "username": "mohitgupta1194",
                        "content": "Are there questions similar to this problem i.e. which uses this eulerian path algorithm?"
                    },
                    {
                        "username": "Kajal_Joshi",
                        "content": "As per the problem, smaller lexical value string should come before in itinerary sequence.\\n\\nso [\"JFK\",\"KUL\"] is smaller than [\"JFK\",\"NRT\"],\\nso ouput should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\n\\nbut expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nPlease someone explain how this output is calculated?"
                    },
                    {
                        "username": "90K2",
                        "content": "The test case is [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nAnd the expected answer is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] but why? If [JFK, KUL] < [JFK, NRT]"
                    },
                    {
                        "username": "ysingh",
                        "content": "I tried [[\"JFK\", \"LGA\"],[\"JFK\", \"LGB\"]] as a test case and got this as expected answer:\\n[\"JFK\",\"LGB\",\"LGA\"].\\n\\nTwo concerns regarding the expected answer:\\n1) How could this be valid answer when there is no flight between LGB->LGA? \\nDoes the itinerary [\"JFK\",\"LGB\",\"LGA\"] implies that there should be a valid flight between \"JFK\"->\"LGB\" &  \"LGB\" ->\"LGA\".\\n2) Also shouldn't LGA come before LGB as per lexical ordering?"
                    }
                ]
            },
            {
                "id": 1569081,
                "content": [
                    {
                        "username": "phaniram28",
                        "content": "Could anyone help me understand why does Hierholzer\\'s algorithm work in this problem??\\nI see that the problme mentions there exists an answer, is that the valid reason, why if we keep traversing and backtracking on a dead end, would give us a valid answer??\\n\\nI\\'m looking for more formal explaination/logic than simple words, could anyone help??\\n\\n\\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@bparanj](/bparanj) Can u please tell what would be the time complexity of backtracking approach ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Hierholzer\\'s algorithm is typically used to find an Eulerian path or circuit in a graph. An Eulerian path is a trail in a graph that visits every edge exactly once. The algorithm works well in this problem because of a few key properties:\\n\\n1. **Existence of Eulerian Path**: The problem guarantees that an Eulerian path exists, i.e., you can travel every \\'ticket\\' exactly once. This is confirmed by the problem\\'s condition that an answer always exists.\\n\\n2. **Directed Graph**: The tickets can be considered as directed edges in a graph. You can only go from the \"from\" airport to the \"to\" airport as specified on each ticket. Hierholzer\\'s algorithm can easily adapt to directed graphs.\\n\\n3. **Degree of Vertices**: In an Eulerian path, each vertex (except possibly for the start and end vertex) has an equal in-degree and out-degree. This means you can \\'enter\\' and \\'leave\\' each vertex the same number of times. In the problem, the number of tickets to enter an airport would be the same as the number to leave, except for JFK (the start) and possibly another airport if the path is not a circuit.\\n\\n4. **Dead Ends and Backtracking**: Hierholzer\\'s algorithm naturally handles dead ends via backtracking. When you hit a dead-end, you know you\\'ve traversed all outgoing edges (tickets) for that vertex (airport). You can then backtrack and continue traversing other unexplored edges, eventually forming the Eulerian path.\\n\\n5. **Lexicographic Ordering**: While Hierholzer\\'s doesn\\'t inherently give a lexicographically minimal path, you can achieve this by always choosing the smallest available vertex to visit next, which aligns well with the problem\\'s constraints.\\n\\nThe formal reasoning behind why Hierholzer\\'s works is fundamentally based on the properties of Eulerian paths and the constraints of the problem. Given the existence of an Eulerian path and the balanced in-degree and out-degree for each vertex, Hierholzer\\'s will construct the path by traversing each edge exactly once, thus providing a valid answer."
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Hint : Use DFS with a stack, sort destinations, and mark used tickets to find the itinerary!"
                    },
                    {
                        "username": "c910335",
                        "content": "Whoever wrote the program that produces the expected answer, well done!\\n\\n```rb\\n[[\"JFK\",\"YZZ\"], [\"YZZ\", \"JFK\"], [\"JFK\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"]]\\n```\\n\\n![](https://i.imgur.com/UMAEfvY.png)"
                    },
                    {
                        "username": "c910335",
                        "content": "[@lucasscodes](/lucasscodes) 100% reproducible"
                    },
                    {
                        "username": "kenlau",
                        "content": "Looks like the online judge got TLE ..."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "cannot reproduce?"
                    },
                    {
                        "username": "advfeature",
                        "content": "That means you might have to visit certain edges multiple times. That broke my first submission!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "yes you have to use all the ticket even revisiting it \\nknow more about from here  - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "kwonkyu",
                        "content": "At 29th test case, \\n[[\"EZE\",\"TIA\"],[\"EZE\",\"HBA\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AXA\"],[\"ANU\",\"JFK\"],[\"ADL\",\"ANU\"],**[\"TIA\",\"AUA\"]**,[\"ANU\",\"AUA\"],[\"ADL\",\"EZE\"],[\"ADL\",\"EZE\"],[\"EZE\",\"ADL\"],[\"AXA\",\"EZE\"],[\"AUA\",\"AXA\"],[\"JFK\",\"AXA\"],[\"AXA\",\"AUA\"],[\"AUA\",\"ADL\"],[\"ANU\",\"EZE\"],**[\"TIA\",\"ADL\"]**,[\"EZE\",\"ANU\"],[\"AUA\",\"ANU\"]]\\n\\nThere\\'re two destinations from \"TIA\", which are \"ADL\" and \"AUA\".\\nSo I thought the result should be like [..., \"TIA\", \"ADL\", ..., \"TIA\", \"AUA\", ...] but test case shows [..., \"TIA\", \"AUA\", ..., \"TIA\", \"ADL\", ...].\\n~~Isn\\'t \"ADL\" is prior to \"AUA\" in lexical order? Or should I manually select ticket to use all of my tickets even if it\\'s not in lexical order?~~\\n\\n~~I\\'m not native speaker so I may missed some points but I can\\'t tell what it is. Does anyone know?~~\\n\\nOh I was stupid\\uD83D\\uDE05 Description said \"You must use all tickets\" so...\\ngotta get some sleep. my brain\\'s not working."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@user5400vw](/user5400vw)  I got this and solved it too, then got stuck at the 33rd testcase."
                    },
                    {
                        "username": "user5400vw",
                        "content": "if u guys get this test case you\\'re halfway there."
                    },
                    {
                        "username": "segfz",
                        "content": "Consider test case [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nexpected result: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\nI expect the result to be : [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\nAm I correct to say \"NRT\" is lexically larger than \"KUL\"?\\n\\nI am sure I have gotten it wrong but what is it?\\n\\nThank you so much"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "but after selecting jul you get dead end you cannot go anywhere \\nknow more about this here - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "The answer should be: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] since there is no path from KUL to NRT, so [\"JFK\",\"KUL\",\"NRT\",\"JFK\"] cannot be a valid answer. We need to return the lexicographically smallest VALID answer."
                    },
                    {
                        "username": "mohitgupta1194",
                        "content": "Are there questions similar to this problem i.e. which uses this eulerian path algorithm?"
                    },
                    {
                        "username": "Kajal_Joshi",
                        "content": "As per the problem, smaller lexical value string should come before in itinerary sequence.\\n\\nso [\"JFK\",\"KUL\"] is smaller than [\"JFK\",\"NRT\"],\\nso ouput should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\n\\nbut expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nPlease someone explain how this output is calculated?"
                    },
                    {
                        "username": "90K2",
                        "content": "The test case is [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nAnd the expected answer is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] but why? If [JFK, KUL] < [JFK, NRT]"
                    },
                    {
                        "username": "ysingh",
                        "content": "I tried [[\"JFK\", \"LGA\"],[\"JFK\", \"LGB\"]] as a test case and got this as expected answer:\\n[\"JFK\",\"LGB\",\"LGA\"].\\n\\nTwo concerns regarding the expected answer:\\n1) How could this be valid answer when there is no flight between LGB->LGA? \\nDoes the itinerary [\"JFK\",\"LGB\",\"LGA\"] implies that there should be a valid flight between \"JFK\"->\"LGB\" &  \"LGB\" ->\"LGA\".\\n2) Also shouldn't LGA come before LGB as per lexical ordering?"
                    }
                ]
            },
            {
                "id": 1569084,
                "content": [
                    {
                        "username": "suexcxine",
                        "content": "Thanks!\\nWhatever I return, \\nIt shows that what I returned is [],\\nI just don't know why.\\n\\nAnd what confuses me very much is that the parameter *returnSize is 0..."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I seriously respect how brave you are bro, I can\\'t event think of solving it in C in a million years."
                    },
                    {
                        "username": "JerryLife",
                        "content": "Why does the problem description never mention that there are *duplicate* edges?\\n\\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`"
                    },
                    {
                        "username": "kerash",
                        "content": "so that they can cheat your submit once lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "they did us dirty"
                    },
                    {
                        "username": "ajithcherukad",
                        "content": "I believe there is an error in one of the test cases for this question.\\n\\nMy solution doesn't work for the below test case which I believe is wrong.\\n\\nInput:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nCorrect me if I'm wrong here."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Is this question is more difficult to understand than life ?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\n\n\n\n\n\nSPOILER\n```\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        edge = defaultdict(lambda:[]) #get O(1) access\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\n        for k in edge.keys(): edge[k].sort() #lexical order\n\n        used = [False]*len(tickets) #used position indices or -1\n        res = [\"JFK\"] #store reached positions\n        def rec(i=0,start=\"JFK\"): #for flight n from start\n            if i==len(tickets): return True #did the dfs\n            for target,pos in edge[start]: #for each edge\n                if not used[pos]: #unused\n                    used[pos] = True #store pos used\n                    res.append(target) #fly there\n                    if rec(i+1,target): return True #pass up valid dfs choice\n                    else: #bad choice revert stored values\n                        res.pop()\n                        used[pos] = False\n            return False #no acces in this dfs traversal\n        assert rec() #dfs error\n\n        return res\n```"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "by by my 2 day streak :("
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\\nnext thing i applied is hashing to get every edge possible in O(1).\\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\\n\\nSPOILER\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        edge = defaultdict(lambda:[]) #get O(1) access\\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\\n        for k in edge.keys(): edge[k].sort() #lexical order\\n\\n        used = [False]*len(tickets) #used position indices or -1\\n        res = [\"JFK\"] #store reached positions\\n        def rec(i=0,start=\"JFK\"): #for flight n from start\\n            if i==len(tickets): return True #did the dfs\\n            for target,pos in edge[start]: #for each edge\\n                if not used[pos]: #unused\\n                    used[pos] = True #store pos used\\n                    res.append(target) #fly there\\n                    if rec(i+1,target): return True #pass up valid dfs choice\\n                    else: #bad choice revert stored values\\n                        res.pop()\\n                        used[pos] = False\\n            return False #no acces in this dfs traversal\\n        assert rec() #dfs error\\n\\n        return res\\n```"
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "I can solve it so the given test cases will pass, but I can come up with such test cases myself, so it will fail."
                    },
                    {
                        "username": "mstuebs",
                        "content": "I can confirm that."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I opened LC at 7pm, and it\\'s a HARD problem, DESTROYED"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I visualized and explained in a [concise way here](https://leetcode.com/problems/reconstruct-itinerary/solutions/4042456/93-short-concise-explanation-with-visualization-dfs/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here's some useful test cases:\n\nDuplicate routes/edges:\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\nDead ends:\n`[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]`"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "happy after solving it"
                    }
                ]
            },
            {
                "id": 2056967,
                "content": [
                    {
                        "username": "suexcxine",
                        "content": "Thanks!\\nWhatever I return, \\nIt shows that what I returned is [],\\nI just don't know why.\\n\\nAnd what confuses me very much is that the parameter *returnSize is 0..."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I seriously respect how brave you are bro, I can\\'t event think of solving it in C in a million years."
                    },
                    {
                        "username": "JerryLife",
                        "content": "Why does the problem description never mention that there are *duplicate* edges?\\n\\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`"
                    },
                    {
                        "username": "kerash",
                        "content": "so that they can cheat your submit once lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "they did us dirty"
                    },
                    {
                        "username": "ajithcherukad",
                        "content": "I believe there is an error in one of the test cases for this question.\\n\\nMy solution doesn't work for the below test case which I believe is wrong.\\n\\nInput:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nCorrect me if I'm wrong here."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Is this question is more difficult to understand than life ?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\n\n\n\n\n\nSPOILER\n```\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        edge = defaultdict(lambda:[]) #get O(1) access\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\n        for k in edge.keys(): edge[k].sort() #lexical order\n\n        used = [False]*len(tickets) #used position indices or -1\n        res = [\"JFK\"] #store reached positions\n        def rec(i=0,start=\"JFK\"): #for flight n from start\n            if i==len(tickets): return True #did the dfs\n            for target,pos in edge[start]: #for each edge\n                if not used[pos]: #unused\n                    used[pos] = True #store pos used\n                    res.append(target) #fly there\n                    if rec(i+1,target): return True #pass up valid dfs choice\n                    else: #bad choice revert stored values\n                        res.pop()\n                        used[pos] = False\n            return False #no acces in this dfs traversal\n        assert rec() #dfs error\n\n        return res\n```"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "by by my 2 day streak :("
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\\nnext thing i applied is hashing to get every edge possible in O(1).\\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\\n\\nSPOILER\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        edge = defaultdict(lambda:[]) #get O(1) access\\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\\n        for k in edge.keys(): edge[k].sort() #lexical order\\n\\n        used = [False]*len(tickets) #used position indices or -1\\n        res = [\"JFK\"] #store reached positions\\n        def rec(i=0,start=\"JFK\"): #for flight n from start\\n            if i==len(tickets): return True #did the dfs\\n            for target,pos in edge[start]: #for each edge\\n                if not used[pos]: #unused\\n                    used[pos] = True #store pos used\\n                    res.append(target) #fly there\\n                    if rec(i+1,target): return True #pass up valid dfs choice\\n                    else: #bad choice revert stored values\\n                        res.pop()\\n                        used[pos] = False\\n            return False #no acces in this dfs traversal\\n        assert rec() #dfs error\\n\\n        return res\\n```"
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "I can solve it so the given test cases will pass, but I can come up with such test cases myself, so it will fail."
                    },
                    {
                        "username": "mstuebs",
                        "content": "I can confirm that."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I opened LC at 7pm, and it\\'s a HARD problem, DESTROYED"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I visualized and explained in a [concise way here](https://leetcode.com/problems/reconstruct-itinerary/solutions/4042456/93-short-concise-explanation-with-visualization-dfs/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here's some useful test cases:\n\nDuplicate routes/edges:\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\nDead ends:\n`[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]`"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "happy after solving it"
                    }
                ]
            },
            {
                "id": 1567958,
                "content": [
                    {
                        "username": "suexcxine",
                        "content": "Thanks!\\nWhatever I return, \\nIt shows that what I returned is [],\\nI just don't know why.\\n\\nAnd what confuses me very much is that the parameter *returnSize is 0..."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I seriously respect how brave you are bro, I can\\'t event think of solving it in C in a million years."
                    },
                    {
                        "username": "JerryLife",
                        "content": "Why does the problem description never mention that there are *duplicate* edges?\\n\\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`"
                    },
                    {
                        "username": "kerash",
                        "content": "so that they can cheat your submit once lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "they did us dirty"
                    },
                    {
                        "username": "ajithcherukad",
                        "content": "I believe there is an error in one of the test cases for this question.\\n\\nMy solution doesn't work for the below test case which I believe is wrong.\\n\\nInput:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nCorrect me if I'm wrong here."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Is this question is more difficult to understand than life ?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\n\n\n\n\n\nSPOILER\n```\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        edge = defaultdict(lambda:[]) #get O(1) access\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\n        for k in edge.keys(): edge[k].sort() #lexical order\n\n        used = [False]*len(tickets) #used position indices or -1\n        res = [\"JFK\"] #store reached positions\n        def rec(i=0,start=\"JFK\"): #for flight n from start\n            if i==len(tickets): return True #did the dfs\n            for target,pos in edge[start]: #for each edge\n                if not used[pos]: #unused\n                    used[pos] = True #store pos used\n                    res.append(target) #fly there\n                    if rec(i+1,target): return True #pass up valid dfs choice\n                    else: #bad choice revert stored values\n                        res.pop()\n                        used[pos] = False\n            return False #no acces in this dfs traversal\n        assert rec() #dfs error\n\n        return res\n```"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "by by my 2 day streak :("
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\\nnext thing i applied is hashing to get every edge possible in O(1).\\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\\n\\nSPOILER\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        edge = defaultdict(lambda:[]) #get O(1) access\\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\\n        for k in edge.keys(): edge[k].sort() #lexical order\\n\\n        used = [False]*len(tickets) #used position indices or -1\\n        res = [\"JFK\"] #store reached positions\\n        def rec(i=0,start=\"JFK\"): #for flight n from start\\n            if i==len(tickets): return True #did the dfs\\n            for target,pos in edge[start]: #for each edge\\n                if not used[pos]: #unused\\n                    used[pos] = True #store pos used\\n                    res.append(target) #fly there\\n                    if rec(i+1,target): return True #pass up valid dfs choice\\n                    else: #bad choice revert stored values\\n                        res.pop()\\n                        used[pos] = False\\n            return False #no acces in this dfs traversal\\n        assert rec() #dfs error\\n\\n        return res\\n```"
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "I can solve it so the given test cases will pass, but I can come up with such test cases myself, so it will fail."
                    },
                    {
                        "username": "mstuebs",
                        "content": "I can confirm that."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I opened LC at 7pm, and it\\'s a HARD problem, DESTROYED"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I visualized and explained in a [concise way here](https://leetcode.com/problems/reconstruct-itinerary/solutions/4042456/93-short-concise-explanation-with-visualization-dfs/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here's some useful test cases:\n\nDuplicate routes/edges:\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\nDead ends:\n`[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]`"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "happy after solving it"
                    }
                ]
            },
            {
                "id": 2057609,
                "content": [
                    {
                        "username": "suexcxine",
                        "content": "Thanks!\\nWhatever I return, \\nIt shows that what I returned is [],\\nI just don't know why.\\n\\nAnd what confuses me very much is that the parameter *returnSize is 0..."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I seriously respect how brave you are bro, I can\\'t event think of solving it in C in a million years."
                    },
                    {
                        "username": "JerryLife",
                        "content": "Why does the problem description never mention that there are *duplicate* edges?\\n\\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`"
                    },
                    {
                        "username": "kerash",
                        "content": "so that they can cheat your submit once lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "they did us dirty"
                    },
                    {
                        "username": "ajithcherukad",
                        "content": "I believe there is an error in one of the test cases for this question.\\n\\nMy solution doesn't work for the below test case which I believe is wrong.\\n\\nInput:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nCorrect me if I'm wrong here."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Is this question is more difficult to understand than life ?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\n\n\n\n\n\nSPOILER\n```\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        edge = defaultdict(lambda:[]) #get O(1) access\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\n        for k in edge.keys(): edge[k].sort() #lexical order\n\n        used = [False]*len(tickets) #used position indices or -1\n        res = [\"JFK\"] #store reached positions\n        def rec(i=0,start=\"JFK\"): #for flight n from start\n            if i==len(tickets): return True #did the dfs\n            for target,pos in edge[start]: #for each edge\n                if not used[pos]: #unused\n                    used[pos] = True #store pos used\n                    res.append(target) #fly there\n                    if rec(i+1,target): return True #pass up valid dfs choice\n                    else: #bad choice revert stored values\n                        res.pop()\n                        used[pos] = False\n            return False #no acces in this dfs traversal\n        assert rec() #dfs error\n\n        return res\n```"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "by by my 2 day streak :("
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\\nnext thing i applied is hashing to get every edge possible in O(1).\\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\\n\\nSPOILER\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        edge = defaultdict(lambda:[]) #get O(1) access\\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\\n        for k in edge.keys(): edge[k].sort() #lexical order\\n\\n        used = [False]*len(tickets) #used position indices or -1\\n        res = [\"JFK\"] #store reached positions\\n        def rec(i=0,start=\"JFK\"): #for flight n from start\\n            if i==len(tickets): return True #did the dfs\\n            for target,pos in edge[start]: #for each edge\\n                if not used[pos]: #unused\\n                    used[pos] = True #store pos used\\n                    res.append(target) #fly there\\n                    if rec(i+1,target): return True #pass up valid dfs choice\\n                    else: #bad choice revert stored values\\n                        res.pop()\\n                        used[pos] = False\\n            return False #no acces in this dfs traversal\\n        assert rec() #dfs error\\n\\n        return res\\n```"
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "I can solve it so the given test cases will pass, but I can come up with such test cases myself, so it will fail."
                    },
                    {
                        "username": "mstuebs",
                        "content": "I can confirm that."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I opened LC at 7pm, and it\\'s a HARD problem, DESTROYED"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I visualized and explained in a [concise way here](https://leetcode.com/problems/reconstruct-itinerary/solutions/4042456/93-short-concise-explanation-with-visualization-dfs/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here's some useful test cases:\n\nDuplicate routes/edges:\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\nDead ends:\n`[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]`"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "happy after solving it"
                    }
                ]
            },
            {
                "id": 2057580,
                "content": [
                    {
                        "username": "suexcxine",
                        "content": "Thanks!\\nWhatever I return, \\nIt shows that what I returned is [],\\nI just don't know why.\\n\\nAnd what confuses me very much is that the parameter *returnSize is 0..."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I seriously respect how brave you are bro, I can\\'t event think of solving it in C in a million years."
                    },
                    {
                        "username": "JerryLife",
                        "content": "Why does the problem description never mention that there are *duplicate* edges?\\n\\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`"
                    },
                    {
                        "username": "kerash",
                        "content": "so that they can cheat your submit once lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "they did us dirty"
                    },
                    {
                        "username": "ajithcherukad",
                        "content": "I believe there is an error in one of the test cases for this question.\\n\\nMy solution doesn't work for the below test case which I believe is wrong.\\n\\nInput:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nCorrect me if I'm wrong here."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Is this question is more difficult to understand than life ?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\n\n\n\n\n\nSPOILER\n```\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        edge = defaultdict(lambda:[]) #get O(1) access\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\n        for k in edge.keys(): edge[k].sort() #lexical order\n\n        used = [False]*len(tickets) #used position indices or -1\n        res = [\"JFK\"] #store reached positions\n        def rec(i=0,start=\"JFK\"): #for flight n from start\n            if i==len(tickets): return True #did the dfs\n            for target,pos in edge[start]: #for each edge\n                if not used[pos]: #unused\n                    used[pos] = True #store pos used\n                    res.append(target) #fly there\n                    if rec(i+1,target): return True #pass up valid dfs choice\n                    else: #bad choice revert stored values\n                        res.pop()\n                        used[pos] = False\n            return False #no acces in this dfs traversal\n        assert rec() #dfs error\n\n        return res\n```"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "by by my 2 day streak :("
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\\nnext thing i applied is hashing to get every edge possible in O(1).\\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\\n\\nSPOILER\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        edge = defaultdict(lambda:[]) #get O(1) access\\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\\n        for k in edge.keys(): edge[k].sort() #lexical order\\n\\n        used = [False]*len(tickets) #used position indices or -1\\n        res = [\"JFK\"] #store reached positions\\n        def rec(i=0,start=\"JFK\"): #for flight n from start\\n            if i==len(tickets): return True #did the dfs\\n            for target,pos in edge[start]: #for each edge\\n                if not used[pos]: #unused\\n                    used[pos] = True #store pos used\\n                    res.append(target) #fly there\\n                    if rec(i+1,target): return True #pass up valid dfs choice\\n                    else: #bad choice revert stored values\\n                        res.pop()\\n                        used[pos] = False\\n            return False #no acces in this dfs traversal\\n        assert rec() #dfs error\\n\\n        return res\\n```"
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "I can solve it so the given test cases will pass, but I can come up with such test cases myself, so it will fail."
                    },
                    {
                        "username": "mstuebs",
                        "content": "I can confirm that."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I opened LC at 7pm, and it\\'s a HARD problem, DESTROYED"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I visualized and explained in a [concise way here](https://leetcode.com/problems/reconstruct-itinerary/solutions/4042456/93-short-concise-explanation-with-visualization-dfs/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here's some useful test cases:\n\nDuplicate routes/edges:\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\nDead ends:\n`[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]`"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "happy after solving it"
                    }
                ]
            },
            {
                "id": 2057435,
                "content": [
                    {
                        "username": "suexcxine",
                        "content": "Thanks!\\nWhatever I return, \\nIt shows that what I returned is [],\\nI just don't know why.\\n\\nAnd what confuses me very much is that the parameter *returnSize is 0..."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I seriously respect how brave you are bro, I can\\'t event think of solving it in C in a million years."
                    },
                    {
                        "username": "JerryLife",
                        "content": "Why does the problem description never mention that there are *duplicate* edges?\\n\\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`"
                    },
                    {
                        "username": "kerash",
                        "content": "so that they can cheat your submit once lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "they did us dirty"
                    },
                    {
                        "username": "ajithcherukad",
                        "content": "I believe there is an error in one of the test cases for this question.\\n\\nMy solution doesn't work for the below test case which I believe is wrong.\\n\\nInput:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nCorrect me if I'm wrong here."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Is this question is more difficult to understand than life ?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\n\n\n\n\n\nSPOILER\n```\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        edge = defaultdict(lambda:[]) #get O(1) access\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\n        for k in edge.keys(): edge[k].sort() #lexical order\n\n        used = [False]*len(tickets) #used position indices or -1\n        res = [\"JFK\"] #store reached positions\n        def rec(i=0,start=\"JFK\"): #for flight n from start\n            if i==len(tickets): return True #did the dfs\n            for target,pos in edge[start]: #for each edge\n                if not used[pos]: #unused\n                    used[pos] = True #store pos used\n                    res.append(target) #fly there\n                    if rec(i+1,target): return True #pass up valid dfs choice\n                    else: #bad choice revert stored values\n                        res.pop()\n                        used[pos] = False\n            return False #no acces in this dfs traversal\n        assert rec() #dfs error\n\n        return res\n```"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "by by my 2 day streak :("
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\\nnext thing i applied is hashing to get every edge possible in O(1).\\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\\n\\nSPOILER\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        edge = defaultdict(lambda:[]) #get O(1) access\\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\\n        for k in edge.keys(): edge[k].sort() #lexical order\\n\\n        used = [False]*len(tickets) #used position indices or -1\\n        res = [\"JFK\"] #store reached positions\\n        def rec(i=0,start=\"JFK\"): #for flight n from start\\n            if i==len(tickets): return True #did the dfs\\n            for target,pos in edge[start]: #for each edge\\n                if not used[pos]: #unused\\n                    used[pos] = True #store pos used\\n                    res.append(target) #fly there\\n                    if rec(i+1,target): return True #pass up valid dfs choice\\n                    else: #bad choice revert stored values\\n                        res.pop()\\n                        used[pos] = False\\n            return False #no acces in this dfs traversal\\n        assert rec() #dfs error\\n\\n        return res\\n```"
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "I can solve it so the given test cases will pass, but I can come up with such test cases myself, so it will fail."
                    },
                    {
                        "username": "mstuebs",
                        "content": "I can confirm that."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I opened LC at 7pm, and it\\'s a HARD problem, DESTROYED"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I visualized and explained in a [concise way here](https://leetcode.com/problems/reconstruct-itinerary/solutions/4042456/93-short-concise-explanation-with-visualization-dfs/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here's some useful test cases:\n\nDuplicate routes/edges:\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\nDead ends:\n`[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]`"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "happy after solving it"
                    }
                ]
            },
            {
                "id": 2057429,
                "content": [
                    {
                        "username": "suexcxine",
                        "content": "Thanks!\\nWhatever I return, \\nIt shows that what I returned is [],\\nI just don't know why.\\n\\nAnd what confuses me very much is that the parameter *returnSize is 0..."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I seriously respect how brave you are bro, I can\\'t event think of solving it in C in a million years."
                    },
                    {
                        "username": "JerryLife",
                        "content": "Why does the problem description never mention that there are *duplicate* edges?\\n\\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`"
                    },
                    {
                        "username": "kerash",
                        "content": "so that they can cheat your submit once lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "they did us dirty"
                    },
                    {
                        "username": "ajithcherukad",
                        "content": "I believe there is an error in one of the test cases for this question.\\n\\nMy solution doesn't work for the below test case which I believe is wrong.\\n\\nInput:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nCorrect me if I'm wrong here."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Is this question is more difficult to understand than life ?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\n\n\n\n\n\nSPOILER\n```\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        edge = defaultdict(lambda:[]) #get O(1) access\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\n        for k in edge.keys(): edge[k].sort() #lexical order\n\n        used = [False]*len(tickets) #used position indices or -1\n        res = [\"JFK\"] #store reached positions\n        def rec(i=0,start=\"JFK\"): #for flight n from start\n            if i==len(tickets): return True #did the dfs\n            for target,pos in edge[start]: #for each edge\n                if not used[pos]: #unused\n                    used[pos] = True #store pos used\n                    res.append(target) #fly there\n                    if rec(i+1,target): return True #pass up valid dfs choice\n                    else: #bad choice revert stored values\n                        res.pop()\n                        used[pos] = False\n            return False #no acces in this dfs traversal\n        assert rec() #dfs error\n\n        return res\n```"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "by by my 2 day streak :("
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\\nnext thing i applied is hashing to get every edge possible in O(1).\\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\\n\\nSPOILER\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        edge = defaultdict(lambda:[]) #get O(1) access\\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\\n        for k in edge.keys(): edge[k].sort() #lexical order\\n\\n        used = [False]*len(tickets) #used position indices or -1\\n        res = [\"JFK\"] #store reached positions\\n        def rec(i=0,start=\"JFK\"): #for flight n from start\\n            if i==len(tickets): return True #did the dfs\\n            for target,pos in edge[start]: #for each edge\\n                if not used[pos]: #unused\\n                    used[pos] = True #store pos used\\n                    res.append(target) #fly there\\n                    if rec(i+1,target): return True #pass up valid dfs choice\\n                    else: #bad choice revert stored values\\n                        res.pop()\\n                        used[pos] = False\\n            return False #no acces in this dfs traversal\\n        assert rec() #dfs error\\n\\n        return res\\n```"
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "I can solve it so the given test cases will pass, but I can come up with such test cases myself, so it will fail."
                    },
                    {
                        "username": "mstuebs",
                        "content": "I can confirm that."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I opened LC at 7pm, and it\\'s a HARD problem, DESTROYED"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I visualized and explained in a [concise way here](https://leetcode.com/problems/reconstruct-itinerary/solutions/4042456/93-short-concise-explanation-with-visualization-dfs/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here's some useful test cases:\n\nDuplicate routes/edges:\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\nDead ends:\n`[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]`"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "happy after solving it"
                    }
                ]
            },
            {
                "id": 2056950,
                "content": [
                    {
                        "username": "suexcxine",
                        "content": "Thanks!\\nWhatever I return, \\nIt shows that what I returned is [],\\nI just don't know why.\\n\\nAnd what confuses me very much is that the parameter *returnSize is 0..."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I seriously respect how brave you are bro, I can\\'t event think of solving it in C in a million years."
                    },
                    {
                        "username": "JerryLife",
                        "content": "Why does the problem description never mention that there are *duplicate* edges?\\n\\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`"
                    },
                    {
                        "username": "kerash",
                        "content": "so that they can cheat your submit once lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "they did us dirty"
                    },
                    {
                        "username": "ajithcherukad",
                        "content": "I believe there is an error in one of the test cases for this question.\\n\\nMy solution doesn't work for the below test case which I believe is wrong.\\n\\nInput:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nCorrect me if I'm wrong here."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Is this question is more difficult to understand than life ?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\n\n\n\n\n\nSPOILER\n```\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        edge = defaultdict(lambda:[]) #get O(1) access\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\n        for k in edge.keys(): edge[k].sort() #lexical order\n\n        used = [False]*len(tickets) #used position indices or -1\n        res = [\"JFK\"] #store reached positions\n        def rec(i=0,start=\"JFK\"): #for flight n from start\n            if i==len(tickets): return True #did the dfs\n            for target,pos in edge[start]: #for each edge\n                if not used[pos]: #unused\n                    used[pos] = True #store pos used\n                    res.append(target) #fly there\n                    if rec(i+1,target): return True #pass up valid dfs choice\n                    else: #bad choice revert stored values\n                        res.pop()\n                        used[pos] = False\n            return False #no acces in this dfs traversal\n        assert rec() #dfs error\n\n        return res\n```"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "by by my 2 day streak :("
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\\nnext thing i applied is hashing to get every edge possible in O(1).\\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\\n\\nSPOILER\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        edge = defaultdict(lambda:[]) #get O(1) access\\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\\n        for k in edge.keys(): edge[k].sort() #lexical order\\n\\n        used = [False]*len(tickets) #used position indices or -1\\n        res = [\"JFK\"] #store reached positions\\n        def rec(i=0,start=\"JFK\"): #for flight n from start\\n            if i==len(tickets): return True #did the dfs\\n            for target,pos in edge[start]: #for each edge\\n                if not used[pos]: #unused\\n                    used[pos] = True #store pos used\\n                    res.append(target) #fly there\\n                    if rec(i+1,target): return True #pass up valid dfs choice\\n                    else: #bad choice revert stored values\\n                        res.pop()\\n                        used[pos] = False\\n            return False #no acces in this dfs traversal\\n        assert rec() #dfs error\\n\\n        return res\\n```"
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "I can solve it so the given test cases will pass, but I can come up with such test cases myself, so it will fail."
                    },
                    {
                        "username": "mstuebs",
                        "content": "I can confirm that."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I opened LC at 7pm, and it\\'s a HARD problem, DESTROYED"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I visualized and explained in a [concise way here](https://leetcode.com/problems/reconstruct-itinerary/solutions/4042456/93-short-concise-explanation-with-visualization-dfs/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here's some useful test cases:\n\nDuplicate routes/edges:\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\nDead ends:\n`[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]`"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "happy after solving it"
                    }
                ]
            },
            {
                "id": 2056915,
                "content": [
                    {
                        "username": "suexcxine",
                        "content": "Thanks!\\nWhatever I return, \\nIt shows that what I returned is [],\\nI just don't know why.\\n\\nAnd what confuses me very much is that the parameter *returnSize is 0..."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I seriously respect how brave you are bro, I can\\'t event think of solving it in C in a million years."
                    },
                    {
                        "username": "JerryLife",
                        "content": "Why does the problem description never mention that there are *duplicate* edges?\\n\\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`"
                    },
                    {
                        "username": "kerash",
                        "content": "so that they can cheat your submit once lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "they did us dirty"
                    },
                    {
                        "username": "ajithcherukad",
                        "content": "I believe there is an error in one of the test cases for this question.\\n\\nMy solution doesn't work for the below test case which I believe is wrong.\\n\\nInput:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nCorrect me if I'm wrong here."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Is this question is more difficult to understand than life ?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\n\n\n\n\n\nSPOILER\n```\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        edge = defaultdict(lambda:[]) #get O(1) access\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\n        for k in edge.keys(): edge[k].sort() #lexical order\n\n        used = [False]*len(tickets) #used position indices or -1\n        res = [\"JFK\"] #store reached positions\n        def rec(i=0,start=\"JFK\"): #for flight n from start\n            if i==len(tickets): return True #did the dfs\n            for target,pos in edge[start]: #for each edge\n                if not used[pos]: #unused\n                    used[pos] = True #store pos used\n                    res.append(target) #fly there\n                    if rec(i+1,target): return True #pass up valid dfs choice\n                    else: #bad choice revert stored values\n                        res.pop()\n                        used[pos] = False\n            return False #no acces in this dfs traversal\n        assert rec() #dfs error\n\n        return res\n```"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "by by my 2 day streak :("
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\\nnext thing i applied is hashing to get every edge possible in O(1).\\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\\n\\nSPOILER\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        edge = defaultdict(lambda:[]) #get O(1) access\\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\\n        for k in edge.keys(): edge[k].sort() #lexical order\\n\\n        used = [False]*len(tickets) #used position indices or -1\\n        res = [\"JFK\"] #store reached positions\\n        def rec(i=0,start=\"JFK\"): #for flight n from start\\n            if i==len(tickets): return True #did the dfs\\n            for target,pos in edge[start]: #for each edge\\n                if not used[pos]: #unused\\n                    used[pos] = True #store pos used\\n                    res.append(target) #fly there\\n                    if rec(i+1,target): return True #pass up valid dfs choice\\n                    else: #bad choice revert stored values\\n                        res.pop()\\n                        used[pos] = False\\n            return False #no acces in this dfs traversal\\n        assert rec() #dfs error\\n\\n        return res\\n```"
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "I can solve it so the given test cases will pass, but I can come up with such test cases myself, so it will fail."
                    },
                    {
                        "username": "mstuebs",
                        "content": "I can confirm that."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I opened LC at 7pm, and it\\'s a HARD problem, DESTROYED"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I visualized and explained in a [concise way here](https://leetcode.com/problems/reconstruct-itinerary/solutions/4042456/93-short-concise-explanation-with-visualization-dfs/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here's some useful test cases:\n\nDuplicate routes/edges:\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\nDead ends:\n`[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]`"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "happy after solving it"
                    }
                ]
            },
            {
                "id": 1962030,
                "content": [
                    {
                        "username": "suexcxine",
                        "content": "Thanks!\\nWhatever I return, \\nIt shows that what I returned is [],\\nI just don't know why.\\n\\nAnd what confuses me very much is that the parameter *returnSize is 0..."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I seriously respect how brave you are bro, I can\\'t event think of solving it in C in a million years."
                    },
                    {
                        "username": "JerryLife",
                        "content": "Why does the problem description never mention that there are *duplicate* edges?\\n\\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`"
                    },
                    {
                        "username": "kerash",
                        "content": "so that they can cheat your submit once lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "they did us dirty"
                    },
                    {
                        "username": "ajithcherukad",
                        "content": "I believe there is an error in one of the test cases for this question.\\n\\nMy solution doesn't work for the below test case which I believe is wrong.\\n\\nInput:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nCorrect me if I'm wrong here."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Is this question is more difficult to understand than life ?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\n\n\n\n\n\nSPOILER\n```\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        edge = defaultdict(lambda:[]) #get O(1) access\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\n        for k in edge.keys(): edge[k].sort() #lexical order\n\n        used = [False]*len(tickets) #used position indices or -1\n        res = [\"JFK\"] #store reached positions\n        def rec(i=0,start=\"JFK\"): #for flight n from start\n            if i==len(tickets): return True #did the dfs\n            for target,pos in edge[start]: #for each edge\n                if not used[pos]: #unused\n                    used[pos] = True #store pos used\n                    res.append(target) #fly there\n                    if rec(i+1,target): return True #pass up valid dfs choice\n                    else: #bad choice revert stored values\n                        res.pop()\n                        used[pos] = False\n            return False #no acces in this dfs traversal\n        assert rec() #dfs error\n\n        return res\n```"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "by by my 2 day streak :("
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\\nnext thing i applied is hashing to get every edge possible in O(1).\\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\\n\\nSPOILER\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        edge = defaultdict(lambda:[]) #get O(1) access\\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\\n        for k in edge.keys(): edge[k].sort() #lexical order\\n\\n        used = [False]*len(tickets) #used position indices or -1\\n        res = [\"JFK\"] #store reached positions\\n        def rec(i=0,start=\"JFK\"): #for flight n from start\\n            if i==len(tickets): return True #did the dfs\\n            for target,pos in edge[start]: #for each edge\\n                if not used[pos]: #unused\\n                    used[pos] = True #store pos used\\n                    res.append(target) #fly there\\n                    if rec(i+1,target): return True #pass up valid dfs choice\\n                    else: #bad choice revert stored values\\n                        res.pop()\\n                        used[pos] = False\\n            return False #no acces in this dfs traversal\\n        assert rec() #dfs error\\n\\n        return res\\n```"
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "I can solve it so the given test cases will pass, but I can come up with such test cases myself, so it will fail."
                    },
                    {
                        "username": "mstuebs",
                        "content": "I can confirm that."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I opened LC at 7pm, and it\\'s a HARD problem, DESTROYED"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I visualized and explained in a [concise way here](https://leetcode.com/problems/reconstruct-itinerary/solutions/4042456/93-short-concise-explanation-with-visualization-dfs/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here's some useful test cases:\n\nDuplicate routes/edges:\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\nDead ends:\n`[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]`"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "happy after solving it"
                    }
                ]
            },
            {
                "id": 1576757,
                "content": [
                    {
                        "username": "VoidedName",
                        "content": "I don\\'t believe the error reporting for the typescript version is correct. The string ATLJFKATL is < JFKATLJFK (same length and first letter already decides A < J). Unless the use of lexical in the desciption differs from the common definition. And since the input is a cycle, both paths should be candidates.\\n\\n![image](https://assets.leetcode.com/users/images/7ea9207b-a052-4451-b1da-2df858b28850_1652559354.383964.png)\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "JFK must always be the starting point. It is written in the description."
                    },
                    {
                        "username": "codemaster2911",
                        "content": "[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nwhat shoul be the output of this\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "For example 886 Possible Bipartition, the time complexity for the DFS solution that put the \"dislike\" relation on to a graph, is O(V+E).\\nO(V+E) means you have to visit each vertex and edge for at lease once. \\nWhy this question is not the case? \\nCan anyone give detailed explanation, thanks!"
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Whats the proof that the point where we get stuck is the end point??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "When all edges are visited, that\\'s the endpoint."
                    },
                    {
                        "username": "Paras132",
                        "content": "Input : [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput : [\"JFK\",\"KUL\"]\\nExpected : [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow the values in \"Expected\" holds true ? question says ned to return lexical order so in that case \"KUL\" is smaller than \"NRT\".\\n\\nPlease explain.\\n\\n"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "I can think of some intuition behind solving this problem, but I\\'m struggling to understand why itineraries can come back to an airport that has already been visited?\\nIn graph search, we don\\'t process the same node twice, right? So how are any of these test cases given in the question valid in any way?"
                    },
                    {
                        "username": "Hugheym",
                        "content": "This is what I\\'m getting:\\n\\nInput:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nIf read as a single string, wouldn\\'t the sequence starting with ATL be first?"
                    },
                    {
                        "username": "kargreat",
                        "content": "for test case: [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"],[\"LHR\",\"SEA\"]]\\nleetcode output is: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\",\"SEA\"]\\n\\nThis is absurd."
                    },
                    {
                        "username": "JiaweiZhang1994",
                        "content": "I have solved the problem by the top 1 answer. However I still have a problem about Eulerian path.\\nTest case: [[\"E\", \"F\"], [\"JFK\", \"A\"], [\"A\", \"D\"], [\"D\", \"E\"],[\"F\",\"A\"],[\"JFK\",\"B\"],[\"B\", \"F\"]]\\nI am not sure about the expected answer.\\nThe expected answer is [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\",\"A\"],\\nHowever I think it should be [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\"]\\nSo the graph should looks like:\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1568312939.png)\\n\\n\\nDoes Anyone can help me with my confusing?\\nI would appreciate that."
                    },
                    {
                        "username": "sssss29",
                        "content": "In this test case \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]] why output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nKUL is alphabetically ahead of NRT,m so it should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]??"
                    }
                ]
            },
            {
                "id": 1575311,
                "content": [
                    {
                        "username": "VoidedName",
                        "content": "I don\\'t believe the error reporting for the typescript version is correct. The string ATLJFKATL is < JFKATLJFK (same length and first letter already decides A < J). Unless the use of lexical in the desciption differs from the common definition. And since the input is a cycle, both paths should be candidates.\\n\\n![image](https://assets.leetcode.com/users/images/7ea9207b-a052-4451-b1da-2df858b28850_1652559354.383964.png)\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "JFK must always be the starting point. It is written in the description."
                    },
                    {
                        "username": "codemaster2911",
                        "content": "[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nwhat shoul be the output of this\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "For example 886 Possible Bipartition, the time complexity for the DFS solution that put the \"dislike\" relation on to a graph, is O(V+E).\\nO(V+E) means you have to visit each vertex and edge for at lease once. \\nWhy this question is not the case? \\nCan anyone give detailed explanation, thanks!"
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Whats the proof that the point where we get stuck is the end point??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "When all edges are visited, that\\'s the endpoint."
                    },
                    {
                        "username": "Paras132",
                        "content": "Input : [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput : [\"JFK\",\"KUL\"]\\nExpected : [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow the values in \"Expected\" holds true ? question says ned to return lexical order so in that case \"KUL\" is smaller than \"NRT\".\\n\\nPlease explain.\\n\\n"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "I can think of some intuition behind solving this problem, but I\\'m struggling to understand why itineraries can come back to an airport that has already been visited?\\nIn graph search, we don\\'t process the same node twice, right? So how are any of these test cases given in the question valid in any way?"
                    },
                    {
                        "username": "Hugheym",
                        "content": "This is what I\\'m getting:\\n\\nInput:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nIf read as a single string, wouldn\\'t the sequence starting with ATL be first?"
                    },
                    {
                        "username": "kargreat",
                        "content": "for test case: [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"],[\"LHR\",\"SEA\"]]\\nleetcode output is: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\",\"SEA\"]\\n\\nThis is absurd."
                    },
                    {
                        "username": "JiaweiZhang1994",
                        "content": "I have solved the problem by the top 1 answer. However I still have a problem about Eulerian path.\\nTest case: [[\"E\", \"F\"], [\"JFK\", \"A\"], [\"A\", \"D\"], [\"D\", \"E\"],[\"F\",\"A\"],[\"JFK\",\"B\"],[\"B\", \"F\"]]\\nI am not sure about the expected answer.\\nThe expected answer is [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\",\"A\"],\\nHowever I think it should be [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\"]\\nSo the graph should looks like:\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1568312939.png)\\n\\n\\nDoes Anyone can help me with my confusing?\\nI would appreciate that."
                    },
                    {
                        "username": "sssss29",
                        "content": "In this test case \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]] why output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nKUL is alphabetically ahead of NRT,m so it should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]??"
                    }
                ]
            },
            {
                "id": 1575170,
                "content": [
                    {
                        "username": "VoidedName",
                        "content": "I don\\'t believe the error reporting for the typescript version is correct. The string ATLJFKATL is < JFKATLJFK (same length and first letter already decides A < J). Unless the use of lexical in the desciption differs from the common definition. And since the input is a cycle, both paths should be candidates.\\n\\n![image](https://assets.leetcode.com/users/images/7ea9207b-a052-4451-b1da-2df858b28850_1652559354.383964.png)\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "JFK must always be the starting point. It is written in the description."
                    },
                    {
                        "username": "codemaster2911",
                        "content": "[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nwhat shoul be the output of this\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "For example 886 Possible Bipartition, the time complexity for the DFS solution that put the \"dislike\" relation on to a graph, is O(V+E).\\nO(V+E) means you have to visit each vertex and edge for at lease once. \\nWhy this question is not the case? \\nCan anyone give detailed explanation, thanks!"
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Whats the proof that the point where we get stuck is the end point??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "When all edges are visited, that\\'s the endpoint."
                    },
                    {
                        "username": "Paras132",
                        "content": "Input : [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput : [\"JFK\",\"KUL\"]\\nExpected : [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow the values in \"Expected\" holds true ? question says ned to return lexical order so in that case \"KUL\" is smaller than \"NRT\".\\n\\nPlease explain.\\n\\n"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "I can think of some intuition behind solving this problem, but I\\'m struggling to understand why itineraries can come back to an airport that has already been visited?\\nIn graph search, we don\\'t process the same node twice, right? So how are any of these test cases given in the question valid in any way?"
                    },
                    {
                        "username": "Hugheym",
                        "content": "This is what I\\'m getting:\\n\\nInput:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nIf read as a single string, wouldn\\'t the sequence starting with ATL be first?"
                    },
                    {
                        "username": "kargreat",
                        "content": "for test case: [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"],[\"LHR\",\"SEA\"]]\\nleetcode output is: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\",\"SEA\"]\\n\\nThis is absurd."
                    },
                    {
                        "username": "JiaweiZhang1994",
                        "content": "I have solved the problem by the top 1 answer. However I still have a problem about Eulerian path.\\nTest case: [[\"E\", \"F\"], [\"JFK\", \"A\"], [\"A\", \"D\"], [\"D\", \"E\"],[\"F\",\"A\"],[\"JFK\",\"B\"],[\"B\", \"F\"]]\\nI am not sure about the expected answer.\\nThe expected answer is [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\",\"A\"],\\nHowever I think it should be [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\"]\\nSo the graph should looks like:\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1568312939.png)\\n\\n\\nDoes Anyone can help me with my confusing?\\nI would appreciate that."
                    },
                    {
                        "username": "sssss29",
                        "content": "In this test case \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]] why output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nKUL is alphabetically ahead of NRT,m so it should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]??"
                    }
                ]
            },
            {
                "id": 1574969,
                "content": [
                    {
                        "username": "VoidedName",
                        "content": "I don\\'t believe the error reporting for the typescript version is correct. The string ATLJFKATL is < JFKATLJFK (same length and first letter already decides A < J). Unless the use of lexical in the desciption differs from the common definition. And since the input is a cycle, both paths should be candidates.\\n\\n![image](https://assets.leetcode.com/users/images/7ea9207b-a052-4451-b1da-2df858b28850_1652559354.383964.png)\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "JFK must always be the starting point. It is written in the description."
                    },
                    {
                        "username": "codemaster2911",
                        "content": "[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nwhat shoul be the output of this\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "For example 886 Possible Bipartition, the time complexity for the DFS solution that put the \"dislike\" relation on to a graph, is O(V+E).\\nO(V+E) means you have to visit each vertex and edge for at lease once. \\nWhy this question is not the case? \\nCan anyone give detailed explanation, thanks!"
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Whats the proof that the point where we get stuck is the end point??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "When all edges are visited, that\\'s the endpoint."
                    },
                    {
                        "username": "Paras132",
                        "content": "Input : [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput : [\"JFK\",\"KUL\"]\\nExpected : [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow the values in \"Expected\" holds true ? question says ned to return lexical order so in that case \"KUL\" is smaller than \"NRT\".\\n\\nPlease explain.\\n\\n"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "I can think of some intuition behind solving this problem, but I\\'m struggling to understand why itineraries can come back to an airport that has already been visited?\\nIn graph search, we don\\'t process the same node twice, right? So how are any of these test cases given in the question valid in any way?"
                    },
                    {
                        "username": "Hugheym",
                        "content": "This is what I\\'m getting:\\n\\nInput:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nIf read as a single string, wouldn\\'t the sequence starting with ATL be first?"
                    },
                    {
                        "username": "kargreat",
                        "content": "for test case: [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"],[\"LHR\",\"SEA\"]]\\nleetcode output is: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\",\"SEA\"]\\n\\nThis is absurd."
                    },
                    {
                        "username": "JiaweiZhang1994",
                        "content": "I have solved the problem by the top 1 answer. However I still have a problem about Eulerian path.\\nTest case: [[\"E\", \"F\"], [\"JFK\", \"A\"], [\"A\", \"D\"], [\"D\", \"E\"],[\"F\",\"A\"],[\"JFK\",\"B\"],[\"B\", \"F\"]]\\nI am not sure about the expected answer.\\nThe expected answer is [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\",\"A\"],\\nHowever I think it should be [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\"]\\nSo the graph should looks like:\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1568312939.png)\\n\\n\\nDoes Anyone can help me with my confusing?\\nI would appreciate that."
                    },
                    {
                        "username": "sssss29",
                        "content": "In this test case \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]] why output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nKUL is alphabetically ahead of NRT,m so it should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]??"
                    }
                ]
            },
            {
                "id": 1573578,
                "content": [
                    {
                        "username": "VoidedName",
                        "content": "I don\\'t believe the error reporting for the typescript version is correct. The string ATLJFKATL is < JFKATLJFK (same length and first letter already decides A < J). Unless the use of lexical in the desciption differs from the common definition. And since the input is a cycle, both paths should be candidates.\\n\\n![image](https://assets.leetcode.com/users/images/7ea9207b-a052-4451-b1da-2df858b28850_1652559354.383964.png)\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "JFK must always be the starting point. It is written in the description."
                    },
                    {
                        "username": "codemaster2911",
                        "content": "[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nwhat shoul be the output of this\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "For example 886 Possible Bipartition, the time complexity for the DFS solution that put the \"dislike\" relation on to a graph, is O(V+E).\\nO(V+E) means you have to visit each vertex and edge for at lease once. \\nWhy this question is not the case? \\nCan anyone give detailed explanation, thanks!"
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Whats the proof that the point where we get stuck is the end point??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "When all edges are visited, that\\'s the endpoint."
                    },
                    {
                        "username": "Paras132",
                        "content": "Input : [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput : [\"JFK\",\"KUL\"]\\nExpected : [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow the values in \"Expected\" holds true ? question says ned to return lexical order so in that case \"KUL\" is smaller than \"NRT\".\\n\\nPlease explain.\\n\\n"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "I can think of some intuition behind solving this problem, but I\\'m struggling to understand why itineraries can come back to an airport that has already been visited?\\nIn graph search, we don\\'t process the same node twice, right? So how are any of these test cases given in the question valid in any way?"
                    },
                    {
                        "username": "Hugheym",
                        "content": "This is what I\\'m getting:\\n\\nInput:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nIf read as a single string, wouldn\\'t the sequence starting with ATL be first?"
                    },
                    {
                        "username": "kargreat",
                        "content": "for test case: [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"],[\"LHR\",\"SEA\"]]\\nleetcode output is: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\",\"SEA\"]\\n\\nThis is absurd."
                    },
                    {
                        "username": "JiaweiZhang1994",
                        "content": "I have solved the problem by the top 1 answer. However I still have a problem about Eulerian path.\\nTest case: [[\"E\", \"F\"], [\"JFK\", \"A\"], [\"A\", \"D\"], [\"D\", \"E\"],[\"F\",\"A\"],[\"JFK\",\"B\"],[\"B\", \"F\"]]\\nI am not sure about the expected answer.\\nThe expected answer is [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\",\"A\"],\\nHowever I think it should be [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\"]\\nSo the graph should looks like:\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1568312939.png)\\n\\n\\nDoes Anyone can help me with my confusing?\\nI would appreciate that."
                    },
                    {
                        "username": "sssss29",
                        "content": "In this test case \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]] why output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nKUL is alphabetically ahead of NRT,m so it should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]??"
                    }
                ]
            },
            {
                "id": 1573541,
                "content": [
                    {
                        "username": "VoidedName",
                        "content": "I don\\'t believe the error reporting for the typescript version is correct. The string ATLJFKATL is < JFKATLJFK (same length and first letter already decides A < J). Unless the use of lexical in the desciption differs from the common definition. And since the input is a cycle, both paths should be candidates.\\n\\n![image](https://assets.leetcode.com/users/images/7ea9207b-a052-4451-b1da-2df858b28850_1652559354.383964.png)\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "JFK must always be the starting point. It is written in the description."
                    },
                    {
                        "username": "codemaster2911",
                        "content": "[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nwhat shoul be the output of this\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "For example 886 Possible Bipartition, the time complexity for the DFS solution that put the \"dislike\" relation on to a graph, is O(V+E).\\nO(V+E) means you have to visit each vertex and edge for at lease once. \\nWhy this question is not the case? \\nCan anyone give detailed explanation, thanks!"
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Whats the proof that the point where we get stuck is the end point??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "When all edges are visited, that\\'s the endpoint."
                    },
                    {
                        "username": "Paras132",
                        "content": "Input : [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput : [\"JFK\",\"KUL\"]\\nExpected : [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow the values in \"Expected\" holds true ? question says ned to return lexical order so in that case \"KUL\" is smaller than \"NRT\".\\n\\nPlease explain.\\n\\n"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "I can think of some intuition behind solving this problem, but I\\'m struggling to understand why itineraries can come back to an airport that has already been visited?\\nIn graph search, we don\\'t process the same node twice, right? So how are any of these test cases given in the question valid in any way?"
                    },
                    {
                        "username": "Hugheym",
                        "content": "This is what I\\'m getting:\\n\\nInput:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nIf read as a single string, wouldn\\'t the sequence starting with ATL be first?"
                    },
                    {
                        "username": "kargreat",
                        "content": "for test case: [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"],[\"LHR\",\"SEA\"]]\\nleetcode output is: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\",\"SEA\"]\\n\\nThis is absurd."
                    },
                    {
                        "username": "JiaweiZhang1994",
                        "content": "I have solved the problem by the top 1 answer. However I still have a problem about Eulerian path.\\nTest case: [[\"E\", \"F\"], [\"JFK\", \"A\"], [\"A\", \"D\"], [\"D\", \"E\"],[\"F\",\"A\"],[\"JFK\",\"B\"],[\"B\", \"F\"]]\\nI am not sure about the expected answer.\\nThe expected answer is [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\",\"A\"],\\nHowever I think it should be [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\"]\\nSo the graph should looks like:\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1568312939.png)\\n\\n\\nDoes Anyone can help me with my confusing?\\nI would appreciate that."
                    },
                    {
                        "username": "sssss29",
                        "content": "In this test case \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]] why output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nKUL is alphabetically ahead of NRT,m so it should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]??"
                    }
                ]
            },
            {
                "id": 1573403,
                "content": [
                    {
                        "username": "VoidedName",
                        "content": "I don\\'t believe the error reporting for the typescript version is correct. The string ATLJFKATL is < JFKATLJFK (same length and first letter already decides A < J). Unless the use of lexical in the desciption differs from the common definition. And since the input is a cycle, both paths should be candidates.\\n\\n![image](https://assets.leetcode.com/users/images/7ea9207b-a052-4451-b1da-2df858b28850_1652559354.383964.png)\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "JFK must always be the starting point. It is written in the description."
                    },
                    {
                        "username": "codemaster2911",
                        "content": "[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nwhat shoul be the output of this\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "For example 886 Possible Bipartition, the time complexity for the DFS solution that put the \"dislike\" relation on to a graph, is O(V+E).\\nO(V+E) means you have to visit each vertex and edge for at lease once. \\nWhy this question is not the case? \\nCan anyone give detailed explanation, thanks!"
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Whats the proof that the point where we get stuck is the end point??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "When all edges are visited, that\\'s the endpoint."
                    },
                    {
                        "username": "Paras132",
                        "content": "Input : [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput : [\"JFK\",\"KUL\"]\\nExpected : [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow the values in \"Expected\" holds true ? question says ned to return lexical order so in that case \"KUL\" is smaller than \"NRT\".\\n\\nPlease explain.\\n\\n"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "I can think of some intuition behind solving this problem, but I\\'m struggling to understand why itineraries can come back to an airport that has already been visited?\\nIn graph search, we don\\'t process the same node twice, right? So how are any of these test cases given in the question valid in any way?"
                    },
                    {
                        "username": "Hugheym",
                        "content": "This is what I\\'m getting:\\n\\nInput:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nIf read as a single string, wouldn\\'t the sequence starting with ATL be first?"
                    },
                    {
                        "username": "kargreat",
                        "content": "for test case: [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"],[\"LHR\",\"SEA\"]]\\nleetcode output is: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\",\"SEA\"]\\n\\nThis is absurd."
                    },
                    {
                        "username": "JiaweiZhang1994",
                        "content": "I have solved the problem by the top 1 answer. However I still have a problem about Eulerian path.\\nTest case: [[\"E\", \"F\"], [\"JFK\", \"A\"], [\"A\", \"D\"], [\"D\", \"E\"],[\"F\",\"A\"],[\"JFK\",\"B\"],[\"B\", \"F\"]]\\nI am not sure about the expected answer.\\nThe expected answer is [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\",\"A\"],\\nHowever I think it should be [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\"]\\nSo the graph should looks like:\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1568312939.png)\\n\\n\\nDoes Anyone can help me with my confusing?\\nI would appreciate that."
                    },
                    {
                        "username": "sssss29",
                        "content": "In this test case \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]] why output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nKUL is alphabetically ahead of NRT,m so it should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]??"
                    }
                ]
            },
            {
                "id": 1573318,
                "content": [
                    {
                        "username": "VoidedName",
                        "content": "I don\\'t believe the error reporting for the typescript version is correct. The string ATLJFKATL is < JFKATLJFK (same length and first letter already decides A < J). Unless the use of lexical in the desciption differs from the common definition. And since the input is a cycle, both paths should be candidates.\\n\\n![image](https://assets.leetcode.com/users/images/7ea9207b-a052-4451-b1da-2df858b28850_1652559354.383964.png)\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "JFK must always be the starting point. It is written in the description."
                    },
                    {
                        "username": "codemaster2911",
                        "content": "[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nwhat shoul be the output of this\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "For example 886 Possible Bipartition, the time complexity for the DFS solution that put the \"dislike\" relation on to a graph, is O(V+E).\\nO(V+E) means you have to visit each vertex and edge for at lease once. \\nWhy this question is not the case? \\nCan anyone give detailed explanation, thanks!"
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Whats the proof that the point where we get stuck is the end point??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "When all edges are visited, that\\'s the endpoint."
                    },
                    {
                        "username": "Paras132",
                        "content": "Input : [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput : [\"JFK\",\"KUL\"]\\nExpected : [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow the values in \"Expected\" holds true ? question says ned to return lexical order so in that case \"KUL\" is smaller than \"NRT\".\\n\\nPlease explain.\\n\\n"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "I can think of some intuition behind solving this problem, but I\\'m struggling to understand why itineraries can come back to an airport that has already been visited?\\nIn graph search, we don\\'t process the same node twice, right? So how are any of these test cases given in the question valid in any way?"
                    },
                    {
                        "username": "Hugheym",
                        "content": "This is what I\\'m getting:\\n\\nInput:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nIf read as a single string, wouldn\\'t the sequence starting with ATL be first?"
                    },
                    {
                        "username": "kargreat",
                        "content": "for test case: [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"],[\"LHR\",\"SEA\"]]\\nleetcode output is: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\",\"SEA\"]\\n\\nThis is absurd."
                    },
                    {
                        "username": "JiaweiZhang1994",
                        "content": "I have solved the problem by the top 1 answer. However I still have a problem about Eulerian path.\\nTest case: [[\"E\", \"F\"], [\"JFK\", \"A\"], [\"A\", \"D\"], [\"D\", \"E\"],[\"F\",\"A\"],[\"JFK\",\"B\"],[\"B\", \"F\"]]\\nI am not sure about the expected answer.\\nThe expected answer is [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\",\"A\"],\\nHowever I think it should be [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\"]\\nSo the graph should looks like:\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1568312939.png)\\n\\n\\nDoes Anyone can help me with my confusing?\\nI would appreciate that."
                    },
                    {
                        "username": "sssss29",
                        "content": "In this test case \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]] why output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nKUL is alphabetically ahead of NRT,m so it should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]??"
                    }
                ]
            },
            {
                "id": 1572997,
                "content": [
                    {
                        "username": "VoidedName",
                        "content": "I don\\'t believe the error reporting for the typescript version is correct. The string ATLJFKATL is < JFKATLJFK (same length and first letter already decides A < J). Unless the use of lexical in the desciption differs from the common definition. And since the input is a cycle, both paths should be candidates.\\n\\n![image](https://assets.leetcode.com/users/images/7ea9207b-a052-4451-b1da-2df858b28850_1652559354.383964.png)\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "JFK must always be the starting point. It is written in the description."
                    },
                    {
                        "username": "codemaster2911",
                        "content": "[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nwhat shoul be the output of this\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "For example 886 Possible Bipartition, the time complexity for the DFS solution that put the \"dislike\" relation on to a graph, is O(V+E).\\nO(V+E) means you have to visit each vertex and edge for at lease once. \\nWhy this question is not the case? \\nCan anyone give detailed explanation, thanks!"
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Whats the proof that the point where we get stuck is the end point??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "When all edges are visited, that\\'s the endpoint."
                    },
                    {
                        "username": "Paras132",
                        "content": "Input : [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput : [\"JFK\",\"KUL\"]\\nExpected : [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow the values in \"Expected\" holds true ? question says ned to return lexical order so in that case \"KUL\" is smaller than \"NRT\".\\n\\nPlease explain.\\n\\n"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "I can think of some intuition behind solving this problem, but I\\'m struggling to understand why itineraries can come back to an airport that has already been visited?\\nIn graph search, we don\\'t process the same node twice, right? So how are any of these test cases given in the question valid in any way?"
                    },
                    {
                        "username": "Hugheym",
                        "content": "This is what I\\'m getting:\\n\\nInput:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nIf read as a single string, wouldn\\'t the sequence starting with ATL be first?"
                    },
                    {
                        "username": "kargreat",
                        "content": "for test case: [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"],[\"LHR\",\"SEA\"]]\\nleetcode output is: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\",\"SEA\"]\\n\\nThis is absurd."
                    },
                    {
                        "username": "JiaweiZhang1994",
                        "content": "I have solved the problem by the top 1 answer. However I still have a problem about Eulerian path.\\nTest case: [[\"E\", \"F\"], [\"JFK\", \"A\"], [\"A\", \"D\"], [\"D\", \"E\"],[\"F\",\"A\"],[\"JFK\",\"B\"],[\"B\", \"F\"]]\\nI am not sure about the expected answer.\\nThe expected answer is [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\",\"A\"],\\nHowever I think it should be [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\"]\\nSo the graph should looks like:\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1568312939.png)\\n\\n\\nDoes Anyone can help me with my confusing?\\nI would appreciate that."
                    },
                    {
                        "username": "sssss29",
                        "content": "In this test case \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]] why output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nKUL is alphabetically ahead of NRT,m so it should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]??"
                    }
                ]
            },
            {
                "id": 1572307,
                "content": [
                    {
                        "username": "VoidedName",
                        "content": "I don\\'t believe the error reporting for the typescript version is correct. The string ATLJFKATL is < JFKATLJFK (same length and first letter already decides A < J). Unless the use of lexical in the desciption differs from the common definition. And since the input is a cycle, both paths should be candidates.\\n\\n![image](https://assets.leetcode.com/users/images/7ea9207b-a052-4451-b1da-2df858b28850_1652559354.383964.png)\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "JFK must always be the starting point. It is written in the description."
                    },
                    {
                        "username": "codemaster2911",
                        "content": "[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nwhat shoul be the output of this\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "For example 886 Possible Bipartition, the time complexity for the DFS solution that put the \"dislike\" relation on to a graph, is O(V+E).\\nO(V+E) means you have to visit each vertex and edge for at lease once. \\nWhy this question is not the case? \\nCan anyone give detailed explanation, thanks!"
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Whats the proof that the point where we get stuck is the end point??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "When all edges are visited, that\\'s the endpoint."
                    },
                    {
                        "username": "Paras132",
                        "content": "Input : [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput : [\"JFK\",\"KUL\"]\\nExpected : [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow the values in \"Expected\" holds true ? question says ned to return lexical order so in that case \"KUL\" is smaller than \"NRT\".\\n\\nPlease explain.\\n\\n"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "I can think of some intuition behind solving this problem, but I\\'m struggling to understand why itineraries can come back to an airport that has already been visited?\\nIn graph search, we don\\'t process the same node twice, right? So how are any of these test cases given in the question valid in any way?"
                    },
                    {
                        "username": "Hugheym",
                        "content": "This is what I\\'m getting:\\n\\nInput:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nIf read as a single string, wouldn\\'t the sequence starting with ATL be first?"
                    },
                    {
                        "username": "kargreat",
                        "content": "for test case: [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"],[\"LHR\",\"SEA\"]]\\nleetcode output is: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\",\"SEA\"]\\n\\nThis is absurd."
                    },
                    {
                        "username": "JiaweiZhang1994",
                        "content": "I have solved the problem by the top 1 answer. However I still have a problem about Eulerian path.\\nTest case: [[\"E\", \"F\"], [\"JFK\", \"A\"], [\"A\", \"D\"], [\"D\", \"E\"],[\"F\",\"A\"],[\"JFK\",\"B\"],[\"B\", \"F\"]]\\nI am not sure about the expected answer.\\nThe expected answer is [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\",\"A\"],\\nHowever I think it should be [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\"]\\nSo the graph should looks like:\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1568312939.png)\\n\\n\\nDoes Anyone can help me with my confusing?\\nI would appreciate that."
                    },
                    {
                        "username": "sssss29",
                        "content": "In this test case \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]] why output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nKUL is alphabetically ahead of NRT,m so it should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]??"
                    }
                ]
            },
            {
                "id": 1571592,
                "content": [
                    {
                        "username": "strisunshine",
                        "content": "[[\"SJC\",\"MUC\"],[\"JFK\",\"MUC\"],[\"JFK\",\"SJC\"],[\"MUC\",\"SFO\"],[\"SFO\",\"LHR\"]]? \\n\\nIs JFK->SJC->MUC->SFO->LHR a valid itinerary ?"
                    },
                    {
                        "username": "mysun",
                        "content": "For example: the tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]], and how can we find the start airport, that is \"JFK\""
                    },
                    {
                        "username": "lindan_xmu",
                        "content": "Input [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]], \\n why the result is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"], not [\"JFK\",\"KUL\"]"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "How do we analyze the time complexity in this case?"
                    },
                    {
                        "username": "nikhil72",
                        "content": "Hi,\\n\\nPlease explain how and why my output is wrong. Is ADL not lexically smaller than AUA? Or is it that the AXA following AUA has to be taken into consideration?\\n\\nOutput:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"ADL\",\"EZE\",\"HBA\",\"AUA\",\"AXA\",\"TIA\"]\\nExpected:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"AUA\",\"AXA\",\"TIA\",\"ADL\",\"EZE\",\"HBA\"]\\n\\nThanks,\\nNikhil"
                    },
                    {
                        "username": "slords",
                        "content": "\\nInput: [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput: [\"ATL\",\"JFK\",\"ATL\"]\\nExpected: [\"JFK\",\"ATL\",\"JFK\"]\\n\\nDoes it mean that  [\"ATL\",\"JFK\",\"ATL\"] is larger than [\"JFK\",\"ATL\",\"JFK\"] in lexical order?"
                    },
                    {
                        "username": "quan_mai",
                        "content": "tip: backtracking :-)"
                    },
                    {
                        "username": "wafsinc",
                        "content": "What? No."
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I got the solution accepted in March 2023 but retrying the same solution in Sept 2023 is giving TLE :-("
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "Well, I solved it and it works on the given test cases.\\n\\nBut, like I said, I cannot guarantee, that it will work on ANY set of input data.\\n\\nFor example, it will likely fail if we have a disconnected graph, i. e. a graph with more than 1 component of connectivity/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "We know the tickets are from a single itinerary, so they have to be connected and a solution is guaranteed to exist."
                    }
                ]
            },
            {
                "id": 1571593,
                "content": [
                    {
                        "username": "strisunshine",
                        "content": "[[\"SJC\",\"MUC\"],[\"JFK\",\"MUC\"],[\"JFK\",\"SJC\"],[\"MUC\",\"SFO\"],[\"SFO\",\"LHR\"]]? \\n\\nIs JFK->SJC->MUC->SFO->LHR a valid itinerary ?"
                    },
                    {
                        "username": "mysun",
                        "content": "For example: the tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]], and how can we find the start airport, that is \"JFK\""
                    },
                    {
                        "username": "lindan_xmu",
                        "content": "Input [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]], \\n why the result is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"], not [\"JFK\",\"KUL\"]"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "How do we analyze the time complexity in this case?"
                    },
                    {
                        "username": "nikhil72",
                        "content": "Hi,\\n\\nPlease explain how and why my output is wrong. Is ADL not lexically smaller than AUA? Or is it that the AXA following AUA has to be taken into consideration?\\n\\nOutput:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"ADL\",\"EZE\",\"HBA\",\"AUA\",\"AXA\",\"TIA\"]\\nExpected:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"AUA\",\"AXA\",\"TIA\",\"ADL\",\"EZE\",\"HBA\"]\\n\\nThanks,\\nNikhil"
                    },
                    {
                        "username": "slords",
                        "content": "\\nInput: [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput: [\"ATL\",\"JFK\",\"ATL\"]\\nExpected: [\"JFK\",\"ATL\",\"JFK\"]\\n\\nDoes it mean that  [\"ATL\",\"JFK\",\"ATL\"] is larger than [\"JFK\",\"ATL\",\"JFK\"] in lexical order?"
                    },
                    {
                        "username": "quan_mai",
                        "content": "tip: backtracking :-)"
                    },
                    {
                        "username": "wafsinc",
                        "content": "What? No."
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I got the solution accepted in March 2023 but retrying the same solution in Sept 2023 is giving TLE :-("
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "Well, I solved it and it works on the given test cases.\\n\\nBut, like I said, I cannot guarantee, that it will work on ANY set of input data.\\n\\nFor example, it will likely fail if we have a disconnected graph, i. e. a graph with more than 1 component of connectivity/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "We know the tickets are from a single itinerary, so they have to be connected and a solution is guaranteed to exist."
                    }
                ]
            },
            {
                "id": 1571594,
                "content": [
                    {
                        "username": "strisunshine",
                        "content": "[[\"SJC\",\"MUC\"],[\"JFK\",\"MUC\"],[\"JFK\",\"SJC\"],[\"MUC\",\"SFO\"],[\"SFO\",\"LHR\"]]? \\n\\nIs JFK->SJC->MUC->SFO->LHR a valid itinerary ?"
                    },
                    {
                        "username": "mysun",
                        "content": "For example: the tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]], and how can we find the start airport, that is \"JFK\""
                    },
                    {
                        "username": "lindan_xmu",
                        "content": "Input [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]], \\n why the result is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"], not [\"JFK\",\"KUL\"]"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "How do we analyze the time complexity in this case?"
                    },
                    {
                        "username": "nikhil72",
                        "content": "Hi,\\n\\nPlease explain how and why my output is wrong. Is ADL not lexically smaller than AUA? Or is it that the AXA following AUA has to be taken into consideration?\\n\\nOutput:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"ADL\",\"EZE\",\"HBA\",\"AUA\",\"AXA\",\"TIA\"]\\nExpected:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"AUA\",\"AXA\",\"TIA\",\"ADL\",\"EZE\",\"HBA\"]\\n\\nThanks,\\nNikhil"
                    },
                    {
                        "username": "slords",
                        "content": "\\nInput: [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput: [\"ATL\",\"JFK\",\"ATL\"]\\nExpected: [\"JFK\",\"ATL\",\"JFK\"]\\n\\nDoes it mean that  [\"ATL\",\"JFK\",\"ATL\"] is larger than [\"JFK\",\"ATL\",\"JFK\"] in lexical order?"
                    },
                    {
                        "username": "quan_mai",
                        "content": "tip: backtracking :-)"
                    },
                    {
                        "username": "wafsinc",
                        "content": "What? No."
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I got the solution accepted in March 2023 but retrying the same solution in Sept 2023 is giving TLE :-("
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "Well, I solved it and it works on the given test cases.\\n\\nBut, like I said, I cannot guarantee, that it will work on ANY set of input data.\\n\\nFor example, it will likely fail if we have a disconnected graph, i. e. a graph with more than 1 component of connectivity/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "We know the tickets are from a single itinerary, so they have to be connected and a solution is guaranteed to exist."
                    }
                ]
            },
            {
                "id": 1571595,
                "content": [
                    {
                        "username": "strisunshine",
                        "content": "[[\"SJC\",\"MUC\"],[\"JFK\",\"MUC\"],[\"JFK\",\"SJC\"],[\"MUC\",\"SFO\"],[\"SFO\",\"LHR\"]]? \\n\\nIs JFK->SJC->MUC->SFO->LHR a valid itinerary ?"
                    },
                    {
                        "username": "mysun",
                        "content": "For example: the tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]], and how can we find the start airport, that is \"JFK\""
                    },
                    {
                        "username": "lindan_xmu",
                        "content": "Input [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]], \\n why the result is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"], not [\"JFK\",\"KUL\"]"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "How do we analyze the time complexity in this case?"
                    },
                    {
                        "username": "nikhil72",
                        "content": "Hi,\\n\\nPlease explain how and why my output is wrong. Is ADL not lexically smaller than AUA? Or is it that the AXA following AUA has to be taken into consideration?\\n\\nOutput:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"ADL\",\"EZE\",\"HBA\",\"AUA\",\"AXA\",\"TIA\"]\\nExpected:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"AUA\",\"AXA\",\"TIA\",\"ADL\",\"EZE\",\"HBA\"]\\n\\nThanks,\\nNikhil"
                    },
                    {
                        "username": "slords",
                        "content": "\\nInput: [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput: [\"ATL\",\"JFK\",\"ATL\"]\\nExpected: [\"JFK\",\"ATL\",\"JFK\"]\\n\\nDoes it mean that  [\"ATL\",\"JFK\",\"ATL\"] is larger than [\"JFK\",\"ATL\",\"JFK\"] in lexical order?"
                    },
                    {
                        "username": "quan_mai",
                        "content": "tip: backtracking :-)"
                    },
                    {
                        "username": "wafsinc",
                        "content": "What? No."
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I got the solution accepted in March 2023 but retrying the same solution in Sept 2023 is giving TLE :-("
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "Well, I solved it and it works on the given test cases.\\n\\nBut, like I said, I cannot guarantee, that it will work on ANY set of input data.\\n\\nFor example, it will likely fail if we have a disconnected graph, i. e. a graph with more than 1 component of connectivity/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "We know the tickets are from a single itinerary, so they have to be connected and a solution is guaranteed to exist."
                    }
                ]
            },
            {
                "id": 1571596,
                "content": [
                    {
                        "username": "strisunshine",
                        "content": "[[\"SJC\",\"MUC\"],[\"JFK\",\"MUC\"],[\"JFK\",\"SJC\"],[\"MUC\",\"SFO\"],[\"SFO\",\"LHR\"]]? \\n\\nIs JFK->SJC->MUC->SFO->LHR a valid itinerary ?"
                    },
                    {
                        "username": "mysun",
                        "content": "For example: the tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]], and how can we find the start airport, that is \"JFK\""
                    },
                    {
                        "username": "lindan_xmu",
                        "content": "Input [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]], \\n why the result is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"], not [\"JFK\",\"KUL\"]"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "How do we analyze the time complexity in this case?"
                    },
                    {
                        "username": "nikhil72",
                        "content": "Hi,\\n\\nPlease explain how and why my output is wrong. Is ADL not lexically smaller than AUA? Or is it that the AXA following AUA has to be taken into consideration?\\n\\nOutput:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"ADL\",\"EZE\",\"HBA\",\"AUA\",\"AXA\",\"TIA\"]\\nExpected:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"AUA\",\"AXA\",\"TIA\",\"ADL\",\"EZE\",\"HBA\"]\\n\\nThanks,\\nNikhil"
                    },
                    {
                        "username": "slords",
                        "content": "\\nInput: [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput: [\"ATL\",\"JFK\",\"ATL\"]\\nExpected: [\"JFK\",\"ATL\",\"JFK\"]\\n\\nDoes it mean that  [\"ATL\",\"JFK\",\"ATL\"] is larger than [\"JFK\",\"ATL\",\"JFK\"] in lexical order?"
                    },
                    {
                        "username": "quan_mai",
                        "content": "tip: backtracking :-)"
                    },
                    {
                        "username": "wafsinc",
                        "content": "What? No."
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I got the solution accepted in March 2023 but retrying the same solution in Sept 2023 is giving TLE :-("
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "Well, I solved it and it works on the given test cases.\\n\\nBut, like I said, I cannot guarantee, that it will work on ANY set of input data.\\n\\nFor example, it will likely fail if we have a disconnected graph, i. e. a graph with more than 1 component of connectivity/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "We know the tickets are from a single itinerary, so they have to be connected and a solution is guaranteed to exist."
                    }
                ]
            },
            {
                "id": 1569082,
                "content": [
                    {
                        "username": "strisunshine",
                        "content": "[[\"SJC\",\"MUC\"],[\"JFK\",\"MUC\"],[\"JFK\",\"SJC\"],[\"MUC\",\"SFO\"],[\"SFO\",\"LHR\"]]? \\n\\nIs JFK->SJC->MUC->SFO->LHR a valid itinerary ?"
                    },
                    {
                        "username": "mysun",
                        "content": "For example: the tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]], and how can we find the start airport, that is \"JFK\""
                    },
                    {
                        "username": "lindan_xmu",
                        "content": "Input [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]], \\n why the result is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"], not [\"JFK\",\"KUL\"]"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "How do we analyze the time complexity in this case?"
                    },
                    {
                        "username": "nikhil72",
                        "content": "Hi,\\n\\nPlease explain how and why my output is wrong. Is ADL not lexically smaller than AUA? Or is it that the AXA following AUA has to be taken into consideration?\\n\\nOutput:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"ADL\",\"EZE\",\"HBA\",\"AUA\",\"AXA\",\"TIA\"]\\nExpected:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"AUA\",\"AXA\",\"TIA\",\"ADL\",\"EZE\",\"HBA\"]\\n\\nThanks,\\nNikhil"
                    },
                    {
                        "username": "slords",
                        "content": "\\nInput: [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput: [\"ATL\",\"JFK\",\"ATL\"]\\nExpected: [\"JFK\",\"ATL\",\"JFK\"]\\n\\nDoes it mean that  [\"ATL\",\"JFK\",\"ATL\"] is larger than [\"JFK\",\"ATL\",\"JFK\"] in lexical order?"
                    },
                    {
                        "username": "quan_mai",
                        "content": "tip: backtracking :-)"
                    },
                    {
                        "username": "wafsinc",
                        "content": "What? No."
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I got the solution accepted in March 2023 but retrying the same solution in Sept 2023 is giving TLE :-("
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "Well, I solved it and it works on the given test cases.\\n\\nBut, like I said, I cannot guarantee, that it will work on ANY set of input data.\\n\\nFor example, it will likely fail if we have a disconnected graph, i. e. a graph with more than 1 component of connectivity/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "We know the tickets are from a single itinerary, so they have to be connected and a solution is guaranteed to exist."
                    }
                ]
            },
            {
                "id": 2056868,
                "content": [
                    {
                        "username": "strisunshine",
                        "content": "[[\"SJC\",\"MUC\"],[\"JFK\",\"MUC\"],[\"JFK\",\"SJC\"],[\"MUC\",\"SFO\"],[\"SFO\",\"LHR\"]]? \\n\\nIs JFK->SJC->MUC->SFO->LHR a valid itinerary ?"
                    },
                    {
                        "username": "mysun",
                        "content": "For example: the tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]], and how can we find the start airport, that is \"JFK\""
                    },
                    {
                        "username": "lindan_xmu",
                        "content": "Input [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]], \\n why the result is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"], not [\"JFK\",\"KUL\"]"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "How do we analyze the time complexity in this case?"
                    },
                    {
                        "username": "nikhil72",
                        "content": "Hi,\\n\\nPlease explain how and why my output is wrong. Is ADL not lexically smaller than AUA? Or is it that the AXA following AUA has to be taken into consideration?\\n\\nOutput:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"ADL\",\"EZE\",\"HBA\",\"AUA\",\"AXA\",\"TIA\"]\\nExpected:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"AUA\",\"AXA\",\"TIA\",\"ADL\",\"EZE\",\"HBA\"]\\n\\nThanks,\\nNikhil"
                    },
                    {
                        "username": "slords",
                        "content": "\\nInput: [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput: [\"ATL\",\"JFK\",\"ATL\"]\\nExpected: [\"JFK\",\"ATL\",\"JFK\"]\\n\\nDoes it mean that  [\"ATL\",\"JFK\",\"ATL\"] is larger than [\"JFK\",\"ATL\",\"JFK\"] in lexical order?"
                    },
                    {
                        "username": "quan_mai",
                        "content": "tip: backtracking :-)"
                    },
                    {
                        "username": "wafsinc",
                        "content": "What? No."
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I got the solution accepted in March 2023 but retrying the same solution in Sept 2023 is giving TLE :-("
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "Well, I solved it and it works on the given test cases.\\n\\nBut, like I said, I cannot guarantee, that it will work on ANY set of input data.\\n\\nFor example, it will likely fail if we have a disconnected graph, i. e. a graph with more than 1 component of connectivity/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "We know the tickets are from a single itinerary, so they have to be connected and a solution is guaranteed to exist."
                    }
                ]
            },
            {
                "id": 2056714,
                "content": [
                    {
                        "username": "strisunshine",
                        "content": "[[\"SJC\",\"MUC\"],[\"JFK\",\"MUC\"],[\"JFK\",\"SJC\"],[\"MUC\",\"SFO\"],[\"SFO\",\"LHR\"]]? \\n\\nIs JFK->SJC->MUC->SFO->LHR a valid itinerary ?"
                    },
                    {
                        "username": "mysun",
                        "content": "For example: the tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]], and how can we find the start airport, that is \"JFK\""
                    },
                    {
                        "username": "lindan_xmu",
                        "content": "Input [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]], \\n why the result is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"], not [\"JFK\",\"KUL\"]"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "How do we analyze the time complexity in this case?"
                    },
                    {
                        "username": "nikhil72",
                        "content": "Hi,\\n\\nPlease explain how and why my output is wrong. Is ADL not lexically smaller than AUA? Or is it that the AXA following AUA has to be taken into consideration?\\n\\nOutput:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"ADL\",\"EZE\",\"HBA\",\"AUA\",\"AXA\",\"TIA\"]\\nExpected:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"AUA\",\"AXA\",\"TIA\",\"ADL\",\"EZE\",\"HBA\"]\\n\\nThanks,\\nNikhil"
                    },
                    {
                        "username": "slords",
                        "content": "\\nInput: [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput: [\"ATL\",\"JFK\",\"ATL\"]\\nExpected: [\"JFK\",\"ATL\",\"JFK\"]\\n\\nDoes it mean that  [\"ATL\",\"JFK\",\"ATL\"] is larger than [\"JFK\",\"ATL\",\"JFK\"] in lexical order?"
                    },
                    {
                        "username": "quan_mai",
                        "content": "tip: backtracking :-)"
                    },
                    {
                        "username": "wafsinc",
                        "content": "What? No."
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I got the solution accepted in March 2023 but retrying the same solution in Sept 2023 is giving TLE :-("
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "Well, I solved it and it works on the given test cases.\\n\\nBut, like I said, I cannot guarantee, that it will work on ANY set of input data.\\n\\nFor example, it will likely fail if we have a disconnected graph, i. e. a graph with more than 1 component of connectivity/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "We know the tickets are from a single itinerary, so they have to be connected and a solution is guaranteed to exist."
                    }
                ]
            },
            {
                "id": 2071356,
                "content": [
                    {
                        "username": "strisunshine",
                        "content": "[[\"SJC\",\"MUC\"],[\"JFK\",\"MUC\"],[\"JFK\",\"SJC\"],[\"MUC\",\"SFO\"],[\"SFO\",\"LHR\"]]? \\n\\nIs JFK->SJC->MUC->SFO->LHR a valid itinerary ?"
                    },
                    {
                        "username": "mysun",
                        "content": "For example: the tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]], and how can we find the start airport, that is \"JFK\""
                    },
                    {
                        "username": "lindan_xmu",
                        "content": "Input [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]], \\n why the result is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"], not [\"JFK\",\"KUL\"]"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "How do we analyze the time complexity in this case?"
                    },
                    {
                        "username": "nikhil72",
                        "content": "Hi,\\n\\nPlease explain how and why my output is wrong. Is ADL not lexically smaller than AUA? Or is it that the AXA following AUA has to be taken into consideration?\\n\\nOutput:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"ADL\",\"EZE\",\"HBA\",\"AUA\",\"AXA\",\"TIA\"]\\nExpected:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"AUA\",\"AXA\",\"TIA\",\"ADL\",\"EZE\",\"HBA\"]\\n\\nThanks,\\nNikhil"
                    },
                    {
                        "username": "slords",
                        "content": "\\nInput: [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput: [\"ATL\",\"JFK\",\"ATL\"]\\nExpected: [\"JFK\",\"ATL\",\"JFK\"]\\n\\nDoes it mean that  [\"ATL\",\"JFK\",\"ATL\"] is larger than [\"JFK\",\"ATL\",\"JFK\"] in lexical order?"
                    },
                    {
                        "username": "quan_mai",
                        "content": "tip: backtracking :-)"
                    },
                    {
                        "username": "wafsinc",
                        "content": "What? No."
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I got the solution accepted in March 2023 but retrying the same solution in Sept 2023 is giving TLE :-("
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "Well, I solved it and it works on the given test cases.\\n\\nBut, like I said, I cannot guarantee, that it will work on ANY set of input data.\\n\\nFor example, it will likely fail if we have a disconnected graph, i. e. a graph with more than 1 component of connectivity/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "We know the tickets are from a single itinerary, so they have to be connected and a solution is guaranteed to exist."
                    }
                ]
            },
            {
                "id": 2057916,
                "content": [
                    {
                        "username": "strisunshine",
                        "content": "[[\"SJC\",\"MUC\"],[\"JFK\",\"MUC\"],[\"JFK\",\"SJC\"],[\"MUC\",\"SFO\"],[\"SFO\",\"LHR\"]]? \\n\\nIs JFK->SJC->MUC->SFO->LHR a valid itinerary ?"
                    },
                    {
                        "username": "mysun",
                        "content": "For example: the tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]], and how can we find the start airport, that is \"JFK\""
                    },
                    {
                        "username": "lindan_xmu",
                        "content": "Input [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]], \\n why the result is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"], not [\"JFK\",\"KUL\"]"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "How do we analyze the time complexity in this case?"
                    },
                    {
                        "username": "nikhil72",
                        "content": "Hi,\\n\\nPlease explain how and why my output is wrong. Is ADL not lexically smaller than AUA? Or is it that the AXA following AUA has to be taken into consideration?\\n\\nOutput:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"ADL\",\"EZE\",\"HBA\",\"AUA\",\"AXA\",\"TIA\"]\\nExpected:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"AUA\",\"AXA\",\"TIA\",\"ADL\",\"EZE\",\"HBA\"]\\n\\nThanks,\\nNikhil"
                    },
                    {
                        "username": "slords",
                        "content": "\\nInput: [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput: [\"ATL\",\"JFK\",\"ATL\"]\\nExpected: [\"JFK\",\"ATL\",\"JFK\"]\\n\\nDoes it mean that  [\"ATL\",\"JFK\",\"ATL\"] is larger than [\"JFK\",\"ATL\",\"JFK\"] in lexical order?"
                    },
                    {
                        "username": "quan_mai",
                        "content": "tip: backtracking :-)"
                    },
                    {
                        "username": "wafsinc",
                        "content": "What? No."
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I got the solution accepted in March 2023 but retrying the same solution in Sept 2023 is giving TLE :-("
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "Well, I solved it and it works on the given test cases.\\n\\nBut, like I said, I cannot guarantee, that it will work on ANY set of input data.\\n\\nFor example, it will likely fail if we have a disconnected graph, i. e. a graph with more than 1 component of connectivity/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "We know the tickets are from a single itinerary, so they have to be connected and a solution is guaranteed to exist."
                    }
                ]
            },
            {
                "id": 2057904,
                "content": [
                    {
                        "username": "Shivam_verma24",
                        "content": "Medium level sorting + DFS problem tagged hard"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "What is going on with this testcase?\n`tickets = [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]`\n\nMy output:\n`[\"ATL\",\"JFK\",\"ATL\"]`\n\nExpected:\n`[\"JFK\",\"ATL\",\"JFK\"]`\n\nEdit: I missed that you always start at JFK."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hints in increasing levels of spoilers: (Hints for this question are kind of hard to do unfortunately)\\n\\n1) Actually this is the biggest spoiler, but tbh I would just read the wikipedia page on Eulerian Paths. \\n\\n2) If you tried to construct a path and then failed because you didn\\'t hit every single node, is all of the work you did for nothing? Do you need to restart? or can you reuse the result you got somehow? \\nIs there any structure to the part you missed? "
                    },
                    {
                        "username": "z3eg",
                        "content": "and there goes my third hard problems solved completely by myself. ~300 lines of code and several hours of time and here we go! don\\'t give up, guys, this one doesnt seem to require some special approach, i solved it with a very very common one (surprisingly lol)"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This is a fun problem.  Here are a couple hints if you are stuck:\\n\\n* solving the lexical ordering problem first will increase the efficiency and ease of finding the final solution.\\n\\n* The relatively small amount of tickets opens up a solution method that could be extremely consumptive on large data sets. 1 <= tickets.length <= 300\\n\\nGood Luck!"
                    },
                    {
                        "username": "mstuebs",
                        "content": "I have found that for this challenge the leetcode solution might crash. I got a TLE for empty code for this testcase:\n```\n[[\"JFK\",\"KLO\"],[\"KLO\",\"VRU\"],[\"VRU\",\"JFK\"],[\"JFK\",\"IWC\"],[\"IWC\",\"EXD\"],[\"EXD\",\"VMC\"],[\"VMC\",\"EWR\"],[\"EWR\",\"PDS\"],[\"PDS\",\"PIT\"],[\"PIT\",\"YSM\"],[\"YSM\",\"HKO\"],[\"HKO\",\"RSW\"],[\"RSW\",\"HFM\"],[\"HFM\",\"HMN\"],[\"HMN\",\"IEM\"],[\"IEM\",\"MED\"],[\"MED\",\"NGX\"],[\"NGX\",\"FLL\"],[\"FLL\",\"BYC\"],[\"BYC\",\"SFO\"],[\"SFO\",\"XVS\"],[\"XVS\",\"FUQ\"],[\"FUQ\",\"XBK\"],[\"XBK\",\"DHW\"],[\"DHW\",\"YJO\"],[\"YJO\",\"ODN\"],[\"ODN\",\"XQT\"],[\"XQT\",\"ARH\"],[\"ARH\",\"DTW\"],[\"DTW\",\"MEI\"],[\"MEI\",\"DTW\"],[\"DTW\",\"GPP\"],[\"GPP\",\"WIE\"],[\"WIE\",\"ICJ\"],[\"ICJ\",\"VYX\"],[\"VYX\",\"TLS\"],[\"TLS\",\"NUB\"],[\"NUB\",\"YSM\"],[\"YSM\",\"CSD\"],[\"CSD\",\"CTI\"],[\"CTI\",\"LTU\"],[\"LTU\",\"YAE\"],[\"YAE\",\"KMO\"],[\"KMO\",\"AIT\"],[\"AIT\",\"IWC\"],[\"IWC\",\"OJB\"],[\"OJB\",\"DFV\"],[\"DFV\",\"HSS\"],[\"HSS\",\"EAN\"],[\"EAN\",\"SRT\"],[\"SRT\",\"BUF\"],[\"BUF\",\"EUH\"],[\"EUH\",\"KTE\"],[\"KTE\",\"TPA\"],[\"TPA\",\"SMF\"],[\"SMF\",\"AKP\"],[\"AKP\",\"MMB\"],[\"MMB\",\"TPA\"],[\"TPA\",\"VTO\"],[\"VTO\",\"LBT\"],[\"LBT\",\"GPP\"],[\"GPP\",\"KLO\"],[\"KLO\",\"LAX\"],[\"LAX\",\"MIA\"],[\"MIA\",\"LBT\"],[\"LBT\",\"THM\"],[\"THM\",\"WIB\"],[\"WIB\",\"ORO\"],[\"ORO\",\"IAD\"],[\"IAD\",\"GDP\"],[\"GDP\",\"HMN\"],[\"HMN\",\"CVO\"],[\"CVO\",\"LBT\"],[\"LBT\",\"UGU\"],[\"UGU\",\"HNL\"],[\"HNL\",\"JNQ\"],[\"JNQ\",\"YJO\"],[\"YJO\",\"UGU\"],[\"UGU\",\"ERQ\"],[\"ERQ\",\"XMP\"],[\"XMP\",\"DFF\"],[\"DFF\",\"BWI\"],[\"BWI\",\"MDW\"],[\"MDW\",\"XQT\"],[\"XQT\",\"PBI\"],[\"PBI\",\"IND\"],[\"IND\",\"MJN\"],[\"MJN\",\"SFO\"],[\"SFO\",\"RGS\"],[\"RGS\",\"NVP\"],[\"NVP\",\"LAS\"],[\"LAS\",\"KMO\"],[\"KMO\",\"RSW\"],[\"RSW\",\"HEW\"],[\"HEW\",\"NAT\"],[\"NAT\",\"SJU\"],[\"SJU\",\"FLM\"],[\"FLM\",\"DHL\"],[\"DHL\",\"LPI\"],[\"LPI\",\"QCD\"],[\"QCD\",\"HEW\"],[\"HEW\",\"MFN\"],[\"MFN\",\"YBC\"],[\"YBC\",\"CTX\"],[\"CTX\",\"IWC\"],[\"IWC\",\"BNG\"],[\"BNG\",\"QSH\"],[\"QSH\",\"ANC\"],[\"ANC\",\"EQC\"],[\"EQC\",\"MFN\"],[\"MFN\",\"FBW\"],[\"FBW\",\"NML\"],[\"NML\",\"AUR\"],[\"AUR\",\"LAS\"],[\"LAS\",\"EQC\"],[\"EQC\",\"KKC\"],[\"KKC\",\"LAS\"],[\"LAS\",\"QHN\"],[\"QHN\",\"MDW\"],[\"MDW\",\"KTL\"],[\"KTL\",\"BMQ\"],[\"BMQ\",\"UUH\"],[\"UUH\",\"VTO\"],[\"VTO\",\"CLF\"],[\"CLF\",\"XWB\"],[\"XWB\",\"JWA\"],[\"JWA\",\"STL\"],[\"STL\",\"BPF\"],[\"BPF\",\"MBD\"],[\"MBD\",\"HJT\"],[\"HJT\",\"UYU\"],[\"UYU\",\"HPE\"],[\"HPE\",\"VTO\"],[\"VTO\",\"OJB\"],[\"OJB\",\"SJU\"],[\"SJU\",\"MSY\"],[\"MSY\",\"QWV\"],[\"QWV\",\"OUC\"],[\"OUC\",\"XOY\"],[\"XOY\",\"GPW\"],[\"GPW\",\"OSC\"],[\"OSC\",\"MGL\"],[\"MGL\",\"VRF\"],[\"VRF\",\"XBK\"],[\"XBK\",\"PHL\"],[\"PHL\",\"QAW\"],[\"QAW\",\"YYQ\"],[\"YYQ\",\"BVI\"],[\"BVI\",\"LGA\"],[\"LGA\",\"VLT\"],[\"VLT\",\"UJJ\"],[\"UJJ\",\"BWI\"],[\"BWI\",\"LBT\"],[\"LBT\",\"DTW\"],[\"DTW\",\"MJN\"],[\"MJN\",\"HSS\"],[\"HSS\",\"OHW\"],[\"OHW\",\"BMT\"],[\"BMT\",\"IWC\"],[\"IWC\",\"UJJ\"],[\"UJJ\",\"PDS\"],[\"PDS\",\"EGK\"],[\"EGK\",\"TLS\"],[\"TLS\",\"SIX\"],[\"SIX\",\"AOT\"],[\"AOT\",\"SSH\"],[\"SSH\",\"VGK\"],[\"VGK\",\"JSF\"],[\"JSF\",\"GDP\"],[\"GDP\",\"BOL\"],[\"BOL\",\"JGH\"],[\"JGH\",\"IWC\"],[\"IWC\",\"AOX\"],[\"AOX\",\"FRI\"],[\"FRI\",\"LWV\"],[\"LWV\",\"PDX\"],[\"PDX\",\"STL\"],[\"STL\",\"AIT\"],[\"AIT\",\"CSD\"],[\"CSD\",\"SIX\"],[\"SIX\",\"BUF\"],[\"BUF\",\"VDB\"],[\"VDB\",\"XOY\"],[\"XOY\",\"TBV\"],[\"TBV\",\"BNG\"],[\"BNG\",\"HWF\"],[\"HWF\",\"LPI\"],[\"LPI\",\"JCB\"],[\"JCB\",\"DUI\"],[\"DUI\",\"IIK\"],[\"IIK\",\"YBC\"],[\"YBC\",\"VYX\"],[\"VYX\",\"YNS\"],[\"YNS\",\"BQH\"],[\"BQH\",\"WRM\"],[\"WRM\",\"SCY\"],[\"SCY\",\"DFY\"],[\"DFY\",\"BLC\"],[\"BLC\",\"PHX\"],[\"PHX\",\"DFY\"],[\"DFY\",\"BOS\"],[\"BOS\",\"WIB\"],[\"WIB\",\"SEA\"],[\"SEA\",\"THM\"],[\"THM\",\"TTY\"],[\"TTY\",\"HEW\"],[\"HEW\",\"YSM\"],[\"YSM\",\"BNN\"],[\"BNN\",\"MGY\"],[\"MGY\",\"PAR\"],[\"PAR\",\"IRJ\"],[\"IRJ\",\"VDB\"],[\"VDB\",\"ANC\"],[\"ANC\",\"SAN\"],[\"SAN\",\"RDU\"],[\"RDU\",\"REF\"],[\"REF\",\"BWI\"],[\"BWI\",\"HNL\"],[\"HNL\",\"AAP\"],[\"AAP\",\"CVO\"],[\"CVO\",\"JIR\"],[\"JIR\",\"AIT\"],[\"AIT\",\"NEE\"],[\"NEE\",\"HIN\"],[\"HIN\",\"TPU\"],[\"TPU\",\"AHF\"],[\"AHF\",\"MSY\"],[\"MSY\",\"HFM\"],[\"HFM\",\"ATW\"],[\"ATW\",\"KKC\"],[\"KKC\",\"CFB\"],[\"CFB\",\"HPE\"],[\"HPE\",\"BPF\"],[\"BPF\",\"XWB\"],[\"XWB\",\"XVS\"],[\"XVS\",\"FKN\"],[\"FKN\",\"SMF\"],[\"SMF\",\"AIT\"],[\"AIT\",\"MDW\"],[\"MDW\",\"CRG\"],[\"CRG\",\"VRU\"],[\"VRU\",\"FGD\"],[\"FGD\",\"GJK\"],[\"GJK\",\"WSR\"],[\"WSR\",\"FLM\"],[\"FLM\",\"OFX\"],[\"OFX\",\"GVU\"],[\"GVU\",\"UGU\"],[\"UGU\",\"DFV\"],[\"DFV\",\"DEN\"],[\"DEN\",\"NRE\"],[\"NRE\",\"PDX\"],[\"PDX\",\"CWG\"],[\"CWG\",\"TLS\"],[\"TLS\",\"HSS\"],[\"HSS\",\"BQI\"],[\"BQI\",\"HSB\"],[\"HSB\",\"CGT\"],[\"CGT\",\"OFX\"],[\"OFX\",\"TBV\"],[\"TBV\",\"NAT\"],[\"NAT\",\"JGH\"],[\"JGH\",\"NBP\"],[\"NBP\",\"AIT\"],[\"AIT\",\"AKP\"],[\"AKP\",\"SRT\"],[\"SRT\",\"NBP\"],[\"NBP\",\"JGH\"],[\"JGH\",\"VDB\"],[\"VDB\",\"YXT\"],[\"YXT\",\"CLF\"],[\"CLF\",\"KKC\"],[\"KKC\",\"KLO\"],[\"KLO\",\"BWT\"],[\"BWT\",\"LBT\"],[\"LBT\",\"ODN\"],[\"ODN\",\"SMF\"],[\"SMF\",\"GHP\"],[\"GHP\",\"BQI\"],[\"BQI\",\"EXD\"],[\"EXD\",\"ODN\"],[\"ODN\",\"BWT\"],[\"BWT\",\"PDX\"],[\"PDX\",\"IRU\"],[\"IRU\",\"SMJ\"],[\"SMJ\",\"UBB\"],[\"UBB\",\"SIX\"],[\"SIX\",\"XVS\"],[\"XVS\",\"ATW\"],[\"ATW\",\"AAP\"],[\"AAP\",\"RDU\"],[\"RDU\",\"TBV\"],[\"TBV\",\"JCB\"],[\"JCB\",\"TBV\"],[\"TBV\",\"IWC\"],[\"IWC\",\"VTO\"]]\n```\n![image](https://github.com/mquintus/l33tcode-reload/assets/515945/2e6b511e-d801-4f2f-a232-61793fc892c6)"
                    },
                    {
                        "username": "chrisblueeyes",
                        "content": "lol this was a sample google interview question... this brilliant high schooler solved it!! using graphs, heres the video, no code just the theory\n\nhttps://www.youtube.com/watch?v=qz9tKlF431k"
                    },
                    {
                        "username": "realitant",
                        "content": "I think it's worthwhile to explicitly state if the tickets are unique or not.\nEDIT: To anyone else wondering, the tickets are not necessarily unique"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Note- There can be multiple same direction tickets between 2 cities."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Today\\'s question was easy \\uD83E\\uDEE1\\uD83E\\uDEE1\\n\\nhttps://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    }
                ]
            },
            {
                "id": 2057903,
                "content": [
                    {
                        "username": "Shivam_verma24",
                        "content": "Medium level sorting + DFS problem tagged hard"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "What is going on with this testcase?\n`tickets = [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]`\n\nMy output:\n`[\"ATL\",\"JFK\",\"ATL\"]`\n\nExpected:\n`[\"JFK\",\"ATL\",\"JFK\"]`\n\nEdit: I missed that you always start at JFK."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hints in increasing levels of spoilers: (Hints for this question are kind of hard to do unfortunately)\\n\\n1) Actually this is the biggest spoiler, but tbh I would just read the wikipedia page on Eulerian Paths. \\n\\n2) If you tried to construct a path and then failed because you didn\\'t hit every single node, is all of the work you did for nothing? Do you need to restart? or can you reuse the result you got somehow? \\nIs there any structure to the part you missed? "
                    },
                    {
                        "username": "z3eg",
                        "content": "and there goes my third hard problems solved completely by myself. ~300 lines of code and several hours of time and here we go! don\\'t give up, guys, this one doesnt seem to require some special approach, i solved it with a very very common one (surprisingly lol)"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This is a fun problem.  Here are a couple hints if you are stuck:\\n\\n* solving the lexical ordering problem first will increase the efficiency and ease of finding the final solution.\\n\\n* The relatively small amount of tickets opens up a solution method that could be extremely consumptive on large data sets. 1 <= tickets.length <= 300\\n\\nGood Luck!"
                    },
                    {
                        "username": "mstuebs",
                        "content": "I have found that for this challenge the leetcode solution might crash. I got a TLE for empty code for this testcase:\n```\n[[\"JFK\",\"KLO\"],[\"KLO\",\"VRU\"],[\"VRU\",\"JFK\"],[\"JFK\",\"IWC\"],[\"IWC\",\"EXD\"],[\"EXD\",\"VMC\"],[\"VMC\",\"EWR\"],[\"EWR\",\"PDS\"],[\"PDS\",\"PIT\"],[\"PIT\",\"YSM\"],[\"YSM\",\"HKO\"],[\"HKO\",\"RSW\"],[\"RSW\",\"HFM\"],[\"HFM\",\"HMN\"],[\"HMN\",\"IEM\"],[\"IEM\",\"MED\"],[\"MED\",\"NGX\"],[\"NGX\",\"FLL\"],[\"FLL\",\"BYC\"],[\"BYC\",\"SFO\"],[\"SFO\",\"XVS\"],[\"XVS\",\"FUQ\"],[\"FUQ\",\"XBK\"],[\"XBK\",\"DHW\"],[\"DHW\",\"YJO\"],[\"YJO\",\"ODN\"],[\"ODN\",\"XQT\"],[\"XQT\",\"ARH\"],[\"ARH\",\"DTW\"],[\"DTW\",\"MEI\"],[\"MEI\",\"DTW\"],[\"DTW\",\"GPP\"],[\"GPP\",\"WIE\"],[\"WIE\",\"ICJ\"],[\"ICJ\",\"VYX\"],[\"VYX\",\"TLS\"],[\"TLS\",\"NUB\"],[\"NUB\",\"YSM\"],[\"YSM\",\"CSD\"],[\"CSD\",\"CTI\"],[\"CTI\",\"LTU\"],[\"LTU\",\"YAE\"],[\"YAE\",\"KMO\"],[\"KMO\",\"AIT\"],[\"AIT\",\"IWC\"],[\"IWC\",\"OJB\"],[\"OJB\",\"DFV\"],[\"DFV\",\"HSS\"],[\"HSS\",\"EAN\"],[\"EAN\",\"SRT\"],[\"SRT\",\"BUF\"],[\"BUF\",\"EUH\"],[\"EUH\",\"KTE\"],[\"KTE\",\"TPA\"],[\"TPA\",\"SMF\"],[\"SMF\",\"AKP\"],[\"AKP\",\"MMB\"],[\"MMB\",\"TPA\"],[\"TPA\",\"VTO\"],[\"VTO\",\"LBT\"],[\"LBT\",\"GPP\"],[\"GPP\",\"KLO\"],[\"KLO\",\"LAX\"],[\"LAX\",\"MIA\"],[\"MIA\",\"LBT\"],[\"LBT\",\"THM\"],[\"THM\",\"WIB\"],[\"WIB\",\"ORO\"],[\"ORO\",\"IAD\"],[\"IAD\",\"GDP\"],[\"GDP\",\"HMN\"],[\"HMN\",\"CVO\"],[\"CVO\",\"LBT\"],[\"LBT\",\"UGU\"],[\"UGU\",\"HNL\"],[\"HNL\",\"JNQ\"],[\"JNQ\",\"YJO\"],[\"YJO\",\"UGU\"],[\"UGU\",\"ERQ\"],[\"ERQ\",\"XMP\"],[\"XMP\",\"DFF\"],[\"DFF\",\"BWI\"],[\"BWI\",\"MDW\"],[\"MDW\",\"XQT\"],[\"XQT\",\"PBI\"],[\"PBI\",\"IND\"],[\"IND\",\"MJN\"],[\"MJN\",\"SFO\"],[\"SFO\",\"RGS\"],[\"RGS\",\"NVP\"],[\"NVP\",\"LAS\"],[\"LAS\",\"KMO\"],[\"KMO\",\"RSW\"],[\"RSW\",\"HEW\"],[\"HEW\",\"NAT\"],[\"NAT\",\"SJU\"],[\"SJU\",\"FLM\"],[\"FLM\",\"DHL\"],[\"DHL\",\"LPI\"],[\"LPI\",\"QCD\"],[\"QCD\",\"HEW\"],[\"HEW\",\"MFN\"],[\"MFN\",\"YBC\"],[\"YBC\",\"CTX\"],[\"CTX\",\"IWC\"],[\"IWC\",\"BNG\"],[\"BNG\",\"QSH\"],[\"QSH\",\"ANC\"],[\"ANC\",\"EQC\"],[\"EQC\",\"MFN\"],[\"MFN\",\"FBW\"],[\"FBW\",\"NML\"],[\"NML\",\"AUR\"],[\"AUR\",\"LAS\"],[\"LAS\",\"EQC\"],[\"EQC\",\"KKC\"],[\"KKC\",\"LAS\"],[\"LAS\",\"QHN\"],[\"QHN\",\"MDW\"],[\"MDW\",\"KTL\"],[\"KTL\",\"BMQ\"],[\"BMQ\",\"UUH\"],[\"UUH\",\"VTO\"],[\"VTO\",\"CLF\"],[\"CLF\",\"XWB\"],[\"XWB\",\"JWA\"],[\"JWA\",\"STL\"],[\"STL\",\"BPF\"],[\"BPF\",\"MBD\"],[\"MBD\",\"HJT\"],[\"HJT\",\"UYU\"],[\"UYU\",\"HPE\"],[\"HPE\",\"VTO\"],[\"VTO\",\"OJB\"],[\"OJB\",\"SJU\"],[\"SJU\",\"MSY\"],[\"MSY\",\"QWV\"],[\"QWV\",\"OUC\"],[\"OUC\",\"XOY\"],[\"XOY\",\"GPW\"],[\"GPW\",\"OSC\"],[\"OSC\",\"MGL\"],[\"MGL\",\"VRF\"],[\"VRF\",\"XBK\"],[\"XBK\",\"PHL\"],[\"PHL\",\"QAW\"],[\"QAW\",\"YYQ\"],[\"YYQ\",\"BVI\"],[\"BVI\",\"LGA\"],[\"LGA\",\"VLT\"],[\"VLT\",\"UJJ\"],[\"UJJ\",\"BWI\"],[\"BWI\",\"LBT\"],[\"LBT\",\"DTW\"],[\"DTW\",\"MJN\"],[\"MJN\",\"HSS\"],[\"HSS\",\"OHW\"],[\"OHW\",\"BMT\"],[\"BMT\",\"IWC\"],[\"IWC\",\"UJJ\"],[\"UJJ\",\"PDS\"],[\"PDS\",\"EGK\"],[\"EGK\",\"TLS\"],[\"TLS\",\"SIX\"],[\"SIX\",\"AOT\"],[\"AOT\",\"SSH\"],[\"SSH\",\"VGK\"],[\"VGK\",\"JSF\"],[\"JSF\",\"GDP\"],[\"GDP\",\"BOL\"],[\"BOL\",\"JGH\"],[\"JGH\",\"IWC\"],[\"IWC\",\"AOX\"],[\"AOX\",\"FRI\"],[\"FRI\",\"LWV\"],[\"LWV\",\"PDX\"],[\"PDX\",\"STL\"],[\"STL\",\"AIT\"],[\"AIT\",\"CSD\"],[\"CSD\",\"SIX\"],[\"SIX\",\"BUF\"],[\"BUF\",\"VDB\"],[\"VDB\",\"XOY\"],[\"XOY\",\"TBV\"],[\"TBV\",\"BNG\"],[\"BNG\",\"HWF\"],[\"HWF\",\"LPI\"],[\"LPI\",\"JCB\"],[\"JCB\",\"DUI\"],[\"DUI\",\"IIK\"],[\"IIK\",\"YBC\"],[\"YBC\",\"VYX\"],[\"VYX\",\"YNS\"],[\"YNS\",\"BQH\"],[\"BQH\",\"WRM\"],[\"WRM\",\"SCY\"],[\"SCY\",\"DFY\"],[\"DFY\",\"BLC\"],[\"BLC\",\"PHX\"],[\"PHX\",\"DFY\"],[\"DFY\",\"BOS\"],[\"BOS\",\"WIB\"],[\"WIB\",\"SEA\"],[\"SEA\",\"THM\"],[\"THM\",\"TTY\"],[\"TTY\",\"HEW\"],[\"HEW\",\"YSM\"],[\"YSM\",\"BNN\"],[\"BNN\",\"MGY\"],[\"MGY\",\"PAR\"],[\"PAR\",\"IRJ\"],[\"IRJ\",\"VDB\"],[\"VDB\",\"ANC\"],[\"ANC\",\"SAN\"],[\"SAN\",\"RDU\"],[\"RDU\",\"REF\"],[\"REF\",\"BWI\"],[\"BWI\",\"HNL\"],[\"HNL\",\"AAP\"],[\"AAP\",\"CVO\"],[\"CVO\",\"JIR\"],[\"JIR\",\"AIT\"],[\"AIT\",\"NEE\"],[\"NEE\",\"HIN\"],[\"HIN\",\"TPU\"],[\"TPU\",\"AHF\"],[\"AHF\",\"MSY\"],[\"MSY\",\"HFM\"],[\"HFM\",\"ATW\"],[\"ATW\",\"KKC\"],[\"KKC\",\"CFB\"],[\"CFB\",\"HPE\"],[\"HPE\",\"BPF\"],[\"BPF\",\"XWB\"],[\"XWB\",\"XVS\"],[\"XVS\",\"FKN\"],[\"FKN\",\"SMF\"],[\"SMF\",\"AIT\"],[\"AIT\",\"MDW\"],[\"MDW\",\"CRG\"],[\"CRG\",\"VRU\"],[\"VRU\",\"FGD\"],[\"FGD\",\"GJK\"],[\"GJK\",\"WSR\"],[\"WSR\",\"FLM\"],[\"FLM\",\"OFX\"],[\"OFX\",\"GVU\"],[\"GVU\",\"UGU\"],[\"UGU\",\"DFV\"],[\"DFV\",\"DEN\"],[\"DEN\",\"NRE\"],[\"NRE\",\"PDX\"],[\"PDX\",\"CWG\"],[\"CWG\",\"TLS\"],[\"TLS\",\"HSS\"],[\"HSS\",\"BQI\"],[\"BQI\",\"HSB\"],[\"HSB\",\"CGT\"],[\"CGT\",\"OFX\"],[\"OFX\",\"TBV\"],[\"TBV\",\"NAT\"],[\"NAT\",\"JGH\"],[\"JGH\",\"NBP\"],[\"NBP\",\"AIT\"],[\"AIT\",\"AKP\"],[\"AKP\",\"SRT\"],[\"SRT\",\"NBP\"],[\"NBP\",\"JGH\"],[\"JGH\",\"VDB\"],[\"VDB\",\"YXT\"],[\"YXT\",\"CLF\"],[\"CLF\",\"KKC\"],[\"KKC\",\"KLO\"],[\"KLO\",\"BWT\"],[\"BWT\",\"LBT\"],[\"LBT\",\"ODN\"],[\"ODN\",\"SMF\"],[\"SMF\",\"GHP\"],[\"GHP\",\"BQI\"],[\"BQI\",\"EXD\"],[\"EXD\",\"ODN\"],[\"ODN\",\"BWT\"],[\"BWT\",\"PDX\"],[\"PDX\",\"IRU\"],[\"IRU\",\"SMJ\"],[\"SMJ\",\"UBB\"],[\"UBB\",\"SIX\"],[\"SIX\",\"XVS\"],[\"XVS\",\"ATW\"],[\"ATW\",\"AAP\"],[\"AAP\",\"RDU\"],[\"RDU\",\"TBV\"],[\"TBV\",\"JCB\"],[\"JCB\",\"TBV\"],[\"TBV\",\"IWC\"],[\"IWC\",\"VTO\"]]\n```\n![image](https://github.com/mquintus/l33tcode-reload/assets/515945/2e6b511e-d801-4f2f-a232-61793fc892c6)"
                    },
                    {
                        "username": "chrisblueeyes",
                        "content": "lol this was a sample google interview question... this brilliant high schooler solved it!! using graphs, heres the video, no code just the theory\n\nhttps://www.youtube.com/watch?v=qz9tKlF431k"
                    },
                    {
                        "username": "realitant",
                        "content": "I think it's worthwhile to explicitly state if the tickets are unique or not.\nEDIT: To anyone else wondering, the tickets are not necessarily unique"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Note- There can be multiple same direction tickets between 2 cities."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Today\\'s question was easy \\uD83E\\uDEE1\\uD83E\\uDEE1\\n\\nhttps://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    }
                ]
            },
            {
                "id": 2057851,
                "content": [
                    {
                        "username": "Shivam_verma24",
                        "content": "Medium level sorting + DFS problem tagged hard"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "What is going on with this testcase?\n`tickets = [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]`\n\nMy output:\n`[\"ATL\",\"JFK\",\"ATL\"]`\n\nExpected:\n`[\"JFK\",\"ATL\",\"JFK\"]`\n\nEdit: I missed that you always start at JFK."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hints in increasing levels of spoilers: (Hints for this question are kind of hard to do unfortunately)\\n\\n1) Actually this is the biggest spoiler, but tbh I would just read the wikipedia page on Eulerian Paths. \\n\\n2) If you tried to construct a path and then failed because you didn\\'t hit every single node, is all of the work you did for nothing? Do you need to restart? or can you reuse the result you got somehow? \\nIs there any structure to the part you missed? "
                    },
                    {
                        "username": "z3eg",
                        "content": "and there goes my third hard problems solved completely by myself. ~300 lines of code and several hours of time and here we go! don\\'t give up, guys, this one doesnt seem to require some special approach, i solved it with a very very common one (surprisingly lol)"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This is a fun problem.  Here are a couple hints if you are stuck:\\n\\n* solving the lexical ordering problem first will increase the efficiency and ease of finding the final solution.\\n\\n* The relatively small amount of tickets opens up a solution method that could be extremely consumptive on large data sets. 1 <= tickets.length <= 300\\n\\nGood Luck!"
                    },
                    {
                        "username": "mstuebs",
                        "content": "I have found that for this challenge the leetcode solution might crash. I got a TLE for empty code for this testcase:\n```\n[[\"JFK\",\"KLO\"],[\"KLO\",\"VRU\"],[\"VRU\",\"JFK\"],[\"JFK\",\"IWC\"],[\"IWC\",\"EXD\"],[\"EXD\",\"VMC\"],[\"VMC\",\"EWR\"],[\"EWR\",\"PDS\"],[\"PDS\",\"PIT\"],[\"PIT\",\"YSM\"],[\"YSM\",\"HKO\"],[\"HKO\",\"RSW\"],[\"RSW\",\"HFM\"],[\"HFM\",\"HMN\"],[\"HMN\",\"IEM\"],[\"IEM\",\"MED\"],[\"MED\",\"NGX\"],[\"NGX\",\"FLL\"],[\"FLL\",\"BYC\"],[\"BYC\",\"SFO\"],[\"SFO\",\"XVS\"],[\"XVS\",\"FUQ\"],[\"FUQ\",\"XBK\"],[\"XBK\",\"DHW\"],[\"DHW\",\"YJO\"],[\"YJO\",\"ODN\"],[\"ODN\",\"XQT\"],[\"XQT\",\"ARH\"],[\"ARH\",\"DTW\"],[\"DTW\",\"MEI\"],[\"MEI\",\"DTW\"],[\"DTW\",\"GPP\"],[\"GPP\",\"WIE\"],[\"WIE\",\"ICJ\"],[\"ICJ\",\"VYX\"],[\"VYX\",\"TLS\"],[\"TLS\",\"NUB\"],[\"NUB\",\"YSM\"],[\"YSM\",\"CSD\"],[\"CSD\",\"CTI\"],[\"CTI\",\"LTU\"],[\"LTU\",\"YAE\"],[\"YAE\",\"KMO\"],[\"KMO\",\"AIT\"],[\"AIT\",\"IWC\"],[\"IWC\",\"OJB\"],[\"OJB\",\"DFV\"],[\"DFV\",\"HSS\"],[\"HSS\",\"EAN\"],[\"EAN\",\"SRT\"],[\"SRT\",\"BUF\"],[\"BUF\",\"EUH\"],[\"EUH\",\"KTE\"],[\"KTE\",\"TPA\"],[\"TPA\",\"SMF\"],[\"SMF\",\"AKP\"],[\"AKP\",\"MMB\"],[\"MMB\",\"TPA\"],[\"TPA\",\"VTO\"],[\"VTO\",\"LBT\"],[\"LBT\",\"GPP\"],[\"GPP\",\"KLO\"],[\"KLO\",\"LAX\"],[\"LAX\",\"MIA\"],[\"MIA\",\"LBT\"],[\"LBT\",\"THM\"],[\"THM\",\"WIB\"],[\"WIB\",\"ORO\"],[\"ORO\",\"IAD\"],[\"IAD\",\"GDP\"],[\"GDP\",\"HMN\"],[\"HMN\",\"CVO\"],[\"CVO\",\"LBT\"],[\"LBT\",\"UGU\"],[\"UGU\",\"HNL\"],[\"HNL\",\"JNQ\"],[\"JNQ\",\"YJO\"],[\"YJO\",\"UGU\"],[\"UGU\",\"ERQ\"],[\"ERQ\",\"XMP\"],[\"XMP\",\"DFF\"],[\"DFF\",\"BWI\"],[\"BWI\",\"MDW\"],[\"MDW\",\"XQT\"],[\"XQT\",\"PBI\"],[\"PBI\",\"IND\"],[\"IND\",\"MJN\"],[\"MJN\",\"SFO\"],[\"SFO\",\"RGS\"],[\"RGS\",\"NVP\"],[\"NVP\",\"LAS\"],[\"LAS\",\"KMO\"],[\"KMO\",\"RSW\"],[\"RSW\",\"HEW\"],[\"HEW\",\"NAT\"],[\"NAT\",\"SJU\"],[\"SJU\",\"FLM\"],[\"FLM\",\"DHL\"],[\"DHL\",\"LPI\"],[\"LPI\",\"QCD\"],[\"QCD\",\"HEW\"],[\"HEW\",\"MFN\"],[\"MFN\",\"YBC\"],[\"YBC\",\"CTX\"],[\"CTX\",\"IWC\"],[\"IWC\",\"BNG\"],[\"BNG\",\"QSH\"],[\"QSH\",\"ANC\"],[\"ANC\",\"EQC\"],[\"EQC\",\"MFN\"],[\"MFN\",\"FBW\"],[\"FBW\",\"NML\"],[\"NML\",\"AUR\"],[\"AUR\",\"LAS\"],[\"LAS\",\"EQC\"],[\"EQC\",\"KKC\"],[\"KKC\",\"LAS\"],[\"LAS\",\"QHN\"],[\"QHN\",\"MDW\"],[\"MDW\",\"KTL\"],[\"KTL\",\"BMQ\"],[\"BMQ\",\"UUH\"],[\"UUH\",\"VTO\"],[\"VTO\",\"CLF\"],[\"CLF\",\"XWB\"],[\"XWB\",\"JWA\"],[\"JWA\",\"STL\"],[\"STL\",\"BPF\"],[\"BPF\",\"MBD\"],[\"MBD\",\"HJT\"],[\"HJT\",\"UYU\"],[\"UYU\",\"HPE\"],[\"HPE\",\"VTO\"],[\"VTO\",\"OJB\"],[\"OJB\",\"SJU\"],[\"SJU\",\"MSY\"],[\"MSY\",\"QWV\"],[\"QWV\",\"OUC\"],[\"OUC\",\"XOY\"],[\"XOY\",\"GPW\"],[\"GPW\",\"OSC\"],[\"OSC\",\"MGL\"],[\"MGL\",\"VRF\"],[\"VRF\",\"XBK\"],[\"XBK\",\"PHL\"],[\"PHL\",\"QAW\"],[\"QAW\",\"YYQ\"],[\"YYQ\",\"BVI\"],[\"BVI\",\"LGA\"],[\"LGA\",\"VLT\"],[\"VLT\",\"UJJ\"],[\"UJJ\",\"BWI\"],[\"BWI\",\"LBT\"],[\"LBT\",\"DTW\"],[\"DTW\",\"MJN\"],[\"MJN\",\"HSS\"],[\"HSS\",\"OHW\"],[\"OHW\",\"BMT\"],[\"BMT\",\"IWC\"],[\"IWC\",\"UJJ\"],[\"UJJ\",\"PDS\"],[\"PDS\",\"EGK\"],[\"EGK\",\"TLS\"],[\"TLS\",\"SIX\"],[\"SIX\",\"AOT\"],[\"AOT\",\"SSH\"],[\"SSH\",\"VGK\"],[\"VGK\",\"JSF\"],[\"JSF\",\"GDP\"],[\"GDP\",\"BOL\"],[\"BOL\",\"JGH\"],[\"JGH\",\"IWC\"],[\"IWC\",\"AOX\"],[\"AOX\",\"FRI\"],[\"FRI\",\"LWV\"],[\"LWV\",\"PDX\"],[\"PDX\",\"STL\"],[\"STL\",\"AIT\"],[\"AIT\",\"CSD\"],[\"CSD\",\"SIX\"],[\"SIX\",\"BUF\"],[\"BUF\",\"VDB\"],[\"VDB\",\"XOY\"],[\"XOY\",\"TBV\"],[\"TBV\",\"BNG\"],[\"BNG\",\"HWF\"],[\"HWF\",\"LPI\"],[\"LPI\",\"JCB\"],[\"JCB\",\"DUI\"],[\"DUI\",\"IIK\"],[\"IIK\",\"YBC\"],[\"YBC\",\"VYX\"],[\"VYX\",\"YNS\"],[\"YNS\",\"BQH\"],[\"BQH\",\"WRM\"],[\"WRM\",\"SCY\"],[\"SCY\",\"DFY\"],[\"DFY\",\"BLC\"],[\"BLC\",\"PHX\"],[\"PHX\",\"DFY\"],[\"DFY\",\"BOS\"],[\"BOS\",\"WIB\"],[\"WIB\",\"SEA\"],[\"SEA\",\"THM\"],[\"THM\",\"TTY\"],[\"TTY\",\"HEW\"],[\"HEW\",\"YSM\"],[\"YSM\",\"BNN\"],[\"BNN\",\"MGY\"],[\"MGY\",\"PAR\"],[\"PAR\",\"IRJ\"],[\"IRJ\",\"VDB\"],[\"VDB\",\"ANC\"],[\"ANC\",\"SAN\"],[\"SAN\",\"RDU\"],[\"RDU\",\"REF\"],[\"REF\",\"BWI\"],[\"BWI\",\"HNL\"],[\"HNL\",\"AAP\"],[\"AAP\",\"CVO\"],[\"CVO\",\"JIR\"],[\"JIR\",\"AIT\"],[\"AIT\",\"NEE\"],[\"NEE\",\"HIN\"],[\"HIN\",\"TPU\"],[\"TPU\",\"AHF\"],[\"AHF\",\"MSY\"],[\"MSY\",\"HFM\"],[\"HFM\",\"ATW\"],[\"ATW\",\"KKC\"],[\"KKC\",\"CFB\"],[\"CFB\",\"HPE\"],[\"HPE\",\"BPF\"],[\"BPF\",\"XWB\"],[\"XWB\",\"XVS\"],[\"XVS\",\"FKN\"],[\"FKN\",\"SMF\"],[\"SMF\",\"AIT\"],[\"AIT\",\"MDW\"],[\"MDW\",\"CRG\"],[\"CRG\",\"VRU\"],[\"VRU\",\"FGD\"],[\"FGD\",\"GJK\"],[\"GJK\",\"WSR\"],[\"WSR\",\"FLM\"],[\"FLM\",\"OFX\"],[\"OFX\",\"GVU\"],[\"GVU\",\"UGU\"],[\"UGU\",\"DFV\"],[\"DFV\",\"DEN\"],[\"DEN\",\"NRE\"],[\"NRE\",\"PDX\"],[\"PDX\",\"CWG\"],[\"CWG\",\"TLS\"],[\"TLS\",\"HSS\"],[\"HSS\",\"BQI\"],[\"BQI\",\"HSB\"],[\"HSB\",\"CGT\"],[\"CGT\",\"OFX\"],[\"OFX\",\"TBV\"],[\"TBV\",\"NAT\"],[\"NAT\",\"JGH\"],[\"JGH\",\"NBP\"],[\"NBP\",\"AIT\"],[\"AIT\",\"AKP\"],[\"AKP\",\"SRT\"],[\"SRT\",\"NBP\"],[\"NBP\",\"JGH\"],[\"JGH\",\"VDB\"],[\"VDB\",\"YXT\"],[\"YXT\",\"CLF\"],[\"CLF\",\"KKC\"],[\"KKC\",\"KLO\"],[\"KLO\",\"BWT\"],[\"BWT\",\"LBT\"],[\"LBT\",\"ODN\"],[\"ODN\",\"SMF\"],[\"SMF\",\"GHP\"],[\"GHP\",\"BQI\"],[\"BQI\",\"EXD\"],[\"EXD\",\"ODN\"],[\"ODN\",\"BWT\"],[\"BWT\",\"PDX\"],[\"PDX\",\"IRU\"],[\"IRU\",\"SMJ\"],[\"SMJ\",\"UBB\"],[\"UBB\",\"SIX\"],[\"SIX\",\"XVS\"],[\"XVS\",\"ATW\"],[\"ATW\",\"AAP\"],[\"AAP\",\"RDU\"],[\"RDU\",\"TBV\"],[\"TBV\",\"JCB\"],[\"JCB\",\"TBV\"],[\"TBV\",\"IWC\"],[\"IWC\",\"VTO\"]]\n```\n![image](https://github.com/mquintus/l33tcode-reload/assets/515945/2e6b511e-d801-4f2f-a232-61793fc892c6)"
                    },
                    {
                        "username": "chrisblueeyes",
                        "content": "lol this was a sample google interview question... this brilliant high schooler solved it!! using graphs, heres the video, no code just the theory\n\nhttps://www.youtube.com/watch?v=qz9tKlF431k"
                    },
                    {
                        "username": "realitant",
                        "content": "I think it's worthwhile to explicitly state if the tickets are unique or not.\nEDIT: To anyone else wondering, the tickets are not necessarily unique"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Note- There can be multiple same direction tickets between 2 cities."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Today\\'s question was easy \\uD83E\\uDEE1\\uD83E\\uDEE1\\n\\nhttps://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    }
                ]
            },
            {
                "id": 2057800,
                "content": [
                    {
                        "username": "Shivam_verma24",
                        "content": "Medium level sorting + DFS problem tagged hard"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "What is going on with this testcase?\n`tickets = [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]`\n\nMy output:\n`[\"ATL\",\"JFK\",\"ATL\"]`\n\nExpected:\n`[\"JFK\",\"ATL\",\"JFK\"]`\n\nEdit: I missed that you always start at JFK."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hints in increasing levels of spoilers: (Hints for this question are kind of hard to do unfortunately)\\n\\n1) Actually this is the biggest spoiler, but tbh I would just read the wikipedia page on Eulerian Paths. \\n\\n2) If you tried to construct a path and then failed because you didn\\'t hit every single node, is all of the work you did for nothing? Do you need to restart? or can you reuse the result you got somehow? \\nIs there any structure to the part you missed? "
                    },
                    {
                        "username": "z3eg",
                        "content": "and there goes my third hard problems solved completely by myself. ~300 lines of code and several hours of time and here we go! don\\'t give up, guys, this one doesnt seem to require some special approach, i solved it with a very very common one (surprisingly lol)"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This is a fun problem.  Here are a couple hints if you are stuck:\\n\\n* solving the lexical ordering problem first will increase the efficiency and ease of finding the final solution.\\n\\n* The relatively small amount of tickets opens up a solution method that could be extremely consumptive on large data sets. 1 <= tickets.length <= 300\\n\\nGood Luck!"
                    },
                    {
                        "username": "mstuebs",
                        "content": "I have found that for this challenge the leetcode solution might crash. I got a TLE for empty code for this testcase:\n```\n[[\"JFK\",\"KLO\"],[\"KLO\",\"VRU\"],[\"VRU\",\"JFK\"],[\"JFK\",\"IWC\"],[\"IWC\",\"EXD\"],[\"EXD\",\"VMC\"],[\"VMC\",\"EWR\"],[\"EWR\",\"PDS\"],[\"PDS\",\"PIT\"],[\"PIT\",\"YSM\"],[\"YSM\",\"HKO\"],[\"HKO\",\"RSW\"],[\"RSW\",\"HFM\"],[\"HFM\",\"HMN\"],[\"HMN\",\"IEM\"],[\"IEM\",\"MED\"],[\"MED\",\"NGX\"],[\"NGX\",\"FLL\"],[\"FLL\",\"BYC\"],[\"BYC\",\"SFO\"],[\"SFO\",\"XVS\"],[\"XVS\",\"FUQ\"],[\"FUQ\",\"XBK\"],[\"XBK\",\"DHW\"],[\"DHW\",\"YJO\"],[\"YJO\",\"ODN\"],[\"ODN\",\"XQT\"],[\"XQT\",\"ARH\"],[\"ARH\",\"DTW\"],[\"DTW\",\"MEI\"],[\"MEI\",\"DTW\"],[\"DTW\",\"GPP\"],[\"GPP\",\"WIE\"],[\"WIE\",\"ICJ\"],[\"ICJ\",\"VYX\"],[\"VYX\",\"TLS\"],[\"TLS\",\"NUB\"],[\"NUB\",\"YSM\"],[\"YSM\",\"CSD\"],[\"CSD\",\"CTI\"],[\"CTI\",\"LTU\"],[\"LTU\",\"YAE\"],[\"YAE\",\"KMO\"],[\"KMO\",\"AIT\"],[\"AIT\",\"IWC\"],[\"IWC\",\"OJB\"],[\"OJB\",\"DFV\"],[\"DFV\",\"HSS\"],[\"HSS\",\"EAN\"],[\"EAN\",\"SRT\"],[\"SRT\",\"BUF\"],[\"BUF\",\"EUH\"],[\"EUH\",\"KTE\"],[\"KTE\",\"TPA\"],[\"TPA\",\"SMF\"],[\"SMF\",\"AKP\"],[\"AKP\",\"MMB\"],[\"MMB\",\"TPA\"],[\"TPA\",\"VTO\"],[\"VTO\",\"LBT\"],[\"LBT\",\"GPP\"],[\"GPP\",\"KLO\"],[\"KLO\",\"LAX\"],[\"LAX\",\"MIA\"],[\"MIA\",\"LBT\"],[\"LBT\",\"THM\"],[\"THM\",\"WIB\"],[\"WIB\",\"ORO\"],[\"ORO\",\"IAD\"],[\"IAD\",\"GDP\"],[\"GDP\",\"HMN\"],[\"HMN\",\"CVO\"],[\"CVO\",\"LBT\"],[\"LBT\",\"UGU\"],[\"UGU\",\"HNL\"],[\"HNL\",\"JNQ\"],[\"JNQ\",\"YJO\"],[\"YJO\",\"UGU\"],[\"UGU\",\"ERQ\"],[\"ERQ\",\"XMP\"],[\"XMP\",\"DFF\"],[\"DFF\",\"BWI\"],[\"BWI\",\"MDW\"],[\"MDW\",\"XQT\"],[\"XQT\",\"PBI\"],[\"PBI\",\"IND\"],[\"IND\",\"MJN\"],[\"MJN\",\"SFO\"],[\"SFO\",\"RGS\"],[\"RGS\",\"NVP\"],[\"NVP\",\"LAS\"],[\"LAS\",\"KMO\"],[\"KMO\",\"RSW\"],[\"RSW\",\"HEW\"],[\"HEW\",\"NAT\"],[\"NAT\",\"SJU\"],[\"SJU\",\"FLM\"],[\"FLM\",\"DHL\"],[\"DHL\",\"LPI\"],[\"LPI\",\"QCD\"],[\"QCD\",\"HEW\"],[\"HEW\",\"MFN\"],[\"MFN\",\"YBC\"],[\"YBC\",\"CTX\"],[\"CTX\",\"IWC\"],[\"IWC\",\"BNG\"],[\"BNG\",\"QSH\"],[\"QSH\",\"ANC\"],[\"ANC\",\"EQC\"],[\"EQC\",\"MFN\"],[\"MFN\",\"FBW\"],[\"FBW\",\"NML\"],[\"NML\",\"AUR\"],[\"AUR\",\"LAS\"],[\"LAS\",\"EQC\"],[\"EQC\",\"KKC\"],[\"KKC\",\"LAS\"],[\"LAS\",\"QHN\"],[\"QHN\",\"MDW\"],[\"MDW\",\"KTL\"],[\"KTL\",\"BMQ\"],[\"BMQ\",\"UUH\"],[\"UUH\",\"VTO\"],[\"VTO\",\"CLF\"],[\"CLF\",\"XWB\"],[\"XWB\",\"JWA\"],[\"JWA\",\"STL\"],[\"STL\",\"BPF\"],[\"BPF\",\"MBD\"],[\"MBD\",\"HJT\"],[\"HJT\",\"UYU\"],[\"UYU\",\"HPE\"],[\"HPE\",\"VTO\"],[\"VTO\",\"OJB\"],[\"OJB\",\"SJU\"],[\"SJU\",\"MSY\"],[\"MSY\",\"QWV\"],[\"QWV\",\"OUC\"],[\"OUC\",\"XOY\"],[\"XOY\",\"GPW\"],[\"GPW\",\"OSC\"],[\"OSC\",\"MGL\"],[\"MGL\",\"VRF\"],[\"VRF\",\"XBK\"],[\"XBK\",\"PHL\"],[\"PHL\",\"QAW\"],[\"QAW\",\"YYQ\"],[\"YYQ\",\"BVI\"],[\"BVI\",\"LGA\"],[\"LGA\",\"VLT\"],[\"VLT\",\"UJJ\"],[\"UJJ\",\"BWI\"],[\"BWI\",\"LBT\"],[\"LBT\",\"DTW\"],[\"DTW\",\"MJN\"],[\"MJN\",\"HSS\"],[\"HSS\",\"OHW\"],[\"OHW\",\"BMT\"],[\"BMT\",\"IWC\"],[\"IWC\",\"UJJ\"],[\"UJJ\",\"PDS\"],[\"PDS\",\"EGK\"],[\"EGK\",\"TLS\"],[\"TLS\",\"SIX\"],[\"SIX\",\"AOT\"],[\"AOT\",\"SSH\"],[\"SSH\",\"VGK\"],[\"VGK\",\"JSF\"],[\"JSF\",\"GDP\"],[\"GDP\",\"BOL\"],[\"BOL\",\"JGH\"],[\"JGH\",\"IWC\"],[\"IWC\",\"AOX\"],[\"AOX\",\"FRI\"],[\"FRI\",\"LWV\"],[\"LWV\",\"PDX\"],[\"PDX\",\"STL\"],[\"STL\",\"AIT\"],[\"AIT\",\"CSD\"],[\"CSD\",\"SIX\"],[\"SIX\",\"BUF\"],[\"BUF\",\"VDB\"],[\"VDB\",\"XOY\"],[\"XOY\",\"TBV\"],[\"TBV\",\"BNG\"],[\"BNG\",\"HWF\"],[\"HWF\",\"LPI\"],[\"LPI\",\"JCB\"],[\"JCB\",\"DUI\"],[\"DUI\",\"IIK\"],[\"IIK\",\"YBC\"],[\"YBC\",\"VYX\"],[\"VYX\",\"YNS\"],[\"YNS\",\"BQH\"],[\"BQH\",\"WRM\"],[\"WRM\",\"SCY\"],[\"SCY\",\"DFY\"],[\"DFY\",\"BLC\"],[\"BLC\",\"PHX\"],[\"PHX\",\"DFY\"],[\"DFY\",\"BOS\"],[\"BOS\",\"WIB\"],[\"WIB\",\"SEA\"],[\"SEA\",\"THM\"],[\"THM\",\"TTY\"],[\"TTY\",\"HEW\"],[\"HEW\",\"YSM\"],[\"YSM\",\"BNN\"],[\"BNN\",\"MGY\"],[\"MGY\",\"PAR\"],[\"PAR\",\"IRJ\"],[\"IRJ\",\"VDB\"],[\"VDB\",\"ANC\"],[\"ANC\",\"SAN\"],[\"SAN\",\"RDU\"],[\"RDU\",\"REF\"],[\"REF\",\"BWI\"],[\"BWI\",\"HNL\"],[\"HNL\",\"AAP\"],[\"AAP\",\"CVO\"],[\"CVO\",\"JIR\"],[\"JIR\",\"AIT\"],[\"AIT\",\"NEE\"],[\"NEE\",\"HIN\"],[\"HIN\",\"TPU\"],[\"TPU\",\"AHF\"],[\"AHF\",\"MSY\"],[\"MSY\",\"HFM\"],[\"HFM\",\"ATW\"],[\"ATW\",\"KKC\"],[\"KKC\",\"CFB\"],[\"CFB\",\"HPE\"],[\"HPE\",\"BPF\"],[\"BPF\",\"XWB\"],[\"XWB\",\"XVS\"],[\"XVS\",\"FKN\"],[\"FKN\",\"SMF\"],[\"SMF\",\"AIT\"],[\"AIT\",\"MDW\"],[\"MDW\",\"CRG\"],[\"CRG\",\"VRU\"],[\"VRU\",\"FGD\"],[\"FGD\",\"GJK\"],[\"GJK\",\"WSR\"],[\"WSR\",\"FLM\"],[\"FLM\",\"OFX\"],[\"OFX\",\"GVU\"],[\"GVU\",\"UGU\"],[\"UGU\",\"DFV\"],[\"DFV\",\"DEN\"],[\"DEN\",\"NRE\"],[\"NRE\",\"PDX\"],[\"PDX\",\"CWG\"],[\"CWG\",\"TLS\"],[\"TLS\",\"HSS\"],[\"HSS\",\"BQI\"],[\"BQI\",\"HSB\"],[\"HSB\",\"CGT\"],[\"CGT\",\"OFX\"],[\"OFX\",\"TBV\"],[\"TBV\",\"NAT\"],[\"NAT\",\"JGH\"],[\"JGH\",\"NBP\"],[\"NBP\",\"AIT\"],[\"AIT\",\"AKP\"],[\"AKP\",\"SRT\"],[\"SRT\",\"NBP\"],[\"NBP\",\"JGH\"],[\"JGH\",\"VDB\"],[\"VDB\",\"YXT\"],[\"YXT\",\"CLF\"],[\"CLF\",\"KKC\"],[\"KKC\",\"KLO\"],[\"KLO\",\"BWT\"],[\"BWT\",\"LBT\"],[\"LBT\",\"ODN\"],[\"ODN\",\"SMF\"],[\"SMF\",\"GHP\"],[\"GHP\",\"BQI\"],[\"BQI\",\"EXD\"],[\"EXD\",\"ODN\"],[\"ODN\",\"BWT\"],[\"BWT\",\"PDX\"],[\"PDX\",\"IRU\"],[\"IRU\",\"SMJ\"],[\"SMJ\",\"UBB\"],[\"UBB\",\"SIX\"],[\"SIX\",\"XVS\"],[\"XVS\",\"ATW\"],[\"ATW\",\"AAP\"],[\"AAP\",\"RDU\"],[\"RDU\",\"TBV\"],[\"TBV\",\"JCB\"],[\"JCB\",\"TBV\"],[\"TBV\",\"IWC\"],[\"IWC\",\"VTO\"]]\n```\n![image](https://github.com/mquintus/l33tcode-reload/assets/515945/2e6b511e-d801-4f2f-a232-61793fc892c6)"
                    },
                    {
                        "username": "chrisblueeyes",
                        "content": "lol this was a sample google interview question... this brilliant high schooler solved it!! using graphs, heres the video, no code just the theory\n\nhttps://www.youtube.com/watch?v=qz9tKlF431k"
                    },
                    {
                        "username": "realitant",
                        "content": "I think it's worthwhile to explicitly state if the tickets are unique or not.\nEDIT: To anyone else wondering, the tickets are not necessarily unique"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Note- There can be multiple same direction tickets between 2 cities."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Today\\'s question was easy \\uD83E\\uDEE1\\uD83E\\uDEE1\\n\\nhttps://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    }
                ]
            },
            {
                "id": 2057771,
                "content": [
                    {
                        "username": "Shivam_verma24",
                        "content": "Medium level sorting + DFS problem tagged hard"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "What is going on with this testcase?\n`tickets = [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]`\n\nMy output:\n`[\"ATL\",\"JFK\",\"ATL\"]`\n\nExpected:\n`[\"JFK\",\"ATL\",\"JFK\"]`\n\nEdit: I missed that you always start at JFK."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hints in increasing levels of spoilers: (Hints for this question are kind of hard to do unfortunately)\\n\\n1) Actually this is the biggest spoiler, but tbh I would just read the wikipedia page on Eulerian Paths. \\n\\n2) If you tried to construct a path and then failed because you didn\\'t hit every single node, is all of the work you did for nothing? Do you need to restart? or can you reuse the result you got somehow? \\nIs there any structure to the part you missed? "
                    },
                    {
                        "username": "z3eg",
                        "content": "and there goes my third hard problems solved completely by myself. ~300 lines of code and several hours of time and here we go! don\\'t give up, guys, this one doesnt seem to require some special approach, i solved it with a very very common one (surprisingly lol)"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This is a fun problem.  Here are a couple hints if you are stuck:\\n\\n* solving the lexical ordering problem first will increase the efficiency and ease of finding the final solution.\\n\\n* The relatively small amount of tickets opens up a solution method that could be extremely consumptive on large data sets. 1 <= tickets.length <= 300\\n\\nGood Luck!"
                    },
                    {
                        "username": "mstuebs",
                        "content": "I have found that for this challenge the leetcode solution might crash. I got a TLE for empty code for this testcase:\n```\n[[\"JFK\",\"KLO\"],[\"KLO\",\"VRU\"],[\"VRU\",\"JFK\"],[\"JFK\",\"IWC\"],[\"IWC\",\"EXD\"],[\"EXD\",\"VMC\"],[\"VMC\",\"EWR\"],[\"EWR\",\"PDS\"],[\"PDS\",\"PIT\"],[\"PIT\",\"YSM\"],[\"YSM\",\"HKO\"],[\"HKO\",\"RSW\"],[\"RSW\",\"HFM\"],[\"HFM\",\"HMN\"],[\"HMN\",\"IEM\"],[\"IEM\",\"MED\"],[\"MED\",\"NGX\"],[\"NGX\",\"FLL\"],[\"FLL\",\"BYC\"],[\"BYC\",\"SFO\"],[\"SFO\",\"XVS\"],[\"XVS\",\"FUQ\"],[\"FUQ\",\"XBK\"],[\"XBK\",\"DHW\"],[\"DHW\",\"YJO\"],[\"YJO\",\"ODN\"],[\"ODN\",\"XQT\"],[\"XQT\",\"ARH\"],[\"ARH\",\"DTW\"],[\"DTW\",\"MEI\"],[\"MEI\",\"DTW\"],[\"DTW\",\"GPP\"],[\"GPP\",\"WIE\"],[\"WIE\",\"ICJ\"],[\"ICJ\",\"VYX\"],[\"VYX\",\"TLS\"],[\"TLS\",\"NUB\"],[\"NUB\",\"YSM\"],[\"YSM\",\"CSD\"],[\"CSD\",\"CTI\"],[\"CTI\",\"LTU\"],[\"LTU\",\"YAE\"],[\"YAE\",\"KMO\"],[\"KMO\",\"AIT\"],[\"AIT\",\"IWC\"],[\"IWC\",\"OJB\"],[\"OJB\",\"DFV\"],[\"DFV\",\"HSS\"],[\"HSS\",\"EAN\"],[\"EAN\",\"SRT\"],[\"SRT\",\"BUF\"],[\"BUF\",\"EUH\"],[\"EUH\",\"KTE\"],[\"KTE\",\"TPA\"],[\"TPA\",\"SMF\"],[\"SMF\",\"AKP\"],[\"AKP\",\"MMB\"],[\"MMB\",\"TPA\"],[\"TPA\",\"VTO\"],[\"VTO\",\"LBT\"],[\"LBT\",\"GPP\"],[\"GPP\",\"KLO\"],[\"KLO\",\"LAX\"],[\"LAX\",\"MIA\"],[\"MIA\",\"LBT\"],[\"LBT\",\"THM\"],[\"THM\",\"WIB\"],[\"WIB\",\"ORO\"],[\"ORO\",\"IAD\"],[\"IAD\",\"GDP\"],[\"GDP\",\"HMN\"],[\"HMN\",\"CVO\"],[\"CVO\",\"LBT\"],[\"LBT\",\"UGU\"],[\"UGU\",\"HNL\"],[\"HNL\",\"JNQ\"],[\"JNQ\",\"YJO\"],[\"YJO\",\"UGU\"],[\"UGU\",\"ERQ\"],[\"ERQ\",\"XMP\"],[\"XMP\",\"DFF\"],[\"DFF\",\"BWI\"],[\"BWI\",\"MDW\"],[\"MDW\",\"XQT\"],[\"XQT\",\"PBI\"],[\"PBI\",\"IND\"],[\"IND\",\"MJN\"],[\"MJN\",\"SFO\"],[\"SFO\",\"RGS\"],[\"RGS\",\"NVP\"],[\"NVP\",\"LAS\"],[\"LAS\",\"KMO\"],[\"KMO\",\"RSW\"],[\"RSW\",\"HEW\"],[\"HEW\",\"NAT\"],[\"NAT\",\"SJU\"],[\"SJU\",\"FLM\"],[\"FLM\",\"DHL\"],[\"DHL\",\"LPI\"],[\"LPI\",\"QCD\"],[\"QCD\",\"HEW\"],[\"HEW\",\"MFN\"],[\"MFN\",\"YBC\"],[\"YBC\",\"CTX\"],[\"CTX\",\"IWC\"],[\"IWC\",\"BNG\"],[\"BNG\",\"QSH\"],[\"QSH\",\"ANC\"],[\"ANC\",\"EQC\"],[\"EQC\",\"MFN\"],[\"MFN\",\"FBW\"],[\"FBW\",\"NML\"],[\"NML\",\"AUR\"],[\"AUR\",\"LAS\"],[\"LAS\",\"EQC\"],[\"EQC\",\"KKC\"],[\"KKC\",\"LAS\"],[\"LAS\",\"QHN\"],[\"QHN\",\"MDW\"],[\"MDW\",\"KTL\"],[\"KTL\",\"BMQ\"],[\"BMQ\",\"UUH\"],[\"UUH\",\"VTO\"],[\"VTO\",\"CLF\"],[\"CLF\",\"XWB\"],[\"XWB\",\"JWA\"],[\"JWA\",\"STL\"],[\"STL\",\"BPF\"],[\"BPF\",\"MBD\"],[\"MBD\",\"HJT\"],[\"HJT\",\"UYU\"],[\"UYU\",\"HPE\"],[\"HPE\",\"VTO\"],[\"VTO\",\"OJB\"],[\"OJB\",\"SJU\"],[\"SJU\",\"MSY\"],[\"MSY\",\"QWV\"],[\"QWV\",\"OUC\"],[\"OUC\",\"XOY\"],[\"XOY\",\"GPW\"],[\"GPW\",\"OSC\"],[\"OSC\",\"MGL\"],[\"MGL\",\"VRF\"],[\"VRF\",\"XBK\"],[\"XBK\",\"PHL\"],[\"PHL\",\"QAW\"],[\"QAW\",\"YYQ\"],[\"YYQ\",\"BVI\"],[\"BVI\",\"LGA\"],[\"LGA\",\"VLT\"],[\"VLT\",\"UJJ\"],[\"UJJ\",\"BWI\"],[\"BWI\",\"LBT\"],[\"LBT\",\"DTW\"],[\"DTW\",\"MJN\"],[\"MJN\",\"HSS\"],[\"HSS\",\"OHW\"],[\"OHW\",\"BMT\"],[\"BMT\",\"IWC\"],[\"IWC\",\"UJJ\"],[\"UJJ\",\"PDS\"],[\"PDS\",\"EGK\"],[\"EGK\",\"TLS\"],[\"TLS\",\"SIX\"],[\"SIX\",\"AOT\"],[\"AOT\",\"SSH\"],[\"SSH\",\"VGK\"],[\"VGK\",\"JSF\"],[\"JSF\",\"GDP\"],[\"GDP\",\"BOL\"],[\"BOL\",\"JGH\"],[\"JGH\",\"IWC\"],[\"IWC\",\"AOX\"],[\"AOX\",\"FRI\"],[\"FRI\",\"LWV\"],[\"LWV\",\"PDX\"],[\"PDX\",\"STL\"],[\"STL\",\"AIT\"],[\"AIT\",\"CSD\"],[\"CSD\",\"SIX\"],[\"SIX\",\"BUF\"],[\"BUF\",\"VDB\"],[\"VDB\",\"XOY\"],[\"XOY\",\"TBV\"],[\"TBV\",\"BNG\"],[\"BNG\",\"HWF\"],[\"HWF\",\"LPI\"],[\"LPI\",\"JCB\"],[\"JCB\",\"DUI\"],[\"DUI\",\"IIK\"],[\"IIK\",\"YBC\"],[\"YBC\",\"VYX\"],[\"VYX\",\"YNS\"],[\"YNS\",\"BQH\"],[\"BQH\",\"WRM\"],[\"WRM\",\"SCY\"],[\"SCY\",\"DFY\"],[\"DFY\",\"BLC\"],[\"BLC\",\"PHX\"],[\"PHX\",\"DFY\"],[\"DFY\",\"BOS\"],[\"BOS\",\"WIB\"],[\"WIB\",\"SEA\"],[\"SEA\",\"THM\"],[\"THM\",\"TTY\"],[\"TTY\",\"HEW\"],[\"HEW\",\"YSM\"],[\"YSM\",\"BNN\"],[\"BNN\",\"MGY\"],[\"MGY\",\"PAR\"],[\"PAR\",\"IRJ\"],[\"IRJ\",\"VDB\"],[\"VDB\",\"ANC\"],[\"ANC\",\"SAN\"],[\"SAN\",\"RDU\"],[\"RDU\",\"REF\"],[\"REF\",\"BWI\"],[\"BWI\",\"HNL\"],[\"HNL\",\"AAP\"],[\"AAP\",\"CVO\"],[\"CVO\",\"JIR\"],[\"JIR\",\"AIT\"],[\"AIT\",\"NEE\"],[\"NEE\",\"HIN\"],[\"HIN\",\"TPU\"],[\"TPU\",\"AHF\"],[\"AHF\",\"MSY\"],[\"MSY\",\"HFM\"],[\"HFM\",\"ATW\"],[\"ATW\",\"KKC\"],[\"KKC\",\"CFB\"],[\"CFB\",\"HPE\"],[\"HPE\",\"BPF\"],[\"BPF\",\"XWB\"],[\"XWB\",\"XVS\"],[\"XVS\",\"FKN\"],[\"FKN\",\"SMF\"],[\"SMF\",\"AIT\"],[\"AIT\",\"MDW\"],[\"MDW\",\"CRG\"],[\"CRG\",\"VRU\"],[\"VRU\",\"FGD\"],[\"FGD\",\"GJK\"],[\"GJK\",\"WSR\"],[\"WSR\",\"FLM\"],[\"FLM\",\"OFX\"],[\"OFX\",\"GVU\"],[\"GVU\",\"UGU\"],[\"UGU\",\"DFV\"],[\"DFV\",\"DEN\"],[\"DEN\",\"NRE\"],[\"NRE\",\"PDX\"],[\"PDX\",\"CWG\"],[\"CWG\",\"TLS\"],[\"TLS\",\"HSS\"],[\"HSS\",\"BQI\"],[\"BQI\",\"HSB\"],[\"HSB\",\"CGT\"],[\"CGT\",\"OFX\"],[\"OFX\",\"TBV\"],[\"TBV\",\"NAT\"],[\"NAT\",\"JGH\"],[\"JGH\",\"NBP\"],[\"NBP\",\"AIT\"],[\"AIT\",\"AKP\"],[\"AKP\",\"SRT\"],[\"SRT\",\"NBP\"],[\"NBP\",\"JGH\"],[\"JGH\",\"VDB\"],[\"VDB\",\"YXT\"],[\"YXT\",\"CLF\"],[\"CLF\",\"KKC\"],[\"KKC\",\"KLO\"],[\"KLO\",\"BWT\"],[\"BWT\",\"LBT\"],[\"LBT\",\"ODN\"],[\"ODN\",\"SMF\"],[\"SMF\",\"GHP\"],[\"GHP\",\"BQI\"],[\"BQI\",\"EXD\"],[\"EXD\",\"ODN\"],[\"ODN\",\"BWT\"],[\"BWT\",\"PDX\"],[\"PDX\",\"IRU\"],[\"IRU\",\"SMJ\"],[\"SMJ\",\"UBB\"],[\"UBB\",\"SIX\"],[\"SIX\",\"XVS\"],[\"XVS\",\"ATW\"],[\"ATW\",\"AAP\"],[\"AAP\",\"RDU\"],[\"RDU\",\"TBV\"],[\"TBV\",\"JCB\"],[\"JCB\",\"TBV\"],[\"TBV\",\"IWC\"],[\"IWC\",\"VTO\"]]\n```\n![image](https://github.com/mquintus/l33tcode-reload/assets/515945/2e6b511e-d801-4f2f-a232-61793fc892c6)"
                    },
                    {
                        "username": "chrisblueeyes",
                        "content": "lol this was a sample google interview question... this brilliant high schooler solved it!! using graphs, heres the video, no code just the theory\n\nhttps://www.youtube.com/watch?v=qz9tKlF431k"
                    },
                    {
                        "username": "realitant",
                        "content": "I think it's worthwhile to explicitly state if the tickets are unique or not.\nEDIT: To anyone else wondering, the tickets are not necessarily unique"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Note- There can be multiple same direction tickets between 2 cities."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Today\\'s question was easy \\uD83E\\uDEE1\\uD83E\\uDEE1\\n\\nhttps://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    }
                ]
            },
            {
                "id": 2057752,
                "content": [
                    {
                        "username": "Shivam_verma24",
                        "content": "Medium level sorting + DFS problem tagged hard"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "What is going on with this testcase?\n`tickets = [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]`\n\nMy output:\n`[\"ATL\",\"JFK\",\"ATL\"]`\n\nExpected:\n`[\"JFK\",\"ATL\",\"JFK\"]`\n\nEdit: I missed that you always start at JFK."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hints in increasing levels of spoilers: (Hints for this question are kind of hard to do unfortunately)\\n\\n1) Actually this is the biggest spoiler, but tbh I would just read the wikipedia page on Eulerian Paths. \\n\\n2) If you tried to construct a path and then failed because you didn\\'t hit every single node, is all of the work you did for nothing? Do you need to restart? or can you reuse the result you got somehow? \\nIs there any structure to the part you missed? "
                    },
                    {
                        "username": "z3eg",
                        "content": "and there goes my third hard problems solved completely by myself. ~300 lines of code and several hours of time and here we go! don\\'t give up, guys, this one doesnt seem to require some special approach, i solved it with a very very common one (surprisingly lol)"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This is a fun problem.  Here are a couple hints if you are stuck:\\n\\n* solving the lexical ordering problem first will increase the efficiency and ease of finding the final solution.\\n\\n* The relatively small amount of tickets opens up a solution method that could be extremely consumptive on large data sets. 1 <= tickets.length <= 300\\n\\nGood Luck!"
                    },
                    {
                        "username": "mstuebs",
                        "content": "I have found that for this challenge the leetcode solution might crash. I got a TLE for empty code for this testcase:\n```\n[[\"JFK\",\"KLO\"],[\"KLO\",\"VRU\"],[\"VRU\",\"JFK\"],[\"JFK\",\"IWC\"],[\"IWC\",\"EXD\"],[\"EXD\",\"VMC\"],[\"VMC\",\"EWR\"],[\"EWR\",\"PDS\"],[\"PDS\",\"PIT\"],[\"PIT\",\"YSM\"],[\"YSM\",\"HKO\"],[\"HKO\",\"RSW\"],[\"RSW\",\"HFM\"],[\"HFM\",\"HMN\"],[\"HMN\",\"IEM\"],[\"IEM\",\"MED\"],[\"MED\",\"NGX\"],[\"NGX\",\"FLL\"],[\"FLL\",\"BYC\"],[\"BYC\",\"SFO\"],[\"SFO\",\"XVS\"],[\"XVS\",\"FUQ\"],[\"FUQ\",\"XBK\"],[\"XBK\",\"DHW\"],[\"DHW\",\"YJO\"],[\"YJO\",\"ODN\"],[\"ODN\",\"XQT\"],[\"XQT\",\"ARH\"],[\"ARH\",\"DTW\"],[\"DTW\",\"MEI\"],[\"MEI\",\"DTW\"],[\"DTW\",\"GPP\"],[\"GPP\",\"WIE\"],[\"WIE\",\"ICJ\"],[\"ICJ\",\"VYX\"],[\"VYX\",\"TLS\"],[\"TLS\",\"NUB\"],[\"NUB\",\"YSM\"],[\"YSM\",\"CSD\"],[\"CSD\",\"CTI\"],[\"CTI\",\"LTU\"],[\"LTU\",\"YAE\"],[\"YAE\",\"KMO\"],[\"KMO\",\"AIT\"],[\"AIT\",\"IWC\"],[\"IWC\",\"OJB\"],[\"OJB\",\"DFV\"],[\"DFV\",\"HSS\"],[\"HSS\",\"EAN\"],[\"EAN\",\"SRT\"],[\"SRT\",\"BUF\"],[\"BUF\",\"EUH\"],[\"EUH\",\"KTE\"],[\"KTE\",\"TPA\"],[\"TPA\",\"SMF\"],[\"SMF\",\"AKP\"],[\"AKP\",\"MMB\"],[\"MMB\",\"TPA\"],[\"TPA\",\"VTO\"],[\"VTO\",\"LBT\"],[\"LBT\",\"GPP\"],[\"GPP\",\"KLO\"],[\"KLO\",\"LAX\"],[\"LAX\",\"MIA\"],[\"MIA\",\"LBT\"],[\"LBT\",\"THM\"],[\"THM\",\"WIB\"],[\"WIB\",\"ORO\"],[\"ORO\",\"IAD\"],[\"IAD\",\"GDP\"],[\"GDP\",\"HMN\"],[\"HMN\",\"CVO\"],[\"CVO\",\"LBT\"],[\"LBT\",\"UGU\"],[\"UGU\",\"HNL\"],[\"HNL\",\"JNQ\"],[\"JNQ\",\"YJO\"],[\"YJO\",\"UGU\"],[\"UGU\",\"ERQ\"],[\"ERQ\",\"XMP\"],[\"XMP\",\"DFF\"],[\"DFF\",\"BWI\"],[\"BWI\",\"MDW\"],[\"MDW\",\"XQT\"],[\"XQT\",\"PBI\"],[\"PBI\",\"IND\"],[\"IND\",\"MJN\"],[\"MJN\",\"SFO\"],[\"SFO\",\"RGS\"],[\"RGS\",\"NVP\"],[\"NVP\",\"LAS\"],[\"LAS\",\"KMO\"],[\"KMO\",\"RSW\"],[\"RSW\",\"HEW\"],[\"HEW\",\"NAT\"],[\"NAT\",\"SJU\"],[\"SJU\",\"FLM\"],[\"FLM\",\"DHL\"],[\"DHL\",\"LPI\"],[\"LPI\",\"QCD\"],[\"QCD\",\"HEW\"],[\"HEW\",\"MFN\"],[\"MFN\",\"YBC\"],[\"YBC\",\"CTX\"],[\"CTX\",\"IWC\"],[\"IWC\",\"BNG\"],[\"BNG\",\"QSH\"],[\"QSH\",\"ANC\"],[\"ANC\",\"EQC\"],[\"EQC\",\"MFN\"],[\"MFN\",\"FBW\"],[\"FBW\",\"NML\"],[\"NML\",\"AUR\"],[\"AUR\",\"LAS\"],[\"LAS\",\"EQC\"],[\"EQC\",\"KKC\"],[\"KKC\",\"LAS\"],[\"LAS\",\"QHN\"],[\"QHN\",\"MDW\"],[\"MDW\",\"KTL\"],[\"KTL\",\"BMQ\"],[\"BMQ\",\"UUH\"],[\"UUH\",\"VTO\"],[\"VTO\",\"CLF\"],[\"CLF\",\"XWB\"],[\"XWB\",\"JWA\"],[\"JWA\",\"STL\"],[\"STL\",\"BPF\"],[\"BPF\",\"MBD\"],[\"MBD\",\"HJT\"],[\"HJT\",\"UYU\"],[\"UYU\",\"HPE\"],[\"HPE\",\"VTO\"],[\"VTO\",\"OJB\"],[\"OJB\",\"SJU\"],[\"SJU\",\"MSY\"],[\"MSY\",\"QWV\"],[\"QWV\",\"OUC\"],[\"OUC\",\"XOY\"],[\"XOY\",\"GPW\"],[\"GPW\",\"OSC\"],[\"OSC\",\"MGL\"],[\"MGL\",\"VRF\"],[\"VRF\",\"XBK\"],[\"XBK\",\"PHL\"],[\"PHL\",\"QAW\"],[\"QAW\",\"YYQ\"],[\"YYQ\",\"BVI\"],[\"BVI\",\"LGA\"],[\"LGA\",\"VLT\"],[\"VLT\",\"UJJ\"],[\"UJJ\",\"BWI\"],[\"BWI\",\"LBT\"],[\"LBT\",\"DTW\"],[\"DTW\",\"MJN\"],[\"MJN\",\"HSS\"],[\"HSS\",\"OHW\"],[\"OHW\",\"BMT\"],[\"BMT\",\"IWC\"],[\"IWC\",\"UJJ\"],[\"UJJ\",\"PDS\"],[\"PDS\",\"EGK\"],[\"EGK\",\"TLS\"],[\"TLS\",\"SIX\"],[\"SIX\",\"AOT\"],[\"AOT\",\"SSH\"],[\"SSH\",\"VGK\"],[\"VGK\",\"JSF\"],[\"JSF\",\"GDP\"],[\"GDP\",\"BOL\"],[\"BOL\",\"JGH\"],[\"JGH\",\"IWC\"],[\"IWC\",\"AOX\"],[\"AOX\",\"FRI\"],[\"FRI\",\"LWV\"],[\"LWV\",\"PDX\"],[\"PDX\",\"STL\"],[\"STL\",\"AIT\"],[\"AIT\",\"CSD\"],[\"CSD\",\"SIX\"],[\"SIX\",\"BUF\"],[\"BUF\",\"VDB\"],[\"VDB\",\"XOY\"],[\"XOY\",\"TBV\"],[\"TBV\",\"BNG\"],[\"BNG\",\"HWF\"],[\"HWF\",\"LPI\"],[\"LPI\",\"JCB\"],[\"JCB\",\"DUI\"],[\"DUI\",\"IIK\"],[\"IIK\",\"YBC\"],[\"YBC\",\"VYX\"],[\"VYX\",\"YNS\"],[\"YNS\",\"BQH\"],[\"BQH\",\"WRM\"],[\"WRM\",\"SCY\"],[\"SCY\",\"DFY\"],[\"DFY\",\"BLC\"],[\"BLC\",\"PHX\"],[\"PHX\",\"DFY\"],[\"DFY\",\"BOS\"],[\"BOS\",\"WIB\"],[\"WIB\",\"SEA\"],[\"SEA\",\"THM\"],[\"THM\",\"TTY\"],[\"TTY\",\"HEW\"],[\"HEW\",\"YSM\"],[\"YSM\",\"BNN\"],[\"BNN\",\"MGY\"],[\"MGY\",\"PAR\"],[\"PAR\",\"IRJ\"],[\"IRJ\",\"VDB\"],[\"VDB\",\"ANC\"],[\"ANC\",\"SAN\"],[\"SAN\",\"RDU\"],[\"RDU\",\"REF\"],[\"REF\",\"BWI\"],[\"BWI\",\"HNL\"],[\"HNL\",\"AAP\"],[\"AAP\",\"CVO\"],[\"CVO\",\"JIR\"],[\"JIR\",\"AIT\"],[\"AIT\",\"NEE\"],[\"NEE\",\"HIN\"],[\"HIN\",\"TPU\"],[\"TPU\",\"AHF\"],[\"AHF\",\"MSY\"],[\"MSY\",\"HFM\"],[\"HFM\",\"ATW\"],[\"ATW\",\"KKC\"],[\"KKC\",\"CFB\"],[\"CFB\",\"HPE\"],[\"HPE\",\"BPF\"],[\"BPF\",\"XWB\"],[\"XWB\",\"XVS\"],[\"XVS\",\"FKN\"],[\"FKN\",\"SMF\"],[\"SMF\",\"AIT\"],[\"AIT\",\"MDW\"],[\"MDW\",\"CRG\"],[\"CRG\",\"VRU\"],[\"VRU\",\"FGD\"],[\"FGD\",\"GJK\"],[\"GJK\",\"WSR\"],[\"WSR\",\"FLM\"],[\"FLM\",\"OFX\"],[\"OFX\",\"GVU\"],[\"GVU\",\"UGU\"],[\"UGU\",\"DFV\"],[\"DFV\",\"DEN\"],[\"DEN\",\"NRE\"],[\"NRE\",\"PDX\"],[\"PDX\",\"CWG\"],[\"CWG\",\"TLS\"],[\"TLS\",\"HSS\"],[\"HSS\",\"BQI\"],[\"BQI\",\"HSB\"],[\"HSB\",\"CGT\"],[\"CGT\",\"OFX\"],[\"OFX\",\"TBV\"],[\"TBV\",\"NAT\"],[\"NAT\",\"JGH\"],[\"JGH\",\"NBP\"],[\"NBP\",\"AIT\"],[\"AIT\",\"AKP\"],[\"AKP\",\"SRT\"],[\"SRT\",\"NBP\"],[\"NBP\",\"JGH\"],[\"JGH\",\"VDB\"],[\"VDB\",\"YXT\"],[\"YXT\",\"CLF\"],[\"CLF\",\"KKC\"],[\"KKC\",\"KLO\"],[\"KLO\",\"BWT\"],[\"BWT\",\"LBT\"],[\"LBT\",\"ODN\"],[\"ODN\",\"SMF\"],[\"SMF\",\"GHP\"],[\"GHP\",\"BQI\"],[\"BQI\",\"EXD\"],[\"EXD\",\"ODN\"],[\"ODN\",\"BWT\"],[\"BWT\",\"PDX\"],[\"PDX\",\"IRU\"],[\"IRU\",\"SMJ\"],[\"SMJ\",\"UBB\"],[\"UBB\",\"SIX\"],[\"SIX\",\"XVS\"],[\"XVS\",\"ATW\"],[\"ATW\",\"AAP\"],[\"AAP\",\"RDU\"],[\"RDU\",\"TBV\"],[\"TBV\",\"JCB\"],[\"JCB\",\"TBV\"],[\"TBV\",\"IWC\"],[\"IWC\",\"VTO\"]]\n```\n![image](https://github.com/mquintus/l33tcode-reload/assets/515945/2e6b511e-d801-4f2f-a232-61793fc892c6)"
                    },
                    {
                        "username": "chrisblueeyes",
                        "content": "lol this was a sample google interview question... this brilliant high schooler solved it!! using graphs, heres the video, no code just the theory\n\nhttps://www.youtube.com/watch?v=qz9tKlF431k"
                    },
                    {
                        "username": "realitant",
                        "content": "I think it's worthwhile to explicitly state if the tickets are unique or not.\nEDIT: To anyone else wondering, the tickets are not necessarily unique"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Note- There can be multiple same direction tickets between 2 cities."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Today\\'s question was easy \\uD83E\\uDEE1\\uD83E\\uDEE1\\n\\nhttps://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    }
                ]
            },
            {
                "id": 2057751,
                "content": [
                    {
                        "username": "Shivam_verma24",
                        "content": "Medium level sorting + DFS problem tagged hard"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "What is going on with this testcase?\n`tickets = [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]`\n\nMy output:\n`[\"ATL\",\"JFK\",\"ATL\"]`\n\nExpected:\n`[\"JFK\",\"ATL\",\"JFK\"]`\n\nEdit: I missed that you always start at JFK."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hints in increasing levels of spoilers: (Hints for this question are kind of hard to do unfortunately)\\n\\n1) Actually this is the biggest spoiler, but tbh I would just read the wikipedia page on Eulerian Paths. \\n\\n2) If you tried to construct a path and then failed because you didn\\'t hit every single node, is all of the work you did for nothing? Do you need to restart? or can you reuse the result you got somehow? \\nIs there any structure to the part you missed? "
                    },
                    {
                        "username": "z3eg",
                        "content": "and there goes my third hard problems solved completely by myself. ~300 lines of code and several hours of time and here we go! don\\'t give up, guys, this one doesnt seem to require some special approach, i solved it with a very very common one (surprisingly lol)"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This is a fun problem.  Here are a couple hints if you are stuck:\\n\\n* solving the lexical ordering problem first will increase the efficiency and ease of finding the final solution.\\n\\n* The relatively small amount of tickets opens up a solution method that could be extremely consumptive on large data sets. 1 <= tickets.length <= 300\\n\\nGood Luck!"
                    },
                    {
                        "username": "mstuebs",
                        "content": "I have found that for this challenge the leetcode solution might crash. I got a TLE for empty code for this testcase:\n```\n[[\"JFK\",\"KLO\"],[\"KLO\",\"VRU\"],[\"VRU\",\"JFK\"],[\"JFK\",\"IWC\"],[\"IWC\",\"EXD\"],[\"EXD\",\"VMC\"],[\"VMC\",\"EWR\"],[\"EWR\",\"PDS\"],[\"PDS\",\"PIT\"],[\"PIT\",\"YSM\"],[\"YSM\",\"HKO\"],[\"HKO\",\"RSW\"],[\"RSW\",\"HFM\"],[\"HFM\",\"HMN\"],[\"HMN\",\"IEM\"],[\"IEM\",\"MED\"],[\"MED\",\"NGX\"],[\"NGX\",\"FLL\"],[\"FLL\",\"BYC\"],[\"BYC\",\"SFO\"],[\"SFO\",\"XVS\"],[\"XVS\",\"FUQ\"],[\"FUQ\",\"XBK\"],[\"XBK\",\"DHW\"],[\"DHW\",\"YJO\"],[\"YJO\",\"ODN\"],[\"ODN\",\"XQT\"],[\"XQT\",\"ARH\"],[\"ARH\",\"DTW\"],[\"DTW\",\"MEI\"],[\"MEI\",\"DTW\"],[\"DTW\",\"GPP\"],[\"GPP\",\"WIE\"],[\"WIE\",\"ICJ\"],[\"ICJ\",\"VYX\"],[\"VYX\",\"TLS\"],[\"TLS\",\"NUB\"],[\"NUB\",\"YSM\"],[\"YSM\",\"CSD\"],[\"CSD\",\"CTI\"],[\"CTI\",\"LTU\"],[\"LTU\",\"YAE\"],[\"YAE\",\"KMO\"],[\"KMO\",\"AIT\"],[\"AIT\",\"IWC\"],[\"IWC\",\"OJB\"],[\"OJB\",\"DFV\"],[\"DFV\",\"HSS\"],[\"HSS\",\"EAN\"],[\"EAN\",\"SRT\"],[\"SRT\",\"BUF\"],[\"BUF\",\"EUH\"],[\"EUH\",\"KTE\"],[\"KTE\",\"TPA\"],[\"TPA\",\"SMF\"],[\"SMF\",\"AKP\"],[\"AKP\",\"MMB\"],[\"MMB\",\"TPA\"],[\"TPA\",\"VTO\"],[\"VTO\",\"LBT\"],[\"LBT\",\"GPP\"],[\"GPP\",\"KLO\"],[\"KLO\",\"LAX\"],[\"LAX\",\"MIA\"],[\"MIA\",\"LBT\"],[\"LBT\",\"THM\"],[\"THM\",\"WIB\"],[\"WIB\",\"ORO\"],[\"ORO\",\"IAD\"],[\"IAD\",\"GDP\"],[\"GDP\",\"HMN\"],[\"HMN\",\"CVO\"],[\"CVO\",\"LBT\"],[\"LBT\",\"UGU\"],[\"UGU\",\"HNL\"],[\"HNL\",\"JNQ\"],[\"JNQ\",\"YJO\"],[\"YJO\",\"UGU\"],[\"UGU\",\"ERQ\"],[\"ERQ\",\"XMP\"],[\"XMP\",\"DFF\"],[\"DFF\",\"BWI\"],[\"BWI\",\"MDW\"],[\"MDW\",\"XQT\"],[\"XQT\",\"PBI\"],[\"PBI\",\"IND\"],[\"IND\",\"MJN\"],[\"MJN\",\"SFO\"],[\"SFO\",\"RGS\"],[\"RGS\",\"NVP\"],[\"NVP\",\"LAS\"],[\"LAS\",\"KMO\"],[\"KMO\",\"RSW\"],[\"RSW\",\"HEW\"],[\"HEW\",\"NAT\"],[\"NAT\",\"SJU\"],[\"SJU\",\"FLM\"],[\"FLM\",\"DHL\"],[\"DHL\",\"LPI\"],[\"LPI\",\"QCD\"],[\"QCD\",\"HEW\"],[\"HEW\",\"MFN\"],[\"MFN\",\"YBC\"],[\"YBC\",\"CTX\"],[\"CTX\",\"IWC\"],[\"IWC\",\"BNG\"],[\"BNG\",\"QSH\"],[\"QSH\",\"ANC\"],[\"ANC\",\"EQC\"],[\"EQC\",\"MFN\"],[\"MFN\",\"FBW\"],[\"FBW\",\"NML\"],[\"NML\",\"AUR\"],[\"AUR\",\"LAS\"],[\"LAS\",\"EQC\"],[\"EQC\",\"KKC\"],[\"KKC\",\"LAS\"],[\"LAS\",\"QHN\"],[\"QHN\",\"MDW\"],[\"MDW\",\"KTL\"],[\"KTL\",\"BMQ\"],[\"BMQ\",\"UUH\"],[\"UUH\",\"VTO\"],[\"VTO\",\"CLF\"],[\"CLF\",\"XWB\"],[\"XWB\",\"JWA\"],[\"JWA\",\"STL\"],[\"STL\",\"BPF\"],[\"BPF\",\"MBD\"],[\"MBD\",\"HJT\"],[\"HJT\",\"UYU\"],[\"UYU\",\"HPE\"],[\"HPE\",\"VTO\"],[\"VTO\",\"OJB\"],[\"OJB\",\"SJU\"],[\"SJU\",\"MSY\"],[\"MSY\",\"QWV\"],[\"QWV\",\"OUC\"],[\"OUC\",\"XOY\"],[\"XOY\",\"GPW\"],[\"GPW\",\"OSC\"],[\"OSC\",\"MGL\"],[\"MGL\",\"VRF\"],[\"VRF\",\"XBK\"],[\"XBK\",\"PHL\"],[\"PHL\",\"QAW\"],[\"QAW\",\"YYQ\"],[\"YYQ\",\"BVI\"],[\"BVI\",\"LGA\"],[\"LGA\",\"VLT\"],[\"VLT\",\"UJJ\"],[\"UJJ\",\"BWI\"],[\"BWI\",\"LBT\"],[\"LBT\",\"DTW\"],[\"DTW\",\"MJN\"],[\"MJN\",\"HSS\"],[\"HSS\",\"OHW\"],[\"OHW\",\"BMT\"],[\"BMT\",\"IWC\"],[\"IWC\",\"UJJ\"],[\"UJJ\",\"PDS\"],[\"PDS\",\"EGK\"],[\"EGK\",\"TLS\"],[\"TLS\",\"SIX\"],[\"SIX\",\"AOT\"],[\"AOT\",\"SSH\"],[\"SSH\",\"VGK\"],[\"VGK\",\"JSF\"],[\"JSF\",\"GDP\"],[\"GDP\",\"BOL\"],[\"BOL\",\"JGH\"],[\"JGH\",\"IWC\"],[\"IWC\",\"AOX\"],[\"AOX\",\"FRI\"],[\"FRI\",\"LWV\"],[\"LWV\",\"PDX\"],[\"PDX\",\"STL\"],[\"STL\",\"AIT\"],[\"AIT\",\"CSD\"],[\"CSD\",\"SIX\"],[\"SIX\",\"BUF\"],[\"BUF\",\"VDB\"],[\"VDB\",\"XOY\"],[\"XOY\",\"TBV\"],[\"TBV\",\"BNG\"],[\"BNG\",\"HWF\"],[\"HWF\",\"LPI\"],[\"LPI\",\"JCB\"],[\"JCB\",\"DUI\"],[\"DUI\",\"IIK\"],[\"IIK\",\"YBC\"],[\"YBC\",\"VYX\"],[\"VYX\",\"YNS\"],[\"YNS\",\"BQH\"],[\"BQH\",\"WRM\"],[\"WRM\",\"SCY\"],[\"SCY\",\"DFY\"],[\"DFY\",\"BLC\"],[\"BLC\",\"PHX\"],[\"PHX\",\"DFY\"],[\"DFY\",\"BOS\"],[\"BOS\",\"WIB\"],[\"WIB\",\"SEA\"],[\"SEA\",\"THM\"],[\"THM\",\"TTY\"],[\"TTY\",\"HEW\"],[\"HEW\",\"YSM\"],[\"YSM\",\"BNN\"],[\"BNN\",\"MGY\"],[\"MGY\",\"PAR\"],[\"PAR\",\"IRJ\"],[\"IRJ\",\"VDB\"],[\"VDB\",\"ANC\"],[\"ANC\",\"SAN\"],[\"SAN\",\"RDU\"],[\"RDU\",\"REF\"],[\"REF\",\"BWI\"],[\"BWI\",\"HNL\"],[\"HNL\",\"AAP\"],[\"AAP\",\"CVO\"],[\"CVO\",\"JIR\"],[\"JIR\",\"AIT\"],[\"AIT\",\"NEE\"],[\"NEE\",\"HIN\"],[\"HIN\",\"TPU\"],[\"TPU\",\"AHF\"],[\"AHF\",\"MSY\"],[\"MSY\",\"HFM\"],[\"HFM\",\"ATW\"],[\"ATW\",\"KKC\"],[\"KKC\",\"CFB\"],[\"CFB\",\"HPE\"],[\"HPE\",\"BPF\"],[\"BPF\",\"XWB\"],[\"XWB\",\"XVS\"],[\"XVS\",\"FKN\"],[\"FKN\",\"SMF\"],[\"SMF\",\"AIT\"],[\"AIT\",\"MDW\"],[\"MDW\",\"CRG\"],[\"CRG\",\"VRU\"],[\"VRU\",\"FGD\"],[\"FGD\",\"GJK\"],[\"GJK\",\"WSR\"],[\"WSR\",\"FLM\"],[\"FLM\",\"OFX\"],[\"OFX\",\"GVU\"],[\"GVU\",\"UGU\"],[\"UGU\",\"DFV\"],[\"DFV\",\"DEN\"],[\"DEN\",\"NRE\"],[\"NRE\",\"PDX\"],[\"PDX\",\"CWG\"],[\"CWG\",\"TLS\"],[\"TLS\",\"HSS\"],[\"HSS\",\"BQI\"],[\"BQI\",\"HSB\"],[\"HSB\",\"CGT\"],[\"CGT\",\"OFX\"],[\"OFX\",\"TBV\"],[\"TBV\",\"NAT\"],[\"NAT\",\"JGH\"],[\"JGH\",\"NBP\"],[\"NBP\",\"AIT\"],[\"AIT\",\"AKP\"],[\"AKP\",\"SRT\"],[\"SRT\",\"NBP\"],[\"NBP\",\"JGH\"],[\"JGH\",\"VDB\"],[\"VDB\",\"YXT\"],[\"YXT\",\"CLF\"],[\"CLF\",\"KKC\"],[\"KKC\",\"KLO\"],[\"KLO\",\"BWT\"],[\"BWT\",\"LBT\"],[\"LBT\",\"ODN\"],[\"ODN\",\"SMF\"],[\"SMF\",\"GHP\"],[\"GHP\",\"BQI\"],[\"BQI\",\"EXD\"],[\"EXD\",\"ODN\"],[\"ODN\",\"BWT\"],[\"BWT\",\"PDX\"],[\"PDX\",\"IRU\"],[\"IRU\",\"SMJ\"],[\"SMJ\",\"UBB\"],[\"UBB\",\"SIX\"],[\"SIX\",\"XVS\"],[\"XVS\",\"ATW\"],[\"ATW\",\"AAP\"],[\"AAP\",\"RDU\"],[\"RDU\",\"TBV\"],[\"TBV\",\"JCB\"],[\"JCB\",\"TBV\"],[\"TBV\",\"IWC\"],[\"IWC\",\"VTO\"]]\n```\n![image](https://github.com/mquintus/l33tcode-reload/assets/515945/2e6b511e-d801-4f2f-a232-61793fc892c6)"
                    },
                    {
                        "username": "chrisblueeyes",
                        "content": "lol this was a sample google interview question... this brilliant high schooler solved it!! using graphs, heres the video, no code just the theory\n\nhttps://www.youtube.com/watch?v=qz9tKlF431k"
                    },
                    {
                        "username": "realitant",
                        "content": "I think it's worthwhile to explicitly state if the tickets are unique or not.\nEDIT: To anyone else wondering, the tickets are not necessarily unique"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Note- There can be multiple same direction tickets between 2 cities."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Today\\'s question was easy \\uD83E\\uDEE1\\uD83E\\uDEE1\\n\\nhttps://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    }
                ]
            },
            {
                "id": 2057450,
                "content": [
                    {
                        "username": "Shivam_verma24",
                        "content": "Medium level sorting + DFS problem tagged hard"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "What is going on with this testcase?\n`tickets = [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]`\n\nMy output:\n`[\"ATL\",\"JFK\",\"ATL\"]`\n\nExpected:\n`[\"JFK\",\"ATL\",\"JFK\"]`\n\nEdit: I missed that you always start at JFK."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hints in increasing levels of spoilers: (Hints for this question are kind of hard to do unfortunately)\\n\\n1) Actually this is the biggest spoiler, but tbh I would just read the wikipedia page on Eulerian Paths. \\n\\n2) If you tried to construct a path and then failed because you didn\\'t hit every single node, is all of the work you did for nothing? Do you need to restart? or can you reuse the result you got somehow? \\nIs there any structure to the part you missed? "
                    },
                    {
                        "username": "z3eg",
                        "content": "and there goes my third hard problems solved completely by myself. ~300 lines of code and several hours of time and here we go! don\\'t give up, guys, this one doesnt seem to require some special approach, i solved it with a very very common one (surprisingly lol)"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This is a fun problem.  Here are a couple hints if you are stuck:\\n\\n* solving the lexical ordering problem first will increase the efficiency and ease of finding the final solution.\\n\\n* The relatively small amount of tickets opens up a solution method that could be extremely consumptive on large data sets. 1 <= tickets.length <= 300\\n\\nGood Luck!"
                    },
                    {
                        "username": "mstuebs",
                        "content": "I have found that for this challenge the leetcode solution might crash. I got a TLE for empty code for this testcase:\n```\n[[\"JFK\",\"KLO\"],[\"KLO\",\"VRU\"],[\"VRU\",\"JFK\"],[\"JFK\",\"IWC\"],[\"IWC\",\"EXD\"],[\"EXD\",\"VMC\"],[\"VMC\",\"EWR\"],[\"EWR\",\"PDS\"],[\"PDS\",\"PIT\"],[\"PIT\",\"YSM\"],[\"YSM\",\"HKO\"],[\"HKO\",\"RSW\"],[\"RSW\",\"HFM\"],[\"HFM\",\"HMN\"],[\"HMN\",\"IEM\"],[\"IEM\",\"MED\"],[\"MED\",\"NGX\"],[\"NGX\",\"FLL\"],[\"FLL\",\"BYC\"],[\"BYC\",\"SFO\"],[\"SFO\",\"XVS\"],[\"XVS\",\"FUQ\"],[\"FUQ\",\"XBK\"],[\"XBK\",\"DHW\"],[\"DHW\",\"YJO\"],[\"YJO\",\"ODN\"],[\"ODN\",\"XQT\"],[\"XQT\",\"ARH\"],[\"ARH\",\"DTW\"],[\"DTW\",\"MEI\"],[\"MEI\",\"DTW\"],[\"DTW\",\"GPP\"],[\"GPP\",\"WIE\"],[\"WIE\",\"ICJ\"],[\"ICJ\",\"VYX\"],[\"VYX\",\"TLS\"],[\"TLS\",\"NUB\"],[\"NUB\",\"YSM\"],[\"YSM\",\"CSD\"],[\"CSD\",\"CTI\"],[\"CTI\",\"LTU\"],[\"LTU\",\"YAE\"],[\"YAE\",\"KMO\"],[\"KMO\",\"AIT\"],[\"AIT\",\"IWC\"],[\"IWC\",\"OJB\"],[\"OJB\",\"DFV\"],[\"DFV\",\"HSS\"],[\"HSS\",\"EAN\"],[\"EAN\",\"SRT\"],[\"SRT\",\"BUF\"],[\"BUF\",\"EUH\"],[\"EUH\",\"KTE\"],[\"KTE\",\"TPA\"],[\"TPA\",\"SMF\"],[\"SMF\",\"AKP\"],[\"AKP\",\"MMB\"],[\"MMB\",\"TPA\"],[\"TPA\",\"VTO\"],[\"VTO\",\"LBT\"],[\"LBT\",\"GPP\"],[\"GPP\",\"KLO\"],[\"KLO\",\"LAX\"],[\"LAX\",\"MIA\"],[\"MIA\",\"LBT\"],[\"LBT\",\"THM\"],[\"THM\",\"WIB\"],[\"WIB\",\"ORO\"],[\"ORO\",\"IAD\"],[\"IAD\",\"GDP\"],[\"GDP\",\"HMN\"],[\"HMN\",\"CVO\"],[\"CVO\",\"LBT\"],[\"LBT\",\"UGU\"],[\"UGU\",\"HNL\"],[\"HNL\",\"JNQ\"],[\"JNQ\",\"YJO\"],[\"YJO\",\"UGU\"],[\"UGU\",\"ERQ\"],[\"ERQ\",\"XMP\"],[\"XMP\",\"DFF\"],[\"DFF\",\"BWI\"],[\"BWI\",\"MDW\"],[\"MDW\",\"XQT\"],[\"XQT\",\"PBI\"],[\"PBI\",\"IND\"],[\"IND\",\"MJN\"],[\"MJN\",\"SFO\"],[\"SFO\",\"RGS\"],[\"RGS\",\"NVP\"],[\"NVP\",\"LAS\"],[\"LAS\",\"KMO\"],[\"KMO\",\"RSW\"],[\"RSW\",\"HEW\"],[\"HEW\",\"NAT\"],[\"NAT\",\"SJU\"],[\"SJU\",\"FLM\"],[\"FLM\",\"DHL\"],[\"DHL\",\"LPI\"],[\"LPI\",\"QCD\"],[\"QCD\",\"HEW\"],[\"HEW\",\"MFN\"],[\"MFN\",\"YBC\"],[\"YBC\",\"CTX\"],[\"CTX\",\"IWC\"],[\"IWC\",\"BNG\"],[\"BNG\",\"QSH\"],[\"QSH\",\"ANC\"],[\"ANC\",\"EQC\"],[\"EQC\",\"MFN\"],[\"MFN\",\"FBW\"],[\"FBW\",\"NML\"],[\"NML\",\"AUR\"],[\"AUR\",\"LAS\"],[\"LAS\",\"EQC\"],[\"EQC\",\"KKC\"],[\"KKC\",\"LAS\"],[\"LAS\",\"QHN\"],[\"QHN\",\"MDW\"],[\"MDW\",\"KTL\"],[\"KTL\",\"BMQ\"],[\"BMQ\",\"UUH\"],[\"UUH\",\"VTO\"],[\"VTO\",\"CLF\"],[\"CLF\",\"XWB\"],[\"XWB\",\"JWA\"],[\"JWA\",\"STL\"],[\"STL\",\"BPF\"],[\"BPF\",\"MBD\"],[\"MBD\",\"HJT\"],[\"HJT\",\"UYU\"],[\"UYU\",\"HPE\"],[\"HPE\",\"VTO\"],[\"VTO\",\"OJB\"],[\"OJB\",\"SJU\"],[\"SJU\",\"MSY\"],[\"MSY\",\"QWV\"],[\"QWV\",\"OUC\"],[\"OUC\",\"XOY\"],[\"XOY\",\"GPW\"],[\"GPW\",\"OSC\"],[\"OSC\",\"MGL\"],[\"MGL\",\"VRF\"],[\"VRF\",\"XBK\"],[\"XBK\",\"PHL\"],[\"PHL\",\"QAW\"],[\"QAW\",\"YYQ\"],[\"YYQ\",\"BVI\"],[\"BVI\",\"LGA\"],[\"LGA\",\"VLT\"],[\"VLT\",\"UJJ\"],[\"UJJ\",\"BWI\"],[\"BWI\",\"LBT\"],[\"LBT\",\"DTW\"],[\"DTW\",\"MJN\"],[\"MJN\",\"HSS\"],[\"HSS\",\"OHW\"],[\"OHW\",\"BMT\"],[\"BMT\",\"IWC\"],[\"IWC\",\"UJJ\"],[\"UJJ\",\"PDS\"],[\"PDS\",\"EGK\"],[\"EGK\",\"TLS\"],[\"TLS\",\"SIX\"],[\"SIX\",\"AOT\"],[\"AOT\",\"SSH\"],[\"SSH\",\"VGK\"],[\"VGK\",\"JSF\"],[\"JSF\",\"GDP\"],[\"GDP\",\"BOL\"],[\"BOL\",\"JGH\"],[\"JGH\",\"IWC\"],[\"IWC\",\"AOX\"],[\"AOX\",\"FRI\"],[\"FRI\",\"LWV\"],[\"LWV\",\"PDX\"],[\"PDX\",\"STL\"],[\"STL\",\"AIT\"],[\"AIT\",\"CSD\"],[\"CSD\",\"SIX\"],[\"SIX\",\"BUF\"],[\"BUF\",\"VDB\"],[\"VDB\",\"XOY\"],[\"XOY\",\"TBV\"],[\"TBV\",\"BNG\"],[\"BNG\",\"HWF\"],[\"HWF\",\"LPI\"],[\"LPI\",\"JCB\"],[\"JCB\",\"DUI\"],[\"DUI\",\"IIK\"],[\"IIK\",\"YBC\"],[\"YBC\",\"VYX\"],[\"VYX\",\"YNS\"],[\"YNS\",\"BQH\"],[\"BQH\",\"WRM\"],[\"WRM\",\"SCY\"],[\"SCY\",\"DFY\"],[\"DFY\",\"BLC\"],[\"BLC\",\"PHX\"],[\"PHX\",\"DFY\"],[\"DFY\",\"BOS\"],[\"BOS\",\"WIB\"],[\"WIB\",\"SEA\"],[\"SEA\",\"THM\"],[\"THM\",\"TTY\"],[\"TTY\",\"HEW\"],[\"HEW\",\"YSM\"],[\"YSM\",\"BNN\"],[\"BNN\",\"MGY\"],[\"MGY\",\"PAR\"],[\"PAR\",\"IRJ\"],[\"IRJ\",\"VDB\"],[\"VDB\",\"ANC\"],[\"ANC\",\"SAN\"],[\"SAN\",\"RDU\"],[\"RDU\",\"REF\"],[\"REF\",\"BWI\"],[\"BWI\",\"HNL\"],[\"HNL\",\"AAP\"],[\"AAP\",\"CVO\"],[\"CVO\",\"JIR\"],[\"JIR\",\"AIT\"],[\"AIT\",\"NEE\"],[\"NEE\",\"HIN\"],[\"HIN\",\"TPU\"],[\"TPU\",\"AHF\"],[\"AHF\",\"MSY\"],[\"MSY\",\"HFM\"],[\"HFM\",\"ATW\"],[\"ATW\",\"KKC\"],[\"KKC\",\"CFB\"],[\"CFB\",\"HPE\"],[\"HPE\",\"BPF\"],[\"BPF\",\"XWB\"],[\"XWB\",\"XVS\"],[\"XVS\",\"FKN\"],[\"FKN\",\"SMF\"],[\"SMF\",\"AIT\"],[\"AIT\",\"MDW\"],[\"MDW\",\"CRG\"],[\"CRG\",\"VRU\"],[\"VRU\",\"FGD\"],[\"FGD\",\"GJK\"],[\"GJK\",\"WSR\"],[\"WSR\",\"FLM\"],[\"FLM\",\"OFX\"],[\"OFX\",\"GVU\"],[\"GVU\",\"UGU\"],[\"UGU\",\"DFV\"],[\"DFV\",\"DEN\"],[\"DEN\",\"NRE\"],[\"NRE\",\"PDX\"],[\"PDX\",\"CWG\"],[\"CWG\",\"TLS\"],[\"TLS\",\"HSS\"],[\"HSS\",\"BQI\"],[\"BQI\",\"HSB\"],[\"HSB\",\"CGT\"],[\"CGT\",\"OFX\"],[\"OFX\",\"TBV\"],[\"TBV\",\"NAT\"],[\"NAT\",\"JGH\"],[\"JGH\",\"NBP\"],[\"NBP\",\"AIT\"],[\"AIT\",\"AKP\"],[\"AKP\",\"SRT\"],[\"SRT\",\"NBP\"],[\"NBP\",\"JGH\"],[\"JGH\",\"VDB\"],[\"VDB\",\"YXT\"],[\"YXT\",\"CLF\"],[\"CLF\",\"KKC\"],[\"KKC\",\"KLO\"],[\"KLO\",\"BWT\"],[\"BWT\",\"LBT\"],[\"LBT\",\"ODN\"],[\"ODN\",\"SMF\"],[\"SMF\",\"GHP\"],[\"GHP\",\"BQI\"],[\"BQI\",\"EXD\"],[\"EXD\",\"ODN\"],[\"ODN\",\"BWT\"],[\"BWT\",\"PDX\"],[\"PDX\",\"IRU\"],[\"IRU\",\"SMJ\"],[\"SMJ\",\"UBB\"],[\"UBB\",\"SIX\"],[\"SIX\",\"XVS\"],[\"XVS\",\"ATW\"],[\"ATW\",\"AAP\"],[\"AAP\",\"RDU\"],[\"RDU\",\"TBV\"],[\"TBV\",\"JCB\"],[\"JCB\",\"TBV\"],[\"TBV\",\"IWC\"],[\"IWC\",\"VTO\"]]\n```\n![image](https://github.com/mquintus/l33tcode-reload/assets/515945/2e6b511e-d801-4f2f-a232-61793fc892c6)"
                    },
                    {
                        "username": "chrisblueeyes",
                        "content": "lol this was a sample google interview question... this brilliant high schooler solved it!! using graphs, heres the video, no code just the theory\n\nhttps://www.youtube.com/watch?v=qz9tKlF431k"
                    },
                    {
                        "username": "realitant",
                        "content": "I think it's worthwhile to explicitly state if the tickets are unique or not.\nEDIT: To anyone else wondering, the tickets are not necessarily unique"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Note- There can be multiple same direction tickets between 2 cities."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Today\\'s question was easy \\uD83E\\uDEE1\\uD83E\\uDEE1\\n\\nhttps://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    }
                ]
            },
            {
                "id": 2057357,
                "content": [
                    {
                        "username": "Shivam_verma24",
                        "content": "Medium level sorting + DFS problem tagged hard"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "What is going on with this testcase?\n`tickets = [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]`\n\nMy output:\n`[\"ATL\",\"JFK\",\"ATL\"]`\n\nExpected:\n`[\"JFK\",\"ATL\",\"JFK\"]`\n\nEdit: I missed that you always start at JFK."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hints in increasing levels of spoilers: (Hints for this question are kind of hard to do unfortunately)\\n\\n1) Actually this is the biggest spoiler, but tbh I would just read the wikipedia page on Eulerian Paths. \\n\\n2) If you tried to construct a path and then failed because you didn\\'t hit every single node, is all of the work you did for nothing? Do you need to restart? or can you reuse the result you got somehow? \\nIs there any structure to the part you missed? "
                    },
                    {
                        "username": "z3eg",
                        "content": "and there goes my third hard problems solved completely by myself. ~300 lines of code and several hours of time and here we go! don\\'t give up, guys, this one doesnt seem to require some special approach, i solved it with a very very common one (surprisingly lol)"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This is a fun problem.  Here are a couple hints if you are stuck:\\n\\n* solving the lexical ordering problem first will increase the efficiency and ease of finding the final solution.\\n\\n* The relatively small amount of tickets opens up a solution method that could be extremely consumptive on large data sets. 1 <= tickets.length <= 300\\n\\nGood Luck!"
                    },
                    {
                        "username": "mstuebs",
                        "content": "I have found that for this challenge the leetcode solution might crash. I got a TLE for empty code for this testcase:\n```\n[[\"JFK\",\"KLO\"],[\"KLO\",\"VRU\"],[\"VRU\",\"JFK\"],[\"JFK\",\"IWC\"],[\"IWC\",\"EXD\"],[\"EXD\",\"VMC\"],[\"VMC\",\"EWR\"],[\"EWR\",\"PDS\"],[\"PDS\",\"PIT\"],[\"PIT\",\"YSM\"],[\"YSM\",\"HKO\"],[\"HKO\",\"RSW\"],[\"RSW\",\"HFM\"],[\"HFM\",\"HMN\"],[\"HMN\",\"IEM\"],[\"IEM\",\"MED\"],[\"MED\",\"NGX\"],[\"NGX\",\"FLL\"],[\"FLL\",\"BYC\"],[\"BYC\",\"SFO\"],[\"SFO\",\"XVS\"],[\"XVS\",\"FUQ\"],[\"FUQ\",\"XBK\"],[\"XBK\",\"DHW\"],[\"DHW\",\"YJO\"],[\"YJO\",\"ODN\"],[\"ODN\",\"XQT\"],[\"XQT\",\"ARH\"],[\"ARH\",\"DTW\"],[\"DTW\",\"MEI\"],[\"MEI\",\"DTW\"],[\"DTW\",\"GPP\"],[\"GPP\",\"WIE\"],[\"WIE\",\"ICJ\"],[\"ICJ\",\"VYX\"],[\"VYX\",\"TLS\"],[\"TLS\",\"NUB\"],[\"NUB\",\"YSM\"],[\"YSM\",\"CSD\"],[\"CSD\",\"CTI\"],[\"CTI\",\"LTU\"],[\"LTU\",\"YAE\"],[\"YAE\",\"KMO\"],[\"KMO\",\"AIT\"],[\"AIT\",\"IWC\"],[\"IWC\",\"OJB\"],[\"OJB\",\"DFV\"],[\"DFV\",\"HSS\"],[\"HSS\",\"EAN\"],[\"EAN\",\"SRT\"],[\"SRT\",\"BUF\"],[\"BUF\",\"EUH\"],[\"EUH\",\"KTE\"],[\"KTE\",\"TPA\"],[\"TPA\",\"SMF\"],[\"SMF\",\"AKP\"],[\"AKP\",\"MMB\"],[\"MMB\",\"TPA\"],[\"TPA\",\"VTO\"],[\"VTO\",\"LBT\"],[\"LBT\",\"GPP\"],[\"GPP\",\"KLO\"],[\"KLO\",\"LAX\"],[\"LAX\",\"MIA\"],[\"MIA\",\"LBT\"],[\"LBT\",\"THM\"],[\"THM\",\"WIB\"],[\"WIB\",\"ORO\"],[\"ORO\",\"IAD\"],[\"IAD\",\"GDP\"],[\"GDP\",\"HMN\"],[\"HMN\",\"CVO\"],[\"CVO\",\"LBT\"],[\"LBT\",\"UGU\"],[\"UGU\",\"HNL\"],[\"HNL\",\"JNQ\"],[\"JNQ\",\"YJO\"],[\"YJO\",\"UGU\"],[\"UGU\",\"ERQ\"],[\"ERQ\",\"XMP\"],[\"XMP\",\"DFF\"],[\"DFF\",\"BWI\"],[\"BWI\",\"MDW\"],[\"MDW\",\"XQT\"],[\"XQT\",\"PBI\"],[\"PBI\",\"IND\"],[\"IND\",\"MJN\"],[\"MJN\",\"SFO\"],[\"SFO\",\"RGS\"],[\"RGS\",\"NVP\"],[\"NVP\",\"LAS\"],[\"LAS\",\"KMO\"],[\"KMO\",\"RSW\"],[\"RSW\",\"HEW\"],[\"HEW\",\"NAT\"],[\"NAT\",\"SJU\"],[\"SJU\",\"FLM\"],[\"FLM\",\"DHL\"],[\"DHL\",\"LPI\"],[\"LPI\",\"QCD\"],[\"QCD\",\"HEW\"],[\"HEW\",\"MFN\"],[\"MFN\",\"YBC\"],[\"YBC\",\"CTX\"],[\"CTX\",\"IWC\"],[\"IWC\",\"BNG\"],[\"BNG\",\"QSH\"],[\"QSH\",\"ANC\"],[\"ANC\",\"EQC\"],[\"EQC\",\"MFN\"],[\"MFN\",\"FBW\"],[\"FBW\",\"NML\"],[\"NML\",\"AUR\"],[\"AUR\",\"LAS\"],[\"LAS\",\"EQC\"],[\"EQC\",\"KKC\"],[\"KKC\",\"LAS\"],[\"LAS\",\"QHN\"],[\"QHN\",\"MDW\"],[\"MDW\",\"KTL\"],[\"KTL\",\"BMQ\"],[\"BMQ\",\"UUH\"],[\"UUH\",\"VTO\"],[\"VTO\",\"CLF\"],[\"CLF\",\"XWB\"],[\"XWB\",\"JWA\"],[\"JWA\",\"STL\"],[\"STL\",\"BPF\"],[\"BPF\",\"MBD\"],[\"MBD\",\"HJT\"],[\"HJT\",\"UYU\"],[\"UYU\",\"HPE\"],[\"HPE\",\"VTO\"],[\"VTO\",\"OJB\"],[\"OJB\",\"SJU\"],[\"SJU\",\"MSY\"],[\"MSY\",\"QWV\"],[\"QWV\",\"OUC\"],[\"OUC\",\"XOY\"],[\"XOY\",\"GPW\"],[\"GPW\",\"OSC\"],[\"OSC\",\"MGL\"],[\"MGL\",\"VRF\"],[\"VRF\",\"XBK\"],[\"XBK\",\"PHL\"],[\"PHL\",\"QAW\"],[\"QAW\",\"YYQ\"],[\"YYQ\",\"BVI\"],[\"BVI\",\"LGA\"],[\"LGA\",\"VLT\"],[\"VLT\",\"UJJ\"],[\"UJJ\",\"BWI\"],[\"BWI\",\"LBT\"],[\"LBT\",\"DTW\"],[\"DTW\",\"MJN\"],[\"MJN\",\"HSS\"],[\"HSS\",\"OHW\"],[\"OHW\",\"BMT\"],[\"BMT\",\"IWC\"],[\"IWC\",\"UJJ\"],[\"UJJ\",\"PDS\"],[\"PDS\",\"EGK\"],[\"EGK\",\"TLS\"],[\"TLS\",\"SIX\"],[\"SIX\",\"AOT\"],[\"AOT\",\"SSH\"],[\"SSH\",\"VGK\"],[\"VGK\",\"JSF\"],[\"JSF\",\"GDP\"],[\"GDP\",\"BOL\"],[\"BOL\",\"JGH\"],[\"JGH\",\"IWC\"],[\"IWC\",\"AOX\"],[\"AOX\",\"FRI\"],[\"FRI\",\"LWV\"],[\"LWV\",\"PDX\"],[\"PDX\",\"STL\"],[\"STL\",\"AIT\"],[\"AIT\",\"CSD\"],[\"CSD\",\"SIX\"],[\"SIX\",\"BUF\"],[\"BUF\",\"VDB\"],[\"VDB\",\"XOY\"],[\"XOY\",\"TBV\"],[\"TBV\",\"BNG\"],[\"BNG\",\"HWF\"],[\"HWF\",\"LPI\"],[\"LPI\",\"JCB\"],[\"JCB\",\"DUI\"],[\"DUI\",\"IIK\"],[\"IIK\",\"YBC\"],[\"YBC\",\"VYX\"],[\"VYX\",\"YNS\"],[\"YNS\",\"BQH\"],[\"BQH\",\"WRM\"],[\"WRM\",\"SCY\"],[\"SCY\",\"DFY\"],[\"DFY\",\"BLC\"],[\"BLC\",\"PHX\"],[\"PHX\",\"DFY\"],[\"DFY\",\"BOS\"],[\"BOS\",\"WIB\"],[\"WIB\",\"SEA\"],[\"SEA\",\"THM\"],[\"THM\",\"TTY\"],[\"TTY\",\"HEW\"],[\"HEW\",\"YSM\"],[\"YSM\",\"BNN\"],[\"BNN\",\"MGY\"],[\"MGY\",\"PAR\"],[\"PAR\",\"IRJ\"],[\"IRJ\",\"VDB\"],[\"VDB\",\"ANC\"],[\"ANC\",\"SAN\"],[\"SAN\",\"RDU\"],[\"RDU\",\"REF\"],[\"REF\",\"BWI\"],[\"BWI\",\"HNL\"],[\"HNL\",\"AAP\"],[\"AAP\",\"CVO\"],[\"CVO\",\"JIR\"],[\"JIR\",\"AIT\"],[\"AIT\",\"NEE\"],[\"NEE\",\"HIN\"],[\"HIN\",\"TPU\"],[\"TPU\",\"AHF\"],[\"AHF\",\"MSY\"],[\"MSY\",\"HFM\"],[\"HFM\",\"ATW\"],[\"ATW\",\"KKC\"],[\"KKC\",\"CFB\"],[\"CFB\",\"HPE\"],[\"HPE\",\"BPF\"],[\"BPF\",\"XWB\"],[\"XWB\",\"XVS\"],[\"XVS\",\"FKN\"],[\"FKN\",\"SMF\"],[\"SMF\",\"AIT\"],[\"AIT\",\"MDW\"],[\"MDW\",\"CRG\"],[\"CRG\",\"VRU\"],[\"VRU\",\"FGD\"],[\"FGD\",\"GJK\"],[\"GJK\",\"WSR\"],[\"WSR\",\"FLM\"],[\"FLM\",\"OFX\"],[\"OFX\",\"GVU\"],[\"GVU\",\"UGU\"],[\"UGU\",\"DFV\"],[\"DFV\",\"DEN\"],[\"DEN\",\"NRE\"],[\"NRE\",\"PDX\"],[\"PDX\",\"CWG\"],[\"CWG\",\"TLS\"],[\"TLS\",\"HSS\"],[\"HSS\",\"BQI\"],[\"BQI\",\"HSB\"],[\"HSB\",\"CGT\"],[\"CGT\",\"OFX\"],[\"OFX\",\"TBV\"],[\"TBV\",\"NAT\"],[\"NAT\",\"JGH\"],[\"JGH\",\"NBP\"],[\"NBP\",\"AIT\"],[\"AIT\",\"AKP\"],[\"AKP\",\"SRT\"],[\"SRT\",\"NBP\"],[\"NBP\",\"JGH\"],[\"JGH\",\"VDB\"],[\"VDB\",\"YXT\"],[\"YXT\",\"CLF\"],[\"CLF\",\"KKC\"],[\"KKC\",\"KLO\"],[\"KLO\",\"BWT\"],[\"BWT\",\"LBT\"],[\"LBT\",\"ODN\"],[\"ODN\",\"SMF\"],[\"SMF\",\"GHP\"],[\"GHP\",\"BQI\"],[\"BQI\",\"EXD\"],[\"EXD\",\"ODN\"],[\"ODN\",\"BWT\"],[\"BWT\",\"PDX\"],[\"PDX\",\"IRU\"],[\"IRU\",\"SMJ\"],[\"SMJ\",\"UBB\"],[\"UBB\",\"SIX\"],[\"SIX\",\"XVS\"],[\"XVS\",\"ATW\"],[\"ATW\",\"AAP\"],[\"AAP\",\"RDU\"],[\"RDU\",\"TBV\"],[\"TBV\",\"JCB\"],[\"JCB\",\"TBV\"],[\"TBV\",\"IWC\"],[\"IWC\",\"VTO\"]]\n```\n![image](https://github.com/mquintus/l33tcode-reload/assets/515945/2e6b511e-d801-4f2f-a232-61793fc892c6)"
                    },
                    {
                        "username": "chrisblueeyes",
                        "content": "lol this was a sample google interview question... this brilliant high schooler solved it!! using graphs, heres the video, no code just the theory\n\nhttps://www.youtube.com/watch?v=qz9tKlF431k"
                    },
                    {
                        "username": "realitant",
                        "content": "I think it's worthwhile to explicitly state if the tickets are unique or not.\nEDIT: To anyone else wondering, the tickets are not necessarily unique"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Note- There can be multiple same direction tickets between 2 cities."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Today\\'s question was easy \\uD83E\\uDEE1\\uD83E\\uDEE1\\n\\nhttps://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    }
                ]
            },
            {
                "id": 2057356,
                "content": [
                    {
                        "username": "Shivam_verma24",
                        "content": "Medium level sorting + DFS problem tagged hard"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "What is going on with this testcase?\n`tickets = [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]`\n\nMy output:\n`[\"ATL\",\"JFK\",\"ATL\"]`\n\nExpected:\n`[\"JFK\",\"ATL\",\"JFK\"]`\n\nEdit: I missed that you always start at JFK."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hints in increasing levels of spoilers: (Hints for this question are kind of hard to do unfortunately)\\n\\n1) Actually this is the biggest spoiler, but tbh I would just read the wikipedia page on Eulerian Paths. \\n\\n2) If you tried to construct a path and then failed because you didn\\'t hit every single node, is all of the work you did for nothing? Do you need to restart? or can you reuse the result you got somehow? \\nIs there any structure to the part you missed? "
                    },
                    {
                        "username": "z3eg",
                        "content": "and there goes my third hard problems solved completely by myself. ~300 lines of code and several hours of time and here we go! don\\'t give up, guys, this one doesnt seem to require some special approach, i solved it with a very very common one (surprisingly lol)"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This is a fun problem.  Here are a couple hints if you are stuck:\\n\\n* solving the lexical ordering problem first will increase the efficiency and ease of finding the final solution.\\n\\n* The relatively small amount of tickets opens up a solution method that could be extremely consumptive on large data sets. 1 <= tickets.length <= 300\\n\\nGood Luck!"
                    },
                    {
                        "username": "mstuebs",
                        "content": "I have found that for this challenge the leetcode solution might crash. I got a TLE for empty code for this testcase:\n```\n[[\"JFK\",\"KLO\"],[\"KLO\",\"VRU\"],[\"VRU\",\"JFK\"],[\"JFK\",\"IWC\"],[\"IWC\",\"EXD\"],[\"EXD\",\"VMC\"],[\"VMC\",\"EWR\"],[\"EWR\",\"PDS\"],[\"PDS\",\"PIT\"],[\"PIT\",\"YSM\"],[\"YSM\",\"HKO\"],[\"HKO\",\"RSW\"],[\"RSW\",\"HFM\"],[\"HFM\",\"HMN\"],[\"HMN\",\"IEM\"],[\"IEM\",\"MED\"],[\"MED\",\"NGX\"],[\"NGX\",\"FLL\"],[\"FLL\",\"BYC\"],[\"BYC\",\"SFO\"],[\"SFO\",\"XVS\"],[\"XVS\",\"FUQ\"],[\"FUQ\",\"XBK\"],[\"XBK\",\"DHW\"],[\"DHW\",\"YJO\"],[\"YJO\",\"ODN\"],[\"ODN\",\"XQT\"],[\"XQT\",\"ARH\"],[\"ARH\",\"DTW\"],[\"DTW\",\"MEI\"],[\"MEI\",\"DTW\"],[\"DTW\",\"GPP\"],[\"GPP\",\"WIE\"],[\"WIE\",\"ICJ\"],[\"ICJ\",\"VYX\"],[\"VYX\",\"TLS\"],[\"TLS\",\"NUB\"],[\"NUB\",\"YSM\"],[\"YSM\",\"CSD\"],[\"CSD\",\"CTI\"],[\"CTI\",\"LTU\"],[\"LTU\",\"YAE\"],[\"YAE\",\"KMO\"],[\"KMO\",\"AIT\"],[\"AIT\",\"IWC\"],[\"IWC\",\"OJB\"],[\"OJB\",\"DFV\"],[\"DFV\",\"HSS\"],[\"HSS\",\"EAN\"],[\"EAN\",\"SRT\"],[\"SRT\",\"BUF\"],[\"BUF\",\"EUH\"],[\"EUH\",\"KTE\"],[\"KTE\",\"TPA\"],[\"TPA\",\"SMF\"],[\"SMF\",\"AKP\"],[\"AKP\",\"MMB\"],[\"MMB\",\"TPA\"],[\"TPA\",\"VTO\"],[\"VTO\",\"LBT\"],[\"LBT\",\"GPP\"],[\"GPP\",\"KLO\"],[\"KLO\",\"LAX\"],[\"LAX\",\"MIA\"],[\"MIA\",\"LBT\"],[\"LBT\",\"THM\"],[\"THM\",\"WIB\"],[\"WIB\",\"ORO\"],[\"ORO\",\"IAD\"],[\"IAD\",\"GDP\"],[\"GDP\",\"HMN\"],[\"HMN\",\"CVO\"],[\"CVO\",\"LBT\"],[\"LBT\",\"UGU\"],[\"UGU\",\"HNL\"],[\"HNL\",\"JNQ\"],[\"JNQ\",\"YJO\"],[\"YJO\",\"UGU\"],[\"UGU\",\"ERQ\"],[\"ERQ\",\"XMP\"],[\"XMP\",\"DFF\"],[\"DFF\",\"BWI\"],[\"BWI\",\"MDW\"],[\"MDW\",\"XQT\"],[\"XQT\",\"PBI\"],[\"PBI\",\"IND\"],[\"IND\",\"MJN\"],[\"MJN\",\"SFO\"],[\"SFO\",\"RGS\"],[\"RGS\",\"NVP\"],[\"NVP\",\"LAS\"],[\"LAS\",\"KMO\"],[\"KMO\",\"RSW\"],[\"RSW\",\"HEW\"],[\"HEW\",\"NAT\"],[\"NAT\",\"SJU\"],[\"SJU\",\"FLM\"],[\"FLM\",\"DHL\"],[\"DHL\",\"LPI\"],[\"LPI\",\"QCD\"],[\"QCD\",\"HEW\"],[\"HEW\",\"MFN\"],[\"MFN\",\"YBC\"],[\"YBC\",\"CTX\"],[\"CTX\",\"IWC\"],[\"IWC\",\"BNG\"],[\"BNG\",\"QSH\"],[\"QSH\",\"ANC\"],[\"ANC\",\"EQC\"],[\"EQC\",\"MFN\"],[\"MFN\",\"FBW\"],[\"FBW\",\"NML\"],[\"NML\",\"AUR\"],[\"AUR\",\"LAS\"],[\"LAS\",\"EQC\"],[\"EQC\",\"KKC\"],[\"KKC\",\"LAS\"],[\"LAS\",\"QHN\"],[\"QHN\",\"MDW\"],[\"MDW\",\"KTL\"],[\"KTL\",\"BMQ\"],[\"BMQ\",\"UUH\"],[\"UUH\",\"VTO\"],[\"VTO\",\"CLF\"],[\"CLF\",\"XWB\"],[\"XWB\",\"JWA\"],[\"JWA\",\"STL\"],[\"STL\",\"BPF\"],[\"BPF\",\"MBD\"],[\"MBD\",\"HJT\"],[\"HJT\",\"UYU\"],[\"UYU\",\"HPE\"],[\"HPE\",\"VTO\"],[\"VTO\",\"OJB\"],[\"OJB\",\"SJU\"],[\"SJU\",\"MSY\"],[\"MSY\",\"QWV\"],[\"QWV\",\"OUC\"],[\"OUC\",\"XOY\"],[\"XOY\",\"GPW\"],[\"GPW\",\"OSC\"],[\"OSC\",\"MGL\"],[\"MGL\",\"VRF\"],[\"VRF\",\"XBK\"],[\"XBK\",\"PHL\"],[\"PHL\",\"QAW\"],[\"QAW\",\"YYQ\"],[\"YYQ\",\"BVI\"],[\"BVI\",\"LGA\"],[\"LGA\",\"VLT\"],[\"VLT\",\"UJJ\"],[\"UJJ\",\"BWI\"],[\"BWI\",\"LBT\"],[\"LBT\",\"DTW\"],[\"DTW\",\"MJN\"],[\"MJN\",\"HSS\"],[\"HSS\",\"OHW\"],[\"OHW\",\"BMT\"],[\"BMT\",\"IWC\"],[\"IWC\",\"UJJ\"],[\"UJJ\",\"PDS\"],[\"PDS\",\"EGK\"],[\"EGK\",\"TLS\"],[\"TLS\",\"SIX\"],[\"SIX\",\"AOT\"],[\"AOT\",\"SSH\"],[\"SSH\",\"VGK\"],[\"VGK\",\"JSF\"],[\"JSF\",\"GDP\"],[\"GDP\",\"BOL\"],[\"BOL\",\"JGH\"],[\"JGH\",\"IWC\"],[\"IWC\",\"AOX\"],[\"AOX\",\"FRI\"],[\"FRI\",\"LWV\"],[\"LWV\",\"PDX\"],[\"PDX\",\"STL\"],[\"STL\",\"AIT\"],[\"AIT\",\"CSD\"],[\"CSD\",\"SIX\"],[\"SIX\",\"BUF\"],[\"BUF\",\"VDB\"],[\"VDB\",\"XOY\"],[\"XOY\",\"TBV\"],[\"TBV\",\"BNG\"],[\"BNG\",\"HWF\"],[\"HWF\",\"LPI\"],[\"LPI\",\"JCB\"],[\"JCB\",\"DUI\"],[\"DUI\",\"IIK\"],[\"IIK\",\"YBC\"],[\"YBC\",\"VYX\"],[\"VYX\",\"YNS\"],[\"YNS\",\"BQH\"],[\"BQH\",\"WRM\"],[\"WRM\",\"SCY\"],[\"SCY\",\"DFY\"],[\"DFY\",\"BLC\"],[\"BLC\",\"PHX\"],[\"PHX\",\"DFY\"],[\"DFY\",\"BOS\"],[\"BOS\",\"WIB\"],[\"WIB\",\"SEA\"],[\"SEA\",\"THM\"],[\"THM\",\"TTY\"],[\"TTY\",\"HEW\"],[\"HEW\",\"YSM\"],[\"YSM\",\"BNN\"],[\"BNN\",\"MGY\"],[\"MGY\",\"PAR\"],[\"PAR\",\"IRJ\"],[\"IRJ\",\"VDB\"],[\"VDB\",\"ANC\"],[\"ANC\",\"SAN\"],[\"SAN\",\"RDU\"],[\"RDU\",\"REF\"],[\"REF\",\"BWI\"],[\"BWI\",\"HNL\"],[\"HNL\",\"AAP\"],[\"AAP\",\"CVO\"],[\"CVO\",\"JIR\"],[\"JIR\",\"AIT\"],[\"AIT\",\"NEE\"],[\"NEE\",\"HIN\"],[\"HIN\",\"TPU\"],[\"TPU\",\"AHF\"],[\"AHF\",\"MSY\"],[\"MSY\",\"HFM\"],[\"HFM\",\"ATW\"],[\"ATW\",\"KKC\"],[\"KKC\",\"CFB\"],[\"CFB\",\"HPE\"],[\"HPE\",\"BPF\"],[\"BPF\",\"XWB\"],[\"XWB\",\"XVS\"],[\"XVS\",\"FKN\"],[\"FKN\",\"SMF\"],[\"SMF\",\"AIT\"],[\"AIT\",\"MDW\"],[\"MDW\",\"CRG\"],[\"CRG\",\"VRU\"],[\"VRU\",\"FGD\"],[\"FGD\",\"GJK\"],[\"GJK\",\"WSR\"],[\"WSR\",\"FLM\"],[\"FLM\",\"OFX\"],[\"OFX\",\"GVU\"],[\"GVU\",\"UGU\"],[\"UGU\",\"DFV\"],[\"DFV\",\"DEN\"],[\"DEN\",\"NRE\"],[\"NRE\",\"PDX\"],[\"PDX\",\"CWG\"],[\"CWG\",\"TLS\"],[\"TLS\",\"HSS\"],[\"HSS\",\"BQI\"],[\"BQI\",\"HSB\"],[\"HSB\",\"CGT\"],[\"CGT\",\"OFX\"],[\"OFX\",\"TBV\"],[\"TBV\",\"NAT\"],[\"NAT\",\"JGH\"],[\"JGH\",\"NBP\"],[\"NBP\",\"AIT\"],[\"AIT\",\"AKP\"],[\"AKP\",\"SRT\"],[\"SRT\",\"NBP\"],[\"NBP\",\"JGH\"],[\"JGH\",\"VDB\"],[\"VDB\",\"YXT\"],[\"YXT\",\"CLF\"],[\"CLF\",\"KKC\"],[\"KKC\",\"KLO\"],[\"KLO\",\"BWT\"],[\"BWT\",\"LBT\"],[\"LBT\",\"ODN\"],[\"ODN\",\"SMF\"],[\"SMF\",\"GHP\"],[\"GHP\",\"BQI\"],[\"BQI\",\"EXD\"],[\"EXD\",\"ODN\"],[\"ODN\",\"BWT\"],[\"BWT\",\"PDX\"],[\"PDX\",\"IRU\"],[\"IRU\",\"SMJ\"],[\"SMJ\",\"UBB\"],[\"UBB\",\"SIX\"],[\"SIX\",\"XVS\"],[\"XVS\",\"ATW\"],[\"ATW\",\"AAP\"],[\"AAP\",\"RDU\"],[\"RDU\",\"TBV\"],[\"TBV\",\"JCB\"],[\"JCB\",\"TBV\"],[\"TBV\",\"IWC\"],[\"IWC\",\"VTO\"]]\n```\n![image](https://github.com/mquintus/l33tcode-reload/assets/515945/2e6b511e-d801-4f2f-a232-61793fc892c6)"
                    },
                    {
                        "username": "chrisblueeyes",
                        "content": "lol this was a sample google interview question... this brilliant high schooler solved it!! using graphs, heres the video, no code just the theory\n\nhttps://www.youtube.com/watch?v=qz9tKlF431k"
                    },
                    {
                        "username": "realitant",
                        "content": "I think it's worthwhile to explicitly state if the tickets are unique or not.\nEDIT: To anyone else wondering, the tickets are not necessarily unique"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Note- There can be multiple same direction tickets between 2 cities."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Today\\'s question was easy \\uD83E\\uDEE1\\uD83E\\uDEE1\\n\\nhttps://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    }
                ]
            },
            {
                "id": 2057325,
                "content": [
                    {
                        "username": "itsyeshu",
                        "content": "`tickets` can have mutiple `ticket [from, to]` with same `from` and `to`.\n\nExample :\n `tickets` = `[[\"EZE\",\"AXA\"]`,`[\"TIA\",\"ANU\"],[\"TIA\",\"ANU\"]`,`[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\n Check `[\"TIA\", \"ANU\"]` appears twice."
                    },
                    {
                        "username": "psionl0",
                        "content": "It looks like the choice for me is either cheat or give up my streak. This is an interesting problem and I will solve it eventually but 24 hours (less time for the biological world) is not enough for me."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I set up an adjacency matrix with the cities sorted in alphabetical order (except that \"JFK\" is first) and ran a dfs. This greedy approach doesn\\'t work so I need to add backtracking to the mix. I wasn\\'t aware that two cities can have multiple paths between them so this complicates things."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you will get there padawan!\ngraph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result."
                    },
                    {
                        "username": "anonymouss_01",
                        "content": "Think of Eulerian Path."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "End of my streak!!"
                    },
                    {
                        "username": "vinitabai",
                        "content": "Excellent problem to revise dfs. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "This will an easy problem if you know Hierholzer\\'s Algorithm for Euler Path/Circuit. Basically it is just naive dfs over edges, instead of nodes. You don\\'t need to check if given graph contains Euler Path/Circuit, because in the problem constraints it is said a vaild itinerary will always exist. Just create a graph from the given tickets (edges), use min heap inside hash-map to store the edges in lexicographical order for current node. Then just apply simple dfs and keep poping edges from the heap, whenever the current node is out of edges, add it to the beginning of the answer array. (Search for William Fiset\\'s video on Euler Paths/Circuits on yt)"
                    },
                    {
                        "username": "aitachii",
                        "content": "If you\\'re sorting the vertices connected to each vertex, is the time complexity `V * KlogK`?\\nwhere \\n`V = total number of vertices`\\n`K = number of vertices/destinations connected to a vertex`"
                    },
                    {
                        "username": "DilemmaRabbit",
                        "content": "Does every ticket [from, to] unique in testcase?\\nIs there have duplicate same ticket [from, to]? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All that the problem is asking you to do is traverse every edge in a graph while maintaining the tiniest lexicographic order possible. \nNote that there is always at least one solution. `Tip`"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Being a avigeek, I got excited after seeing code names of one of my favorite airports JFK,LHR,SFO <3"
                    }
                ]
            },
            {
                "id": 2057303,
                "content": [
                    {
                        "username": "itsyeshu",
                        "content": "`tickets` can have mutiple `ticket [from, to]` with same `from` and `to`.\n\nExample :\n `tickets` = `[[\"EZE\",\"AXA\"]`,`[\"TIA\",\"ANU\"],[\"TIA\",\"ANU\"]`,`[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\n Check `[\"TIA\", \"ANU\"]` appears twice."
                    },
                    {
                        "username": "psionl0",
                        "content": "It looks like the choice for me is either cheat or give up my streak. This is an interesting problem and I will solve it eventually but 24 hours (less time for the biological world) is not enough for me."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I set up an adjacency matrix with the cities sorted in alphabetical order (except that \"JFK\" is first) and ran a dfs. This greedy approach doesn\\'t work so I need to add backtracking to the mix. I wasn\\'t aware that two cities can have multiple paths between them so this complicates things."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you will get there padawan!\ngraph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result."
                    },
                    {
                        "username": "anonymouss_01",
                        "content": "Think of Eulerian Path."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "End of my streak!!"
                    },
                    {
                        "username": "vinitabai",
                        "content": "Excellent problem to revise dfs. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "This will an easy problem if you know Hierholzer\\'s Algorithm for Euler Path/Circuit. Basically it is just naive dfs over edges, instead of nodes. You don\\'t need to check if given graph contains Euler Path/Circuit, because in the problem constraints it is said a vaild itinerary will always exist. Just create a graph from the given tickets (edges), use min heap inside hash-map to store the edges in lexicographical order for current node. Then just apply simple dfs and keep poping edges from the heap, whenever the current node is out of edges, add it to the beginning of the answer array. (Search for William Fiset\\'s video on Euler Paths/Circuits on yt)"
                    },
                    {
                        "username": "aitachii",
                        "content": "If you\\'re sorting the vertices connected to each vertex, is the time complexity `V * KlogK`?\\nwhere \\n`V = total number of vertices`\\n`K = number of vertices/destinations connected to a vertex`"
                    },
                    {
                        "username": "DilemmaRabbit",
                        "content": "Does every ticket [from, to] unique in testcase?\\nIs there have duplicate same ticket [from, to]? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All that the problem is asking you to do is traverse every edge in a graph while maintaining the tiniest lexicographic order possible. \nNote that there is always at least one solution. `Tip`"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Being a avigeek, I got excited after seeing code names of one of my favorite airports JFK,LHR,SFO <3"
                    }
                ]
            },
            {
                "id": 2057196,
                "content": [
                    {
                        "username": "itsyeshu",
                        "content": "`tickets` can have mutiple `ticket [from, to]` with same `from` and `to`.\n\nExample :\n `tickets` = `[[\"EZE\",\"AXA\"]`,`[\"TIA\",\"ANU\"],[\"TIA\",\"ANU\"]`,`[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\n Check `[\"TIA\", \"ANU\"]` appears twice."
                    },
                    {
                        "username": "psionl0",
                        "content": "It looks like the choice for me is either cheat or give up my streak. This is an interesting problem and I will solve it eventually but 24 hours (less time for the biological world) is not enough for me."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I set up an adjacency matrix with the cities sorted in alphabetical order (except that \"JFK\" is first) and ran a dfs. This greedy approach doesn\\'t work so I need to add backtracking to the mix. I wasn\\'t aware that two cities can have multiple paths between them so this complicates things."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you will get there padawan!\ngraph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result."
                    },
                    {
                        "username": "anonymouss_01",
                        "content": "Think of Eulerian Path."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "End of my streak!!"
                    },
                    {
                        "username": "vinitabai",
                        "content": "Excellent problem to revise dfs. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "This will an easy problem if you know Hierholzer\\'s Algorithm for Euler Path/Circuit. Basically it is just naive dfs over edges, instead of nodes. You don\\'t need to check if given graph contains Euler Path/Circuit, because in the problem constraints it is said a vaild itinerary will always exist. Just create a graph from the given tickets (edges), use min heap inside hash-map to store the edges in lexicographical order for current node. Then just apply simple dfs and keep poping edges from the heap, whenever the current node is out of edges, add it to the beginning of the answer array. (Search for William Fiset\\'s video on Euler Paths/Circuits on yt)"
                    },
                    {
                        "username": "aitachii",
                        "content": "If you\\'re sorting the vertices connected to each vertex, is the time complexity `V * KlogK`?\\nwhere \\n`V = total number of vertices`\\n`K = number of vertices/destinations connected to a vertex`"
                    },
                    {
                        "username": "DilemmaRabbit",
                        "content": "Does every ticket [from, to] unique in testcase?\\nIs there have duplicate same ticket [from, to]? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All that the problem is asking you to do is traverse every edge in a graph while maintaining the tiniest lexicographic order possible. \nNote that there is always at least one solution. `Tip`"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Being a avigeek, I got excited after seeing code names of one of my favorite airports JFK,LHR,SFO <3"
                    }
                ]
            },
            {
                "id": 2057190,
                "content": [
                    {
                        "username": "itsyeshu",
                        "content": "`tickets` can have mutiple `ticket [from, to]` with same `from` and `to`.\n\nExample :\n `tickets` = `[[\"EZE\",\"AXA\"]`,`[\"TIA\",\"ANU\"],[\"TIA\",\"ANU\"]`,`[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\n Check `[\"TIA\", \"ANU\"]` appears twice."
                    },
                    {
                        "username": "psionl0",
                        "content": "It looks like the choice for me is either cheat or give up my streak. This is an interesting problem and I will solve it eventually but 24 hours (less time for the biological world) is not enough for me."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I set up an adjacency matrix with the cities sorted in alphabetical order (except that \"JFK\" is first) and ran a dfs. This greedy approach doesn\\'t work so I need to add backtracking to the mix. I wasn\\'t aware that two cities can have multiple paths between them so this complicates things."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you will get there padawan!\ngraph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result."
                    },
                    {
                        "username": "anonymouss_01",
                        "content": "Think of Eulerian Path."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "End of my streak!!"
                    },
                    {
                        "username": "vinitabai",
                        "content": "Excellent problem to revise dfs. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "This will an easy problem if you know Hierholzer\\'s Algorithm for Euler Path/Circuit. Basically it is just naive dfs over edges, instead of nodes. You don\\'t need to check if given graph contains Euler Path/Circuit, because in the problem constraints it is said a vaild itinerary will always exist. Just create a graph from the given tickets (edges), use min heap inside hash-map to store the edges in lexicographical order for current node. Then just apply simple dfs and keep poping edges from the heap, whenever the current node is out of edges, add it to the beginning of the answer array. (Search for William Fiset\\'s video on Euler Paths/Circuits on yt)"
                    },
                    {
                        "username": "aitachii",
                        "content": "If you\\'re sorting the vertices connected to each vertex, is the time complexity `V * KlogK`?\\nwhere \\n`V = total number of vertices`\\n`K = number of vertices/destinations connected to a vertex`"
                    },
                    {
                        "username": "DilemmaRabbit",
                        "content": "Does every ticket [from, to] unique in testcase?\\nIs there have duplicate same ticket [from, to]? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All that the problem is asking you to do is traverse every edge in a graph while maintaining the tiniest lexicographic order possible. \nNote that there is always at least one solution. `Tip`"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Being a avigeek, I got excited after seeing code names of one of my favorite airports JFK,LHR,SFO <3"
                    }
                ]
            },
            {
                "id": 2057184,
                "content": [
                    {
                        "username": "itsyeshu",
                        "content": "`tickets` can have mutiple `ticket [from, to]` with same `from` and `to`.\n\nExample :\n `tickets` = `[[\"EZE\",\"AXA\"]`,`[\"TIA\",\"ANU\"],[\"TIA\",\"ANU\"]`,`[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\n Check `[\"TIA\", \"ANU\"]` appears twice."
                    },
                    {
                        "username": "psionl0",
                        "content": "It looks like the choice for me is either cheat or give up my streak. This is an interesting problem and I will solve it eventually but 24 hours (less time for the biological world) is not enough for me."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I set up an adjacency matrix with the cities sorted in alphabetical order (except that \"JFK\" is first) and ran a dfs. This greedy approach doesn\\'t work so I need to add backtracking to the mix. I wasn\\'t aware that two cities can have multiple paths between them so this complicates things."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you will get there padawan!\ngraph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result."
                    },
                    {
                        "username": "anonymouss_01",
                        "content": "Think of Eulerian Path."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "End of my streak!!"
                    },
                    {
                        "username": "vinitabai",
                        "content": "Excellent problem to revise dfs. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "This will an easy problem if you know Hierholzer\\'s Algorithm for Euler Path/Circuit. Basically it is just naive dfs over edges, instead of nodes. You don\\'t need to check if given graph contains Euler Path/Circuit, because in the problem constraints it is said a vaild itinerary will always exist. Just create a graph from the given tickets (edges), use min heap inside hash-map to store the edges in lexicographical order for current node. Then just apply simple dfs and keep poping edges from the heap, whenever the current node is out of edges, add it to the beginning of the answer array. (Search for William Fiset\\'s video on Euler Paths/Circuits on yt)"
                    },
                    {
                        "username": "aitachii",
                        "content": "If you\\'re sorting the vertices connected to each vertex, is the time complexity `V * KlogK`?\\nwhere \\n`V = total number of vertices`\\n`K = number of vertices/destinations connected to a vertex`"
                    },
                    {
                        "username": "DilemmaRabbit",
                        "content": "Does every ticket [from, to] unique in testcase?\\nIs there have duplicate same ticket [from, to]? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All that the problem is asking you to do is traverse every edge in a graph while maintaining the tiniest lexicographic order possible. \nNote that there is always at least one solution. `Tip`"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Being a avigeek, I got excited after seeing code names of one of my favorite airports JFK,LHR,SFO <3"
                    }
                ]
            },
            {
                "id": 2057181,
                "content": [
                    {
                        "username": "itsyeshu",
                        "content": "`tickets` can have mutiple `ticket [from, to]` with same `from` and `to`.\n\nExample :\n `tickets` = `[[\"EZE\",\"AXA\"]`,`[\"TIA\",\"ANU\"],[\"TIA\",\"ANU\"]`,`[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\n Check `[\"TIA\", \"ANU\"]` appears twice."
                    },
                    {
                        "username": "psionl0",
                        "content": "It looks like the choice for me is either cheat or give up my streak. This is an interesting problem and I will solve it eventually but 24 hours (less time for the biological world) is not enough for me."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I set up an adjacency matrix with the cities sorted in alphabetical order (except that \"JFK\" is first) and ran a dfs. This greedy approach doesn\\'t work so I need to add backtracking to the mix. I wasn\\'t aware that two cities can have multiple paths between them so this complicates things."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you will get there padawan!\ngraph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result."
                    },
                    {
                        "username": "anonymouss_01",
                        "content": "Think of Eulerian Path."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "End of my streak!!"
                    },
                    {
                        "username": "vinitabai",
                        "content": "Excellent problem to revise dfs. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "This will an easy problem if you know Hierholzer\\'s Algorithm for Euler Path/Circuit. Basically it is just naive dfs over edges, instead of nodes. You don\\'t need to check if given graph contains Euler Path/Circuit, because in the problem constraints it is said a vaild itinerary will always exist. Just create a graph from the given tickets (edges), use min heap inside hash-map to store the edges in lexicographical order for current node. Then just apply simple dfs and keep poping edges from the heap, whenever the current node is out of edges, add it to the beginning of the answer array. (Search for William Fiset\\'s video on Euler Paths/Circuits on yt)"
                    },
                    {
                        "username": "aitachii",
                        "content": "If you\\'re sorting the vertices connected to each vertex, is the time complexity `V * KlogK`?\\nwhere \\n`V = total number of vertices`\\n`K = number of vertices/destinations connected to a vertex`"
                    },
                    {
                        "username": "DilemmaRabbit",
                        "content": "Does every ticket [from, to] unique in testcase?\\nIs there have duplicate same ticket [from, to]? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All that the problem is asking you to do is traverse every edge in a graph while maintaining the tiniest lexicographic order possible. \nNote that there is always at least one solution. `Tip`"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Being a avigeek, I got excited after seeing code names of one of my favorite airports JFK,LHR,SFO <3"
                    }
                ]
            },
            {
                "id": 2057165,
                "content": [
                    {
                        "username": "itsyeshu",
                        "content": "`tickets` can have mutiple `ticket [from, to]` with same `from` and `to`.\n\nExample :\n `tickets` = `[[\"EZE\",\"AXA\"]`,`[\"TIA\",\"ANU\"],[\"TIA\",\"ANU\"]`,`[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\n Check `[\"TIA\", \"ANU\"]` appears twice."
                    },
                    {
                        "username": "psionl0",
                        "content": "It looks like the choice for me is either cheat or give up my streak. This is an interesting problem and I will solve it eventually but 24 hours (less time for the biological world) is not enough for me."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I set up an adjacency matrix with the cities sorted in alphabetical order (except that \"JFK\" is first) and ran a dfs. This greedy approach doesn\\'t work so I need to add backtracking to the mix. I wasn\\'t aware that two cities can have multiple paths between them so this complicates things."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you will get there padawan!\ngraph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result."
                    },
                    {
                        "username": "anonymouss_01",
                        "content": "Think of Eulerian Path."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "End of my streak!!"
                    },
                    {
                        "username": "vinitabai",
                        "content": "Excellent problem to revise dfs. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "This will an easy problem if you know Hierholzer\\'s Algorithm for Euler Path/Circuit. Basically it is just naive dfs over edges, instead of nodes. You don\\'t need to check if given graph contains Euler Path/Circuit, because in the problem constraints it is said a vaild itinerary will always exist. Just create a graph from the given tickets (edges), use min heap inside hash-map to store the edges in lexicographical order for current node. Then just apply simple dfs and keep poping edges from the heap, whenever the current node is out of edges, add it to the beginning of the answer array. (Search for William Fiset\\'s video on Euler Paths/Circuits on yt)"
                    },
                    {
                        "username": "aitachii",
                        "content": "If you\\'re sorting the vertices connected to each vertex, is the time complexity `V * KlogK`?\\nwhere \\n`V = total number of vertices`\\n`K = number of vertices/destinations connected to a vertex`"
                    },
                    {
                        "username": "DilemmaRabbit",
                        "content": "Does every ticket [from, to] unique in testcase?\\nIs there have duplicate same ticket [from, to]? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All that the problem is asking you to do is traverse every edge in a graph while maintaining the tiniest lexicographic order possible. \nNote that there is always at least one solution. `Tip`"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Being a avigeek, I got excited after seeing code names of one of my favorite airports JFK,LHR,SFO <3"
                    }
                ]
            },
            {
                "id": 2057161,
                "content": [
                    {
                        "username": "itsyeshu",
                        "content": "`tickets` can have mutiple `ticket [from, to]` with same `from` and `to`.\n\nExample :\n `tickets` = `[[\"EZE\",\"AXA\"]`,`[\"TIA\",\"ANU\"],[\"TIA\",\"ANU\"]`,`[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\n Check `[\"TIA\", \"ANU\"]` appears twice."
                    },
                    {
                        "username": "psionl0",
                        "content": "It looks like the choice for me is either cheat or give up my streak. This is an interesting problem and I will solve it eventually but 24 hours (less time for the biological world) is not enough for me."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I set up an adjacency matrix with the cities sorted in alphabetical order (except that \"JFK\" is first) and ran a dfs. This greedy approach doesn\\'t work so I need to add backtracking to the mix. I wasn\\'t aware that two cities can have multiple paths between them so this complicates things."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you will get there padawan!\ngraph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result."
                    },
                    {
                        "username": "anonymouss_01",
                        "content": "Think of Eulerian Path."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "End of my streak!!"
                    },
                    {
                        "username": "vinitabai",
                        "content": "Excellent problem to revise dfs. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "This will an easy problem if you know Hierholzer\\'s Algorithm for Euler Path/Circuit. Basically it is just naive dfs over edges, instead of nodes. You don\\'t need to check if given graph contains Euler Path/Circuit, because in the problem constraints it is said a vaild itinerary will always exist. Just create a graph from the given tickets (edges), use min heap inside hash-map to store the edges in lexicographical order for current node. Then just apply simple dfs and keep poping edges from the heap, whenever the current node is out of edges, add it to the beginning of the answer array. (Search for William Fiset\\'s video on Euler Paths/Circuits on yt)"
                    },
                    {
                        "username": "aitachii",
                        "content": "If you\\'re sorting the vertices connected to each vertex, is the time complexity `V * KlogK`?\\nwhere \\n`V = total number of vertices`\\n`K = number of vertices/destinations connected to a vertex`"
                    },
                    {
                        "username": "DilemmaRabbit",
                        "content": "Does every ticket [from, to] unique in testcase?\\nIs there have duplicate same ticket [from, to]? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All that the problem is asking you to do is traverse every edge in a graph while maintaining the tiniest lexicographic order possible. \nNote that there is always at least one solution. `Tip`"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Being a avigeek, I got excited after seeing code names of one of my favorite airports JFK,LHR,SFO <3"
                    }
                ]
            },
            {
                "id": 2057154,
                "content": [
                    {
                        "username": "itsyeshu",
                        "content": "`tickets` can have mutiple `ticket [from, to]` with same `from` and `to`.\n\nExample :\n `tickets` = `[[\"EZE\",\"AXA\"]`,`[\"TIA\",\"ANU\"],[\"TIA\",\"ANU\"]`,`[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\n Check `[\"TIA\", \"ANU\"]` appears twice."
                    },
                    {
                        "username": "psionl0",
                        "content": "It looks like the choice for me is either cheat or give up my streak. This is an interesting problem and I will solve it eventually but 24 hours (less time for the biological world) is not enough for me."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I set up an adjacency matrix with the cities sorted in alphabetical order (except that \"JFK\" is first) and ran a dfs. This greedy approach doesn\\'t work so I need to add backtracking to the mix. I wasn\\'t aware that two cities can have multiple paths between them so this complicates things."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you will get there padawan!\ngraph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result."
                    },
                    {
                        "username": "anonymouss_01",
                        "content": "Think of Eulerian Path."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "End of my streak!!"
                    },
                    {
                        "username": "vinitabai",
                        "content": "Excellent problem to revise dfs. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "This will an easy problem if you know Hierholzer\\'s Algorithm for Euler Path/Circuit. Basically it is just naive dfs over edges, instead of nodes. You don\\'t need to check if given graph contains Euler Path/Circuit, because in the problem constraints it is said a vaild itinerary will always exist. Just create a graph from the given tickets (edges), use min heap inside hash-map to store the edges in lexicographical order for current node. Then just apply simple dfs and keep poping edges from the heap, whenever the current node is out of edges, add it to the beginning of the answer array. (Search for William Fiset\\'s video on Euler Paths/Circuits on yt)"
                    },
                    {
                        "username": "aitachii",
                        "content": "If you\\'re sorting the vertices connected to each vertex, is the time complexity `V * KlogK`?\\nwhere \\n`V = total number of vertices`\\n`K = number of vertices/destinations connected to a vertex`"
                    },
                    {
                        "username": "DilemmaRabbit",
                        "content": "Does every ticket [from, to] unique in testcase?\\nIs there have duplicate same ticket [from, to]? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All that the problem is asking you to do is traverse every edge in a graph while maintaining the tiniest lexicographic order possible. \nNote that there is always at least one solution. `Tip`"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Being a avigeek, I got excited after seeing code names of one of my favorite airports JFK,LHR,SFO <3"
                    }
                ]
            },
            {
                "id": 2057065,
                "content": [
                    {
                        "username": "itsyeshu",
                        "content": "`tickets` can have mutiple `ticket [from, to]` with same `from` and `to`.\n\nExample :\n `tickets` = `[[\"EZE\",\"AXA\"]`,`[\"TIA\",\"ANU\"],[\"TIA\",\"ANU\"]`,`[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\n Check `[\"TIA\", \"ANU\"]` appears twice."
                    },
                    {
                        "username": "psionl0",
                        "content": "It looks like the choice for me is either cheat or give up my streak. This is an interesting problem and I will solve it eventually but 24 hours (less time for the biological world) is not enough for me."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I set up an adjacency matrix with the cities sorted in alphabetical order (except that \"JFK\" is first) and ran a dfs. This greedy approach doesn\\'t work so I need to add backtracking to the mix. I wasn\\'t aware that two cities can have multiple paths between them so this complicates things."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you will get there padawan!\ngraph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result."
                    },
                    {
                        "username": "anonymouss_01",
                        "content": "Think of Eulerian Path."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "End of my streak!!"
                    },
                    {
                        "username": "vinitabai",
                        "content": "Excellent problem to revise dfs. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "This will an easy problem if you know Hierholzer\\'s Algorithm for Euler Path/Circuit. Basically it is just naive dfs over edges, instead of nodes. You don\\'t need to check if given graph contains Euler Path/Circuit, because in the problem constraints it is said a vaild itinerary will always exist. Just create a graph from the given tickets (edges), use min heap inside hash-map to store the edges in lexicographical order for current node. Then just apply simple dfs and keep poping edges from the heap, whenever the current node is out of edges, add it to the beginning of the answer array. (Search for William Fiset\\'s video on Euler Paths/Circuits on yt)"
                    },
                    {
                        "username": "aitachii",
                        "content": "If you\\'re sorting the vertices connected to each vertex, is the time complexity `V * KlogK`?\\nwhere \\n`V = total number of vertices`\\n`K = number of vertices/destinations connected to a vertex`"
                    },
                    {
                        "username": "DilemmaRabbit",
                        "content": "Does every ticket [from, to] unique in testcase?\\nIs there have duplicate same ticket [from, to]? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All that the problem is asking you to do is traverse every edge in a graph while maintaining the tiniest lexicographic order possible. \nNote that there is always at least one solution. `Tip`"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Being a avigeek, I got excited after seeing code names of one of my favorite airports JFK,LHR,SFO <3"
                    }
                ]
            },
            {
                "id": 2057006,
                "content": [
                    {
                        "username": "saumyagupta1",
                        "content": "aayein? baigan"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I\\'m so scared"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "plz check for understanding question and getting answer\\nhttps://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "harsha335",
                        "content": "Can anyone help me out ... i can\\'t get this test case\\nInput\\ntickets =\\n[[\"EZE\",\"TIA\"],[\"EZE\",\"AXA\"],[\"AUA\",\"EZE\"],[\"EZE\",\"JFK\"],[\"JFK\",\"ANU\"],[\"JFK\",\"ANU\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AUA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"EZE\"],[\"ANU\",\"EZE\"],[\"TIA\",\"AUA\"]]\\n\\nOutput\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"TIA\",\"JFK\",\"ANU\",\"EZE\",\"JFK\",\"AUA\"]\\nExpected\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"JFK\",\"ANU\",\"EZE\",\"TIA\",\"JFK\",\"AUA\"]"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Expected answer is lexicographically smaller than yours, that\\'s why."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I give up without even trying and feeling relaxed \\uD83E\\uDD71"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Why? It\\'s only Thursday."
                    },
                    {
                        "username": "___lovesh1808___",
                        "content": "what in the leetcode is this"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to solve this with best time complexity as well as space complexity solution"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Because you have to use every ticket one time, the length of a valid itinerary will be equal to the length of tickets + 1. If you always try using the lexically shortest destinations first, then your first time reaching an itinerary of length (tickets.Length + 1) will be your answer."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "can anyone give their intuition or  some hint"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@wentland](/wentland) Can u please explain the time complexity of this ?"
                    },
                    {
                        "username": "wentland",
                        "content": "Build a list of possible destinations for each airport. Sort the lists in lexical order. Then try traversing through by picking the first element in the array and removing it. If it doesn\\'t work then add it back to the array and go to the next element. Continue until you get a success. "
                    }
                ]
            },
            {
                "id": 2056913,
                "content": [
                    {
                        "username": "saumyagupta1",
                        "content": "aayein? baigan"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I\\'m so scared"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "plz check for understanding question and getting answer\\nhttps://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "harsha335",
                        "content": "Can anyone help me out ... i can\\'t get this test case\\nInput\\ntickets =\\n[[\"EZE\",\"TIA\"],[\"EZE\",\"AXA\"],[\"AUA\",\"EZE\"],[\"EZE\",\"JFK\"],[\"JFK\",\"ANU\"],[\"JFK\",\"ANU\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AUA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"EZE\"],[\"ANU\",\"EZE\"],[\"TIA\",\"AUA\"]]\\n\\nOutput\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"TIA\",\"JFK\",\"ANU\",\"EZE\",\"JFK\",\"AUA\"]\\nExpected\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"JFK\",\"ANU\",\"EZE\",\"TIA\",\"JFK\",\"AUA\"]"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Expected answer is lexicographically smaller than yours, that\\'s why."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I give up without even trying and feeling relaxed \\uD83E\\uDD71"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Why? It\\'s only Thursday."
                    },
                    {
                        "username": "___lovesh1808___",
                        "content": "what in the leetcode is this"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to solve this with best time complexity as well as space complexity solution"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Because you have to use every ticket one time, the length of a valid itinerary will be equal to the length of tickets + 1. If you always try using the lexically shortest destinations first, then your first time reaching an itinerary of length (tickets.Length + 1) will be your answer."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "can anyone give their intuition or  some hint"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@wentland](/wentland) Can u please explain the time complexity of this ?"
                    },
                    {
                        "username": "wentland",
                        "content": "Build a list of possible destinations for each airport. Sort the lists in lexical order. Then try traversing through by picking the first element in the array and removing it. If it doesn\\'t work then add it back to the array and go to the next element. Continue until you get a success. "
                    }
                ]
            },
            {
                "id": 2056895,
                "content": [
                    {
                        "username": "saumyagupta1",
                        "content": "aayein? baigan"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I\\'m so scared"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "plz check for understanding question and getting answer\\nhttps://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "harsha335",
                        "content": "Can anyone help me out ... i can\\'t get this test case\\nInput\\ntickets =\\n[[\"EZE\",\"TIA\"],[\"EZE\",\"AXA\"],[\"AUA\",\"EZE\"],[\"EZE\",\"JFK\"],[\"JFK\",\"ANU\"],[\"JFK\",\"ANU\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AUA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"EZE\"],[\"ANU\",\"EZE\"],[\"TIA\",\"AUA\"]]\\n\\nOutput\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"TIA\",\"JFK\",\"ANU\",\"EZE\",\"JFK\",\"AUA\"]\\nExpected\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"JFK\",\"ANU\",\"EZE\",\"TIA\",\"JFK\",\"AUA\"]"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Expected answer is lexicographically smaller than yours, that\\'s why."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I give up without even trying and feeling relaxed \\uD83E\\uDD71"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Why? It\\'s only Thursday."
                    },
                    {
                        "username": "___lovesh1808___",
                        "content": "what in the leetcode is this"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to solve this with best time complexity as well as space complexity solution"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Because you have to use every ticket one time, the length of a valid itinerary will be equal to the length of tickets + 1. If you always try using the lexically shortest destinations first, then your first time reaching an itinerary of length (tickets.Length + 1) will be your answer."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "can anyone give their intuition or  some hint"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@wentland](/wentland) Can u please explain the time complexity of this ?"
                    },
                    {
                        "username": "wentland",
                        "content": "Build a list of possible destinations for each airport. Sort the lists in lexical order. Then try traversing through by picking the first element in the array and removing it. If it doesn\\'t work then add it back to the array and go to the next element. Continue until you get a success. "
                    }
                ]
            },
            {
                "id": 2056887,
                "content": [
                    {
                        "username": "saumyagupta1",
                        "content": "aayein? baigan"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I\\'m so scared"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "plz check for understanding question and getting answer\\nhttps://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "harsha335",
                        "content": "Can anyone help me out ... i can\\'t get this test case\\nInput\\ntickets =\\n[[\"EZE\",\"TIA\"],[\"EZE\",\"AXA\"],[\"AUA\",\"EZE\"],[\"EZE\",\"JFK\"],[\"JFK\",\"ANU\"],[\"JFK\",\"ANU\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AUA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"EZE\"],[\"ANU\",\"EZE\"],[\"TIA\",\"AUA\"]]\\n\\nOutput\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"TIA\",\"JFK\",\"ANU\",\"EZE\",\"JFK\",\"AUA\"]\\nExpected\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"JFK\",\"ANU\",\"EZE\",\"TIA\",\"JFK\",\"AUA\"]"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Expected answer is lexicographically smaller than yours, that\\'s why."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I give up without even trying and feeling relaxed \\uD83E\\uDD71"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Why? It\\'s only Thursday."
                    },
                    {
                        "username": "___lovesh1808___",
                        "content": "what in the leetcode is this"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to solve this with best time complexity as well as space complexity solution"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Because you have to use every ticket one time, the length of a valid itinerary will be equal to the length of tickets + 1. If you always try using the lexically shortest destinations first, then your first time reaching an itinerary of length (tickets.Length + 1) will be your answer."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "can anyone give their intuition or  some hint"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@wentland](/wentland) Can u please explain the time complexity of this ?"
                    },
                    {
                        "username": "wentland",
                        "content": "Build a list of possible destinations for each airport. Sort the lists in lexical order. Then try traversing through by picking the first element in the array and removing it. If it doesn\\'t work then add it back to the array and go to the next element. Continue until you get a success. "
                    }
                ]
            },
            {
                "id": 2056886,
                "content": [
                    {
                        "username": "saumyagupta1",
                        "content": "aayein? baigan"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I\\'m so scared"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "plz check for understanding question and getting answer\\nhttps://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "harsha335",
                        "content": "Can anyone help me out ... i can\\'t get this test case\\nInput\\ntickets =\\n[[\"EZE\",\"TIA\"],[\"EZE\",\"AXA\"],[\"AUA\",\"EZE\"],[\"EZE\",\"JFK\"],[\"JFK\",\"ANU\"],[\"JFK\",\"ANU\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AUA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"EZE\"],[\"ANU\",\"EZE\"],[\"TIA\",\"AUA\"]]\\n\\nOutput\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"TIA\",\"JFK\",\"ANU\",\"EZE\",\"JFK\",\"AUA\"]\\nExpected\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"JFK\",\"ANU\",\"EZE\",\"TIA\",\"JFK\",\"AUA\"]"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Expected answer is lexicographically smaller than yours, that\\'s why."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I give up without even trying and feeling relaxed \\uD83E\\uDD71"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Why? It\\'s only Thursday."
                    },
                    {
                        "username": "___lovesh1808___",
                        "content": "what in the leetcode is this"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to solve this with best time complexity as well as space complexity solution"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Because you have to use every ticket one time, the length of a valid itinerary will be equal to the length of tickets + 1. If you always try using the lexically shortest destinations first, then your first time reaching an itinerary of length (tickets.Length + 1) will be your answer."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "can anyone give their intuition or  some hint"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@wentland](/wentland) Can u please explain the time complexity of this ?"
                    },
                    {
                        "username": "wentland",
                        "content": "Build a list of possible destinations for each airport. Sort the lists in lexical order. Then try traversing through by picking the first element in the array and removing it. If it doesn\\'t work then add it back to the array and go to the next element. Continue until you get a success. "
                    }
                ]
            },
            {
                "id": 2056821,
                "content": [
                    {
                        "username": "saumyagupta1",
                        "content": "aayein? baigan"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I\\'m so scared"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "plz check for understanding question and getting answer\\nhttps://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "harsha335",
                        "content": "Can anyone help me out ... i can\\'t get this test case\\nInput\\ntickets =\\n[[\"EZE\",\"TIA\"],[\"EZE\",\"AXA\"],[\"AUA\",\"EZE\"],[\"EZE\",\"JFK\"],[\"JFK\",\"ANU\"],[\"JFK\",\"ANU\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AUA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"EZE\"],[\"ANU\",\"EZE\"],[\"TIA\",\"AUA\"]]\\n\\nOutput\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"TIA\",\"JFK\",\"ANU\",\"EZE\",\"JFK\",\"AUA\"]\\nExpected\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"JFK\",\"ANU\",\"EZE\",\"TIA\",\"JFK\",\"AUA\"]"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Expected answer is lexicographically smaller than yours, that\\'s why."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I give up without even trying and feeling relaxed \\uD83E\\uDD71"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Why? It\\'s only Thursday."
                    },
                    {
                        "username": "___lovesh1808___",
                        "content": "what in the leetcode is this"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to solve this with best time complexity as well as space complexity solution"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Because you have to use every ticket one time, the length of a valid itinerary will be equal to the length of tickets + 1. If you always try using the lexically shortest destinations first, then your first time reaching an itinerary of length (tickets.Length + 1) will be your answer."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "can anyone give their intuition or  some hint"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@wentland](/wentland) Can u please explain the time complexity of this ?"
                    },
                    {
                        "username": "wentland",
                        "content": "Build a list of possible destinations for each airport. Sort the lists in lexical order. Then try traversing through by picking the first element in the array and removing it. If it doesn\\'t work then add it back to the array and go to the next element. Continue until you get a success. "
                    }
                ]
            },
            {
                "id": 2056780,
                "content": [
                    {
                        "username": "saumyagupta1",
                        "content": "aayein? baigan"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I\\'m so scared"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "plz check for understanding question and getting answer\\nhttps://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "harsha335",
                        "content": "Can anyone help me out ... i can\\'t get this test case\\nInput\\ntickets =\\n[[\"EZE\",\"TIA\"],[\"EZE\",\"AXA\"],[\"AUA\",\"EZE\"],[\"EZE\",\"JFK\"],[\"JFK\",\"ANU\"],[\"JFK\",\"ANU\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AUA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"EZE\"],[\"ANU\",\"EZE\"],[\"TIA\",\"AUA\"]]\\n\\nOutput\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"TIA\",\"JFK\",\"ANU\",\"EZE\",\"JFK\",\"AUA\"]\\nExpected\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"JFK\",\"ANU\",\"EZE\",\"TIA\",\"JFK\",\"AUA\"]"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Expected answer is lexicographically smaller than yours, that\\'s why."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I give up without even trying and feeling relaxed \\uD83E\\uDD71"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Why? It\\'s only Thursday."
                    },
                    {
                        "username": "___lovesh1808___",
                        "content": "what in the leetcode is this"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to solve this with best time complexity as well as space complexity solution"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Because you have to use every ticket one time, the length of a valid itinerary will be equal to the length of tickets + 1. If you always try using the lexically shortest destinations first, then your first time reaching an itinerary of length (tickets.Length + 1) will be your answer."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "can anyone give their intuition or  some hint"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@wentland](/wentland) Can u please explain the time complexity of this ?"
                    },
                    {
                        "username": "wentland",
                        "content": "Build a list of possible destinations for each airport. Sort the lists in lexical order. Then try traversing through by picking the first element in the array and removing it. If it doesn\\'t work then add it back to the array and go to the next element. Continue until you get a success. "
                    }
                ]
            },
            {
                "id": 2056763,
                "content": [
                    {
                        "username": "saumyagupta1",
                        "content": "aayein? baigan"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I\\'m so scared"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "plz check for understanding question and getting answer\\nhttps://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "harsha335",
                        "content": "Can anyone help me out ... i can\\'t get this test case\\nInput\\ntickets =\\n[[\"EZE\",\"TIA\"],[\"EZE\",\"AXA\"],[\"AUA\",\"EZE\"],[\"EZE\",\"JFK\"],[\"JFK\",\"ANU\"],[\"JFK\",\"ANU\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AUA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"EZE\"],[\"ANU\",\"EZE\"],[\"TIA\",\"AUA\"]]\\n\\nOutput\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"TIA\",\"JFK\",\"ANU\",\"EZE\",\"JFK\",\"AUA\"]\\nExpected\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"JFK\",\"ANU\",\"EZE\",\"TIA\",\"JFK\",\"AUA\"]"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Expected answer is lexicographically smaller than yours, that\\'s why."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I give up without even trying and feeling relaxed \\uD83E\\uDD71"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Why? It\\'s only Thursday."
                    },
                    {
                        "username": "___lovesh1808___",
                        "content": "what in the leetcode is this"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to solve this with best time complexity as well as space complexity solution"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Because you have to use every ticket one time, the length of a valid itinerary will be equal to the length of tickets + 1. If you always try using the lexically shortest destinations first, then your first time reaching an itinerary of length (tickets.Length + 1) will be your answer."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "can anyone give their intuition or  some hint"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@wentland](/wentland) Can u please explain the time complexity of this ?"
                    },
                    {
                        "username": "wentland",
                        "content": "Build a list of possible destinations for each airport. Sort the lists in lexical order. Then try traversing through by picking the first element in the array and removing it. If it doesn\\'t work then add it back to the array and go to the next element. Continue until you get a success. "
                    }
                ]
            },
            {
                "id": 2056749,
                "content": [
                    {
                        "username": "saumyagupta1",
                        "content": "aayein? baigan"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I\\'m so scared"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "plz check for understanding question and getting answer\\nhttps://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "harsha335",
                        "content": "Can anyone help me out ... i can\\'t get this test case\\nInput\\ntickets =\\n[[\"EZE\",\"TIA\"],[\"EZE\",\"AXA\"],[\"AUA\",\"EZE\"],[\"EZE\",\"JFK\"],[\"JFK\",\"ANU\"],[\"JFK\",\"ANU\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AUA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"EZE\"],[\"ANU\",\"EZE\"],[\"TIA\",\"AUA\"]]\\n\\nOutput\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"TIA\",\"JFK\",\"ANU\",\"EZE\",\"JFK\",\"AUA\"]\\nExpected\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"JFK\",\"ANU\",\"EZE\",\"TIA\",\"JFK\",\"AUA\"]"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Expected answer is lexicographically smaller than yours, that\\'s why."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I give up without even trying and feeling relaxed \\uD83E\\uDD71"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Why? It\\'s only Thursday."
                    },
                    {
                        "username": "___lovesh1808___",
                        "content": "what in the leetcode is this"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to solve this with best time complexity as well as space complexity solution"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Because you have to use every ticket one time, the length of a valid itinerary will be equal to the length of tickets + 1. If you always try using the lexically shortest destinations first, then your first time reaching an itinerary of length (tickets.Length + 1) will be your answer."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "can anyone give their intuition or  some hint"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@wentland](/wentland) Can u please explain the time complexity of this ?"
                    },
                    {
                        "username": "wentland",
                        "content": "Build a list of possible destinations for each airport. Sort the lists in lexical order. Then try traversing through by picking the first element in the array and removing it. If it doesn\\'t work then add it back to the array and go to the next element. Continue until you get a success. "
                    }
                ]
            },
            {
                "id": 2056723,
                "content": [
                    {
                        "username": "saumyagupta1",
                        "content": "aayein? baigan"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I\\'m so scared"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "plz check for understanding question and getting answer\\nhttps://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "harsha335",
                        "content": "Can anyone help me out ... i can\\'t get this test case\\nInput\\ntickets =\\n[[\"EZE\",\"TIA\"],[\"EZE\",\"AXA\"],[\"AUA\",\"EZE\"],[\"EZE\",\"JFK\"],[\"JFK\",\"ANU\"],[\"JFK\",\"ANU\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AUA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"EZE\"],[\"ANU\",\"EZE\"],[\"TIA\",\"AUA\"]]\\n\\nOutput\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"TIA\",\"JFK\",\"ANU\",\"EZE\",\"JFK\",\"AUA\"]\\nExpected\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"JFK\",\"ANU\",\"EZE\",\"TIA\",\"JFK\",\"AUA\"]"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Expected answer is lexicographically smaller than yours, that\\'s why."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I give up without even trying and feeling relaxed \\uD83E\\uDD71"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Why? It\\'s only Thursday."
                    },
                    {
                        "username": "___lovesh1808___",
                        "content": "what in the leetcode is this"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to solve this with best time complexity as well as space complexity solution"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Because you have to use every ticket one time, the length of a valid itinerary will be equal to the length of tickets + 1. If you always try using the lexically shortest destinations first, then your first time reaching an itinerary of length (tickets.Length + 1) will be your answer."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "can anyone give their intuition or  some hint"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@wentland](/wentland) Can u please explain the time complexity of this ?"
                    },
                    {
                        "username": "wentland",
                        "content": "Build a list of possible destinations for each airport. Sort the lists in lexical order. Then try traversing through by picking the first element in the array and removing it. If it doesn\\'t work then add it back to the array and go to the next element. Continue until you get a success. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Prime Number of Set Bits in Binary Representation",
        "question_content": "<p>Given two integers <code>left</code> and <code>right</code>, return <em>the <strong>count</strong> of numbers in the <strong>inclusive</strong> range </em><code>[left, right]</code><em> having a <strong>prime number of set bits</strong> in their binary representation</em>.</p>\n\n<p>Recall that the <strong>number of set bits</strong> an integer has is the number of <code>1</code>&#39;s present when written in binary.</p>\n\n<ul>\n\t<li>For example, <code>21</code> written in binary is <code>10101</code>, which has <code>3</code> set bits.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> left = 6, right = 10\n<strong>Output:</strong> 4\n<strong>Explanation:</strong>\n6  -&gt; 110 (2 set bits, 2 is prime)\n7  -&gt; 111 (3 set bits, 3 is prime)\n8  -&gt; 1000 (1 set bit, 1 is not prime)\n9  -&gt; 1001 (2 set bits, 2 is prime)\n10 -&gt; 1010 (2 set bits, 2 is prime)\n4 numbers have a prime number of set bits.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> left = 10, right = 15\n<strong>Output:</strong> 5\n<strong>Explanation:</strong>\n10 -&gt; 1010 (2 set bits, 2 is prime)\n11 -&gt; 1011 (3 set bits, 3 is prime)\n12 -&gt; 1100 (2 set bits, 2 is prime)\n13 -&gt; 1101 (3 set bits, 3 is prime)\n14 -&gt; 1110 (3 set bits, 3 is prime)\n15 -&gt; 1111 (4 set bits, 4 is not prime)\n5 numbers have a prime number of set bits.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= left &lt;= right &lt;= 10<sup>6</sup></code></li>\n\t<li><code>0 &lt;= right - left &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 113232,
                "title": "665772",
                "content": "Ruby:\\n```\\ndef count_prime_set_bits(l, r)\\n  (l..r).sum { |i| 665772 >> i.digits(2).sum & 1 }\\nend\\n```\\nPython:\\n\\n    def countPrimeSetBits(self, L, R):\\n        return sum(665772 >> bin(i).count('1') & 1 for i in range(L, R+1))\\n\\nJava stream:\\n\\n    public int countPrimeSetBits(int L, int R) {\\n        return IntStream.range(L, R+1).map(i -> 665772 >> Integer.bitCount(i) & 1).sum();\\n    }\\n\\nJava:\\n\\n    public int countPrimeSetBits(int L, int R) {\\n        int count = 0;\\n        while (L <= R)\\n            count += 665772 >> Integer.bitCount(L++) & 1;\\n        return count;\\n    }\\n\\nC++:\\n\\n    int countPrimeSetBits(int L, int R) {\\n        int count = 0;\\n        while (L <= R)\\n            count += 665772 >> __builtin_popcount(L++) & 1;\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "```\\ndef count_prime_set_bits(l, r)\\n  (l..r).sum { |i| 665772 >> i.digits(2).sum & 1 }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 113227,
                "title": "java-c-clean-code",
                "content": "**Java**\\n```\\nclass Solution {\\n    public int countPrimeSetBits(int l, int r) {\\n        Set<Integer> primes = new HashSet<>(Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19 /*, 23, 29 */ ));\\n        int cnt = 0;\\n        for (int i = l; i <= r; i++) {\\n            int bits = 0;\\n            for (int n = i; n > 0; n >>= 1)\\n                bits += n & 1;\\n            cnt += primes.contains(bits) ? 1 : 0;\\n        }\\n        return cnt;        \\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int l, int r) {\\n        set<int> primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 };\\n        int cnt = 0;\\n        for (int i = l; i <= r; i++) {\\n            int bits = 0;\\n            for (int n = i; n; n >>= 1)\\n                bits += n & 1;\\n            cnt += primes.count(bits);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPrimeSetBits(int l, int r) {\\n        Set<Integer> primes = new HashSet<>(Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19 /*, 23, 29 */ ));\\n        int cnt = 0;\\n        for (int i = l; i <= r; i++) {\\n            int bits = 0;\\n            for (int n = i; n > 0; n >>= 1)\\n                bits += n & 1;\\n            cnt += primes.contains(bits) ? 1 : 0;\\n        }\\n        return cnt;        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int l, int r) {\\n        set<int> primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 };\\n        int cnt = 0;\\n        for (int i = l; i <= r; i++) {\\n            int bits = 0;\\n            for (int n = i; n; n >>= 1)\\n                bits += n & 1;\\n            cnt += primes.count(bits);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 114870,
                "title": "sort-easy-python",
                "content": "```\\nclass Solution:\\n    def countPrimeSetBits(self, L, R):\\n        \"\"\"\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        primes = {2, 3, 5, 7, 11, 13, 17, 19}\\n        return sum(map(lambda x: bin(x).count('1') in primes, range(L, R+1)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPrimeSetBits(self, L, R):\\n        \"\"\"\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        primes = {2, 3, 5, 7, 11, 13, 17, 19}\\n        return sum(map(lambda x: bin(x).count('1') in primes, range(L, R+1)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113248,
                "title": "easy-o-n-java-solution-using-dp",
                "content": "```\\nclass Solution {\\n    public int countPrimeSetBits(int L, int R) {\\n        int cnt = 0;\\n        Set<Integer> listPrimes = new HashSet<>(Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ));\\n        int[] res = countBits(R);\\n        for(int i=L;i<=R;i++){\\n            if(listPrimes.contains(res[i])){\\n                cnt++;\\n            }             \\n        }\\n        return cnt;\\n    }    \\n    \\n    public int[] countBits(int num) {\\n        if(num == 0)\\n            return new int[1];\\n        int[] dp = new int[num+1];\\n        \\n        dp[0] = 0;\\n        dp[1] = 1;\\n        \\n        for(int i=2;i<=num;i++){\\n            dp[i] = dp[i >> 1] + dp[i & 1]; //  i >> 1 is i / 2 and i & 1 is i % 2\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPrimeSetBits(int L, int R) {\\n        int cnt = 0;\\n        Set<Integer> listPrimes = new HashSet<>(Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ));\\n        int[] res = countBits(R);\\n        for(int i=L;i<=R;i++){\\n            if(listPrimes.contains(res[i])){\\n                cnt++;\\n            }             \\n        }\\n        return cnt;\\n    }    \\n    \\n    public int[] countBits(int num) {\\n        if(num == 0)\\n            return new int[1];\\n        int[] dp = new int[num+1];\\n        \\n        dp[0] = 0;\\n        dp[1] = 1;\\n        \\n        for(int i=2;i<=num;i++){\\n            dp[i] = dp[i >> 1] + dp[i & 1]; //  i >> 1 is i / 2 and i & 1 is i % 2\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158109,
                "title": "a-fast-algorithm-utilizing-pascal-s-triangle",
                "content": "## Simple scenarios\\nLet\\'s observe first, how we may count the total number of set bits from `(L,0]`. We start with \"simple numbers\", e.g. `0b10000`, with a `1` at position `n` followed by `n-1` `0`s:\\n\\n|n|   L       |   Possible bit combos within (L,0] | 0 set bits | 1 set bits | 2 set bits | 3 set bits |\\n|-|----------|-------------------------------------------|-------------|-------------|-------------|-------------|\\n|1| `0b1`   | `0b0`                                            | 1             |                 |                |                 |\\n|2| `0b10` | `0b1`, `0b0`                                 | 1             |  1              |                |                |\\n|3|`0b100`| `0b11`, `0b10`, `0b1`, `0b0`        | 1              | 2             | 1             |                 |\\n|4|`0b1000`| `0b111`, `0b110`, `0b101`, `0b100`, `0b11`, `0b10`, `0b1`, `0b0`        | 1 | 3 | 3 | 1 |\\n\\n\\\\* It can be proven easily using combinatorics, that the number of set bits of such a \"simple number\" follows the Pascal\\'s Triangle.\\n\\n## More complex scenarios\\nGiven a more complex number, such as `0b1100`, the number of set bits within `(0b1100,0]` can be obtained by combining the set bits in two ranges: 1) `(0b1100,0b1000]` and 2) `(0b1000,0]`. The set bits of range 2 can be directly looked up in our Pascal Triangle. The set bit of range 1 is a bit tricky. You look up `0b100` in the triangle, which gives you `{0:1,1:2, 2:1}` and then you shift the set bit by 1 to obtain `{1:1, 2:2, 3:1}`. This is to accomodate the fact that there is a bit `1` ahead of `0b100`.\\nGiven more comples numbers and you may need to divide it into several ranges and use a similar procesure to get the number of set bits.\\n\\nSo that is the idea of using Pascal Triangle to obtain set bits in range `(L,0]`. With a little modification, one can get the prime number of set bits in range `[L,R]`.\\n\\n## Time complexity\\nThe time complexity is in the order of `O(N^2)` where `N` is the position of the most significant bit in `R`.\\n\\n## Sample Code\\nPython for expresiveness.\\n\\n```\\nclass Solution:\\n  def getMostSignificantBitPosition(self,num):\\n    \"\"\"\\n    param: A *positive* number\\n    return: The position of the most significant bit\\n\\n    Example:\\n      Given 0b101001\\n      Return 6\\n    \"\"\"\\n    return len(bin(num))-len(\"0b\")\\n\\n  def getPascalTriangle(self, num):\\n    \"\"\"\\n    param: The desired triangle level\\n    return: A pascal triangle of desired leven\\n\\n    Example\\n      Given 4\\n      Return [[1]             index:0    level:1\\n              [1,1]\\n              [1,2,1]\\n              [1,3,3,1]\\n              ]\\n      #bit set 0 1 2 3 ...\\n    \"\"\"\\n    # Assume num>=1\\n    ret = [[1]]\\n    for i in range(1,num):\\n      tmp=[1]\\n      for m,n in zip(ret[i-1][1:],ret[i-1][:-1]):\\n        tmp.append(m+n)\\n      tmp.append(1)\\n\\n      ret.append(tmp)\\n    return ret\\n\\n  def getPrimeBitSets(self,num,PascalTriangle):\\n    \"\"\"\\n    param: a positive number smaller than 2^32\\n    param: a pascal triangle of enough level\\n    return: the number of prime bit sets in range (num,0]\\n\\n    Example\\n      Given 0b1001\\n      Return\\n    \"\"\"\\n    # Prime table\\n    #          0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16\\n    #         17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32\\n    isPrime = [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0,\\n               1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0]\\n    primeCount = 0\\n    prevBitCount = 0\\n    pos = self.getMostSignificantBitPosition(num)\\n    for p in range(pos,0,-1): # p for position\\n      mask = 1 << (p-1)\\n      if mask & num == 0:\\n        continue\\n\\n      # Encountered bit \\'1\\'\\n      # Loop up the triangle for prime bit sets\\n      for n,v in enumerate(PascalTriangle[p-1]): # n for bit sets\\n        if isPrime[n+prevBitCount]:\\n          primeCount+=v\\n      # END FOR\\n\\n      prevBitCount+=1\\n    # END FOR\\n    return primeCount\\n\\n  def countPrimeSetBits(self, L, R):\\n    \"\"\"\\n    :type L: int\\n    :type R: int\\n    :rtype: int\\n    \"\"\"\\n\\n    # To obtain prime number of bit sets in range [R,L]\\n    # We opt to obtain prime number of bit sets\\n    # in range (R+1,0] and (L,0] and use subtraction to\\n    # obtain that in range [R,L]\\n\\n    # Needed to run getPrimeBitSets(R+1,trangle)\\n    triangle = self.getPascalTriangle(\\n                    self.getMostSignificantBitPosition(R+1) )\\n    return self.getPrimeBitSets(R+1,triangle)-self.getPrimeBitSets(L,triangle)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def getMostSignificantBitPosition(self,num):\\n    \"\"\"\\n    param: A *positive* number\\n    return: The position of the most significant bit\\n\\n    Example:\\n      Given 0b101001\\n      Return 6\\n    \"\"\"\\n    return len(bin(num))-len(\"0b\")\\n\\n  def getPascalTriangle(self, num):\\n    \"\"\"\\n    param: The desired triangle level\\n    return: A pascal triangle of desired leven\\n\\n    Example\\n      Given 4\\n      Return [[1]             index:0    level:1\\n              [1,1]\\n              [1,2,1]\\n              [1,3,3,1]\\n              ]\\n      #bit set 0 1 2 3 ...\\n    \"\"\"\\n    # Assume num>=1\\n    ret = [[1]]\\n    for i in range(1,num):\\n      tmp=[1]\\n      for m,n in zip(ret[i-1][1:],ret[i-1][:-1]):\\n        tmp.append(m+n)\\n      tmp.append(1)\\n\\n      ret.append(tmp)\\n    return ret\\n\\n  def getPrimeBitSets(self,num,PascalTriangle):\\n    \"\"\"\\n    param: a positive number smaller than 2^32\\n    param: a pascal triangle of enough level\\n    return: the number of prime bit sets in range (num,0]\\n\\n    Example\\n      Given 0b1001\\n      Return\\n    \"\"\"\\n    # Prime table\\n    #          0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16\\n    #         17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32\\n    isPrime = [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0,\\n               1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0]\\n    primeCount = 0\\n    prevBitCount = 0\\n    pos = self.getMostSignificantBitPosition(num)\\n    for p in range(pos,0,-1): # p for position\\n      mask = 1 << (p-1)\\n      if mask & num == 0:\\n        continue\\n\\n      # Encountered bit \\'1\\'\\n      # Loop up the triangle for prime bit sets\\n      for n,v in enumerate(PascalTriangle[p-1]): # n for bit sets\\n        if isPrime[n+prevBitCount]:\\n          primeCount+=v\\n      # END FOR\\n\\n      prevBitCount+=1\\n    # END FOR\\n    return primeCount\\n\\n  def countPrimeSetBits(self, L, R):\\n    \"\"\"\\n    :type L: int\\n    :type R: int\\n    :rtype: int\\n    \"\"\"\\n\\n    # To obtain prime number of bit sets in range [R,L]\\n    # We opt to obtain prime number of bit sets\\n    # in range (R+1,0] and (L,0] and use subtraction to\\n    # obtain that in range [R,L]\\n\\n    # Needed to run getPrimeBitSets(R+1,trangle)\\n    triangle = self.getPascalTriangle(\\n                    self.getMostSignificantBitPosition(R+1) )\\n    return self.getPrimeBitSets(R+1,triangle)-self.getPrimeBitSets(L,triangle)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160145,
                "title": "python-1-line",
                "content": "```\\nclass Solution:\\n    def countPrimeSetBits(self, L, R):\\n        \"\"\"\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        return len([1 for i in range(L,R+1) if bin(i).count(\\'1\\') in [2, 3, 5, 7, 11, 13, 17, 19]])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPrimeSetBits(self, L, R):\\n        \"\"\"\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        return len([1 for i in range(L,R+1) if bin(i).count(\\'1\\') in [2, 3, 5, 7, 11, 13, 17, 19]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 157907,
                "title": "fast-python-beats-100-40ms-uses-binomial-coefficients",
                "content": "Using this formula\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/gd303/image_1533731042.png)\\nwe can obtain some fast code. There are O(log^2 N / log log N) binomial coefficients in this sum, I think. Note that the binomial coefficient cache is global across test cases.\\n```\\ndef binomial(n, k, cache={}):\\n    if k == 0: return 1\\n    if (n, k) not in cache:\\n        cache[n, k] = binomial(n-1, k-1) * n // k\\n    return cache[n, k]\\n\\n\\nclass Solution:\\n    def countPrimeSetBits(self, L, R):\\n        return self.fast_count(R+1) - self.fast_count(L)\\n    \\n    def fast_count(self, N):\\n        S = bin(N)\\n        B = [len(S) + ~i for i, b in enumerate(S) if b == \\'1\\']\\n        res = 0\\n        for p in [2, 3, 5, 7, 11, 13, 17, 19]:\\n            if B[0] < p: break\\n            for i in range(min(p+1, len(B))):\\n                n = B[i]; k = p-i\\n                if n < k: break\\n                res += binomial(n, k)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef binomial(n, k, cache={}):\\n    if k == 0: return 1\\n    if (n, k) not in cache:\\n        cache[n, k] = binomial(n-1, k-1) * n // k\\n    return cache[n, k]\\n\\n\\nclass Solution:\\n    def countPrimeSetBits(self, L, R):\\n        return self.fast_count(R+1) - self.fast_count(L)\\n    \\n    def fast_count(self, N):\\n        S = bin(N)\\n        B = [len(S) + ~i for i, b in enumerate(S) if b == \\'1\\']\\n        res = 0\\n        for p in [2, 3, 5, 7, 11, 13, 17, 19]:\\n            if B[0] < p: break\\n            for i in range(min(p+1, len(B))):\\n                n = B[i]; k = p-i\\n                if n < k: break\\n                res += binomial(n, k)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 751555,
                "title": "c-implementation-for-every-function",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int count_of_bits(int num){ //function to return number of bits\\n        int count = 0;\\n        while (num > 0){\\n            if (num % 2 == 1){\\n                count +=1;\\n                num = num/2;\\n            }\\n            else{\\n                num = num/2;\\n            }\\n        }\\n        return count;\\n    }\\n    //-----\\n    bool if_prime(int num){ //function to return if a number is prime(true) or not(false)\\n        if (num <=1){ //0 and 0 is not prime\\n            return false;\\n        }\\n        int i =2;\\n        while (i <= (num/2)){\\n            if (num % i == 0){\\n                return false;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n    //-----\\n    int countPrimeSetBits(int L, int R) {\\n        int res = 0;\\n        int count;\\n        for (int i = L; i <= R; i++){\\n            count = count_of_bits(i);\\n            if (if_prime(count)){\\n                res +=1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int count_of_bits(int num){ //function to return number of bits\\n        int count = 0;\\n        while (num > 0){\\n            if (num % 2 == 1){\\n                count +=1;\\n                num = num/2;\\n            }\\n            else{\\n                num = num/2;\\n            }\\n        }\\n        return count;\\n    }\\n    //-----\\n    bool if_prime(int num){ //function to return if a number is prime(true) or not(false)\\n        if (num <=1){ //0 and 0 is not prime\\n            return false;\\n        }\\n        int i =2;\\n        while (i <= (num/2)){\\n            if (num % i == 0){\\n                return false;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n    //-----\\n    int countPrimeSetBits(int L, int R) {\\n        int res = 0;\\n        int count;\\n        for (int i = L; i <= R; i++){\\n            count = count_of_bits(i);\\n            if (if_prime(count)){\\n                res +=1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442403,
                "title": "application-of-wilson-s-theorem",
                "content": "It follows [Wilson\\'s theorem](https://en.wikipedia.org/wiki/Wilson%27s_theorem) to perform one-liner test for prime. But to create the hash table is still quicker.\\n```python\\nclass Solution(object):\\n    def countPrimeSetBits(self, L, R):\\n        \"\"\"\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        for i in range(L,R+1):\\n            bits= bin(i).count(\\'1\\')\\n            if bits!=1 and math.factorial(bits - 1)  % bits == bits - 1:\\n                res+=1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution(object):\\n    def countPrimeSetBits(self, L, R):\\n        \"\"\"\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        for i in range(L,R+1):\\n            bits= bin(i).count(\\'1\\')\\n            if bits!=1 and math.factorial(bits - 1)  % bits == bits - 1:\\n                res+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203317,
                "title": "python-simple-solution-w-explanation",
                "content": "The most intuitive way to count for 1\\'s in the binary expression of a number, is counting the 1\\'s. Luckily, python can do that using .count() method. \\n\\nSo all we have to do is convert the number to binary, and do a count(). However, how do we know if a count is prime? \\n\\nWe could solve for the prime, but that would take forever, instead, we can opt for a reference table of prime numbers. Therefore we create a set containing all primes from 0~19, (since 20 bits is the limit due to OP stating max number there is 10^6, which can have up to 20 bits)\\n\\nFrom them on, it\\'s a simple comparison.\\n\\n```\\nclass Solution:\\n    def countPrimeSetBits(self, L, R):\\n        prime_set = {2, 3, 5, 7, 11, 13, 17, 19}\\n        \\n        ret = 0\\n        for i in range(L, R+1):\\n            one_count = bin(i).count(\\'1\\')\\n            if one_count in prime_set:\\n                ret +=1\\n        \\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPrimeSetBits(self, L, R):\\n        prime_set = {2, 3, 5, 7, 11, 13, 17, 19}\\n        \\n        ret = 0\\n        for i in range(L, R+1):\\n            one_count = bin(i).count(\\'1\\')\\n            if one_count in prime_set:\\n                ret +=1\\n        \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350897,
                "title": "rust-1-liner-0ms-1-9mb",
                "content": "```\\npub fn count_prime_set_bits(l: i32, r: i32) -> i32 {\\n        (l..=r).filter(|x|[2,3,5,7,11,13,17,19].contains(&x.count_ones())).count() as i32\\n}\\n// 2021 Dec: Updated from 2.3->1.9mb and to not check >19 as per BigMih\\'s comment\\n```\\n\\nFun fact:\\nThere\\'s an instruction in recent Intel & AMD processors for counting the number of bits set in an integer:\\nhttps://en.wikipedia.org/wiki/SSE4#POPCNT_and_LZCNT\\n\\nOften people still write loops manually to do this, but compilers can be smart enough to replace your loop with the single instruction:\\nhttps://lemire.me/blog/2016/05/23/the-surprising-cleverness-of-modern-compilers/",
                "solutionTags": [],
                "code": "```\\npub fn count_prime_set_bits(l: i32, r: i32) -> i32 {\\n        (l..=r).filter(|x|[2,3,5,7,11,13,17,19].contains(&x.count_ones())).count() as i32\\n}\\n// 2021 Dec: Updated from 2.3->1.9mb and to not check >19 as per BigMih\\'s comment\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2021251,
                "title": "python-solution-w-o-bit-manipulation-214ms-beats-91-23-with-explanation",
                "content": "**Explanation**\\n*The hard part was checking whether the set bit was prime, but the 32-bit integer limit helped us with that! \\uD83D\\uDE0F*\\n\\n1. Iterate through the range\\n2. Check the number of `1`\\'s in the binary representation of that the number\\n3. Check if it is prime: if yes, add 1 to count\\n\\n![image](https://assets.leetcode.com/users/images/fde62c42-9902-4b5a-81f8-635a9052c992_1652068454.4434237.png)\\n\\n\\n```\\nclass Solution(object):\\n    def countPrimeSetBits(self, left, right):\\n        \"\"\"\\n        :type left: int\\n        :type right: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        primes = [2,3,5,7,11,13,17,19,23,29,31]\\n        for i in range(left, right+1):\\n            set_bits = bin(i).count(\\'1\\')\\n            if set_bits in primes:\\n                count += 1           \\n        return count\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countPrimeSetBits(self, left, right):\\n        \"\"\"\\n        :type left: int\\n        :type right: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        primes = [2,3,5,7,11,13,17,19,23,29,31]\\n        for i in range(left, right+1):\\n            set_bits = bin(i).count(\\'1\\')\\n            if set_bits in primes:\\n                count += 1           \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125388,
                "title": "c-simple-solution-100-faster-in-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int L, int R) {\\n        int count=0;\\n        for(int i=L;i<=R;i++){\\n            if(checkPrime(findSetBits(i))) count++;\\n        }\\n        return count;\\n    }\\n    int findSetBits(int n){\\n        int count=0;\\n        while(n){\\n            n=n&(n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n    bool checkPrime(int x){\\n        return (x == 2 || x == 3 || x == 5 || x == 7 ||\\n                x == 11 || x == 13 || x == 17 || x == 19);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int L, int R) {\\n        int count=0;\\n        for(int i=L;i<=R;i++){\\n            if(checkPrime(findSetBits(i))) count++;\\n        }\\n        return count;\\n    }\\n    int findSetBits(int n){\\n        int count=0;\\n        while(n){\\n            n=n&(n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n    bool checkPrime(int x){\\n        return (x == 2 || x == 3 || x == 5 || x == 7 ||\\n                x == 11 || x == 13 || x == 17 || x == 19);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 240824,
                "title": "python-1-line-solution",
                "content": "```python\\nreturn len([i for i in range(L, R + 1) if bin(i).count(\\'1\\') in {2, 3, 5, 7, 11, 13, 17, 19, 23, 29}])\\n```",
                "solutionTags": [],
                "code": "```python\\nreturn len([i for i in range(L, R + 1) if bin(i).count(\\'1\\') in {2, 3, 5, 7, 11, 13, 17, 19, 23, 29}])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 113235,
                "title": "c-9-ms",
                "content": "```\\nclass Solution {\\npublic:\\n  int countPrimeSetBits(int L, int R) {\\n    int ans = 0;\\n    unsigned magic = 2693408941;\\n    for (int n = L; n <= R; ++n)\\n      if (magic & (1 << __builtin_popcountll(n))) ++ans;\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int countPrimeSetBits(int L, int R) {\\n    int ans = 0;\\n    unsigned magic = 2693408941;\\n    for (int n = L; n <= R; ++n)\\n      if (magic & (1 << __builtin_popcountll(n))) ++ans;\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198469,
                "title": "simple-c-code-with-explanation-easy-understanding",
                "content": "class Solution {\\npublic:\\nint countPrimeSetBits(int left, int right) {\\n// given constraint left , right <= 10^6\\n\\n    // 2^10 == 10^3  implies 10^6 ==2^20  ( 20 bits can be set at max )\\n    \\n    vector<bool> p(20,false);\\n    \\n    //set prime vector p\\n    p[2]=p[3]=p[5]=p[7]=p[11]=p[13]=p[17]=p[19]=true;\\n        \\n    int result=0;\\n\\n    for(int i=left;i<right+1;i++)\\n    {\\n        int t=i,c=0;\\n        while(t)\\n        {\\n            c=c+(t&1);\\n            t=t>>1;\\n        }\\n        \\n        if(p[c]==true)\\n            result++;\\n    }\\n    return result;\\n}\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\nint countPrimeSetBits(int left, int right) {\\n// given constraint left , right <= 10^6\\n\\n    // 2^10 == 10^3  implies 10^6 ==2^20  ( 20 bits can be set at max )\\n    \\n    vector<bool> p(20,false);\\n    \\n    //set prime vector p\\n    p[2]=p[3]=p[5]=p[7]=p[11]=p[13]=p[17]=p[19]=true;\\n        \\n    int result=0;\\n\\n    for(int i=left;i<right+1;i++)\\n    {\\n        int t=i,c=0;\\n        while(t)\\n        {\\n            c=c+(t&1);\\n            t=t>>1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2414059,
                "title": "c-3ms",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int cnt1(int n)\\n    {\\n        int cnt = 0;\\n        while(n)\\n        {\\n            n = n & (n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    bool isPrime(int n)\\n    {\\n        return n == 2 || n ==3 || n == 5 || n == 7 || n == 11 || n == 13 || n == 17 || n == 19;\\n        // max value in the question is 10^6 boils down to 2^19 (approx), so at max there can be only 19 set bits\\n    }\\n    int countPrimeSetBits(int left, int right) {\\n        int cnt = 0;\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(isPrime(cnt1(i)))\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int cnt1(int n)\\n    {\\n        int cnt = 0;\\n        while(n)\\n        {\\n            n = n & (n-1);\\n            cnt++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1612314,
                "title": "easy-python-solution",
                "content": "```\\ndef countPrimeSetBits(self, left: int, right: int) -> int:\\n        count=0\\n        for i in range(left,right+1):\\n            c=0\\n            n=bin(i).count(\"1\")\\n            for j in range(1,n+1):\\n                if n%j==0:\\n                    c+=1\\n            if c==2:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef countPrimeSetBits(self, left: int, right: int) -> int:\\n        count=0\\n        for i in range(left,right+1):\\n            c=0\\n            n=bin(i).count(\"1\")\\n            for j in range(1,n+1):\\n                if n%j==0:\\n                    c+=1\\n            if c==2:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1253250,
                "title": "c-easy-to-understand-fast-and-efficient-intuitive-approach",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)**\\n```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n        int num;\\n        int count,c=0;\\n         while(left!=(right+1))         \\n        {\\n            count=0;\\n            num=left;\\n            while(num)\\n            {\\n                count++;\\n                num=num&(num-1);\\n            }  \\n            if(prime(count))\\n            c++;\\n             left++;\\n        }  \\n        return c;\\n    }\\nbool prime(int num)\\n{\\n    int c=0;\\n    for(int i=num;i>=1;i--)\\n    {\\n        if(num%i==0)\\n         c++;   \\n    }  \\n    return c==2;\\n} \\n};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n        int num;\\n        int count,c=0;\\n         while(left!=(right+1))         \\n        {\\n            count=0;\\n            num=left;\\n            while(num)\\n            {\\n                count++;\\n                num=num&(num-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1240812,
                "title": "easy-python-again",
                "content": "class Solution:\\n      \\n    def countPrimeSetBits(self, left: int, right: int) -> int:\\n        res = 0\\n        for x in range(left, right+1):\\n            if bin(x).count(\\'1\\') in {2, 3, 5, 7, 11, 13, 17, 19, 23, 29}:\\n                res += 1\\n        return res\\n",
                "solutionTags": [],
                "code": "class Solution:\\n      \\n    def countPrimeSetBits(self, left: int, right: int) -> int:\\n        res = 0\\n        for x in range(left, right+1):\\n            if bin(x).count(\\'1\\') in {2, 3, 5, 7, 11, 13, 17, 19, 23, 29}",
                "codeTag": "Java"
            },
            {
                "id": 699300,
                "title": "simple-java-solution-time-o-n-space-o-1",
                "content": "**Intuition:**\\nWe have limited range of L and R - up to 10^6, meaning their bit representations will have up to 20 symbols (10^6 < 2^20).\\nWe can cash prime numbers in range of 0-20, maybe the most efficient is to use bucket sort so the found prime numbers: 2, 3, 5, 7, 11, 13, 17, 19 are converted into true in the corresponding array of booleans of length 21\\nThe final solution looks like:\\n```\\npublic int countPrimeSetBits(int L, int R) {\\n        boolean [] primes = new boolean[]{false, false, true, true, false, true, false, true, false, false , false, true, false, true, false, false, false, true, false, true, false};\\n        int count = 0;\\n        for(int i = L; i <= R; i++) {\\n            if (primes[countBits(i)]) count++;\\n        }\\n        return count;\\n    }\\n    \\n    private int countBits(int n) {\\n        int count = 0;\\n        for(int i = n; i > 0; i >>= 1)\\n            count += i & 1;\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Bucket Sort"
                ],
                "code": "```\\npublic int countPrimeSetBits(int L, int R) {\\n        boolean [] primes = new boolean[]{false, false, true, true, false, true, false, true, false, false , false, true, false, true, false, false, false, true, false, true, false};\\n        int count = 0;\\n        for(int i = L; i <= R; i++) {\\n            if (primes[countBits(i)]) count++;\\n        }\\n        return count;\\n    }\\n    \\n    private int countBits(int n) {\\n        int count = 0;\\n        for(int i = n; i > 0; i >>= 1)\\n            count += i & 1;\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 530628,
                "title": "5-lines-hashset-regexp-javascript-solution",
                "content": "```\\n/**\\n * @param {number} L\\n * @param {number} R\\n * @return {number}\\n */\\nvar countPrimeSetBits = function(L, R) {\\n  let set = new Set([2, 3, 5, 7, 11, 13, 17, 19]);\\n  let countPrime = 0;\\n  \\n  for (let i = L; i <= R; i++) {\\n    if (set.has(i.toString(2).replace(/0/g, \\'\\').length)) countPrime++;\\n  }\\n\\n  return countPrime;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} L\\n * @param {number} R\\n * @return {number}\\n */\\nvar countPrimeSetBits = function(L, R) {\\n  let set = new Set([2, 3, 5, 7, 11, 13, 17, 19]);\\n  let countPrime = 0;\\n  \\n  for (let i = L; i <= R; i++) {\\n    if (set.has(i.toString(2).replace(/0/g, \\'\\').length)) countPrime++;\\n  }\\n\\n  return countPrime;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 113242,
                "title": "c-solution",
                "content": "    public int CountPrimeSetBits(int L, int R) {\\n        int count = 0;\\n        for (int i = L; i <= R; i++)\\n        {\\n            int bitsCount = GetBitsCount(i);\\n            if (IsPrime(bitsCount)) count++; \\n        }\\n        \\n        return count; \\n    }\\n    \\n    private int GetBitsCount(int a)\\n    {\\n        int count = 0; \\n        while (a > 0)\\n        {\\n            count += a % 2;\\n            a /= 2; \\n        }\\n        \\n        return count; \\n    }\\n    \\n    private bool IsPrime(int a)\\n    {\\n        if (a <= 1) return false; \\n        \\n        for (int i = 2; i < a; i++)\\n        {\\n            if (a % i == 0) return false; \\n        }\\n        \\n        return true; \\n    }",
                "solutionTags": [],
                "code": "    public int CountPrimeSetBits(int L, int R) {\\n        int count = 0;\\n        for (int i = L; i <= R; i++)\\n        {\\n            int bitsCount = GetBitsCount(i);\\n            if (IsPrime(bitsCount)) count++; \\n        }\\n        \\n        return count; \\n    }\\n    \\n    private int GetBitsCount(int a)\\n    {\\n        int count = 0; \\n        while (a > 0)\\n        {\\n            count += a % 2;\\n            a /= 2; \\n        }\\n        \\n        return count; \\n    }\\n    \\n    private bool IsPrime(int a)\\n    {\\n        if (a <= 1) return false; \\n        \\n        for (int i = 2; i < a; i++)\\n        {\\n            if (a % i == 0) return false; \\n        }\\n        \\n        return true; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 113244,
                "title": "o-log-r-solution-c-python-ruby",
                "content": "So far I think only brute force solutions have been posted (checking all numbers from L to R and counting the \"good\" ones (those with a prime number of 1-bits)). Here's an efficient solution, it's O(log<sup>2</sup> R<sub>max</sub>) where R<sub>max</sub> is the maximum allowed R-value (i.e., 10^6 in the problem specification). And in the end I optimize it to O(log R).\\n\\nEven the Python version can for example solve `countPrimeSetBits(1, 1000000)` (much larger range than allowed in the problem) in about 0.00006 seconds on my PC. And `countPrimeSetBits(None, 1, 1000000000)` in about 0.00015 seconds (after modifying the code to go up to bit 29 instead of just bit 19).\\n\\nFirst let's reduce the \"from-to\" problem to an \"under\" problem: How to count the \"good\" numbers from L to R? Count those under R+1 and discount those under L.\\n\\nTo count the \"good\" numbers under a certain limit: How do numbers under the limit look like? They may start like the limit (i.e., have the same high-bits) but then some 1-bit must be changed to a 0-bit. And then the lower bits can be whatever.\\n\\nSo go through the bits of the limit number. Whenever we see a 1-bit, we can make it 0 and then have to ask: With all the possibilities for the remaining lower bits, how many of them give us numbers with a prime number of 1-bits? Well, let's say 5 of the higher bits are 1-bits and we have 7 lower bits left. We can turn 0 to 7 of them into 1-bits. But together with the 5 higher 1-bits we want a prime number, so exactly 0, 2, or 6 of the lower bits must be 1-bits (only 5+0, 5+2 and 5+6 are prime). And for example for 2 lower 1-bits, we have 7C2 (\"7 choose 2\") possibilities to choose 2 of those 7 lower bits.\\n\\n```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int L, int R) {\\n        return under(R+1) - under(L);\\n    }\\n\\n    int under(int limit) {\\n        int count = 0, highOnes = 0;\\n        for (int lowBits = 19; lowBits >= 0; lowBits--) {\\n            if (limit & (1 << lowBits)) {\\n                for (int lowOnes = 0; lowOnes <= lowBits; lowOnes++)\\n                    if (isPrime(lowOnes + highOnes))\\n                        count += nCk(lowBits, lowOnes);\\n                highOnes++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    int isPrime(int n) {\\n        return n < 4 ? n > 1 : n % 2 && n % 3;\\n    }\\n    \\n    int nCk(int n, int k) {\\n        return k < 0 ? 0 : k == 0 ? 1 : nCk(n, k-1) * (n-k+1) / k;\\n    }\\n};\\n```\\nOptimized version which doesn't recompute nCk from scratch all the time:\\n```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int L, int R) {\\n        return under(R+1) - under(L);\\n    }\\n\\n    int under(int m) {\\n        int count = 0, K = 0;\\n        for (int n = 19; n >= 0; n--) {\\n            if (m & (1 << n)) {\\n                for (int k = 0, nCk = 1; k <= n; k++, nCk = nCk * (n-k+1) / k)\\n                    if (isPrime(k + K))\\n                        count += nCk;\\n                K++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    int isPrime(int n) {\\n        return n < 4 ? n > 1 : n % 2 && n % 3;\\n    }\\n};\\n```\\nHere `K` is the number of 1-bits in the upper part (above the found 1-bit), `n` is the number of bits in the lower part (below the found 1-bit), and `k` is the number of 1-bits in the lower part.\\n\\nThe solution could be further optimized to O(log R<sub>max</sub>) by replacing the inner loop with a table lookup: `count += lookup[K][n]`. Since 0 &le; `K`, `n` &le; 19, this would be a fairly small table that could easily be hardcoded (or just computed once and stored in a static variable).\\n\\n\\nPython version:\\n\\n    def countPrimeSetBits(self, L, R):\\n        def under(m):\\n            count = 0\\n            K = 0;\\n            for n in range(19, -1, -1):\\n                if m & (1 << n):\\n                    nCk = 1\\n                    for k in range(n+1):\\n                        if k + K in {2, 3, 5, 7, 11, 13, 17, 19}:\\n                            count += nCk\\n                        nCk = nCk * (n-k) / (k+1)\\n                    K += 1\\n            return count\\n        return under(R+1) - under(L)\\n\\nRuby version:\\n```\\ndef count_prime_set_bits(l, r)\\n  def under(m)\\n    count = 0\\n    hi = 0;\\n    19.downto(0) do |n|\\n      if m & (1 << n) > 0\\n        nCk = 1\\n        (0..n).each do |k|\\n          count += nCk if [2, 3, 5, 7, 11, 13, 17, 19].member?(k + hi)\\n          nCk = nCk * (n-k) / (k+1)\\n        end\\n        hi += 1\\n      end\\n    end\\n    count\\n  end\\n  under(r+1) - under(l)\\nend\\n```\\n\\n## Optimization to O(log R)\\nWith the precomputed lookup table mentioned above, and I don't always start at bit 19 but just at the highest actual 1-bit:\\n```\\nlookup = [[0, 0, 1, 4, 10, 21, 41, 78, 148, 282, 537, 1013, 1882, 3446, 6267, 11468, 21416, 41209, 81771, 166042], [0, 1, 3, 6, 11, 20, 37, 70, 134, 255, 476, 869, 1564, 2821, 5201, 9948, 19793, 40562, 84271, 174952], [1, 2, 3, 5, 9, 17, 33, 64, 121, 221, 393, 695, 1257, 2380, 4747, 9845, 20769, 43709, 90681, 184624], [1, 1, 2, 4, 8, 16, 31, 57, 100, 172, 302, 562, 1123, 2367, 5098, 10924, 22940, 46972, 93943, 184605], [0, 1, 2, 4, 8, 15, 26, 43, 72, 130, 260, 561, 1244, 2731, 5826, 12016, 24032, 46971, 90662, 174762], [1, 1, 2, 4, 7, 11, 17, 29, 58, 130, 301, 683, 1487, 3095, 6190, 12016, 22939, 43691, 84100, 164902], [0, 1, 2, 3, 4, 6, 12, 29, 72, 171, 382, 804, 1608, 3095, 5826, 10923, 20752, 40409, 80802, 164749], [1, 1, 1, 1, 2, 6, 17, 43, 99, 211, 422, 804, 1487, 2731, 5097, 9829, 19657, 40393, 83947, 173775], [0, 0, 0, 1, 4, 11, 26, 56, 112, 211, 382, 683, 1244, 2366, 4732, 9828, 20736, 43554, 89828, 180557], [0, 0, 1, 3, 7, 15, 30, 56, 99, 171, 301, 561, 1122, 2366, 5096, 10908, 22818, 46274, 90729, 172007], [0, 1, 2, 4, 8, 15, 26, 43, 72, 130, 260, 561, 1244, 2730, 5812, 11910, 23456, 44455, 81278, 143754], [1, 1, 2, 4, 7, 11, 17, 29, 58, 130, 301, 683, 1486, 3082, 6098, 11546, 20999, 36823, 62476, 102886], [0, 1, 2, 3, 4, 6, 12, 29, 72, 171, 382, 803, 1596, 3016, 5448, 9453, 15824, 25653, 40410, 62035], [1, 1, 1, 1, 2, 6, 17, 43, 99, 211, 421, 793, 1420, 2432, 4005, 6371, 9829, 14757, 21625, 31009], [0, 0, 0, 1, 4, 11, 26, 56, 112, 210, 372, 627, 1012, 1573, 2366, 3458, 4928, 6868, 9384, 12597], [0, 0, 1, 3, 7, 15, 30, 56, 98, 162, 255, 385, 561, 793, 1092, 1470, 1940, 2516, 3213, 4047], [0, 1, 2, 4, 8, 15, 26, 42, 64, 93, 130, 176, 232, 299, 378, 470, 576, 697, 834, 988], [1, 1, 2, 4, 7, 11, 16, 22, 29, 37, 46, 56, 67, 79, 92, 106, 121, 137, 154, 172], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]]\\n\\nclass Solution(object):\\n    def countPrimeSetBits(self, L, R):\\n        def under(m):\\n            count = 0\\n            K = 0;\\n            for n in range(m.bit_length())[::-1]:\\n                if m & (1 << n):\\n                    count += lookup[K][n]\\n                    K += 1\\n            return count\\n        return under(R+1) - under(L)\\n```\\nFor `countPrimeSetBits(1, 1000000)` this takes only about 0.0000045 seconds on my PC.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int L, int R) {\\n        return under(R+1) - under(L);\\n    }\\n\\n    int under(int limit) {\\n        int count = 0, highOnes = 0;\\n        for (int lowBits = 19; lowBits >= 0; lowBits--) {\\n            if (limit & (1 << lowBits)) {\\n                for (int lowOnes = 0; lowOnes <= lowBits; lowOnes++)\\n                    if (isPrime(lowOnes + highOnes))\\n                        count += nCk(lowBits, lowOnes);\\n                highOnes++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    int isPrime(int n) {\\n        return n < 4 ? n > 1 : n % 2 && n % 3;\\n    }\\n    \\n    int nCk(int n, int k) {\\n        return k < 0 ? 0 : k == 0 ? 1 : nCk(n, k-1) * (n-k+1) / k;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int L, int R) {\\n        return under(R+1) - under(L);\\n    }\\n\\n    int under(int m) {\\n        int count = 0, K = 0;\\n        for (int n = 19; n >= 0; n--) {\\n            if (m & (1 << n)) {\\n                for (int k = 0, nCk = 1; k <= n; k++, nCk = nCk * (n-k+1) / k)\\n                    if (isPrime(k + K))\\n                        count += nCk;\\n                K++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    int isPrime(int n) {\\n        return n < 4 ? n > 1 : n % 2 && n % 3;\\n    }\\n};\\n```\n```\\ndef count_prime_set_bits(l, r)\\n  def under(m)\\n    count = 0\\n    hi = 0;\\n    19.downto(0) do |n|\\n      if m & (1 << n) > 0\\n        nCk = 1\\n        (0..n).each do |k|\\n          count += nCk if [2, 3, 5, 7, 11, 13, 17, 19].member?(k + hi)\\n          nCk = nCk * (n-k) / (k+1)\\n        end\\n        hi += 1\\n      end\\n    end\\n    count\\n  end\\n  under(r+1) - under(l)\\nend\\n```\n```\\nlookup = [[0, 0, 1, 4, 10, 21, 41, 78, 148, 282, 537, 1013, 1882, 3446, 6267, 11468, 21416, 41209, 81771, 166042], [0, 1, 3, 6, 11, 20, 37, 70, 134, 255, 476, 869, 1564, 2821, 5201, 9948, 19793, 40562, 84271, 174952], [1, 2, 3, 5, 9, 17, 33, 64, 121, 221, 393, 695, 1257, 2380, 4747, 9845, 20769, 43709, 90681, 184624], [1, 1, 2, 4, 8, 16, 31, 57, 100, 172, 302, 562, 1123, 2367, 5098, 10924, 22940, 46972, 93943, 184605], [0, 1, 2, 4, 8, 15, 26, 43, 72, 130, 260, 561, 1244, 2731, 5826, 12016, 24032, 46971, 90662, 174762], [1, 1, 2, 4, 7, 11, 17, 29, 58, 130, 301, 683, 1487, 3095, 6190, 12016, 22939, 43691, 84100, 164902], [0, 1, 2, 3, 4, 6, 12, 29, 72, 171, 382, 804, 1608, 3095, 5826, 10923, 20752, 40409, 80802, 164749], [1, 1, 1, 1, 2, 6, 17, 43, 99, 211, 422, 804, 1487, 2731, 5097, 9829, 19657, 40393, 83947, 173775], [0, 0, 0, 1, 4, 11, 26, 56, 112, 211, 382, 683, 1244, 2366, 4732, 9828, 20736, 43554, 89828, 180557], [0, 0, 1, 3, 7, 15, 30, 56, 99, 171, 301, 561, 1122, 2366, 5096, 10908, 22818, 46274, 90729, 172007], [0, 1, 2, 4, 8, 15, 26, 43, 72, 130, 260, 561, 1244, 2730, 5812, 11910, 23456, 44455, 81278, 143754], [1, 1, 2, 4, 7, 11, 17, 29, 58, 130, 301, 683, 1486, 3082, 6098, 11546, 20999, 36823, 62476, 102886], [0, 1, 2, 3, 4, 6, 12, 29, 72, 171, 382, 803, 1596, 3016, 5448, 9453, 15824, 25653, 40410, 62035], [1, 1, 1, 1, 2, 6, 17, 43, 99, 211, 421, 793, 1420, 2432, 4005, 6371, 9829, 14757, 21625, 31009], [0, 0, 0, 1, 4, 11, 26, 56, 112, 210, 372, 627, 1012, 1573, 2366, 3458, 4928, 6868, 9384, 12597], [0, 0, 1, 3, 7, 15, 30, 56, 98, 162, 255, 385, 561, 793, 1092, 1470, 1940, 2516, 3213, 4047], [0, 1, 2, 4, 8, 15, 26, 42, 64, 93, 130, 176, 232, 299, 378, 470, 576, 697, 834, 988], [1, 1, 2, 4, 7, 11, 16, 22, 29, 37, 46, 56, 67, 79, 92, 106, 121, 137, 154, 172], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]]\\n\\nclass Solution(object):\\n    def countPrimeSetBits(self, L, R):\\n        def under(m):\\n            count = 0\\n            K = 0;\\n            for n in range(m.bit_length())[::-1]:\\n                if m & (1 << n):\\n                    count += lookup[K][n]\\n                    K += 1\\n            return count\\n        return under(R+1) - under(L)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990937,
                "title": "c-bits-count-vs-combinatorial-formula-pascal-beats-100",
                "content": "\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBits counting  is very intuitive to solve this question and just uses built-in function. The hard way is to use the follolwing  combinatorial formula\\n$$\\n#\\\\{x <N|bit\\\\_count(x)=k\\\\} =\\n\\\\sum_{i=0}^k C(p[i], k-i)\\n$$\\nwhere p[i]=position for i-th 1 in N\\'s binary expression. The combinatorial numbers $C(N,k)$ are computed by Pascal\\'s traingle, i.e.\\n$\\nC(N, k)=C(N-1, k-1)+C(N-1, k) \\n$ for $N\\\\geq k.$\\n[Please turn on English subtitles if necessary]\\n[https://youtu.be/paoJGMYEEhA?si=QM8YR8CCCTjLXqsA](https://youtu.be/paoJGMYEEhA?si=QM8YR8CCCTjLXqsA)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe question asks the how many numbers $x\\\\in [left, right]$ for which bit_count(x) is a prime. \\n\\nSince the constraints \\n```\\n1 <= left <= right <= 10^6\\n0 <= right - left <= 10^4\\n```\\nare so small, a list of primes below 20 is enough, and the bit-length is not greater than 20. Pascal traingle needs just a small memory need! \\n```\\nint prime[] = {2, 3, 5, 7, 11, 13, 17, 19};\\nint C[21][21] = {0};\\n```\\nSome functions are written:\\n```\\nvoid PascalTriangle(int n)=> compute C\\nvector<int> N2p(int N) => convert N to array p\\nint nums_bitcount(vector<int>& p, int k) =>combinatorial formula\\nint nums_bitcount_isPrime(int N) => summing all k being prime\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\neasy Bits counting method: $O(n\\\\log n)$ \\nhard Combinatorial Formula method $O(\\\\log^2 n)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(\\\\log n)$ vs $O(\\\\log^2 n)$\\n# Hard approach using combinatorial formula beats 100% runtime 0 ms\\n```\\n/*\\nThere is a combinatorial formula for computing \\n#{x <N| x is natural number with bitcount(x)=k} =\\n\\\\sum_{i=0}^k C(p[i], k-i)\\nwhere p[i]=position for i-th 1 in N\\'s binary expression.\\n*/\\n\\nint prime[] = {2, 3, 5, 7, 11, 13, 17, 19};\\nint C[21][21] = {0};\\n\\nclass Solution {\\npublic:\\n    void PascalTriangle(int n) {\\n        for (int i = 0; i <= n; i++) {\\n            fill(C[i], C[i] + (i + 1), 1);\\n            for (int j = 1; j <= i / 2; j++) {\\n                C[i][i-j] = C[i][j] = C[i-1][j-1] + C[i-1][j];\\n            }\\n        }\\n    }\\n\\n    vector<int> N2p(int N) {\\n        bitset<21> bN(N);\\n        vector<int> p;\\n        for (int i=20; i >= 0; i--) {\\n            if (bN[i]) p.push_back(i);\\n        }\\n        return p;\\n    }\\n\\n    int nums_bitcount(vector<int>& p, int k) {\\n        int sum = 0;\\n        for (int i = 0; i < p.size(); i++) {\\n            int maxIndex = min(p[i], k-i);\\n            if (maxIndex >= 0) {\\n                sum += C[p[i]][k-i];\\n            }\\n        }\\n        return sum;\\n    }\\n\\n    int nums_bitcount_isPrime(int N) {\\n        vector<int> p = N2p(N);\\n        int sum = 0;\\n        for (int k : prime) {\\n            sum += nums_bitcount(p, k);\\n        }\\n        return sum;\\n    }\\n\\n    int countPrimeSetBits(int left, int right) {\\n        int L = log2(right+1) + 1;\\n        PascalTriangle(L);\\n        return nums_bitcount_isPrime(right+1)-nums_bitcount_isPrime(left);\\n    }\\n};\\n```\\n# easy approach beats 100% runtime 0 ms\\n\\n```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n        int prime[]={2, 3, 5, 7, 11, 13, 17, 19};\\n        vector<bool> isPrime(21, 0);\\n        for(int p: prime) isPrime[p]=1;\\n        int sum=0;\\n        for(int i=left; i<=right; i++){\\n            int b=__builtin_popcount(i);\\n            if (isPrime[b]) sum++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Combinatorics",
                    "Number Theory"
                ],
                "code": "```\\n1 <= left <= right <= 10^6\\n0 <= right - left <= 10^4\\n```\n```\\nint prime[] = {2, 3, 5, 7, 11, 13, 17, 19};\\nint C[21][21] = {0};\\n```\n```\\nvoid PascalTriangle(int n)=> compute C\\nvector<int> N2p(int N) => convert N to array p\\nint nums_bitcount(vector<int>& p, int k) =>combinatorial formula\\nint nums_bitcount_isPrime(int N) => summing all k being prime\\n```\n```\\n/*\\nThere is a combinatorial formula for computing \\n#{x <N| x is natural number with bitcount(x)=k} =\\n\\\\sum_{i=0}^k C(p[i], k-i)\\nwhere p[i]=position for i-th 1 in N\\'s binary expression.\\n*/\\n\\nint prime[] = {2, 3, 5, 7, 11, 13, 17, 19};\\nint C[21][21] = {0};\\n\\nclass Solution {\\npublic:\\n    void PascalTriangle(int n) {\\n        for (int i = 0; i <= n; i++) {\\n            fill(C[i], C[i] + (i + 1), 1);\\n            for (int j = 1; j <= i / 2; j++) {\\n                C[i][i-j] = C[i][j] = C[i-1][j-1] + C[i-1][j];\\n            }\\n        }\\n    }\\n\\n    vector<int> N2p(int N) {\\n        bitset<21> bN(N);\\n        vector<int> p;\\n        for (int i=20; i >= 0; i--) {\\n            if (bN[i]) p.push_back(i);\\n        }\\n        return p;\\n    }\\n\\n    int nums_bitcount(vector<int>& p, int k) {\\n        int sum = 0;\\n        for (int i = 0; i < p.size(); i++) {\\n            int maxIndex = min(p[i], k-i);\\n            if (maxIndex >= 0) {\\n                sum += C[p[i]][k-i];\\n            }\\n        }\\n        return sum;\\n    }\\n\\n    int nums_bitcount_isPrime(int N) {\\n        vector<int> p = N2p(N);\\n        int sum = 0;\\n        for (int k : prime) {\\n            sum += nums_bitcount(p, k);\\n        }\\n        return sum;\\n    }\\n\\n    int countPrimeSetBits(int left, int right) {\\n        int L = log2(right+1) + 1;\\n        PascalTriangle(L);\\n        return nums_bitcount_isPrime(right+1)-nums_bitcount_isPrime(left);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n        int prime[]={2, 3, 5, 7, 11, 13, 17, 19};\\n        vector<bool> isPrime(21, 0);\\n        for(int p: prime) isPrime[p]=1;\\n        int sum=0;\\n        for(int i=left; i<=right; i++){\\n            int b=__builtin_popcount(i);\\n            if (isPrime[b]) sum++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143037,
                "title": "dp-and-combinatorics-fastest-o-log2-r-complete-math-explanation",
                "content": "Dont forget to upvote if you like the content below. \\uD83D\\uDE43\\n\\n# TL;DR\\nTake as an example the range `[6, 10]`.\\n1. Examine the most significant bit of the binary representation of $$10$$: `1010`.\\n2. For numbers less than `1000` (i.e., 8 in decimal), i.e., in the range of `[0, 111]`, we can fill the $$3$$ bits with $$3$$ or $$2$$ ones. So, the count in this range is $$\\\\binom{3}{3}+\\\\binom{3}{2} = 4$$, where $$\\\\binom{n}{k}$$ denotes the binomial coefficient, i.e., $$\\\\frac{n!}{k!(n - k)!}$$.\\n3. Move to the next $$1$$ and count the numbers in the range `[1000, 1010]`. We can fill the $$1$$ bit with $$1$$ one (because we already \"set\" $$1$$ at the beginning, making the total number of ones $$2$$, and $$2$$ is prime). Thus, the count is $$\\\\binom{1}{1} = 1$$.\\n4. Add the counts from steps 2 and 3 to find the total count of numbers with prime set bits between `0` and `10` exclusively: $$\\\\binom{3}{3}+\\\\binom{3}{2} + \\\\binom{1}{1} = 5$$.\\n5. Check is the original number has prime bits set *(yes, it does)*, and include it also. Now the **desired number** for the range `[0, 10]` is $$5 + 1 = 6$$.\\n5. Doing the same thing for `[0, 5]` we\\'ll get $$2$$.\\n6. Finally, to find the count of numbers with prime set bits in the range `[6, 10]`, subtract the count for `[0, 5]` from the count for `[0, 10]`: $$6 - 2 = 4$$.\\n\\n\\n\\n# Readme\\nIn the next section, I will provide a more comprehensive explanation of the thoughts behind the solution, including the mathematical reasoning and logic. If you notice any mistakes or would like to suggest improvements, please let me know in the comments. \\n\\n# Intuition\\n\\nThe goal of this task is to count the number of integers in the range `[left, right]` with a prime number of set bits in their binary representation. Instead of iterating through all integers in the range and checking the set bits one by one, we can use combinatorics and dynamic programming to solve this problem more efficiently.\\n\\nTo do this, we\\'ll calculate the amount of desired numbers from 0 to `right` inclusively and from 0 to `left` exclusively, and then subtract the latter from the former.\\n\\n## Mathematical Explanation\\n\\nLet\\'s gather some facts.\\n\\nIf we had a function $$f(x)$$ for $$x \\\\in \\\\mathbb{N}$$ which calculates the amount of desired numbers from $$0$$ to $$x$$ inclusively, then a count of these numbers in range $$[a,b]$$ for $$a \\\\in \\\\mathbb{N}$$, and $$b \\\\in \\\\mathbb{N}$$, and $$b \\\\ge a$$ would be $$f(b) - f(a - 1)$$, that\\'s pretty clear.\\n\\nWe may notice that for numbers like $$10..0$$ having $$n$$ zeroes after the first $$1$$ the answer is just a sum of amounts of opportunities to put prime amounts of $$1$$ in $$n$$ places. These numbers are just powers of $$2$$, and this amount of opportunities is $$nCk$$, or $$\\\\binom{n}{k}$$ *(binomial coefficient)*, and $$\\\\binom{n}{k} = \\\\frac{n!}{k! * (n - k)!}$$, where $$n \\\\in \\\\mathbb{N}$$, in our case, is the number of places to put $$1$$ and $$k \\\\in \\\\mathbb{N}$$ is the amount of $$1$$ we are trying to put in them, and $$n \\\\ge k \\\\ge 0$$. This is because the numer itself is definetely doesn\\'t count because it has only 1 *(not prime)* bit set, and with these $$nCk$$ we will check all numbers less than this one.\\n\\nWe can not use $$nCk$$ as is because in our case $$k$$ could possible be greater than $$n$$, so let\\'s define a simple function $$c(n, k)$$ that calculates the binomial coefficient when $$n \\\\ge k$$ and returns 0 otherwise:\\n $$c(n, k) = \\\\begin{cases}0,&\\\\text{if } n < k\\\\\\\\\\\\binom{n}{k}, &\\\\text{otherwise} \\\\end{cases}$$\\n\\nBut we also want these $$k$$ to be only primes ($$k \\\\in \\\\mathbb{P}$$). So let\\'s assume we had a prime-checking function:\\n $$p(x) = \\\\begin{cases}1,&\\\\text{if } x \\\\in \\\\mathbb{P}\\\\\\\\0, &\\\\text{otherwise} \\\\end{cases}$$\\nSo we say that $$f(2^n) = \\\\Sigma_{k=0}^n (p(k) * c(n, k))$$\\n\\nCongratulations, now we\\'re able to calculate the amount of numbers containing prime amount of set bits in their binary representation from $$0$$ to $$2^n$$. \\uD83E\\uDD73\\n\\nBut what about numbers which are not powers of 2? Well, the good news are, as we all know, all numbers are just sums of different powers of 2! Does that mean that we can just decompose any number into it\\'s sum of powers of 2 and sum all values of $$f$$ on them? No, unfortunately, not that easy.\\n \\nConsider a number, for example, $$10100$$. It\\'s obvious that we can not just do $$f(2^4) + f(2^2)$$, because $$f(2^4)$$ already counted all values from $$f(2^2)$$... Wait, was all of that a way to nowhere then?.. No! But we must to make our function a little bit more complex. For the second iteration the amount of $$1$$ to put will be 1 less because we already put one in our number and we can not to avoid of counting it. Now we say that $$f(2^n, x)=\\\\sum_{k=0}^n (p(k) * c(n, k - x))$$ for $$x \\\\in \\\\mathbb{N}$$, which is a number of already set bits, and $$n \\\\in \\\\mathbb{N}$$.\\n\\nOoof... Maybe now it\\'s all done and we can solve it with that sum of values of $$f$$ by our degrees?.. Well, almost. Don\\'t forget to check the number itself if it has prime set bits. \\uD83C\\uDF1A\\n\\nFinally, to find the number of desired numbers in the range $$[left, right]$$, apply the above steps for $$right$$ and $$left - 1$$, and then subtract the latter from the former:\\n\\n$$f(right) - f(left - 1)$$\\n\\nThat\\'s it! This is the complete mathematical explanation of the problem and its solution. Using this approach, we can efficiently count the number of integers with a prime number of set bits in their binary representation for the given range.\\n\\n# Implementation\\n\\nLet\\'s break down the code into its main components and explain the logic behind each part.\\n\\n## Helper Functions\\n\\n### nChooseK\\n\\nThis function calculates the binomial coefficient $$C(n, k)$$, which is used to find the number of ways to choose $$k$$ items from a set of $$n$$ items. The function uses memoization to store previously computed values in a 2D array `nChooseKCache` to avoid redundant calculations.\\n\\nThe function also uses the property $$C(n, k) = C(n, n - k)$$ to reduce the number of calculations needed.\\n\\n### isPrime\\n\\nThis function checks if a given number is a prime number by comparing it against the precomputed list of prime numbers `primes`.\\n\\n### primeBitNumbersCount\\n\\nThis function calculates the number of integers with a prime number of set bits in their binary representation between $$0$$ and a given number `number` (inclusive).\\n\\n1. The function calculates the length of the binary representation of the given number (ignoring the most significant bit, which is always $$1$$) using the formula: $$length = \\\\lfloor \\\\log_2(number) \\\\rfloor$$\\n2. It initializes a `pointer` variable as a power of $$2$$ equal to the length of the binary representation of the given number.\\n3. It iterates through the bits of the given number using a while loop. If the current bit is set ($$1$$), it calculates the number of desired numbers for the remaining bits using the `nChooseK` function and adds the result to the `primeBitsNumbersCount` variable. It then increments the `setBitsCount` variable.\\n4. After iterating through all bits, the function checks if the total number of set bits is prime. If it is, it increments the `primeBitsNumbersCount`.\\n\\n## countPrimeSetBits\\n\\nThis is the main function of the solution. It calculates the number of integers with a prime number of set bits in their binary representation in the range $$[left, right]$$ by invoking the `primeBitNumbersCount` function for `right` and `left - 1`, and then subtracting the latter from the former.\\n\\n# Complexity\\n- Time complexity of the given code is $$O(log\\xB2(right) * P)$$, where $$P$$ is the number of prime numbers used in the algorithm. In this specific case, $$P = 11$$, as there are $$11$$ prime numbers in the primes array.\\n    - The `countPrimeSetBits` function calls `primeBitNumbersCount` twice.\\n    - The `primeBitNumbersCount` function has a while loop that iterates $$log\\u2082(right)$$ times in the worst case, as the position variable starts at $$31$$ and decrements in each iteration until it reaches $$0$$. In each iteration, the function calls `primeBitNumbersCount(position - 1, bitsSet)` method, which has an inner loop that iterates over all the prime numbers in the primes array, i.e., $$P$$ times.\\n    - As a result, the time complexity is $$O(log\\xB2(right) * P)$$.\\n- Space complexity of the code is $$O(1)$$, because the only significant data structures used are the primes array and cache, which have a constant size.\\n\\n\\n# Code\\n```java\\nclass Solution {\\n\\n    private final int[] primes = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31};\\n    private final int[][] nChooseKCache = new int[32][32];\\n\\n    private int nChooseK(int n, int k) {\\n        if (n < 0 || k < 0) {\\n            return 0;\\n        }\\n        k = Math.min(k, n - k); // C(n, k) = C(n, n - k)\\n        if (k == 0 || k == n) {\\n            return 1;\\n        }\\n        if (nChooseKCache[n][k] != 0) {\\n            return nChooseKCache[n][k];\\n        }\\n        nChooseKCache[n][k] = nChooseK(n - 1, k - 1) + nChooseK(n - 1, k);\\n        return nChooseKCache[n][k];\\n    }\\n\\n    private boolean isPrime(int number) {\\n        int i = 0;\\n        while (primes[i] < number) {\\n            i++;\\n        }\\n        return primes[i] == number;\\n    }\\n\\n    private int primeBitNumbersCount(int number) {\\n        int length = (int) (Math.log(number) / Math.log(2));\\n        int pointer = 1 << length;\\n        int setBitsCount = 0;\\n        int primeBitsNumbersCount = 0;\\n\\n        while (pointer != 0) {\\n            if ((number & pointer) > 0) {\\n                for (int i = 0; i < primes.length && primes[i] - setBitsCount <= length; i++) {\\n                    primeBitsNumbersCount += nChooseK(length, primes[i] - setBitsCount);\\n                }\\n                setBitsCount++;\\n            }\\n            pointer >>>= 1;\\n            length--;\\n        }\\n\\n        if (isPrime(setBitsCount)) {\\n            primeBitsNumbersCount++;\\n        }\\n\\n        return primeBitsNumbersCount;\\n    }\\n\\n    public int countPrimeSetBits(int left, int right) {\\n        return primeBitNumbersCount(right) - primeBitNumbersCount(left - 1);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Brainteaser",
                    "Combinatorics"
                ],
                "code": "```java\\nclass Solution {\\n\\n    private final int[] primes = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31};\\n    private final int[][] nChooseKCache = new int[32][32];\\n\\n    private int nChooseK(int n, int k) {\\n        if (n < 0 || k < 0) {\\n            return 0;\\n        }\\n        k = Math.min(k, n - k); // C(n, k) = C(n, n - k)\\n        if (k == 0 || k == n) {\\n            return 1;\\n        }\\n        if (nChooseKCache[n][k] != 0) {\\n            return nChooseKCache[n][k];\\n        }\\n        nChooseKCache[n][k] = nChooseK(n - 1, k - 1) + nChooseK(n - 1, k);\\n        return nChooseKCache[n][k];\\n    }\\n\\n    private boolean isPrime(int number) {\\n        int i = 0;\\n        while (primes[i] < number) {\\n            i++;\\n        }\\n        return primes[i] == number;\\n    }\\n\\n    private int primeBitNumbersCount(int number) {\\n        int length = (int) (Math.log(number) / Math.log(2));\\n        int pointer = 1 << length;\\n        int setBitsCount = 0;\\n        int primeBitsNumbersCount = 0;\\n\\n        while (pointer != 0) {\\n            if ((number & pointer) > 0) {\\n                for (int i = 0; i < primes.length && primes[i] - setBitsCount <= length; i++) {\\n                    primeBitsNumbersCount += nChooseK(length, primes[i] - setBitsCount);\\n                }\\n                setBitsCount++;\\n            }\\n            pointer >>>= 1;\\n            length--;\\n        }\\n\\n        if (isPrime(setBitsCount)) {\\n            primeBitsNumbersCount++;\\n        }\\n\\n        return primeBitsNumbersCount;\\n    }\\n\\n    public int countPrimeSetBits(int left, int right) {\\n        return primeBitNumbersCount(right) - primeBitNumbersCount(left - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563178,
                "title": "go-using-kernighan-s-algorithm-for-counting-set-bits",
                "content": "```\\nfunc countPrimeSetBits(left int, right int) int {\\n    primes := map[int]bool{\\n        2: true,\\n        3: true,\\n        5: true,\\n        7: true,\\n        11: true,\\n        13: true,\\n        17: true,\\n        19: true,\\n    }\\n    c := 0\\n    for i := left; i <= right; i++ {\\n        s := countSetBits(i)\\n        if primes[s] {\\n            c++\\n        }\\n    }\\n    return c\\n}\\n\\nfunc countSetBits(n int) int {\\n    c := 0\\n    for n != 0 {\\n        n = n & (n-1)\\n        c++\\n    }\\n    return c\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countPrimeSetBits(left int, right int) int {\\n    primes := map[int]bool{\\n        2: true,\\n        3: true,\\n        5: true,\\n        7: true,\\n        11: true,\\n        13: true,\\n        17: true,\\n        19: true,\\n    }\\n    c := 0\\n    for i := left; i <= right; i++ {\\n        s := countSetBits(i)\\n        if primes[s] {\\n            c++\\n        }\\n    }\\n    return c\\n}\\n\\nfunc countSetBits(n int) int {\\n    c := 0\\n    for n != 0 {\\n        n = n & (n-1)\\n        c++\\n    }\\n    return c\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2075648,
                "title": "java-for-loop-easy-solution",
                "content": "```\\n    public int countPrimeSetBits(int left, int right) {\\n        int res = 0;\\n        for (int i = left; i <= right; i++) {\\n            if (isPrime(Integer.bitCount(i))) res++;\\n        }\\n        return res;\\n    }\\n\\n    public boolean isPrime(int n) {\\n        if (n <= 1) return false;\\n        for (int i = 2; i < Math.sqrt(n); i++) {\\n            if (n % i == 0) return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int countPrimeSetBits(int left, int right) {\\n        int res = 0;\\n        for (int i = left; i <= right; i++) {\\n            if (isPrime(Integer.bitCount(i))) res++;\\n        }\\n        return res;\\n    }\\n\\n    public boolean isPrime(int n) {\\n        if (n <= 1) return false;\\n        for (int i = 2; i < Math.sqrt(n); i++) {\\n            if (n % i == 0) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 881645,
                "title": "python3-with-checkprime-function",
                "content": "```\\nclass Solution:\\n    def checkPrime(self, number):\\n        if number > 1:\\n            for i in range(2, number):\\n                if (number % i) == 0:\\n                    return False\\n                    break\\n            else:\\n                return True\\n        else:\\n            return False\\n    def countPrimeSetBits(self, L: int, R: int) -> int:\\n        return sum([self.checkPrime(bin(x)[2:].count(\\'1\\')) for x in range(L,R+1)])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkPrime(self, number):\\n        if number > 1:\\n            for i in range(2, number):\\n                if (number % i) == 0:\\n                    return False\\n                    break\\n            else:\\n                return True\\n        else:\\n            return False\\n    def countPrimeSetBits(self, L: int, R: int) -> int:\\n        return sum([self.checkPrime(bin(x)[2:].count(\\'1\\')) for x in range(L,R+1)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 297863,
                "title": "javascript-js-solution-s-that-beats-100",
                "content": "My first approach was the following (it uses [Primality test with 6k \\xB1 1 optimization](https://en.wikipedia.org/wiki/Primality_test#Pseudocode), pre-defined set of known prime numbers and caching):\\n```\\n/**\\n * @param {number} L\\n * @param {number} R\\n * @return {number}\\n */\\nconst getNumOfSetBits = function(n) {\\n    let result = 0;\\n    while (n) {\\n        result += (n & 1);\\n        n = n >> 1;\\n    }\\n    return result;\\n}\\n\\nconst isPrime = function(n) {\\n    if (n <= 1) {\\n        return false;\\n    }\\n    if (n <= 3) {\\n        return true;\\n    }\\n    if (n % 2 === 0 || n % 3 === 0) {\\n        return false;\\n    }\\n    for (let i = 5; i * i < n; i += 6) {\\n        if (n % i === 0 || n % (i + 2) === 0) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nconst primes = new Set([2, 3, 5, 7, 11]);\\n\\nconst countPrimeSetBits = function(L, R) {\\n    let count = 0;\\n    for (let n = L; n <= R; n++) {\\n        const bitNum = getNumOfSetBits(n);\\n        if (primes.has(bitNum)) {\\n            count++;\\n        } else if (isPrime(bitNum)) {\\n            count++;\\n            primes.add(bitNum);\\n        }\\n    }\\n    return count;\\n};\\n```\\nBut then I found a post from [@jxw7410](https://leetcode.com/jxw7410): \"[Python simple solution w/ explanation](https://leetcode.com/problems/prime-number-of-set-bits-in-binary-representation/discuss/203317/Python-simple-solution-w-explanation)\" and siplified the solution to:\\n```\\n/**\\n * @param {number} L\\n * @param {number} R\\n * @return {number}\\n */\\nconst getNumOfSetBits = function(n) {\\n    let result = 0;\\n    while (n) {\\n        result += (n & 1);\\n        n = n >> 1;\\n    }\\n    return result;\\n}\\n\\nconst primes = new Set([2, 3, 5, 7, 11, 13, 17, 19, 23]);\\n\\nconst countPrimeSetBits = function(L, R) {\\n    let count = 0;\\n    for (let n = L; n <= R; n++) {\\n        if (primes.has(getNumOfSetBits(n))) {\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```\\nIt is strange but the second variant shows worse results than the first one.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} L\\n * @param {number} R\\n * @return {number}\\n */\\nconst getNumOfSetBits = function(n) {\\n    let result = 0;\\n    while (n) {\\n        result += (n & 1);\\n        n = n >> 1;\\n    }\\n    return result;\\n}\\n\\nconst isPrime = function(n) {\\n    if (n <= 1) {\\n        return false;\\n    }\\n    if (n <= 3) {\\n        return true;\\n    }\\n    if (n % 2 === 0 || n % 3 === 0) {\\n        return false;\\n    }\\n    for (let i = 5; i * i < n; i += 6) {\\n        if (n % i === 0 || n % (i + 2) === 0) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nconst primes = new Set([2, 3, 5, 7, 11]);\\n\\nconst countPrimeSetBits = function(L, R) {\\n    let count = 0;\\n    for (let n = L; n <= R; n++) {\\n        const bitNum = getNumOfSetBits(n);\\n        if (primes.has(bitNum)) {\\n            count++;\\n        } else if (isPrime(bitNum)) {\\n            count++;\\n            primes.add(bitNum);\\n        }\\n    }\\n    return count;\\n};\\n```\n```\\n/**\\n * @param {number} L\\n * @param {number} R\\n * @return {number}\\n */\\nconst getNumOfSetBits = function(n) {\\n    let result = 0;\\n    while (n) {\\n        result += (n & 1);\\n        n = n >> 1;\\n    }\\n    return result;\\n}\\n\\nconst primes = new Set([2, 3, 5, 7, 11, 13, 17, 19, 23]);\\n\\nconst countPrimeSetBits = function(L, R) {\\n    let count = 0;\\n    for (let n = L; n <= R; n++) {\\n        if (primes.has(getNumOfSetBits(n))) {\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 222284,
                "title": "simple-javascript",
                "content": "```\\n  /**\\n   * https://leetcode.com/problems/prime-number-of-set-bits-in-binary-representation/\\n   * @param {number} L\\n   * @param {number} R\\n   * @return {number}\\n   */\\n  var countPrimeSetBits = function(L, R) {\\n    let result = 0;\\n    let primes = [2, 3, 5, 7, 11, 13, 17, 19, 23];\\n\\n    for(let i = L; i <= R; i++){\\n      let num2 = i.toString(2);\\n      let count = 0;\\n\\n      num2.split(\\'\\').forEach(sym => {\\n        if(sym == 1) count++;\\n      });\\n\\n      if(primes.indexOf(count) > -1) result++;\\n    }\\n\\n    return result;\\n  };\\n  ```",
                "solutionTags": [],
                "code": "```\\n  /**\\n   * https://leetcode.com/problems/prime-number-of-set-bits-in-binary-representation/\\n   * @param {number} L\\n   * @param {number} R\\n   * @return {number}\\n   */\\n  var countPrimeSetBits = function(L, R) {\\n    let result = 0;\\n    let primes = [2, 3, 5, 7, 11, 13, 17, 19, 23];\\n\\n    for(let i = L; i <= R; i++){\\n      let num2 = i.toString(2);\\n      let count = 0;\\n\\n      num2.split(\\'\\').forEach(sym => {\\n        if(sym == 1) count++;\\n      });\\n\\n      if(primes.indexOf(count) > -1) result++;\\n    }\\n\\n    return result;\\n  };\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 3458892,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n        int ans=0;\\n        while(left<=right) {\\n            int cnt=__builtin_popcount(left);\\n            if(cnt==2 || cnt==3 || cnt==5 || cnt==7 || cnt==11 || cnt==13 || cnt==17 || cnt==19)\\n                ++ans;\\n            ++left;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def countPrimeSetBits(self, left: int, right: int) -> int:\\n        primes = {2, 3, 5, 7, 11, 13, 17, 19}\\n        c = 0\\n\\n        for i in range(left, right + 1):\\n            if i.bit_count() in primes:\\n                c += 1\\n                \\n        return c\\n```\\n\\n```Java []\\nclass Solution {\\n    private final int[] primes = new int[]{2, 3, 5, 7, 11, 13, 17, 19};\\n    private int cnk(int n, int k) {\\n        if (n <= 0 || k <= 0) {\\n            return 0;\\n        }\\n        long f1 = 1;\\n        for (int i = k + 1; i <= n; i++) {\\n            f1 *= i;\\n        }\\n        long f2 = 1;\\n        for (int i = 2; i <= n - k; i++) {\\n            f2 *= i;\\n        }\\n        return (int) (f1 / f2);\\n    }\\n    private int primeBitNumbersCount(int length, int minus) {\\n        int result = 0;\\n        for (int i = 0; i < primes.length && primes[i] - minus <= length; i++) {\\n            result += cnk(length, primes[i] - minus);\\n        }\\n        return result;\\n    }\\n    private int primesTo(int number) {\\n        for (int i = primes.length - 1; i >= 0; i--) {\\n            if (number >= primes[i]) {\\n                return i + 1;\\n            }\\n        }\\n        return 0;\\n    }\\n    private int primeBitNumbersCount(int number) {\\n        int pointer = 0x40000000;\\n        int position = 31;\\n        int bitsSet = 0;\\n        int primeBitNumbersCount = 0;  \\n\\n        while (pointer != 0) {\\n            if ((number & pointer) > 0) {\\n                primeBitNumbersCount += primeBitNumbersCount(position - 1, bitsSet);\\n                bitsSet++;\\n            }\\n            pointer >>>= 1;\\n            position--;\\n        }\\n        primeBitNumbersCount += primesTo(bitsSet);\\n        return primeBitNumbersCount;\\n    }\\n    public int countPrimeSetBits(int left, int right) {\\n        return primeBitNumbersCount(right) - primeBitNumbersCount(left - 1);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n        int ans=0;\\n        while(left<=right) {\\n            int cnt=__builtin_popcount(left);\\n            if(cnt==2 || cnt==3 || cnt==5 || cnt==7 || cnt==11 || cnt==13 || cnt==17 || cnt==19)\\n                ++ans;\\n            ++left;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def countPrimeSetBits(self, left: int, right: int) -> int:\\n        primes = {2, 3, 5, 7, 11, 13, 17, 19}\\n        c = 0\\n\\n        for i in range(left, right + 1):\\n            if i.bit_count() in primes:\\n                c += 1\\n                \\n        return c\\n```\n```Java []\\nclass Solution {\\n    private final int[] primes = new int[]{2, 3, 5, 7, 11, 13, 17, 19};\\n    private int cnk(int n, int k) {\\n        if (n <= 0 || k <= 0) {\\n            return 0;\\n        }\\n        long f1 = 1;\\n        for (int i = k + 1; i <= n; i++) {\\n            f1 *= i;\\n        }\\n        long f2 = 1;\\n        for (int i = 2; i <= n - k; i++) {\\n            f2 *= i;\\n        }\\n        return (int) (f1 / f2);\\n    }\\n    private int primeBitNumbersCount(int length, int minus) {\\n        int result = 0;\\n        for (int i = 0; i < primes.length && primes[i] - minus <= length; i++) {\\n            result += cnk(length, primes[i] - minus);\\n        }\\n        return result;\\n    }\\n    private int primesTo(int number) {\\n        for (int i = primes.length - 1; i >= 0; i--) {\\n            if (number >= primes[i]) {\\n                return i + 1;\\n            }\\n        }\\n        return 0;\\n    }\\n    private int primeBitNumbersCount(int number) {\\n        int pointer = 0x40000000;\\n        int position = 31;\\n        int bitsSet = 0;\\n        int primeBitNumbersCount = 0;  \\n\\n        while (pointer != 0) {\\n            if ((number & pointer) > 0) {\\n                primeBitNumbersCount += primeBitNumbersCount(position - 1, bitsSet);\\n                bitsSet++;\\n            }\\n            pointer >>>= 1;\\n            position--;\\n        }\\n        primeBitNumbersCount += primesTo(bitsSet);\\n        return primeBitNumbersCount;\\n    }\\n    public int countPrimeSetBits(int left, int right) {\\n        return primeBitNumbersCount(right) - primeBitNumbersCount(left - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979749,
                "title": "cpp-solution-easy-to-understand-simple-and-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool prime (int x)\\n{\\n    bool flag = false ;\\n    if(x==1) return false;\\n    for(int i =2 ; i < x ; i++)\\n    {\\n        if(x % i ==0 ){flag=true;break;}\\n    }\\n    if(flag)return false;\\n    return true;\\n}\\n    string convert(int x)\\n    {\\n        string ans=\"\";\\n        while( x > 0)\\n        {\\n            if(x % 2 == 0){ans+=\"0\";}\\n            else {ans+=\\'1\\';}\\n            x/=2;\\n        }\\n        return ans;\\n    }\\n    int countone(string s)\\n    {\\n        int count=0;\\n        for(int  i= 0 ;i < s.size();i++)\\n        {\\n          if(s[i] == \\'1\\'){count++;}\\n        }\\n        return count;\\n    }\\n    int countPrimeSetBits(int left, int right) {\\n        int ans=0;\\n        for(int i = left ;i <= right ;i++)\\n        {\\n            int x = countone(convert(i));\\n\\n            if(prime(x)==true){ans++;}\\n        }\\n         return  ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool prime (int x)\\n{\\n    bool flag = false ;\\n    if(x==1) return false;\\n    for(int i =2 ; i < x ; i++)\\n    {\\n        if(x % i ==0 ){flag=true;break;}\\n    }\\n    if(flag)return false;\\n    return true;\\n}\\n    string convert(int x)\\n    {\\n        string ans=\"\";\\n        while( x > 0)\\n        {\\n            if(x % 2 == 0){ans+=\"0\";}\\n            else {ans+=\\'1\\';}\\n            x/=2;\\n        }\\n        return ans;\\n    }\\n    int countone(string s)\\n    {\\n        int count=0;\\n        for(int  i= 0 ;i < s.size();i++)\\n        {\\n          if(s[i] == \\'1\\'){count++;}\\n        }\\n        return count;\\n    }\\n    int countPrimeSetBits(int left, int right) {\\n        int ans=0;\\n        for(int i = left ;i <= right ;i++)\\n        {\\n            int x = countone(convert(i));\\n\\n            if(prime(x)==true){ans++;}\\n        }\\n         return  ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548221,
                "title": "70-beats-c-simple-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int &left, int &right) {\\n        vector<int> v = {0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0};\\n        int ans = 0,x,k;\\n        while(left <= right){\\n            x = 0;\\n            k = left;\\n            while(k){\\n                x += (k&1);\\n                k = k >> 1;\\n            }\\n            ans += v[x];\\n            left++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int &left, int &right) {\\n        vector<int> v = {0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0};\\n        int ans = 0,x,k;\\n        while(left <= right){\\n            x = 0;\\n            k = left;\\n            while(k){\\n                x += (k&1);\\n                k = k >> 1;\\n            }\\n            ans += v[x];\\n            left++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391997,
                "title": "easiest-java-short-and-simple-straight-forward-solution",
                "content": "\\n```\\nclass Solution {\\n     public  int calculateSetBits(String s){\\n        int count=0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i)==\\'1\\') count++;\\n        }\\n        return count;\\n    }\\n\\n    public  boolean isPrime(int n){\\n        if (n==0 || n==1) return false;\\n        for (int i = 2; i <= n/2; i++) {\\n            if(n%i ==0 ) return false;\\n        }\\n//        System.out.println(n+\" - \");\\n        return true;\\n    }\\n\\n    public  int countPrimeSetBits(int left, int right) {\\n        int count=0;\\n        for(int i=left;i<=right;i++){\\n            String b= Integer.toBinaryString(i);\\n\\n            int n=calculateSetBits(b);\\n\\n            if(isPrime(n)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public  int calculateSetBits(String s){\\n        int count=0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i)==\\'1\\') count++;\\n        }\\n        return count;\\n    }\\n\\n    public  boolean isPrime(int n){\\n        if (n==0 || n==1) return false;\\n        for (int i = 2; i <= n/2; i++) {\\n            if(n%i ==0 ) return false;\\n        }\\n//        System.out.println(n+\" - \");\\n        return true;\\n    }\\n\\n    public  int countPrimeSetBits(int left, int right) {\\n        int count=0;\\n        for(int i=left;i<=right;i++){\\n            String b= Integer.toBinaryString(i);\\n\\n            int n=calculateSetBits(b);\\n\\n            if(isPrime(n)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1971581,
                "title": "o-1-to-check-prime-or-not",
                "content": "As no.of primes are limited we can use Hashset to check no.of set bits is prime or not\\n```\\nclass Solution {\\n    public int countPrimeSetBits(int left, int right) {\\n        HashSet<Integer> s=new HashSet<>();\\n        s.add(2);\\n        s.add(3);\\n        s.add(5);\\n        s.add(7);\\n        s.add(11);\\n        s.add(13);\\n        s.add(17);\\n        s.add(19);\\n        s.add(23);\\n        s.add(29);\\n        s.add(31);\\n        int res=0;\\n        for(int i=left;i<=right;i++){\\n            int x=num(i);\\n            if(s.contains(x))\\n                res++;\\n        }\\n        return res;\\n    }\\n    public int num(int x){\\n        int res=0;\\n        for(int i=0;i<32;i++){\\n            if((x&(1<<i))!=0)\\n                res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrimeSetBits(int left, int right) {\\n        HashSet<Integer> s=new HashSet<>();\\n        s.add(2);\\n        s.add(3);\\n        s.add(5);\\n        s.add(7);\\n        s.add(11);\\n        s.add(13);\\n        s.add(17);\\n        s.add(19);\\n        s.add(23);\\n        s.add(29);\\n        s.add(31);\\n        int res=0;\\n        for(int i=left;i<=right;i++){\\n            int x=num(i);\\n            if(s.contains(x))\\n                res++;\\n        }\\n        return res;\\n    }\\n    public int num(int x){\\n        int res=0;\\n        for(int i=0;i<32;i++){\\n            if((x&(1<<i))!=0)\\n                res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900596,
                "title": "easy-solution-faster-than-others-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n){\\n        if(n==2||n==3||n==5 ||n==7||n==11||n==13||n==17||n==19)\\n            return true;\\n        return false;\\n    }\\n    int setCount(int n){\\n        int count=0;\\n        while(n>0){\\n            n=n&(n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n    int countPrimeSetBits(int left, int right) {\\n        int res=0;\\n        for(int i=left;i<=right;i++){\\n            int count=setCount(i);\\n            if(isPrime(count))\\n                res++;\\n            \\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    bool isPrime(int n){\\n        if(n==2||n==3||n==5 ||n==7||n==11||n==13||n==17||n==19)\\n            return true;\\n        return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1878779,
                "title": "prime-number-of-set-bits-in-binary-representation-solution-java",
                "content": "class Solution {\\n  public int countPrimeSetBits(int L, int R) {\\n    // { 2, 3, 5, 7, 11, 13, 17, 19 }th bits are 1s\\n    // (10100010100010101100)2 = (665772)10\\n    final int magic = 665772;\\n    int ans = 0;\\n\\n    for (int n = L; n <= R; ++n)\\n      if ((magic & 1 << Integer.bitCount(n)) > 0)\\n        ++ans;\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n  public int countPrimeSetBits(int L, int R) {\\n    // { 2, 3, 5, 7, 11, 13, 17, 19 }",
                "codeTag": "Java"
            },
            {
                "id": 1555192,
                "title": "c-faster-than-95-75",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    bool prime(int x)\\n    {\\n        return (x == 2 || x == 3 || x == 5 || x == 7 ||\\n                x == 11 || x == 13 || x == 17 || x == 19);\\n    }\\n\\n    int countPrimeSetBits(int left, int right)\\n    {\\n        int count = 0;\\n        int n;\\n        for (int i = left; i <= right; i++)\\n        {\\n            if (prime(__builtin_popcount(i)))\\n                count++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool prime(int x)\\n    {\\n        return (x == 2 || x == 3 || x == 5 || x == 7 ||\\n                x == 11 || x == 13 || x == 17 || x == 19);\\n    }\\n\\n    int countPrimeSetBits(int left, int right)\\n    {\\n        int count = 0;\\n        int n;\\n        for (int i = left; i <= right; i++)\\n        {\\n            if (prime(__builtin_popcount(i)))\\n                count++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520271,
                "title": "c-easy-bit-manipulation-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int CheckCnt(int n) {\\n        int cnt = 0;\\n        \\n        while (n) {\\n            cnt++;\\n            n = n & (n - 1);\\n        }\\n        \\n        return cnt;\\n    }\\n    \\n    bool isPrime(int n) {\\n        if (n <= 1)  return false;\\n\\n        for (int i = 2; i < n; ++i)\\n            if (n % i == 0)\\n                return false;\\n\\n        return true;\\n    }\\n    \\n    int countPrimeSetBits(int left, int right) {\\n        int b_cnt;\\n        int fin_cnt;\\n        \\n        for (int i = left; i <= right; i++) {\\n            b_cnt = CheckCnt(i);\\n            if (isPrime(b_cnt))\\n                fin_cnt++;\\n        }\\n        \\n        return fin_cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int CheckCnt(int n) {\\n        int cnt = 0;\\n        \\n        while (n) {\\n            cnt++;\\n            n = n & (n - 1);\\n        }\\n        \\n        return cnt;\\n    }\\n    \\n    bool isPrime(int n) {\\n        if (n <= 1)  return false;\\n\\n        for (int i = 2; i < n; ++i)\\n            if (n % i == 0)\\n                return false;\\n\\n        return true;\\n    }\\n    \\n    int countPrimeSetBits(int left, int right) {\\n        int b_cnt;\\n        int fin_cnt;\\n        \\n        for (int i = left; i <= right; i++) {\\n            b_cnt = CheckCnt(i);\\n            if (isPrime(b_cnt))\\n                fin_cnt++;\\n        }\\n        \\n        return fin_cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513583,
                "title": "java-brute-force-count-set-bits-prime-checking",
                "content": "```\\nclass Solution {\\n    public int countPrimeSetBits(int left, int right) {\\n        int primes = 0;\\n        for (int i = left; i <= right; i++) {\\n            //counting set bits\\n            int x = countSetBits(i);\\n            if (checkingPrime(x)) {\\n                primes++;\\n            }\\n        }\\n        return primes;\\n    }\\n    \\n    public int countSetBits(int n) {\\n        int count = 0;\\n        while (n != 0) {\\n            count++;\\n            n = n & (n - 1);\\n        }\\n        return count;\\n    }\\n    \\n    public boolean checkingPrime(int n) {\\n        if (n <= 1)\\n            return false;\\n \\n        // Check if number is 2\\n        else if (n == 2)\\n            return true;\\n \\n        // Check if n is a multiple of 2\\n        else if (n % 2 == 0)\\n            return false;\\n \\n        // If not, then just check the odds\\n        for (int i = 3; i <= Math.sqrt(n); i += 2)\\n        {\\n            if (n % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrimeSetBits(int left, int right) {\\n        int primes = 0;\\n        for (int i = left; i <= right; i++) {\\n            //counting set bits\\n            int x = countSetBits(i);\\n            if (checkingPrime(x)) {\\n                primes++;\\n            }\\n        }\\n        return primes;\\n    }\\n    \\n    public int countSetBits(int n) {\\n        int count = 0;\\n        while (n != 0) {\\n            count++;\\n            n = n & (n - 1);\\n        }\\n        return count;\\n    }\\n    \\n    public boolean checkingPrime(int n) {\\n        if (n <= 1)\\n            return false;\\n \\n        // Check if number is 2\\n        else if (n == 2)\\n            return true;\\n \\n        // Check if n is a multiple of 2\\n        else if (n % 2 == 0)\\n            return false;\\n \\n        // If not, then just check the odds\\n        for (int i = 3; i <= Math.sqrt(n); i += 2)\\n        {\\n            if (n % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396940,
                "title": "python-solution-for-only-one-line",
                "content": "constraints: 1 <= left <= right <= 10^6\\n10^6 = \\'0b11110100001001000000\\'\\nmaximum number of 1\\'s present is 20\\nprime numbers within 20 is all of [2, 3, 5, 7, 11, 13, 17, 19]\\n```\\nclass Solution:\\n    def countPrimeSetBits(self, left: int, right: int) -> int:\\n        return len([(list(bin(i)).count(\\'1\\')) for i in range(left, right+1) if (list(bin(i)).count(\\'1\\')) in [2, 3, 5, 7, 11, 13, 17, 19]])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPrimeSetBits(self, left: int, right: int) -> int:\\n        return len([(list(bin(i)).count(\\'1\\')) for i in range(left, right+1) if (list(bin(i)).count(\\'1\\')) in [2, 3, 5, 7, 11, 13, 17, 19]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367480,
                "title": "runtime-4ms-faster-than-95-c-solution",
                "content": "```\\nint ones(int num){\\nint res=0;\\nwhile(n>0){\\nnum = num & (num-1);\\nres++;\\n}\\nreturn res;\\n}\\n    int countPrimeSetBits(int left, int right) {\\n        int res=0;\\n        for(int i=left;i<=right;i++){\\n            int ans = ones(i);\\n            if((ans & 1)!=0 || ans==2){\\n                if(ans==3)\\n                    res++;\\n                if(ans!=1 && ans%3!=0)\\n                res++;\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint ones(int num){\\nint res=0;\\nwhile(n>0){\\nnum = num & (num-1);\\nres++;\\n}\\nreturn res;\\n}\\n    int countPrimeSetBits(int left, int right) {\\n        int res=0;\\n        for(int i=left;i<=right;i++){\\n            int ans = ones(i);\\n            if((ans & 1)!=0 || ans==2){\\n                if(ans==3)\\n                    res++;\\n                if(ans!=1 && ans%3!=0)\\n                res++;\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1282324,
                "title": "java-naive-approach",
                "content": "\\tpublic int CountNumberofSetBit(int n){\\n\\t//      -n ==2\\'s Complement\\n\\t\\t\\tint counter=0;\\n\\t\\t\\twhile (n!=0){\\n\\t\\t\\t\\tint temp = n & -n;\\n\\t\\t\\t\\tn-=temp;\\n\\t\\t\\t\\tcounter++;\\n\\t\\t\\t}\\n\\t\\t\\treturn(counter);\\n\\t\\t}\\n\\t\\tpublic int countPrimeSetBits(int left, int right) {\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i =left;i<=right;i++){\\n\\t\\t\\t\\tint count=CountNumberofSetBit(i);\\n\\t\\t\\t\\tint div=0;\\n\\t\\t\\t\\tfor(int j=2;j<count;j++){\\n\\t\\t\\t\\t\\tif(count%j==0){\\n\\t\\t\\t\\t\\t\\tdiv++;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!(div>0||count<=1)){\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\tpublic int CountNumberofSetBit(int n){\\n\\t//      -n ==2\\'s Complement\\n\\t\\t\\tint counter=0;\\n\\t\\t\\twhile (n!=0){\\n\\t\\t\\t\\tint temp = n & -n;\\n\\t\\t\\t\\tn-=temp;\\n\\t\\t\\t\\tcounter++;\\n\\t\\t\\t}\\n\\t\\t\\treturn(counter);\\n\\t\\t}\\n\\t\\tpublic int countPrimeSetBits(int left, int right) {\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i =left;i<=right;i++){\\n\\t\\t\\t\\tint count=CountNumberofSetBit(i);\\n\\t\\t\\t\\tint div=0;\\n\\t\\t\\t\\tfor(int j=2;j<count;j++){\\n\\t\\t\\t\\t\\tif(count%j==0){\\n\\t\\t\\t\\t\\t\\tdiv++;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(!(div>0||count<=1)){\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1204247,
                "title": "faster-than-99-16-java-soultion",
                "content": "class Solution {\\n    public boolean prime(int n)\\n    {\\n        if(n==2 || n==3|| n==5|| n==7|| n==11||n==13|| n==17|| n==19 || n==23)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    public int countPrimeSetBits(int left, int right) {\\n        if(right<15)\\n            return right-left;\\n        int count=0;\\n        for(int i=left;i<=right;i++)\\n        {\\n            int n= Integer.bitCount(i);\\n            if(prime(n))\\n                count++;\\n        }\\n        return count;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public boolean prime(int n)\\n    {\\n        if(n==2 || n==3|| n==5|| n==7|| n==11||n==13|| n==17|| n==19 || n==23)\\n        {\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1067566,
                "title": "faster-than-94-62-of-python3-online-submissions",
                "content": "```\\nclass Solution:\\n    def countPrimeSetBits(self, L: int, R: int) -> int:\\n        prime = {2,3,5,7,11,13,17,19}\\n        count = 0\\n        for i in range(L,R + 1):\\n            num = bin(i).count(\\'1\\')\\n            if num in prime:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPrimeSetBits(self, L: int, R: int) -> int:\\n        prime = {2,3,5,7,11,13,17,19}\\n        count = 0\\n        for i in range(L,R + 1):\\n            num = bin(i).count(\\'1\\')\\n            if num in prime:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735780,
                "title": "java-clean-code-o-n-log-n-optimal-solution",
                "content": "```\\nclass Solution {\\n    \\n    private boolean isPrime (int n) {\\n        return n == 2 || n == 3 || n == 5 || n == 7 || n == 11 || n == 13 || n== 17 || n == 19;\\n    }\\n    \\n    public int countPrimeSetBits(int L, int R) {\\n        \\n        int ans = 0;\\n        \\n        while (L <= R) {\\n            if (isPrime (Integer.bitCount (L++))) {\\n                ++ans;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private boolean isPrime (int n) {\\n        return n == 2 || n == 3 || n == 5 || n == 7 || n == 11 || n == 13 || n== 17 || n == 19;\\n    }\\n    \\n    public int countPrimeSetBits(int L, int R) {\\n        \\n        int ans = 0;\\n        \\n        while (L <= R) {\\n            if (isPrime (Integer.bitCount (L++))) {\\n                ++ans;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662670,
                "title": "c-easy-solution-to-understand-no-built-in-methods",
                "content": "<hr>\\n\\n**Please upvote if you like this post.**\\n<hr>\\n\\n**Result:** Accepted\\n```\\nclass Solution {\\npublic:\\n    bool isPrime(int n){\\n        if(n==1)\\n            return false;\\n        int count=0;\\n        for(int i=2;i<=n;i++){\\n            if(n%i==0)\\n                count++;\\n        }\\n        if(count==1)\\n            return true;\\n        return false;\\n    }\\n    \\n    int countPrimeSetBits(int L, int R) {\\n        int noPrime = 0;\\n        for(int i=L;i<=R;i++){\\n            int num=i,countOne=0;\\n            while(num>0){\\n                if(num%2==1)\\n                    countOne++;\\n                num=num/2;\\n            }\\n            if(isPrime(countOne))\\n                noPrime++;\\n        }\\n        return noPrime;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n){\\n        if(n==1)\\n            return false;\\n        int count=0;\\n        for(int i=2;i<=n;i++){\\n            if(n%i==0)\\n                count++;\\n        }\\n        if(count==1)\\n            return true;\\n        return false;\\n    }\\n    \\n    int countPrimeSetBits(int L, int R) {\\n        int noPrime = 0;\\n        for(int i=L;i<=R;i++){\\n            int num=i,countOne=0;\\n            while(num>0){\\n                if(num%2==1)\\n                    countOne++;\\n                num=num/2;\\n            }\\n            if(isPrime(countOne))\\n                noPrime++;\\n        }\\n        return noPrime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165055,
                "title": "java-with-sieve-of-eratosphenus",
                "content": "```\\nclass Solution {\\n    boolean[] prime;\\n    void sieveOfEratosphenus(int n){\\n        prime = new boolean[n+1];\\n        for(int i = 0; i < n; i++)\\n            prime[i] = true;\\n         \\n        for(int p = 2; p*p <=n; p++)\\n        {\\n            // If prime[p] is not changed, then it is a prime\\n            if(prime[p] == true)\\n            {\\n                // Update all multiples of p\\n                for(int i = p*2; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n        prime[1] = false;\\n    }\\n    public int numberOfOnes(int n){\\n        String inBinary = Integer.toBinaryString(n);\\n        int res = 0;\\n        for(int i = 0; i < inBinary.length(); i++){\\n            if(inBinary.charAt(i)==\\'1\\'){\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int countPrimeSetBits(int L, int R) {\\n        int sum = 0;\\n        sieveOfEratosphenus(R);\\n        System.out.print(prime[1]);\\n        for(int i = L; i<=R; i++){\\n            int ones = numberOfOnes(i);\\n            if(prime[ones] == true) sum++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean[] prime;\\n    void sieveOfEratosphenus(int n){\\n        prime = new boolean[n+1];\\n        for(int i = 0; i < n; i++)\\n            prime[i] = true;\\n         \\n        for(int p = 2; p*p <=n; p++)\\n        {\\n            // If prime[p] is not changed, then it is a prime\\n            if(prime[p] == true)\\n            {\\n                // Update all multiples of p\\n                for(int i = p*2; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n        prime[1] = false;\\n    }\\n    public int numberOfOnes(int n){\\n        String inBinary = Integer.toBinaryString(n);\\n        int res = 0;\\n        for(int i = 0; i < inBinary.length(); i++){\\n            if(inBinary.charAt(i)==\\'1\\'){\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int countPrimeSetBits(int L, int R) {\\n        int sum = 0;\\n        sieveOfEratosphenus(R);\\n        System.out.print(prime[1]);\\n        for(int i = L; i<=R; i++){\\n            int ones = numberOfOnes(i);\\n            if(prime[ones] == true) sum++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113225,
                "title": "short-c-12-ms",
                "content": "    int countPrimeSetBits(int L, int R) {\\n        int count = 0;\\n        while (L <= R) {\\n            int b = __builtin_popcount(L++);\\n            count += b < 4 ? b > 1 : b % 2 && b % 3;\\n        }\\n        return count;\\n    }\\n\\nNumbers in the allowed range have only up to 20 bits and for a primality check it suffices to check prime divisors until the square root, so I just test prime divisors 2 and 3.",
                "solutionTags": [],
                "code": "    int countPrimeSetBits(int L, int R) {\\n        int count = 0;\\n        while (L <= R) {\\n            int b = __builtin_popcount(L++);\\n            count += b < 4 ? b > 1 : b % 2 && b % 3;\\n        }\\n        return count;\\n    }\\n\\nNumbers in the allowed range have only up to 20 bits and for a primality check it suffices to check prime divisors until the square root, so I just test prime divisors 2 and 3.",
                "codeTag": "Unknown"
            },
            {
                "id": 3566428,
                "title": "c-solution-70-time-67-5-space-used-set",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(log2(n))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountPrimeSetBits(int left, int right) {\\n        int i, maxPrime = 32, step=1, n=0;\\n        HashSet<int> s = new HashSet<int>();\\n        for (i = 2; i <= maxPrime; i+=step) {\\n            if (isPrime(ref i)) {\\n                s.Add(i);\\n            }\\n            if (i == 3) {\\n                ++step;\\n            }\\n        }\\n        for (i = left; i <= right; ++i) {\\n            if (s.Contains(binCountBitsOn(ref i))) {\\n                ++n;\\n            }\\n        }\\n        return n;\\n    }\\n\\n    public int binCountBitsOn(ref int n) {\\n        int i, c = 0;\\n        for (i = 1 << 30; i > 0; i = i / 2) {\\n            if((n & i) != 0) {\\n                ++c;\\n            }\\n        }\\n        return c;\\n    }\\n\\n    public bool isPrime(ref int n) {\\n        if (n <= 1) {\\n            return false;\\n        } else if (n == 2) {\\n            return true;\\n        }\\n        for (int i = 3; i < n; i+=2) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n}\\n\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountPrimeSetBits(int left, int right) {\\n        int i, maxPrime = 32, step=1, n=0;\\n        HashSet<int> s = new HashSet<int>();\\n        for (i = 2; i <= maxPrime; i+=step) {\\n            if (isPrime(ref i)) {\\n                s.Add(i);\\n            }\\n            if (i == 3) {\\n                ++step;\\n            }\\n        }\\n        for (i = left; i <= right; ++i) {\\n            if (s.Contains(binCountBitsOn(ref i))) {\\n                ++n;\\n            }\\n        }\\n        return n;\\n    }\\n\\n    public int binCountBitsOn(ref int n) {\\n        int i, c = 0;\\n        for (i = 1 << 30; i > 0; i = i / 2) {\\n            if((n & i) != 0) {\\n                ++c;\\n            }\\n        }\\n        return c;\\n    }\\n\\n    public bool isPrime(ref int n) {\\n        if (n <= 1) {\\n            return false;\\n        } else if (n == 2) {\\n            return true;\\n        }\\n        for (int i = 3; i < n; i+=2) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555971,
                "title": "762-prime-number-of-set-bits-in-binary-representation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n){\\n        bool flag=true;\\n        if(n==0 || n==1)    return false;\\n        for(int i=2;i*i<=n;i++){\\n            if(n%i==0){\\n                flag=false;\\n                break;\\n            }\\n        }\\n        return flag;\\n    }\\n    int countPrimeSetBits(int left, int right) {\\n        int res=0,cnt=0;\\n        for(int i=left;i<=right;i++){\\n            cnt=0;\\n            int tmp=i;\\n            while(tmp>0){\\n                if(tmp&1)   cnt++;\\n                tmp>>=1;\\n            }\\n            if(isPrime(cnt)) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n){\\n        bool flag=true;\\n        if(n==0 || n==1)    return false;\\n        for(int i=2;i*i<=n;i++){\\n            if(n%i==0){\\n                flag=false;\\n                break;\\n            }\\n        }\\n        return flag;\\n    }\\n    int countPrimeSetBits(int left, int right) {\\n        int res=0,cnt=0;\\n        for(int i=left;i<=right;i++){\\n            cnt=0;\\n            int tmp=i;\\n            while(tmp>0){\\n                if(tmp&1)   cnt++;\\n                tmp>>=1;\\n            }\\n            if(isPrime(cnt)) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516215,
                "title": "python-one-liner",
                "content": "# Intuition\\nJust iterate and sum\\n\\nNote that 10**6 has 20 bits, so we need only primes <= 20.\\nAlso, python 3.10 introduced int.bit_count() that is more or less equivalent to bin(x).count(\"1\") but obviously much faster.\\n\\n\\n# Complexity\\n- Time complexity: O(n) - iterating over the left..right range.\\n\\n- Space complexity: O(1) - sum is computed via generator\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrimeSetBits(self, left: int, right: int) -> int:\\n        return (primes := (2,3,5,7,11,13,17,19)) and sum((x.bit_count() in primes) for x in range(left, right+1))\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrimeSetBits(self, left: int, right: int) -> int:\\n        return (primes := (2,3,5,7,11,13,17,19)) and sum((x.bit_count() in primes) for x in range(left, right+1))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235229,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int a)\\n    {\\n        int ans=0;\\n        while(a>0)\\n        {\\n            if(a%2==1)ans++;\\n\\n            a/=2;\\n        }\\n        return ans;\\n    }\\n    bool isprime(int a)\\n    {\\n        if(a==1)return false;\\n        for(int i=2;i<=sqrt(a);i++)\\n        {\\n            if(a%i==0)return false;\\n        }\\n        return true;\\n    }\\n    int countPrimeSetBits(int left, int right) {\\n        int ans=0;\\n        for(int i=left;i<=right;i++)\\n        {\\n            int a=solve(i);\\n            if(isprime(a)==true)\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int a)\\n    {\\n        int ans=0;\\n        while(a>0)\\n        {\\n            if(a%2==1)ans++;\\n\\n            a/=2;\\n        }\\n        return ans;\\n    }\\n    bool isprime(int a)\\n    {\\n        if(a==1)return false;\\n        for(int i=2;i<=sqrt(a);i++)\\n        {\\n            if(a%i==0)return false;\\n        }\\n        return true;\\n    }\\n    int countPrimeSetBits(int left, int right) {\\n        int ans=0;\\n        for(int i=left;i<=right;i++)\\n        {\\n            int a=solve(i);\\n            if(isprime(a)==true)\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3199774,
                "title": "prime-number-of-set-bits-in-binary-representation-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n        int i, j, k, flag=0, countbits=0, count=0;\\n        for(i=left ; i<=right ; i++)\\n        {\\n            flag=0;\\n            countbits=0;\\n            j = i;\\n            while(j>0)\\n            {\\n                k = j%2;\\n                j = j/2;\\n                if(k==1)\\n                {\\n                    countbits++;\\n                }\\n            }\\n            for(j=2 ; j<=countbits/2 ; j++)\\n            {\\n                if(countbits%j==0)\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag!=1 && countbits>1)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n        int i, j, k, flag=0, countbits=0, count=0;\\n        for(i=left ; i<=right ; i++)\\n        {\\n            flag=0;\\n            countbits=0;\\n            j = i;\\n            while(j>0)\\n            {\\n                k = j%2;\\n                j = j/2;\\n                if(k==1)\\n                {\\n                    countbits++;\\n                }\\n            }\\n            for(j=2 ; j<=countbits/2 ; j++)\\n            {\\n                if(countbits%j==0)\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag!=1 && countbits>1)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111287,
                "title": "javascript",
                "content": "\\n```\\nvar countPrimeSetBits = function (left, right) {\\n    // numbers not greater then 10^6 have max 20 set bits\\n    // primes to check 2, 3, 5, 7, 11, 13, 17, 19\\n    \\n    const primes = [2, 3, 5, 7, 11, 13, 17, 19];\\n    let count = 0;\\n\\n    for (let i = left; i <= right; i++) {\\n        const setBitCount = [...i.toString(2)].reduce((s, c) => s + +c, 0);\\n        if (primes.includes(setBitCount)) count++;\\n    }\\n\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countPrimeSetBits = function (left, right) {\\n    // numbers not greater then 10^6 have max 20 set bits\\n    // primes to check 2, 3, 5, 7, 11, 13, 17, 19\\n    \\n    const primes = [2, 3, 5, 7, 11, 13, 17, 19];\\n    let count = 0;\\n\\n    for (let i = left; i <= right; i++) {\\n        const setBitCount = [...i.toString(2)].reduce((s, c) => s + +c, 0);\\n        if (primes.includes(setBitCount)) count++;\\n    }\\n\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3018402,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int countPrimeSetBits(int l, int r) {\\n set<int> p = { 2, 3, 5, 7, 11, 13, 17, 19};// max possible prime no. 19.Because of range is 10^6  \\n        int x=0;\\n        while((r-l+1)!=0){\\n        int i=0;\\n        int y=l;// here we put the value to y because if you use l as code than value of l change.....\\n        while(y!=0){\\n        i+=(y&1);\\n        y=y>>1;\\n         }\\n        x+=p.count(i);\\n        l++;\\n        }\\n        return x;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int countPrimeSetBits(int l, int r) {\\n set<int> p = { 2, 3, 5, 7, 11, 13, 17, 19};// max possible prime no. 19.Because of range is 10^6  \\n        int x=0;\\n        while((r-l+1)!=0){\\n        int i=0;\\n        int y=l;// here we put the value to y because if you use l as code than value of l change.....\\n        while(y!=0){\\n        i+=(y&1);\\n        y=y>>1;\\n         }\\n        x+=p.count(i);\\n        l++;\\n        }\\n        return x;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2866532,
                "title": "swift-easy-to-understand",
                "content": "```\\nclass Solution {\\n    func countPrimeSetBits(_ left: Int, _ right: Int) -> Int {\\n\\t    var left = left\\n\\t    var result = 0\\n\\t    while left <= right {\\n\\t\\t    result += isPrime(left.nonzeroBitCount) ? 1 : 0\\n\\t\\t    left += 1\\n\\t    }\\n\\t    return result\\n    }\\n\\n    func isPrime(_ number: Int) -> Bool {\\n\\t    return number > 1 && !(2..<number).contains { number % $0 == 0 }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countPrimeSetBits(_ left: Int, _ right: Int) -> Int {\\n\\t    var left = left\\n\\t    var result = 0\\n\\t    while left <= right {\\n\\t\\t    result += isPrime(left.nonzeroBitCount) ? 1 : 0\\n\\t\\t    left += 1\\n\\t    }\\n\\t    return result\\n    }\\n\\n    func isPrime(_ number: Int) -> Bool {\\n\\t    return number > 1 && !(2..<number).contains { number % $0 == 0 }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719011,
                "title": "prime-number-of-set-bits-in-binary-representation-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n        int count=0;\\n        for(int i=left;i<=right;++i)\\n        {\\n            bitset<32> b(i);\\n            int x=b.count();\\n            int flag=0;\\n             if(x==1)\\n                 continue;\\n            for(int j=2;j<=sqrt(x);++j)\\n            {\\n                if(x%j==0)\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n        int count=0;\\n        for(int i=left;i<=right;++i)\\n        {\\n            bitset<32> b(i);\\n            int x=b.count();\\n            int flag=0;\\n             if(x==1)\\n                 continue;\\n            for(int j=2;j<=sqrt(x);++j)\\n            {\\n                if(x%j==0)\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709505,
                "title": "prime-number-of-set-bits-in-binary-representation-python",
                "content": "I have this problem explained and solved on my channel , please check it out.\\nhttps://youtube.com/playlist?list=PLxukZCav2iGzzFMWq-esWbEEZ0KJ17t9L\\nalso please, give your valueable feedback.\\n```\\nclass Solution:\\n    def countPrimeSetBits(self, left: int, right: int) -> int:\\n        def isPrime(n:int)->bool :\\n            count=0\\n            for i in range(1,n+1) :\\n                if n%i==0:\\n                    count+=1\\n            if count==2 :\\n                return True\\n            else:\\n                return False\\n        countp=0\\n        for i in range(left,right+1) :\\n            ans = bin(i).count(\"1\")\\n            if isPrime(ans) :\\n                countp+=1\\n        return countp\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countPrimeSetBits(self, left: int, right: int) -> int:\\n        def isPrime(n:int)->bool :\\n            count=0\\n            for i in range(1,n+1) :\\n                if n%i==0:\\n                    count+=1\\n            if count==2 :\\n                return True\\n            else:\\n                return False\\n        countp=0\\n        for i in range(left,right+1) :\\n            ans = bin(i).count(\"1\")\\n            if isPrime(ans) :\\n                countp+=1\\n        return countp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465099,
                "title": "c-setbit-count-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n        int res=0;\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(check(bits(i)))\\n                res++;\\n        }\\n        return res;\\n    }\\n    int check(int n)\\n    {\\n        if(n<2)\\n            return 0;\\n        for(int i=2;i<=sqrt(n);i++)\\n        {\\n            if(n%i==0)\\n                return 0;\\n        }\\n        return 1;\\n    }\\n    int bits(int n)\\n    {\\n        int c=0;\\n        while(n)\\n        {\\n            c+=n%2;\\n            n/=2;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n        int res=0;\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(check(bits(i)))\\n                res++;\\n        }\\n        return res;\\n    }\\n    int check(int n)\\n    {\\n        if(n<2)\\n            return 0;\\n        for(int i=2;i<=sqrt(n);i++)\\n        {\\n            if(n%i==0)\\n                return 0;\\n        }\\n        return 1;\\n    }\\n    int bits(int n)\\n    {\\n        int c=0;\\n        while(n)\\n        {\\n            c+=n%2;\\n            n/=2;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386763,
                "title": "almighty-c",
                "content": "\\tint countSetBits(int n)\\n\\t\\t{\\n\\t\\t\\tint count = 0;\\n\\t\\t\\twhile(n!=0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tn = n&(n-1);\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n    \\n    bool isPrime(int n)\\n    {\\n        if(n==2 || n==3 || n==5 || n==7 || n==11 || n==13 || n==17 || n==19 || n==23 || n==29)\\n            return true;\\n        \\n        return false;\\n    }\\n\\n    \\n    int countPrimeSetBits(int left, int right)\\n    {\\n    \\n        int i,count = 0;\\n        for(i=left;i<=right;i++)\\n        {\\n            if(isPrime(countSetBits(i)))\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tint countSetBits(int n)\\n\\t\\t{\\n\\t\\t\\tint count = 0;\\n\\t\\t\\twhile(n!=0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tn = n&(n-1);\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n    \\n    bool isPrime(int n)\\n    {\\n        if(n==2 || n==3 || n==5 || n==7 || n==11 || n==13 || n==17 || n==19 || n==23 || n==29)\\n            return true;\\n        \\n        return false;\\n    }\\n\\n    \\n    int countPrimeSetBits(int left, int right)\\n    {\\n    \\n        int i,count = 0;\\n        for(i=left;i<=right;i++)\\n        {\\n            if(isPrime(countSetBits(i)))\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2359746,
                "title": "c-100-fast-100-less-memory-usage",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrimary(int n){\\n        if(n <= 1) return false;\\n        for(int i = 2; i<=n/2; i++){\\n            if(n%i == 0) return false;\\n        }\\n        return true;\\n    }\\n    \\n    int countBits(int n){\\n        int x = 0;\\n        while(n>0){\\n            n = n & (n-1);\\n            x++;\\n        }\\n        return x;\\n    }\\n    \\n    int countPrimeSetBits(int left, int right) {\\n        int count = 0;\\n        for(int i = left; i<=right; i++){\\n            if(isPrimary(countBits(i))) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrimary(int n){\\n        if(n <= 1) return false;\\n        for(int i = 2; i<=n/2; i++){\\n            if(n%i == 0) return false;\\n        }\\n        return true;\\n    }\\n    \\n    int countBits(int n){\\n        int x = 0;\\n        while(n>0){\\n            n = n & (n-1);\\n            x++;\\n        }\\n        return x;\\n    }\\n    \\n    int countPrimeSetBits(int left, int right) {\\n        int count = 0;\\n        for(int i = left; i<=right; i++){\\n            if(isPrimary(countBits(i))) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266541,
                "title": "python-easy-and-fast",
                "content": "```\\nimport math\\nclass Solution:\\n    def countPrimeSetBits(self, left: int, right: int) -> int:\\n        primes = set()\\n        for i in range(2, 30):\\n            for p in primes:\\n                if i%p == 0: break\\n            else:\\n                primes.add(i)\\n        res = 0\\n        for i in range(left, right+1):\\n            if bin(i).count(\\'1\\') in primes:\\n                res += 1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def countPrimeSetBits(self, left: int, right: int) -> int:\\n        primes = set()\\n        for i in range(2, 30):\\n            for p in primes:\\n                if i%p == 0: break\\n            else:\\n                primes.add(i)\\n        res = 0\\n        for i in range(left, right+1):\\n            if bin(i).count(\\'1\\') in primes:\\n                res += 1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2223600,
                "title": "a-faster-solution-o-4-log-r-log-r-0ms-digit-dp-c",
                "content": "Wrote a digit dp solution out of boredom.\\nPrecautionary advice for beginners : It is okay if you don\\'t understand this solution right now. This code is optimal for higher constraints on R-L (like 1e18), where we can not traverse from L to R for optimal solution.\\n\\nConvert both left and right to their binary representation as strings. After that count all the strings that exist (lexicographcally) between a and b (both inclusive) and end up having prime number of set bits that is \\'1\\'s.\\n\\n**Similar Problem**\\nhttps://leetcode.com/problems/find-all-good-strings/\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    vector <int> prime;\\n    \\n    int memo[32][2][2][32];\\n    \\n    int helper(string &a, string &b, int i, int down, int up, int cnt)\\n    {\\n        if(i >= a.size())\\n        {\\n            if(prime[cnt]==1)\\n                return 1;\\n            return 0;\\n        }\\n        \\n        if(memo[i][down][up][cnt] != -1) return memo[i][down][up][cnt]; \\n        \\n        int ans = 0;\\n        \\n        int low = 0;\\n        int high = 1;\\n        \\n        if(!down)\\n            low = a[i]-\\'0\\';\\n        \\n        if(!up)\\n            high = b[i]-\\'0\\';\\n        \\n        for(int j = low; j <= high; j++)\\n        {\\n            ans += helper(a,b,i+1,down||(j > low), up||(j < high), cnt + (j==1));\\n        }\\n        \\n        return memo[i][down][up][cnt] = ans;\\n    }\\n    \\n    int countPrimeSetBits(int left, int right) {\\n        \\n        string a,b;\\n        markPrimes();\\n        \\n        while(left)\\n        {\\n            a += \\'0\\' + left%2;\\n            left/=2;\\n        }\\n        \\n        while(right)\\n        {\\n            b += \\'0\\' + right%2;\\n            right/=2;\\n        }\\n        \\n        while(a.size() < 31)\\n            a += \\'0\\';\\n        \\n        while(b.size() < 31)\\n            b += \\'0\\';\\n        \\n        reverse(a.begin(), a.end());\\n        reverse(b.begin(), b.end());\\n        \\n        memset(memo,-1,sizeof memo);\\n        int ans = helper(a,b,0,0,0,0);\\n        return ans;\\n    }\\n    \\n    void markPrimes()\\n    {\\n        prime.resize(33,0);\\n        prime[2] = 1;\\n        prime[3] = 1;\\n        prime[5] = 1;\\n        prime[7] = 1;\\n        prime[11] = 1;\\n        prime[13] = 1;\\n        prime[17] = 1;\\n        prime[19] = 1;\\n        prime[23] = 1;\\n        prime[29] = 1;\\n        prime[31] = 1;\\n    }\\n};\\n```\\n\\nTime complexity : O(4* log(r)* log(r))\\nSpace complexity : O(4* log(r)* log(r))",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector <int> prime;\\n    \\n    int memo[32][2][2][32];\\n    \\n    int helper(string &a, string &b, int i, int down, int up, int cnt)\\n    {\\n        if(i >= a.size())\\n        {\\n            if(prime[cnt]==1)\\n                return 1;\\n            return 0;\\n        }\\n        \\n        if(memo[i][down][up][cnt] != -1) return memo[i][down][up][cnt]; \\n        \\n        int ans = 0;\\n        \\n        int low = 0;\\n        int high = 1;\\n        \\n        if(!down)\\n            low = a[i]-\\'0\\';\\n        \\n        if(!up)\\n            high = b[i]-\\'0\\';\\n        \\n        for(int j = low; j <= high; j++)\\n        {\\n            ans += helper(a,b,i+1,down||(j > low), up||(j < high), cnt + (j==1));\\n        }\\n        \\n        return memo[i][down][up][cnt] = ans;\\n    }\\n    \\n    int countPrimeSetBits(int left, int right) {\\n        \\n        string a,b;\\n        markPrimes();\\n        \\n        while(left)\\n        {\\n            a += \\'0\\' + left%2;\\n            left/=2;\\n        }\\n        \\n        while(right)\\n        {\\n            b += \\'0\\' + right%2;\\n            right/=2;\\n        }\\n        \\n        while(a.size() < 31)\\n            a += \\'0\\';\\n        \\n        while(b.size() < 31)\\n            b += \\'0\\';\\n        \\n        reverse(a.begin(), a.end());\\n        reverse(b.begin(), b.end());\\n        \\n        memset(memo,-1,sizeof memo);\\n        int ans = helper(a,b,0,0,0,0);\\n        return ans;\\n    }\\n    \\n    void markPrimes()\\n    {\\n        prime.resize(33,0);\\n        prime[2] = 1;\\n        prime[3] = 1;\\n        prime[5] = 1;\\n        prime[7] = 1;\\n        prime[11] = 1;\\n        prime[13] = 1;\\n        prime[17] = 1;\\n        prime[19] = 1;\\n        prime[23] = 1;\\n        prime[29] = 1;\\n        prime[31] = 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171256,
                "title": "c-solution-with-brian-kernighan-s-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int left, int right) \\n    {\\n        vector<bool> prime(20, false);\\n        prime[2] = prime[3] = prime[5] = prime[7] = prime[11] = prime[13] = prime[17] = prime[19] = true;\\n        \\n        int res = 0;\\n        \\n        for(int i=left; i<=right; i++)\\n        {\\n            int cnt = 0;\\n            int num = i;\\n            while(num)\\n            {\\n                num = num & (num-1);\\n                cnt++;\\n            }\\n            \\n            res += prime[cnt];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int left, int right) \\n    {\\n        vector<bool> prime(20, false);\\n        prime[2] = prime[3] = prime[5] = prime[7] = prime[11] = prime[13] = prime[17] = prime[19] = true;\\n        \\n        int res = 0;\\n        \\n        for(int i=left; i<=right; i++)\\n        {\\n            int cnt = 0;\\n            int num = i;\\n            while(num)\\n            {\\n                num = num & (num-1);\\n                cnt++;\\n            }\\n            \\n            res += prime[cnt];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089022,
                "title": "java-3-methods-maths-explained-bruteforce-better-optimal",
                "content": "```\\n//Bruteforce Approach\\n\\nclass Solution {\\n    public int countPrimeSetBits(int left, int right) {\\n        int cnt=0;\\n        for(int i=left;i<=right;i++)\\n           if(primeSetBits(i))\\n              cnt++;\\n        return cnt;\\n    }\\n     \\n    public static boolean primeSetBits(int num)\\n    {\\n        int cntSetBits=countSetBits(num);\\n        return isPrime(cntSetBits);\\n    }\\n    \\n    public static int countSetBits(int num)//Kernighan\\'s Algorithm\\n    {\\n       int count=0;\\n       while(num!=0)\\n       {\\n          int rmsbm=rMSBM(num);\\n          num=num-rmsbm;\\n          count++;  \\n       }\\n       return count;\\n    }\\n\\t\\n    public static int rMSBM(int num)\\n    {\\n\\t  int rmsbm=num & twosCompliment(num);\\n\\t  return rmsbm;\\n    }\\n\\t\\n    public static int twosCompliment(int num)\\n    {\\n        return -num;//return (~num+1);\\n    }\\n    \\n    public static boolean isPrime(int num)\\n    {\\n        if(num<=1)\\n\\t    return false;\\n        \\n        for(int i=2;(i*i)<=num;i++)\\n          if((num%i)==0)\\n            return false; \\n\\t    \\n        return true; \\n    }\\n}\\n```\\n\\n```\\n//Better Approach\\nclass Solution {\\n    public int countPrimeSetBits(int left, int right) {\\n       int cnt=0;\\n       for(int i=left;i<=right;i++)\\n         if(isPrime(Integer.bitCount(i)))\\n           cnt++;\\n       return cnt;\\n    }\\n    \\n    public static boolean isPrime(int num)\\n    {\\n        if(num<=1)\\n\\t      return false;\\n        \\n        for(int i=2;(i*i)<=num;i++)\\n          if((num%i)==0)\\n            return false;  \\n\\t    \\n        return true; \\n    }\\n}\\n```\\n\\n```\\n//Optimal Approach\\n/*\\nAn Integer is Represented using 32 bits so total bits =32 out of these 32 bits some will be Set/On while Other will be Unset/Off \\nso all we need to Do is Pre Compute all the prime Numbers in the the Range [1,32](both Inclusive)\\nAs no.of primes are limited we can use Hashset to check no.of set bits is prime or not.\\n*/\\n\\nclass Solution {\\n    public int countPrimeSetBits(int left, int right) {\\n        HashSet<Integer>prime=new HashSet<>();\\n        prime.add(2);\\n        prime.add(3);\\n        prime.add(5);\\n        prime.add(7);\\n        prime.add(11);\\n        prime.add(13);\\n        prime.add(17);\\n        prime.add(19);\\n\\t    prime.add(23);\\n        prime.add(29);\\n        prime.add(31);\\n        \\n        int cnt=0;\\n        for(int i=left;i<=right;i++)\\n          if(prime.contains(Integer.bitCount(i)))\\n             cnt++;\\n        \\n        return cnt;        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//Bruteforce Approach\\n\\nclass Solution {\\n    public int countPrimeSetBits(int left, int right) {\\n        int cnt=0;\\n        for(int i=left;i<=right;i++)\\n           if(primeSetBits(i))\\n              cnt++;\\n        return cnt;\\n    }\\n     \\n    public static boolean primeSetBits(int num)\\n    {\\n        int cntSetBits=countSetBits(num);\\n        return isPrime(cntSetBits);\\n    }\\n    \\n    public static int countSetBits(int num)//Kernighan\\'s Algorithm\\n    {\\n       int count=0;\\n       while(num!=0)\\n       {\\n          int rmsbm=rMSBM(num);\\n          num=num-rmsbm;\\n          count++;  \\n       }\\n       return count;\\n    }\\n\\t\\n    public static int rMSBM(int num)\\n    {\\n\\t  int rmsbm=num & twosCompliment(num);\\n\\t  return rmsbm;\\n    }\\n\\t\\n    public static int twosCompliment(int num)\\n    {\\n        return -num;//return (~num+1);\\n    }\\n    \\n    public static boolean isPrime(int num)\\n    {\\n        if(num<=1)\\n\\t    return false;\\n        \\n        for(int i=2;(i*i)<=num;i++)\\n          if((num%i)==0)\\n            return false; \\n\\t    \\n        return true; \\n    }\\n}\\n```\n```\\n//Better Approach\\nclass Solution {\\n    public int countPrimeSetBits(int left, int right) {\\n       int cnt=0;\\n       for(int i=left;i<=right;i++)\\n         if(isPrime(Integer.bitCount(i)))\\n           cnt++;\\n       return cnt;\\n    }\\n    \\n    public static boolean isPrime(int num)\\n    {\\n        if(num<=1)\\n\\t      return false;\\n        \\n        for(int i=2;(i*i)<=num;i++)\\n          if((num%i)==0)\\n            return false;  \\n\\t    \\n        return true; \\n    }\\n}\\n```\n```\\n//Optimal Approach\\n/*\\nAn Integer is Represented using 32 bits so total bits =32 out of these 32 bits some will be Set/On while Other will be Unset/Off \\nso all we need to Do is Pre Compute all the prime Numbers in the the Range [1,32](both Inclusive)\\nAs no.of primes are limited we can use Hashset to check no.of set bits is prime or not.\\n*/\\n\\nclass Solution {\\n    public int countPrimeSetBits(int left, int right) {\\n        HashSet<Integer>prime=new HashSet<>();\\n        prime.add(2);\\n        prime.add(3);\\n        prime.add(5);\\n        prime.add(7);\\n        prime.add(11);\\n        prime.add(13);\\n        prime.add(17);\\n        prime.add(19);\\n\\t    prime.add(23);\\n        prime.add(29);\\n        prime.add(31);\\n        \\n        int cnt=0;\\n        for(int i=left;i<=right;i++)\\n          if(prime.contains(Integer.bitCount(i)))\\n             cnt++;\\n        \\n        return cnt;        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063452,
                "title": "java-simple-solution-easy-to-understand",
                "content": "class Solution {\\n    boolean prime(int n)\\n    {\\n        int i,c=0;\\n        for(i=1;i<=n;i++)\\n        {\\n            if(n%i==0)c++;\\n        }\\n        if(c==2){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    public int countPrimeSetBits(int left, int right) {\\n        int i,c=0,k;\\n        for(i=left;i<=right;i++)\\n        {\\n            k=Integer.bitCount(i);\\n            boolean yes=prime(k);\\n            if(yes==true)c++;\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    boolean prime(int n)\\n    {\\n        int i,c=0;\\n        for(i=1;i<=n;i++)\\n        {\\n            if(n%i==0)c++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1991306,
                "title": "c-o-log-n-2-solution-0ms",
                "content": "# Main idea\\n\\nGiven `a = 10101001`, we can count the number of positive integers less than `a` with 5 bits set as follows:\\n\\n1. Count `b`\\'s such that `b = 0xxxxxxx` and there are 5 bits set in `x`\\'s.\\n\\t- There are <img src=\"https://render.githubusercontent.com/render/math?math=7\\\\choose5\"> such `b`\\'s.\\n1. Count `b`\\'s such that `b = 100xxxxx` and there are 4 bits set in `x`\\'s.\\n\\t- There are <img src=\"https://render.githubusercontent.com/render/math?math=5\\\\choose4\"> such `b`\\'s.\\n1. Count `b`\\'s such that `b = 10100xxx` and there are 3 bits set in `x`\\'s.\\n\\t- There are <img src=\"https://render.githubusercontent.com/render/math?math=3\\\\choose3\"> such `b`\\'s.\\n1. Count `b`\\'s such that `b = 10101000` and there are 2 bits set in `x`\\'s.\\n    - There are 0 such `b`\\'s.\\n\\nLet\\'s say `until(n, p)` counts the number of positive integers less than `n` with `p` bits set.\\nThen, we only need to compute `until(right + 1, p) - until(left, p)` for each valid `p`.\\n\\n# Complexity\\n\\nLet\\'s say `N = right`.\\n\\n- Computing Pascal\\'s triangle requires <img src=\"https://render.githubusercontent.com/render/math?math=O((\\\\log N)^2)\"> operations.\\n- Computing primes takes <img src=\"https://render.githubusercontent.com/render/math?math=O((\\\\log N)(\\\\log \\\\log \\\\log N))\"> (https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Algorithmic_complexity).\\n\\t- Here I omitted prime computation in the code snippet below.\\n- Computing the count for all valid primes takes <img src=\"https://render.githubusercontent.com/render/math?math=O((\\\\log N)^2)\">\\n\\t- Asymptotically there are <img src=\"https://render.githubusercontent.com/render/math?math=O(\\\\log N)\"> primes in a range [1, N] (https://en.wikipedia.org/wiki/Prime_number_theorem).\\n\\t- `until` function takes <img src=\"https://render.githubusercontent.com/render/math?math=O(\\\\log N)\">.\\n\\nTherefore, the time complexity is <img src=\"https://render.githubusercontent.com/render/math?math=O((\\\\log N)^2)\">.\\n\\n\\n# Code snippet\\n```c++\\nclass Solution {\\npublic:\\n  int countPrimeSetBits(int l, int r) {\\n    // Build Pascal\\'s triangle\\n    // O((log r) ^ 2)\\n    for (int i = 0; i < 21; ++i) {\\n      for (int j = 0; j <= i; ++j) {\\n        if (j == 0 || j == i) {\\n          comb[i][j] = 1;\\n        } else {\\n          comb[i][j] = comb[i-1][j-1] + comb[i-1][j]; \\n        }\\n      }\\n    }    \\n\\n    // O((log r) ^ 2), as the ratio of primes converges to log r.\\n    int ret = 0;\\n    for (auto p : {2, 3, 5, 7, 11, 13, 17, 19}) {\\n      ret += until(r+1, p) - until(l, p);\\n    }\\n    return ret;\\n  }\\n  \\n  // O(log n)\\n  int until(int n, int p) {\\n    string s;\\n    for (int nn = n; nn > 0; nn >>= 1) {\\n      s.push_back(nn & 1);\\n    }\\n    \\n    int ret = 0;\\n    while (!s.empty()) {\\n      if (s.back() == 1) {\\n        ret += pascal(s.size()-1, p);\\n        --p;\\n      }\\n      s.pop_back();\\n    }\\n    return ret;\\n  }\\n  \\n  int pascal(int a, int b) {\\n    if (a < 0 || b < 0 || a < b) {\\n      return 0;\\n    } else {\\n      return comb[a][min(b, a-b)];\\n    }\\n  }\\n  \\n  int comb[21][21];\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n  int countPrimeSetBits(int l, int r) {\\n    // Build Pascal\\'s triangle\\n    // O((log r) ^ 2)\\n    for (int i = 0; i < 21; ++i) {\\n      for (int j = 0; j <= i; ++j) {\\n        if (j == 0 || j == i) {\\n          comb[i][j] = 1;\\n        } else {\\n          comb[i][j] = comb[i-1][j-1] + comb[i-1][j]; \\n        }\\n      }\\n    }    \\n\\n    // O((log r) ^ 2), as the ratio of primes converges to log r.\\n    int ret = 0;\\n    for (auto p : {2, 3, 5, 7, 11, 13, 17, 19}) {\\n      ret += until(r+1, p) - until(l, p);\\n    }\\n    return ret;\\n  }\\n  \\n  // O(log n)\\n  int until(int n, int p) {\\n    string s;\\n    for (int nn = n; nn > 0; nn >>= 1) {\\n      s.push_back(nn & 1);\\n    }\\n    \\n    int ret = 0;\\n    while (!s.empty()) {\\n      if (s.back() == 1) {\\n        ret += pascal(s.size()-1, p);\\n        --p;\\n      }\\n      s.pop_back();\\n    }\\n    return ret;\\n  }\\n  \\n  int pascal(int a, int b) {\\n    if (a < 0 || b < 0 || a < b) {\\n      return 0;\\n    } else {\\n      return comb[a][min(b, a-b)];\\n    }\\n  }\\n  \\n  int comb[21][21];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949327,
                "title": "easy-c-kernighan-s-algorithm-explained",
                "content": "class Solution {\\npublic:\\n\\t\\n\\t*/\\n\\t\\t=>Idea is to find the no of set bits of interget i which is in range [left,right] inclusive\\n\\t\\t=>so to calculate no. of set bits \\n\\t\\t\\t\\t=>we find the right most set bit everytime and subtrract that from the orgnal no. untill the orignal no. is greater than 0\\n\\t\\t\\t\\t=>check how many time this iteration is done, that turns out to be setbits\\n\\t\\t=>Atlast if the no. of set bits are prime increment the answer.\\n\\t*/\\n\\t\\n    bool isprime(int n){if(n<=1)return false;if(n<=3)return true;if(n%2==0||n%3==0)return false;for(int i=5;i*i<=n;i=i+6)if(n%i==0||n%(i+2)==0)return false;return true;} \\n    int countPrimeSetBits(int left, int right) {\\n        int ans=0;\\n        for(int i=left;i<=right;i++){\\n            int cnt=0;\\n            int x=i;\\n            while(x>0){\\n                int rsb=x&(-x);\\n                x=x-rsb;\\n                cnt++;\\n            }\\n            if(isprime(cnt))ans++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\t\\n\\t*/\\n\\t\\t=>Idea is to find the no of set bits of interget i which is in range [left,right] inclusive\\n\\t\\t=>so to calculate no. of set bits \\n\\t\\t\\t\\t=>we find the right most set bit everytime and subtrract that from the orgnal no. untill the orignal no. is greater than 0\\n\\t\\t\\t\\t=>check how many time this iteration is done, that turns out to be setbits\\n\\t\\t=>Atlast if the no. of set bits are prime increment the answer.\\n\\t*/\\n\\t\\n    bool isprime(int n){if(n<=1)return false;if(n<=3)return true;if(n%2==0||n%3==0)return false;for(int i=5;i*i<=n;i=i+6)if(n%i==0||n%(i+2)==0)return false;return true;}",
                "codeTag": "Java"
            },
            {
                "id": 1816781,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int cnt(int n){\\n      int ans=0;\\n      while(n>0){\\n          ans+=n&1;\\n          n/=2;\\n      }\\n      return ans;\\n  }\\n  bool isprime(int n){\\n      if (n==1)return false;\\n      if(n==3 or n==2 )return true;\\n      for(int i=2;i<=n/2;i++){\\n          if(n%i==0){\\n              return false;\\n          }\\n      }\\n      return true;\\n  }\\n    int countPrimeSetBits(int L, int R){\\n        // code here\\n        int ans=0;\\n        for(int i=L;i<=R;i++){\\n            if(isprime(cnt(i))){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int cnt(int n){\\n      int ans=0;\\n      while(n>0){\\n          ans+=n&1;\\n          n/=2;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1790962,
                "title": "c-simple-solution",
                "content": "\\n```\\nint countPrimeSetBits(int left, int right) { \\n        \\n        set<int> primes = { 2, 3, 5, 7, 11, 13, 17, 19 };\\n        int cnt = 0;\\n        for (int i = left; i <= right; i++) { \\n            cnt += primes.count(bitset<32>(i).count());\\n        }\\n        return cnt;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n```\\nint countPrimeSetBits(int left, int right) { \\n        \\n        set<int> primes = { 2, 3, 5, 7, 11, 13, 17, 19 };\\n        int cnt = 0;\\n        for (int i = left; i <= right; i++) { \\n            cnt += primes.count(bitset<32>(i).count());\\n        }\\n        return cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1789120,
                "title": "c-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(int n){\\n        return (n==2 or n==3 or n== 5 or n==7 or n==11 or n==13 or n==17 or n== 19);\\n    }\\n    int countPrimeSetBits(int left, int right) {\\n        int ans = 0;\\n        for(int i = left ; i <= right ; i++){\\n            int x = i;\\n            int cnt = 0;\\n            while(x){\\n                x = x&(x-1);\\n                cnt++;\\n            }\\n            if(check(cnt)) ans++;\\n        }\\n        return ans;      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int n){\\n        return (n==2 or n==3 or n== 5 or n==7 or n==11 or n==13 or n==17 or n== 19);\\n    }\\n    int countPrimeSetBits(int left, int right) {\\n        int ans = 0;\\n        for(int i = left ; i <= right ; i++){\\n            int x = i;\\n            int cnt = 0;\\n            while(x){\\n                x = x&(x-1);\\n                cnt++;\\n            }\\n            if(check(cnt)) ans++;\\n        }\\n        return ans;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1685874,
                "title": "simple-python-code",
                "content": "```\\nclass Solution:\\n    def isPrime(self,x):\\n        flag=0\\n        if x==1:\\n            return False\\n        for i in range(2,x):\\n            if x%i==0:\\n                flag=1\\n                break\\n        if flag==1:\\n            return False\\n        return True\\n        \\n    def countPrimeSetBits(self, left: int, right: int) -> int:\\n        arr_dict={}\\n        lst=list(range(left,right+1))\\n        for i in lst:\\n            if i not in arr_dict:\\n                arr_dict[i]=bin(i).replace(\"0b\",\"\")\\n        arr=list(arr_dict.values())\\n        count=0\\n        for i in arr:\\n            if self.isPrime(i.count(\\'1\\')):\\n                # print(i)\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def isPrime(self,x):\\n        flag=0\\n        if x==1:\\n            return False\\n        for i in range(2,x):\\n            if x%i==0:\\n                flag=1\\n                break\\n        if flag==1:\\n            return False\\n        return True\\n        \\n    def countPrimeSetBits(self, left: int, right: int) -> int:\\n        arr_dict={}\\n        lst=list(range(left,right+1))\\n        for i in lst:\\n            if i not in arr_dict:\\n                arr_dict[i]=bin(i).replace(\"0b\",\"\")\\n        arr=list(arr_dict.values())\\n        count=0\\n        for i in arr:\\n            if self.isPrime(i.count(\\'1\\')):\\n                # print(i)\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668587,
                "title": "easy-bits-solution-with-explanation-in-o-n-time",
                "content": "\\tAccepted\\t36 ms\\t6 MB\\tcpp\\n\\n```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int &left, int &right) {\\n        // a number can be have at max 32 bits (in integer c++), so calculating all primes till 32 only \\n        vector<int>primes{2,3,5,7,11,13,17,19,23,29,31};\\n        int ans=0,setBits;\\n        \\n        for(int num=left; num<=right; num++) // O(right-left) ~ O(n)\\n        {\\n            setBits=0;\\n            \\n            // count set bits in num\\n            for(int i=0;i<32;i++) // O(32)\\n            {\\n                if(1<<i&num)\\n                    setBits++;\\n            }\\n            \\n            bool isPrime=false;\\n            for(int j=0;j<11;j++) // O(11)\\n            {\\n                if(setBits==primes[j])\\n                {\\n                    isPrime=true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isPrime)\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int &left, int &right) {\\n        // a number can be have at max 32 bits (in integer c++), so calculating all primes till 32 only \\n        vector<int>primes{2,3,5,7,11,13,17,19,23,29,31};\\n        int ans=0,setBits;\\n        \\n        for(int num=left; num<=right; num++) // O(right-left) ~ O(n)\\n        {\\n            setBits=0;\\n            \\n            // count set bits in num\\n            for(int i=0;i<32;i++) // O(32)\\n            {\\n                if(1<<i&num)\\n                    setBits++;\\n            }\\n            \\n            bool isPrime=false;\\n            for(int j=0;j<11;j++) // O(11)\\n            {\\n                if(setBits==primes[j])\\n                {\\n                    isPrime=true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isPrime)\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509030,
                "title": "simple-c-code-for-beginners-using-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int cntBits(int n)\\n    {\\n        int cnt =0;\\n        while(n!=0)\\n        {\\n            cnt+=(n&1);\\n            n/=2;\\n        }\\n        return cnt;\\n    }\\n    \\n    bool isPrime(int n)\\n    {\\n        if(n==0 || n==1) return false;\\n        for(int i=2;i<=sqrt(n);i++)\\n        {\\n            if(n%i==0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int countPrimeSetBits(int left, int right) {\\n        int cnt =0;\\n        for(int i=left;i<=right;i++){\\n        if(isPrime(cntBits(i)))\\n        {\\n           cnt++;\\n        }\\n    }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int cntBits(int n)\\n    {\\n        int cnt =0;\\n        while(n!=0)\\n        {\\n            cnt+=(n&1);\\n            n/=2;\\n        }\\n        return cnt;\\n    }\\n    \\n    bool isPrime(int n)\\n    {\\n        if(n==0 || n==1) return false;\\n        for(int i=2;i<=sqrt(n);i++)\\n        {\\n            if(n%i==0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int countPrimeSetBits(int left, int right) {\\n        int cnt =0;\\n        for(int i=left;i<=right;i++){\\n        if(isPrime(cntBits(i)))\\n        {\\n           cnt++;\\n        }\\n    }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501257,
                "title": "java-easy-solution-faster-than-87-of-submissions",
                "content": "```\\nclass Solution {\\n    public int countPrimeSetBits(int left, int right) {\\n        int count = 0;\\n        for (int i = left; i <= right; i++) \\n            if (isPrime(getCount(i)))\\n                count++;\\n        return count;\\n    }\\n    static int getCount(int n) {\\n        int count = 0;\\n        while (n > 0) {\\n            count++;\\n            n -= n & (-n);\\n        }\\n        return count;\\n    }\\n    static boolean isPrime(int n) {\\n        if (n <= 1)\\n            return false;\\n        int c = 2;\\n        while (c * c <= n) {\\n            if (n % c == 0)\\n                return false;\\n            c++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrimeSetBits(int left, int right) {\\n        int count = 0;\\n        for (int i = left; i <= right; i++) \\n            if (isPrime(getCount(i)))\\n                count++;\\n        return count;\\n    }\\n    static int getCount(int n) {\\n        int count = 0;\\n        while (n > 0) {\\n            count++;\\n            n -= n & (-n);\\n        }\\n        return count;\\n    }\\n    static boolean isPrime(int n) {\\n        if (n <= 1)\\n            return false;\\n        int c = 2;\\n        while (c * c <= n) {\\n            if (n % c == 0)\\n                return false;\\n            c++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1459662,
                "title": "c-similar-vibe-questions",
                "content": "191. Number of 1 Bits\\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n\\n        while (n) {\\n            n = n & (n - 1);\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n};\\n// remove the lowest 1 and count how many 1\\'s can we be removed\\n/*\\nn & (n - 1) drops the lowest set bit. It\\'s a neat little bit trick.\\nLet\\'s use n = 00101100 as an example. This binary representation has three 1s.\\nIf n = 00101100, then n - 1 = 00101011, so n & (n - 1) = 00101100 & 00101011 = 00101000. Count = 1.\\nIf n = 00101000, then n - 1 = 00100111, so n & (n - 1) = 00101000 & 00100111 = 00100000. Count = 2.\\nIf n = 00100000, then n - 1 = 00011111, so n & (n - 1) = 00100000 & 00011111 = 00000000. Count = 3.\\nn is now zero, so the while loop ends, and the final count (the numbers of set bits) is returned.\\n*/\\n```\\nanother approach \\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int total=0;\\n        for(int i=0;i<32;i++){\\n            if(n & (1<<i)){\\n                total++;\\n            }\\n        }\\n        return total;\\n    }\\n};\\n// travel the one to every position (0 to 31) and & with the n so that we know how many positions in n have 1\\n```\\n338. Counting Bits\\n```\\nclass Solution {\\npublic:\\n    vector<int> countBits(int num) {\\n        \\n        vector<int> dp(num+1, 0);\\n        \\n        for (int i = 1; i <= num; ++i)          \\n            dp[i] = dp[i&(i-1)] + 1;\\n        \\n        return dp;\\n    }\\n};\\n\\n// Remove last bit with 1 => A&(A-1)\\n// n = n&(n-1) we get n with one 1 less from the end\\n// so we see the last no with one less 1 in dp and add one 1 of the current num\\n```\\n461. Hamming Distance\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        \\n        int dist = 0;\\n        int n = x ^ y;    \\n        \\n        while (n) {           \\n            n &= n - 1;\\n            dist++;\\n        }\\n        \\n        return dist;\\n    }\\n};\\n\\n// n = x ^ y -> we get 1 if the digits are diff \\n// then we count the no of 1\\'s\\n```\\n477. Total Hamming Distance\\n```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        \\n        int n=nums.size(),i=0,ans=0,cnt=0;\\n        \\n        for(i=31;i>=0;i--){\\n            \\n            cnt=0;\\n            \\n            for(int j=0;j<n;j++){\\n                \\n                 if(nums[j]&(1<<i))\\n                    cnt++;\\n            }\\n            \\n            ans+=(cnt*(n-cnt));  // no of 1\\'s * no of 0\\'s\\n        }\\n        return ans;\\n    }\\n};\\n\\n// travel 1 to every position (i = 0 to 31) and \\n    // & with evey num(j) so that we know how many 1\\'s are there for that particular position i\\n        // we know how many 1\\'s and we know how many 0\\'s (total no  - no of 1\\'s)\\n        // so cnt*(n-cnt) gives the combination of bits with different bits \\n// ans + add that combination for every ith position \\n```\\n762. Prime Number of Set Bits in Binary Representation\\n```\\nclass Solution {\\npublic:\\n    \\n    bool Isprime(int num){\\n        int c=0;\\n        for(int i=num;i>=1;i--){\\n            if(num%i==0)\\n             c++;   \\n        }  \\n        return c==2;\\n    } \\n// if there is any other factor than the number itself and one return false\\n    \\n    int countPrimeSetBits(int left, int right) {\\n        \\n        int ans = 0;\\n       // travel all the numbers \\n        for(int i = left ; i <= right ; i++){  \\n            int count = 0;\\n            int n =i;\\n            \\n            // how many 1\\'s they have\\n            while(n){\\n                n=n&(n-1);\\n                count++;\\n            }\\n            \\n            if(Isprime(count))\\n                    ans++;    \\n            // is this a prime number\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n231. Power of Two\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) { \\n        \\n        return (n>0 && !(n & (n - 1)));\\n\\n    }\\n};\\n\\n/*\\nIf n is the power of two:\\n\\nn = 2 ^ 0 = 1 = 0b0000...00000001, and (n - 1) = 0 = 0b0000...0000.\\nn = 2 ^ 1 = 2 = 0b0000...00000010, and (n - 1) = 1 = 0b0000...0001.\\nn = 2 ^ 2 = 4 = 0b0000...00000100, and (n - 1) = 3 = 0b0000...0011.\\nn = 2 ^ 3 = 8 = 0b0000...00001000, and (n - 1) = 7 = 0b0000...0111.\\nwe have n & (n-1) == 0b0000...0000 == 0\\n\\n*/\\n```\\n326. Power of Three\\nwe solve it by recurssion \\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfThree(int n) {\\n        \\n        if(n <= 0) return false;\\n        \\n        while(n > 1){\\n            if(n %3 != 0) return false;\\n            n/=3;\\n        }\\n        return true;   \\n    }\\n};\\n```\\n342. Power of Four\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfFour(int n) {\\n       //  return num > 0 && (num & (num - 1)) == 0 && (num - 1) % 3 == 0;\\n        return n>0 && !(n&(n-1)) && (n & 0x55555555);\\n    }\\n};\\n// 0x5 == (0101)B, so 0x55555555 means that every odd bit is 1.\\n// if (n&0x55555555) means that the only bit whose value is 1 is odd bit, then and the number of 0 bits behind 1 bit is even. So n is power of 4.\\n// All by observation:\\n// 4 == 100 & 0101 = 1, the number of 0 bits is multiple is even, so true\\n// 8 == 1000 & 0101 = 0, 0 bits odd, not true\\n// 16 == 10000 & 10101 = 1, even, true\\n// and so on...\\n\\n\\n// first    +ve integer\\n// second    power of 2\\n// third     & with odd 1 bits is non zero\\n\\n// we can aslo solve it by recurssion \\nclass Solution {\\npublic:\\n    bool isPowerOfFour(int n) {\\n        if(n < 1)return false;\\n        if(n == 1)return true;\\n        if(n < 4) return false;\\n        while(n%4 == 0){\\n            n = n/4;\\n            if(n==1)return true;\\n        }\\n    return false;\\n    }\\n};\\n```\\n693. Binary Number with Alternating Bits\\n```\\nclass Solution {\\npublic:\\n\\tbool hasAlternatingBits(int n) {\\n        \\n\\t\\tint prevbit\\t= n & 1; // last bit 00001 & xxxxy will give y\\n\\t\\tn = n>>1;            // shift n to the right OR dec n by 1 bit \\n        \\n\\t\\twhile(n != 0){\\n\\t\\t\\tint currentbit = n & 1;   // n is already dec by 1 so it\\'s second last bit\\t\\t\\n\\t\\t\\tif(prevbit == currentbit) \\n                return false;            // we need alternating \\n\\t\\t\\tprevbit = currentbit;       \\n            n = n >> 1;                 // dec n by 1 bit \\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```\\n190. Reverse Bits\\n```\\nclass Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        \\n\\tuint32_t mask = 1, ret = 0;\\n        \\n\\tfor(int i = 0; i < 32; ++i){\\n        \\n\\t\\tret = ret << 1;\\n\\t\\tif(mask & n) ret = ret|1;\\n\\t\\tmask = mask << 1;\\n\\t}\\n\\treturn ret;\\n }\\n};\\n\\n// Do it for every position i = 0 to 31\\n    // inc the reverse - ret by 1 bit\\n    // if we get the n and mask any bit same mean we know there is 1 at this ith location\\n        //we put 1 at end\\n    // inc the mask by 1 bit, its just 1 at ith position and 0 everywhere\\n\\n// everytime we know there is 1 in n at ith position from the right we put 1 in the end of ret and we are shifting ret to right so its automatically comming in the front so it will be at ith from the left\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int count = 0;\\n\\n        while (n) {\\n            n = n & (n - 1);\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n};\\n// remove the lowest 1 and count how many 1\\'s can we be removed\\n/*\\nn & (n - 1) drops the lowest set bit. It\\'s a neat little bit trick.\\nLet\\'s use n = 00101100 as an example. This binary representation has three 1s.\\nIf n = 00101100, then n - 1 = 00101011, so n & (n - 1) = 00101100 & 00101011 = 00101000. Count = 1.\\nIf n = 00101000, then n - 1 = 00100111, so n & (n - 1) = 00101000 & 00100111 = 00100000. Count = 2.\\nIf n = 00100000, then n - 1 = 00011111, so n & (n - 1) = 00100000 & 00011111 = 00000000. Count = 3.\\nn is now zero, so the while loop ends, and the final count (the numbers of set bits) is returned.\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int total=0;\\n        for(int i=0;i<32;i++){\\n            if(n & (1<<i)){\\n                total++;\\n            }\\n        }\\n        return total;\\n    }\\n};\\n// travel the one to every position (0 to 31) and & with the n so that we know how many positions in n have 1\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> countBits(int num) {\\n        \\n        vector<int> dp(num+1, 0);\\n        \\n        for (int i = 1; i <= num; ++i)          \\n            dp[i] = dp[i&(i-1)] + 1;\\n        \\n        return dp;\\n    }\\n};\\n\\n// Remove last bit with 1 => A&(A-1)\\n// n = n&(n-1) we get n with one 1 less from the end\\n// so we see the last no with one less 1 in dp and add one 1 of the current num\\n```\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        \\n        int dist = 0;\\n        int n = x ^ y;    \\n        \\n        while (n) {           \\n            n &= n - 1;\\n            dist++;\\n        }\\n        \\n        return dist;\\n    }\\n};\\n\\n// n = x ^ y -> we get 1 if the digits are diff \\n// then we count the no of 1\\'s\\n```\n```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        \\n        int n=nums.size(),i=0,ans=0,cnt=0;\\n        \\n        for(i=31;i>=0;i--){\\n            \\n            cnt=0;\\n            \\n            for(int j=0;j<n;j++){\\n                \\n                 if(nums[j]&(1<<i))\\n                    cnt++;\\n            }\\n            \\n            ans+=(cnt*(n-cnt));  // no of 1\\'s * no of 0\\'s\\n        }\\n        return ans;\\n    }\\n};\\n\\n// travel 1 to every position (i = 0 to 31) and \\n    // & with evey num(j) so that we know how many 1\\'s are there for that particular position i\\n        // we know how many 1\\'s and we know how many 0\\'s (total no  - no of 1\\'s)\\n        // so cnt*(n-cnt) gives the combination of bits with different bits \\n// ans + add that combination for every ith position \\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool Isprime(int num){\\n        int c=0;\\n        for(int i=num;i>=1;i--){\\n            if(num%i==0)\\n             c++;   \\n        }  \\n        return c==2;\\n    } \\n// if there is any other factor than the number itself and one return false\\n    \\n    int countPrimeSetBits(int left, int right) {\\n        \\n        int ans = 0;\\n       // travel all the numbers \\n        for(int i = left ; i <= right ; i++){  \\n            int count = 0;\\n            int n =i;\\n            \\n            // how many 1\\'s they have\\n            while(n){\\n                n=n&(n-1);\\n                count++;\\n            }\\n            \\n            if(Isprime(count))\\n                    ans++;    \\n            // is this a prime number\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) { \\n        \\n        return (n>0 && !(n & (n - 1)));\\n\\n    }\\n};\\n\\n/*\\nIf n is the power of two:\\n\\nn = 2 ^ 0 = 1 = 0b0000...00000001, and (n - 1) = 0 = 0b0000...0000.\\nn = 2 ^ 1 = 2 = 0b0000...00000010, and (n - 1) = 1 = 0b0000...0001.\\nn = 2 ^ 2 = 4 = 0b0000...00000100, and (n - 1) = 3 = 0b0000...0011.\\nn = 2 ^ 3 = 8 = 0b0000...00001000, and (n - 1) = 7 = 0b0000...0111.\\nwe have n & (n-1) == 0b0000...0000 == 0\\n\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfThree(int n) {\\n        \\n        if(n <= 0) return false;\\n        \\n        while(n > 1){\\n            if(n %3 != 0) return false;\\n            n/=3;\\n        }\\n        return true;   \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfFour(int n) {\\n       //  return num > 0 && (num & (num - 1)) == 0 && (num - 1) % 3 == 0;\\n        return n>0 && !(n&(n-1)) && (n & 0x55555555);\\n    }\\n};\\n// 0x5 == (0101)B, so 0x55555555 means that every odd bit is 1.\\n// if (n&0x55555555) means that the only bit whose value is 1 is odd bit, then and the number of 0 bits behind 1 bit is even. So n is power of 4.\\n// All by observation:\\n// 4 == 100 & 0101 = 1, the number of 0 bits is multiple is even, so true\\n// 8 == 1000 & 0101 = 0, 0 bits odd, not true\\n// 16 == 10000 & 10101 = 1, even, true\\n// and so on...\\n\\n\\n// first    +ve integer\\n// second    power of 2\\n// third     & with odd 1 bits is non zero\\n\\n// we can aslo solve it by recurssion \\nclass Solution {\\npublic:\\n    bool isPowerOfFour(int n) {\\n        if(n < 1)return false;\\n        if(n == 1)return true;\\n        if(n < 4) return false;\\n        while(n%4 == 0){\\n            n = n/4;\\n            if(n==1)return true;\\n        }\\n    return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tbool hasAlternatingBits(int n) {\\n        \\n\\t\\tint prevbit\\t= n & 1; // last bit 00001 & xxxxy will give y\\n\\t\\tn = n>>1;            // shift n to the right OR dec n by 1 bit \\n        \\n\\t\\twhile(n != 0){\\n\\t\\t\\tint currentbit = n & 1;   // n is already dec by 1 so it\\'s second last bit\\t\\t\\n\\t\\t\\tif(prevbit == currentbit) \\n                return false;            // we need alternating \\n\\t\\t\\tprevbit = currentbit;       \\n            n = n >> 1;                 // dec n by 1 bit \\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341244,
                "title": "300ms-rust",
                "content": "```\\nimpl Solution {\\n    pub fn count_prime_set_bits(l: i32, r: i32) -> i32 {\\n            let mut ans = 0;\\n    let set_bits:[i32;8] = [2,3,5,7,11,13,17,19];\\n    for item in l..=r {\\n        let item_string = format!(\"{:b}\",item).split(\"\").filter(|&x| x == \"1\".to_string().as_str()).count() as i32;\\n        if set_bits.contains(&item_string) {\\n            ans+=1;\\n        }\\n    }\\n    ans\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn count_prime_set_bits(l: i32, r: i32) -> i32 {\\n            let mut ans = 0;\\n    let set_bits:[i32;8] = [2,3,5,7,11,13,17,19];\\n    for item in l..=r {\\n        let item_string = format!(\"{:b}\",item).split(\"\").filter(|&x| x == \"1\".to_string().as_str()).count() as i32;\\n        if set_bits.contains(&item_string) {\\n            ans+=1;\\n        }\\n    }\\n    ans\\n\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1331546,
                "title": "java-solution-o-nd-time-o-1-space-d-sqrt-number-and-n-range-size",
                "content": "[https://github.com/2018hsridhar/Leetcode_Solutions/blob/master/leetcode_762.java](http://)\\n```\\n/*\\n\\nTHOUGHT PROCESS :\\nURL = https://leetcode.com/problems/prime-number-of-set-bits-in-binary-representation/\\n762. Prime Number of Set Bits in Binary Representation\\n\\n\\nInclusive : <= VERSUS exclusive : < \\n\\nDesired computational complexity : \\nTime = O(Nsqrt(N)), where N := range cardinality ( right - left + 1 ) \\nSpace= O(1) \\n\\nEdge case testing\\n(1) Range = singleton elements ( left=right=1, left=right=10 )\\n(2) Range = all primes {2,3}\\n(3) Large volume - [left = 1, right = 1,000,000 ]\\n\\nIn this case, 1 is not prime\\n\\n*/\\n\\n\\nclass Solution \\n{\\n    public int countPrimeSetBits(int left, int right) \\n    {\\n        int setPrimes = 0;\\n        int x = 127;\\n        for(int i = left; i <= right; ++i)\\n        {\\n            int countBits = countNumSetBits(i);\\n            if(isPrime(countBits)) ++setPrimes;\\n        }\\n        return setPrimes;\\n    }\\n    \\n    // In this case, 1 => false, but 2,3 => true\\n    public boolean isPrime(int x)\\n    {\\n        if(x == 1) return false;\\n        if(x <= 3) return true;\\n        int upperLim = (int)Math.sqrt(x);\\n        for(int i = 2; i <= upperLim; ++i)\\n            if(x % i == 0) return false;\\n        return true;\\n    }\\n    \\n    \\n    // Working with unsigned integer here\\n    // BUT values in range never go past (2^31)-1\\n    // count LSB here ( rightmost bit )\\n    public int countNumSetBits(int x)\\n    {\\n        int numSetBits = 0;\\n        while(x > 0)\\n        {\\n            int lsb = (x & 0b1);\\n            if(lsb == 1) ++numSetBits;\\n            x >>>= 1; // Divide by 2 for next value ( is arithmetic shift operation )\\n        }\\n        return numSetBits;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\n\\nTHOUGHT PROCESS :\\nURL = https://leetcode.com/problems/prime-number-of-set-bits-in-binary-representation/\\n762. Prime Number of Set Bits in Binary Representation\\n\\n\\nInclusive : <= VERSUS exclusive : < \\n\\nDesired computational complexity : \\nTime = O(Nsqrt(N)), where N := range cardinality ( right - left + 1 ) \\nSpace= O(1) \\n\\nEdge case testing\\n(1) Range = singleton elements ( left=right=1, left=right=10 )\\n(2) Range = all primes {2,3}\\n(3) Large volume - [left = 1, right = 1,000,000 ]\\n\\nIn this case, 1 is not prime\\n\\n*/\\n\\n\\nclass Solution \\n{\\n    public int countPrimeSetBits(int left, int right) \\n    {\\n        int setPrimes = 0;\\n        int x = 127;\\n        for(int i = left; i <= right; ++i)\\n        {\\n            int countBits = countNumSetBits(i);\\n            if(isPrime(countBits)) ++setPrimes;\\n        }\\n        return setPrimes;\\n    }\\n    \\n    // In this case, 1 => false, but 2,3 => true\\n    public boolean isPrime(int x)\\n    {\\n        if(x == 1) return false;\\n        if(x <= 3) return true;\\n        int upperLim = (int)Math.sqrt(x);\\n        for(int i = 2; i <= upperLim; ++i)\\n            if(x % i == 0) return false;\\n        return true;\\n    }\\n    \\n    \\n    // Working with unsigned integer here\\n    // BUT values in range never go past (2^31)-1\\n    // count LSB here ( rightmost bit )\\n    public int countNumSetBits(int x)\\n    {\\n        int numSetBits = 0;\\n        while(x > 0)\\n        {\\n            int lsb = (x & 0b1);\\n            if(lsb == 1) ++numSetBits;\\n            x >>>= 1; // Divide by 2 for next value ( is arithmetic shift operation )\\n        }\\n        return numSetBits;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272638,
                "title": "js",
                "content": "The left and right boundaries are in range [0, 10^6]. The length of the biggest binary number of the range is 20. Thus, we have limited set of possible prime numbers.\\n\\n```\\nconst primes = new Set([\\n    2, 3, 5, 7, 11, 13, 17, 19\\n]);\\n\\nfunction countPrimeSetBits(left: number, right: number): number {\\n    let result = 0;\\n    \\n    for (let number = left; number <= right; number++) {\\n        const bits = number.toString(2).replace(/0/g, \\'\\').length\\n        \\n        if (primes.has(bits)) {\\n            result++;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst primes = new Set([\\n    2, 3, 5, 7, 11, 13, 17, 19\\n]);\\n\\nfunction countPrimeSetBits(left: number, right: number): number {\\n    let result = 0;\\n    \\n    for (let number = left; number <= right; number++) {\\n        const bits = number.toString(2).replace(/0/g, \\'\\').length\\n        \\n        if (primes.has(bits)) {\\n            result++;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1237192,
                "title": "java-97-4-faster-very-easy-solution",
                "content": "class Solution {\\n    public int countPrimeSetBits(int left, int right) {\\n        int[] prime_sequence = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1};\\n\\t\\tint ans=0;\\n\\t\\tfor(int i=left;i<=right;i++){\\n\\t\\t\\tint num = Integer.bitCount(i);\\n\\t\\t\\tif(prime_sequence[num]==1)\\n\\t\\t\\t\\tans++;\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n}\\n\\n//at position 2 the character is 1 which means if the bits are in prime then we will get 1.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countPrimeSetBits(int left, int right) {\\n        int[] prime_sequence = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1}",
                "codeTag": "Java"
            },
            {
                "id": 1225664,
                "title": "python-sieve-of-eratosthenes",
                "content": "```\\ndef get_prime_list(n: int) -> list:\\n    # Sieve of Eratosthenes\\n    primes = [True]*(n+1)\\n    primes[0] = primes[1] = False\\n\\n    i = 2\\n    n = 32\\n    while i*i < n:\\n        if primes[i]:\\n            j = i\\n            while i*j < n:\\n                primes[i*j] = False\\n                j += 1\\n        i+=1\\n    return primes\\nclass Solution:\\n    def countPrimeSetBits(self, left: int, right: int) -> int:\\n        # first find prime between 1 to 32 ( 32 bit integer)\\n        is_prime = get_prime_list(32)\\n        return len(list(filter(lambda x: is_prime[bin(x).count(\\'1\\')], range(left,right+1))))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef get_prime_list(n: int) -> list:\\n    # Sieve of Eratosthenes\\n    primes = [True]*(n+1)\\n    primes[0] = primes[1] = False\\n\\n    i = 2\\n    n = 32\\n    while i*i < n:\\n        if primes[i]:\\n            j = i\\n            while i*j < n:\\n                primes[i*j] = False\\n                j += 1\\n        i+=1\\n    return primes\\nclass Solution:\\n    def countPrimeSetBits(self, left: int, right: int) -> int:\\n        # first find prime between 1 to 32 ( 32 bit integer)\\n        is_prime = get_prime_list(32)\\n        return len(list(filter(lambda x: is_prime[bin(x).count(\\'1\\')], range(left,right+1))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225353,
                "title": "easy-c-solution",
                "content": "Algorithm:-\\nStep-1: Declared a set which consists of prime numbers (2, 3, 5, 7, 11, 13, 17, 19). Here we took till 19 because 10^6 is the upper limit and log2(10^6) = 19.93.. So number of bits will not go beyond 19. \\nStep-2. Traversing from left till right and counting bits for each number.\\nStep-3. Check if that count is in primes set or not. \\n\\n```\\nclass Solution {\\npublic:\\n    // count bits in a value\\n    int countBits(int val)\\n    {\\n        int bits=0;\\n        while(val>0)\\n        {\\n            val = val &(val-1);\\n            bits++;\\n        }\\n        return bits;\\n    }\\n    \\n    \\n    int countPrimeSetBits(int left, int right) {\\n        int ans = 0;\\n        set<int>primes = {2, 3, 5, 7, 11, 13, 17, 19};\\n        for(int i=left;i<=right;i++)\\n        {\\n            int count = countBits(i);\\n            if(primes.find(count) != primes.end())\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    // count bits in a value\\n    int countBits(int val)\\n    {\\n        int bits=0;\\n        while(val>0)\\n        {\\n            val = val &(val-1);\\n            bits++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1154738,
                "title": "bit-manipulation-python-faster-than-97-percent-of-all-submissions",
                "content": "```\\ndef countPrimeSetBits(self, L: int, R: int) -> int:\\n        map_ = set()\\n        map_.add(2)\\n        map_.add(3)\\n        map_.add(5)\\n        map_.add(7)\\n        map_.add(11)\\n        map_.add(13)\\n        map_.add(17)\\n        map_.add(19)\\n        \\n        count = 0\\n        for ele in range(L,R+1):\\n            if bin(ele).count(\\'1\\') in map_:\\n                count = count+1\\n        return count\\n#         for ele in range(L,R+1):\\n#             ans = self.countbits(ele)\\n#             if ans in map_:\\n#                 count = count+1\\n#         return count\\n        \\n#     def countbits(self,num):\\n#         count = 0\\n#         while num>0:\\n#             res = num & (-num)\\n#             num = num-res\\n#             count = count+1\\n#         return count\\n```\\nThe commented method is slow but it get rids of follow up you might get in an interview to not use inbuilt functions. Thanks and please help improve the solution if you know better ones.",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\ndef countPrimeSetBits(self, L: int, R: int) -> int:\\n        map_ = set()\\n        map_.add(2)\\n        map_.add(3)\\n        map_.add(5)\\n        map_.add(7)\\n        map_.add(11)\\n        map_.add(13)\\n        map_.add(17)\\n        map_.add(19)\\n        \\n        count = 0\\n        for ele in range(L,R+1):\\n            if bin(ele).count(\\'1\\') in map_:\\n                count = count+1\\n        return count\\n#         for ele in range(L,R+1):\\n#             ans = self.countbits(ele)\\n#             if ans in map_:\\n#                 count = count+1\\n#         return count\\n        \\n#     def countbits(self,num):\\n#         count = 0\\n#         while num>0:\\n#             res = num & (-num)\\n#             num = num-res\\n#             count = count+1\\n#         return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1146911,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool Prime(int x) {\\n        return (x == 2 || x == 3 || x == 5 || x == 7 ||\\n                x == 11 || x == 13 || x == 17 || x == 19);\\n    }\\n    int countPrimeSetBits(int L, int R) {\\n        int ans=0;\\n        for(int i=L;i<=R;i++){\\n            bitset<32> b(i);\\n            if(Prime(b.count())){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool Prime(int x) {\\n        return (x == 2 || x == 3 || x == 5 || x == 7 ||\\n                x == 11 || x == 13 || x == 17 || x == 19);\\n    }\\n    int countPrimeSetBits(int L, int R) {\\n        int ans=0;\\n        for(int i=L;i<=R;i++){\\n            bitset<32> b(i);\\n            if(Prime(b.count())){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145702,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int L, int R) {\\n        int count = 0;\\n        for (int i = L; i <= R; i++)\\n            if (isPrime(__builtin_popcount(i)))\\n                count++;\\n        return count;\\n    }\\n    \\n    bool isPrime(int num) {\\n        return (num == 2 or num == 3 or num == 5 or num == 7 \\\\\\n                or num == 11 or num == 13 or num == 17 or num == 19);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countPrimeSetBits(int L, int R) {\\n        int count = 0;\\n        for (int i = L; i <= R; i++)\\n            if (isPrime(__builtin_popcount(i)))\\n                count++;\\n        return count;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1048159,
                "title": "beats-70-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\n     public boolean isPrime(int num){\\n            if(num==1)return false;\\n            \\n            if(num == 2 || num == 3)return true;\\n         \\n            if(num % 2 == 0 || num % 3 == 0)return false;\\n                \\n            for(int i=5;i*i<=num;i=i+6)\\n                if(num % i == 0 || num % (i+2) == 0)\\n                    return false;\\n            \\n                return true;\\n        }\\n    \\n    public int countPrimeSetBits(int L, int R) {\\n        int counter=0;\\n        \\n          if(R <= 15){\\n            return R - L;\\n        }\\n      \\n        int n = 0;\\n        int count=0;\\n        for(int i=L;i<=R;i++){\\n            n=i;\\n            count=0;\\n            while(n!=0){\\n              n = n&(n-1);\\n              count++;\\n              //System.out.println(n);\\n            }\\n            if(isPrime(count)){\\n                counter++;\\n            }\\n            \\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    \\n     public boolean isPrime(int num){\\n            if(num==1)return false;\\n            \\n            if(num == 2 || num == 3)return true;\\n         \\n            if(num % 2 == 0 || num % 3 == 0)return false;\\n                \\n            for(int i=5;i*i<=num;i=i+6)\\n                if(num % i == 0 || num % (i+2) == 0)\\n                    return false;\\n            \\n                return true;\\n        }\\n    \\n    public int countPrimeSetBits(int L, int R) {\\n        int counter=0;\\n        \\n          if(R <= 15){\\n            return R - L;\\n        }\\n      \\n        int n = 0;\\n        int count=0;\\n        for(int i=L;i<=R;i++){\\n            n=i;\\n            count=0;\\n            while(n!=0){\\n              n = n&(n-1);\\n              count++;\\n              //System.out.println(n);\\n            }\\n            if(isPrime(count)){\\n                counter++;\\n            }\\n            \\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1035280,
                "title": "c-4-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int L, int R) {\\n        \\n        constexpr int prime[20] {0,0,2,3,0,5,0,7,0,0,0,11,0,13,0,0,0,17,0,19};\\n        \\n        int count=0;\\n        for(int i=L; i<=R; ++i) {\\n            bitset<20> b(i);\\n            if(prime[b.count()]) ++count;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int L, int R) {\\n        \\n        constexpr int prime[20] {0,0,2,3,0,5,0,7,0,0,0,11,0,13,0,0,0,17,0,19};\\n        \\n        int count=0;\\n        for(int i=L; i<=R; ++i) {\\n            bitset<20> b(i);\\n            if(prime[b.count()]) ++count;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774267,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def countPrimeSetBits(self, L: int, R: int) -> int:\\n        prime = 0\\n        \\n        #count number of set bits\\n        for i in range(L, R + 1):\\n            count = 0\\n            while i:\\n                i &= (i - 1)\\n                count += 1\\n                \\n            #check if number of 1\\'s is prime\\n            if count > 1: \\n                for j in range(2, count): \\n                    if (count % j) == 0:\\n                        break;\\n                else:\\n                    prime += 1\\n        return prime\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPrimeSetBits(self, L: int, R: int) -> int:\\n        prime = 0\\n        \\n        #count number of set bits\\n        for i in range(L, R + 1):\\n            count = 0\\n            while i:\\n                i &= (i - 1)\\n                count += 1\\n                \\n            #check if number of 1\\'s is prime\\n            if count > 1: \\n                for j in range(2, count): \\n                    if (count % j) == 0:\\n                        break;\\n                else:\\n                    prime += 1\\n        return prime\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 752101,
                "title": "python-3-solution-beats-95-w-comments",
                "content": "```\\nclass Solution:\\n    def countPrimeSetBits(self, L: int, R: int) -> int:         \\n\\t# We know that the maximum input is 10^6 and the maximum number closest to this limit \\n\\t# with the most 1s is 983039 which contains 19 1s. So we just need to initialize a set\\n\\t# containing primes from 2 to 19.\\n\\t\\n        primes = {2, 3, 5, 7, 11, 13, 17, 19}\\n        ans = 0\\n\\t\\t\\n\\t# From here we just simply loop through the given range and check if the number of \\n\\t# 1s is in our initialized set\\n\\t\\t\\n        for i in range(L, R+1):\\n            if bin(i).count(\"1\") in primes:\\n                ans += 1\\n        \\n        return ans\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def countPrimeSetBits(self, L: int, R: int) -> int:         \\n\\t# We know that the maximum input is 10^6 and the maximum number closest to this limit \\n\\t# with the most 1s is 983039 which contains 19 1s. So we just need to initialize a set\\n\\t# containing primes from 2 to 19.\\n\\t\\n        primes = {2, 3, 5, 7, 11, 13, 17, 19}",
                "codeTag": "Java"
            },
            {
                "id": 751285,
                "title": "python-3-submission",
                "content": "```\\nclass Solution:\\n    def countPrimeSetBits(self, L, R):\\n        top = []\\n        for i in range(L,R+1):\\n            bit_rep = bin(i)[2:]\\n            ones = len([item for item in bit_rep if item == \"1\"])\\n            top.append(self.dictionary(ones))\\n        return (len([item for item in top if item == True ]))\\n        \\n    def dictionary(self,value):\\n        if value == 1:\\n            return False\\n        for i in range(2,value):\\n            if value%i ==0:\\n                return False \\n        return True \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrimeSetBits(self, L, R):\\n        top = []\\n        for i in range(L,R+1):\\n            bit_rep = bin(i)[2:]\\n            ones = len([item for item in bit_rep if item == \"1\"])\\n            top.append(self.dictionary(ones))\\n        return (len([item for item in top if item == True ]))\\n        \\n    def dictionary(self,value):\\n        if value == 1:\\n            return False\\n        for i in range(2,value):\\n            if value%i ==0:\\n                return False \\n        return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 745903,
                "title": "c-easy-using-builtin-popcount-faster-than-94-71-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int num){\\n        for(int j = 2; j<=num/2; j++){ //can also loop until sqrt(num)\\n            if(num%j==0) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int countPrimeSetBits(int L, int R) {\\n        int res = 0;\\n        for(int i = L; i <=R; i++){\\n            int num = __builtin_popcount(i);\\n            if(num==1) continue;\\n            if(isPrime(num)) res+=1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int num){\\n        for(int j = 2; j<=num/2; j++){ //can also loop until sqrt(num)\\n            if(num%j==0) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int countPrimeSetBits(int L, int R) {\\n        int res = 0;\\n        for(int i = L; i <=R; i++){\\n            int num = __builtin_popcount(i);\\n            if(num==1) continue;\\n            if(isPrime(num)) res+=1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536570,
                "title": "javascript-solution-using-memorization-100",
                "content": "```\\nlet isPrime = function (num) {\\n    if(num === 1) return false;\\n    if(num === 2) return true;\\n    let sqrt = Math.sqrt(num);\\n    for(let i = 2; i <= sqrt; i += 1)\\n        if(num % i === 0)\\n\\t\\t    return false;\\n    return true;\\n};\\n\\nlet isPrimeCache = function (num, cache) {\\n    if(typeof cache[num] !== \\'undefined\\') return cache[num];\\n    return cache[num] = isPrime(num);\\n};\\n\\nlet bitCount = function  (n) {\\n    n = n - ((n >> 1) & 0x55555555);\\n    n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\\n    return ((n + (n >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;\\n};\\n\\nvar countPrimeSetBits = function(L, R) {\\n    let numberOfPrimeBitsNumber = 0,\\n        cache = {};\\n    for(let i = L; i <= R; i += 1) \\n        if(isPrime(bitCount(i), cache))\\n            numberOfPrimeBitsNumber += 1;\\n    return numberOfPrimeBitsNumber;\\n};\\n```\\n\\nThis version is less confusing and still works to count bits.\\n```\\nlet countSetBits = function (num, bits) {\\n    let initialNumberOfOnes = 0;\\n    while(num !== 0) {\\n        if(typeof bits[num] !== \\'undefined\\') return bits[num] + initialNumberOfOnes;\\n        initialNumberOfOnes += num & 1;\\n        num >>= 1;\\n    }\\n    bits[num] = initialNumberOfOnes;\\n    return initialNumberOfOnes;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet isPrime = function (num) {\\n    if(num === 1) return false;\\n    if(num === 2) return true;\\n    let sqrt = Math.sqrt(num);\\n    for(let i = 2; i <= sqrt; i += 1)\\n        if(num % i === 0)\\n\\t\\t    return false;\\n    return true;\\n};\\n\\nlet isPrimeCache = function (num, cache) {\\n    if(typeof cache[num] !== \\'undefined\\') return cache[num];\\n    return cache[num] = isPrime(num);\\n};\\n\\nlet bitCount = function  (n) {\\n    n = n - ((n >> 1) & 0x55555555);\\n    n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\\n    return ((n + (n >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;\\n};\\n\\nvar countPrimeSetBits = function(L, R) {\\n    let numberOfPrimeBitsNumber = 0,\\n        cache = {};\\n    for(let i = L; i <= R; i += 1) \\n        if(isPrime(bitCount(i), cache))\\n            numberOfPrimeBitsNumber += 1;\\n    return numberOfPrimeBitsNumber;\\n};\\n```\n```\\nlet countSetBits = function (num, bits) {\\n    let initialNumberOfOnes = 0;\\n    while(num !== 0) {\\n        if(typeof bits[num] !== \\'undefined\\') return bits[num] + initialNumberOfOnes;\\n        initialNumberOfOnes += num & 1;\\n        num >>= 1;\\n    }\\n    bits[num] = initialNumberOfOnes;\\n    return initialNumberOfOnes;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 516608,
                "title": "c-16ms-simple-bitwise-ops-to-count-bits-prime-lookup-table",
                "content": "```\\nint countPrimeSetBits(int L, int R){\\n    int result = 0;\\n    \\n    int primes[] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, \\n                    0, 1, 0, 1, 0, 0, 0, 1, 0, 1}; \\n    \\n    for(int j = L; j <= R; j++){\\n        int n = j;\\n        int val = 0;\\n        for (int i = 0; i < 32; i++) {\\n            val += n & 1;\\n            n >>= 1;\\n        }\\n        result += primes[val];\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint countPrimeSetBits(int L, int R){\\n    int result = 0;\\n    \\n    int primes[] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, \\n                    0, 1, 0, 1, 0, 0, 0, 1, 0, 1}; \\n    \\n    for(int j = L; j <= R; j++){\\n        int n = j;\\n        int val = 0;\\n        for (int i = 0; i < 32; i++) {\\n            val += n & 1;\\n            n >>= 1;\\n        }\\n        result += primes[val];\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 485283,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int L, int R) {\\n        int primes[20];\\n        loadPrimes(primes);\\n        \\n        int ret = 0;\\n        \\n        for(int i = L; i <= R; i++){\\n            ret += primes[getSetBits(i)];\\n        }\\n        \\n        return(ret);\\n    }\\n    \\nprivate:\\n    void loadPrimes(int *primes){\\n        memset(primes, 0, 20 * sizeof(int));\\n        primes[2] = 1;\\n        primes[3] = 1;\\n        primes[5] = 1;\\n        primes[7] = 1;\\n        primes[11] = 1;\\n        primes[13] = 1;\\n        primes[17] = 1;\\n        primes[19] = 1;\\n    }\\n    \\n    int getSetBits(int num){\\n        int ret = 0;\\n        int compare = 1;\\n        \\n        for(int i = 0; i < 20; i++){\\n            if((num & compare) == compare){\\n                ret++;\\n            }\\n            compare <<= 1;\\n        }\\n        \\n        return(ret);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int L, int R) {\\n        int primes[20];\\n        loadPrimes(primes);\\n        \\n        int ret = 0;\\n        \\n        for(int i = L; i <= R; i++){\\n            ret += primes[getSetBits(i)];\\n        }\\n        \\n        return(ret);\\n    }\\n    \\nprivate:\\n    void loadPrimes(int *primes){\\n        memset(primes, 0, 20 * sizeof(int));\\n        primes[2] = 1;\\n        primes[3] = 1;\\n        primes[5] = 1;\\n        primes[7] = 1;\\n        primes[11] = 1;\\n        primes[13] = 1;\\n        primes[17] = 1;\\n        primes[19] = 1;\\n    }\\n    \\n    int getSetBits(int num){\\n        int ret = 0;\\n        int compare = 1;\\n        \\n        for(int i = 0; i < 20; i++){\\n            if((num & compare) == compare){\\n                ret++;\\n            }\\n            compare <<= 1;\\n        }\\n        \\n        return(ret);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484839,
                "title": "c-5",
                "content": "class Solution \\n{\\n    public:\\n    \\n    int countPrimeSetBits(int L, int R) \\n    {\\n        int res = 0;\\n        \\n        for(int x = L; x <= R; x++)\\n        {\\n            std::string s = std::bitset<64>(x).to_string();\\n            \\n            int cnt = std::count(s.begin(), s.end(), \\'1\\');\\n            \\n            if(cnt == 2  || \\n               cnt == 3  || \\n               cnt == 5  ||\\n               cnt == 7  ||\\n               cnt == 11 ||\\n               cnt == 13 ||\\n               cnt == 17 ||\\n               cnt == 19)\\n            {\\n                res++;\\n            }\\n        }\\n    \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution \\n{\\n    public:\\n    \\n    int countPrimeSetBits(int L, int R) \\n    {\\n        int res = 0;\\n        \\n        for(int x = L; x <= R; x++)\\n        {\\n            std::string s = std::bitset<64>(x).to_string();\\n            \\n            int cnt = std::count(s.begin(), s.end(), \\'1\\');\\n            \\n            if(cnt == 2  || \\n               cnt == 3  || \\n               cnt == 5  ||\\n               cnt == 7  ||\\n               cnt == 11 ||\\n               cnt == 13 ||\\n               cnt == 17 ||\\n               cnt == 19)\\n            {\\n                res++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 390298,
                "title": "easy-c-solution-4ms-bitset-and-sieve-of-eratosthenes",
                "content": "Runtime: 4 ms, faster than 98.11% of C++ online submissions for Prime Number of Set Bits in Binary Representation.\\nMemory Usage: 8.2 MB, less than 66.67% of C++ online submissions for Prime Number of Set Bits in Binary Representation.\\n\\n```\\nint countPrimeSetBits(int L, int R) {\\n        \\n        int count = 0;\\n        for(int i=L; i<=R; i++)\\n        {\\n            if(isPrime(bitset<32>(i).count()))\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    bool isPrime(int n)\\n    {\\n        if(n == 0 || n == 1)\\n            return false;\\n        \\n        for(int i=2; i*i <= n; i++)\\n        {\\n            if(n%i == 0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 4 ms, faster than 98.11% of C++ online submissions for Prime Number of Set Bits in Binary Representation.\\nMemory Usage: 8.2 MB, less than 66.67% of C++ online submissions for Prime Number of Set Bits in Binary Representation.\\n\\n```\\nint countPrimeSetBits(int L, int R) {\\n        \\n        int count = 0;\\n        for(int i=L; i<=R; i++)\\n        {\\n            if(isPrime(bitset<32>(i).count()))\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    bool isPrime(int n)\\n    {\\n        if(n == 0 || n == 1)\\n            return false;\\n        \\n        for(int i=2; i*i <= n; i++)\\n        {\\n            if(n%i == 0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 381146,
                "title": "solution-in-python-3-beats-98-one-line",
                "content": "```\\nclass Solution:\\n    def countPrimeSetBits(self, L: int, R: int) -> int:\\n    \\treturn sum(1 for i in range(L,R+1) if bin(i).count(\\'1\\') in {2,3,5,7,11,13,17,19})\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def countPrimeSetBits(self, L: int, R: int) -> int:\\n    \\treturn sum(1 for i in range(L,R+1) if bin(i).count(\\'1\\') in {2,3,5,7,11,13,17,19}",
                "codeTag": "Java"
            },
            {
                "id": 342365,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int CountPrimeSetBits(int L, int R) \\n    {\\n        int primeSetBits = (int) 0b0010_0000_1000_1010_0010_1000_1010_1100, result = 0;\\n        for(int i = L; i <= R; i++)\\n            if((1 << BitCount(i) & primeSetBits) != 0) result++;\\n        return result;\\n    }\\n    \\n    private int BitCount(int n)\\n    {\\n        int count = 0;\\n        while(n > 0)\\n        {\\n            count += n % 2;\\n            n = n / 2;\\n        }\\n        \\n        return  count;\\n    }\\n}\\n```\\n\\nWith fancy bit count function:\\n```\\npublic class Solution \\n{\\n    public int CountPrimeSetBits(int L, int R) \\n    {\\n        int primeSetBits = (int) 0b0010_0000_1000_1010_0010_1000_1010_1100, result = 0;\\n        for(int i = L; i <= R; i++)\\n            if((1 << BitCount(i) & primeSetBits) != 0) \\n                result++;\\n        return result;\\n    }\\n    \\n    private int BitCount(int n)\\n    {\\n        var bitCount = n - ((n >> 1) & 0b1101_1011_0110_1101_1011_0110_1101_1011)\\n                         - ((n >> 2) & 0b0000_1001_0010_0100_1001_0010_0100_1001);\\n        return (int) ((bitCount + (bitCount >> 3)) & 0b1100_0111_0001_1100_0111_0001_1100_0111) % 63;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int CountPrimeSetBits(int L, int R) \\n    {\\n        int primeSetBits = (int) 0b0010_0000_1000_1010_0010_1000_1010_1100, result = 0;\\n        for(int i = L; i <= R; i++)\\n            if((1 << BitCount(i) & primeSetBits) != 0) result++;\\n        return result;\\n    }\\n    \\n    private int BitCount(int n)\\n    {\\n        int count = 0;\\n        while(n > 0)\\n        {\\n            count += n % 2;\\n            n = n / 2;\\n        }\\n        \\n        return  count;\\n    }\\n}\\n```\n```\\npublic class Solution \\n{\\n    public int CountPrimeSetBits(int L, int R) \\n    {\\n        int primeSetBits = (int) 0b0010_0000_1000_1010_0010_1000_1010_1100, result = 0;\\n        for(int i = L; i <= R; i++)\\n            if((1 << BitCount(i) & primeSetBits) != 0) \\n                result++;\\n        return result;\\n    }\\n    \\n    private int BitCount(int n)\\n    {\\n        var bitCount = n - ((n >> 1) & 0b1101_1011_0110_1101_1011_0110_1101_1011)\\n                         - ((n >> 2) & 0b0000_1001_0010_0100_1001_0010_0100_1001);\\n        return (int) ((bitCount + (bitCount >> 3)) & 0b1100_0111_0001_1100_0111_0001_1100_0111) % 63;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 335072,
                "title": "beat-98-python",
                "content": "```\\nclass Solution:\\n    def countPrimeSetBits(self, L: int, R: int) -> int:\\n        primes = set([2,3,5,7,11,13,17,19,23])\\n        res = 0\\n        for i in range(L, R+1):\\n            if bin(i).count(\\'1\\') in primes:\\n                res += 1\\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPrimeSetBits(self, L: int, R: int) -> int:\\n        primes = set([2,3,5,7,11,13,17,19,23])\\n        res = 0\\n        for i in range(L, R+1):\\n            if bin(i).count(\\'1\\') in primes:\\n                res += 1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 319900,
                "title": "golang-4ms",
                "content": "```\\nfunc countPrimeSetBits(L int, R int) int {\\n\\tvar res int\\n\\tfor i := L; i <= R; i++ {\\n\\t\\tif isPrime(countOnes(i)) {\\n\\t\\t\\tres++\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\nfunc countOnes(n int) int {\\n\\tvar res int\\n\\tfor n > 0 {\\n\\t\\tres += n & 1\\n\\t\\tn = n >> 1\\n\\t}\\n\\treturn res\\n}\\n\\nfunc isPrime(n int) bool {\\n\\tswitch n {\\n\\tcase 2, 3, 5, 7, 11, 13, 17, 19:\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nfunc countPrimeSetBits(L int, R int) int {\\n\\tvar res int\\n\\tfor i := L; i <= R; i++ {\\n\\t\\tif isPrime(countOnes(i)) {\\n\\t\\t\\tres++\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\nfunc countOnes(n int) int {\\n\\tvar res int\\n\\tfor n > 0 {\\n\\t\\tres += n & 1\\n\\t\\tn = n >> 1\\n\\t}\\n\\treturn res\\n}\\n\\nfunc isPrime(n int) bool {\\n\\tswitch n {\\n\\tcase 2, 3, 5, 7, 11, 13, 17, 19:\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 306492,
                "title": "simple-javascript-solution-92-ms-faster-than-81-50",
                "content": "```\\nvar countPrimeSetBits = function(L, R) {\\n    // binary(1,000,000) = 11110100001001000000 // 20 digits\\n    let primes = new Set([2, 3, 5, 7, 11, 13, 17, 19]);\\n    let setBits;\\n    let quot, rem;\\n    let count = 0;\\n    \\n    for (i = L; i <= R; i++) {\\n        setBits = 0;        \\n        quot = i;\\n        \\n        while (quot > 0) {\\n            rem = quot % 2;\\n            quot = (quot - rem) / 2;\\n            setBits += rem;\\n        }\\n        \\n        if (primes.has(setBits)) {\\n            count++;\\n        }      \\n    }\\n    \\n    return count;\\n};\\n```\\nRuntime: 92 ms, faster than 81.50% of JavaScript online submissions for Prime Number of Set Bits in Binary Representation.\\nMemory Usage: 34.4 MB, less than 96.87% of JavaScript online submissions for Prime Number of Set Bits in Binary Representation.\\n",
                "solutionTags": [],
                "code": "```\\nvar countPrimeSetBits = function(L, R) {\\n    // binary(1,000,000) = 11110100001001000000 // 20 digits\\n    let primes = new Set([2, 3, 5, 7, 11, 13, 17, 19]);\\n    let setBits;\\n    let quot, rem;\\n    let count = 0;\\n    \\n    for (i = L; i <= R; i++) {\\n        setBits = 0;        \\n        quot = i;\\n        \\n        while (quot > 0) {\\n            rem = quot % 2;\\n            quot = (quot - rem) / 2;\\n            setBits += rem;\\n        }\\n        \\n        if (primes.has(setBits)) {\\n            count++;\\n        }      \\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 280474,
                "title": "c-solution-beats-100",
                "content": "```\\npublic class Solution {\\n    public int CountPrimeSetBits(int L, int R) {\\n        ISet<int> st = new HashSet<int>(new int[]{2,3,5,7,11,13,17,19});\\n        int sum = 0;\\n        for (int i = L; i <= R; i++) {\\n            if (st.Contains(NumberOfSetBits(i))) sum++;\\n        }\\n        return sum;\\n    }\\n    \\n    public int NumberOfSetBits(int i)    {\\n        i = i - ((i >> 1) & 0x55555555);\\n        i = (i & 0x33333333) + ((i >> 2) & 0x33333333);\\n        return (((i + (i >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int CountPrimeSetBits(int L, int R) {\\n        ISet<int> st = new HashSet<int>(new int[]{2,3,5,7,11,13,17,19}",
                "codeTag": "Java"
            },
            {
                "id": 270806,
                "title": "python-interview-appropriate",
                "content": "Slow, but if you must explicitly find a prime and use bitwise:\\n```\\n    def countPrimeSetBits(self, L, R):\\n        \"\"\"\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        def isPrime(n):\\n            if n==2 or n==3: return True\\n            if n%2==0 or n<2: return False\\n            for i in range(3,int(n**0.5)+1,2):   # only odd numbers\\n                if n%i==0:\\n                    return False    \\n\\n            return True\\n        \\n        def countOnes(n):\\n            ones = 0\\n            while n:\\n                check = 1\\n                check &= n\\n                ones += check\\n                n >>= 1\\n            \\n            return ones\\n        \\n        primes = 0\\n        for n in range(L, R+1):\\n            ones = countOnes(n)\\n            if isPrime(ones):\\n                primes += 1\\n        \\n        return primes  \\n```\\n\\nSped up version:\\n```\\n    def countPrimeSetBits(self, L, R):\\n        \"\"\"\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        primeSet = {2,3,5,7,11,13,17,19,23,29}\\n        \\n        primes = 0\\n        for n in range(L, R+1):\\n            ones = bin(n).count(\\'1\\')\\n            if ones in primeSet:\\n                primes += 1\\n        \\n        return primes  \\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\n    def countPrimeSetBits(self, L, R):\\n        \"\"\"\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        def isPrime(n):\\n            if n==2 or n==3: return True\\n            if n%2==0 or n<2: return False\\n            for i in range(3,int(n**0.5)+1,2):   # only odd numbers\\n                if n%i==0:\\n                    return False    \\n\\n            return True\\n        \\n        def countOnes(n):\\n            ones = 0\\n            while n:\\n                check = 1\\n                check &= n\\n                ones += check\\n                n >>= 1\\n            \\n            return ones\\n        \\n        primes = 0\\n        for n in range(L, R+1):\\n            ones = countOnes(n)\\n            if isPrime(ones):\\n                primes += 1\\n        \\n        return primes  \\n```\n```\\n    def countPrimeSetBits(self, L, R):\\n        \"\"\"\\n        :type L: int\\n        :type R: int\\n        :rtype: int\\n        \"\"\"\\n        primeSet = {2,3,5,7,11,13,17,19,23,29}\\n        \\n        primes = 0\\n        for n in range(L, R+1):\\n            ones = bin(n).count(\\'1\\')\\n            if ones in primeSet:\\n                primes += 1\\n        \\n        return primes  \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 201605,
                "title": "4-ms-c-simple-solution",
                "content": "A simple global map on <bitCnt, isPrime> will tell you if the bit count is prime or not.\\n```\\nchar isPrimeMap[25] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0,  /* 0 -9 */\\n                       0, 1, 0, 1, 0, 0, 0, 1, 0, 1,  /* 10 - 19 */\\n                       0, 0, 0, 1, 0};                /* 20 - 24 */\\n\\nbool isPrime(int n)\\n{\\n    return isPrimeMap[n];\\n}\\n\\nint getBitsCount(int n)\\n{\\n    int cnt = 0;\\n    while(n != 0)\\n    {\\n        n &= (n-1);\\n        cnt++;\\n    }\\n    \\n    return cnt;\\n}\\n\\nint countPrimeSetBits(int L, int R) {\\n    int cnt = 0;\\n    for (int i = L; i <= R; i++)\\n    {\\n        if (isPrime(getBitsCount(i))) cnt++;\\n    }\\n    \\n    return cnt;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nchar isPrimeMap[25] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0,  /* 0 -9 */\\n                       0, 1, 0, 1, 0, 0, 0, 1, 0, 1,  /* 10 - 19 */\\n                       0, 0, 0, 1, 0};                /* 20 - 24 */\\n\\nbool isPrime(int n)\\n{\\n    return isPrimeMap[n];\\n}\\n\\nint getBitsCount(int n)\\n{\\n    int cnt = 0;\\n    while(n != 0)\\n    {\\n        n &= (n-1);\\n        cnt++;\\n    }\\n    \\n    return cnt;\\n}\\n\\nint countPrimeSetBits(int L, int R) {\\n    int cnt = 0;\\n    for (int i = L; i <= R; i++)\\n    {\\n        if (isPrime(getBitsCount(i))) cnt++;\\n    }\\n    \\n    return cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 164223,
                "title": "fast-algorithm-with-explanation-o-logn-c-4ms",
                "content": "  The key point is to count numbers of K set bits in range [1, N].\\n\\tLet\\'s take N = 100 (0b1100100) for example.\\n\\tDivide [1,100(0b1100100)] into three parts: [1,63(0b111111)], 64(0b1000000), and [65(0b1000001), 100(0b1100100)].\\n\\t1. In the first range [1, 0b111111(63)], we can find C(n,K) numbers, n = 6 which is the bit length of 63.\\n\\t2. The second part always has 1 set bit.\\n  3. In the third range [0b1000001(65), 0b1100100(100)], all the numbers has the set bit 0b1000000, so the answer equals to count numbers of (K-1) set bits in range [1, 0b100100(100-64)], we can solve this recursively.\\n```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int L, int R) {\\n        return countPrimeSetBitsFrom1(R) - countPrimeSetBitsFrom1(L-1);\\n    }\\n    int countPrimeSetBitsFrom1(int N){\\n        return countNumbersHasKBits(N, 2)\\n            + countNumbersHasKBits(N, 3)\\n            + countNumbersHasKBits(N, 5)\\n            + countNumbersHasKBits(N, 7)\\n            + countNumbersHasKBits(N, 11)\\n            + countNumbersHasKBits(N, 13)\\n            + countNumbersHasKBits(N, 17)\\n            + countNumbersHasKBits(N, 19)\\n            + countNumbersHasKBits(N, 23)\\n            + countNumbersHasKBits(N, 29)\\n            + countNumbersHasKBits(N, 31);\\n    }\\n    int countNumbersHasKBits(int N, int k){\\n        if(N < ((1<<k)-1)) return 0;\\n        int n = 32 - __builtin_clz(N) - 1;\\n        return combination(n, k) + countNumbersHasKBits(N - (1<<n), k - 1);\\n    }\\n    int combination(int n, int k){\\n        long total = 1;\\n        for(int i = 1; i <= k; i++){\\n            total = total * (n-i+1) / i;\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int L, int R) {\\n        return countPrimeSetBitsFrom1(R) - countPrimeSetBitsFrom1(L-1);\\n    }\\n    int countPrimeSetBitsFrom1(int N){\\n        return countNumbersHasKBits(N, 2)\\n            + countNumbersHasKBits(N, 3)\\n            + countNumbersHasKBits(N, 5)\\n            + countNumbersHasKBits(N, 7)\\n            + countNumbersHasKBits(N, 11)\\n            + countNumbersHasKBits(N, 13)\\n            + countNumbersHasKBits(N, 17)\\n            + countNumbersHasKBits(N, 19)\\n            + countNumbersHasKBits(N, 23)\\n            + countNumbersHasKBits(N, 29)\\n            + countNumbersHasKBits(N, 31);\\n    }\\n    int countNumbersHasKBits(int N, int k){\\n        if(N < ((1<<k)-1)) return 0;\\n        int n = 32 - __builtin_clz(N) - 1;\\n        return combination(n, k) + countNumbersHasKBits(N - (1<<n), k - 1);\\n    }\\n    int combination(int n, int k){\\n        long total = 1;\\n        for(int i = 1; i <= k; i++){\\n            total = total * (n-i+1) / i;\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 145452,
                "title": "4ms-c-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int L, int R) {\\n        static int bitCountMap[] =\\n        {\\n            0,1,1,2,1,2,2,3,\\t1,2,2,3,2,3,3,4,\\n            1,2,2,3,2,3,3,4,\\t2,3,3,4,3,4,4,5,\\n            1,2,2,3,2,3,3,4,\\t2,3,3,4,3,4,4,5,\\n            2,3,3,4,3,4,4,5,\\t3,4,4,5,4,5,5,6,\\n            1,2,2,3,2,3,3,4,\\t2,3,3,4,3,4,4,5,\\n            2,3,3,4,3,4,4,5,\\t3,4,4,5,4,5,5,6,\\n            2,3,3,4,3,4,4,5,\\t3,4,4,5,4,5,5,6,\\n            3,4,4,5,4,5,5,6,\\t4,5,5,6,5,6,6,7,\\n            1,2,2,3,2,3,3,4,\\t2,3,3,4,3,4,4,5,\\n            2,3,3,4,3,4,4,5,\\t3,4,4,5,4,5,5,6,\\n            2,3,3,4,3,4,4,5,\\t3,4,4,5,4,5,5,6,\\n            3,4,4,5,4,5,5,6,\\t4,5,5,6,5,6,6,7,\\n            2,3,3,4,3,4,4,5,\\t3,4,4,5,4,5,5,6,\\n            3,4,4,5,4,5,5,6,\\t4,5,5,6,5,6,6,7,\\n            3,4,4,5,4,5,5,6,\\t4,5,5,6,5,6,6,7,\\n            4,5,5,6,5,6,6,7,\\t5,6,6,7,6,7,7,8,\\n        };\\n        bool isPrime[] = {\\n            false, false, true, true, false, true, false, true,\\n            false, false, false, true, false, true, false, false,\\n            false, true, false, true, false, false, false, true,\\n            false, false, false, false, false, true, false, true, false\\n        };\\n        int ret = 0;\\n        while (L <= R)\\n        {\\n            auto cp = (unsigned char*)&L;\\n            if (isPrime[bitCountMap[cp[0]]+bitCountMap[cp[1]]+bitCountMap[cp[2]]+bitCountMap[cp[3]]]) ++ret;\\n            ++L;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int L, int R) {\\n        static int bitCountMap[] =\\n        {\\n            0,1,1,2,1,2,2,3,\\t1,2,2,3,2,3,3,4,\\n            1,2,2,3,2,3,3,4,\\t2,3,3,4,3,4,4,5,\\n            1,2,2,3,2,3,3,4,\\t2,3,3,4,3,4,4,5,\\n            2,3,3,4,3,4,4,5,\\t3,4,4,5,4,5,5,6,\\n            1,2,2,3,2,3,3,4,\\t2,3,3,4,3,4,4,5,\\n            2,3,3,4,3,4,4,5,\\t3,4,4,5,4,5,5,6,\\n            2,3,3,4,3,4,4,5,\\t3,4,4,5,4,5,5,6,\\n            3,4,4,5,4,5,5,6,\\t4,5,5,6,5,6,6,7,\\n            1,2,2,3,2,3,3,4,\\t2,3,3,4,3,4,4,5,\\n            2,3,3,4,3,4,4,5,\\t3,4,4,5,4,5,5,6,\\n            2,3,3,4,3,4,4,5,\\t3,4,4,5,4,5,5,6,\\n            3,4,4,5,4,5,5,6,\\t4,5,5,6,5,6,6,7,\\n            2,3,3,4,3,4,4,5,\\t3,4,4,5,4,5,5,6,\\n            3,4,4,5,4,5,5,6,\\t4,5,5,6,5,6,6,7,\\n            3,4,4,5,4,5,5,6,\\t4,5,5,6,5,6,6,7,\\n            4,5,5,6,5,6,6,7,\\t5,6,6,7,6,7,7,8,\\n        };\\n        bool isPrime[] = {\\n            false, false, true, true, false, true, false, true,\\n            false, false, false, true, false, true, false, false,\\n            false, true, false, true, false, false, false, true,\\n            false, false, false, false, false, true, false, true, false\\n        };\\n        int ret = 0;\\n        while (L <= R)\\n        {\\n            auto cp = (unsigned char*)&L;\\n            if (isPrime[bitCountMap[cp[0]]+bitCountMap[cp[1]]+bitCountMap[cp[2]]+bitCountMap[cp[3]]]) ++ret;\\n            ++L;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 119761,
                "title": "o-1-time-c-solution",
                "content": "The idea is based on the following observation:\\nIf we want to find out how many numbers in the range of [1,52] have prime number of set bits, we first examine the most significant bit of the binary representation 110100.\\nFor numbers less than 100000, i.e. in the range of [0,11111], we can fill the 5 bits with 2 or 3 or 5 ones, so the count in this range is C(5,2)+C(5,3)+C(5,5)=21.\\nWe then move to the next 1 and count the numbers in the range [100000,101111], we can fill the 4 bits with 1 or 2 or 4 ones (plus the 1 in the beginning that makes the total number of ones 2 or 3 or 5), so the count is C(4,1)+C(4,2)+C(4,4)=11.\\nWe then move to the next \\'1\\' and add C(2,0)+C(2,1)=3 to the total count.\\nDon\\'t forget to add one more for 110100 it self. So the final answer is 21+11+3+1=36.\\nFor the count in range of [L,R], we do the calculation for R and L-1 and the result is the difference.\\nI know for the given input range this code is more complicated but runs slower than some linear time implementation (97.77%), I still want to share this theoretically better solution:)\\n```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int L, int R) {\\n        return countPrimeSetBitsNumber(R)-countPrimeSetBitsNumber(L-1);\\n    }\\n    int countPrimeSetBitsNumber(int num)\\n    {\\n        unordered_set<int> prime={2,3,5,7,11,13,17,19};\\n        int numBitsRight = log2(num), base = 1 << numBitsRight, numOnesLeft = 0, ans = 0;\\n        while(base > 0)\\n        {\\n            if (num & base)\\n            {\\n                int nChoosek = 1;\\n                for (int i = 0; i <= numBitsRight; i++)\\n                {\\n                    if (prime.count(i + numOnesLeft))\\n                        ans += nChoosek;\\n                    nChoosek = nChoosek * (numBitsRight - i) / (i + 1);\\n                }\\n                numOnesLeft++;\\n            }\\n            base = base >> 1;\\n            numBitsRight--;\\n        }\\n        return ans+prime.count(numOnesLeft);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int L, int R) {\\n        return countPrimeSetBitsNumber(R)-countPrimeSetBitsNumber(L-1);\\n    }\\n    int countPrimeSetBitsNumber(int num)\\n    {\\n        unordered_set<int> prime={2,3,5,7,11,13,17,19};\\n        int numBitsRight = log2(num), base = 1 << numBitsRight, numOnesLeft = 0, ans = 0;\\n        while(base > 0)\\n        {\\n            if (num & base)\\n            {\\n                int nChoosek = 1;\\n                for (int i = 0; i <= numBitsRight; i++)\\n                {\\n                    if (prime.count(i + numOnesLeft))\\n                        ans += nChoosek;\\n                    nChoosek = nChoosek * (numBitsRight - i) / (i + 1);\\n                }\\n                numOnesLeft++;\\n            }\\n            base = base >> 1;\\n            numBitsRight--;\\n        }\\n        return ans+prime.count(numOnesLeft);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113249,
                "title": "ruby-oneliner",
                "content": "```\\nrequire 'prime'\\n\\ndef count_prime_set_bits(l, r)\\n  (l..r).count { |i| i.digits(2).sum.prime? }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\nrequire 'prime'\\n\\ndef count_prime_set_bits(l, r)\\n  (l..r).count { |i| i.digits(2).sum.prime? }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 113229,
                "title": "simple-python-solution",
                "content": "Just check if number of 1's in bit representation of each integer in given range is prime or not. \\n\\n```\\n    def countPrimeSetBits(self, L, R):\\n        def isPrime(x):\\n            if x < 2:\\n                return False\\n            for i in range(2, x):\\n                if not x%i:\\n                    return False\\n            return True\\n        count = 0\\n        for i in range(L, R+1):\\n            if isPrime(bin(i)[2:].count('1')):\\n                count += 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\n    def countPrimeSetBits(self, L, R):\\n        def isPrime(x):\\n            if x < 2:\\n                return False\\n            for i in range(2, x):\\n                if not x%i:\\n                    return False\\n            return True\\n        count = 0\\n        for i in range(L, R+1):\\n            if isPrime(bin(i)[2:].count('1')):\\n                count += 1\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4106578,
                "title": "bruteforce-loop-beats-96",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int countPrimeSetBits(int left, int right) {\\n        int counter = 0;\\n\\n        for (int i = left; i <= right; i++) {\\n            int bits = Integer.bitCount(i);\\n\\n            switch (bits) {\\n                case 2:\\n                case 3:\\n                case 5:\\n                case 7:\\n                case 11:\\n                case 13:\\n                case 17:\\n                case 19:\\n                case 23:\\n                case 29:\\n                case 31:\\n                    counter++;\\n                    break;\\n            }\\n        }\\n\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int countPrimeSetBits(int left, int right) {\\n        int counter = 0;\\n\\n        for (int i = left; i <= right; i++) {\\n            int bits = Integer.bitCount(i);\\n\\n            switch (bits) {\\n                case 2:\\n                case 3:\\n                case 5:\\n                case 7:\\n                case 11:\\n                case 13:\\n                case 17:\\n                case 19:\\n                case 23:\\n                case 29:\\n                case 31:\\n                    counter++;\\n                    break;\\n            }\\n        }\\n\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4106538,
                "title": "c-simple-solution-beginners",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int count_set_bits(int num){\\n        int count = 0;\\n        while(num){\\n            count += num & 1;\\n            num >>= 1;\\n        }\\n        return count;\\n    }\\n\\n    bool isPrime(int num){\\n        if(num <= 1){\\n            return false;\\n        }\\n\\n        for(int i = 2; i <= sqrt(num); i++){\\n            if(num % i == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int countPrimeSetBits(int left, int right) {\\n        int count = 0;\\n        for(int i = left; i <= right; i++){\\n            if(isPrime(count_set_bits(i))){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count_set_bits(int num){\\n        int count = 0;\\n        while(num){\\n            count += num & 1;\\n            num >>= 1;\\n        }\\n        return count;\\n    }\\n\\n    bool isPrime(int num){\\n        if(num <= 1){\\n            return false;\\n        }\\n\\n        for(int i = 2; i <= sqrt(num); i++){\\n            if(num % i == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int countPrimeSetBits(int left, int right) {\\n        int count = 0;\\n        for(int i = left; i <= right; i++){\\n            if(isPrime(count_set_bits(i))){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095563,
                "title": "beat-easy-to-understand-number-theory-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\nbool isPrime(int n) {\\n    if (n <= 1) return false;\\n    if (n <= 3) return true;\\n\\n    if (n % 2 == 0 || n % 3 == 0) return false;\\n\\n    for (int i = 5; i * i <= n; i += 6) {\\n        if (n % i == 0 || n % (i + 2) == 0) return false;\\n    }\\n\\n    return true;\\n}\\n\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n        int ans=0;\\n        for(auto i = left; i<=right; i++){\\n            ans+=(isPrime(__builtin_popcount(i)));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\nbool isPrime(int n) {\\n    if (n <= 1) return false;\\n    if (n <= 3) return true;\\n\\n    if (n % 2 == 0 || n % 3 == 0) return false;\\n\\n    for (int i = 5; i * i <= n; i += 6) {\\n        if (n % i == 0 || n % (i + 2) == 0) return false;\\n    }\\n\\n    return true;\\n}\\n\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n        int ans=0;\\n        for(auto i = left; i<=right; i++){\\n            ans+=(isPrime(__builtin_popcount(i)));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094608,
                "title": "python-easy-and-short-solution",
                "content": "The maximum binary length is 20 (10^6 \\u2248 2^20), so we can fix a set with the primes up to 20\\n\\n# Complexity\\nTime complexity is O(n) where n is the length of the interval and space O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrimeSetBits(self, left: int, right: int) -> int:\\n        primes = {2,3,5,7,11,13,17,19}\\n        return sum(bin(x).count(\\'1\\') in primes for x in range(left, right + 1))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrimeSetBits(self, left: int, right: int) -> int:\\n        primes = {2,3,5,7,11,13,17,19}\\n        return sum(bin(x).count(\\'1\\') in primes for x in range(left, right + 1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093335,
                "title": "typescript-counting-bits-and-checking-for-prime-number-runtime-beats-87-50-memory-beats-37-50",
                "content": "# Intuition\\nCount bits via bitwise operation.\\n\\n# Approach\\nIterate through each number and store the total number of bits into an array and check if the number is a prime number. If it is, increment the total.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n $$O(n)$$ \\n\\n# Code\\n```\\nfunction countPrimeSetBits(left: number, right: number): number {\\n  let bits: number[] = [];\\n\\n  for (let i = left; i < right + 1; i++) {\\n    bitCounter(i);\\n  }\\n\\n  function bitCounter(num: number) {\\n    let sum = 0;\\n\\n    while (num) {\\n      sum += num & 1;\\n      num = num >> 1;\\n    }\\n    bits.push(sum);\\n  }\\n\\n  let bitsTotal = 0;\\n\\n  for (let i = 0; i < bits.length; i++) {\\n    if (isPrime(bits[i])) {\\n      bitsTotal++;\\n    } else {\\n      continue;\\n    }\\n  }\\n\\n  function isPrime(num: number): boolean {\\n    if (num <= 1) return false;\\n\\n    for (let i = 2; i < num; i++) {\\n      if (num % i == 0) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  return bitsTotal;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction countPrimeSetBits(left: number, right: number): number {\\n  let bits: number[] = [];\\n\\n  for (let i = left; i < right + 1; i++) {\\n    bitCounter(i);\\n  }\\n\\n  function bitCounter(num: number) {\\n    let sum = 0;\\n\\n    while (num) {\\n      sum += num & 1;\\n      num = num >> 1;\\n    }\\n    bits.push(sum);\\n  }\\n\\n  let bitsTotal = 0;\\n\\n  for (let i = 0; i < bits.length; i++) {\\n    if (isPrime(bits[i])) {\\n      bitsTotal++;\\n    } else {\\n      continue;\\n    }\\n  }\\n\\n  function isPrime(num: number): boolean {\\n    if (num <= 1) return false;\\n\\n    for (let i = 2; i < num; i++) {\\n      if (num % i == 0) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  return bitsTotal;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4093196,
                "title": "easy-soltuion-for-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO((left - right) * k)\\n- Space complexity:\\nO(log(i))\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrimeSetBits(int left, int right) {\\n        int ans = 0;\\n        while(left <= right) {\\n            if(countSets(left)) ans++;\\n            left++;\\n        }\\n\\n        return ans;\\n    }\\n    private boolean countSets(int i) {\\n        String s = Integer.toBinaryString(i);\\n        int count = 0;\\n        for(char c : s.toCharArray()) {\\n            if(c == \\'1\\') count++;\\n        }\\n\\n        return count == 2 || count == 3 || count == 5 || count == 7 || count == 11 || count == 13 || count == 17 || count == 19;\\n    }\\n}\\n```\\nUpvote if you are homophobic",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrimeSetBits(int left, int right) {\\n        int ans = 0;\\n        while(left <= right) {\\n            if(countSets(left)) ans++;\\n            left++;\\n        }\\n\\n        return ans;\\n    }\\n    private boolean countSets(int i) {\\n        String s = Integer.toBinaryString(i);\\n        int count = 0;\\n        for(char c : s.toCharArray()) {\\n            if(c == \\'1\\') count++;\\n        }\\n\\n        return count == 2 || count == 3 || count == 5 || count == 7 || count == 11 || count == 13 || count == 17 || count == 19;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082005,
                "title": "java-solution-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    boolean isprime(int num){\\n        if(num==0 || num==1)\\n         return false;\\n       for(int i=2;i<num;i++){\\n           if(num%i==0)\\n             return false;\\n       }\\n       return true;\\n    }\\n    public int countPrimeSetBits(int left, int right) {\\n        // jay shree ram\\n        String num = \"\";\\n        int count=0,value=0;\\n         while(left<=right){\\n              num = Integer.toBinaryString(left);\\n              count=0;\\n                    for(int i=0;i<num.length();i++){\\n                        if(num.charAt(i)==\\'1\\')\\n                        count++;\\n                    }\\n                    if(isprime(count)){\\n                        value++;\\n                    }\\n                    left++;\\n              }\\n         return value;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    boolean isprime(int num){\\n        if(num==0 || num==1)\\n         return false;\\n       for(int i=2;i<num;i++){\\n           if(num%i==0)\\n             return false;\\n       }\\n       return true;\\n    }\\n    public int countPrimeSetBits(int left, int right) {\\n        // jay shree ram\\n        String num = \"\";\\n        int count=0,value=0;\\n         while(left<=right){\\n              num = Integer.toBinaryString(left);\\n              count=0;\\n                    for(int i=0;i<num.length();i++){\\n                        if(num.charAt(i)==\\'1\\')\\n                        count++;\\n                    }\\n                    if(isprime(count)){\\n                        value++;\\n                    }\\n                    left++;\\n              }\\n         return value;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065422,
                "title": "brute-force-easy-and-thinkable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int setbit(int n)\\n    {\\n        int c=0;\\n        while(n)\\n        {\\n            if(n&1)\\n            c++;\\n            n=n>>1;\\n        }\\n        return c;\\n    }\\n    bool isPrime(int n)\\n    {\\n        int c=0;\\n        // if(n==2||n==3)\\n        // return 1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            if(n%i==0)\\n            c++;\\n        }\\n        if(c==1)\\n        return 1;\\n        return 0;\\n    }\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n        int c=0;\\n        for(int i=left;i<=right;i++)\\n        {\\n            int set=setbit(i);\\n            if(isPrime(set))\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int setbit(int n)\\n    {\\n        int c=0;\\n        while(n)\\n        {\\n            if(n&1)\\n            c++;\\n            n=n>>1;\\n        }\\n        return c;\\n    }\\n    bool isPrime(int n)\\n    {\\n        int c=0;\\n        // if(n==2||n==3)\\n        // return 1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            if(n%i==0)\\n            c++;\\n        }\\n        if(c==1)\\n        return 1;\\n        return 0;\\n    }\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n        int c=0;\\n        for(int i=left;i<=right;i++)\\n        {\\n            int set=setbit(i);\\n            if(isPrime(set))\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064482,
                "title": "c-solution-bit-manipulation-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$ O(n) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$ O(1) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountPrimeSetBits(int left, int right) {\\n        HashSet<int> primes = new HashSet<int>() { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };\\n        int count = 0;\\n\\n        for(int i=left; i<= right; i++){\\n            int setBits = 0;\\n\\n            for(int j=0; j<32; j++){\\n                if((i&(1<<j)) != 0){\\n                    setBits++;\\n                }\\n            }\\n\\n            if(primes.Contains(setBits)){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountPrimeSetBits(int left, int right) {\\n        HashSet<int> primes = new HashSet<int>() { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };\\n        int count = 0;\\n\\n        for(int i=left; i<= right; i++){\\n            int setBits = 0;\\n\\n            for(int j=0; j<32; j++){\\n                if((i&(1<<j)) != 0){\\n                    setBits++;\\n                }\\n            }\\n\\n            if(primes.Contains(setBits)){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048636,
                "title": "using-bitswise-shift-oparetor-easy-to-understand-cpp-solution-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int chack(int n){\\n        int cnt=0;\\n        while(n!=0){\\n            if(n&1){\\n                cnt+=1;\\n                \\n            }\\n            n=n>>1;\\n           \\n        }\\n         return cnt;\\n    }\\n    bool prime(int&  n){\\n        if(n==1){\\n            return false;\\n        }\\n       for(int i=2;i*i<=n;i++){\\n            if(n%i==0){\\n            return false;\\n        \\n        }\\n       }\\n        return true;\\n    }\\n    int countPrimeSetBits(int left, int right) {\\n        int cnt=0;\\n        for(int i=left;i<=right;i++){\\n            int f=chack(i);\\n            if(prime(f)==true){\\n                cnt+=1;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int chack(int n){\\n        int cnt=0;\\n        while(n!=0){\\n            if(n&1){\\n                cnt+=1;\\n                \\n            }\\n            n=n>>1;\\n           \\n        }\\n         return cnt;\\n    }\\n    bool prime(int&  n){\\n        if(n==1){\\n            return false;\\n        }\\n       for(int i=2;i*i<=n;i++){\\n            if(n%i==0){\\n            return false;\\n        \\n        }\\n       }\\n        return true;\\n    }\\n    int countPrimeSetBits(int left, int right) {\\n        int cnt=0;\\n        for(int i=left;i<=right;i++){\\n            int f=chack(i);\\n            if(prime(f)==true){\\n                cnt+=1;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047569,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrimeSetBits(int left, int right) {\\n        int a=0;\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(isPrime(Integer.bitCount(i)))\\n            a++;\\n        }return a;\\n    }\\n    public boolean isPrime(int n)\\n    {\\n        if(n<=1)return false;\\n        for(int i=2;i<=Math.sqrt(n);i++)\\n        {\\n            if(n%i==0)return false;\\n        }return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrimeSetBits(int left, int right) {\\n        int a=0;\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(isPrime(Integer.bitCount(i)))\\n            a++;\\n        }return a;\\n    }\\n    public boolean isPrime(int n)\\n    {\\n        if(n<=1)return false;\\n        for(int i=2;i<=Math.sqrt(n);i++)\\n        {\\n            if(n%i==0)return false;\\n        }return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041001,
                "title": "concept-of-number-theory-and-builtin-popcount-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(sqrt(n)*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool primality_test(int n){\\n    if(n==1)return false;\\n    for(int i=2;i*i<=n;i++){\\n        if(n%i==0){\\n            return false;\\n\\n        }\\n    }\\n    return true;\\n\\n}\\n\\n    int countPrimeSetBits(int left, int right) {\\n        int cnt=0;\\n        for(int i=left;i<=right;i++){\\n            int x=__builtin_popcount(i);\\n            if(primality_test(x)){\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool primality_test(int n){\\n    if(n==1)return false;\\n    for(int i=2;i*i<=n;i++){\\n        if(n%i==0){\\n            return false;\\n\\n        }\\n    }\\n    return true;\\n\\n}\\n\\n    int countPrimeSetBits(int left, int right) {\\n        int cnt=0;\\n        for(int i=left;i<=right;i++){\\n            int x=__builtin_popcount(i);\\n            if(primality_test(x)){\\n                cnt++;\\n            }\\n\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037262,
                "title": "fastest-c-bit-manipulation",
                "content": "\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n        int count=0;\\n        for(int i=left;i<=right;i++)\\n        {\\n            int check=i;\\n            int set=0;\\n            while(check)\\n            {\\n                set+=(check&1);\\n                check=check>>1;\\n            }\\n            if(prime(set))\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    bool prime(int n)\\n    {\\n        int yes=0;\\n        if(n==1)\\n        return false;\\n        for(int i=2;i<=n/2;i++)\\n        {\\n            if(n%i==0)\\n            yes++;\\n        }\\n        return yes==0?true:false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n        int count=0;\\n        for(int i=left;i<=right;i++)\\n        {\\n            int check=i;\\n            int set=0;\\n            while(check)\\n            {\\n                set+=(check&1);\\n                check=check>>1;\\n            }\\n            if(prime(set))\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    bool prime(int n)\\n    {\\n        int yes=0;\\n        if(n==1)\\n        return false;\\n        for(int i=2;i<=n/2;i++)\\n        {\\n            if(n%i==0)\\n            yes++;\\n        }\\n        return yes==0?true:false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035517,
                "title": "c-code-for-prime-number-of-set-bits-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n    int mask;\\n    int number_of_set_bits;\\n    int result = 0;\\n    for (; left <= right; left += 1) \\n    {\\n\\t    mask = 0b00000000000000000001;\\n\\t    number_of_set_bits = 0;\\n\\t    for (int i = 0; i < 20; i += 1)\\n\\t    {\\n\\t\\t    if ((left & mask) > 0) number_of_set_bits += 1;\\n\\t\\t    mask = mask << 1;\\n\\t    }\\n\\tif (number_of_set_bits == 2 || number_of_set_bits == 3) result += 1;\\n    else\\n    {\\n\\t    if (number_of_set_bits > 1)\\n\\t    {\\n\\t\\t    if (number_of_set_bits % 2 != 0 && number_of_set_bits % 3 != 0) result += 1;\\n\\t    }\\n\\t\\n    }\\n    }\\n    return result;\\n  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n    int mask;\\n    int number_of_set_bits;\\n    int result = 0;\\n    for (; left <= right; left += 1) \\n    {\\n\\t    mask = 0b00000000000000000001;\\n\\t    number_of_set_bits = 0;\\n\\t    for (int i = 0; i < 20; i += 1)\\n\\t    {\\n\\t\\t    if ((left & mask) > 0) number_of_set_bits += 1;\\n\\t\\t    mask = mask << 1;\\n\\t    }\\n\\tif (number_of_set_bits == 2 || number_of_set_bits == 3) result += 1;\\n    else\\n    {\\n\\t    if (number_of_set_bits > 1)\\n\\t    {\\n\\t\\t    if (number_of_set_bits % 2 != 0 && number_of_set_bits % 3 != 0) result += 1;\\n\\t    }\\n\\t\\n    }\\n    }\\n    return result;\\n  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029759,
                "title": "python-simple-solution-math-counting",
                "content": "# Complexity\\n- Time complexity: $$O(m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python\\ndef is_prime(num: int) -> bool:\\n  binary_count = 0\\n  while num > 0:\\n    if num % 2 == 1:\\n      binary_count += 1\\n    num //= 2\\n  count = 0\\n  for i in range(1, binary_count + 1):\\n    if binary_count % i == 0:\\n      count += 1\\n    if count > 2:\\n      return False\\n  return count == 2\\n\\nclass Solution:\\n  def countPrimeSetBits(self, left: int, right: int) -> int:\\n    count = 0\\n    for num in range(left, right + 1):\\n      if is_prime(num):\\n        count += 1\\n    return count\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Counting"
                ],
                "code": "```python\\ndef is_prime(num: int) -> bool:\\n  binary_count = 0\\n  while num > 0:\\n    if num % 2 == 1:\\n      binary_count += 1\\n    num //= 2\\n  count = 0\\n  for i in range(1, binary_count + 1):\\n    if binary_count % i == 0:\\n      count += 1\\n    if count > 2:\\n      return False\\n  return count == 2\\n\\nclass Solution:\\n  def countPrimeSetBits(self, left: int, right: int) -> int:\\n    count = 0\\n    for num in range(left, right + 1):\\n      if is_prime(num):\\n        count += 1\\n    return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010610,
                "title": "find-prime-number",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countPrimeSetBits(self, left: int, right: int) -> int:\\n        cnt = 0\\n        for i in range(left, right+1):\\n            bin_i_cnt = bin(i)[2:].count(\\'1\\')\\n            if bin_i_cnt == 1:\\n                pass\\n            else:\\n                flag_ = False\\n                for j in range(2, bin_i_cnt):\\n                    if bin_i_cnt % j == 0:\\n                        flag_ = True\\n                if flag_ == False:\\n                    cnt += 1\\n        return cnt\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrimeSetBits(self, left: int, right: int) -> int:\\n        cnt = 0\\n        for i in range(left, right+1):\\n            bin_i_cnt = bin(i)[2:].count(\\'1\\')\\n            if bin_i_cnt == 1:\\n                pass\\n            else:\\n                flag_ = False\\n                for j in range(2, bin_i_cnt):\\n                    if bin_i_cnt % j == 0:\\n                        flag_ = True\\n                if flag_ == False:\\n                    cnt += 1\\n        return cnt\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003505,
                "title": "2-subproblems",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n  bool isPrime(int n) {\\n    if (n == 0) return false;\\n\\n    if (n == 1) return false;\\n\\n    for (int i = 2; i <= sqrt(n); ++i) {\\n      if (n % i == 0) return false;\\n    }\\n    return true;\\n  }\\n  int countSetBits(int n) {\\n    int ret = 0;\\n    while (n > 0) {\\n      if (n%2 == 1) ret++;\\n      n/=2;\\n    }\\n    return ret;\\n  }\\n\\n public:\\n  int countPrimeSetBits(int left, int right) {\\n    /* def: set bits - number of 1s when written in binary */\\n    int ret = 0;\\n    for (int i = left; i <= right; ++i) {\\n      if (isPrime(countSetBits(i))) ++ret;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\n  bool isPrime(int n) {\\n    if (n == 0) return false;\\n\\n    if (n == 1) return false;\\n\\n    for (int i = 2; i <= sqrt(n); ++i) {\\n      if (n % i == 0) return false;\\n    }\\n    return true;\\n  }\\n  int countSetBits(int n) {\\n    int ret = 0;\\n    while (n > 0) {\\n      if (n%2 == 1) ret++;\\n      n/=2;\\n    }\\n    return ret;\\n  }\\n\\n public:\\n  int countPrimeSetBits(int left, int right) {\\n    /* def: set bits - number of 1s when written in binary */\\n    int ret = 0;\\n    for (int i = left; i <= right; ++i) {\\n      if (isPrime(countSetBits(i))) ++ret;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002434,
                "title": "beginner-friendly-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public  int calculateSetBits(String s){\\n        int count=0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i)==\\'1\\') count++;\\n        }\\n        return count;\\n    }\\n\\n    public  boolean isPrime(int n){\\n        if (n==0 || n==1) return false;\\n        for (int i = 2; i <= n/2; i++) {\\n            if(n%i ==0 ) return false;\\n        }\\n//        System.out.println(n+\" - \");\\n        return true;\\n    }\\n\\n    public  int countPrimeSetBits(int left, int right) {\\n        int count=0;\\n        for(int i=left;i<=right;i++){\\n            String b= Integer.toBinaryString(i);\\n\\n            int n=calculateSetBits(b);\\n\\n            if(isPrime(n)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public  int calculateSetBits(String s){\\n        int count=0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i)==\\'1\\') count++;\\n        }\\n        return count;\\n    }\\n\\n    public  boolean isPrime(int n){\\n        if (n==0 || n==1) return false;\\n        for (int i = 2; i <= n/2; i++) {\\n            if(n%i ==0 ) return false;\\n        }\\n//        System.out.println(n+\" - \");\\n        return true;\\n    }\\n\\n    public  int countPrimeSetBits(int left, int right) {\\n        int count=0;\\n        for(int i=left;i<=right;i++){\\n            String b= Integer.toBinaryString(i);\\n\\n            int n=calculateSetBits(b);\\n\\n            if(isPrime(n)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994809,
                "title": "simple-c-solution-using-hashset-for-prime-numbers",
                "content": "# Approach\\n- Number of bits is small - we can list prime numbers in `HashSet` to make quick lookup\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int CountPrimeSetBits(int left, int right)\\n    {\\n        var primes = new HashSet<int> {2, 3, 5, 7, 11, 13, 17, 19};\\n        var count = 0;\\n\\n        for (var i = left; i <= right; i++)\\n        {\\n            if (primes.Contains(BitOperations.PopCount((uint) i)))\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int CountPrimeSetBits(int left, int right)\\n    {\\n        var primes = new HashSet<int> {2, 3, 5, 7, 11, 13, 17, 19};\\n        var count = 0;\\n\\n        for (var i = left; i <= right; i++)\\n        {\\n            if (primes.Contains(BitOperations.PopCount((uint) i)))\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993534,
                "title": "c-very-simple-and-easy-to-understand-solution",
                "content": "# Intuition\\nThe intuition behind this solution is to check whether the number of set bits in the binary representation of each integer in the range `[left, right]` is a prime number.\\n\\n# Approach\\nThe approach to solving this problem involves the following steps:\\n1. Implement a primality test function `primalityTest` to check if a given integer is prime. This function handles edge cases and uses a basic prime-checking algorithm.\\n2. Implement a function `countSetBits` to count the number of set bits (1\\'s) in the binary representation of an integer. It uses bitwise operations to calculate the count efficiently.\\n3. Initialize a counter `count` to keep track of the count of integers with a prime number of set bits.\\n4. Iterate through the integers in the range `[left, right]` (inclusive).\\n   - For each integer `i`, calculate the count of set bits using the `countSetBits` function.\\n   - Check if the count of set bits is a prime number using the `primalityTest` function.\\n   - If it is prime, increment the `count` variable.\\n5. Return the final count, which represents the number of integers in the range `[left, right]` with a prime number of set bits in their binary representation.\\n\\n# Complexity\\n- Time complexity: **O(n * log(log(n)))**\\n\\n- Space complexity: **O(1)**\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    bool primalityTest(int n) {\\n        if (n == 1) return false;\\n        if (n == 2 || n == 3) return true;\\n        if (n % 2 == 0 || n % 3 == 0) return false;\\n        for (int i = 5; i * i <= n; i += 6) {\\n            if (n % i == 0 || n % (i + 2) == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    int countSetBits(int n) {\\n        int result = 0;\\n        while (n > 0) {\\n            n = n & (n - 1);\\n            result++;\\n        }\\n        return result;\\n    }\\n\\n    int countPrimeSetBits(int left, int right) {\\n        int count = 0;\\n        for (int i = left; i <= right; i++) {\\n            if (primalityTest(countSetBits(i))) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool primalityTest(int n) {\\n        if (n == 1) return false;\\n        if (n == 2 || n == 3) return true;\\n        if (n % 2 == 0 || n % 3 == 0) return false;\\n        for (int i = 5; i * i <= n; i += 6) {\\n            if (n % i == 0 || n % (i + 2) == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    int countSetBits(int n) {\\n        int result = 0;\\n        while (n > 0) {\\n            n = n & (n - 1);\\n            result++;\\n        }\\n        return result;\\n    }\\n\\n    int countPrimeSetBits(int left, int right) {\\n        int count = 0;\\n        for (int i = left; i <= right; i++) {\\n            if (primalityTest(countSetBits(i))) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992530,
                "title": "solution",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def prime(self,n):\\n        if n<=1:\\n            return False\\n        a=int(n**0.5)+1\\n        for i in range(2,a):\\n            if n%i==0:\\n                return False\\n        return True\\n\\n    def countPrimeSetBits(self, left, right):\\n        c=0\\n        for i in range(left,right+1):\\n            p=0\\n            b=bin(i)[2:]\\n            a=len(b)\\n            for j in range(a):\\n                if b[j]==\\'1\\':\\n                    p+=1\\n            if self.prime(p):\\n                c+=1\\n        return c\\n            \\n\\n\\n        \"\"\"\\n        :type left: int\\n        :type right: int\\n        :rtype: int\\n        \"\"\"\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution(object):\\n    def prime(self,n):\\n        if n<=1:\\n            return False\\n        a=int(n**0.5)+1\\n        for i in range(2,a):\\n            if n%i==0:\\n                return False\\n        return True\\n\\n    def countPrimeSetBits(self, left, right):\\n        c=0\\n        for i in range(left,right+1):\\n            p=0\\n            b=bin(i)[2:]\\n            a=len(b)\\n            for j in range(a):\\n                if b[j]==\\'1\\':\\n                    p+=1\\n            if self.prime(p):\\n                c+=1\\n        return c\\n            \\n\\n\\n        \"\"\"\\n        :type left: int\\n        :type right: int\\n        :rtype: int\\n        \"\"\"\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985640,
                "title": "easy-javascript-solution-with-line-by-line-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} left\\n * @param {number} right\\n * @return {number}\\n */\\nvar countPrimeSetBits = function (left, right) {\\n\\n    // initialize function isPrime with parameter num\\n    function isPrime(num) {\\n\\n        // if num is equal to 2 then return true\\n        if (num === 2) return true;\\n\\n        // if number is divisable by 2 then return true\\n        if (num % 2 === 0) return false;\\n\\n        // loop through the 3 to square root of num\\n        for (let i = 3; i <= Math.sqrt(num); i += 2) {\\n\\n            // if num is divisable by i then return false\\n            if (num % i === 0) return false;\\n        }\\n\\n        // return true if num is greater then 1 otherwise false\\n        return num > 1;\\n    }\\n\\n    // initialize count to zero\\n    let count = 0;\\n\\n    // loop through the left to right\\n    for (let i = left; i <= right; i++) {\\n\\n        // find the setBits by converting i to binary using toString(2) with base 2 and then remove all zero from string using replace() with regex property then find the length using .length property\\n        let setBits = i.toString(2).replace(/[^1]/g,\"\").length;\\n\\n        // call isPrime function with setBits as argument if it\\'s prime then increment count\\n        if (isPrime(setBits)) count++;\\n    }\\n\\n    // return count\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} left\\n * @param {number} right\\n * @return {number}\\n */\\nvar countPrimeSetBits = function (left, right) {\\n\\n    // initialize function isPrime with parameter num\\n    function isPrime(num) {\\n\\n        // if num is equal to 2 then return true\\n        if (num === 2) return true;\\n\\n        // if number is divisable by 2 then return true\\n        if (num % 2 === 0) return false;\\n\\n        // loop through the 3 to square root of num\\n        for (let i = 3; i <= Math.sqrt(num); i += 2) {\\n\\n            // if num is divisable by i then return false\\n            if (num % i === 0) return false;\\n        }\\n\\n        // return true if num is greater then 1 otherwise false\\n        return num > 1;\\n    }\\n\\n    // initialize count to zero\\n    let count = 0;\\n\\n    // loop through the left to right\\n    for (let i = left; i <= right; i++) {\\n\\n        // find the setBits by converting i to binary using toString(2) with base 2 and then remove all zero from string using replace() with regex property then find the length using .length property\\n        let setBits = i.toString(2).replace(/[^1]/g,\"\").length;\\n\\n        // call isPrime function with setBits as argument if it\\'s prime then increment count\\n        if (isPrime(setBits)) count++;\\n    }\\n\\n    // return count\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3968891,
                "title": "python3-solution-by-applying-prime-test-function-to-binary-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrimeSetBits(self, left: int, right: int) -> int:\\n        counter=0\\n        \\n        def is_prime(number):\\n            if number <= 1:\\n                return False\\n            if number <= 3:\\n                return True\\n            if number % 2 == 0 or number % 3 == 0:\\n                return False\\n            i = 5\\n            while i * i <= number:\\n                if number % i == 0 or number % (i + 2) == 0:\\n                    return False\\n                i += 6\\n            return True\\n        for i in range(left,right+1):\\n            binary=bin(i)[2:]\\n            binary_sum=sum(int(digit) for digit in binary)\\n            if is_prime(binary_sum):\\n                counter+=1\\n        return counter        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrimeSetBits(self, left: int, right: int) -> int:\\n        counter=0\\n        \\n        def is_prime(number):\\n            if number <= 1:\\n                return False\\n            if number <= 3:\\n                return True\\n            if number % 2 == 0 or number % 3 == 0:\\n                return False\\n            i = 5\\n            while i * i <= number:\\n                if number % i == 0 or number % (i + 2) == 0:\\n                    return False\\n                i += 6\\n            return True\\n        for i in range(left,right+1):\\n            binary=bin(i)[2:]\\n            binary_sum=sum(int(digit) for digit in binary)\\n            if is_prime(binary_sum):\\n                counter+=1\\n        return counter        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966345,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint Find1s(int n)\\n{\\n    int cnt = 0;\\n    while(n)\\n    {\\n        cnt++;\\n        n &= n-1;\\n    }\\n\\n    return cnt;\\n}\\n\\nbool isPrime(int n)\\n{\\n    if(n==0 || n==1)\\n        return false;\\n    \\n    for(int i=2; i<=n/2; i++)\\n        if(n%i == 0) return false;\\n    \\n    return true;\\n}\\n\\nint countPrimeSetBits(int left, int right){\\n\\n    int cnt = 0;\\n\\n    for(int i=left; i<=right; i++)\\n    {\\n        if(isPrime(Find1s(i)))\\n            cnt++;   \\n    }\\n\\n    return cnt;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint Find1s(int n)\\n{\\n    int cnt = 0;\\n    while(n)\\n    {\\n        cnt++;\\n        n &= n-1;\\n    }\\n\\n    return cnt;\\n}\\n\\nbool isPrime(int n)\\n{\\n    if(n==0 || n==1)\\n        return false;\\n    \\n    for(int i=2; i<=n/2; i++)\\n        if(n%i == 0) return false;\\n    \\n    return true;\\n}\\n\\nint countPrimeSetBits(int left, int right){\\n\\n    int cnt = 0;\\n\\n    for(int i=left; i<=right; i++)\\n    {\\n        if(isPrime(Find1s(i)))\\n            cnt++;   \\n    }\\n\\n    return cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3964855,
                "title": "easy-solution-on-go-with-math-big-9ms-6-73mb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport \"math/bits\"\\nimport \"math/big\"\\n\\nfunc countPrimeSetBits(left int, right int) int {\\n\\tres := 0\\n\\n\\tfor ; left <= right; left++ {\\n\\t\\tonesBits := bits.OnesCount(uint(left))\\n\\t\\tif big.NewInt(int64(onesBits)).ProbablyPrime(0) {\\n\\t\\t\\tres++\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nimport \"math/bits\"\\nimport \"math/big\"\\n\\nfunc countPrimeSetBits(left int, right int) int {\\n\\tres := 0\\n\\n\\tfor ; left <= right; left++ {\\n\\t\\tonesBits := bits.OnesCount(uint(left))\\n\\t\\tif big.NewInt(int64(onesBits)).ProbablyPrime(0) {\\n\\t\\t\\tres++\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3962455,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} left\\n * @param {number} right\\n * @return {number}\\n */\\nvar countPrimeSetBits = function(left, right) {\\n    let counter=0;\\n    for(i=left;i<=right;i++){\\n        if(isPrime(countBits1(i)))\\n        counter++;\\n    }\\n    return counter;\\n};\\n\\nconst isPrime = (n) => {\\n    if (n == 1) return false;\\n    for (let i = 2; i <= Math.sqrt(n); i++) {\\n        if (n % i == 0) return false;\\n    }\\n    return true;\\n}\\n\\n\\nfunction countBits1(num) {\\n    let counter = 0;\\n    while (num) {\\n        counter++;\\n        num = num & (num - 1); //remove first 1 from right\\n    }\\n    return counter;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} left\\n * @param {number} right\\n * @return {number}\\n */\\nvar countPrimeSetBits = function(left, right) {\\n    let counter=0;\\n    for(i=left;i<=right;i++){\\n        if(isPrime(countBits1(i)))\\n        counter++;\\n    }\\n    return counter;\\n};\\n\\nconst isPrime = (n) => {\\n    if (n == 1) return false;\\n    for (let i = 2; i <= Math.sqrt(n); i++) {\\n        if (n % i == 0) return false;\\n    }\\n    return true;\\n}\\n\\n\\nfunction countBits1(num) {\\n    let counter = 0;\\n    while (num) {\\n        counter++;\\n        num = num & (num - 1); //remove first 1 from right\\n    }\\n    return counter;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962223,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} left\\n * @param {number} right\\n * @return {number}\\n */\\nvar countPrimeSetBits = function(left, right) {\\n    let counter=0;\\n    for(i=left;i<=right;i++){\\n        if(isPrime(countBits1(i)))\\n        counter++;\\n    }\\n    return counter;\\n};\\n\\nconst isPrime = (n) => {\\n    if (n == 1) return false;\\n    for (let i = 2; i <= Math.sqrt(n); i++) {\\n        if (n % i == 0) return false;\\n    }\\n    return true;\\n}\\n\\n\\nfunction countBits1(num) {\\n    let counter = 0;\\n    while (num) {\\n        counter++;\\n        num = num & (num - 1); //remove first 1 from right\\n    }\\n    return counter;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} left\\n * @param {number} right\\n * @return {number}\\n */\\nvar countPrimeSetBits = function(left, right) {\\n    let counter=0;\\n    for(i=left;i<=right;i++){\\n        if(isPrime(countBits1(i)))\\n        counter++;\\n    }\\n    return counter;\\n};\\n\\nconst isPrime = (n) => {\\n    if (n == 1) return false;\\n    for (let i = 2; i <= Math.sqrt(n); i++) {\\n        if (n % i == 0) return false;\\n    }\\n    return true;\\n}\\n\\n\\nfunction countBits1(num) {\\n    let counter = 0;\\n    while (num) {\\n        counter++;\\n        num = num & (num - 1); //remove first 1 from right\\n    }\\n    return counter;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3951873,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool solve(int n) {\\n        if (n <= 1)\\n        return 0;\\n \\n    for (int i = 2; i <= n / 2; i++)\\n        if (n % i == 0)\\n            return 0;\\n    return 1;\\n    }\\n    \\n    int countPrimeSetBits(int left, int right) {\\n        int ret=0;\\n        for(int i=left; i<=right; ++i) \\n            if(solve(__builtin_popcount(i))) ret++;\\n        return ret;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool solve(int n) {\\n        if (n <= 1)\\n        return 0;\\n \\n    for (int i = 2; i <= n / 2; i++)\\n        if (n % i == 0)\\n            return 0;\\n    return 1;\\n    }\\n    \\n    int countPrimeSetBits(int left, int right) {\\n        int ret=0;\\n        for(int i=left; i<=right; ++i) \\n            if(solve(__builtin_popcount(i))) ret++;\\n        return ret;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943440,
                "title": "good-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrimeSetBits(int s, int e) {\\n      int count=0;\\n      for(int i=s;i<=e;i++){\\n          int c=countbit(i);\\n          if(isprime(c)){\\n            count++;\\n          }\\n      }\\n      return count;\\n     \\n    }\\n    public boolean isprime(int n){\\n      if(n<=1){\\n        return false;\\n\\n      }\\n      int c=2;\\n      while(c*c<=n){\\n        if(n%c==0){\\n          return false;\\n        }else{\\n          c++;\\n        }\\n\\n      }\\n      return true;\\n    }\\n    public int countbit(int n){\\n      int count=0;\\n      while(n>0){\\n        count++;\\n        n=n&(n-1);\\n      }\\n      return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrimeSetBits(int s, int e) {\\n      int count=0;\\n      for(int i=s;i<=e;i++){\\n          int c=countbit(i);\\n          if(isprime(c)){\\n            count++;\\n          }\\n      }\\n      return count;\\n     \\n    }\\n    public boolean isprime(int n){\\n      if(n<=1){\\n        return false;\\n\\n      }\\n      int c=2;\\n      while(c*c<=n){\\n        if(n%c==0){\\n          return false;\\n        }else{\\n          c++;\\n        }\\n\\n      }\\n      return true;\\n    }\\n    public int countbit(int n){\\n      int count=0;\\n      while(n>0){\\n        count++;\\n        n=n&(n-1);\\n      }\\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935396,
                "title": "direct-elixir",
                "content": "# Code\\n```\\ndefmodule Solution do\\n  @spec count_prime_set_bits(left :: integer, right :: integer) :: integer\\n  def count_prime_set_bits(left, right) do\\n    Enum.count(left..right, fn num -> is_prime_set_bits(num) end)\\n  end\\n\\n  defp is_prime_set_bits(num), do: count_bits(num) |> is_prime()\\n\\n  defp count_bits(num) do\\n    Integer.to_string(num, 2) |> String.graphemes() |> Enum.count(fn char -> char == \"1\" end)\\n  end\\n\\n  defp is_prime(num) do\\n    num in [2, 3, 5, 7, 11, 13, 17, 19] \\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec count_prime_set_bits(left :: integer, right :: integer) :: integer\\n  def count_prime_set_bits(left, right) do\\n    Enum.count(left..right, fn num -> is_prime_set_bits(num) end)\\n  end\\n\\n  defp is_prime_set_bits(num), do: count_bits(num) |> is_prime()\\n\\n  defp count_bits(num) do\\n    Integer.to_string(num, 2) |> String.graphemes() |> Enum.count(fn char -> char == \"1\" end)\\n  end\\n\\n  defp is_prime(num) do\\n    num in [2, 3, 5, 7, 11, 13, 17, 19] \\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3933062,
                "title": "java-basic-approach-must-check-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate Bitcount of each number in [left , right], now check wheather that count is prime or not, if count is prime then take another variable and increase its count, and return it......\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrimeSetBits(int left, int right) {\\n        int count = 0;\\n\\n        for(int i = left ; i <= right ; i++){\\n\\n            int temp = bitCount(i);\\n\\n            if(primeBitCount(temp)){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public static int bitCount(int n){\\n\\n        int c = 0;\\n        while(n > 0){\\n            int rem = n % 2;\\n\\n            if(rem == 1){\\n                c++;\\n            }\\n            n = n / 2;\\n        }\\n        return c;\\n    }\\n\\n    public static boolean primeBitCount(int val){\\n\\n        int cnt = 0;\\n        for(int j = 1 ; j <= val ; j++){\\n\\n            if(val % j == 0){\\n                cnt++;\\n            }\\n        }\\n        if(cnt == 2){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrimeSetBits(int left, int right) {\\n        int count = 0;\\n\\n        for(int i = left ; i <= right ; i++){\\n\\n            int temp = bitCount(i);\\n\\n            if(primeBitCount(temp)){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public static int bitCount(int n){\\n\\n        int c = 0;\\n        while(n > 0){\\n            int rem = n % 2;\\n\\n            if(rem == 1){\\n                c++;\\n            }\\n            n = n / 2;\\n        }\\n        return c;\\n    }\\n\\n    public static boolean primeBitCount(int val){\\n\\n        int cnt = 0;\\n        for(int j = 1 ; j <= val ; j++){\\n\\n            if(val % j == 0){\\n                cnt++;\\n            }\\n        }\\n        if(cnt == 2){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926107,
                "title": "simple-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int calculateBit(String b){\\n        int count=0;\\n        for(int i=0;i<b.length();i++){\\n            if(b.charAt(i)==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    public static boolean isPrime(int count){\\n        if(count==1||count==0){\\n            return false;\\n        }\\n        for(int i=2;i<=count/2;i++){\\n            if(count%i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public int countPrimeSetBits(int l, int r) {\\n       int count =0;\\n       for(int i = l;i<=r;i++){\\n           String b = Integer.toBinaryString(i);\\n           int n = calculateBit(b);\\n           if(isPrime(n)){\\n               count++;\\n           }\\n       }\\n       return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int calculateBit(String b){\\n        int count=0;\\n        for(int i=0;i<b.length();i++){\\n            if(b.charAt(i)==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    public static boolean isPrime(int count){\\n        if(count==1||count==0){\\n            return false;\\n        }\\n        for(int i=2;i<=count/2;i++){\\n            if(count%i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public int countPrimeSetBits(int l, int r) {\\n       int count =0;\\n       for(int i = l;i<=r;i++){\\n           String b = Integer.toBinaryString(i);\\n           int n = calculateBit(b);\\n           if(isPrime(n)){\\n               count++;\\n           }\\n       }\\n       return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915333,
                "title": "problem-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first I thought I might need to use the left, right as starting stopping points. Then do a while loop and sort through, converting to binary, checking for prime and then counting the items pushed to a new array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs I mapped out my intuition and initial thoughts I realized I might be able to set my left, right variables as a range, which can be converted to an array. Much easier to map or use select as my iterator. From there I still needed to convert to binary and determine if it was prime number.\\n\\nThe translating to binary I was pretty confident there was a standard Ruby method that could do this easily, and there was.\\n\\nThe prime number I wasn\\'t sure if there would be a direct method. Ultimately I saw a lot of methods/algos determining prime but ended up importing the library for simplicity sake. No need to recreate something that already exists.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# @param {Integer} left\\n# @param {Integer} right\\n# @return {Integer}\\nrequire \\'prime\\'\\n\\ndef count_prime_set_bits(left, right)\\n    range = (left..right).to_a\\n\\n    range.select do |num|\\n        binary = num.to_s(2)\\n        count = binary.count \"1\"\\n        count.prime?\\n    end.count\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer} left\\n# @param {Integer} right\\n# @return {Integer}\\nrequire \\'prime\\'\\n\\ndef count_prime_set_bits(left, right)\\n    range = (left..right).to_a\\n\\n    range.select do |num|\\n        binary = num.to_s(2)\\n        count = binary.count \"1\"\\n        count.prime?\\n    end.count\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3900506,
                "title": "solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrimeSetBits(int left, int right) {\\n        int ans=0;\\n        for(int i=left;i<=right;i++){\\n             if(isPrime(countBits(i))){\\n                 ans++;\\n             }\\n        }\\n        return ans;      \\n    }\\n    int countBits(int n){\\n          int count=0;\\n            while(n!=0){\\n                n=n&(n-1);\\n                count++;\\n            }\\n            return count;\\n    }\\n    private static boolean isPrime(int n) {\\n\\t\\tif(n<=1)return false;\\n\\t\\tfor(int i=2;i<=Math.sqrt(n);i++) {\\n\\t\\t\\tif(n%i==0)return false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrimeSetBits(int left, int right) {\\n        int ans=0;\\n        for(int i=left;i<=right;i++){\\n             if(isPrime(countBits(i))){\\n                 ans++;\\n             }\\n        }\\n        return ans;      \\n    }\\n    int countBits(int n){\\n          int count=0;\\n            while(n!=0){\\n                n=n&(n-1);\\n                count++;\\n            }\\n            return count;\\n    }\\n    private static boolean isPrime(int n) {\\n\\t\\tif(n<=1)return false;\\n\\t\\tfor(int i=2;i<=Math.sqrt(n);i++) {\\n\\t\\t\\tif(n%i==0)return false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898784,
                "title": "easiest-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int count_one(int n){\\n        int count=0;\\n        while(n){\\n            n=n&(n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n        \\n        vector<int> v;\\n        \\n\\n        while(left<=right){\\n            int ans=count_one(left);\\n            v.push_back(ans);\\n            left++;\\n        }\\n\\n        int res=0;\\n        for(auto ele:v){\\n            if(ele==2||ele==3||ele==5)\\n                res++;\\n                else if(ele%2!=0 and ele!=1&& ele%3!=0 && ele%5!=0)\\n                res++;\\n        }\\n\\n        return res;\\n    }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int count_one(int n){\\n        int count=0;\\n        while(n){\\n            n=n&(n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n        \\n        vector<int> v;\\n        \\n\\n        while(left<=right){\\n            int ans=count_one(left);\\n            v.push_back(ans);\\n            left++;\\n        }\\n\\n        int res=0;\\n        for(auto ele:v){\\n            if(ele==2||ele==3||ele==5)\\n                res++;\\n                else if(ele%2!=0 and ele!=1&& ele%3!=0 && ele%5!=0)\\n                res++;\\n        }\\n\\n        return res;\\n    }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898781,
                "title": "easiest-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int count_one(int n){\\n        int count=0;\\n        while(n){\\n            n=n&(n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n        \\n        vector<int> v;\\n        \\n\\n        while(left<=right){\\n            int ans=count_one(left);\\n            v.push_back(ans);\\n            left++;\\n        }\\n\\n        int res=0;\\n        for(auto ele:v){\\n            if(ele==2||ele==3||ele==5)\\n                res++;\\n                else if(ele%2!=0 and ele!=1&& ele%3!=0 && ele%5!=0)\\n                res++;\\n        }\\n\\n        return res;\\n    }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int count_one(int n){\\n        int count=0;\\n        while(n){\\n            n=n&(n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n        \\n        vector<int> v;\\n        \\n\\n        while(left<=right){\\n            int ans=count_one(left);\\n            v.push_back(ans);\\n            left++;\\n        }\\n\\n        int res=0;\\n        for(auto ele:v){\\n            if(ele==2||ele==3||ele==5)\\n                res++;\\n                else if(ele%2!=0 and ele!=1&& ele%3!=0 && ele%5!=0)\\n                res++;\\n        }\\n\\n        return res;\\n    }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896534,
                "title": "c-easy-sol-using-prime-vector-method",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n        int range=(int)(sqrt(right)+1),i,j,result=0;\\n        vector<int> prime(range+1,1);\\n        prime[0]=0,prime[1]=0;\\n        for(i=2;i<=sqrt(range);i++){\\n            if(prime[i]==1){\\n                for(j=i*i;j<=range;j=j+i)\\n                prime[j]=0;\\n            }\\n        }\\n        for(i=left;i<=right;i++){\\n            int t=i,count=0;\\n            while(t){\\n                if(t%2==1)\\n                count++;\\n                t=t/2;\\n            }\\n            if(prime[count]){\\n                cout<<i<<\" \"<<count<<endl;\\n                result++;\\n            }\\n        }\\n        for(auto i:prime)\\n        cout<<i<<\" \";\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrimeSetBits(int left, int right) {\\n        int range=(int)(sqrt(right)+1),i,j,result=0;\\n        vector<int> prime(range+1,1);\\n        prime[0]=0,prime[1]=0;\\n        for(i=2;i<=sqrt(range);i++){\\n            if(prime[i]==1){\\n                for(j=i*i;j<=range;j=j+i)\\n                prime[j]=0;\\n            }\\n        }\\n        for(i=left;i<=right;i++){\\n            int t=i,count=0;\\n            while(t){\\n                if(t%2==1)\\n                count++;\\n                t=t/2;\\n            }\\n            if(prime[count]){\\n                cout<<i<<\" \"<<count<<endl;\\n                result++;\\n            }\\n        }\\n        for(auto i:prime)\\n        cout<<i<<\" \";\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3895642,
                "title": "solution-with-3-for-loop-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} left\\n * @param {number} right\\n * @return {number}\\n */\\nvar countPrimeSetBits = function(left, right) {\\n    \\n   if(left < 10000000 && (right - left) <= 100000) { \\n    \\n    let result = 0;\\n     \\n    for(let i = left;i <=right;i++) {\\n      \\n        let asalcheck =true;\\n       \\n        let count = 0\\n        let number = i.toString(2).split(\\'\\');\\n     \\n        for(let j =0;j < number.length;j++) {\\n            if(number[j] == 1) {\\n               count++\\n            }\\n         \\n        }\\n        if(count < 2) {\\n            asalcheck = false\\n        }\\n      \\n        for(let k = 2;k <= count;k++) {\\n         \\n         if(count % k === 0 && count != k ) {\\n             asalcheck = false;\\n         }\\n        }\\n     \\n        if(asalcheck === true) {\\n            result++;\\n        }   \\n       \\n}\\n    \\n    return result\\n    \\n}\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} left\\n * @param {number} right\\n * @return {number}\\n */\\nvar countPrimeSetBits = function(left, right) {\\n    \\n   if(left < 10000000 && (right - left) <= 100000) { \\n    \\n    let result = 0;\\n     \\n    for(let i = left;i <=right;i++) {\\n      \\n        let asalcheck =true;\\n       \\n        let count = 0\\n        let number = i.toString(2).split(\\'\\');\\n     \\n        for(let j =0;j < number.length;j++) {\\n            if(number[j] == 1) {\\n               count++\\n            }\\n         \\n        }\\n        if(count < 2) {\\n            asalcheck = false\\n        }\\n      \\n        for(let k = 2;k <= count;k++) {\\n         \\n         if(count % k === 0 && count != k ) {\\n             asalcheck = false;\\n         }\\n        }\\n     \\n        if(asalcheck === true) {\\n            result++;\\n        }   \\n       \\n}\\n    \\n    return result\\n    \\n}\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3887930,
                "title": "go",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    import bits2 \"math/bits\"\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\nimport bits2 \"math/bits\"\\n\\nfunc countPrimeSetBits(left int, right int) int {\\n\\tvar result int\\n\\n\\tfor i := left; i <= right; i++ {\\n\\t\\toneCount := bits2.OnesCount(uint(i))\\n\\t\\tif isPrime(oneCount) {\\n\\t\\t\\tresult++\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc isPrime(num int) bool {\\n\\tif num <= 1 {\\n\\t\\treturn false\\n\\t} else if num <= 3 {\\n\\t\\treturn true\\n\\t} else if num%2 == 0 || num%3 == 0 {\\n\\t\\treturn false\\n\\t}\\n\\n\\ti := 5\\n\\tfor i*i < num {\\n\\t\\tif num%i == 0 || num%(i+2) == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\ti += 6\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nimport bits2 \"math/bits\"\\n\\nfunc countPrimeSetBits(left int, right int) int {\\n\\tvar result int\\n\\n\\tfor i := left; i <= right; i++ {\\n\\t\\toneCount := bits2.OnesCount(uint(i))\\n\\t\\tif isPrime(oneCount) {\\n\\t\\t\\tresult++\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc isPrime(num int) bool {\\n\\tif num <= 1 {\\n\\t\\treturn false\\n\\t} else if num <= 3 {\\n\\t\\treturn true\\n\\t} else if num%2 == 0 || num%3 == 0 {\\n\\t\\treturn false\\n\\t}\\n\\n\\ti := 5\\n\\tfor i*i < num {\\n\\t\\tif num%i == 0 || num%(i+2) == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\ti += 6\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1683996,
                "content": [
                    {
                        "username": "J_AcHiNt",
                        "content": "i am not getting it my code is just taking 651ms to run but still facing TIME LIMIT EXCEEDED why?\\n"
                    },
                    {
                        "username": "user5400vw",
                        "content": "[@Teja767](/Teja767) wow didn\\'t expect there to be optimization necessary in an Easy.  That said, yes, you should know the sqrt optimization for the classic isPrime implementation"
                    },
                    {
                        "username": "Teja767",
                        "content": "use sqrt in prime logic it will helps to reduce time limit"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The constraint `1 <= left <= right <= 10^6` tells you that the maximum number you can get is `10^6`.\\nThis number is represented as `1111 01000010 01000000` in binary, which means that the most amount of bits set (for this problem) is 19: `111 11111111 11111111`.\\nAll the prime numbers up to 19 (inclusive) are `[2, 3, 5, 7, 11, 13, 17, 19]`.\\nThe only thing left for you is to count the number of bits set for the numbers in the range."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice question,  Eratosthenes helped me solve this"
                    },
                    {
                        "username": "iota_spark",
                        "content": "!!! why my code is not running for long value such as 3 digit number range.....\\n\\n\\n\\nclass Solution {\\npublic:\\nbool isPrime(long int n){\\n    if(n==1)\\n    return false;\\n    if(n==2 || n==3)\\n    return true;\\n    if(n%2==0 || n%3==0)\\n    return false;\\n    for(long int i=5;i<n;i=i+6)\\n    if(n%i==0 || n%(i+2)==0)\\n    return false;\\n    return true;\\n}\\nint count(long int x)\\n{\\n    int c=0;\\n     while(x!=0)\\n    {\\n        x=x&(x-1);\\n        c++;\\n    }\\n    return c;\\n}\\n    int countPrimeSetBits(int left, int right) {\\n        int c=0;\\n        for(long int i=left;i<=right;i++)\\n        {\\n            if(isPrime(count(i))==1)\\n            c++;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your original C++ code is generally correct in logic, but it can be optimized in terms of efficiency.\\n\\nThe `isPrime` function, as it\\'s currently written, iterates over every number from 2 to `n` to check whether `n` is divisible by any of these numbers. This is not efficient for larger `n` because it requires a lot of division operations. A more efficient approach is to check divisibility only up to the square root of `n`, because a larger factor of `n` would have a corresponding smaller factor that has already been tested.\\n\\nYour `count` function also has room for optimization. This function is using the Brian Kernighan\\u2019s Algorithm to count the set bits in an integer. It\\'s generally an efficient way to count set bits, but when you know your input range, you can limit the calculations that you need to perform.\\n\\nIn your specific problem, you\\'re working with 32-bit integers. Therefore, the maximum number of set bits in a number would be 32. But, since you only have to find the count of prime set bits, and the largest prime number less than 32 is 31, you only have to check for primes numbers up to 31. This can significantly reduce the number of iterations in your `isPrime` function.\\n\\nHere\\'s an optimized version of your C++ code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isPrime(int n) {\\n        if (n <= 1) return false;\\n        if (n <= 3) return true;\\n        if (n % 2 == 0 || n % 3 == 0) return false;\\n        for (int i = 5; i * i <= n; i += 6)\\n            if (n % i == 0 || n % (i + 2) == 0)\\n                return false;\\n        return true;\\n    }\\n\\n    int countSetBits(int n) {\\n        int count = 0;\\n        while (n) {\\n            n &= (n - 1);\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    int countPrimeSetBits(int left, int right) {\\n        int count = 0;\\n        for (int i = left; i <= right; i++) {\\n            if (isPrime(countSetBits(i))) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\nThis version of the code reduces the range of numbers checked in the `isPrime` function to only up to the square root of `n`, and keeps the `countSetBits` function the same. The main function `countPrimeSetBits` remains the same. This optimized version should run faster, especially for larger input ranges."
                    },
                    {
                        "username": "wasam1119",
                        "content": "Tip: Consider the length of the binary representation of the largest acceptable value\\n "
                    },
                    {
                        "username": "Harsh_Singh23_",
                        "content": "can anyone tell me how to use isPrime() method in java? What should i import for this?"
                    },
                    {
                        "username": "Teja767",
                        "content": "there is no inbuild prime method in java(so u cant import it)\\n u need to implement prime logic yourself"
                    },
                    {
                        "username": "rntongo",
                        "content": "you have to implement it yourself. Iterate from 1 till num. Then maintain a counter to store the number of factors i.e everytime you find a number where num%i==0 increment the counter. then if the counter==2 after the loop its a prime number else its a not"
                    }
                ]
            },
            {
                "id": 2067169,
                "content": [
                    {
                        "username": "J_AcHiNt",
                        "content": "i am not getting it my code is just taking 651ms to run but still facing TIME LIMIT EXCEEDED why?\\n"
                    },
                    {
                        "username": "user5400vw",
                        "content": "[@Teja767](/Teja767) wow didn\\'t expect there to be optimization necessary in an Easy.  That said, yes, you should know the sqrt optimization for the classic isPrime implementation"
                    },
                    {
                        "username": "Teja767",
                        "content": "use sqrt in prime logic it will helps to reduce time limit"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The constraint `1 <= left <= right <= 10^6` tells you that the maximum number you can get is `10^6`.\\nThis number is represented as `1111 01000010 01000000` in binary, which means that the most amount of bits set (for this problem) is 19: `111 11111111 11111111`.\\nAll the prime numbers up to 19 (inclusive) are `[2, 3, 5, 7, 11, 13, 17, 19]`.\\nThe only thing left for you is to count the number of bits set for the numbers in the range."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice question,  Eratosthenes helped me solve this"
                    },
                    {
                        "username": "iota_spark",
                        "content": "!!! why my code is not running for long value such as 3 digit number range.....\\n\\n\\n\\nclass Solution {\\npublic:\\nbool isPrime(long int n){\\n    if(n==1)\\n    return false;\\n    if(n==2 || n==3)\\n    return true;\\n    if(n%2==0 || n%3==0)\\n    return false;\\n    for(long int i=5;i<n;i=i+6)\\n    if(n%i==0 || n%(i+2)==0)\\n    return false;\\n    return true;\\n}\\nint count(long int x)\\n{\\n    int c=0;\\n     while(x!=0)\\n    {\\n        x=x&(x-1);\\n        c++;\\n    }\\n    return c;\\n}\\n    int countPrimeSetBits(int left, int right) {\\n        int c=0;\\n        for(long int i=left;i<=right;i++)\\n        {\\n            if(isPrime(count(i))==1)\\n            c++;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your original C++ code is generally correct in logic, but it can be optimized in terms of efficiency.\\n\\nThe `isPrime` function, as it\\'s currently written, iterates over every number from 2 to `n` to check whether `n` is divisible by any of these numbers. This is not efficient for larger `n` because it requires a lot of division operations. A more efficient approach is to check divisibility only up to the square root of `n`, because a larger factor of `n` would have a corresponding smaller factor that has already been tested.\\n\\nYour `count` function also has room for optimization. This function is using the Brian Kernighan\\u2019s Algorithm to count the set bits in an integer. It\\'s generally an efficient way to count set bits, but when you know your input range, you can limit the calculations that you need to perform.\\n\\nIn your specific problem, you\\'re working with 32-bit integers. Therefore, the maximum number of set bits in a number would be 32. But, since you only have to find the count of prime set bits, and the largest prime number less than 32 is 31, you only have to check for primes numbers up to 31. This can significantly reduce the number of iterations in your `isPrime` function.\\n\\nHere\\'s an optimized version of your C++ code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isPrime(int n) {\\n        if (n <= 1) return false;\\n        if (n <= 3) return true;\\n        if (n % 2 == 0 || n % 3 == 0) return false;\\n        for (int i = 5; i * i <= n; i += 6)\\n            if (n % i == 0 || n % (i + 2) == 0)\\n                return false;\\n        return true;\\n    }\\n\\n    int countSetBits(int n) {\\n        int count = 0;\\n        while (n) {\\n            n &= (n - 1);\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    int countPrimeSetBits(int left, int right) {\\n        int count = 0;\\n        for (int i = left; i <= right; i++) {\\n            if (isPrime(countSetBits(i))) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\nThis version of the code reduces the range of numbers checked in the `isPrime` function to only up to the square root of `n`, and keeps the `countSetBits` function the same. The main function `countPrimeSetBits` remains the same. This optimized version should run faster, especially for larger input ranges."
                    },
                    {
                        "username": "wasam1119",
                        "content": "Tip: Consider the length of the binary representation of the largest acceptable value\\n "
                    },
                    {
                        "username": "Harsh_Singh23_",
                        "content": "can anyone tell me how to use isPrime() method in java? What should i import for this?"
                    },
                    {
                        "username": "Teja767",
                        "content": "there is no inbuild prime method in java(so u cant import it)\\n u need to implement prime logic yourself"
                    },
                    {
                        "username": "rntongo",
                        "content": "you have to implement it yourself. Iterate from 1 till num. Then maintain a counter to store the number of factors i.e everytime you find a number where num%i==0 increment the counter. then if the counter==2 after the loop its a prime number else its a not"
                    }
                ]
            },
            {
                "id": 1864123,
                "content": [
                    {
                        "username": "J_AcHiNt",
                        "content": "i am not getting it my code is just taking 651ms to run but still facing TIME LIMIT EXCEEDED why?\\n"
                    },
                    {
                        "username": "user5400vw",
                        "content": "[@Teja767](/Teja767) wow didn\\'t expect there to be optimization necessary in an Easy.  That said, yes, you should know the sqrt optimization for the classic isPrime implementation"
                    },
                    {
                        "username": "Teja767",
                        "content": "use sqrt in prime logic it will helps to reduce time limit"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The constraint `1 <= left <= right <= 10^6` tells you that the maximum number you can get is `10^6`.\\nThis number is represented as `1111 01000010 01000000` in binary, which means that the most amount of bits set (for this problem) is 19: `111 11111111 11111111`.\\nAll the prime numbers up to 19 (inclusive) are `[2, 3, 5, 7, 11, 13, 17, 19]`.\\nThe only thing left for you is to count the number of bits set for the numbers in the range."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice question,  Eratosthenes helped me solve this"
                    },
                    {
                        "username": "iota_spark",
                        "content": "!!! why my code is not running for long value such as 3 digit number range.....\\n\\n\\n\\nclass Solution {\\npublic:\\nbool isPrime(long int n){\\n    if(n==1)\\n    return false;\\n    if(n==2 || n==3)\\n    return true;\\n    if(n%2==0 || n%3==0)\\n    return false;\\n    for(long int i=5;i<n;i=i+6)\\n    if(n%i==0 || n%(i+2)==0)\\n    return false;\\n    return true;\\n}\\nint count(long int x)\\n{\\n    int c=0;\\n     while(x!=0)\\n    {\\n        x=x&(x-1);\\n        c++;\\n    }\\n    return c;\\n}\\n    int countPrimeSetBits(int left, int right) {\\n        int c=0;\\n        for(long int i=left;i<=right;i++)\\n        {\\n            if(isPrime(count(i))==1)\\n            c++;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your original C++ code is generally correct in logic, but it can be optimized in terms of efficiency.\\n\\nThe `isPrime` function, as it\\'s currently written, iterates over every number from 2 to `n` to check whether `n` is divisible by any of these numbers. This is not efficient for larger `n` because it requires a lot of division operations. A more efficient approach is to check divisibility only up to the square root of `n`, because a larger factor of `n` would have a corresponding smaller factor that has already been tested.\\n\\nYour `count` function also has room for optimization. This function is using the Brian Kernighan\\u2019s Algorithm to count the set bits in an integer. It\\'s generally an efficient way to count set bits, but when you know your input range, you can limit the calculations that you need to perform.\\n\\nIn your specific problem, you\\'re working with 32-bit integers. Therefore, the maximum number of set bits in a number would be 32. But, since you only have to find the count of prime set bits, and the largest prime number less than 32 is 31, you only have to check for primes numbers up to 31. This can significantly reduce the number of iterations in your `isPrime` function.\\n\\nHere\\'s an optimized version of your C++ code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isPrime(int n) {\\n        if (n <= 1) return false;\\n        if (n <= 3) return true;\\n        if (n % 2 == 0 || n % 3 == 0) return false;\\n        for (int i = 5; i * i <= n; i += 6)\\n            if (n % i == 0 || n % (i + 2) == 0)\\n                return false;\\n        return true;\\n    }\\n\\n    int countSetBits(int n) {\\n        int count = 0;\\n        while (n) {\\n            n &= (n - 1);\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    int countPrimeSetBits(int left, int right) {\\n        int count = 0;\\n        for (int i = left; i <= right; i++) {\\n            if (isPrime(countSetBits(i))) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\nThis version of the code reduces the range of numbers checked in the `isPrime` function to only up to the square root of `n`, and keeps the `countSetBits` function the same. The main function `countPrimeSetBits` remains the same. This optimized version should run faster, especially for larger input ranges."
                    },
                    {
                        "username": "wasam1119",
                        "content": "Tip: Consider the length of the binary representation of the largest acceptable value\\n "
                    },
                    {
                        "username": "Harsh_Singh23_",
                        "content": "can anyone tell me how to use isPrime() method in java? What should i import for this?"
                    },
                    {
                        "username": "Teja767",
                        "content": "there is no inbuild prime method in java(so u cant import it)\\n u need to implement prime logic yourself"
                    },
                    {
                        "username": "rntongo",
                        "content": "you have to implement it yourself. Iterate from 1 till num. Then maintain a counter to store the number of factors i.e everytime you find a number where num%i==0 increment the counter. then if the counter==2 after the loop its a prime number else its a not"
                    }
                ]
            },
            {
                "id": 1834402,
                "content": [
                    {
                        "username": "J_AcHiNt",
                        "content": "i am not getting it my code is just taking 651ms to run but still facing TIME LIMIT EXCEEDED why?\\n"
                    },
                    {
                        "username": "user5400vw",
                        "content": "[@Teja767](/Teja767) wow didn\\'t expect there to be optimization necessary in an Easy.  That said, yes, you should know the sqrt optimization for the classic isPrime implementation"
                    },
                    {
                        "username": "Teja767",
                        "content": "use sqrt in prime logic it will helps to reduce time limit"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The constraint `1 <= left <= right <= 10^6` tells you that the maximum number you can get is `10^6`.\\nThis number is represented as `1111 01000010 01000000` in binary, which means that the most amount of bits set (for this problem) is 19: `111 11111111 11111111`.\\nAll the prime numbers up to 19 (inclusive) are `[2, 3, 5, 7, 11, 13, 17, 19]`.\\nThe only thing left for you is to count the number of bits set for the numbers in the range."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice question,  Eratosthenes helped me solve this"
                    },
                    {
                        "username": "iota_spark",
                        "content": "!!! why my code is not running for long value such as 3 digit number range.....\\n\\n\\n\\nclass Solution {\\npublic:\\nbool isPrime(long int n){\\n    if(n==1)\\n    return false;\\n    if(n==2 || n==3)\\n    return true;\\n    if(n%2==0 || n%3==0)\\n    return false;\\n    for(long int i=5;i<n;i=i+6)\\n    if(n%i==0 || n%(i+2)==0)\\n    return false;\\n    return true;\\n}\\nint count(long int x)\\n{\\n    int c=0;\\n     while(x!=0)\\n    {\\n        x=x&(x-1);\\n        c++;\\n    }\\n    return c;\\n}\\n    int countPrimeSetBits(int left, int right) {\\n        int c=0;\\n        for(long int i=left;i<=right;i++)\\n        {\\n            if(isPrime(count(i))==1)\\n            c++;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your original C++ code is generally correct in logic, but it can be optimized in terms of efficiency.\\n\\nThe `isPrime` function, as it\\'s currently written, iterates over every number from 2 to `n` to check whether `n` is divisible by any of these numbers. This is not efficient for larger `n` because it requires a lot of division operations. A more efficient approach is to check divisibility only up to the square root of `n`, because a larger factor of `n` would have a corresponding smaller factor that has already been tested.\\n\\nYour `count` function also has room for optimization. This function is using the Brian Kernighan\\u2019s Algorithm to count the set bits in an integer. It\\'s generally an efficient way to count set bits, but when you know your input range, you can limit the calculations that you need to perform.\\n\\nIn your specific problem, you\\'re working with 32-bit integers. Therefore, the maximum number of set bits in a number would be 32. But, since you only have to find the count of prime set bits, and the largest prime number less than 32 is 31, you only have to check for primes numbers up to 31. This can significantly reduce the number of iterations in your `isPrime` function.\\n\\nHere\\'s an optimized version of your C++ code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isPrime(int n) {\\n        if (n <= 1) return false;\\n        if (n <= 3) return true;\\n        if (n % 2 == 0 || n % 3 == 0) return false;\\n        for (int i = 5; i * i <= n; i += 6)\\n            if (n % i == 0 || n % (i + 2) == 0)\\n                return false;\\n        return true;\\n    }\\n\\n    int countSetBits(int n) {\\n        int count = 0;\\n        while (n) {\\n            n &= (n - 1);\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    int countPrimeSetBits(int left, int right) {\\n        int count = 0;\\n        for (int i = left; i <= right; i++) {\\n            if (isPrime(countSetBits(i))) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\nThis version of the code reduces the range of numbers checked in the `isPrime` function to only up to the square root of `n`, and keeps the `countSetBits` function the same. The main function `countPrimeSetBits` remains the same. This optimized version should run faster, especially for larger input ranges."
                    },
                    {
                        "username": "wasam1119",
                        "content": "Tip: Consider the length of the binary representation of the largest acceptable value\\n "
                    },
                    {
                        "username": "Harsh_Singh23_",
                        "content": "can anyone tell me how to use isPrime() method in java? What should i import for this?"
                    },
                    {
                        "username": "Teja767",
                        "content": "there is no inbuild prime method in java(so u cant import it)\\n u need to implement prime logic yourself"
                    },
                    {
                        "username": "rntongo",
                        "content": "you have to implement it yourself. Iterate from 1 till num. Then maintain a counter to store the number of factors i.e everytime you find a number where num%i==0 increment the counter. then if the counter==2 after the loop its a prime number else its a not"
                    }
                ]
            },
            {
                "id": 1804347,
                "content": [
                    {
                        "username": "J_AcHiNt",
                        "content": "i am not getting it my code is just taking 651ms to run but still facing TIME LIMIT EXCEEDED why?\\n"
                    },
                    {
                        "username": "user5400vw",
                        "content": "[@Teja767](/Teja767) wow didn\\'t expect there to be optimization necessary in an Easy.  That said, yes, you should know the sqrt optimization for the classic isPrime implementation"
                    },
                    {
                        "username": "Teja767",
                        "content": "use sqrt in prime logic it will helps to reduce time limit"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The constraint `1 <= left <= right <= 10^6` tells you that the maximum number you can get is `10^6`.\\nThis number is represented as `1111 01000010 01000000` in binary, which means that the most amount of bits set (for this problem) is 19: `111 11111111 11111111`.\\nAll the prime numbers up to 19 (inclusive) are `[2, 3, 5, 7, 11, 13, 17, 19]`.\\nThe only thing left for you is to count the number of bits set for the numbers in the range."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice question,  Eratosthenes helped me solve this"
                    },
                    {
                        "username": "iota_spark",
                        "content": "!!! why my code is not running for long value such as 3 digit number range.....\\n\\n\\n\\nclass Solution {\\npublic:\\nbool isPrime(long int n){\\n    if(n==1)\\n    return false;\\n    if(n==2 || n==3)\\n    return true;\\n    if(n%2==0 || n%3==0)\\n    return false;\\n    for(long int i=5;i<n;i=i+6)\\n    if(n%i==0 || n%(i+2)==0)\\n    return false;\\n    return true;\\n}\\nint count(long int x)\\n{\\n    int c=0;\\n     while(x!=0)\\n    {\\n        x=x&(x-1);\\n        c++;\\n    }\\n    return c;\\n}\\n    int countPrimeSetBits(int left, int right) {\\n        int c=0;\\n        for(long int i=left;i<=right;i++)\\n        {\\n            if(isPrime(count(i))==1)\\n            c++;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your original C++ code is generally correct in logic, but it can be optimized in terms of efficiency.\\n\\nThe `isPrime` function, as it\\'s currently written, iterates over every number from 2 to `n` to check whether `n` is divisible by any of these numbers. This is not efficient for larger `n` because it requires a lot of division operations. A more efficient approach is to check divisibility only up to the square root of `n`, because a larger factor of `n` would have a corresponding smaller factor that has already been tested.\\n\\nYour `count` function also has room for optimization. This function is using the Brian Kernighan\\u2019s Algorithm to count the set bits in an integer. It\\'s generally an efficient way to count set bits, but when you know your input range, you can limit the calculations that you need to perform.\\n\\nIn your specific problem, you\\'re working with 32-bit integers. Therefore, the maximum number of set bits in a number would be 32. But, since you only have to find the count of prime set bits, and the largest prime number less than 32 is 31, you only have to check for primes numbers up to 31. This can significantly reduce the number of iterations in your `isPrime` function.\\n\\nHere\\'s an optimized version of your C++ code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isPrime(int n) {\\n        if (n <= 1) return false;\\n        if (n <= 3) return true;\\n        if (n % 2 == 0 || n % 3 == 0) return false;\\n        for (int i = 5; i * i <= n; i += 6)\\n            if (n % i == 0 || n % (i + 2) == 0)\\n                return false;\\n        return true;\\n    }\\n\\n    int countSetBits(int n) {\\n        int count = 0;\\n        while (n) {\\n            n &= (n - 1);\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    int countPrimeSetBits(int left, int right) {\\n        int count = 0;\\n        for (int i = left; i <= right; i++) {\\n            if (isPrime(countSetBits(i))) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\nThis version of the code reduces the range of numbers checked in the `isPrime` function to only up to the square root of `n`, and keeps the `countSetBits` function the same. The main function `countPrimeSetBits` remains the same. This optimized version should run faster, especially for larger input ranges."
                    },
                    {
                        "username": "wasam1119",
                        "content": "Tip: Consider the length of the binary representation of the largest acceptable value\\n "
                    },
                    {
                        "username": "Harsh_Singh23_",
                        "content": "can anyone tell me how to use isPrime() method in java? What should i import for this?"
                    },
                    {
                        "username": "Teja767",
                        "content": "there is no inbuild prime method in java(so u cant import it)\\n u need to implement prime logic yourself"
                    },
                    {
                        "username": "rntongo",
                        "content": "you have to implement it yourself. Iterate from 1 till num. Then maintain a counter to store the number of factors i.e everytime you find a number where num%i==0 increment the counter. then if the counter==2 after the loop its a prime number else its a not"
                    }
                ]
            },
            {
                "id": 1709859,
                "content": [
                    {
                        "username": "J_AcHiNt",
                        "content": "i am not getting it my code is just taking 651ms to run but still facing TIME LIMIT EXCEEDED why?\\n"
                    },
                    {
                        "username": "user5400vw",
                        "content": "[@Teja767](/Teja767) wow didn\\'t expect there to be optimization necessary in an Easy.  That said, yes, you should know the sqrt optimization for the classic isPrime implementation"
                    },
                    {
                        "username": "Teja767",
                        "content": "use sqrt in prime logic it will helps to reduce time limit"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The constraint `1 <= left <= right <= 10^6` tells you that the maximum number you can get is `10^6`.\\nThis number is represented as `1111 01000010 01000000` in binary, which means that the most amount of bits set (for this problem) is 19: `111 11111111 11111111`.\\nAll the prime numbers up to 19 (inclusive) are `[2, 3, 5, 7, 11, 13, 17, 19]`.\\nThe only thing left for you is to count the number of bits set for the numbers in the range."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice question,  Eratosthenes helped me solve this"
                    },
                    {
                        "username": "iota_spark",
                        "content": "!!! why my code is not running for long value such as 3 digit number range.....\\n\\n\\n\\nclass Solution {\\npublic:\\nbool isPrime(long int n){\\n    if(n==1)\\n    return false;\\n    if(n==2 || n==3)\\n    return true;\\n    if(n%2==0 || n%3==0)\\n    return false;\\n    for(long int i=5;i<n;i=i+6)\\n    if(n%i==0 || n%(i+2)==0)\\n    return false;\\n    return true;\\n}\\nint count(long int x)\\n{\\n    int c=0;\\n     while(x!=0)\\n    {\\n        x=x&(x-1);\\n        c++;\\n    }\\n    return c;\\n}\\n    int countPrimeSetBits(int left, int right) {\\n        int c=0;\\n        for(long int i=left;i<=right;i++)\\n        {\\n            if(isPrime(count(i))==1)\\n            c++;\\n        }\\n        return c;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your original C++ code is generally correct in logic, but it can be optimized in terms of efficiency.\\n\\nThe `isPrime` function, as it\\'s currently written, iterates over every number from 2 to `n` to check whether `n` is divisible by any of these numbers. This is not efficient for larger `n` because it requires a lot of division operations. A more efficient approach is to check divisibility only up to the square root of `n`, because a larger factor of `n` would have a corresponding smaller factor that has already been tested.\\n\\nYour `count` function also has room for optimization. This function is using the Brian Kernighan\\u2019s Algorithm to count the set bits in an integer. It\\'s generally an efficient way to count set bits, but when you know your input range, you can limit the calculations that you need to perform.\\n\\nIn your specific problem, you\\'re working with 32-bit integers. Therefore, the maximum number of set bits in a number would be 32. But, since you only have to find the count of prime set bits, and the largest prime number less than 32 is 31, you only have to check for primes numbers up to 31. This can significantly reduce the number of iterations in your `isPrime` function.\\n\\nHere\\'s an optimized version of your C++ code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isPrime(int n) {\\n        if (n <= 1) return false;\\n        if (n <= 3) return true;\\n        if (n % 2 == 0 || n % 3 == 0) return false;\\n        for (int i = 5; i * i <= n; i += 6)\\n            if (n % i == 0 || n % (i + 2) == 0)\\n                return false;\\n        return true;\\n    }\\n\\n    int countSetBits(int n) {\\n        int count = 0;\\n        while (n) {\\n            n &= (n - 1);\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    int countPrimeSetBits(int left, int right) {\\n        int count = 0;\\n        for (int i = left; i <= right; i++) {\\n            if (isPrime(countSetBits(i))) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\nThis version of the code reduces the range of numbers checked in the `isPrime` function to only up to the square root of `n`, and keeps the `countSetBits` function the same. The main function `countPrimeSetBits` remains the same. This optimized version should run faster, especially for larger input ranges."
                    },
                    {
                        "username": "wasam1119",
                        "content": "Tip: Consider the length of the binary representation of the largest acceptable value\\n "
                    },
                    {
                        "username": "Harsh_Singh23_",
                        "content": "can anyone tell me how to use isPrime() method in java? What should i import for this?"
                    },
                    {
                        "username": "Teja767",
                        "content": "there is no inbuild prime method in java(so u cant import it)\\n u need to implement prime logic yourself"
                    },
                    {
                        "username": "rntongo",
                        "content": "you have to implement it yourself. Iterate from 1 till num. Then maintain a counter to store the number of factors i.e everytime you find a number where num%i==0 increment the counter. then if the counter==2 after the loop its a prime number else its a not"
                    }
                ]
            }
        ]
    }
]