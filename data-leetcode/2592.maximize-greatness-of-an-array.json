[
    {
        "title": "Maximize Greatness of an Array",
        "question_content": "You are given a 0-indexed integer array nums. You are allowed to permute nums into a new array perm of your choosing.\nWe define the greatness of nums be the number of indices 0 <= i < nums.length for which perm[i] > nums[i].\nReturn the maximum possible greatness you can achieve after permuting nums.\n&nbsp;\nExample 1:\n\nInput: nums = [1,3,5,2,1,3,1]\nOutput: 4\nExplanation: One of the optimal rearrangements is perm = [2,5,1,3,3,1,1].\nAt indices = 0, 1, 3, and 4, perm[i] > nums[i]. Hence, we return 4.\nExample 2:\n\nInput: nums = [1,2,3,4]\nOutput: 3\nExplanation: We can prove the optimal perm is [2,3,4,1].\nAt indices = 0, 1, and 2, perm[i] > nums[i]. Hence, we return 3.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t0 <= nums[i] <= 109",
        "solutions": [
            {
                "id": 3312061,
                "title": "java-c-python-easy-and-concise-o-n",
                "content": "# **Solution 1**\\nIntuition is to compare elements, need to sort first.\\n\\nTo get as many `perm[i] > nums[i]` as possible,\\nwe will try to put smallest `A[i]` on the right.\\n\\nSo we iterate `A`, and check if it\\'s greater than `A[0]`.\\nIf `A[0]` is done, we then try `A[1]` and so on.\\n\\nSo we can start with `res = 0` and `A[res]` is the next element to compare.\\n\\nFinally return `res` directly.\\n\\n\\n# **Complexity**\\nTime `O(sort)`\\nSpace `O(sort)`\\n<br>\\n\\n**Java**\\n```java\\n    public int maximizeGreatness(int[] A) {\\n        Arrays.sort(A);\\n        int res = 0;\\n        for (int a : A)\\n            if (a > A[res])\\n                res++;\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int maximizeGreatness(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int res = 0;\\n        for (int& a : A)\\n            if (a > A[res])\\n                res++;\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def maximizeGreatness(self, A):\\n        A.sort()\\n        res = 0\\n        for a in A:\\n            if a > A[res]:\\n                res += 1\\n        return res\\n```\\n<br>\\n\\n# **Solution 2**\\nImagine `A` is sorted,\\nand we try to satify as many as possible but `k` elements.\\n\\nHow will we arrange the list?\\n\\nbefore: `A[0] A[1]   ... A[n - 1 - k]`\\nafter:  `A[k] A[1+k] ... A[n - 1]`\\n\\nwhere\\n`A[0] < A[k]`\\n`A[1] < A[1 + k]`\\n`A[2] < A[2 + k]`\\n...\\n`A[n - 1 - k] < A[n - 1]`\\n\\nThis greedy arrange is the best plan to satify as many pairs as possible.\\nNote that `k` need to be bigger than the biggest frequency of `A[i]`,\\notherwise there will be at least one `A[i] == A[i + k]`.\\n\\nSo the problem now is to find out the maximum frequency of `A`.\\n<br>\\n\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public int maximizeGreatness(int[] A) {\\n        var count = new HashMap<Integer, Integer>();\\n        int k = 0;\\n        for (int a : A)\\n            k = Math.max(k, count.merge(a, 1, Integer::sum));\\n        return A.length - k;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int maximizeGreatness(vector<int>& A) {\\n        unordered_map<int, int> count;\\n        int k = 0;\\n        for (int a : A)\\n            k = max(k, ++count[a]);\\n        return A.size() - k;\\n    }\\n```\\n\\n**Python**\\nIdea from @theabbie\\n```py\\n    def maximizeGreatness(self, A):\\n        return len(A) - max(Counter(A).values())\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int maximizeGreatness(int[] A) {\\n        Arrays.sort(A);\\n        int res = 0;\\n        for (int a : A)\\n            if (a > A[res])\\n                res++;\\n        return res;\\n    }\\n```\n```cpp\\n    int maximizeGreatness(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int res = 0;\\n        for (int& a : A)\\n            if (a > A[res])\\n                res++;\\n        return res;\\n    }\\n```\n```py\\n    def maximizeGreatness(self, A):\\n        A.sort()\\n        res = 0\\n        for a in A:\\n            if a > A[res]:\\n                res += 1\\n        return res\\n```\n```java\\n    public int maximizeGreatness(int[] A) {\\n        var count = new HashMap<Integer, Integer>();\\n        int k = 0;\\n        for (int a : A)\\n            k = Math.max(k, count.merge(a, 1, Integer::sum));\\n        return A.length - k;\\n    }\\n```\n```cpp\\n    int maximizeGreatness(vector<int>& A) {\\n        unordered_map<int, int> count;\\n        int k = 0;\\n        for (int a : A)\\n            k = max(k, ++count[a]);\\n        return A.size() - k;\\n    }\\n```\n```py\\n    def maximizeGreatness(self, A):\\n        return len(A) - max(Counter(A).values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3312240,
                "title": "explained-sort-two-pointer-very-simple-easy-to-understand-solution",
                "content": "#### Up vote if you like the solution\\n# Approach\\n1. Sort the array.\\n2. Simply iterate (i) over the array, then check for num[j] which is just larger than nums[i]. once found increament ans & increament i.\\n\\nTo understand 2nd point, lets take an example\\n\\n[1,   1,   1,   2,   3,   3,   5] \\n..i,j\\n\\n[1,   1,   1,   2,   3,   3,   5] => ans = 1;\\n. i ...........j\\n\\n[1,   1,   1,   2,   3,   3,   5] => ans = 2;\\n..... i. ..........j\\n\\n[1,   1,   1,   2,   3,   3,   5] => ans = 3;\\n ......... i . . . . . . j\\n\\n[1,   1,   1,   2,   3,   3,   5] => ans = 4;\\n . . . . . . . .i . . . . . j\\n\\n\\n\\n# Code\\n```\\n\\nint maximizeGreatness(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());\\n    int i = 0, j = 0, ans = 0;\\n    while(j < nums.size()){\\n        if(nums[j] > nums[i]) { i++; ans++; }\\n        j++;\\n    }\\n    return ans;\\n}\\n\\n```\\n\\n<b>Here is an article of my interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nint maximizeGreatness(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());\\n    int i = 0, j = 0, ans = 0;\\n    while(j < nums.size()){\\n        if(nums[j] > nums[i]) { i++; ans++; }\\n        j++;\\n    }\\n    return ans;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3312233,
                "title": "java-python-3-sort-then-2-pointers",
                "content": "Sort then start from index `0` to check how many pairs of `nums[ans] < nums[j] (num in the code)` we can have.\\n\\n```java\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans = 0;\\n        for (int num : nums) {\\n            if (nums[ans] < num) {\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n```python\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = 0\\n        for num in nums:\\n            if nums[ans] < num:\\n                ans += 1\\n        return ans\\n```\\n\\n**Analysis:**\\n\\nTime: `O(nlogn)`, space: `O(sorting space)`, where `n = nums.length`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans = 0;\\n        for (int num : nums) {\\n            if (nums[ans] < num) {\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = 0\\n        for num in nums:\\n            if nums[ans] < num:\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3312006,
                "title": "best-solution-in-c-binarysearch-sorting",
                "content": "#### Connect with me on LinkedIn : https://www.linkedin.com/in/aditya-jhunjhunwala-51b586195/\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n## Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size(),ind=0,count=0;\\n        for(int i=0;i<n;i++){\\n            auto ub=upper_bound(nums.begin()+ind+1,nums.end(),nums[i]);\\n            if(ub!=nums.end()){\\n                count++;\\n                ind=ub-nums.begin();\\n            }\\n            else\\n                break;\\n        } \\n        return count;\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/7a18ee27-13e3-41c8-825c-6ceec830ef7d_1679158054.494318.png)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size(),ind=0,count=0;\\n        for(int i=0;i<n;i++){\\n            auto ub=upper_bound(nums.begin()+ind+1,nums.end(),nums[i]);\\n            if(ub!=nums.end()){\\n                count++;\\n                ind=ub-nums.begin();\\n            }\\n            else\\n                break;\\n        } \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311994,
                "title": "two-pointer-c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n        int i=0,j=1;\\n        while(j<nums.size())\\n        {\\n            if(nums[i]==nums[j])\\n                j++;\\n            else {\\n                i++;\\n                j++;\\n            }\\n        } \\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n        int i=0,j=1;\\n        while(j<nums.size())\\n        {\\n            if(nums[i]==nums[j])\\n                j++;\\n            else {\\n                i++;\\n                j++;\\n            }\\n        } \\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311993,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length==1)\\n            return 0;\\n        int count=0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[count]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length==1)\\n            return 0;\\n        int count=0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[count]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319290,
                "title": "c-easy-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& r) {\\n        sort(r.begin(),r.end());\\n         int n=r.size();\\n        if(n==1)return 0;\\n         int i=n-1;\\n         int lg=1;\\n        int an=0;\\n        int ex=0;\\n        while(i>=1){\\n            if(r[i]==r[i-1])lg++;\\n            else{\\n                an += min(lg,ex);\\n               // cout<<min(lg,ex);\\n                ex -= min(lg,ex);\\n                ex += lg;\\n                lg=1;\\n            }\\n            i--;\\n        }\\n        if(r[0]!=r[1]){\\n            if(ex)an++;\\n        }\\n        else {\\n             an += min(lg,ex);\\n              //  cout<<min(lg,ex);\\n                ex -= min(lg,ex);\\n                ex += lg;\\n        }\\n       // cout<<endl;\\n            return an;\\n        \\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/3b9ca2f2-ba97-4bc6-a9bb-56388e10974c_1679303223.2098072.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& r) {\\n        sort(r.begin(),r.end());\\n         int n=r.size();\\n        if(n==1)return 0;\\n         int i=n-1;\\n         int lg=1;\\n        int an=0;\\n        int ex=0;\\n        while(i>=1){\\n            if(r[i]==r[i-1])lg++;\\n            else{\\n                an += min(lg,ex);\\n               // cout<<min(lg,ex);\\n                ex -= min(lg,ex);\\n                ex += lg;\\n                lg=1;\\n            }\\n            i--;\\n        }\\n        if(r[0]!=r[1]){\\n            if(ex)an++;\\n        }\\n        else {\\n             an += min(lg,ex);\\n              //  cout<<min(lg,ex);\\n                ex -= min(lg,ex);\\n                ex += lg;\\n        }\\n       // cout<<endl;\\n            return an;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3312270,
                "title": "sorting-binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int n = nums.size(), ans = 0, last = 0;\\n        sort(nums.begin(), nums.end());\\n\\n        for(int i=0; i<n; i++) {\\n            int idx = lower_bound(nums.begin() + last + 1, nums.end(), nums[i] + 1) - nums.begin();\\n            if(idx < n) {\\n                last = idx;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int n = nums.size(), ans = 0, last = 0;\\n        sort(nums.begin(), nums.end());\\n\\n        for(int i=0; i<n; i++) {\\n            int idx = lower_bound(nums.begin() + last + 1, nums.end(), nums[i] + 1) - nums.begin();\\n            if(idx < n) {\\n                last = idx;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312039,
                "title": "two-pointers",
                "content": "**C++**\\n```cpp    \\nint maximizeGreatness(vector<int>& nums) {\\n    int i = 0, sz = nums.size();\\n    sort(begin(nums), end(nums));\\n    for (int j = 0; j < sz; i += (j++) < sz)\\n        while (j < sz && nums[j] <= nums[i])\\n            ++j;\\n    return i;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp    \\nint maximizeGreatness(vector<int>& nums) {\\n    int i = 0, sz = nums.size();\\n    sort(begin(nums), end(nums));\\n    for (int j = 0; j < sz; i += (j++) < sz)\\n        while (j < sz && nums[j] <= nums[i])\\n            ++j;\\n    return i;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3312707,
                "title": "easy-c-sorting-two-poiner-based-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this question i observed the ans can be maximum as nums.size()-1 when all elements are unique.We can check this in sorted array from index n-2 till 0,where n is size of nums.size().\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the array,intialise ans as 1 , and a pointer ind as n-1.\\n2. Traverse the array from n-2 to 0. Check if(nums[i]<nums[ind]) if its true then decrement the ind by 1 and increase the ans by 1.\\n3. Return the ans.\\n# Complexity\\n- Time complexity:N*log(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int ans=0;\\n        int ind=n-1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<nums[ind])\\n            {\\n                ind--;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int ans=0;\\n        int ind=n-1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<nums[ind])\\n            {\\n                ind--;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312391,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans=0\\n        for num in nums:\\n            if num>nums[ans]:\\n                ans+=1\\n\\n        return ans        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans=0\\n        for num in nums:\\n            if num>nums[ans]:\\n                ans+=1\\n\\n        return ans        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312167,
                "title": "sorting-python3-easiest-solution",
                "content": "\\n```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int: \\n        nums.sort() \\n        count = 0\\n        j = i = 0  \\n        while j < len(nums):\\n            if nums[i] < nums[j]:\\n                count+=1 \\n                i+=1\\n            j+=1 \\n        return count\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int: \\n        nums.sort() \\n        count = 0\\n        j = i = 0  \\n        while j < len(nums):\\n            if nums[i] < nums[j]:\\n                count+=1 \\n                i+=1\\n            j+=1 \\n        return count\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312153,
                "title": "c-two-pointers-efficient-approach",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int maximizeGreatness(vector<int>& nums) \\n    {\\n        sort(nums.begin(), nums.end());\\n        \\n        int i=0, j=0, n=nums.size(), cnt=0;\\n        while(j<n)\\n        {\\n            if(nums[i] >= nums[j]) j++;\\n            else if(nums[i] < nums[j])\\n            {\\n                cnt++;\\n                i++;\\n                j++;\\n            }\\n        } \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maximizeGreatness(vector<int>& nums) \\n    {\\n        sort(nums.begin(), nums.end());\\n        \\n        int i=0, j=0, n=nums.size(), cnt=0;\\n        while(j<n)\\n        {\\n            if(nums[i] >= nums[j]) j++;\\n            else if(nums[i] < nums[j])\\n            {\\n                cnt++;\\n                i++;\\n                j++;\\n            }\\n        } \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312055,
                "title": "2-pointer-approach",
                "content": "### Space Complexity : O(1)\\n### Time Complexity : O(n logn)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) \\n    {\\n        // arrnge the values in asscending order\\n        sort(nums.begin(),nums.end());\\n        \\n        int st=0;\\n        int en=1;\\n        int cnt=0;\\n        \\n        while(en < nums.size())\\n        {\\n            // finding next greater\\n            while(en < nums.size() && nums[en] <= nums[st])\\n            {\\n                en++;\\n            }\\n            \\n            if(en==nums.size()) break;\\n            \\n            st++;\\n            en++;\\n            cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) \\n    {\\n        // arrnge the values in asscending order\\n        sort(nums.begin(),nums.end());\\n        \\n        int st=0;\\n        int en=1;\\n        int cnt=0;\\n        \\n        while(en < nums.size())\\n        {\\n            // finding next greater\\n            while(en < nums.size() && nums[en] <= nums[st])\\n            {\\n                en++;\\n            }\\n            \\n            if(en==nums.size()) break;\\n            \\n            st++;\\n            en++;\\n            cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311978,
                "title": "simple-java-solution-using-two-pointer",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n log n)$$ \\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int left=0,right=1,count=0;\\n        while(right<nums.length)\\n        {\\n            if(nums[left]<nums[right])\\n            {\\n                left++;\\n                right++;\\n                count++;\\n            }\\n            else\\n            {\\n                right++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int left=0,right=1,count=0;\\n        while(right<nums.length)\\n        {\\n            if(nums[left]<nums[right])\\n            {\\n                left++;\\n                right++;\\n                count++;\\n            }\\n            else\\n            {\\n                right++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541634,
                "title": "using-sort-heap-easy-to-understand-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int ans = 0;\\n        sort(nums.begin(),nums.end());\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        for(auto &i: nums){\\n            pq.push(i);\\n        }\\n        for(auto &i: nums){\\n            while(!pq.empty() && i>=pq.top()){\\n                pq.pop();\\n            }\\n            if(pq.empty())return ans;\\n            pq.pop();\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int ans = 0;\\n        sort(nums.begin(),nums.end());\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        for(auto &i: nums){\\n            pq.push(i);\\n        }\\n        for(auto &i: nums){\\n            while(!pq.empty() && i>=pq.top()){\\n                pq.pop();\\n            }\\n            if(pq.empty())return ans;\\n            pq.pop();\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333896,
                "title": "sort-2-pointers",
                "content": "# Intuition\\nSort the array and find every possible higher element for each element.\\n\\n# Approach\\nSort the array. Create two  pointers. For every possible element find higher one.\\n\\n# Complexity\\n- Time complexity:\\nO(N*Log(N))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maximizeGreatness = function(nums) {\\n    nums.sort((a,b) => a - b)\\n    let res = 0;\\n    let j = 1;\\n    for(let i = 0; i < nums.length; i++){\\n        while(j < nums.length && nums[j] <= nums[i]){\\n            j++;\\n        }\\n        if(j < nums.length && nums[j] > nums[i]){\\n            j++;\\n            res++;\\n        }\\n    }\\n    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maximizeGreatness = function(nums) {\\n    nums.sort((a,b) => a - b)\\n    let res = 0;\\n    let j = 1;\\n    for(let i = 0; i < nums.length; i++){\\n        while(j < nums.length && nums[j] <= nums[i]){\\n            j++;\\n        }\\n        if(j < nums.length && nums[j] > nums[i]){\\n            j++;\\n            res++;\\n        }\\n    }\\n    \\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3332108,
                "title": "one-line-solution-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n> It is a solution of my friend Ruslans (@ruslans_al), which was refined by me slightly.\\n\\nLet\\'s consider subsets of array `nums`: $$A_1,...,A_k$$, each of them does not contain repeating integers. For each $$A_j$$ answer is a $$|A_j|-1$$. Therefore, the answer for the overall array `nums` is a $$\\\\sum\\\\limits_j (|A_j|-1)=n-k$$, where $$n$$ is the length of `nums` and $$k$$ is the number of subsets $A_j$ in `nums`. On the other hand, $$k$$ is equal to the number of occurrences of the most frequent integer in the array `nums`.\\n\\n\\n \\n---\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSee the one-line code snippet below.\\n---\\n---\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n---\\n# Code\\n```python []\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        return len(nums) - max(Counter(nums).values())  \\n```\\n---\\n```\\nIf you like this solution, upvote please\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```python []\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        return len(nums) - max(Counter(nums).values())  \\n```\n```\\nIf you like this solution, upvote please\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316622,
                "title": "two-possible-solution-easy-to-understand-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn two pointer approach we keep track of exactly how many numbers have a number bigger(strictly) than it in the same array.\\nUSing Multiset also same concept.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple two pointer approach and multiset Approach\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//using two pointer approach--->O(nlogn)\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int n= nums.size();\\n        sort(nums.begin(),nums.end());\\n        int cnt=0;\\n        int i=0,j=1;\\n        while(j<n)\\n        {\\n            if(nums[i]<nums[j])\\n            {\\n                cnt++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n\\n// using multiset approach--->O(nlogn)\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        multiset<int> s;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++)\\n            s.insert(nums[i]);\\n        int cnt=0,i=0;\\n        while(s.size()>0 && i<nums.size())\\n        {\\n            auto i1=s.find(nums[i]);\\n            if(i1!=s.end())\\n             s.erase(i1);\\n            auto i2=s.upper_bound(nums[i]);\\n            if(i2!=s.end())\\n            {\\n                cnt++;\\n                s.erase(i2);\\n                i++;\\n            }\\n            else\\n                 break;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\n//using two pointer approach--->O(nlogn)\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int n= nums.size();\\n        sort(nums.begin(),nums.end());\\n        int cnt=0;\\n        int i=0,j=1;\\n        while(j<n)\\n        {\\n            if(nums[i]<nums[j])\\n            {\\n                cnt++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n\\n// using multiset approach--->O(nlogn)\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        multiset<int> s;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++)\\n            s.insert(nums[i]);\\n        int cnt=0,i=0;\\n        while(s.size()>0 && i<nums.size())\\n        {\\n            auto i1=s.find(nums[i]);\\n            if(i1!=s.end())\\n             s.erase(i1);\\n            auto i2=s.upper_bound(nums[i]);\\n            if(i2!=s.end())\\n            {\\n                cnt++;\\n                s.erase(i2);\\n                i++;\\n            }\\n            else\\n                 break;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315153,
                "title": "c-solution-easy-simple-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis can be easily done by sorting and two pointer approach\\n1. Firstly, sort the vector. \\n2. Then initialize two pointers:\\n   one points to the current element and start moving forward with\\n   another pointer till we find the greater element from the current\\n   element.\\n3. If we find greater element increant count and move both the pointers forward. \\n# Complexity\\n- Time complexity: O(N*log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int cnt = 0, i = 0, j = 0;\\n        while(i < nums.size() && j < nums.size()){\\n            if (nums[i] == nums[j]){\\n                while(j < nums.size() && nums[i] == nums[j])\\n                j++;\\n                if (j < nums.size())\\n                cnt++;\\n            }\\n            else cnt++;\\n            i++;j++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int cnt = 0, i = 0, j = 0;\\n        while(i < nums.size() && j < nums.size()){\\n            if (nums[i] == nums[j]){\\n                while(j < nums.size() && nums[i] == nums[j])\\n                j++;\\n                if (j < nums.size())\\n                cnt++;\\n            }\\n            else cnt++;\\n            i++;j++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312450,
                "title": "c-solution-3-method-to-solve-easy-and-concise",
                "content": "# Solution 1 - Easy Solution Using Map\\n\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int maxi=INT_MIN;\\n        int n=nums.size();\\n        map<int,int>m;\\n        for(int i=0;i<n;i++){\\n            m[nums[i]]++;\\n            maxi=max(maxi,m[nums[i]]);\\n        }\\n        return nums.size()-maxi;\\n    }\\n};\\n```\\n\\n---\\n\\n# Solution 2 - By Iteration\\n\\n```\\n  int maximizeGreatness(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int res = 0;\\n        for (int& a : A)\\n            if (a > A[res])\\n                res++;\\n        return res;\\n    }\\n```\\n\\n---\\n\\n\\n\\n# Solution 3 - Simple Solution\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int count = 0;\\n        int i = 0;\\n        int j = 1;\\n        int last = n-1;\\n        while(j<=last)\\n        {\\n            if(nums[i]<nums[j])\\n            {\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n![24f080eb-397a-4a09-a9f5-6a9a315c955f_1675822350.8603303.png](https://assets.leetcode.com/users/images/0b3d4300-2e0d-49be-8edd-6e71a9d2b7a1_1679157326.0122333.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sort",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int maxi=INT_MIN;\\n        int n=nums.size();\\n        map<int,int>m;\\n        for(int i=0;i<n;i++){\\n            m[nums[i]]++;\\n            maxi=max(maxi,m[nums[i]]);\\n        }\\n        return nums.size()-maxi;\\n    }\\n};\\n```\n```\\n  int maximizeGreatness(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int res = 0;\\n        for (int& a : A)\\n            if (a > A[res])\\n                res++;\\n        return res;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int count = 0;\\n        int i = 0;\\n        int j = 1;\\n        int last = n-1;\\n        while(j<=last)\\n        {\\n            if(nums[i]<nums[j])\\n            {\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312009,
                "title": "short-clean-priority-queue-java",
                "content": "\\n```java []\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        PriorityQueue<Integer> pq1 = new PriorityQueue();\\n        PriorityQueue<Integer> pq2 = new PriorityQueue();\\n        for(int i: nums){\\n            pq1.add(i);\\n            pq2.add(i);\\n        }\\n        int count = 0;\\n        while(!pq2.isEmpty()){\\n            if(pq1.peek() < pq2.peek()){\\n                pq1.poll();\\n                count++;\\n            }\\n            pq2.poll();\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        PriorityQueue<Integer> pq1 = new PriorityQueue();\\n        PriorityQueue<Integer> pq2 = new PriorityQueue();\\n        for(int i: nums){\\n            pq1.add(i);\\n            pq2.add(i);\\n        }\\n        int count = 0;\\n        while(!pq2.isEmpty()){\\n            if(pq1.peek() < pq2.peek()){\\n                pq1.poll();\\n                count++;\\n            }\\n            pq2.poll();\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311984,
                "title": "c-sort-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int i=0,n=nums.size(),ans=0;\\n    \\n        for(int k=1;k<n;k++){\\n            if(nums[i] < nums[k]){\\n                ans++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int i=0,n=nums.size(),ans=0;\\n    \\n        for(int k=1;k<n;k++){\\n            if(nums[i] < nums[k]){\\n                ans++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465147,
                "title": "two-pointer-brute-force-tle-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n## Two pointer approach!!\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count=0;\\n        int i=0;\\n        int j=0;\\n        while(j<nums.size())\\n        {\\n            if(nums[i] >= nums[j]) j++;\\n            else if(nums[i] < nums[j]){\\n                count++;\\n                i++;\\n                j++;\\n            }\\n        } \\n        return count;\\n    }\\n};\\n\\n#Brute force(TLE)\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i;j<nums.size();j++){\\n                if(nums[j]>0){\\n                if(nums[j]>abs(nums[i])){\\n                    count++;\\n                    nums[j]=-nums[j];\\n                    break;\\n                }\\n             }\\n          }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count=0;\\n        int i=0;\\n        int j=0;\\n        while(j<nums.size())\\n        {\\n            if(nums[i] >= nums[j]) j++;\\n            else if(nums[i] < nums[j]){\\n                count++;\\n                i++;\\n                j++;\\n            }\\n        } \\n        return count;\\n    }\\n};\\n\\n#Brute force(TLE)\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i;j<nums.size();j++){\\n                if(nums[j]>0){\\n                if(nums[j]>abs(nums[i])){\\n                    count++;\\n                    nums[j]=-nums[j];\\n                    break;\\n                }\\n             }\\n          }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354150,
                "title": "day-363-100-explained-java-c-python-one-pass-o-1-one-liner",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/5385f779-f8cc-4da1-a906-5e08f0066dc4_1680067386.260693.png)\\n\\n# Intuition Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n##### \\u2022\\tThe intuition behind this approach is that we want to maximize the number of indices i for which perm[i] > nums[i] . To do this, we can sort the input array nums in non-decreasing order, and then create a new array perm such that perm[i] is the i -th largest element of nums . \\n##### \\u2022\\tThis will ensure that the largest elements of nums are moved to the beginning of perm , and hence increase the number of indices i for which perm[i] > nums[i] . \\n##### \\u2022\\tHowever, we don\\'t actually need to create a new array perm to compute the maximum possible greatness. Instead, we can simply loop over the elements of nums and keep track of the greatest element seen so far. \\n##### \\u2022\\tIf the current element is greater than the greatest element seen so far, we can increment the number of indices i for which perm[i] > nums[i] . \\n##### \\u2022\\tHere\\'s the step-by-step approach: \\n##### \\u2022\\tSort the input array nums in non-decreasing order using the sort function from the library. \\n##### \\u2022\\tInitialize a variable greatness to 0, which represents the maximum possible greatness. Loop over the elements of nums using a range-based for loop. \\n##### \\u2022\\tFor each element it , check if it > nums[greatness] . If this condition is true, increment greatness by 1, since we can move the element it to index greatness in the permutation to increase the number of indices i for which perm[i] > nums[i] . \\n##### \\u2022\\tReturn the value of greatness , which represents the maximum possible greatness. \\n\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n    sort(nums.begin(), nums.end()); // Sort nums in non-decreasing order\\n    int greatness = 0;\\n    for (auto &it : nums) { // Loop over the elements of nums\\n        if (it > nums[greatness]) { // If the current element is greater than the greatest element seen so far\\n            greatness++; // Increment the number of indices i for which perm[i] > nums[i]\\n        }\\n    }\\n    return greatness; // Return the maximum possible greatness\\n}\\n};\\nstatic bool     _foo = ios::sync_with_stdio(false);\\nstatic ostream* _bar = cin.tie(NULL);\\n```\\n```java []\\npublic int maximizeGreatness(int[] nums) {\\n    Arrays.sort(nums); // Sort nums in non-decreasing order\\n    int greatness = 0;\\n    for (int i = 0; i < nums.length; i++) { // Loop over the elements of nums\\n        if (nums[i] > nums[greatness]) { // If the current element is greater than the greatest element seen so far\\n            greatness++; // Increment the number of indices i for which perm[i] > nums[i]\\n        }\\n    }\\n    return greatness; // Return the maximum possible greatness\\n}\\n```\\n```python []\\ndef maximizeGreatness(nums: List[int]) -> int:\\n    nums.sort() # Sort nums in non-decreasing order\\n    greatness = 0\\n    for i in range(len(nums)): # Loop over the elements of nums\\n        if nums[i] > nums[greatness]: # If the current element is greater than the greatest element seen so far\\n            greatness += 1 # Increment the number of indices i for which perm[i] > nums[i]\\n    return greatness # Return the maximum possible greatness\\n```\\n\\n\\n# Complexity\\n\\n##### \\u2022\\tThe time complexity of this approach is O(n log n), where n is the length of the input array nums , due to the sorting step. \\n##### \\u2022\\tThe space complexity is O(1), since we only need to store a few integer variables.\\n\\n# 2ND WAY ONE LINER  TC = O(N) SC = O(1)\\n\\nMY POST LINK https://leetcode.com/problems/maximize-greatness-of-an-array/solutions/3354150/day-363-100-explained-java-c-python-one-pass-o-1-one-liner/\\n\\n```PYTHON []\\n def maximizeGreatness(nums: List[int]) -> int:\\n        return len(nums) - max(Counter(nums).values())\\n```\\n```JAVA []\\n public int maximizeGreatness(int[] nums) {\\n    return nums.length - Collections.max(Arrays.stream(nums).boxed().collect(Collectors.groupingBy(Function.identity(), Collectors.counting())).values()).intValue();\\n}\\n```\\n```C++ []\\n   int maximizeGreatness(vector<int>& nums) {\\n    std::unordered_map<int, int> freq;\\n    for (int x : nums) freq[x]++;\\n    return nums.size() - std::max_element(freq.begin(), freq.end(), [](const auto& a, const auto& b) { return a.second < b.second; })->second;\\n}\\n```\\n# DRY RUN \\n```\\nnums = [1,3,5,2,1,3,1]\\nnums.sort() # nums = [1,1,1,2,3,3,5]\\ncounter = Counter(nums) # counter = {1: 3, 3: 2, 5: 1, 2: 1}\\nmaxCount = max(counter.values()) # maxCount = 3\\nreturn len(nums) - maxCount # return 7 - 3 = 4\\n```\\n\\n##### \\u2022\\tThe first line, static bool _foo = ios::sync_with_stdio(false); , disables the synchronization between the C++ standard streams (e.g., cin , cout , cerr , etc.) and the C standard streams (e.g., stdin , stdout , stderr , etc.). \\n##### \\u2022\\tBy default, these streams are synchronized, which means that input/output operations on one stream may cause the other stream to flush its buffer. This can be slow, especially when dealing with large amounts of input/output data. \\n##### \\u2022\\tDisabling the synchronization can improve the performance of input/output operations, but it may also cause some unexpected behavior if the streams are used in a mixed manner (i.e., both C++ and C-style input/output operations are used). \\n##### \\u2022\\tThe second line, static ostream* _bar = cin.tie(NULL); , unties the cin stream from the cout stream. By default, the cin stream is tied to the cout stream, which means that the cout stream is flushed before any input is read from the cin stream. \\n##### \\u2022\\tThis can also be slow, especially when dealing with large amounts of input/output data. Untying the streams can improve the performance of input/output operations, but it may also cause some unexpected behavior if the streams are used in a mixed manner. \\n##### \\u2022\\tNote that these lines of code are not necessary in most cases, and may even cause some unexpected behavior if used incorrectly. They are typically used in performance-critical applications where input/output operations are a bottleneck, and where the behavior of the standard streams can be carefully controlled.\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/a387cd36-9f55-470e-aa7c-a89af19fe7bb_1680030050.9267182.webp)\\n![meme2.png](https://assets.leetcode.com/users/images/145cb6b9-c58f-4218-93bb-9845b4793151_1680030060.7843618.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n    sort(nums.begin(), nums.end()); // Sort nums in non-decreasing order\\n    int greatness = 0;\\n    for (auto &it : nums) { // Loop over the elements of nums\\n        if (it > nums[greatness]) { // If the current element is greater than the greatest element seen so far\\n            greatness++; // Increment the number of indices i for which perm[i] > nums[i]\\n        }\\n    }\\n    return greatness; // Return the maximum possible greatness\\n}\\n};\\nstatic bool     _foo = ios::sync_with_stdio(false);\\nstatic ostream* _bar = cin.tie(NULL);\\n```\n```java []\\npublic int maximizeGreatness(int[] nums) {\\n    Arrays.sort(nums); // Sort nums in non-decreasing order\\n    int greatness = 0;\\n    for (int i = 0; i < nums.length; i++) { // Loop over the elements of nums\\n        if (nums[i] > nums[greatness]) { // If the current element is greater than the greatest element seen so far\\n            greatness++; // Increment the number of indices i for which perm[i] > nums[i]\\n        }\\n    }\\n    return greatness; // Return the maximum possible greatness\\n}\\n```\n```python []\\ndef maximizeGreatness(nums: List[int]) -> int:\\n    nums.sort() # Sort nums in non-decreasing order\\n    greatness = 0\\n    for i in range(len(nums)): # Loop over the elements of nums\\n        if nums[i] > nums[greatness]: # If the current element is greater than the greatest element seen so far\\n            greatness += 1 # Increment the number of indices i for which perm[i] > nums[i]\\n    return greatness # Return the maximum possible greatness\\n```\n```PYTHON []\\n def maximizeGreatness(nums: List[int]) -> int:\\n        return len(nums) - max(Counter(nums).values())\\n```\n```JAVA []\\n public int maximizeGreatness(int[] nums) {\\n    return nums.length - Collections.max(Arrays.stream(nums).boxed().collect(Collectors.groupingBy(Function.identity(), Collectors.counting())).values()).intValue();\\n}\\n```\n```C++ []\\n   int maximizeGreatness(vector<int>& nums) {\\n    std::unordered_map<int, int> freq;\\n    for (int x : nums) freq[x]++;\\n    return nums.size() - std::max_element(freq.begin(), freq.end(), [](const auto& a, const auto& b) { return a.second < b.second; })->second;\\n}\\n```\n```\\nnums = [1,3,5,2,1,3,1]\\nnums.sort() # nums = [1,1,1,2,3,3,5]\\ncounter = Counter(nums) # counter = {1: 3, 3: 2, 5: 1, 2: 1}\\nmaxCount = max(counter.values()) # maxCount = 3\\nreturn len(nums) - maxCount # return 7 - 3 = 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316436,
                "title": "c-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        priority_queue<int> pq;\\n        for(auto x:nums){\\n            pq.push(x);\\n        }\\n        sort(nums.rbegin(),nums.rend());\\n        int res=0;\\n        for(auto x:nums){\\n            if(pq.top()>x){\\n                pq.pop();\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        priority_queue<int> pq;\\n        for(auto x:nums){\\n            pq.push(x);\\n        }\\n        sort(nums.rbegin(),nums.rend());\\n        int res=0;\\n        for(auto x:nums){\\n            if(pq.top()>x){\\n                pq.pop();\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314326,
                "title": "sort-two-pointers-short-sweet-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int ans = 0;\\n        int i = 0, j = 0, n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        while(i<n&&j<n){\\n            while(j<n&&nums[j]<=nums[i]){\\n                j++;\\n            }\\n            i++;\\n            if(j==n)break;\\n            j++;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int ans = 0;\\n        int i = 0, j = 0, n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        while(i<n&&j<n){\\n            while(j<n&&nums[j]<=nums[i]){\\n                j++;\\n            }\\n            i++;\\n            if(j==n)break;\\n            j++;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 3313379,
                "title": "java-sorting-two-pointers",
                "content": "# Intuition:\\nPlace the next greater number in place of the current number.\\n\\n---\\n# Solution:\\n```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans = 0;\\n        for (int i = 0, j = 1; j < nums.length; j++) {\\n            if (nums[i] < nums[j]) {\\n                ans++; i++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n---\\n*You can check out my video explanation (Channel link in profile bio).*\\n\\n---\\n##### Time complexity: $$O(n.logn)$$\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans = 0;\\n        for (int i = 0, j = 1; j < nums.length; j++) {\\n            if (nums[i] < nums[j]) {\\n                ans++; i++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312339,
                "title": "map-easy-approch",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe Solution is size of array -max frquency\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int maxi=INT_MIN;\\n        int n=nums.size();\\n        map<int,int>m;\\n        for(int i=0;i<n;i++){\\n            m[nums[i]]++;\\n            maxi=max(maxi,m[nums[i]]);\\n        }\\n        return nums.size()-maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int maxi=INT_MIN;\\n        int n=nums.size();\\n        map<int,int>m;\\n        for(int i=0;i<n;i++){\\n            m[nums[i]]++;\\n            maxi=max(maxi,m[nums[i]]);\\n        }\\n        return nums.size()-maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797998,
                "title": "o-nlogn-solution-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int n=nums.size();\\n        int ans=0;\\n\\n        for(int k=i+1;k<n;k++){\\n            if(nums[i]<nums[k]){\\n                ans++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int n=nums.size();\\n        int ans=0;\\n\\n        for(int k=i+1;k<n;k++){\\n            if(nums[i]<nums[k]){\\n                ans++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699987,
                "title": "easy-sorting-greedy",
                "content": "# if it Helps You. Please Upvote Me...\\uD83E\\uDDE1\\uD83E\\uDD0D\\uD83D\\uDC9A\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is very Simple, firstly  **sort the array** after that **count the pair of arr[i] and just greater of arr[i]**.\\n# Complexity\\n- Time complexity:O(N * Long(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& arr) {\\n        int n = arr.size(),ans = 0;\\n        sort(arr.begin(),arr.end());\\n        if(n<=1) return 0;\\n\\n        int i = 0,j = 0;\\n        while(i<n && j<n)\\n        {\\n           while(j<n && arr[j]==arr[i])\\n           j++;\\n           if(i<n && j<n && arr[i]<arr[j])\\n           {\\n               ans++;\\n               j++;\\n               i++;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/66bb2d25-340c-4f24-ab45-ec17eec995e5_1688119301.996845.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& arr) {\\n        int n = arr.size(),ans = 0;\\n        sort(arr.begin(),arr.end());\\n        if(n<=1) return 0;\\n\\n        int i = 0,j = 0;\\n        while(i<n && j<n)\\n        {\\n           while(j<n && arr[j]==arr[i])\\n           j++;\\n           if(i<n && j<n && arr[i]<arr[j])\\n           {\\n               ans++;\\n               j++;\\n               i++;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542521,
                "title": "2592-maximize-greatness-of-an-array-java",
                "content": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans=0;\\n        for(int i=0,j=1;j<nums.length;j++)\\n        {\\n             if(nums[i]<nums[j])\\n             {\\n                 ans++;\\n                 i++;\\n             }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans=0;\\n        for(int i=0,j=1;j<nums.length;j++)\\n        {\\n             if(nums[i]<nums[j])\\n             {\\n                 ans++;\\n                 i++;\\n             }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488372,
                "title": "simplest-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) \\n    {\\n        int res = 0 ;\\n        sort(nums.begin(),nums.end());\\n        int i  = 0 , j = 0; \\n        while(i<nums.size() && j<nums.size())\\n        {\\n             while( i<nums.size() && j<nums.size() &&nums[i]>nums[j] )\\n             {\\n                 j++; \\n                 i++;\\n             }\\n               if( i<nums.size() && j<nums.size() && nums[i]<=nums[j])\\n               i++;\\n        } \\n\\n        return  j;; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) \\n    {\\n        int res = 0 ;\\n        sort(nums.begin(),nums.end());\\n        int i  = 0 , j = 0; \\n        while(i<nums.size() && j<nums.size())\\n        {\\n             while( i<nums.size() && j<nums.size() &&nums[i]>nums[j] )\\n             {\\n                 j++; \\n                 i++;\\n             }\\n               if( i<nums.size() && j<nums.size() && nums[i]<=nums[j])\\n               i++;\\n        } \\n\\n        return  j;; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400384,
                "title": "c-two-pointers",
                "content": "## Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int cnt=0;\\n        int i=0;\\n        for (int select=1; select<nums.size(); select++){\\n            if (nums[i]<nums[select]){\\n                i++; cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int cnt=0;\\n        int i=0;\\n        for (int select=1; select<nums.size(); select++){\\n            if (nums[i]<nums[select]){\\n                i++; cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347813,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=1;\\n        while(j < nums.size()){\\n            if(nums[j] > nums[i])\\n                i++;\\n            j++;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=1;\\n        while(j < nums.size()){\\n            if(nums[j] > nums[i])\\n                i++;\\n            j++;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325461,
                "title": "simple-two-pointers-easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) \\n    {\\n         sort(nums.begin(),nums.end());\\n         int start = 0;\\n         int end   = 0;\\n\\n         int count = 0;\\n         while(end < (nums.size()))\\n         {\\n             while(end < nums.size() and nums[end] <= nums[start])\\n             {\\n                 end++;\\n             }\\n             if(end < nums.size())\\n             {\\n                 count++;\\n                 start++;\\n                 end++;\\n             }\\n         }\\n         return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) \\n    {\\n         sort(nums.begin(),nums.end());\\n         int start = 0;\\n         int end   = 0;\\n\\n         int count = 0;\\n         while(end < (nums.size()))\\n         {\\n             while(end < nums.size() and nums[end] <= nums[start])\\n             {\\n                 end++;\\n             }\\n             if(end < nums.size())\\n             {\\n                 count++;\\n                 start++;\\n                 end++;\\n             }\\n         }\\n         return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314679,
                "title": "c-multiset-faster-easy-to-understand",
                "content": "* ***Using Multiset***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // declare a multi set\\n        \\n        multiset<int> s;\\n        \\n        // push all the elements into multiset\\n        \\n        for(auto x : nums)\\n        {\\n            s.insert(x);\\n        }\\n        \\n        int count = 0;\\n        \\n        // traverse over the nums\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // find the upper bound of the nums[i]\\n            \\n            auto it = s.upper_bound(nums[i]);\\n            \\n            // if upper bound exist then increment count and erase that number\\n            \\n            if(it != s.end())\\n            {\\n                count++;\\n                \\n                s.erase(it);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // declare a multi set\\n        \\n        multiset<int> s;\\n        \\n        // push all the elements into multiset\\n        \\n        for(auto x : nums)\\n        {\\n            s.insert(x);\\n        }\\n        \\n        int count = 0;\\n        \\n        // traverse over the nums\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // find the upper bound of the nums[i]\\n            \\n            auto it = s.upper_bound(nums[i]);\\n            \\n            // if upper bound exist then increment count and erase that number\\n            \\n            if(it != s.end())\\n            {\\n                count++;\\n                \\n                s.erase(it);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313053,
                "title": "100-time-and-space-c-simple-sol-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we will use the priority queue to store the smallest numbers in the order and will increment the counter as soon as we get the number greater than it and pop the element from the queue simultanousely.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count = 0;\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(int i=0;i<nums.size();i++){\\n            if(!pq.empty()){\\n                if(nums[i] > pq.top()){\\n                    count++;\\n                    pq.pop();\\n                }\\n            }\\n            pq.push(nums[i]);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count = 0;\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(int i=0;i<nums.size();i++){\\n            if(!pq.empty()){\\n                if(nums[i] > pq.top()){\\n                    count++;\\n                    pq.pop();\\n                }\\n            }\\n            pq.push(nums[i]);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312968,
                "title": "python-elegant-short-sorting-two-pointers",
                "content": "```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i = 0\\n\\n        for num in nums:\\n            if nums[i] < num:\\n                i += 1\\n\\n        return i\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i = 0\\n\\n        for num in nums:\\n            if nums[i] < num:\\n                i += 1\\n\\n        return i\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312562,
                "title": "greedy-count-duplicates-sorting",
                "content": "# Intuition\\nThe test case : $$[1,2,3,4]$$ gives an idea to solve this problem. It\\'s answer is $$3$$, or something to do with **the sorted array** arrangement. If the array had no duplicate elements, the answer would always be= **the number of elements -1** .Simple logic being, the greatest number[$$4$$ in the above array considered] in the array cannot be matched with any number, but everybody else can be. That is how we arrive to our answer.\\n\\n# Approach\\nConsider the arrays: \\n-$$[1,1,1,1,1,2,3,4]$$\\nThe answer is $$3$$. The addition of additional $$1s$$ does not affect our answer, as we can match each $$1$$ with a $$1$$\\n\\n---\\n\\n\\nConsider the array in test case 1 in sorted order:\\n$$[1,1,1,2,3,3,5]$$ and notice that it has the same arrangement:\\n$$[3,3,5]$$, which has an answer of $$2$$. The benefit in this case is though, we get an additional $$3$$ that we can match with one of the $$1$$ in the array. That is how the presence of duplicates will give us a greater answer than just the number of distinct elements in the array. \\n\\nIf we **sort** the array, we will always have this subproblem: \\n$$[x,x,x,x,x,x+1,]$$ \\n# It is akin to an array of $$[x,x+1]$$, we just get spare elements(x) that we can use to match with duplicates of numbers smaller than x\\n\\nOr if you **keep a count of numbers** that are greater than $$x$$, you can tabulate your result. \\n\\n# Complexity\\n- Time complexity:\\n$$O(n log n)$$\\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```Java []\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        int ans=0;\\n        int rem=0; //Numbers greater than the current number\\n        int curem=0; //Numbers equal to the current number\\n        int comp= nums[n-1]; //The last greatest number we have encountered so far\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]<comp){ //[3,4] we are checking 3 here\\n                comp=nums[i]; //found a new guy\\n                rem+=curem;  //include the number of 3s in our\\n                            //numbers greater than nums[i] counter\\n                curem=0;  //Reset the count of numbers same as nums[i]\\n                ans++;\\n            }\\n            else if(nums[i]==nums[i+1]) {  \\n                if(rem>0){ //if there is a spare number above, incrememnt sum \\n                    rem--;\\n                    ans++;\\n                }\\n                curem++; //this number cannot be paired, but we can use it later\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n=nums.size();\\n        int ans=0;\\n        int rem=0; //Numbers greater than the current number\\n        int curem=0; //Numbers equal to the current number\\n        int comp= nums[n-1]; //The last greatest number we have encountered so far\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]<comp){ //[3,4] we are checking 3 here\\n                comp=nums[i]; //found a new guy\\n                rem+=curem;  //include the number of 3s in our\\n                            //numbers greater than nums[i] counter\\n                curem=0;  //Reset the count of numbers same as nums[i]\\n                ans++;\\n            }\\n            else if(nums[i]==nums[i+1]) {  \\n                if(rem>0){ //if there is a spare number above, incrememnt sum \\n                    rem--;\\n                    ans++;\\n                }\\n                curem++; //this number cannot be paired, but we can use it later\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n=len(nums)\\n        ans=0\\n        rem=0 #Numbers greater than the current number\\n        curem=0 #Numbers equal to the current number\\n        comp= nums[n-1] #The last greatest number we have encountered so far\\n        for i in range(n-2,-1,-1):\\n            if(nums[i]<comp): #[3,4] we are checking 3 here\\n                comp=nums[i] #found a new guy\\n                rem+=curem #include the number of 3s in our numbers greater than nums[i] counter\\n                curem=0 #Reset the count of numbers same as nums[i]\\n                ans+=1\\n            elif(nums[i]==nums[i+1]): \\n                if(rem>0): #if there is a spare number above, incrememnt sum \\n                    rem-=1\\n                    ans+=1\\n                curem+=1 #this number cannot be paired, but we can use it later\\n        return ans\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        int ans=0;\\n        int rem=0; //Numbers greater than the current number\\n        int curem=0; //Numbers equal to the current number\\n        int comp= nums[n-1]; //The last greatest number we have encountered so far\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]<comp){ //[3,4] we are checking 3 here\\n                comp=nums[i]; //found a new guy\\n                rem+=curem;  //include the number of 3s in our\\n                            //numbers greater than nums[i] counter\\n                curem=0;  //Reset the count of numbers same as nums[i]\\n                ans++;\\n            }\\n            else if(nums[i]==nums[i+1]) {  \\n                if(rem>0){ //if there is a spare number above, incrememnt sum \\n                    rem--;\\n                    ans++;\\n                }\\n                curem++; //this number cannot be paired, but we can use it later\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n=nums.size();\\n        int ans=0;\\n        int rem=0; //Numbers greater than the current number\\n        int curem=0; //Numbers equal to the current number\\n        int comp= nums[n-1]; //The last greatest number we have encountered so far\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]<comp){ //[3,4] we are checking 3 here\\n                comp=nums[i]; //found a new guy\\n                rem+=curem;  //include the number of 3s in our\\n                            //numbers greater than nums[i] counter\\n                curem=0;  //Reset the count of numbers same as nums[i]\\n                ans++;\\n            }\\n            else if(nums[i]==nums[i+1]) {  \\n                if(rem>0){ //if there is a spare number above, incrememnt sum \\n                    rem--;\\n                    ans++;\\n                }\\n                curem++; //this number cannot be paired, but we can use it later\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```Python3 []\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n=len(nums)\\n        ans=0\\n        rem=0 #Numbers greater than the current number\\n        curem=0 #Numbers equal to the current number\\n        comp= nums[n-1] #The last greatest number we have encountered so far\\n        for i in range(n-2,-1,-1):\\n            if(nums[i]<comp): #[3,4] we are checking 3 here\\n                comp=nums[i] #found a new guy\\n                rem+=curem #include the number of 3s in our numbers greater than nums[i] counter\\n                curem=0 #Reset the count of numbers same as nums[i]\\n                ans+=1\\n            elif(nums[i]==nums[i+1]): \\n                if(rem>0): #if there is a spare number above, incrememnt sum \\n                    rem-=1\\n                    ans+=1\\n                curem+=1 #this number cannot be paired, but we can use it later\\n        return ans\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3312548,
                "title": "two-pointer-approach-after-sorting",
                "content": "# Approach\\n\\nIf we sort the array the problem becomes simple. The main idea is to not actually calculate the perm array but find the indexes where nums[i+1] > nums[i] (after sorting) and increase the counter.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) \\n    {\\n       sort(nums.begin(),nums.end());\\n          \\n            int high=1;\\n            int low=0;\\n            int count=0;\\n            while(high<nums.size())\\n            {\\n                if(nums[low]==nums[high])\\n                    \\n                {\\n                    high++;\\n                }\\n                else\\n                {\\n                    low++;\\n                   high++;\\n                    count++;\\n                }\\n            }\\n            return count;\\n            \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) \\n    {\\n       sort(nums.begin(),nums.end());\\n          \\n            int high=1;\\n            int low=0;\\n            int count=0;\\n            while(high<nums.size())\\n            {\\n                if(nums[low]==nums[high])\\n                    \\n                {\\n                    high++;\\n                }\\n                else\\n                {\\n                    low++;\\n                   high++;\\n                    count++;\\n                }\\n            }\\n            return count;\\n            \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312445,
                "title": "beats-time-and-space",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe\\'ll use 2-pointer approach and will compare the elements.\\n\\n---\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlog(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return 0;\\n        int count = 0;\\n        \\n        sort(nums.begin(), nums.end());\\n        int p1 = 0, p2 = 1;\\n        \\n        while(p2!=n){\\n            if(nums[p1]<nums[p2]){\\n                count++;\\n                p1++;\\n                p2++;\\n            }\\n            else{\\n                p2++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n---\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/7bf798d7-29ee-4abf-aa93-dd873f8c9546_1675560239.9938114.jpeg\" alt=\"\">\\n</p>",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return 0;\\n        int count = 0;\\n        \\n        sort(nums.begin(), nums.end());\\n        int p1 = 0, p2 = 1;\\n        \\n        while(p2!=n){\\n            if(nums[p1]<nums[p2]){\\n                count++;\\n                p1++;\\n                p2++;\\n            }\\n            else{\\n                p2++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312415,
                "title": "java-code-using-sorting-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int p1 = 0;\\n        int p2 = 1;\\n        int count = 0;\\n        while(p2 < nums.length){\\n            if(nums[p2] > nums[p1]){\\n                count++;\\n                p1++;\\n                p2++;\\n            }\\n            if(p2 < nums.length && nums[p1] == nums[p2]){\\n                p2++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int p1 = 0;\\n        int p2 = 1;\\n        int count = 0;\\n        while(p2 < nums.length){\\n            if(nums[p2] > nums[p1]){\\n                count++;\\n                p1++;\\n                p2++;\\n            }\\n            if(p2 < nums.length && nums[p1] == nums[p2]){\\n                p2++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312404,
                "title": "go-c-sorted-slice",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n- Space complexity: O(1)\\n\\n# Code\\n```Go []\\nfunc maximizeGreatness(nums []int) int {\\n\\tsort.Slice(nums, func(i, j int) bool {\\n\\t\\treturn nums[j] > nums[i]\\n\\t})\\n\\n\\tvar res int = 0\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tif nums[i] > nums[res] {\\n\\t\\t\\tres++\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```\\n```C# []\\npublic class Solution {\\n    public int MaximizeGreatness(int[] nums)\\n    {\\n        Array.Sort(nums);\\n        int res = 0;\\n        for (int i = 1; i < nums.Length; i++)\\n            if (nums[i] > nums[res])\\n                res++;\\n        return res;\\n    }\\n}\\n``\\'",
                "solutionTags": [
                    "C#",
                    "Go"
                ],
                "code": "```Go []\\nfunc maximizeGreatness(nums []int) int {\\n\\tsort.Slice(nums, func(i, j int) bool {\\n\\t\\treturn nums[j] > nums[i]\\n\\t})\\n\\n\\tvar res int = 0\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tif nums[i] > nums[res] {\\n\\t\\t\\tres++\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3312321,
                "title": "swift-easy-to-understand-and-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    func maximizeGreatness(_ nums: [Int]) -> Int {\\n        var nums = nums.sorted()\\n        var res = 0\\n        \\n        for num in nums{\\n            if num > nums[res] {res += 1}\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximizeGreatness(_ nums: [Int]) -> Int {\\n        var nums = nums.sorted()\\n        var res = 0\\n        \\n        for num in nums{\\n            if num > nums[res] {res += 1}\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312286,
                "title": "c-solution-o-n-time-complexity",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(m.count(nums[i])>0){\\n                m[nums[i]]++;\\n            }\\n            else m[nums[i]]=1;\\n        }\\n        \\n        int ans=0;\\n        queue<int> to_remove;\\n        \\n        while(m.size()>1){\\n            ans+=m.size()-1;\\n            for(auto& x:m){\\n                x.second--;\\n                if(x.second==0){\\n                    to_remove.push(x.first);\\n                }\\n            }\\n            while(!to_remove.empty()){\\n                m.erase(to_remove.front());\\n                to_remove.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(m.count(nums[i])>0){\\n                m[nums[i]]++;\\n            }\\n            else m[nums[i]]=1;\\n        }\\n        \\n        int ans=0;\\n        queue<int> to_remove;\\n        \\n        while(m.size()>1){\\n            ans+=m.size()-1;\\n            for(auto& x:m){\\n                x.second--;\\n                if(x.second==0){\\n                    to_remove.push(x.first);\\n                }\\n            }\\n            while(!to_remove.empty()){\\n                m.erase(to_remove.front());\\n                to_remove.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312245,
                "title": "c-easy-and-simple",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        \\n       map<int,int>m;\\n        for(int x:nums) m[x]++ ;\\n        \\n          sort(nums.begin(),nums.end()) ;\\n         int ans=0;\\n         for(int x:nums) {\\n               \\n               auto it=m.upper_bound(x) ;\\n              \\n               if(it!=m.end()){\\n                    ans++;\\n                   \\n                    if(it->second==1) {\\n                      m.erase(it->first) ; \\n                    }\\n                   else{\\n                       m[it->first]--;\\n                   }\\n               }\\n             \\n              \\n         }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        \\n       map<int,int>m;\\n        for(int x:nums) m[x]++ ;\\n        \\n          sort(nums.begin(),nums.end()) ;\\n         int ans=0;\\n         for(int x:nums) {\\n               \\n               auto it=m.upper_bound(x) ;\\n              \\n               if(it!=m.end()){\\n                    ans++;\\n                   \\n                    if(it->second==1) {\\n                      m.erase(it->first) ; \\n                    }\\n                   else{\\n                       m[it->first]--;\\n                   }\\n               }\\n             \\n              \\n         }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312219,
                "title": "c-map-easy-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        map<int,int>mp;\\n        int k=0;\\n        for(auto &it:nums) mp[it]++;\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            auto it=mp.upper_bound(nums[i]);\\n            if(it!=mp.end() && it->second>0){\\n                ans++;\\n                it->second=it->second-1;\\n                if(it->second==0) mp.erase(it);\\n            }\\n            \\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        map<int,int>mp;\\n        int k=0;\\n        for(auto &it:nums) mp[it]++;\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            auto it=mp.upper_bound(nums[i]);\\n            if(it!=mp.end() && it->second>0){\\n                ans++;\\n                it->second=it->second-1;\\n                if(it->second==0) mp.erase(it);\\n            }\\n            \\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312205,
                "title": "sort-two-pointers-c-sort-sweet-easy-to-uderstand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int ans = 0;\\n        int i = 0, j = 0, n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        while(i<n&&j<n){\\n            while(j<n&&nums[j]<=nums[i]){\\n                j++;\\n            }\\n            i++;\\n            if(j==n)break;\\n            j++;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int ans = 0;\\n        int i = 0, j = 0, n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        while(i<n&&j<n){\\n            while(j<n&&nums[j]<=nums[i]){\\n                j++;\\n            }\\n            i++;\\n            if(j==n)break;\\n            j++;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 3312199,
                "title": "two-pointer-approach-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe just have to count the number of cases where ```a[i] < a[j]``` for all ```i != j```.\\nIn my code, I have used 2 pointer approach to achieve the answer.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int maximizeGreatness(vector<int> &a)\\n    {\\n        sort(begin(a), end(a));\\n        int i = 0;\\n        for (int j = 0; j < a.size(); ++j)\\n            if (a[i] < a[j])\\n                i++;\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```a[i] < a[j]```\n```i != j```\n```\\nclass Solution\\n{\\npublic:\\n    int maximizeGreatness(vector<int> &a)\\n    {\\n        sort(begin(a), end(a));\\n        int i = 0;\\n        for (int j = 0; j < a.size(); ++j)\\n            if (a[i] < a[j])\\n                i++;\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312170,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        //vector<int>v;\\n        //v=nums;\\n        sort(nums.begin(), nums.end());\\n        //map<int, int>m;\\n        //for(int i=0; i<v.size(); i++){m[v[i]]++;}\\n        int cnt=0, i=0, j=1;\\n        // for(int i=0; i<nums.size(); i++){\\n        //     int pos=upper_bound(v.begin(), v.end(), nums[i])-v.begin();\\n        //     //cout<<pos<<endl;\\n        //     if(pos!=v.size()){\\n        //         cnt++;\\n        //         v.erase(v.begin()+pos);\\n        //     }\\n        // }\\n        while(j<nums.size()){\\n            if(nums[i]<nums[j]){\\n                i++; j++; cnt++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        //vector<int>v;\\n        //v=nums;\\n        sort(nums.begin(), nums.end());\\n        //map<int, int>m;\\n        //for(int i=0; i<v.size(); i++){m[v[i]]++;}\\n        int cnt=0, i=0, j=1;\\n        // for(int i=0; i<nums.size(); i++){\\n        //     int pos=upper_bound(v.begin(), v.end(), nums[i])-v.begin();\\n        //     //cout<<pos<<endl;\\n        //     if(pos!=v.size()){\\n        //         cnt++;\\n        //         v.erase(v.begin()+pos);\\n        //     }\\n        // }\\n        while(j<nums.size()){\\n            if(nums[i]<nums[j]){\\n                i++; j++; cnt++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3312114,
                "title": "in-java-using-treemap",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        TreeMap<Integer, Integer> numsCount = new TreeMap<>();\\n        for (int num : nums) {\\n            numsCount.put(num, numsCount.getOrDefault(num, 0) + 1);\\n        }\\n        int res = 0;\\n        for (int num : nums) {\\n            Integer higherKey = numsCount.higherKey(num);\\n            if (higherKey != null) {\\n                numsCount.put(higherKey, numsCount.get(higherKey) - 1);\\n                if (numsCount.get(higherKey) == 0) {\\n                    numsCount.remove(higherKey);\\n                }\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        TreeMap<Integer, Integer> numsCount = new TreeMap<>();\\n        for (int num : nums) {\\n            numsCount.put(num, numsCount.getOrDefault(num, 0) + 1);\\n        }\\n        int res = 0;\\n        for (int num : nums) {\\n            Integer higherKey = numsCount.higherKey(num);\\n            if (higherKey != null) {\\n                numsCount.put(higherKey, numsCount.get(higherKey) - 1);\\n                if (numsCount.get(higherKey) == 0) {\\n                    numsCount.remove(higherKey);\\n                }\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312108,
                "title": "easy-java-solution-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        int left = 0;\\n        int right = 1;\\n        int counter = 0;\\n        \\n        Arrays.sort(nums);\\n        \\n        while(right < nums.length) {\\n            if(nums[left] != nums[right]) {\\n                counter++;\\n                left++;\\n            }\\n            right++;\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        int left = 0;\\n        int right = 1;\\n        int counter = 0;\\n        \\n        Arrays.sort(nums);\\n        \\n        while(right < nums.length) {\\n            if(nums[left] != nums[right]) {\\n                counter++;\\n                left++;\\n            }\\n            right++;\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312083,
                "title": "just-use-map-and-check-if-overlap-c",
                "content": "```\\nint maximizeGreatness(vector<int>& nums) {\\n        \\n        map<int,int> mp;\\n        \\n        for(auto &it: nums){\\n            mp[it]++;\\n        }\\n        \\n        int j=0, placed=0,great=0;\\n        \\n        for(auto &it: mp){\\n            if(j==0){\\n                placed= it.second;\\n            }\\n            else{\\n                great+= min(placed,it.second);\\n                if(it.second>placed){\\n                    placed=it.second;\\n                }\\n            }\\n            j++;\\n        }\\n       \\n        return great;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maximizeGreatness(vector<int>& nums) {\\n        \\n        map<int,int> mp;\\n        \\n        for(auto &it: nums){\\n            mp[it]++;\\n        }\\n        \\n        int j=0, placed=0,great=0;\\n        \\n        for(auto &it: mp){\\n            if(j==0){\\n                placed= it.second;\\n            }\\n            else{\\n                great+= min(placed,it.second);\\n                if(it.second>placed){\\n                    placed=it.second;\\n                }\\n            }\\n            j++;\\n        }\\n       \\n        return great;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3312080,
                "title": "simple-c-solution-with-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nusing intl = long long int;\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int> &nums)\\n{\\n    map<intl, intl> mp;\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        mp[nums[i]]++;\\n    }\\n    sort(nums.begin(), nums.end());\\n    intl count = 0;\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        for (auto &x : mp)\\n        {\\n\\n            while (x.first > nums[i] && i < nums.size() && x.second > 0)\\n            {\\n                x.second--;\\n                count++;\\n                i++;\\n            }\\n        }\\n    }\\n    return count;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nusing intl = long long int;\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int> &nums)\\n{\\n    map<intl, intl> mp;\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        mp[nums[i]]++;\\n    }\\n    sort(nums.begin(), nums.end());\\n    intl count = 0;\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        for (auto &x : mp)\\n        {\\n\\n            while (x.first > nums[i] && i < nums.size() && x.second > 0)\\n            {\\n                x.second--;\\n                count++;\\n                i++;\\n            }\\n        }\\n    }\\n    return count;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312075,
                "title": "python-binary-search",
                "content": "```python\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        count = defaultdict(int)\\n        for n in nums:\\n            count[n] += 1\\n        arr = sorted(count.keys())\\n        \\n        t = 0\\n        for n in nums:\\n            i = bisect.bisect(arr, n)\\n\\n            while i < len(arr):\\n                n = arr[i]\\n                if count[n] > 0:\\n                    count[n] -= 1\\n                    \\n                    # next bisect optimization\\n                    if count[n] == 0:\\n                        if i > 0:\\n                            arr[i] = arr[i - 1]\\n                        else:\\n                            arr[i] = 0\\n\\n                    t += 1\\n                    break\\n                \\n                i += 1\\n\\n        return t\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        count = defaultdict(int)\\n        for n in nums:\\n            count[n] += 1\\n        arr = sorted(count.keys())\\n        \\n        t = 0\\n        for n in nums:\\n            i = bisect.bisect(arr, n)\\n\\n            while i < len(arr):\\n                n = arr[i]\\n                if count[n] > 0:\\n                    count[n] -= 1\\n                    \\n                    # next bisect optimization\\n                    if count[n] == 0:\\n                        if i > 0:\\n                            arr[i] = arr[i - 1]\\n                        else:\\n                            arr[i] = 0\\n\\n                    t += 1\\n                    break\\n                \\n                i += 1\\n\\n        return t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312056,
                "title": "javascript-sort-two-pointer-tc-o-n-log-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maximizeGreatness = function(nums) {\\n    nums.sort((a, b) => a - b);\\n    let i = 0, j = 0;\\n    while (j < nums.length) {\\n        if (nums[i] < nums[j]) {\\n            i++;\\n        }\\n        j++;\\n    }\\n    return i;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sort"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maximizeGreatness = function(nums) {\\n    nums.sort((a, b) => a - b);\\n    let i = 0, j = 0;\\n    while (j < nums.length) {\\n        if (nums[i] < nums[j]) {\\n            i++;\\n        }\\n        j++;\\n    }\\n    return i;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3312053,
                "title": "max-heap-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        priority_queue<int>maxi;\\n        maxi.push(nums[n-1]);\\n        int i=n-2;\\n        int count=0;\\n        while(i>=0)\\n        {\\n            if(maxi.top()>nums[i])\\n            {\\n                count++;\\n                maxi.pop();\\n                maxi.push(nums[i]);\\n            }\\n            else\\n            {\\n                maxi.push(nums[i]);\\n            }\\n            i--;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        priority_queue<int>maxi;\\n        maxi.push(nums[n-1]);\\n        int i=n-2;\\n        int count=0;\\n        while(i>=0)\\n        {\\n            if(maxi.top()>nums[i])\\n            {\\n                count++;\\n                maxi.pop();\\n                maxi.push(nums[i]);\\n            }\\n            else\\n            {\\n                maxi.push(nums[i]);\\n            }\\n            i--;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312010,
                "title": "c-sort-and-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        map<int,int> mp;\\n        for(auto i : nums) mp[i]+=1;\\n        int ans=0;\\n        vector<int> arr = nums;\\n        sort(arr.begin(),arr.end());\\n        for(int i=0;i<nums.size();i++){\\n            auto x = upper_bound(arr.begin(),arr.end(),nums[i]) - arr.begin();\\n            while(x<arr.size() && mp[arr[x]]==0) x+=1;\\n            if(x<nums.size() && mp[arr[x]] > 0 ){\\n                ans += 1;\\n                mp[arr[x]] -= 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        map<int,int> mp;\\n        for(auto i : nums) mp[i]+=1;\\n        int ans=0;\\n        vector<int> arr = nums;\\n        sort(arr.begin(),arr.end());\\n        for(int i=0;i<nums.size();i++){\\n            auto x = upper_bound(arr.begin(),arr.end(),nums[i]) - arr.begin();\\n            while(x<arr.size() && mp[arr[x]]==0) x+=1;\\n            if(x<nums.size() && mp[arr[x]] > 0 ){\\n                ans += 1;\\n                mp[arr[x]] -= 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311973,
                "title": "two-pointer-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int i=0,j=1,ans=0;\\n        while(i<nums.size() && j<nums.size()){\\n            if(nums[i]<nums[j]){\\n                i++;j++;\\n                ans++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int i=0,j=1,ans=0;\\n        while(i<nums.size() && j<nums.size()){\\n            if(nums[i]<nums[j]){\\n                i++;j++;\\n                ans++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084559,
                "title": "java-two-pointers-head-and-tail",
                "content": "\\n# Complexity\\n- Time complexity: NlogN\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(sort)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort( nums);\\n        int tail   = 0 , res = 0 ;\\n        for( int head : nums){\\n            if(head  > nums[tail]){\\n                res++;\\n                tail++;\\n            }\\n        }  \\n        return res; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort( nums);\\n        int tail   = 0 , res = 0 ;\\n        for( int head : nums){\\n            if(head  > nums[tail]){\\n                res++;\\n                tail++;\\n            }\\n        }  \\n        return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061641,
                "title": "c-easy-n-log-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=0,c=0,n=nums.size();\\n        while(i<n && j<n)if(nums[j]>nums[i])i++,j++,c++;else j++;\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=0,c=0,n=nums.size();\\n        while(i<n && j<n)if(nums[j]>nums[i])i++,j++,c++;else j++;\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032547,
                "title": "using-sorting-and-map-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        map<int,int>mp;\\n        int n = nums.size();\\n        for(int i = 0; i<n; i++){\\n            mp[nums[i]]++;\\n        }\\n        sort(nums.begin(), nums.end());\\n        \\n        int count = 0;\\n        for(int i = 0; i<n; i++){\\n            \\n            for(auto it: mp){\\n                // modifying it.second directly within the loop will not work as expected because it is a copy of the key-value pair, and changes to it won\\'t affect the original map. To correctly modify the map\\'s values, you should use mp[it.first]--\\n                while(it.first > nums[i] && i<n && mp[it.first] > 0){\\n\\n                    count++;\\n                    mp[it.first]--;\\n                    \\n                    i++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        map<int,int>mp;\\n        int n = nums.size();\\n        for(int i = 0; i<n; i++){\\n            mp[nums[i]]++;\\n        }\\n        sort(nums.begin(), nums.end());\\n        \\n        int count = 0;\\n        for(int i = 0; i<n; i++){\\n            \\n            for(auto it: mp){\\n                // modifying it.second directly within the loop will not work as expected because it is a copy of the key-value pair, and changes to it won\\'t affect the original map. To correctly modify the map\\'s values, you should use mp[it.first]--\\n                while(it.first > nums[i] && i<n && mp[it.first] > 0){\\n\\n                    count++;\\n                    mp[it.first]--;\\n                    \\n                    i++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029070,
                "title": "simple-c-approach-using-2-pointers-sorting",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        \\n        sort(begin(nums),end(nums));\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        int ans=0;\\n        \\n        while(i<nums.size()){\\n            \\n            if(nums[i]>nums[j]){\\n                ans++;\\n                j++;\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        \\n        sort(begin(nums),end(nums));\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        int ans=0;\\n        \\n        while(i<nums.size()){\\n            \\n            if(nums[i]>nums[j]){\\n                ans++;\\n                j++;\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022683,
                "title": "java-solution-using-queue-find-just-greater-element",
                "content": "# Intuition\\nFind just greater element using queue.\\n\\n# Approach\\nIterate through array and check if current element is greater than queue\\'s peek element then we have a greatness and increment the greateness counter and remove peek element of queue, \\nFurther add current element in queue also to find greatness of this element also.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int greatness = 0;\\n        Queue<Integer> justGreater = new LinkedList<>();\\n        justGreater.add(nums[0]);\\n        for(int i = 1; i < nums.length; i++) {\\n            int previous = justGreater.peek(); \\n\\n            if(nums[i] > previous){\\n                greatness++;\\n                justGreater.remove();\\n            }\\n            justGreater.add(nums[i]);\\n        }\\n        return greatness;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int greatness = 0;\\n        Queue<Integer> justGreater = new LinkedList<>();\\n        justGreater.add(nums[0]);\\n        for(int i = 1; i < nums.length; i++) {\\n            int previous = justGreater.peek(); \\n\\n            if(nums[i] > previous){\\n                greatness++;\\n                justGreater.remove();\\n            }\\n            justGreater.add(nums[i]);\\n        }\\n        return greatness;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007293,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int f=0;int b=1;int c=0;\\n        while(b<nums.size())\\n        {\\n            if(nums[f]<nums[b])\\n            {\\n                c++;\\n                f++;\\n                b++;\\n            }\\n            else{\\n                 b++;\\n                \\n            }\\n        }\\n        return c;\\n     \\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int f=0;int b=1;int c=0;\\n        while(b<nums.size())\\n        {\\n            if(nums[f]<nums[b])\\n            {\\n                c++;\\n                f++;\\n                b++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4003266,
                "title": "c-o-n-time-o-n-space",
                "content": "# Intuition\\n- The optimal way of assigning numbers is to assign the next greatest element for a given array entry.\\n- A good way of doing this is using a priority queue and actually finding the smallest larger element for a given element. If none exists, we can\\'t match it. The solution looks like this, $O(NlogN)$ time (sort, then heap), $O(N)$ space:\\n\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        std::sort(nums.begin(), nums.end());\\n        std::priority_queue<int, vector<int>, std::greater<int>> pq(nums.begin(), nums.end());\\n        int ret{};\\n        for(auto i = 0u; i < nums.size(); ++i){\\n            while(!pq.empty() && pq.top() <= nums[i]) {\\n                pq.pop();\\n            }\\n            if(!pq.empty()){\\n                pq.pop();\\n                ret += 1;\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```\\n\\n- Consider the following cases:\\n1. `[1,2,3,4,5,6,7]`, ans = 6 ... In this case we simply shift down all elements\\n2. `[1,1,2,3,4,5,6,7]`, ans = 6. Note that we added an element, but because it\\'s another 1, it doesn\\'t help us create any additional \"wins\" in any permutation against the original array. One way of looking at this is that we take unique elements `[1,2,3,4,5,6,7]` and construct 6 wins out of this by shifting the array down to `[2,3,4,5,6,7,1]` where we win all but the last element. The last `1` gets no matches.\\n3. Now consider `[1,2,3,4,5,6,7,7]`. Once again the answer is 6. We similarly can do `[1,2,3,4,5,6,7]` and get `[2,3,4,5,6,7,1]` which wins in 6 spots. However the last 7 can\\'t help us anywhere because it doesn\\'t beat out the other 7 in the last position (where the 1 currently is) (e.g. `[2,3,4,5,6,7,7]` has the exact same score).\\n4. Now consider `[1,1,2,3,4,5,6,7,7]`, ans = 7. We get one additional match by first considering `[1,2,3,4,5,6,7] -> 6` then `[1,7] -> 1` for a total of 7. \\n5. Now consider `[1,1,1,2,3,4,5,6,7,7]`, ans = 7. We repeat 4, but now have a hanging `1` by itself. \\n\\nFrom this we notice that the answer has to do something with the size of the array, and the number of repeating elements. Specifically, from examples 3,4,5 above, we note that the answer only depends on the maximum repeating count of a single element.\\n\\nBy just bashing it out, we see that `ans = nums.size() - max_freq_of_single_element`. This matches the following intuition: we first find the maximum length of unique elements and calculate its score (which is length - 1). We then take the remaining elements and repeat this process of taking unique elements. At the end we will be left with a sequence of 1 (if there\\'s a single element with the maximum frequency) or more (if there are multiple) elements. \\n\\nThe total score here is the sum of scores. Each sequence\\'s score is its length minus 1. The sum of length is `nums.size()`. The number of sequences is `max_freq`. Hence the final answer is `nums.size() - max_freq`.\\n\\n\\n# Complexity\\n- Time complexity:\\n$O(N)$\\n\\n- Space complexity:\\n$O(N)$ (actually is $O(unique_elements)$ which may be substantially lower if the elements are dense).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        std::unordered_map<int, int> cnt{};\\n        cnt.reserve(nums.size());\\n\\n        int m{};\\n        for(int n: nums) {\\n            auto [itr, ins] = cnt.insert(std::make_pair(n, 0));\\n            ++itr->second;\\n            m = std::max(itr->second, m);\\n        }\\n        \\n        return nums.size() - m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        std::sort(nums.begin(), nums.end());\\n        std::priority_queue<int, vector<int>, std::greater<int>> pq(nums.begin(), nums.end());\\n        int ret{};\\n        for(auto i = 0u; i < nums.size(); ++i){\\n            while(!pq.empty() && pq.top() <= nums[i]) {\\n                pq.pop();\\n            }\\n            if(!pq.empty()){\\n                pq.pop();\\n                ret += 1;\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        std::unordered_map<int, int> cnt{};\\n        cnt.reserve(nums.size());\\n\\n        int m{};\\n        for(int n: nums) {\\n            auto [itr, ins] = cnt.insert(std::make_pair(n, 0));\\n            ++itr->second;\\n            m = std::max(itr->second, m);\\n        }\\n        \\n        return nums.size() - m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998287,
                "title": "c-beats-80-of-coders-simplest-easiest-optimal-solution-using-sorting-and-two-pointers",
                "content": "# Complexity\\n- Time complexity:\\nO(n log(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int res = 0;\\n\\n        sort(nums.begin(), nums.end());\\n\\n        for(auto it : nums)\\n            if(it > nums[res]) \\n                res++;\\n\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int res = 0;\\n\\n        sort(nums.begin(), nums.end());\\n\\n        for(auto it : nums)\\n            if(it > nums[res]) \\n                res++;\\n\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997683,
                "title": "easy-and-fast-solution-in-java-92-beats",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        int res = 0;\\n        int i = 0;\\n        int j = 1;\\n        Arrays.sort(nums);\\n        while(j < nums.length) {\\n            if(nums[j] > nums[i]) {\\n                res++;\\n                i++;\\n                j++;\\n            } else {\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        int res = 0;\\n        int i = 0;\\n        int j = 1;\\n        Arrays.sort(nums);\\n        while(j < nums.length) {\\n            if(nums[j] > nums[i]) {\\n                res++;\\n                i++;\\n                j++;\\n            } else {\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995764,
                "title": "c-91-88-faster-coder-simplest-solution-using-sorting-and-two-pointers",
                "content": "# Complexity\\n- Time complexity:\\nO(n log(n)) **where n = number of elements in nums.**\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n\\n        int ans = 0;\\n\\n        if(nums.size() == 1)\\n            return ans;\\n\\n        sort(nums.begin(), nums.end());\\n\\n        int j = -1;\\n\\n        for(int i=1; i<nums.size(); i++) {\\n            if(nums[i-1] < nums[i]) {\\n                j = i;\\n                break;\\n            }\\n        }\\n\\n        if(j == -1)\\n            return ans;\\n\\n        int i = 0;\\n\\n        while(i < nums.size() and j < nums.size()) {\\n            if(i == j) {\\n                j++;\\n                continue;\\n            }\\n            if(nums[i] < nums[j]) {\\n                ans++;\\n                i++;\\n                j++;\\n            }\\n            else if(nums[i] >= nums[j])\\n                j++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n\\n        int ans = 0;\\n\\n        if(nums.size() == 1)\\n            return ans;\\n\\n        sort(nums.begin(), nums.end());\\n\\n        int j = -1;\\n\\n        for(int i=1; i<nums.size(); i++) {\\n            if(nums[i-1] < nums[i]) {\\n                j = i;\\n                break;\\n            }\\n        }\\n\\n        if(j == -1)\\n            return ans;\\n\\n        int i = 0;\\n\\n        while(i < nums.size() and j < nums.size()) {\\n            if(i == j) {\\n                j++;\\n                continue;\\n            }\\n            if(nums[i] < nums[j]) {\\n                ans++;\\n                i++;\\n                j++;\\n            }\\n            else if(nums[i] >= nums[j])\\n                j++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982318,
                "title": "explained-c-two-pointer-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince the order doesn\\'t matter as we just want the count of elements greater in the permutation we can start by sorting the array.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing greedy approach to maximise count for every element we would like the next greater in the array since the array is sorted we can use two pointer to find the next greater for each index if possible \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSince you iterate though the array once.\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nConstant space needed.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int j =0;\\n        int count = 0;\\n        //for every index i finding j for which j is the just smaller number\\n        for(int i =1;i<nums.size();i++){\\n            if(nums[j]<nums[i]){\\n                count++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int j =0;\\n        int count = 0;\\n        //for every index i finding j for which j is the just smaller number\\n        for(int i =1;i<nums.size();i++){\\n            if(nums[j]<nums[i]){\\n                count++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959764,
                "title": "sorting-with-two-pointers",
                "content": "# Intuition : after sorting every arr[i+1]>=arr[i]\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: sorting with two pointers\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)(for iteration)+O(NlogN)(for sorting)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        if(nums.size()==1)return 0;\\n        vector<int>ans(nums);\\n        \\n        sort(ans.begin(),ans.end());\\n        int count=0;\\n\\n        int i=0;\\n        int j=1;\\n        while(j<ans.size())\\n        {\\n            if(ans[j]>ans[i])\\n            {\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return count;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        if(nums.size()==1)return 0;\\n        vector<int>ans(nums);\\n        \\n        sort(ans.begin(),ans.end());\\n        int count=0;\\n\\n        int i=0;\\n        int j=1;\\n        while(j<ans.size())\\n        {\\n            if(ans[j]>ans[i])\\n            {\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return count;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951304,
                "title": "simple-solution-using-sorting",
                "content": "# Complexity\\n- Time complexity:\\nO(n log n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int i=0, j=1;\\n        int ans = 0;\\n        for(int k=0 ;k<nums.size() ;k++) cout<<nums[k]<<\" \";\\n        cout<<endl;\\n        \\n        while(j<nums.size()){\\n            if(nums[i]<nums[j]){\\n                j++;\\n                i++;\\n                ans++;\\n            }\\n            else\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int i=0, j=1;\\n        int ans = 0;\\n        for(int k=0 ;k<nums.size() ;k++) cout<<nums[k]<<\" \";\\n        cout<<endl;\\n        \\n        while(j<nums.size()){\\n            if(nums[i]<nums[j]){\\n                j++;\\n                i++;\\n                ans++;\\n            }\\n            else\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3951192,
                "title": "explained-in-comments-sorting-7-to-10-line-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n// what we are doing here is, first we sort the array\\n// why ?\\n// so that we can have a linear increse/decrease sequence in the elements\\n// so that we can compare the elements with a loop\\n// now\\n// we will take the last element of the sorted nums and compare it with all the elements from last till we get a smaller element\\n// once we get a smaller element, we will increase the count and shift the new compare element to last index - 1 and repeat the process\\n\\n\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n\\n        int count = 0;\\n\\n        int end = nums.size() - 1 ;\\n        for( int i = nums.size()-1; i>=0 ; i-- ){\\n            if( nums[end] > nums[i] ){\\n                count++;\\n                end--;\\n            }\\n        }\\n\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n// what we are doing here is, first we sort the array\\n// why ?\\n// so that we can have a linear increse/decrease sequence in the elements\\n// so that we can compare the elements with a loop\\n// now\\n// we will take the last element of the sorted nums and compare it with all the elements from last till we get a smaller element\\n// once we get a smaller element, we will increase the count and shift the new compare element to last index - 1 and repeat the process\\n\\n\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n\\n        int count = 0;\\n\\n        int end = nums.size() - 1 ;\\n        for( int i = nums.size()-1; i>=0 ; i-- ){\\n            if( nums[end] > nums[i] ){\\n                count++;\\n                end--;\\n            }\\n        }\\n\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948161,
                "title": "ez-cpp-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n       \\n\\n        // for(int i=nums.size()-1;i>0;i--){\\n        //     if(nums[i]>nums[i-1] && helo[i-1]==true){\\n        //         ans++;\\n        //         helo[i-1]=false;\\n        //     }else{\\n        //         int count=i-2;\\n        //         while(count<nums.size()){\\n        //             if(nums[count]<nums[i] && helo[count]==true){\\n        //                 ans++;\\n        //                 helo[count]=false;\\n        //                 break;\\n        //             }\\n        //             count--;\\n        //         }\\n                \\n        //     }\\n        // }\\n        // return ans;\\n        int left=nums.size()-2;\\n        int right=nums.size()-1;\\n        while(left>=0){\\n            if(nums[left]<nums[right] ){\\n                ans++;\\n                left--;\\n                right--;\\n\\n            }else{\\n                left--;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n       \\n\\n        // for(int i=nums.size()-1;i>0;i--){\\n        //     if(nums[i]>nums[i-1] && helo[i-1]==true){\\n        //         ans++;\\n        //         helo[i-1]=false;\\n        //     }else{\\n        //         int count=i-2;\\n        //         while(count<nums.size()){\\n        //             if(nums[count]<nums[i] && helo[count]==true){\\n        //                 ans++;\\n        //                 helo[count]=false;\\n        //                 break;\\n        //             }\\n        //             count--;\\n        //         }\\n                \\n        //     }\\n        // }\\n        // return ans;\\n        int left=nums.size()-2;\\n        int right=nums.size()-1;\\n        while(left>=0){\\n            if(nums[left]<nums[right] ){\\n                ans++;\\n                left--;\\n                right--;\\n\\n            }else{\\n                left--;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910952,
                "title": "java-treemap-solution",
                "content": "# Intuition\\nFor every number, we want to pair the smallest number that is just greater than that number. If there isn\\'t a greater number, then we want to pair it with the smallest unpaired number.\\n\\nYou can use an ordered set to find the next higher number in logarithmic time.\\n\\n# Approach\\nAdd all the elements to a sorted map. Iterate through all the elements looking for the next number that is greater than the current number. For each number we pair, we need to remove it from the sorted map by decrementing the count by 1. If the count reaches 0, then remove it from the set\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n        for (var n : nums) map.merge(n, 1, Integer::sum);\\n\\n        int ans = 0;\\n        for (var num : nums) {\\n            var key = map.higherKey(num);\\n            if (key != null) {\\n                //we found a higher element to pair with num\\n                ans++;\\n            } else {\\n                //we didn\\'t find a higher element, so choose the smallest available number to pair\\n                key = map.firstKey();\\n            }\\n\\n            //decrement the counter. If the counter would reach 0, then remove it.\\n            map.merge(key, -1, Integer::sum);\\n\\n            if (map.get(key) == 0) {\\n                map.remove(key);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n        for (var n : nums) map.merge(n, 1, Integer::sum);\\n\\n        int ans = 0;\\n        for (var num : nums) {\\n            var key = map.higherKey(num);\\n            if (key != null) {\\n                //we found a higher element to pair with num\\n                ans++;\\n            } else {\\n                //we didn\\'t find a higher element, so choose the smallest available number to pair\\n                key = map.firstKey();\\n            }\\n\\n            //decrement the counter. If the counter would reach 0, then remove it.\\n            map.merge(key, -1, Integer::sum);\\n\\n            if (map.get(key) == 0) {\\n                map.remove(key);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900323,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int ans=0;\\n        int ind=0;\\n        for (int i=1;i<n;i++)\\n        {\\n            if (nums[i]>nums[ind]) \\n            {\\n                ans++;\\n                ind++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int ans=0;\\n        int ind=0;\\n        for (int i=1;i<n;i++)\\n        {\\n            if (nums[i]>nums[ind]) \\n            {\\n                ans++;\\n                ind++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895792,
                "title": "java-solution-easy-approach-4-line-of-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);        \\n        int perm = 0;\\n        for (int i=0;i<nums.length;i++){\\n            if (nums[perm] < nums[i]){\\n                perm++;\\n            }\\n        }\\n        return perm;\\n    }\\n}\\n```\\n\\nDo Upvote \\u2B06\\uFE0F\\u2B06\\uFE0F",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);        \\n        int perm = 0;\\n        for (int i=0;i<nums.length;i++){\\n            if (nums[perm] < nums[i]){\\n                perm++;\\n            }\\n        }\\n        return perm;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889442,
                "title": "c-easy-clean-code-short-min-heap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& a) {\\n        int c=0;\\n        priority_queue<int,vector<int>,greater<int>> p;\\n        for(auto i: a) p.push(i);\\n        sort(a.begin(),a.end());\\n        for(int i=0;i<a.size();i++)\\n        {\\n            while(p.size() && p.top()<=a[i]) p.pop();\\n            if(p.empty()) break;\\n            c++;\\n            p.pop();\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& a) {\\n        int c=0;\\n        priority_queue<int,vector<int>,greater<int>> p;\\n        for(auto i: a) p.push(i);\\n        sort(a.begin(),a.end());\\n        for(int i=0;i<a.size();i++)\\n        {\\n            while(p.size() && p.top()<=a[i]) p.pop();\\n            if(p.empty()) break;\\n            c++;\\n            p.pop();\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888688,
                "title": "java-pq-solution",
                "content": "# Intuition: Sort\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach Two pointers, Priority Queue\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: NlogN\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n\\n       PriorityQueue<Integer> pQ2 = new PriorityQueue<Integer>(Comparator.reverseOrder());\\n\\n        Arrays.sort(nums);\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            pQ2.add(nums[i]);\\n        }\\n\\n\\n        int count = 0, i = nums.length-1;\\n\\n           while (i >= 0 && !pQ2.isEmpty()) {\\n\\n               if (pQ2.peek() > nums[i]) {\\n                   pQ2.remove();\\n                   count++;\\n               }\\n               \\n               i--;\\n\\n           }\\n\\n\\n\\n\\n    return count;\\n\\n\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n\\n       PriorityQueue<Integer> pQ2 = new PriorityQueue<Integer>(Comparator.reverseOrder());\\n\\n        Arrays.sort(nums);\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            pQ2.add(nums[i]);\\n        }\\n\\n\\n        int count = 0, i = nums.length-1;\\n\\n           while (i >= 0 && !pQ2.isEmpty()) {\\n\\n               if (pQ2.peek() > nums[i]) {\\n                   pQ2.remove();\\n                   count++;\\n               }\\n               \\n               i--;\\n\\n           }\\n\\n\\n\\n\\n    return count;\\n\\n\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887901,
                "title": "cpp-2pointers-jawab-dekh-kar-maja-ayega",
                "content": "// isme kuch nahi humne 2 pointers mantain kiya hai agar value nums[j] >nums[i] to hum count ko bada dete hai\\n// agar equal hoti hai to j ko++ kardo\\n\\n# Complexity\\n- Time complexity:O(nlogn) ->because of sorting\\n\\n- Space complexity:O(1) ->no external space used\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n      sort(nums.begin(),nums.end());\\n      int n=nums.size();\\n        int i=0,j=0,count=0;\\n      while(j<n)\\n      {\\n          if(nums[i]==nums[j]) j++;\\n          else if(nums[i]  < nums[j])\\n          { \\n              i++;\\n              j++;\\n              count++;\\n          }\\n      }\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n      sort(nums.begin(),nums.end());\\n      int n=nums.size();\\n        int i=0,j=0,count=0;\\n      while(j<n)\\n      {\\n          if(nums[i]==nums[j]) j++;\\n          else if(nums[i]  < nums[j])\\n          { \\n              i++;\\n              j++;\\n              count++;\\n          }\\n      }\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880312,
                "title": "sort-two-pointer-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int n = nums.size();\\n        int p1 = 0, p2 = n-1, p3 = 0;\\n        sort(nums.begin(), nums.end(), greater<int>());\\n\\n        int ans = 0;\\n\\n        while (p3 < n) {\\n            // when nums[p1] > nums[p3], use biggest(nums[p1]) to cover biggest(nums[p3]), add one\\n            if (nums[p1] > nums[p3]) {\\n                p1++;\\n                p3++;\\n                ans++;\\n            } else {\\n                // when nums[p1] <= nums[p3], don\\'t waste nums[p1], reserve nums[p1] for next round,\\n                // use smallest(nums[p2]) to cover biggest(nums[p3]), not add one\\n                // e.g: when p1 = 0, p3 = 0, both pointer to the biggest num, we choose smallest num(p2 = n-1) to cover this biggest p3\\n                p2--;\\n                p3++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int n = nums.size();\\n        int p1 = 0, p2 = n-1, p3 = 0;\\n        sort(nums.begin(), nums.end(), greater<int>());\\n\\n        int ans = 0;\\n\\n        while (p3 < n) {\\n            // when nums[p1] > nums[p3], use biggest(nums[p1]) to cover biggest(nums[p3]), add one\\n            if (nums[p1] > nums[p3]) {\\n                p1++;\\n                p3++;\\n                ans++;\\n            } else {\\n                // when nums[p1] <= nums[p3], don\\'t waste nums[p1], reserve nums[p1] for next round,\\n                // use smallest(nums[p2]) to cover biggest(nums[p3]), not add one\\n                // e.g: when p1 = 0, p3 = 0, both pointer to the biggest num, we choose smallest num(p2 = n-1) to cover this biggest p3\\n                p2--;\\n                p3++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871337,
                "title": "easiest-2pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n    sort(nums.begin(),nums.end());\\n    int c=0;\\n    int start=1;\\n    for(int i=0;i<nums.size();i++){\\n        \\n        int end=nums.size()-1;\\n        while(start<=end){\\n            if(nums[start]>nums[i]){\\n                c++;\\n                start++;\\n                break;\\n        \\n            }\\n            start++;\\n        }\\n    }\\n     \\nreturn c;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n    sort(nums.begin(),nums.end());\\n    int c=0;\\n    int start=1;\\n    for(int i=0;i<nums.size();i++){\\n        \\n        int end=nums.size()-1;\\n        while(start<=end){\\n            if(nums[start]>nums[i]){\\n                c++;\\n                start++;\\n                break;\\n        \\n            }\\n            start++;\\n        }\\n    }\\n     \\nreturn c;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869221,
                "title": "succint-python-solution-faster-than-100",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution(object):\\n    def maximizeGreatness(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        nums.sort()\\n        i, j = 0, 1\\n        ctr = 0\\n        while j < len(nums):\\n            if nums[i] < nums[j]:\\n                ctr += 1\\n                i += 1\\n            j += 1\\n        \\n        return ctr\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximizeGreatness(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        nums.sort()\\n        i, j = 0, 1\\n        ctr = 0\\n        while j < len(nums):\\n            if nums[i] < nums[j]:\\n                ctr += 1\\n                i += 1\\n            j += 1\\n        \\n        return ctr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868271,
                "title": "c-solution-short-and-concise",
                "content": "```\\nint maximizeGreatness(vector<int>& nums) {\\n\\tsort(begin(nums), end(nums));\\n\\tint i = 0;\\n\\tfor (int j = 1; j < nums.size(); j++)\\n\\t\\tif (nums[i] < nums[j])\\n\\t\\t\\ti++;\\n\\treturn i;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maximizeGreatness(vector<int>& nums) {\\n\\tsort(begin(nums), end(nums));\\n\\tint i = 0;\\n\\tfor (int j = 1; j < nums.size(); j++)\\n\\t\\tif (nums[i] < nums[j])\\n\\t\\t\\ti++;\\n\\treturn i;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3859397,
                "title": "c-beats-100",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums)\\n    {\\n        sort(nums.begin(), nums.end());\\n        int i = 0;\\n        int j = 1;\\n        while(j<nums.size())\\n        {\\n            if(nums[j]>nums[i]){i++;}\\n            j++;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums)\\n    {\\n        sort(nums.begin(), nums.end());\\n        int i = 0;\\n        int j = 1;\\n        while(j<nums.size())\\n        {\\n            if(nums[j]>nums[i]){i++;}\\n            j++;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844521,
                "title": "binary-search-intuitive-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        multiset<int> nums3(nums.begin(), nums.end());\\n        int count = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int x = nums[i] + 1;\\n            auto it = nums3.lower_bound(x);\\n            if (it != nums3.end()) {\\n                nums3.erase(it);\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        multiset<int> nums3(nums.begin(), nums.end());\\n        int count = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int x = nums[i] + 1;\\n            auto it = nums3.lower_bound(x);\\n            if (it != nums3.end()) {\\n                nums3.erase(it);\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835500,
                "title": "sort-queue-greedy",
                "content": "# Intuition\\nRather than finding this permuation constructively, we just use a greedy approach to pair off larger elements with the first element that is smaller.\\n\\n# Approach\\nFirst sort the array in reverse, and then use a queue to pair the largest elements with the first successor that is less than their value. We will add increasingly smaller values to the queue on the left, and pop the largest values from the right.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        sorted_nums=sorted(nums, reverse=True)\\n        larger_values_above = deque([])\\n        count =0\\n        # loop over sorted nums in reverse\\n        # (no number is larger than the first here)\\n        for i in sorted_nums:\\n            # check if there are values larger than the current one (i)\\n            # if so, we will imagine placing the largest at i\\'s array position\\n            if len(larger_values_above)>0 and  i < larger_values_above[-1]:\\n                # imagine pairing the largest value with the current one\\n                larger_values_above.pop()\\n                # increase greatness return value\\n                count+=1\\n            # the current value is the lowest value encountered so far, so  it should be paired with something lower in the sorted_nums array\\n            larger_values_above.appendleft(i)\\n            \\n\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        sorted_nums=sorted(nums, reverse=True)\\n        larger_values_above = deque([])\\n        count =0\\n        # loop over sorted nums in reverse\\n        # (no number is larger than the first here)\\n        for i in sorted_nums:\\n            # check if there are values larger than the current one (i)\\n            # if so, we will imagine placing the largest at i\\'s array position\\n            if len(larger_values_above)>0 and  i < larger_values_above[-1]:\\n                # imagine pairing the largest value with the current one\\n                larger_values_above.pop()\\n                # increase greatness return value\\n                count+=1\\n            # the current value is the lowest value encountered so far, so  it should be paired with something lower in the sorted_nums array\\n            larger_values_above.appendleft(i)\\n            \\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830943,
                "title": "python-medium",
                "content": "```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        nums.sort()\\n        \\n        h = []\\n        \\n        for n in nums:\\n            heapq.heappush(h, n)\\n            \\n        res = 0\\n        \\n        r = 0\\n        \\n        while h:\\n            if nums[r] < h[0]:\\n                res += 1\\n                r += 1\\n                \\n            heapq.heappop(h)\\n            \\n        return res\\n            \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        nums.sort()\\n        \\n        h = []\\n        \\n        for n in nums:\\n            heapq.heappush(h, n)\\n            \\n        res = 0\\n        \\n        r = 0\\n        \\n        while h:\\n            if nums[r] < h[0]:\\n                res += 1\\n                r += 1\\n                \\n            heapq.heappop(h)\\n            \\n        return res\\n            \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828468,
                "title": "java-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)+O(logN*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n    boolean check(int[] nums, int n , int mid){\\n        int idx = n-mid;\\n        for(int i=0;i<mid;i++){\\n            if(nums[idx] > nums[i]){\\n                idx++;\\n                continue;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }   \\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int lo = 1;\\n        int hi = n-1;\\n        int ans = 0;\\n        //TTTTTTFFFFFFFFF\\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n            if(check(nums,n,mid)){\\n                lo = mid+1;\\n                ans = mid;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n/** \\n0 1 2 3 4 5 6\\n1 1 1 2 3 3 5\\n2 3 3 5 1 1 1\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n\\n\\n    boolean check(int[] nums, int n , int mid){\\n        int idx = n-mid;\\n        for(int i=0;i<mid;i++){\\n            if(nums[idx] > nums[i]){\\n                idx++;\\n                continue;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }   \\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int lo = 1;\\n        int hi = n-1;\\n        int ans = 0;\\n        //TTTTTTFFFFFFFFF\\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n            if(check(nums,n,mid)){\\n                lo = mid+1;\\n                ans = mid;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n/** \\n0 1 2 3 4 5 6\\n1 1 1 2 3 3 5\\n2 3 3 5 1 1 1\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812590,
                "title": "using-counts-to-achieve-o-n-time",
                "content": "# Intuition\\nWe can find the best case by reasoning a bit about the process that would create it.\\n\\nThe algorithm to actually construct the optimal permutation looks like this.\\n1. Make a list of all the original indexes for each unique value.\\n2. Make an empty list of available positions.\\n3. Make a sorted list of the unique values.\\n4. For each unique value; place as many copies of that value into empty positions as possible.\\n5. Append the list of original positions for the current value to the list of empty positions.\\n6. Repeat 4 and 5 until all unique values have been examined.\\n7. Fill in the rest of the array with the remaining values.\\n\\nThe greatness of the array we construct this way is equal to the number of positions that were filled when we completed step 6. Equivalently, it\\'s equal to the length of the array minus the number of positions we had to fill in for step 7.\\n\\nIf we can find a fast way to calculate how many positions we will have to fill in for step 7, we can easily subtract that from the length of the array to get the best possible greatness. In fact, this value is always equal to the maximum count of any value in the array.\\n\\n### Proof by Induction\\nNotation note: In this proof, I will use $$|x|$$ to denote the cardinality of the value $$x$$ inside the original array, rather than absolute value.\\n\\nLet $$f(x)=|x|$$ denote the number of unfilled positions after completing step 5 for a unique value $$x$$ from the original array.\\n\\nBase case: $$x = min(arr)$$. Because this is the first time we are doing step 4, we have no open positions in which to put copies of $$x$$. In step 5 we will add $$|x|$$ positions to the list of open positions. Therefore, $$f(min(arr))=|min(arr)|$$.\\n\\nInductive case: Having just placed all copies of $$x$$, we start step 4, placing copies of $$x+1$$. We have $$|x|$$ available positions. There are 2 possibilities for the comparison of $$|x|$$ and $$|x+1|$$.\\n* $$|x+1|>|x|$$: In step 4 we fill $$|x|$$ positions with the value $$|x+1|$$. Then in step 5 we place $$|x+1|$$ positions into the list of open positions. The number of open positions in now $$|x+1|$$.\\n* $$|x+1| <= |x|$$: In step 4 we will fill $$|x+1|$$ open positions. In step 5 we will add $$|x+1|$$ positions to the list of open positions. Since we have added and subtracted the same number of positions, the number of open positions is still $$|x|$$.\\n\\nTherefore, $$f(x)=|x| => f(x+1)=max(|x|,|x+1|)$$.\\n\\nGiven $$f(x)=|x| => f(x+1)=max(|x|,|x+1|)$$, it is trivial to conclude that $$f(max(arr))=max(|x|, \\u2200x\\u2208arr)$$.\\n\\n# Approach\\nSince we\\'ve just proven that the number of unfilled positions at the end of step 6 is equal to the maximum count of any unique value in the array, we\\'ll simply count occurences of each value, find the maxmimum count, and subtract that maximum count from the length of the array.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfunc maximizeGreatness(nums []int) int {\\n\\n    # O(n) space to keep counts of values.\\n\\tcount := map[int]int{}\\n\\n\\tvar max int\\n\\n    # O(n) time to iterate through array.\\n\\tfor _, x := range nums {\\n\\t\\tc := count[x] + 1\\n\\t\\tif max < c {\\n\\t\\t\\tmax = c\\n\\t\\t}\\n\\t\\tcount[x] = c\\n\\t}\\n\\n\\treturn len(nums) - max\\n}\\n\\n```\\n\\n# Optimizing for Space instead of Time\\nIt is also possible to solve this problem in $$O(1)$$ space, at the tradeoff of spending $$O(n\\xD7log(n))$$ time.\\n\\nIn order to be able to verify the correctness of the below code, one must first make an additional observation: while the optimal final array is dependent on the initial ordering of the array, the greatness of that array is *not*. Whether each individual $$i$$ counts towards greatness is independent of any other value of $$i$$. For that reason, sorting the array does not affect the maximum greatness.\\n```\\nfunc maximizeGreatness(nums []int) int {\\n\\n    # O(n log n) time to sort.\\n\\tsort.Ints(nums)\\n\\t\\n    # Use only O(1) space to track progress.\\n\\tvar run, max int\\n\\tcurr := nums[0]\\n\\n    # O(n) time to iterate through array.\\n\\tfor _, x := range nums {\\n\\n\\t\\tif x > curr {\\n\\t\\t\\tif max < run {\\n\\t\\t\\t\\tmax = run\\n\\t\\t\\t}\\n\\t\\t\\tcurr, run = x, 0\\n\\t\\t}\\n\\n\\t\\trun++\\n\\t}\\n\\n    # Check one more time in case the last value was the most common.\\n\\tif max < run {\\n\\t\\tmax = run\\n\\t}\\n\\n\\treturn len(nums) - max\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximizeGreatness(nums []int) int {\\n\\n    # O(n) space to keep counts of values.\\n\\tcount := map[int]int{}\\n\\n\\tvar max int\\n\\n    # O(n) time to iterate through array.\\n\\tfor _, x := range nums {\\n\\t\\tc := count[x] + 1\\n\\t\\tif max < c {\\n\\t\\t\\tmax = c\\n\\t\\t}\\n\\t\\tcount[x] = c\\n\\t}\\n\\n\\treturn len(nums) - max\\n}\\n\\n```\n```\\nfunc maximizeGreatness(nums []int) int {\\n\\n    # O(n log n) time to sort.\\n\\tsort.Ints(nums)\\n\\t\\n    # Use only O(1) space to track progress.\\n\\tvar run, max int\\n\\tcurr := nums[0]\\n\\n    # O(n) time to iterate through array.\\n\\tfor _, x := range nums {\\n\\n\\t\\tif x > curr {\\n\\t\\t\\tif max < run {\\n\\t\\t\\t\\tmax = run\\n\\t\\t\\t}\\n\\t\\t\\tcurr, run = x, 0\\n\\t\\t}\\n\\n\\t\\trun++\\n\\t}\\n\\n    # Check one more time in case the last value was the most common.\\n\\tif max < run {\\n\\t\\tmax = run\\n\\t}\\n\\n\\treturn len(nums) - max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3803975,
                "title": "only-one-pointer-just-compare-array-from-reverse",
                "content": "**Bold**# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJUST CHECK ARRAY FROM REVERSE\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NLOGN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans=[]\\n        l=len(nums)\\n        i=l-1\\n        last=l-1\\n        x=0\\n        while i>=0:\\n            if nums[i]<nums[last]:\\n                ans.append(nums[last])\\n                last-=1\\n            else:\\n                ans.append(0)\\n                x+=1\\n            i-=1\\n        print(ans)\\n        return len(ans)-x\\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans=[]\\n        l=len(nums)\\n        i=l-1\\n        last=l-1\\n        x=0\\n        while i>=0:\\n            if nums[i]<nums[last]:\\n                ans.append(nums[last])\\n                last-=1\\n            else:\\n                ans.append(0)\\n                x+=1\\n            i-=1\\n        print(ans)\\n        return len(ans)-x\\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784775,
                "title": "chota-sa-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int l = nums.length;\\n        int i =0;\\n        int j =0;\\n        int ans = 0;\\n\\n        while(j<l){\\n            if(nums[i]==nums[j]){\\n                j++;\\n            }\\n            else{\\n                i++;\\n                j++;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int l = nums.length;\\n        int i =0;\\n        int j =0;\\n        int ans = 0;\\n\\n        while(j<l){\\n            if(nums[i]==nums[j]){\\n                j++;\\n            }\\n            else{\\n                i++;\\n                j++;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778590,
                "title": "c-nlogn-using-multiset-and-upper-bound-constructing-perm-array",
                "content": "class Solution {\\npublic:\\n\\n    int maximizeGreatness(vector<int>& nums) {\\n        int n= nums.size();\\n        multiset<int> s;\\n        \\n        for(auto e: nums)\\n            s.insert(e);\\n        \\n        vector<int> perm(n);\\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s.upper_bound(nums[i])!=s.end())\\n            {\\n                perm[i]= *(s.upper_bound(nums[i]));\\n                ans++;\\n                s.erase(s.find(perm[i]));\\n            }\\n            else\\n            {\\n                perm[i]= *(s.begin());\\n                s.erase(s.find(perm[i]));\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maximizeGreatness(vector<int>& nums) {\\n        int n= nums.size();\\n        multiset<int> s;\\n        \\n        for(auto e: nums)\\n            s.insert(e);\\n        \\n        vector<int> perm(n);\\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s.upper_bound(nums[i])!=s.end())\\n            {\\n                perm[i]= *(s.upper_bound(nums[i]));\\n                ans++;\\n                s.erase(s.find(perm[i]));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3750885,
                "title": "golang-two-pointers-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```go\\nfunc maximizeGreatness(nums []int) int {\\n\\tsort.Ints(nums)\\n\\ti, j, g := 0, 1, 0\\n\\tfor j < len(nums) {\\n\\t\\tif nums[j] > nums[i] {\\n\\t\\t\\ti++\\n\\t\\t\\tj++\\n\\t\\t\\tg++\\n\\t\\t} else {\\n\\t\\t\\tj++\\n\\t\\t}\\n\\t}\\n\\treturn g\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers"
                ],
                "code": "```go\\nfunc maximizeGreatness(nums []int) int {\\n\\tsort.Ints(nums)\\n\\ti, j, g := 0, 1, 0\\n\\tfor j < len(nums) {\\n\\t\\tif nums[j] > nums[i] {\\n\\t\\t\\ti++\\n\\t\\t\\tj++\\n\\t\\t\\tg++\\n\\t\\t} else {\\n\\t\\t\\tj++\\n\\t\\t}\\n\\t}\\n\\treturn g\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3739964,
                "title": "python-easy-solution-using-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeGreatness(self, arr: List[int]) -> int:\\n        arr.sort()\\n        idx=0\\n\\n        for i in arr:\\n            if i>arr[idx]:\\n                idx+=1\\n\\n        return idx\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeGreatness(self, arr: List[int]) -> int:\\n        arr.sort()\\n        idx=0\\n\\n        for i in arr:\\n            if i>arr[idx]:\\n                idx+=1\\n\\n        return idx\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736791,
                "title": "easy-to-get-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int p1 = 0;\\n        int p2 = 1;\\n        int cnt = 0;\\n        while(p2 < nums.length){\\n            if(nums[p2] > nums[p1]){\\n                cnt++;\\n                p1++;\\n                p2++;\\n            }\\n            if(p2 < nums.length && nums[p1] == nums[p2]){\\n                p2++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int p1 = 0;\\n        int p2 = 1;\\n        int cnt = 0;\\n        while(p2 < nums.length){\\n            if(nums[p2] > nums[p1]){\\n                cnt++;\\n                p1++;\\n                p2++;\\n            }\\n            if(p2 < nums.length && nums[p1] == nums[p2]){\\n                p2++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733219,
                "title": "two-pointer-java",
                "content": "\\n```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int i =0;\\n        int res =0;\\n        for(int j=0; j<nums.length;j++){\\n            if(nums[j]>nums[i]){\\n                res++;\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int i =0;\\n        int res =0;\\n        for(int j=0; j<nums.length;j++){\\n            if(nums[j]>nums[i]){\\n                res++;\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697175,
                "title": "beats-100-faster-c-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n\\n        // int ans=0;\\n        // vector<int>v2;\\n        // for(auto i:nums){\\n        //     v2.push_back(i);\\n        // }\\n        // sort(v2.begin(),v2.end());\\n        // int maxi=v2[v2.size()-1];\\n        // for(int i=0;i<nums.size();i++){\\n        //     int j=0;\\n        //     int mini=v2[j]; \\n        //     if(maxi==nums[i]){\\n        //         continue;\\n        //     }\\n        //     while(mini<=nums[i] && j<v2.size()){\\n        //         mini=v2[j++];\\n        //     }\\n        //     if(mini>nums[i]){\\n        //         ans++;\\n        //         auto it=v2.begin()+j-1;\\n        //         v2.erase(it);\\n        //     }\\n        // }\\n        // return ans;\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=1;\\n        while(j < nums.size()){\\n            if(nums[j] > nums[i])\\n                i++;\\n            j++;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n\\n        // int ans=0;\\n        // vector<int>v2;\\n        // for(auto i:nums){\\n        //     v2.push_back(i);\\n        // }\\n        // sort(v2.begin(),v2.end());\\n        // int maxi=v2[v2.size()-1];\\n        // for(int i=0;i<nums.size();i++){\\n        //     int j=0;\\n        //     int mini=v2[j]; \\n        //     if(maxi==nums[i]){\\n        //         continue;\\n        //     }\\n        //     while(mini<=nums[i] && j<v2.size()){\\n        //         mini=v2[j++];\\n        //     }\\n        //     if(mini>nums[i]){\\n        //         ans++;\\n        //         auto it=v2.begin()+j-1;\\n        //         v2.erase(it);\\n        //     }\\n        // }\\n        // return ans;\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=1;\\n        while(j < nums.size()){\\n            if(nums[j] > nums[i])\\n                i++;\\n            j++;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3692552,
                "title": "very-simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsorting will work\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the array and then count the occourences of element. and subtract the maximun occurence with the size of array.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//Do Upvote if you liked my approach\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=nums.size();\\n        int cnt=0;\\n        int mx=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){cnt++;mx=max(mx,cnt);}\\n            else cnt=0;\\n        }\\n        return ans-mx-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//Do Upvote if you liked my approach\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=nums.size();\\n        int cnt=0;\\n        int mx=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){cnt++;mx=max(mx,cnt);}\\n            else cnt=0;\\n        }\\n        return ans-mx-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688774,
                "title": "sort-and-rotate-the-sorted-array-to-left-by-maximum-frequent-frequency-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int n=  nums.size();\\n        vector<int>temp1 = nums,temp2 =nums;\\n        unordered_map<int,int>mp;\\n        int k = 0;\\n        for(auto x : nums){\\n            mp[x]++;\\n            k = max(mp[x],k);\\n        }\\n       \\n        sort(temp1.begin(),temp1.end());\\n     \\n\\n        sort(temp2.begin(),temp2.end());\\n        rotate(temp2.begin(),temp2.begin()+k,temp2.end());\\n        int ans =0;\\n        for(int i = 0;i<n;i++){\\n            if(temp2[i]>temp1[i]){\\n                ans++;\\n            }\\n        //   cout<<temp1[i]<<\" \"<<temp2[i]<<endl;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int n=  nums.size();\\n        vector<int>temp1 = nums,temp2 =nums;\\n        unordered_map<int,int>mp;\\n        int k = 0;\\n        for(auto x : nums){\\n            mp[x]++;\\n            k = max(mp[x],k);\\n        }\\n       \\n        sort(temp1.begin(),temp1.end());\\n     \\n\\n        sort(temp2.begin(),temp2.end());\\n        rotate(temp2.begin(),temp2.begin()+k,temp2.end());\\n        int ans =0;\\n        for(int i = 0;i<n;i++){\\n            if(temp2[i]>temp1[i]){\\n                ans++;\\n            }\\n        //   cout<<temp1[i]<<\" \"<<temp2[i]<<endl;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3672291,
                "title": "maximize-greatness-of-an-array-easy-approach-fast-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) \\n    {\\n        sort(nums.rbegin(),nums.rend());\\n        vector<int>temp(nums.begin(),nums.end());\\n\\n        int ans = 0;\\n        int j = 0;\\n        for(int i = 0; i<nums.size(),j<nums.size();j++)\\n        {\\n            if(temp[j]<nums[i])\\n            {\\n                ans++;\\n                i++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) \\n    {\\n        sort(nums.rbegin(),nums.rend());\\n        vector<int>temp(nums.begin(),nums.end());\\n\\n        int ans = 0;\\n        int j = 0;\\n        for(int i = 0; i<nums.size(),j<nums.size();j++)\\n        {\\n            if(temp[j]<nums[i])\\n            {\\n                ans++;\\n                i++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669754,
                "title": "swift-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func maximizeGreatness(_ nums: [Int]) -> Int {\\n        var nums = nums.sorted()\\n        var result = 0\\n    \\n        for num in nums {\\n            num > nums[result] ? result += 1 : nil\\n        }\\n    return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximizeGreatness(_ nums: [Int]) -> Int {\\n        var nums = nums.sorted()\\n        var result = 0\\n    \\n        for num in nums {\\n            num > nums[result] ? result += 1 : nil\\n        }\\n    return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664659,
                "title": "typescript-greedy-runtime-memory-100",
                "content": "# Approach\\nSort Array and copy another one to store remaining value.\\n\\nif val >= compareValue => shift remaining temp arr \\nif val < compareValue => pop remaining temp arr \\n\\n```\\n-------------\\u2193\\n[1,1,1,2,3,3,5] sort Array\\n-------------\\u2193\\n[1,1,1,2,3,3,5] remaining Array\\n\\ncompare last value => 5 is not less then 5\\nremaining Array => shift()\\n\\n-----------\\u2193\\n[1,1,1,2,3,3,5] sort Array\\n-----------\\u2193\\n[1,1,2,3,3,5] remaining Array\\n\\ncompare last value => 3 is less then 5\\nremaining Array => pop() // anwser + 1\\n\\n---------\\u2193\\n[1,1,1,2,3,3,5] sort Array\\n---------\\u2193\\n[1,1,2,3,3] remaining Array\\n\\ncompare last value => 3 is not less then 5\\nremaining Array => shift()\\n\\n```\\n\\n# Complexity\\n- Time complexity:\\nO(logn + n): include sort bulit-in method and one for-loop\\n\\n- Space complexity:\\nO(m): O(2m) => O(m) to save sort array value\\n\\n# Code\\n```\\nfunction maximizeGreatness(nums: number[]): number {\\n    const tempArr = [...nums].sort((a, b) => a - b)\\n    const tempArr2 = [...tempArr]\\n    \\n    let res = 0\\n    for (let i = tempArr.length - 1; i >= 0 && tempArr2.length > 0; i--) {\\n        const val = tempArr[i]\\n        const compareValue = tempArr2[tempArr2.length - 1]\\n\\n        if (val >= compareValue) {\\n            tempArr2.shift()\\n        } else if (val < compareValue) {\\n            tempArr2.pop()\\n            res++\\n        }\\n    }\\n\\n    return res\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n-------------\\u2193\\n[1,1,1,2,3,3,5] sort Array\\n-------------\\u2193\\n[1,1,1,2,3,3,5] remaining Array\\n\\ncompare last value => 5 is not less then 5\\nremaining Array => shift()\\n\\n-----------\\u2193\\n[1,1,1,2,3,3,5] sort Array\\n-----------\\u2193\\n[1,1,2,3,3,5] remaining Array\\n\\ncompare last value => 3 is less then 5\\nremaining Array => pop() // anwser + 1\\n\\n---------\\u2193\\n[1,1,1,2,3,3,5] sort Array\\n---------\\u2193\\n[1,1,2,3,3] remaining Array\\n\\ncompare last value => 3 is not less then 5\\nremaining Array => shift()\\n\\n```\n```\\nfunction maximizeGreatness(nums: number[]): number {\\n    const tempArr = [...nums].sort((a, b) => a - b)\\n    const tempArr2 = [...tempArr]\\n    \\n    let res = 0\\n    for (let i = tempArr.length - 1; i >= 0 && tempArr2.length > 0; i--) {\\n        const val = tempArr[i]\\n        const compareValue = tempArr2[tempArr2.length - 1]\\n\\n        if (val >= compareValue) {\\n            tempArr2.shift()\\n        } else if (val < compareValue) {\\n            tempArr2.pop()\\n            res++\\n        }\\n    }\\n\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3586853,
                "title": "java-two-pointer-solution-with-sorted-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        for (int i = 0, j = 1; i < nums.length && j < nums.length; i++){\\n            while (j < nums.length){\\n                if (nums[i]<nums[j++]){\\n                    count++;\\n                    break;\\n                } \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        for (int i = 0, j = 1; i < nums.length && j < nums.length; i++){\\n            while (j < nums.length){\\n                if (nums[i]<nums[j++]){\\n                    count++;\\n                    break;\\n                } \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567091,
                "title": "simple-and-easy-to-understand-solution-with-queue-explanation-included",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReplace each integer with a number just greater than itself.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the given array.\\n2. Iterate through the sorted array and keep pushing all the elements into the queue.\\n3. Pop if the frontmost integer is lesser than the current integer.\\n4. Answer is the number of integers that are poped out (n-q.size()). \\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size(),ans=0;\\n        queue<int> q;\\n        for(int i=0;i<n;i++){\\n            q.push(nums[i]);\\n            if(q.front()<nums[i])\\n                q.pop();\\n        }\\n        return n-q.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size(),ans=0;\\n        queue<int> q;\\n        for(int i=0;i<n;i++){\\n            q.push(nums[i]);\\n            if(q.front()<nums[i])\\n                q.pop();\\n        }\\n        return n-q.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555865,
                "title": "easy-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) \\n    {\\n        std::sort(nums.begin(), nums.end());\\n\\n        int i=0;\\n        for(; i<nums.size(); i++)\\n        {\\n            if(nums[i]>nums[0])\\n            {\\n                break;\\n            }\\n        }\\n\\n        int j=0;\\n        int res = 0;\\n        for(; i<nums.size(); i++)\\n        {\\n            if(nums[i]>nums[j])\\n            {\\n                res++;\\n\\t\\t\\t\\tj++;\\n            }           \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) \\n    {\\n        std::sort(nums.begin(), nums.end());\\n\\n        int i=0;\\n        for(; i<nums.size(); i++)\\n        {\\n            if(nums[i]>nums[0])\\n            {\\n                break;\\n            }\\n        }\\n\\n        int j=0;\\n        int res = 0;\\n        for(; i<nums.size(); i++)\\n        {\\n            if(nums[i]>nums[j])\\n            {\\n                res++;\\n\\t\\t\\t\\tj++;\\n            }           \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540882,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int st = 0;\\n        int max = 1;\\n        int cnt = 0;\\n        while (max < nums.length) {\\n            while (max < nums.length && nums[max] <= nums[st]) {\\n                max++;\\n            }\\n            if (max == nums.length)\\n                break;\\n            st++;\\n            max++;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int st = 0;\\n        int max = 1;\\n        int cnt = 0;\\n        while (max < nums.length) {\\n            while (max < nums.length && nums[max] <= nums[st]) {\\n                max++;\\n            }\\n            if (max == nums.length)\\n                break;\\n            st++;\\n            max++;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525129,
                "title": "simple-greedy-o-nlogn-algo-in-python",
                "content": "# Intuition\\nAt first I thought I might try something clever with binary search, but gave up because it got too complicated with picking left / right halves. There probably is a way...\\n\\n# Approach\\nI sorted the numbers for readability, because I realized it didnt matter what order the numbers were, just that certain ones were dominated. I then realized that dominating small numbers with other small numbers is always beneficial. There\\'s no reason not to do so, since you free up larger numbers to dominate other remaining / possibly larger numbers. So with this greedy approach, I tried using a heap and the array given to us. \\n\\nBut you can notice that by sorting the numbers, we already have a heap. Also, by sorting the numbers, I have a natural way to go from small numbers to be dominated to larger ones. Again, theres no reason to ever try to dominate larger numbers first, because dominating smaller numbers always is beneficial. So then it was a just a matter of writing the O(n) loop algorithm. Do notice that the while loop is safe because in either condition, we are advancing in the array. \\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) = O(nlogn) from sorting + O(n) from looping, which is not great but I was pleasantly surprised when this was accepted. I was really hoping not to find a more complex, cheaper algo.\\n\\n- Space complexity:\\nO(n), because all we use is the array given to us and two pointers. \\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        heap = []\\n        nums.sort()\\n\\n        heapP = 0\\n        arrP = 0\\n        total = 0\\n\\n        while(arrP < len(nums) and heapP < len(nums)):\\n            if nums[heapP] > nums[arrP]:\\n                total += 1\\n                heapP += 1\\n                arrP += 1\\n            else:\\n                heapP += 1\\n\\n        return total\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        heap = []\\n        nums.sort()\\n\\n        heapP = 0\\n        arrP = 0\\n        total = 0\\n\\n        while(arrP < len(nums) and heapP < len(nums)):\\n            if nums[heapP] > nums[arrP]:\\n                total += 1\\n                heapP += 1\\n                arrP += 1\\n            else:\\n                heapP += 1\\n\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518072,
                "title": "easy-solution-two-pointer-python3",
                "content": "# Approach\\nTwo pointer\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        nums.sort()\\n        l, r = 0, 1\\n        result = 0\\n        while r < len(nums):\\n            if nums[l] < nums[r]:\\n                l += 1\\n                r += 1\\n                result += 1\\n            else: # nums[l] == nums[r]\\n                r += 1\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        nums.sort()\\n        l, r = 0, 1\\n        result = 0\\n        while r < len(nums):\\n            if nums[l] < nums[r]:\\n                l += 1\\n                r += 1\\n                result += 1\\n            else: # nums[l] == nums[r]\\n                r += 1\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503370,
                "title": "java-basic-two-pointer-solution",
                "content": "**Please Upvote!! :\")**\\n\\n# Approach\\n\\n1. Sort the Array.\\n2. In the sorted array take two pointers i and j and start comparing and find out the first number which is greater than nums[i]. Once found start incrementing the counter variable and i pointer.\\n3. Return count;\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n\\n       Arrays.sort(nums);\\n       int i = 0;\\n       int j = 0;\\n       int count = 0;\\n       while(j<nums.length){\\n           if(nums[i]<nums[j]){\\n               count++;\\n               i++;\\n           }\\n           j++;\\n       }\\n       return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n\\n       Arrays.sort(nums);\\n       int i = 0;\\n       int j = 0;\\n       int count = 0;\\n       while(j<nums.length){\\n           if(nums[i]<nums[j]){\\n               count++;\\n               i++;\\n           }\\n           j++;\\n       }\\n       return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493404,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        nums.sort()\\n        arr=nums.copy()\\n        j=0\\n        c=0\\n        for i in range(len(arr)):\\n            if arr[i]>nums[j]:\\n                j+=1\\n                c+=1\\n                continue\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        nums.sort()\\n        arr=nums.copy()\\n        j=0\\n        c=0\\n        for i in range(len(arr)):\\n            if arr[i]>nums[j]:\\n                j+=1\\n                c+=1\\n                continue\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492336,
                "title": "sort-and-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- if nums[i]<nums[j] we can assgin perm[i] with nums[j]\\n- therefore we can sort the array the find the pairs of [i,j] such that nums[i]<nums[j]\\n- make use of two pointers\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int cnt=0;\\n        for(int i=0,j=1;i<j;i++){\\n            while(j<nums.size() and nums[i]==nums[j]) j++;\\n            if(j<nums.size()){\\n                cnt++;\\n                j++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int cnt=0;\\n        for(int i=0,j=1;i<j;i++){\\n            while(j<nums.size() and nums[i]==nums[j]) j++;\\n            if(j<nums.size()){\\n                cnt++;\\n                j++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490742,
                "title": "100-easy-solution-using-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n         Arrays.sort(nums);\\n        int ans = 0;\\n        for (int num : nums) {\\n            if (nums[ans] < num) {\\n                ++ans;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n         Arrays.sort(nums);\\n        int ans = 0;\\n        for (int num : nums) {\\n            if (nums[ans] < num) {\\n                ++ans;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479100,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int openForGreatnessCount=0, gCount=0;\\n        for (int i=0; i<nums.length; i++){\\n            int curCount = 1;\\n            while (i+curCount<nums.length && nums[i]==nums[i+curCount]) curCount++;\\n            int becomingGreat = Math.min(openForGreatnessCount,curCount);\\n            openForGreatnessCount +=  curCount-becomingGreat;\\n            gCount+=becomingGreat;\\n            i += curCount-1; //cus loop does i++\\n        }\\n        return gCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int openForGreatnessCount=0, gCount=0;\\n        for (int i=0; i<nums.length; i++){\\n            int curCount = 1;\\n            while (i+curCount<nums.length && nums[i]==nums[i+curCount]) curCount++;\\n            int becomingGreat = Math.min(openForGreatnessCount,curCount);\\n            openForGreatnessCount +=  curCount-becomingGreat;\\n            gCount+=becomingGreat;\\n            i += curCount-1; //cus loop does i++\\n        }\\n        return gCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474007,
                "title": "two-pointers-python3-plus-sorting-nlogn-o-n-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans=0\\n        n=len(nums)\\n        idx=n-1\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[idx]:ans,idx=ans+1,idx-1\\n      \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans=0\\n        n=len(nums)\\n        idx=n-1\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[idx]:ans,idx=ans+1,idx-1\\n      \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461931,
                "title": "rust-python-go-o-n-with-intuition",
                "content": "# Intuition\\nTo understand the intuition behind linear solution, one has to understand the straight-forward sorting solution. As there are many explantions here, I will refer to them.\\n\\nLets look what happens if we have only unique values. After sorting you have elements $a_1, a_2, ... a_n$. The best ordering will be:\\n\\n - $a_1, a_2, a_3, ..., a_{n-1}, a_n$\\n - $a_2, a_3, a_4, ..., a_{n}, a_1$\\n\\nwhere the score is 1 everywhere except last. So the greatness here is $n - 1$.\\n\\nNow if you have duplicated numbers, you can divide them into groups where each group is as big as possible but without any duplications. You will have $k$ such groups where $k$ is the maximum frequency of duplicated elements. So in total the result will be `len(nums) - max(frequncy_of_elements)`\\n\\n\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$\\n\\n```Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n  pub fn maximize_greatness(nums: Vec<i32>) -> i32 {\\n    let mut freq = HashMap::new();\\n    for n in &nums {\\n      *freq.entry(n).or_insert(0) += 1;\\n    }\\n\\n    let mut max_freq = 0;\\n    for (_, v) in freq {\\n      max_freq = max_freq.max(v);\\n    }\\n\\n    return nums.len() as i32 - max_freq;\\n  }\\n}\\n```\\n```Python []\\nclass Solution:\\n  def maximizeGreatness(self, nums: List[int]) -> int:\\n    return len(nums) - max(Counter(nums).values())\\n```\\n```Go []\\nfunc maximizeGreatness(nums []int) int {\\n  freq := map[int]int{}\\n  for _, v := range nums {\\n    freq[v]++\\n  }\\n\\n  max_freq := 0\\n  for _, v := range freq {\\n    if v > max_freq {\\n      max_freq = v\\n    }\\n  }\\n\\n  return len(nums) - max_freq\\n}\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n  pub fn maximize_greatness(nums: Vec<i32>) -> i32 {\\n    let mut freq = HashMap::new();\\n    for n in &nums {\\n      *freq.entry(n).or_insert(0) += 1;\\n    }\\n\\n    let mut max_freq = 0;\\n    for (_, v) in freq {\\n      max_freq = max_freq.max(v);\\n    }\\n\\n    return nums.len() as i32 - max_freq;\\n  }\\n}\\n```\n```Python []\\nclass Solution:\\n  def maximizeGreatness(self, nums: List[int]) -> int:\\n    return len(nums) - max(Counter(nums).values())\\n```\n```Go []\\nfunc maximizeGreatness(nums []int) int {\\n  freq := map[int]int{}\\n  for _, v := range nums {\\n    freq[v]++\\n  }\\n\\n  max_freq := 0\\n  for _, v := range freq {\\n    if v > max_freq {\\n      max_freq = v\\n    }\\n  }\\n\\n  return len(nums) - max_freq\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458469,
                "title": "2-solutions",
                "content": "**sort**\\n**time: `O(NlogN)`; space: `O(1)`**\\n\\n![image](https://assets.leetcode.com/users/images/387099c9-4964-4b5d-af0e-34d6657fd5fd_1682552055.294677.png)\\n\\n**Why ?**\\n\\n\\uD83D\\uDD35,\\uD83D\\uDFE2 - the numbers we place;\\n\\u2B1C - yet unoccupied placeholders that we place the numbers onto;\\n\\u2B1B - occupied placeholders;\\n`t` - number of uncoccupied placeholders.\\n\\n![image](https://assets.leetcode.com/users/images/16932426-21b0-4295-b534-168627140a5d_1682654795.4676995.png)\\n\\n```\\nint maximizeGreatness(vector<int>& n)\\n{\\n\\tsort(begin(n), end(n));\\n\\tint t{};\\n\\tfor(int i{}, c{}; i<size(n); ++i)\\n\\t\\tt = max(t, c = !i or n[i]==n[i-1] ? c+1 : 1);\\n\\treturn size(n)-t;\\n}\\n```\\n**unordered_map**\\n**time: `O(N)`; space: `O(N)`**\\n\\n![image](https://assets.leetcode.com/users/images/aecde56d-c058-4c0a-af00-fbcbc3c4f8cf_1682553390.0417707.png)\\n\\n```\\nint maximizeGreatness(vector<int>& n)\\n{\\n\\tunordered_map<int, int> m;\\n\\tint t{};\\n\\tfor(const auto & n : n)\\n\\t\\tt = max(t, ++m[n]);\\n\\treturn size(n)-t;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maximizeGreatness(vector<int>& n)\\n{\\n\\tsort(begin(n), end(n));\\n\\tint t{};\\n\\tfor(int i{}, c{}; i<size(n); ++i)\\n\\t\\tt = max(t, c = !i or n[i]==n[i-1] ? c+1 : 1);\\n\\treturn size(n)-t;\\n}\\n```\n```\\nint maximizeGreatness(vector<int>& n)\\n{\\n\\tunordered_map<int, int> m;\\n\\tint t{};\\n\\tfor(const auto & n : n)\\n\\t\\tt = max(t, ++m[n]);\\n\\treturn size(n)-t;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3454159,
                "title": "c-solution-simple-and-easy-sorting-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=0;\\n        int count=0;\\n        while(j<nums.size()){\\n            if(nums[j]>nums[i]){\\n                i+=1;\\n                j+=1;\\n                count+=1;\\n            }\\n            else\\n                j+=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=0;\\n        int count=0;\\n        while(j<nums.size()){\\n            if(nums[j]>nums[i]){\\n                i+=1;\\n                j+=1;\\n                count+=1;\\n            }\\n            else\\n                j+=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437949,
                "title": "simple-solution-time-o-n-log-n-space-o-1",
                "content": "# Complexity\\n- Time complexity: O(n log n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function maximizeGreatness($nums) {\\n        sort($nums);\\n        $count = $i = $j = 0;\\n\\n        while ($i < count($nums))\\n        {\\n            if($nums[$j] < $nums[$i])\\n            {\\n                $count++;\\n                $j++;\\n            }\\n            $i++;\\n        }\\n\\n        return $count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function maximizeGreatness($nums) {\\n        sort($nums);\\n        $count = $i = $j = 0;\\n\\n        while ($i < count($nums))\\n        {\\n            if($nums[$j] < $nums[$i])\\n            {\\n                $count++;\\n                $j++;\\n            }\\n            $i++;\\n        }\\n\\n        return $count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435166,
                "title": "c-multiset-binary-search-upperbound-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        \\n        multiset<int> s;\\n        for(int i=0;i<nums.size();i++){\\n            \\n            s.insert(nums[i]);\\n        }\\n        long long count=0;\\n        for(int i=0;i<nums.size();i++){\\n            \\n            auto it=s.upper_bound(nums[i]);\\n            if(it!=s.end()){\\n                count++;\\n                int num=*it;\\n                s.erase(s.find(num));\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        \\n        multiset<int> s;\\n        for(int i=0;i<nums.size();i++){\\n            \\n            s.insert(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3418896,
                "title": "maximize-greatness-of-an-array",
                "content": "------------- Easy C++ Solution -----------------\\n\\n# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n    int ans = 0;\\n\\n    sort(begin(nums), end(nums));\\n\\n    for (const int num : nums)\\n      if (num > nums[ans])\\n        ++ans;\\n\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n    int ans = 0;\\n\\n    sort(begin(nums), end(nums));\\n\\n    for (const int num : nums)\\n      if (num > nums[ans])\\n        ++ans;\\n\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417814,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n    func maximizeGreatness(_ nums: [Int]) -> Int {\\n        nums.sorted().reduce(into: (0,[Int]())) {$0.1+=[$1];$0.0+=($1>$0.1[$0.0] ? 1:0)}.0\\n    }\\n}\\n```\\n\\n---\\n\\n**One-Liner, expanded and annotated (accepted answer)**\\n```\\nclass Solution {\\n    func maximizeGreatness(_ nums: [Int]) -> Int {\\n        nums.sorted()\\n        .reduce(into: (\\n            result: 0,\\n            arr: [Int]()\\n        )) { data, num in\\n            data.arr.append(num)\\n            data.result += (num > data.arr[data.result] ? 1:0)\\n        }\\n        .result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximizeGreatness(_ nums: [Int]) -> Int {\\n        nums.sorted().reduce(into: (0,[Int]())) {$0.1+=[$1];$0.0+=($1>$0.1[$0.0] ? 1:0)}.0\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func maximizeGreatness(_ nums: [Int]) -> Int {\\n        nums.sorted()\\n        .reduce(into: (\\n            result: 0,\\n            arr: [Int]()\\n        )) { data, num in\\n            data.arr.append(num)\\n            data.result += (num > data.arr[data.result] ? 1:0)\\n        }\\n        .result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417388,
                "title": "two-pointers-approach-cpp-simple-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int ans=0;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=1;\\n        while(i<=n-2&&j<n)\\n        {\\n            if(nums[j]>nums[i])\\n            {\\n                ans++;\\n                i++;\\n                j++;\\n            }\\n            else \\n            {\\n                j++;\\n            }\\n        }\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int ans=0;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=1;\\n        while(i<=n-2&&j<n)\\n        {\\n            if(nums[j]>nums[i])\\n            {\\n                ans++;\\n                i++;\\n                j++;\\n            }\\n            else \\n            {\\n                j++;\\n            }\\n        }\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416358,
                "title": "c-easy-solution-sorting-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst Sort the array so that we can apply binary search\\nFirst find the very first element which is greater than arr[0]\\nthen keep on searching for element which are greater than current element.\\n\\n# Complexity\\n- Time complexity: O(NlogN)+O(logN)+O(n)\\n- Space complexity:   O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int BS(int low,int high,int target,vector<int>arr){\\n        int mid;\\n        while(low<=high){\\n            mid=(high+low)/2;\\n            if(arr[mid]>target && mid-1>=0 && arr[mid-1]==target){\\n                return mid;\\n            }\\n            if(arr[mid]<=target) low=mid+1;\\n            else high=mid-1;\\n        }\\n        return -1;\\n    }\\n    int maximizeGreatness(vector<int>& nums) {\\n        if(nums.size()<=1) return 0;\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        int i=0;\\n        int j=BS(0,nums.size()-1,nums[0],nums);\\n        if(j==-1) return 0;\\n        while(j<nums.size()){\\n            if(nums[i]<nums[j]){ \\n                ans++;\\n                i++;j++;\\n            }else{\\n                while(j<nums.size() && nums[i]>=nums[j]){\\n                    j++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int BS(int low,int high,int target,vector<int>arr){\\n        int mid;\\n        while(low<=high){\\n            mid=(high+low)/2;\\n            if(arr[mid]>target && mid-1>=0 && arr[mid-1]==target){\\n                return mid;\\n            }\\n            if(arr[mid]<=target) low=mid+1;\\n            else high=mid-1;\\n        }\\n        return -1;\\n    }\\n    int maximizeGreatness(vector<int>& nums) {\\n        if(nums.size()<=1) return 0;\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        int i=0;\\n        int j=BS(0,nums.size()-1,nums[0],nums);\\n        if(j==-1) return 0;\\n        while(j<nums.size()){\\n            if(nums[i]<nums[j]){ \\n                ans++;\\n                i++;j++;\\n            }else{\\n                while(j<nums.size() && nums[i]>=nums[j]){\\n                    j++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415698,
                "title": "easy-and-fast-c-code-two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTwo pointer approach\\n# Complexity\\n- Time complexity:\\no(nlogn)(sorting)sor\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n       int i=0,j=1;\\n        while(j<nums.size()){\\n            if(nums[i]<nums[j]){\\n                \\n                i++,j++;\\n            }else {\\n                j++;\\n            }\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n       int i=0,j=1;\\n        while(j<nums.size()){\\n            if(nums[i]<nums[j]){\\n                \\n                i++,j++;\\n            }else {\\n                j++;\\n            }\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393075,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func maximizeGreatness(_ nums: [Int]) -> Int {\\n        \\n        let nums = nums.sorted()\\n        var ni = 0\\n        var pi = 0\\n        var res = 0\\n\\n        while pi < nums.count {\\n            while pi < nums.count, nums[pi] <= nums[ni] { pi += 1 }\\n            guard pi < nums.count, nums[pi] > nums[ni] else { break }\\n\\n            ni += 1\\n            pi += 1\\n            res += 1\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximizeGreatness(_ nums: [Int]) -> Int {\\n        \\n        let nums = nums.sorted()\\n        var ni = 0\\n        var pi = 0\\n        var res = 0\\n\\n        while pi < nums.count {\\n            while pi < nums.count, nums[pi] <= nums[ni] { pi += 1 }\\n            guard pi < nums.count, nums[pi] > nums[ni] else { break }\\n\\n            ni += 1\\n            pi += 1\\n            res += 1\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391603,
                "title": "solution-in-java",
                "content": "# Intuition\\nThink about how to solve it after sorting the array\\n\\n# Approach\\nUsing 2 iterators, try to find the 2nd value(nums[j]) that is lowest greatest value for the 1st value(nums[i]). When found, try to find for the next value in i.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        int i = 0, j = 0, ctr = 0;\\n        Arrays.sort(nums);\\n        while( i < nums.length && j < nums.length){\\n            if(nums[i] < nums[j]){\\n                ctr++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ctr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        int i = 0, j = 0, ctr = 0;\\n        Arrays.sort(nums);\\n        while( i < nums.length && j < nums.length){\\n            if(nums[i] < nums[j]){\\n                ctr++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ctr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386607,
                "title": "c-nice-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nRead code\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int count{0};\\n\\n        sort(nums.begin(), nums.end());\\n\\n        for (int i{0}, j{0}; i < nums.size() && j < nums.size(); i++) {\\n            if (nums[i] > nums[j]) {\\n                count++;\\n                j++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int count{0};\\n\\n        sort(nums.begin(), nums.end());\\n\\n        for (int i{0}, j{0}; i < nums.size() && j < nums.size(); i++) {\\n            if (nums[i] > nums[j]) {\\n                count++;\\n                j++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375782,
                "title": "python-2-approaches-sorting",
                "content": "# Intuition\\nSorting + Pointer\\n\\n# Solution 1\\n# Code\\n```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n\\n        n = len(nums)\\n        nums.sort()\\n        prem = nums\\n\\n        ind = 0\\n        res = 0\\n\\n        for i in range(n):\\n            while ind < n and nums[i] >= prem[ind]:\\n                ind += 1\\n            \\n            if (ind < n and nums[i] < prem[ind]):\\n                res += 1\\n                ind += 1\\n\\n        return res\\n```\\n\\n# Solution 2\\n# Code\\n```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n\\n        n = len(nums)\\n        nums.sort()\\n        prem = nums\\n        ind = 0\\n\\n        for i in nums:\\n            if(i > nums[ind]):\\n                ind += 1\\n\\n        return ind\\n```\\n\\n# Please upvote if you find it useful !!!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n\\n        n = len(nums)\\n        nums.sort()\\n        prem = nums\\n\\n        ind = 0\\n        res = 0\\n\\n        for i in range(n):\\n            while ind < n and nums[i] >= prem[ind]:\\n                ind += 1\\n            \\n            if (ind < n and nums[i] < prem[ind]):\\n                res += 1\\n                ind += 1\\n\\n        return res\\n```\n```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n\\n        n = len(nums)\\n        nums.sort()\\n        prem = nums\\n        ind = 0\\n\\n        for i in nums:\\n            if(i > nums[ind]):\\n                ind += 1\\n\\n        return ind\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375563,
                "title": "very-easy-c-solution-using-constant-space",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int n=nums.size();\\n\\n        <!-- SORT THE ARRAY -->\\n\\n        sort(nums.begin() , nums.end());\\n        int j=0 , ans=0;\\n        for(int i=0;i<n;i++){\\n\\n             <!-- USING UPPER BOUND TO FIND NEXT BIGGER  NUMBER -->\\n\\n             int index = upper_bound(nums.begin()+j+1, nums.end() , nums[i])-nums.begin();\\n             if(index==n) break;\\n             else{\\n                 j=index;\\n                 ans++;\\n             }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int n=nums.size();\\n\\n        <!-- SORT THE ARRAY -->\\n\\n        sort(nums.begin() , nums.end());\\n        int j=0 , ans=0;\\n        for(int i=0;i<n;i++){\\n\\n             <!-- USING UPPER BOUND TO FIND NEXT BIGGER  NUMBER -->\\n\\n             int index = upper_bound(nums.begin()+j+1, nums.end() , nums[i])-nums.begin();\\n             if(index==n) break;\\n             else{\\n                 j=index;\\n                 ans++;\\n             }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373052,
                "title": "c-easy-solution-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=0,n=nums.size(),c=0;\\n        while(j<n){\\n            if(nums[j]>nums[i]){\\n                c+=1;\\n                i+=1,j+=1;\\n            }\\n            else j+=1;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=0,n=nums.size(),c=0;\\n        while(j<n){\\n            if(nums[j]>nums[i]){\\n                c+=1;\\n                i+=1,j+=1;\\n            }\\n            else j+=1;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371960,
                "title": "easiest-java-solution-sorting-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- o(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n\\n        int i = 0;\\n        int j = 1;\\n        int count = 0;\\n        while(i<nums.length && j<nums.length){\\n            if(nums[j]>nums[i]){\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            j++;\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n\\n        int i = 0;\\n        int j = 1;\\n        int count = 0;\\n        while(i<nums.length && j<nums.length){\\n            if(nums[j]>nums[i]){\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            j++;\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370933,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        int n=nums.size();\\n        int i=0;\\n        int j=0;\\n        int ans=0;\\n        while(i<n&&j<n){\\n            \\n            if(nums[i]<nums[j]){ \\n                ans++;\\n                i++;\\n                j++;\\n            }else{\\n                j++;\\n            }\\n            \\n        }\\n    return ans;\\n    }\\n};",
                "solutionTags": [
                    "Array",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        int n=nums.size();\\n        int i=0;\\n        int j=0;\\n        int ans=0;\\n        while(i<n&&j<n){\\n            \\n            if(nums[i]<nums[j]){ \\n                ans++;\\n                i++;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3367506,
                "title": "easy-solution-using-two-pointers",
                "content": "# Approach\\nwe are just sorting the array and checking if their is any element which is greater than current element using two pointers.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=1;\\n        while(j < nums.size()){\\n            if(nums[j] > nums[i])\\n                i++;\\n            j++;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=1;\\n        while(j < nums.size()){\\n            if(nums[j] > nums[i])\\n                i++;\\n            j++;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364501,
                "title": "c-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximizeGreatness(int[] nums) {\\n        var count = 0;\\n        Array.Sort(nums);\\n        for(int i = 0, j = 1; j < nums.Length; j++) {\\n            if(nums[j] > nums[i]) {\\n                count++;\\n                i++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximizeGreatness(int[] nums) {\\n        var count = 0;\\n        Array.Sort(nums);\\n        for(int i = 0, j = 1; j < nums.Length; j++) {\\n            if(nums[j] > nums[i]) {\\n                count++;\\n                i++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359986,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: nlog(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int res = 0,pos=0;\\n        int i=0,j=1;\\n        while(i<A.size() and j<A.size()){          \\n            if(A[i]<A[j]){\\n                res++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                while(j<A.size() and A[i]>=A[j]){\\n                    j++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int res = 0,pos=0;\\n        int i=0,j=1;\\n        while(i<A.size() and j<A.size()){          \\n            if(A[i]<A[j]){\\n                res++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                while(j<A.size() and A[i]>=A[j]){\\n                    j++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359963,
                "title": "two-pointers-with-intuition-java",
                "content": "# Intuition\\n basic two pointer question\\n      // just had to optimize o(n*n) to o(n)/nlogn/logn/1\\n      // logn and 1 are not possible \\n      // so left with o(n) (two pointer/map/etc)  and o(nlogn) (sort/ traverse + log function)  \\n# Approach\\nuse two pointer and start comparing\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) { \\n     int n = nums.length;       \\n      Arrays.sort(nums);\\n      int s = 0; int e = 0;\\n      int res = 0;\\n     while(e<n){\\n          while( e<n && nums[s]==nums[e]) e++;\\n          if(e<n){ res++; \\n          s++;\\n          e++;\\n          }\\n     }\\n       return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) { \\n     int n = nums.length;       \\n      Arrays.sort(nums);\\n      int s = 0; int e = 0;\\n      int res = 0;\\n     while(e<n){\\n          while( e<n && nums[s]==nums[e]) e++;\\n          if(e<n){ res++; \\n          s++;\\n          e++;\\n          }\\n     }\\n       return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358583,
                "title": "java-very-easy-2-pointer-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int c=0,l=0,r=1;\\n        while(r<=nums.length-1)\\n        {\\n            if(nums[l]<nums[r])\\n            {\\n                c+=1;\\n                l+=1;\\n                r+=1;\\n            }\\n            else r+=1;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int c=0,l=0,r=1;\\n        while(r<=nums.length-1)\\n        {\\n            if(nums[l]<nums[r])\\n            {\\n                c+=1;\\n                l+=1;\\n                r+=1;\\n            }\\n            else r+=1;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357141,
                "title": "python-two-pointer",
                "content": "# Intuition\\nAssign every element the next bigger unused element as many times as possible.\\n\\n# Approach\\nsorting + two pointer\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    # two pointer\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        ptr1 = ptr2 = 0\\n        count = 0\\n\\n        while ptr2 < n:\\n            if nums[ptr1] < nums[ptr2]:\\n                ptr1 += 1                \\n                count += 1\\n            ptr2 += 1\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    # two pointer\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        ptr1 = ptr2 = 0\\n        count = 0\\n\\n        while ptr2 < n:\\n            if nums[ptr1] < nums[ptr2]:\\n                ptr1 += 1                \\n                count += 1\\n            ptr2 += 1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355311,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& a) {\\n        sort(a.begin(),a.end());\\n        int l=0, r=0;\\n        while(r<a.size()){\\n            if(a[r++]>a[l]) l++;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& a) {\\n        sort(a.begin(),a.end());\\n        int l=0, r=0;\\n        while(r<a.size()){\\n            if(a[r++]>a[l]) l++;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351262,
                "title": "java-8-lines-solution-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        int arr[] = new int[nums.length];\\n        for(int i = 0,j = 0;i<nums.length;i++){\\n            if(nums[j] < nums[i]){\\n                count++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        int arr[] = new int[nums.length];\\n        for(int i = 0,j = 0;i<nums.length;i++){\\n            if(nums[j] < nums[i]){\\n                count++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349883,
                "title": "c-sliding-window-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        std::sort(nums.begin(), nums.end());\\n        int l = 0, r = 0;\\n        int res = 0;\\n        while (r < nums.size()) {\\n            if (nums[r] > nums[l]) {\\n                r++;\\n                l++;\\n                res++;\\n            } else {\\n                r++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        std::sort(nums.begin(), nums.end());\\n        int l = 0, r = 0;\\n        int res = 0;\\n        while (r < nums.size()) {\\n            if (nums[r] > nums[l]) {\\n                r++;\\n                l++;\\n                res++;\\n            } else {\\n                r++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348967,
                "title": "easiest-approach-o-1-space-used",
                "content": "\\n\\n# Approach\\nFirst sort the array and after that use two pointer approch to find the greatness.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity: O(N logN) + O(N) = O(N logN) -->  basically NlogN complexity for sorting and N for traversal\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n \\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n- Upvote if you like the approch\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n      int greatness = 0;\\n      sort(nums.begin() , nums.end());\\n      int i = 0 , j = 1;\\n\\n      while(j < nums.size()){\\n          if(nums[i] < nums[j]){\\n              greatness++;\\n              i++;\\n              j++;\\n          }\\n          else j++;\\n      }\\n\\n      return greatness;\\n\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n      int greatness = 0;\\n      sort(nums.begin() , nums.end());\\n      int i = 0 , j = 1;\\n\\n      while(j < nums.size()){\\n          if(nums[i] < nums[j]){\\n              greatness++;\\n              i++;\\n              j++;\\n          }\\n          else j++;\\n      }\\n\\n      return greatness;\\n\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348728,
                "title": "sorting-two-pointer-easy-c",
                "content": "# Intuition\\nTwo pointer and sorting \\n\\n# Approach\\nSort the array, keep the two pointers at the start and for every iteration if the number at ptr2 > ptr1, increase the ptr1 and the count(ans) and increase the ptr2 in every iteration so as to move forward\\n\\n# Complexity\\n- Time complexity: O(nlogn), n is the size of the array \\n\\n- Space complexity: O(1), no extra space taken \\n\\n# Code\\n```\\n// #include <bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        //using sorting and two pointer approach \\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int ptr1 = 0, ptr2 = 0, ans = 0;\\n        while(ptr2 < n){\\n            if(nums[ptr2] > nums[ptr1]){\\n                ptr1++;\\n                ans++;\\n            }\\n            ptr2++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\n// #include <bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        //using sorting and two pointer approach \\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int ptr1 = 0, ptr2 = 0, ans = 0;\\n        while(ptr2 < n){\\n            if(nums[ptr2] > nums[ptr1]){\\n                ptr1++;\\n                ans++;\\n            }\\n            ptr2++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3348429,
                "title": "python-two-approaches-easy-understanding",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo Pointer Approach\\n# Complexity\\n- Time complexity: `O(NLogN)`\\n\\n- Space complexity: `O(N)`\\n# Code\\n```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        n = len(nums); \\n        if n == 1: return 0\\n        nums.sort(); i = 0; j = 1; cnt = 0;\\n        while j < n and i < n:\\n            if nums[i] < nums[j]:\\n                cnt += 1;\\n                i += 1; j += 1;\\n            else:\\n                j += 1;\\n        return cnt;\\n```\\n# **2nd Method**\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing SortedList\\n\\n# Complexity\\n- Time complexity:   `O(NLogNLogn);  SortedList - NLogN, remove - LogN `\\n\\n - Space complexity:`O(N)`\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList as sl\\nfrom bisect import bisect as upr\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        nums.sort(); arr = sl(nums); n = len(nums); cnt = 0; i = 0;\\n        while n > 1:\\n            try:\\n                index = upr(arr, nums[i], 0, n);\\n                if index > n-1: break;\\n                cnt += 1; arr.remove(arr[index]);\\n                n -= 1; i += 1;\\n            except Exception:\\n                break\\n        return cnt\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        n = len(nums); \\n        if n == 1: return 0\\n        nums.sort(); i = 0; j = 1; cnt = 0;\\n        while j < n and i < n:\\n            if nums[i] < nums[j]:\\n                cnt += 1;\\n                i += 1; j += 1;\\n            else:\\n                j += 1;\\n        return cnt;\\n```\n```\\nfrom sortedcontainers import SortedList as sl\\nfrom bisect import bisect as upr\\nclass Solution:\\n    def maximizeGreatness(self, nums: List[int]) -> int:\\n        nums.sort(); arr = sl(nums); n = len(nums); cnt = 0; i = 0;\\n        while n > 1:\\n            try:\\n                index = upr(arr, nums[i], 0, n);\\n                if index > n-1: break;\\n                cnt += 1; arr.remove(arr[index]);\\n                n -= 1; i += 1;\\n            except Exception:\\n                break\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346854,
                "title": "esay-to-understand-piece-of-cake",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->/1.sort the arr\\n       // 2.have cur pointer \\n       // 3 cal the ans\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        //1.sort the arr\\n       // 2.have cur pointer \\n       // 3 cal the ans\\n        int n=nums.size(),ans=0;\\n       sort(nums.begin(),nums.end());\\n       int cur=0; \\n       for(int i=0;i<nums.size();i++){\\n           while(cur<n and nums[cur] <=nums[i]) cur++; //the the cur pointerr until you find thsi  nums[cur] >nums[i]\\n           if(cur<n){\\n               ans++;\\n               cur++;\\n           }\\n       }\\n       return ans;\\n\\n    }\\n};\\n\\n```\\n![download.jfif](https://assets.leetcode.com/users/images/6d02ed5a-f6fd-47b9-87aa-70356400e747_1679904170.5833669.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        //1.sort the arr\\n       // 2.have cur pointer \\n       // 3 cal the ans\\n        int n=nums.size(),ans=0;\\n       sort(nums.begin(),nums.end());\\n       int cur=0; \\n       for(int i=0;i<nums.size();i++){\\n           while(cur<n and nums[cur] <=nums[i]) cur++; //the the cur pointerr until you find thsi  nums[cur] >nums[i]\\n           if(cur<n){\\n               ans++;\\n               cur++;\\n           }\\n       }\\n       return ans;\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342665,
                "title": "greedy-sorting-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int maximizeGreatness(vector<int>& nums) \\n    {\\n        vector<int> t=nums;\\n        sort(t.begin(),t.end());\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size(), cnt=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            int p=upper_bound(t.begin(),t.end(),nums[x])-t.begin();\\n            if(p>=0 && p<n)\\n            {\\n                cnt++;\\n                t[p]=-1;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maximizeGreatness(vector<int>& nums) \\n    {\\n        vector<int> t=nums;\\n        sort(t.begin(),t.end());\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size(), cnt=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            int p=upper_bound(t.begin(),t.end(),nums[x])-t.begin();\\n            if(p>=0 && p<n)\\n            {\\n                cnt++;\\n                t[p]=-1;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340985,
                "title": "very-simple-and-best-easy-explanation-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor a given array, say [1,2,4,5,6]:\\n> To ensure max greatness I need to have just greater element than a given element at the corresponding index\\ni.e. for (1) I should have 2 in perm[] and for 2 should have 3\\nIn this way more elements can be covered\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# First thing to do is Sort \\n> Then maintain two pointers where:\\nPointer 1 is pointing to first index i.e. smallest element\\nand Pointer 2 to element just greater than that \\nthen increment both pointers and check if elements corresponding to both satisfy this property or  not\\n\\n> do until Pointer 2 does not point to end of vector\\nFinally elements upto Pointer 1 will be the answer\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(sort)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(Constant)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int n=nums.size();\\n\\n        sort(nums.begin(),nums.end());\\n\\n        //goal is that for a particular value present at an index i \\n        //I am supposed to find just greater element in the vector\\n        //move two pointers further\\n\\n        int i=0;int j=i;\\n        while(j<n)\\n        {\\n            while(j<n and nums[j]<=nums[i])\\n            {\\n                j++;\\n            }\\n            if(j==n)\\n            {\\n                break;\\n            }\\n            i++;j++;\\n        }\\n\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeGreatness(vector<int>& nums) {\\n        int n=nums.size();\\n\\n        sort(nums.begin(),nums.end());\\n\\n        //goal is that for a particular value present at an index i \\n        //I am supposed to find just greater element in the vector\\n        //move two pointers further\\n\\n        int i=0;int j=i;\\n        while(j<n)\\n        {\\n            while(j<n and nums[j]<=nums[i])\\n            {\\n                j++;\\n            }\\n            if(j==n)\\n            {\\n                break;\\n            }\\n            i++;j++;\\n        }\\n\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340026,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int MaximizeGreatness(int[] nums) {\\n        Array.Sort(nums);\\n        Array.Reverse(nums);\\n        int[] dup = nums;\\n        int n = nums.Length;\\n        int res = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] < dup[res])\\n                res++;\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int MaximizeGreatness(int[] nums) {\\n        Array.Sort(nums);\\n        Array.Reverse(nums);\\n        int[] dup = nums;\\n        int n = nums.Length;\\n        int res = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] < dup[res])\\n                res++;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1836322,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "ignore the \\uD83D\\uDC02\\uD83D\\uDCA9written in the problem statement about the perm array...\\nJust focus on counting 1 by 1 the next one and only greater element for that particular element( IMP= just count it once don\\'t look for another  greater element )."
                    },
                    {
                        "username": "user3954sk",
                        "content": "O(nlogn) is accepted, but if you want more of a challenge, there is a less obvious O(n) solution to find."
                    },
                    {
                        "username": "ruslans_al",
                        "content": "Do you have a proof for that solution? It seems to really work, but nothing comes to mind concerning why it works.\n\nUPD: nevermind, I realized that the proof is easy."
                    },
                    {
                        "username": "brinuke",
                        "content": "You\\'re right, it is not necessary to use sorting here. The official hint is for freshmen."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The description of this problem is what makes it a medium..."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Sort the Array.\\nIn the sorted array take two pointers i and j and start comparing and find out the first number which is greater than nums[i]. Once found start incrementing the counter variable and i pointer.\\nReturn count;\\n\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n\\n       Arrays.sort(nums);\\n       int i = 0;\\n       int j = 0;\\n       int count = 0;\\n       while(j<nums.length){\\n           if(nums[i]<nums[j]){\\n               count++;\\n               i++;\\n           }\\n           j++;\\n       }\\n       return count;\\n    }\\n}"
                    },
                    {
                        "username": "404_abhi",
                        "content": "Rather than maintaining two pointers,you can just sort the array and increment the counter if current element is greater than greatest element found so far.\\n\\nNote:-do not post solution under discussion,just your approach to solve the problem will be helpful \\uD83D\\uDE03"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "how tf this is a two pointer related problem?"
                    },
                    {
                        "username": "wf5432",
                        "content": "[870. Advantage Shuffle](https://leetcode.com/problems/advantage-shuffle/) is almost the same question, but with two arrays."
                    }
                ]
            },
            {
                "id": 1836531,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "ignore the \\uD83D\\uDC02\\uD83D\\uDCA9written in the problem statement about the perm array...\\nJust focus on counting 1 by 1 the next one and only greater element for that particular element( IMP= just count it once don\\'t look for another  greater element )."
                    },
                    {
                        "username": "user3954sk",
                        "content": "O(nlogn) is accepted, but if you want more of a challenge, there is a less obvious O(n) solution to find."
                    },
                    {
                        "username": "ruslans_al",
                        "content": "Do you have a proof for that solution? It seems to really work, but nothing comes to mind concerning why it works.\n\nUPD: nevermind, I realized that the proof is easy."
                    },
                    {
                        "username": "brinuke",
                        "content": "You\\'re right, it is not necessary to use sorting here. The official hint is for freshmen."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The description of this problem is what makes it a medium..."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Sort the Array.\\nIn the sorted array take two pointers i and j and start comparing and find out the first number which is greater than nums[i]. Once found start incrementing the counter variable and i pointer.\\nReturn count;\\n\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n\\n       Arrays.sort(nums);\\n       int i = 0;\\n       int j = 0;\\n       int count = 0;\\n       while(j<nums.length){\\n           if(nums[i]<nums[j]){\\n               count++;\\n               i++;\\n           }\\n           j++;\\n       }\\n       return count;\\n    }\\n}"
                    },
                    {
                        "username": "404_abhi",
                        "content": "Rather than maintaining two pointers,you can just sort the array and increment the counter if current element is greater than greatest element found so far.\\n\\nNote:-do not post solution under discussion,just your approach to solve the problem will be helpful \\uD83D\\uDE03"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "how tf this is a two pointer related problem?"
                    },
                    {
                        "username": "wf5432",
                        "content": "[870. Advantage Shuffle](https://leetcode.com/problems/advantage-shuffle/) is almost the same question, but with two arrays."
                    }
                ]
            },
            {
                "id": 1966099,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "ignore the \\uD83D\\uDC02\\uD83D\\uDCA9written in the problem statement about the perm array...\\nJust focus on counting 1 by 1 the next one and only greater element for that particular element( IMP= just count it once don\\'t look for another  greater element )."
                    },
                    {
                        "username": "user3954sk",
                        "content": "O(nlogn) is accepted, but if you want more of a challenge, there is a less obvious O(n) solution to find."
                    },
                    {
                        "username": "ruslans_al",
                        "content": "Do you have a proof for that solution? It seems to really work, but nothing comes to mind concerning why it works.\n\nUPD: nevermind, I realized that the proof is easy."
                    },
                    {
                        "username": "brinuke",
                        "content": "You\\'re right, it is not necessary to use sorting here. The official hint is for freshmen."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The description of this problem is what makes it a medium..."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Sort the Array.\\nIn the sorted array take two pointers i and j and start comparing and find out the first number which is greater than nums[i]. Once found start incrementing the counter variable and i pointer.\\nReturn count;\\n\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n\\n       Arrays.sort(nums);\\n       int i = 0;\\n       int j = 0;\\n       int count = 0;\\n       while(j<nums.length){\\n           if(nums[i]<nums[j]){\\n               count++;\\n               i++;\\n           }\\n           j++;\\n       }\\n       return count;\\n    }\\n}"
                    },
                    {
                        "username": "404_abhi",
                        "content": "Rather than maintaining two pointers,you can just sort the array and increment the counter if current element is greater than greatest element found so far.\\n\\nNote:-do not post solution under discussion,just your approach to solve the problem will be helpful \\uD83D\\uDE03"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "how tf this is a two pointer related problem?"
                    },
                    {
                        "username": "wf5432",
                        "content": "[870. Advantage Shuffle](https://leetcode.com/problems/advantage-shuffle/) is almost the same question, but with two arrays."
                    }
                ]
            },
            {
                "id": 1887942,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "ignore the \\uD83D\\uDC02\\uD83D\\uDCA9written in the problem statement about the perm array...\\nJust focus on counting 1 by 1 the next one and only greater element for that particular element( IMP= just count it once don\\'t look for another  greater element )."
                    },
                    {
                        "username": "user3954sk",
                        "content": "O(nlogn) is accepted, but if you want more of a challenge, there is a less obvious O(n) solution to find."
                    },
                    {
                        "username": "ruslans_al",
                        "content": "Do you have a proof for that solution? It seems to really work, but nothing comes to mind concerning why it works.\n\nUPD: nevermind, I realized that the proof is easy."
                    },
                    {
                        "username": "brinuke",
                        "content": "You\\'re right, it is not necessary to use sorting here. The official hint is for freshmen."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The description of this problem is what makes it a medium..."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Sort the Array.\\nIn the sorted array take two pointers i and j and start comparing and find out the first number which is greater than nums[i]. Once found start incrementing the counter variable and i pointer.\\nReturn count;\\n\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n\\n       Arrays.sort(nums);\\n       int i = 0;\\n       int j = 0;\\n       int count = 0;\\n       while(j<nums.length){\\n           if(nums[i]<nums[j]){\\n               count++;\\n               i++;\\n           }\\n           j++;\\n       }\\n       return count;\\n    }\\n}"
                    },
                    {
                        "username": "404_abhi",
                        "content": "Rather than maintaining two pointers,you can just sort the array and increment the counter if current element is greater than greatest element found so far.\\n\\nNote:-do not post solution under discussion,just your approach to solve the problem will be helpful \\uD83D\\uDE03"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "how tf this is a two pointer related problem?"
                    },
                    {
                        "username": "wf5432",
                        "content": "[870. Advantage Shuffle](https://leetcode.com/problems/advantage-shuffle/) is almost the same question, but with two arrays."
                    }
                ]
            },
            {
                "id": 2057689,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "ignore the \\uD83D\\uDC02\\uD83D\\uDCA9written in the problem statement about the perm array...\\nJust focus on counting 1 by 1 the next one and only greater element for that particular element( IMP= just count it once don\\'t look for another  greater element )."
                    },
                    {
                        "username": "user3954sk",
                        "content": "O(nlogn) is accepted, but if you want more of a challenge, there is a less obvious O(n) solution to find."
                    },
                    {
                        "username": "ruslans_al",
                        "content": "Do you have a proof for that solution? It seems to really work, but nothing comes to mind concerning why it works.\n\nUPD: nevermind, I realized that the proof is easy."
                    },
                    {
                        "username": "brinuke",
                        "content": "You\\'re right, it is not necessary to use sorting here. The official hint is for freshmen."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The description of this problem is what makes it a medium..."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Sort the Array.\\nIn the sorted array take two pointers i and j and start comparing and find out the first number which is greater than nums[i]. Once found start incrementing the counter variable and i pointer.\\nReturn count;\\n\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n\\n       Arrays.sort(nums);\\n       int i = 0;\\n       int j = 0;\\n       int count = 0;\\n       while(j<nums.length){\\n           if(nums[i]<nums[j]){\\n               count++;\\n               i++;\\n           }\\n           j++;\\n       }\\n       return count;\\n    }\\n}"
                    },
                    {
                        "username": "404_abhi",
                        "content": "Rather than maintaining two pointers,you can just sort the array and increment the counter if current element is greater than greatest element found so far.\\n\\nNote:-do not post solution under discussion,just your approach to solve the problem will be helpful \\uD83D\\uDE03"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "how tf this is a two pointer related problem?"
                    },
                    {
                        "username": "wf5432",
                        "content": "[870. Advantage Shuffle](https://leetcode.com/problems/advantage-shuffle/) is almost the same question, but with two arrays."
                    }
                ]
            },
            {
                "id": 1922917,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "ignore the \\uD83D\\uDC02\\uD83D\\uDCA9written in the problem statement about the perm array...\\nJust focus on counting 1 by 1 the next one and only greater element for that particular element( IMP= just count it once don\\'t look for another  greater element )."
                    },
                    {
                        "username": "user3954sk",
                        "content": "O(nlogn) is accepted, but if you want more of a challenge, there is a less obvious O(n) solution to find."
                    },
                    {
                        "username": "ruslans_al",
                        "content": "Do you have a proof for that solution? It seems to really work, but nothing comes to mind concerning why it works.\n\nUPD: nevermind, I realized that the proof is easy."
                    },
                    {
                        "username": "brinuke",
                        "content": "You\\'re right, it is not necessary to use sorting here. The official hint is for freshmen."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The description of this problem is what makes it a medium..."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Sort the Array.\\nIn the sorted array take two pointers i and j and start comparing and find out the first number which is greater than nums[i]. Once found start incrementing the counter variable and i pointer.\\nReturn count;\\n\\nclass Solution {\\n    public int maximizeGreatness(int[] nums) {\\n\\n       Arrays.sort(nums);\\n       int i = 0;\\n       int j = 0;\\n       int count = 0;\\n       while(j<nums.length){\\n           if(nums[i]<nums[j]){\\n               count++;\\n               i++;\\n           }\\n           j++;\\n       }\\n       return count;\\n    }\\n}"
                    },
                    {
                        "username": "404_abhi",
                        "content": "Rather than maintaining two pointers,you can just sort the array and increment the counter if current element is greater than greatest element found so far.\\n\\nNote:-do not post solution under discussion,just your approach to solve the problem will be helpful \\uD83D\\uDE03"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "how tf this is a two pointer related problem?"
                    },
                    {
                        "username": "wf5432",
                        "content": "[870. Advantage Shuffle](https://leetcode.com/problems/advantage-shuffle/) is almost the same question, but with two arrays."
                    }
                ]
            }
        ]
    }
]