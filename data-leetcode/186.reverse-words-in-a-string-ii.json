[
    {
        "title": "Partition List",
        "question_content": "Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\nYou should preserve the original relative order of the nodes in each of the two partitions.\n&nbsp;\nExample 1:\n\nInput: head = [1,4,3,2,5,2], x = 3\nOutput: [1,2,2,4,3,5]\n\nExample 2:\n\nInput: head = [2,1], x = 2\nOutput: [1,2]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the list is in the range [0, 200].\n\t-100 <= Node.val <= 100\n\t-200 <= x <= 200",
        "solutions": [
            {
                "id": 29185,
                "title": "very-concise-one-pass-solution",
                "content": "    ListNode *partition(ListNode *head, int x) {\\n        ListNode node1(0), node2(0);\\n        ListNode *p1 = &node1, *p2 = &node2;\\n        while (head) {\\n            if (head->val < x)\\n                p1 = p1->next = head;\\n            else\\n                p2 = p2->next = head;\\n            head = head->next;\\n        }\\n        p2->next = NULL;\\n        p1->next = node2.next;\\n        return node1.next;\\n    }",
                "solutionTags": [],
                "code": "    ListNode *partition(ListNode *head, int x) {\\n        ListNode node1(0), node2(0);\\n        ListNode *p1 = &node1, *p2 = &node2;\\n        while (head) {\\n            if (head->val < x)\\n                p1 = p1->next = head;\\n            else\\n                p2 = p2->next = head;\\n            head = head->next;\\n        }\\n        p2->next = NULL;\\n        p1->next = node2.next;\\n        return node1.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 29183,
                "title": "concise-java-code-with-explanation-one-pass",
                "content": "the basic idea is to maintain two queues, the first one stores all nodes with val less than x , and the second queue stores all the rest nodes. Then concat these two queues. Remember to set the tail of second queue a null next, or u will get TLE.\\n\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode dummy1 = new ListNode(0), dummy2 = new ListNode(0);  //dummy heads of the 1st and 2nd queues\\n        ListNode curr1 = dummy1, curr2 = dummy2;      //current tails of the two queues;\\n        while (head!=null){\\n            if (head.val<x) {\\n                curr1.next = head;\\n                curr1 = head;\\n            }else {\\n                curr2.next = head;\\n                curr2 = head;\\n            }\\n            head = head.next;\\n        }\\n        curr2.next = null;          //important! avoid cycle in linked list. otherwise u will get TLE.\\n        curr1.next = dummy2.next;\\n        return dummy1.next;\\n    }",
                "solutionTags": [],
                "code": "the basic idea is to maintain two queues, the first one stores all nodes with val less than x , and the second queue stores all the rest nodes. Then concat these two queues. Remember to set the tail of second queue a null next, or u will get TLE.\\n\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode dummy1 = new ListNode(0), dummy2 = new ListNode(0);  //dummy heads of the 1st and 2nd queues\\n        ListNode curr1 = dummy1, curr2 = dummy2;      //current tails of the two queues;\\n        while (head!=null){\\n            if (head.val<x) {\\n                curr1.next = head;\\n                curr1 = head;\\n            }else {\\n                curr2.next = head;\\n                curr2 = head;\\n            }\\n            head = head.next;\\n        }\\n        curr2.next = null;          //important! avoid cycle in linked list. otherwise u will get TLE.\\n        curr1.next = dummy2.next;\\n        return dummy1.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2315494,
                "title": "java-c-detailed-explanation",
                "content": "So, this problem is super-easy trust me. Only if you know the Basics of LinkedList. \\n```\\nAnyways, Ladies-N-Gentlemen let\\'s understand this problem\\n```\\n\\nLet\\'s understand what  the problem is saying, first of all.\\n> We have given a list and a value **x**, we have to partion the list in such that smaller value then **x** comes to **left** & greater or equals to **right**. \\n\\nSo, to do that. One clear thing is coming up in your mind, Why don\\'t we create **2 sublists**.\\n* **Left dummy linked list**\\n* **Right dummy linked list**\\n\\nI mean yes, we are doing that. You guy\\'s are clever. And if you all have think about this as well, **`Left will have values smaller then x`** & **`Right will have value greater or equal to x`**.\\n\\nSo, let\\'s take an example and solve this problem.\\n\\n```\\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\n```\\n\\n**Let\\'s understand it visually ;**\\n\\n![image](https://assets.leetcode.com/users/images/e64ba2fb-18b3-461b-bec1-a886109e913b_1658458237.6596422.gif)\\n\\n\\nNow as you can see when we have seperated the list\\'s as per the questions, our final job is to merge them into one list.\\n\\nSo, to do that what we gonna do is, tecnically **`left list`** end i.e. **2** is pointing to **`null`** and **`right list`** end i.e. **5** pointing to **`2`**. But we want **`2`** to point to the beginning of **`right list`** not null.\\nif we do that we will create a infine[never ending] loop. **Let\\'s see what am talking about**\\n\\n![image](https://assets.leetcode.com/users/images/ba24a36f-f73a-4398-95a8-2e21b8198d07_1658459944.800071.gif)\\n\\n\\nTo, solve this issue what we gonna do is, we want the **`right list`** **5** to point to **null** not to **2**. If we do that then, out list will look\\'s like this:\\n![image](https://assets.leetcode.com/users/images/774f4663-93da-40c3-ad95-16b14bd85ad6_1658458969.4673235.png)\\n\\nAnd by doing that we will get our final list, as shown in the question that\\'s what we want.\\n\\nNow, **ladies-n-gentlemen** let\\'s code this solution\\n\\n**Java**\\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode left = new ListNode(0);\\n        ListNode right = new ListNode(0);\\n        \\n        ListNode leftTail = left;\\n        ListNode rightTail = right;\\n        \\n        while(head != null){\\n            if(head.val < x){\\n                leftTail.next = head;\\n                leftTail = leftTail.next;\\n            }\\n            else{\\n                rightTail.next = head;\\n                rightTail = rightTail.next;\\n            }\\n            head = head.next;\\n        }\\n        \\n        leftTail.next = right.next;\\n        rightTail.next = null;\\n        \\n        return left.next;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *left = new ListNode(0);\\n        ListNode *right = new ListNode(0);\\n        \\n        ListNode *leftTail = left;\\n        ListNode *rightTail = right;\\n        \\n        while(head != NULL){\\n            if(head->val < x){\\n                leftTail->next = head;\\n                leftTail = leftTail->next;\\n            }\\n            else{\\n                rightTail->next = head;\\n                rightTail = rightTail->next;\\n            }\\n            head = head->next;\\n        }\\n        \\n        leftTail->next = right->next;\\n        rightTail->next = NULL;\\n        \\n        return left->next;\\n    }\\n};\\n```\\nANALYSIS:-\\n* **Time Complexity :-** **`BigO(N)`**\\n\\n* **Space Complexity :-** **`BigO(1)`**",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nAnyways, Ladies-N-Gentlemen let\\'s understand this problem\\n```\n```\\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\n```\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode left = new ListNode(0);\\n        ListNode right = new ListNode(0);\\n        \\n        ListNode leftTail = left;\\n        ListNode rightTail = right;\\n        \\n        while(head != null){\\n            if(head.val < x){\\n                leftTail.next = head;\\n                leftTail = leftTail.next;\\n            }\\n            else{\\n                rightTail.next = head;\\n                rightTail = rightTail.next;\\n            }\\n            head = head.next;\\n        }\\n        \\n        leftTail.next = right.next;\\n        rightTail.next = null;\\n        \\n        return left.next;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *left = new ListNode(0);\\n        ListNode *right = new ListNode(0);\\n        \\n        ListNode *leftTail = left;\\n        ListNode *rightTail = right;\\n        \\n        while(head != NULL){\\n            if(head->val < x){\\n                leftTail->next = head;\\n                leftTail = leftTail->next;\\n            }\\n            else{\\n                rightTail->next = head;\\n                rightTail = rightTail->next;\\n            }\\n            head = head->next;\\n        }\\n        \\n        leftTail->next = right->next;\\n        rightTail->next = NULL;\\n        \\n        return left->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29174,
                "title": "python-concise-solution-with-dummy-nodes",
                "content": "        \\n    def partition(self, head, x):\\n        h1 = l1 = ListNode(0)\\n        h2 = l2 = ListNode(0)\\n        while head:\\n            if head.val < x:\\n                l1.next = head\\n                l1 = l1.next\\n            else:\\n                l2.next = head\\n                l2 = l2.next\\n            head = head.next\\n        l2.next = None\\n        l1.next = h2.next\\n        return h1.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def partition(self, head, x):\\n        h1 = l1 = ListNode(0)\\n        h2 = l2 = ListNode(0)\\n        while head:\\n            if head.val < x:\\n                l1.next = head\\n                l1 = l1.next\\n            else:\\n                l2.next = head\\n                l2 = l2.next\\n            head = head.next\\n        l2.next = None\\n        l1.next = h2.next\\n        return h1.next",
                "codeTag": "Python3"
            },
            {
                "id": 3910837,
                "title": "100-two-pointer-video-linked-list-visualization-optimal",
                "content": "# Problem Understanding\\n\\nIn the \"Partition a Linked List Around a Value\" problem, we are provided with the head of a linked list and a value `x`. The task is to rearrange the linked list such that all nodes with values less than `x` come before nodes with values greater than or equal to `x`. A key point is that the original relative order of the nodes in each of the two partitions must be preserved.\\n\\nConsider the linked list `head = [1,4,3,2,5,2]` and `x = 3`. The expected output after partitioning is `[1,2,2,4,3,5]`.\\n\\n---\\n\\n# Live Coding & Logic in Python\\nhttps://youtu.be/q-JTT8Ole6M\\n\\n## Coding in:\\n- [\\uD83D\\uDC0D Python](https://youtu.be/q-JTT8Ole6M)\\n- [\\uD83E\\uDD80 Rust](https://youtu.be/OOw-mP8T2AE)\\n- [\\uD83D\\uDC39 Go](https://youtu.be/d-1OTX26qdo)\\n\\n# Approach: Two Pointer Technique with Dummy Nodes\\n\\nThe idea is to use two pointers (or references) to create two separate linked lists: \\n1. One for nodes with values less than `x`\\n2. Another for nodes with values greater than or equal to `x`\\n\\nAt the end, we can combine the two linked lists to get the desired result.\\n\\n## Key Data Structures:\\n- **Linked List**: We work directly with the given linked list nodes.\\n- **Dummy Nodes**: Two dummy nodes are used to create the starting point for the two partitions.\\n\\n## Step-by-step Breakdown:\\n\\n1. **Initialization**:\\n   - Create two dummy nodes: `before` and `after`.\\n   - Initialize two pointers `before_curr` and `after_curr` at the dummy nodes.\\n   \\n2. **Traversal & Partition**:\\n   - Traverse the linked list with the given `head`.\\n   - For each node, if its value is less than `x`, attach it to the `before` list. Otherwise, attach it to the `after` list.\\n   \\n3. **Merging**:\\n   - After traversing the entire list, append the `after` list to the `before` list to form the partitioned linked list.\\n\\n4. **Result**:\\n   - Return the next node of the `before` dummy node as the new head of the partitioned list.\\n\\n# Example - Visualization:\\nBased on the provided example with the linked list `head = [1,4,3,2,5,2]` and `x = 3`, here\\'s the step-by-step evolution of the `before`, `after`, and `head` lists:\\n\\n![viz_van.png](https://assets.leetcode.com/users/images/a9dac623-2c22-479c-9392-e6b35e3416a5_1692060627.6065295.png)\\n\\n1. After processing node with value `1`:\\n    - `head`: [1, 4, 3, 2, 5, 2]\\n    - `before`: [0, 1]\\n    - `after`: [0]\\n\\n2. After processing node with value `4`:\\n    - `head`: [4, 3, 2, 5, 2]\\n    - `before`: [0, 1]\\n    - `after`: [0, 4]\\n\\n3. After processing node with value `3`:\\n    - `head`: [3, 2, 5, 2]\\n    - `before`: [0, 1]\\n    - `after`: [0, 4, 3]\\n\\n4. After processing node with value `2`:\\n    - `head`: [2, 5, 2]\\n    - `before`: [0, 1, 2]\\n    - `after`: [0, 4, 3]\\n\\n5. After processing node with value `5`:\\n    - `head`: [5, 2]\\n    - `before`: [0, 1, 2]\\n    - `after`: [0, 4, 3, 5]\\n\\n6. After processing node with value `2`:\\n    - `head`: [2]\\n    - `before`: [0, 1, 2, 2]\\n    - `after`: [0, 4, 3, 5]\\n\\nFinally, after merging the `before` and `after` lists, the result is: `[1,2,2,4,3,5]`\\n\\n# Complexity:\\n\\n**Time Complexity:** $$O(n)$$\\n- We traverse the linked list once, making the time complexity linear in the size of the list.\\n\\n**Space Complexity:** $$O(1)$$\\n- We use constant extra space since we are only creating two dummy nodes and reusing the existing nodes in the linked list.\\n\\n# Performance:\\n\\nGiven the constraints, this solution is optimal and will efficiently handle linked lists of size up to 200 nodes.\\n\\n| Language   | Runtime (ms) | Runtime Beat (%) | Memory (MB) | Memory Beat (%) |\\n|------------|--------------|------------------|-------------|-----------------|\\n| **Rust**       | 0            | 100%             | 1.9         | 100%            |\\n| **Go**         | 0            | 100%            | 2.4         | 98.48%          |\\n| **C++**        | 0            | 100%             | 10.2        | 48.14%          |\\n| **Java**       | 0            | 100%             | 40.8        | 83.63%          |\\n| **Python3**    | 32           | 98.81%           | 16.4        | 55.72%          |\\n| **JavaScript** | 45           | 98.36%           | 44.3        | 12.30%          |\\n| **C#**         | 82           | 67.18%           | 39          | 64.10%          |\\n\\n![v2.png](https://assets.leetcode.com/users/images/c524fce6-73ab-41f7-a627-4f18b40fb965_1692069418.268467.png)\\n\\n\\n# Code\\n``` Python []\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        before, after = ListNode(0), ListNode(0)\\n        before_curr, after_curr = before, after\\n        \\n        while head:\\n            if head.val < x:\\n                before_curr.next, before_curr = head, head\\n            else:\\n                after_curr.next, after_curr = head, head\\n            head = head.next\\n        \\n        after_curr.next = None\\n        before_curr.next = after.next\\n        \\n        return before.next\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode before(0), after(0);\\n        ListNode* before_curr = &before;\\n        ListNode* after_curr = &after;\\n        \\n        while(head) {\\n            if(head->val < x) {\\n                before_curr->next = head;\\n                before_curr = head;\\n            } else {\\n                after_curr->next = head;\\n                after_curr = head;\\n            }\\n            head = head->next;\\n        }\\n        \\n        after_curr->next = nullptr;\\n        before_curr->next = after.next;\\n        \\n        return before.next;\\n    }\\n};\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn partition(mut head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\\n        let mut before = ListNode::new(0);\\n        let mut after = ListNode::new(0);\\n        let mut before_tail = &mut before;\\n        let mut after_tail = &mut after;\\n\\n        while let Some(mut node) = head {\\n            head = node.next.take();\\n            if node.val < x {\\n                before_tail.next = Some(node);\\n                before_tail = before_tail.next.as_mut().unwrap();\\n            } else {\\n                after_tail.next = Some(node);\\n                after_tail = after_tail.next.as_mut().unwrap();\\n            }\\n        }\\n\\n        before_tail.next = after.next.take();\\n\\n        before.next\\n    }\\n}\\n```\\n``` Go []\\nfunc partition(head *ListNode, x int) *ListNode {\\n    before := &ListNode{}\\n    after := &ListNode{}\\n    before_curr := before\\n    after_curr := after\\n    \\n    for head != nil {\\n        if head.Val < x {\\n            before_curr.Next = head\\n            before_curr = before_curr.Next\\n        } else {\\n            after_curr.Next = head\\n            after_curr = after_curr.Next\\n        }\\n        head = head.Next\\n    }\\n    \\n    after_curr.Next = nil\\n    before_curr.Next = after.Next\\n    \\n    return before.Next\\n}\\n```\\n``` Java []\\npublic class Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode before = new ListNode(0);\\n        ListNode after = new ListNode(0);\\n        ListNode before_curr = before;\\n        ListNode after_curr = after;\\n        \\n        while(head != null) {\\n            if(head.val < x) {\\n                before_curr.next = head;\\n                before_curr = before_curr.next;\\n            } else {\\n                after_curr.next = head;\\n                after_curr = after_curr.next;\\n            }\\n            head = head.next;\\n        }\\n        \\n        after_curr.next = null;\\n        before_curr.next = after.next;\\n        \\n        return before.next;\\n    }\\n}\\n```\\n``` JavaScript []\\nvar partition = function(head, x) {\\n    let before = new ListNode(0);\\n    let after = new ListNode(0);\\n    let before_curr = before;\\n    let after_curr = after;\\n    \\n    while(head !== null) {\\n        if(head.val < x) {\\n            before_curr.next = head;\\n            before_curr = before_curr.next;\\n        } else {\\n            after_curr.next = head;\\n            after_curr = after_curr.next;\\n        }\\n        head = head.next;\\n    }\\n    \\n    after_curr.next = null;\\n    before_curr.next = after.next;\\n    \\n    return before.next;\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public ListNode Partition(ListNode head, int x) {\\n        ListNode before = new ListNode(0);\\n        ListNode after = new ListNode(0);\\n        ListNode before_curr = before;\\n        ListNode after_curr = after;\\n        \\n        while(head != null) {\\n            if(head.val < x) {\\n                before_curr.next = head;\\n                before_curr = before_curr.next;\\n            } else {\\n                after_curr.next = head;\\n                after_curr = after_curr.next;\\n            }\\n            head = head.next;\\n        }\\n        \\n        after_curr.next = null;\\n        before_curr.next = after.next;\\n        \\n        return before.next;\\n    }\\n}\\n```\\n\\n# Coding in Rust & Go\\n\\nhttps://youtu.be/OOw-mP8T2AE\\nhttps://youtu.be/d-1OTX26qdo\\n\\nThe \"Partition a Linked List Around a Value\" problem exemplifies the elegance of simplicity in coding. Remember, every coding challenge is a gateway to greater understanding and expertise. Embrace each problem, for they refine your skills and mold your coding journey. Stay curious, dive deep, and let your passion for coding guide you to new horizons. \\uD83D\\uDE80\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        before, after = ListNode(0), ListNode(0)\\n        before_curr, after_curr = before, after\\n        \\n        while head:\\n            if head.val < x:\\n                before_curr.next, before_curr = head, head\\n            else:\\n                after_curr.next, after_curr = head, head\\n            head = head.next\\n        \\n        after_curr.next = None\\n        before_curr.next = after.next\\n        \\n        return before.next\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode before(0), after(0);\\n        ListNode* before_curr = &before;\\n        ListNode* after_curr = &after;\\n        \\n        while(head) {\\n            if(head->val < x) {\\n                before_curr->next = head;\\n                before_curr = head;\\n            } else {\\n                after_curr->next = head;\\n                after_curr = head;\\n            }\\n            head = head->next;\\n        }\\n        \\n        after_curr->next = nullptr;\\n        before_curr->next = after.next;\\n        \\n        return before.next;\\n    }\\n};\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn partition(mut head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\\n        let mut before = ListNode::new(0);\\n        let mut after = ListNode::new(0);\\n        let mut before_tail = &mut before;\\n        let mut after_tail = &mut after;\\n\\n        while let Some(mut node) = head {\\n            head = node.next.take();\\n            if node.val < x {\\n                before_tail.next = Some(node);\\n                before_tail = before_tail.next.as_mut().unwrap();\\n            } else {\\n                after_tail.next = Some(node);\\n                after_tail = after_tail.next.as_mut().unwrap();\\n            }\\n        }\\n\\n        before_tail.next = after.next.take();\\n\\n        before.next\\n    }\\n}\\n```\n``` Go []\\nfunc partition(head *ListNode, x int) *ListNode {\\n    before := &ListNode{}\\n    after := &ListNode{}\\n    before_curr := before\\n    after_curr := after\\n    \\n    for head != nil {\\n        if head.Val < x {\\n            before_curr.Next = head\\n            before_curr = before_curr.Next\\n        } else {\\n            after_curr.Next = head\\n            after_curr = after_curr.Next\\n        }\\n        head = head.Next\\n    }\\n    \\n    after_curr.Next = nil\\n    before_curr.Next = after.Next\\n    \\n    return before.Next\\n}\\n```\n``` Java []\\npublic class Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode before = new ListNode(0);\\n        ListNode after = new ListNode(0);\\n        ListNode before_curr = before;\\n        ListNode after_curr = after;\\n        \\n        while(head != null) {\\n            if(head.val < x) {\\n                before_curr.next = head;\\n                before_curr = before_curr.next;\\n            } else {\\n                after_curr.next = head;\\n                after_curr = after_curr.next;\\n            }\\n            head = head.next;\\n        }\\n        \\n        after_curr.next = null;\\n        before_curr.next = after.next;\\n        \\n        return before.next;\\n    }\\n}\\n```\n``` JavaScript []\\nvar partition = function(head, x) {\\n    let before = new ListNode(0);\\n    let after = new ListNode(0);\\n    let before_curr = before;\\n    let after_curr = after;\\n    \\n    while(head !== null) {\\n        if(head.val < x) {\\n            before_curr.next = head;\\n            before_curr = before_curr.next;\\n        } else {\\n            after_curr.next = head;\\n            after_curr = after_curr.next;\\n        }\\n        head = head.next;\\n    }\\n    \\n    after_curr.next = null;\\n    before_curr.next = after.next;\\n    \\n    return before.next;\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public ListNode Partition(ListNode head, int x) {\\n        ListNode before = new ListNode(0);\\n        ListNode after = new ListNode(0);\\n        ListNode before_curr = before;\\n        ListNode after_curr = after;\\n        \\n        while(head != null) {\\n            if(head.val < x) {\\n                before_curr.next = head;\\n                before_curr = before_curr.next;\\n            } else {\\n                after_curr.next = head;\\n                after_curr = after_curr.next;\\n            }\\n            head = head.next;\\n        }\\n        \\n        after_curr.next = null;\\n        before_curr.next = after.next;\\n        \\n        return before.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315305,
                "title": "c-single-pass-o-1-space-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( N ) space approach**\\n\\nTraverse the list and keep the values in a vector that are smaller than ```key``` provided. Traverse again to find the values greater than or equal to ```key```.\\nMake the list and return it.\\n\\n**O ( 1 ) with TWO PASSES**\\n\\nCreate a node with garbage value. *let say **resultant*** -> This prevents us from checking if ```resultant``` linked list is empty or not.\\n*First-pass* -> Traverse and add all the nodes that are ```smaller``` than ```key``` provided.\\n*Secong-pass* -> Traverse again to add nodes that are ```greater than or equal to``` key provided.\\n```return resultant -> next``` *[ next returned to remove garbage node ]*\\n\\n**O ( 1 ) with SINGLE PASS**\\n\\nCreate two nodes with garbage vales.\\n* ```small``` -> to have nodes with value *less* than ```key```\\n* ```large``` -> to have nodes with value *greater than or equal* to ```key```.\\n\\nNow visit each node :\\n* if node smaller -> add to ```small``` and ```small -> next = NULL```\\n* else -> add to ```large``` and ```large -> next = NULL```\\n\\n*[ We make ```small/large -> next = NULL``` to add only a single node and break further connection, if not done , whole list after head will be added to them ]*\\n\\nAt end join two linked lists *[ remember the garbage nodes ]* ->\\n* make ```small -> next = large_head -> next``` : we appending large_head -> **next** because the first node is garbage.\\n\\nSame way while returning remove garbage node from small and return ```return small_head -> next```.\\n\\n**UPVOTE IF HELPFuuL**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode* partition(ListNode* head, int x) {\\n        \\n        ListNode* small = new ListNode(-1);\\n        ListNode* large = new ListNode(-1);\\n        ListNode* small_head = small;\\n        ListNode* large_head = large;\\n        \\n        while (head){\\n            if (head->val < x){\\n                small->next = head;\\n                small = small -> next;\\n                head = head -> next;\\n                small->next = NULL;\\n            }\\n            else{\\n                large->next = head;\\n                large = large -> next;\\n                head = head -> next;\\n                large -> next = NULL;\\n            }\\n        }\\n        small -> next = large_head -> next;\\n\\n        return small_head -> next;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/8047ec32-ac17-4d62-be57-6af715272f6d_1658453504.0169513.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```key```\n```key```\n```resultant```\n```smaller```\n```key```\n```greater than or equal to```\n```return resultant -> next```\n```small```\n```key```\n```large```\n```key```\n```small```\n```small -> next = NULL```\n```large```\n```large -> next = NULL```\n```small/large -> next = NULL```\n```small -> next = large_head -> next```\n```return small_head -> next```\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode* partition(ListNode* head, int x) {\\n        \\n        ListNode* small = new ListNode(-1);\\n        ListNode* large = new ListNode(-1);\\n        ListNode* small_head = small;\\n        ListNode* large_head = large;\\n        \\n        while (head){\\n            if (head->val < x){\\n                small->next = head;\\n                small = small -> next;\\n                head = head -> next;\\n                small->next = NULL;\\n            }\\n            else{\\n                large->next = head;\\n                large = large -> next;\\n                head = head -> next;\\n                large -> next = NULL;\\n            }\\n        }\\n        small -> next = large_head -> next;\\n\\n        return small_head -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157797,
                "title": "js-python-java-c-easy-two-lists-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe easiest thing to do here is to create separate linked lists for the front and back portions of list we want to return. In order to accomplish that, we should first create some dummy heads (**fdum, bdum**), then create pointers for the current nodes each of the front, back, and main lists (**front, back, curr**).\\n\\nThen we can simply iterate through the main list and stitch together each node to either **front** or **back**, depending on the node\\'s value.\\n\\nOnce we reach the end, we just need to stitch together the two sub-lists, making sure to cap off the end of **back**, and then **return** our new list, minus the dummy head.\\n\\n![Visual 1](https://i.imgur.com/X5semXh.png)\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences between the code of all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **80ms / 40.1MB** (beats 92% / 66%).\\n```javascript\\nvar partition = function(head, x) {\\n    let fdum = new ListNode(0), bdum = new ListNode(0),\\n        front = fdum, back = bdum, curr = head\\n    while (curr) {\\n        if (curr.val < x)front.next = curr, front = curr\\n        else back.next = curr, back = curr\\n        curr = curr.next\\n    }\\n    front.next = bdum.next, back.next = null\\n    return fdum.next\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.1MB** (beats 99% / 85%).\\n```python\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        fdum, bdum = ListNode(0), ListNode(0)\\n        front, back, curr = fdum, bdum, head\\n        while curr:\\n            if curr.val < x:\\n                front.next = curr\\n                front = curr\\n            else:\\n                back.next = curr\\n                back = curr\\n            curr = curr.next\\n        front.next, back.next = bdum.next, None\\n        return fdum.next\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 38.2MB** (beats 100% / 69%).\\n```java\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode fdum = new ListNode(0), bdum = new ListNode(0),\\n                 front = fdum, back = bdum, curr = head;\\n        while (curr != null) {\\n            if (curr.val < x) {\\n                front.next = curr;\\n                front = curr;\\n            } else {\\n                back.next = curr;\\n                back = curr;\\n            }\\n            curr = curr.next;\\n        }\\n        front.next = bdum.next;\\n        back.next = null;\\n        return fdum.next;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 10.1MB** (beats 100% / 90%).\\n```c++\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *fdum = new ListNode(0), *bdum = new ListNode(0),\\n                 *front = fdum, *back = bdum, *curr = head;\\n        while (curr) {\\n            if (curr->val < x) front->next = curr, front = curr;\\n            else back->next = curr, back = curr;\\n            curr = curr->next;\\n        }\\n        front->next = bdum->next, back->next = nullptr;\\n        return fdum->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar partition = function(head, x) {\\n    let fdum = new ListNode(0), bdum = new ListNode(0),\\n        front = fdum, back = bdum, curr = head\\n    while (curr) {\\n        if (curr.val < x)front.next = curr, front = curr\\n        else back.next = curr, back = curr\\n        curr = curr.next\\n    }\\n    front.next = bdum.next, back.next = null\\n    return fdum.next\\n};\\n```\n```python\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        fdum, bdum = ListNode(0), ListNode(0)\\n        front, back, curr = fdum, bdum, head\\n        while curr:\\n            if curr.val < x:\\n                front.next = curr\\n                front = curr\\n            else:\\n                back.next = curr\\n                back = curr\\n            curr = curr.next\\n        front.next, back.next = bdum.next, None\\n        return fdum.next\\n```\n```java\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode fdum = new ListNode(0), bdum = new ListNode(0),\\n                 front = fdum, back = bdum, curr = head;\\n        while (curr != null) {\\n            if (curr.val < x) {\\n                front.next = curr;\\n                front = curr;\\n            } else {\\n                back.next = curr;\\n                back = curr;\\n            }\\n            curr = curr.next;\\n        }\\n        front.next = bdum.next;\\n        back.next = null;\\n        return fdum.next;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *fdum = new ListNode(0), *bdum = new ListNode(0),\\n                 *front = fdum, *back = bdum, *curr = head;\\n        while (curr) {\\n            if (curr->val < x) front->next = curr, front = curr;\\n            else back->next = curr, back = curr;\\n            curr = curr->next;\\n        }\\n        front->next = bdum->next, back->next = nullptr;\\n        return fdum->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29181,
                "title": "10-lines-concise-c-solution",
                "content": "    class Solution {\\n    public:\\n        ListNode* partition(ListNode* head, int x) {\\n            ListNode left(0), right(0);\\n            ListNode *l = &left, *r = &right;\\n\\n            while(head){\\n                ListNode* & ref = head->val < x ? l : r;\\n                ref->next = head;\\n                ref = ref->next;\\n                \\n                head = head->next;\\n            }\\n            l->next = right.next;\\n            r->next = NULL;\\n            return left.next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* partition(ListNode* head, int x) {\\n            ListNode left(0), right(0);\\n            ListNode *l = &left, *r = &right;\\n\\n            while(head){\\n                ListNode* & ref = head->val < x ? l : r;\\n                ref->next = head;\\n                ref = ref->next;\\n                \\n                head = head->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1157903,
                "title": "simple-1-pass-partition-w-two-pointers-explained-beats-100",
                "content": "There are a few approach using which this question can be solved. In the simplest solution, we can iterate over the list in the first pass and append all nodes less than `x` and in the second pass append all nodes greater than or equal to `x`.\\n\\nLet\\'s try to solve the problem in one-pass and O(1) Space without making duplicate copies of original nodes.\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution (2-pointer partition)***\\n\\nWe can easily partition the list if we maintain two pointers -\\n* `lesser` - to store all the nodes from original list which are less than `x`.\\n* `greater` - to store all the nodes from original list which are greater than or equal to `x`.\\n\\nWe initialise both of these pointers to temporary / dummy nodes so that we can easily append to them without having to do any extra checks.\\n\\nWe would also need two more variable to store the heads of these pointers - `lesser_head` and `greater_head` which would be required later to join `lesser` to `greater_head` and finally return the head of partition list which would be `lesser_head -> next` (since lesser_head is dummy node, so return its next).\\n\\n```\\n ListNode* partition(ListNode* head, int x) {\\n \\xA0 \\xA0 ListNode *lesser = new ListNode(-1), *greater = new ListNode(-1), *lesser_head = lesser, *greater_head = greater;\\n \\xA0 \\xA0 while(head){\\n \\xA0 \\xA0 \\xA0 \\xA0 if(head -> val < x) \\n                lesser -> next = head, lesser = lesser -> next;\\n \\xA0 \\xA0 \\xA0 \\xA0 else \\n                greater -> next = head, greater = greater -> next;\\n \\xA0 \\xA0 \\xA0 \\xA0 head = head -> next; \\n \\xA0 \\xA0 }\\n \\xA0 \\xA0 greater -> next = NULL;\\n \\xA0 \\xA0 lesser -> next = greater_head -> next;\\n \\xA0 \\xA0 return lesser_head -> next;\\n }\\n```\\n\\n***Time Complexity :*** **`O(N)`**, where `N` is the total number of nodes in original linked list.\\n***Space Complexity :*** **`O(1)`**. Note that we are not making duplicate nodes, just rearranging the original nodes in our partitioned.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n ListNode* partition(ListNode* head, int x) {\\n \\xA0 \\xA0 ListNode *lesser = new ListNode(-1), *greater = new ListNode(-1), *lesser_head = lesser, *greater_head = greater;\\n \\xA0 \\xA0 while(head){\\n \\xA0 \\xA0 \\xA0 \\xA0 if(head -> val < x) \\n                lesser -> next = head, lesser = lesser -> next;\\n \\xA0 \\xA0 \\xA0 \\xA0 else \\n                greater -> next = head, greater = greater -> next;\\n \\xA0 \\xA0 \\xA0 \\xA0 head = head -> next; \\n \\xA0 \\xA0 }\\n \\xA0 \\xA0 greater -> next = NULL;\\n \\xA0 \\xA0 lesser -> next = greater_head -> next;\\n \\xA0 \\xA0 return lesser_head -> next;\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1157788,
                "title": "python-two-pointers-explained",
                "content": "All we need to do is to create two dummy heads for two new lists and then traverse through original list and add elements. On each step we check if value of node is less than `x` or not. If it is less, append it to the end of the first list and move pointer `p1`, so it always points to the end of first list. If it is more than equal than `x`, move second pointer. In the end we have `4` pointers in the following order:  `d1->... -> p1  d2->... ->p2->`, so what we need to do now is to add connection `p1->d2` and also remove connection from `p2`.\\n\\n#### Complexity\\nTime complexity is `O(n)` and space complexity is `O(1)`.\\n\\n#### Code\\n```\\nclass Solution:\\n    def partition(self, head, x):\\n        d1 = ListNode(-1)\\n        d2 = ListNode(-1)\\n        p1, p2 = d1, d2\\n        while head:\\n            if head.val < x:\\n                p1.next = head\\n                p1 = p1.next\\n            else:\\n                p2.next = head\\n                p2 = p2.next\\n            head = head.next\\n            \\n        p1.next = d2.next\\n        p2.next = None\\n        return d1.next\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, head, x):\\n        d1 = ListNode(-1)\\n        d2 = ListNode(-1)\\n        p1, p2 = d1, d2\\n        while head:\\n            if head.val < x:\\n                p1.next = head\\n                p1 = p1.next\\n            else:\\n                p2.next = head\\n                p2 = p2.next\\n            head = head.next\\n            \\n        p1.next = d2.next\\n        p2.next = None\\n        return d1.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911093,
                "title": "commented-code-line-by-line-explained-c-java-python",
                "content": "\\uD83C\\uDDEE\\uD83C\\uDDF3 Happy independence Day \\uD83C\\uDDEE\\uD83C\\uDDF3\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThis approach uses two separate lists to partition the nodes.\\n\\nFor detailed explanation you can refer to my youtube channel (hindi Language)\\nhttps://youtu.be/WOA1IuoONXc\\n or link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Initialize two new linked lists, `less` and `greater`, to hold nodes with values less than `x` and greater than or equal to `x`, respectively.\\n\\n2. Traverse the original linked list, `head`, and for each node:\\n   - If the node\\'s value is less than `x`, append it to the `less` list.\\n   - If the node\\'s value is greater than or equal to `x`, append it to the `greater` list.\\n\\n3. After traversing the original list, attach the `greater` list to the end of the `less` list.\\n\\n4. Set the last node of the `greater` list\\'s `next` pointer to `nullptr` to terminate the list.\\n\\n5. Return the `less` list\\'s head as the result.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 1\\n# Creating new instances of Nodes with given value\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* current = head;  // Pointer to traverse the original list\\n        \\n        ListNode* lessDummy = new ListNode(0);    // Dummy node for nodes < x\\n        ListNode* lessTail = lessDummy;           // Tail pointer for less list\\n        \\n        ListNode* greaterDummy = new ListNode(0); // Dummy node for nodes >= x\\n        ListNode* greaterTail = greaterDummy;     // Tail pointer for greater list\\n        \\n        // Traverse the original list\\n        while (current != nullptr) {\\n            if (current->val < x) {\\n                // Append current node to the less list\\n                lessTail->next = new ListNode(current->val);\\n                lessTail = lessTail->next; // Move the tail pointer\\n            } else {\\n                // Append current node to the greater list\\n                greaterTail->next = new ListNode(current->val);\\n                greaterTail = greaterTail->next; // Move the tail pointer\\n            }\\n            current = current->next; // Move to the next node\\n        }\\n        \\n        \\n        // Attach the greater list to the end of the less list\\n        lessTail->next = greaterDummy->next;\\n        \\n        // Return the modified list starting from the first node after the less dummy node\\n        return lessDummy->next;\\n    }\\n};\\n\\n```\\n```java []\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode current = head;  // Pointer to traverse the original list\\n        \\n        ListNode lessDummy = new ListNode(0);    // Dummy node for nodes < x\\n        ListNode lessTail = lessDummy;           // Tail pointer for less list\\n        \\n        ListNode greaterDummy = new ListNode(0); // Dummy node for nodes >= x\\n        ListNode greaterTail = greaterDummy;     // Tail pointer for greater list\\n        \\n        // Traverse the original list\\n        while (current != null) {\\n            if (current.val < x) {\\n                // Append current node to the less list\\n                lessTail.next = new ListNode(current.val);\\n                lessTail = lessTail.next; // Move the tail pointer\\n            } else {\\n                // Append current node to the greater list\\n                greaterTail.next = new ListNode(current.val);\\n                greaterTail = greaterTail.next; // Move the tail pointer\\n            }\\n            current = current.next; // Move to the next node\\n        }\\n        \\n       \\n        \\n        // Attach the greater list to the end of the less list\\n        lessTail.next = greaterDummy.next;\\n        \\n        // Return the modified list starting from the first node after the less dummy node\\n        return lessDummy.next;\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        current = head  # Pointer to traverse the original list\\n        \\n        less_dummy = ListNode(0)    # Dummy node for nodes < x\\n        less_tail = less_dummy           # Tail pointer for less list\\n        \\n        greater_dummy = ListNode(0) # Dummy node for nodes >= x\\n        greater_tail = greater_dummy     # Tail pointer for greater list\\n        \\n        # Traverse the original list\\n        while current:\\n            if current.val < x:\\n                # Append current node to the less list\\n                less_tail.next = ListNode(current.val)\\n                less_tail = less_tail.next  # Move the tail pointer\\n            else:\\n                # Append current node to the greater list\\n                greater_tail.next = ListNode(current.val)\\n                greater_tail = greater_tail.next  # Move the tail pointer\\n            current = current.next  # Move to the next node\\n        \\n        \\n        # Attach the greater list to the end of the less list\\n        less_tail.next = greater_dummy.next\\n        \\n        # Return the modified list starting from the first node after the less dummy node\\n        return less_dummy.next\\n\\n```\\n\\n\\n# Code 2 \\n# Using  same  Nodes.\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        // Initialize dummy nodes and tail pointers for less and greater lists\\n        ListNode* lessDummy = new ListNode(0);    // Dummy node for nodes < x\\n        ListNode* lessTail = lessDummy;           // Tail pointer for less list\\n        \\n        ListNode* greaterDummy = new ListNode(0); // Dummy node for nodes >= x\\n        ListNode* greaterTail = greaterDummy;     // Tail pointer for greater list\\n        \\n        ListNode* current = head;  // Current pointer for traversing the original list\\n        \\n        // Traverse the original list\\n        while (current != nullptr) {\\n            if (current->val < x) {\\n                // Append current node to the less list\\n                lessTail->next = current;\\n                lessTail = current; // Move the tail pointer\\n            } else {\\n                // Append current node to the greater list\\n                greaterTail->next = current;\\n                greaterTail = current; // Move the tail pointer\\n            }\\n            current = current->next; // Move to the next node\\n        }\\n        \\n        greaterTail->next = nullptr; // Terminate the greater list\\n        \\n        // Attach the greater list to the end of the less list\\n        lessTail->next = greaterDummy->next;\\n        \\n        // Return the modified list starting from the first node after the less dummy node\\n        return lessDummy->next;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode lessDummy = new ListNode(0);   // Dummy node for nodes < x\\n        ListNode lessTail = lessDummy;          // Tail pointer for less list\\n        \\n        ListNode greaterDummy = new ListNode(0); // Dummy node for nodes >= x\\n        ListNode greaterTail = greaterDummy;     // Tail pointer for greater list\\n        \\n        ListNode current = head;  // Current pointer for traversing the original list\\n        \\n        // Traverse the original list\\n        while (current != null) {\\n            if (current.val < x) {\\n                // Append current node to the less list\\n                lessTail.next = current;\\n                lessTail = current; // Move the tail pointer\\n            } else {\\n                // Append current node to the greater list\\n                greaterTail.next = current;\\n                greaterTail = current; // Move the tail pointer\\n            }\\n            current = current.next; // Move to the next node\\n        }\\n        \\n        greaterTail.next = null; // Terminate the greater list\\n        \\n        // Attach the greater list to the end of the less list\\n        lessTail.next = greaterDummy.next;\\n        \\n        // Return the modified list starting from the first node after the less dummy node\\n        return lessDummy.next;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        less_dummy = ListNode(0)   # Dummy node for nodes < x\\n        less_tail = less_dummy     # Tail pointer for less list\\n        \\n        greater_dummy = ListNode(0) # Dummy node for nodes >= x\\n        greater_tail = greater_dummy # Tail pointer for greater list\\n        \\n        current = head  # Current pointer for traversing the original list\\n        \\n        # Traverse the original list\\n        while current:\\n            if current.val < x:\\n                # Append current node to the less list\\n                less_tail.next = current\\n                less_tail = current # Move the tail pointer\\n            else:\\n                # Append current node to the greater list\\n                greater_tail.next = current\\n                greater_tail = current # Move the tail pointer\\n            current = current.next # Move to the next node\\n        \\n        greater_tail.next = None # Terminate the greater list\\n        \\n        # Attach the greater list to the end of the less list\\n        less_tail.next = greater_dummy.next\\n        \\n        # Return the modified list starting from the first node after the less dummy node\\n        return less_dummy.next\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* current = head;  // Pointer to traverse the original list\\n        \\n        ListNode* lessDummy = new ListNode(0);    // Dummy node for nodes < x\\n        ListNode* lessTail = lessDummy;           // Tail pointer for less list\\n        \\n        ListNode* greaterDummy = new ListNode(0); // Dummy node for nodes >= x\\n        ListNode* greaterTail = greaterDummy;     // Tail pointer for greater list\\n        \\n        // Traverse the original list\\n        while (current != nullptr) {\\n            if (current->val < x) {\\n                // Append current node to the less list\\n                lessTail->next = new ListNode(current->val);\\n                lessTail = lessTail->next; // Move the tail pointer\\n            } else {\\n                // Append current node to the greater list\\n                greaterTail->next = new ListNode(current->val);\\n                greaterTail = greaterTail->next; // Move the tail pointer\\n            }\\n            current = current->next; // Move to the next node\\n        }\\n        \\n        \\n        // Attach the greater list to the end of the less list\\n        lessTail->next = greaterDummy->next;\\n        \\n        // Return the modified list starting from the first node after the less dummy node\\n        return lessDummy->next;\\n    }\\n};\\n\\n```\n```java []\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode current = head;  // Pointer to traverse the original list\\n        \\n        ListNode lessDummy = new ListNode(0);    // Dummy node for nodes < x\\n        ListNode lessTail = lessDummy;           // Tail pointer for less list\\n        \\n        ListNode greaterDummy = new ListNode(0); // Dummy node for nodes >= x\\n        ListNode greaterTail = greaterDummy;     // Tail pointer for greater list\\n        \\n        // Traverse the original list\\n        while (current != null) {\\n            if (current.val < x) {\\n                // Append current node to the less list\\n                lessTail.next = new ListNode(current.val);\\n                lessTail = lessTail.next; // Move the tail pointer\\n            } else {\\n                // Append current node to the greater list\\n                greaterTail.next = new ListNode(current.val);\\n                greaterTail = greaterTail.next; // Move the tail pointer\\n            }\\n            current = current.next; // Move to the next node\\n        }\\n        \\n       \\n        \\n        // Attach the greater list to the end of the less list\\n        lessTail.next = greaterDummy.next;\\n        \\n        // Return the modified list starting from the first node after the less dummy node\\n        return lessDummy.next;\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        current = head  # Pointer to traverse the original list\\n        \\n        less_dummy = ListNode(0)    # Dummy node for nodes < x\\n        less_tail = less_dummy           # Tail pointer for less list\\n        \\n        greater_dummy = ListNode(0) # Dummy node for nodes >= x\\n        greater_tail = greater_dummy     # Tail pointer for greater list\\n        \\n        # Traverse the original list\\n        while current:\\n            if current.val < x:\\n                # Append current node to the less list\\n                less_tail.next = ListNode(current.val)\\n                less_tail = less_tail.next  # Move the tail pointer\\n            else:\\n                # Append current node to the greater list\\n                greater_tail.next = ListNode(current.val)\\n                greater_tail = greater_tail.next  # Move the tail pointer\\n            current = current.next  # Move to the next node\\n        \\n        \\n        # Attach the greater list to the end of the less list\\n        less_tail.next = greater_dummy.next\\n        \\n        # Return the modified list starting from the first node after the less dummy node\\n        return less_dummy.next\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        // Initialize dummy nodes and tail pointers for less and greater lists\\n        ListNode* lessDummy = new ListNode(0);    // Dummy node for nodes < x\\n        ListNode* lessTail = lessDummy;           // Tail pointer for less list\\n        \\n        ListNode* greaterDummy = new ListNode(0); // Dummy node for nodes >= x\\n        ListNode* greaterTail = greaterDummy;     // Tail pointer for greater list\\n        \\n        ListNode* current = head;  // Current pointer for traversing the original list\\n        \\n        // Traverse the original list\\n        while (current != nullptr) {\\n            if (current->val < x) {\\n                // Append current node to the less list\\n                lessTail->next = current;\\n                lessTail = current; // Move the tail pointer\\n            } else {\\n                // Append current node to the greater list\\n                greaterTail->next = current;\\n                greaterTail = current; // Move the tail pointer\\n            }\\n            current = current->next; // Move to the next node\\n        }\\n        \\n        greaterTail->next = nullptr; // Terminate the greater list\\n        \\n        // Attach the greater list to the end of the less list\\n        lessTail->next = greaterDummy->next;\\n        \\n        // Return the modified list starting from the first node after the less dummy node\\n        return lessDummy->next;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode lessDummy = new ListNode(0);   // Dummy node for nodes < x\\n        ListNode lessTail = lessDummy;          // Tail pointer for less list\\n        \\n        ListNode greaterDummy = new ListNode(0); // Dummy node for nodes >= x\\n        ListNode greaterTail = greaterDummy;     // Tail pointer for greater list\\n        \\n        ListNode current = head;  // Current pointer for traversing the original list\\n        \\n        // Traverse the original list\\n        while (current != null) {\\n            if (current.val < x) {\\n                // Append current node to the less list\\n                lessTail.next = current;\\n                lessTail = current; // Move the tail pointer\\n            } else {\\n                // Append current node to the greater list\\n                greaterTail.next = current;\\n                greaterTail = current; // Move the tail pointer\\n            }\\n            current = current.next; // Move to the next node\\n        }\\n        \\n        greaterTail.next = null; // Terminate the greater list\\n        \\n        // Attach the greater list to the end of the less list\\n        lessTail.next = greaterDummy.next;\\n        \\n        // Return the modified list starting from the first node after the less dummy node\\n        return lessDummy.next;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        less_dummy = ListNode(0)   # Dummy node for nodes < x\\n        less_tail = less_dummy     # Tail pointer for less list\\n        \\n        greater_dummy = ListNode(0) # Dummy node for nodes >= x\\n        greater_tail = greater_dummy # Tail pointer for greater list\\n        \\n        current = head  # Current pointer for traversing the original list\\n        \\n        # Traverse the original list\\n        while current:\\n            if current.val < x:\\n                # Append current node to the less list\\n                less_tail.next = current\\n                less_tail = current # Move the tail pointer\\n            else:\\n                # Append current node to the greater list\\n                greater_tail.next = current\\n                greater_tail = current # Move the tail pointer\\n            current = current.next # Move to the next node\\n        \\n        greater_tail.next = None # Terminate the greater list\\n        \\n        # Attach the greater list to the end of the less list\\n        less_tail.next = greater_dummy.next\\n        \\n        # Return the modified list starting from the first node after the less dummy node\\n        return less_dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29366,
                "title": "concise-and-simple-c-solution",
                "content": "    ListNode *partition(ListNode *head, int x) {\\n            \\n            ListNode *head1 = new ListNode(0);\\n            ListNode *head2 = new ListNode(0);\\n            ListNode *h1 = head1;\\n            ListNode *h2 = head2;\\n            while(head)\\n            {\\n                int v = head->val;\\n                if(v < x)\\n                {\\n                    head1->next = head;\\n                    head1 = head1->next;\\n                } else {\\n                    head2->next = head;\\n                    head2 = head2->next;\\n                }\\n                head = head->next;\\n            }\\n            head2->next = NULL;\\n            head1->next = h2->next;;\\n            return h1->next;\\n        }",
                "solutionTags": [],
                "code": "    ListNode *partition(ListNode *head, int x) {\\n            \\n            ListNode *head1 = new ListNode(0);\\n            ListNode *head2 = new ListNode(0);\\n            ListNode *h1 = head1;\\n            ListNode *h2 = head2;\\n            while(head)\\n            {\\n                int v = head->val;\\n                if(v < x)\\n                {\\n                    head1->next = head;\\n                    head1 = head1->next;\\n                } else {\\n                    head2->next = head;\\n                    head2 = head2->next;\\n                }\\n                head = head->next;\\n            }\\n            head2->next = NULL;\\n            head1->next = h2->next;;\\n            return h1->next;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 193969,
                "title": "java-beats-100-0ms-explanation",
                "content": "The idea is simple - we separately create two parts of new list head(first part) and tail (second part).\\nInitial state is the following:\\n\\n![image](https://assets.leetcode.com/users/olsh/image_1542296729.png)\\n\\nFirstly, let\\'s find appropriate list for first element:\\n\\n![image](https://assets.leetcode.com/users/olsh/image_1542297024.png)\\n\\nIt\\'s less than x -> goes to head:\\n\\n![image](https://assets.leetcode.com/users/olsh/image_1542297092.png)\\n\\nnow:\\n\\n![image](https://assets.leetcode.com/users/olsh/image_1542297208.png)\\n\\nnext element 4 -> goes to tail:\\n\\n![image](https://assets.leetcode.com/users/olsh/image_1542297259.png)\\n\\nEvery time we add new ListNode in the beginning of head or tail:\\n\\n![image](https://assets.leetcode.com/users/olsh/image_1542297352.png)\\n\\nnext:\\n\\n![image](https://assets.leetcode.com/users/olsh/image_1542297386.png)\\n\\nfinally:\\n![image](https://assets.leetcode.com/users/olsh/image_1542297615.png)\\n\\nAs you can notice, both head and tail are in reversed order.\\nThe next step is merging of these lists into result. Firstly, we add every element from tail, and after it - head.\\n\\n![image](https://assets.leetcode.com/users/olsh/image_1542297852.png)\\n\\n\\nThis adding will be in reverse order, and in such way we\\'ll get resulted list in right order:\\n![image](https://assets.leetcode.com/users/olsh/image_1542297890.png)\\nnext:\\n![image](https://assets.leetcode.com/users/olsh/image_1542297926.png)\\n\\nAll elements from tail were added. As you see, now they are in right order:\\n![image](https://assets.leetcode.com/users/olsh/image_1542298024.png)\\n\\nlet\\'s add all head element in the same way:\\n![image](https://assets.leetcode.com/users/olsh/image_1542298146.png)\\n\\n\\ncode:\\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode headCopy=head;\\n        ListNode h=null;\\n        ListNode t=null;\\n        while (headCopy!=null){\\n            ListNode l = new ListNode(headCopy.val);\\n            if (l.val<x){\\n                l.next = h;\\n                h=l;\\n            }\\n            else {\\n                l.next = t;\\n                t=l;\\n            }\\n            headCopy=headCopy.next;\\n        }\\n        head=null;\\n        while (t!=null){\\n            ListNode l = new ListNode(t.val);\\n            l.next=head;\\n            head = l;\\n            t=t.next;\\n        }\\n        while (h!=null){\\n            ListNode l = new ListNode(h.val);\\n            l.next=head;\\n            head = l;\\n            h=h.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode headCopy=head;\\n        ListNode h=null;\\n        ListNode t=null;\\n        while (headCopy!=null){\\n            ListNode l = new ListNode(headCopy.val);\\n            if (l.val<x){\\n                l.next = h;\\n                h=l;\\n            }\\n            else {\\n                l.next = t;\\n                t=l;\\n            }\\n            headCopy=headCopy.next;\\n        }\\n        head=null;\\n        while (t!=null){\\n            ListNode l = new ListNode(t.val);\\n            l.next=head;\\n            head = l;\\n            t=t.next;\\n        }\\n        while (h!=null){\\n            ListNode l = new ListNode(h.val);\\n            l.next=head;\\n            head = l;\\n            h=h.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157800,
                "title": "partition-list-js-python-java-c-easy-two-lists-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe easiest thing to do here is to create separate linked lists for the front and back portions of list we want to return. In order to accomplish that, we should first create some dummy heads (**fdum, bdum**), then create pointers for the current nodes each of the front, back, and main lists (**front, back, curr**).\\n\\nThen we can simply iterate through the main list and stitch together each node to either **front** or **back**, depending on the node\\'s value.\\n\\nOnce we reach the end, we just need to stitch together the two sub-lists, making sure to cap off the end of **back**, and then **return** our new list, minus the dummy head.\\n\\n![Visual 1](https://i.imgur.com/X5semXh.png)\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences between the code of all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **80ms / 40.1MB** (beats 92% / 66%).\\n```javascript\\nvar partition = function(head, x) {\\n    let fdum = new ListNode(0), bdum = new ListNode(0),\\n        front = fdum, back = bdum, curr = head\\n    while (curr) {\\n        if (curr.val < x)front.next = curr, front = curr\\n        else back.next = curr, back = curr\\n        curr = curr.next\\n    }\\n    front.next = bdum.next, back.next = null\\n    return fdum.next\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.1MB** (beats 99% / 85%).\\n```python\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        fdum, bdum = ListNode(0), ListNode(0)\\n        front, back, curr = fdum, bdum, head\\n        while curr:\\n            if curr.val < x:\\n                front.next = curr\\n                front = curr\\n            else:\\n                back.next = curr\\n                back = curr\\n            curr = curr.next\\n        front.next, back.next = bdum.next, None\\n        return fdum.next\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 38.2MB** (beats 100% / 69%).\\n```java\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode fdum = new ListNode(0), bdum = new ListNode(0),\\n                 front = fdum, back = bdum, curr = head;\\n        while (curr != null) {\\n            if (curr.val < x) {\\n                front.next = curr;\\n                front = curr;\\n            } else {\\n                back.next = curr;\\n                back = curr;\\n            }\\n            curr = curr.next;\\n        }\\n        front.next = bdum.next;\\n        back.next = null;\\n        return fdum.next;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 10.1MB** (beats 100% / 90%).\\n```c++\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *fdum = new ListNode(0), *bdum = new ListNode(0),\\n                 *front = fdum, *back = bdum, *curr = head;\\n        while (curr) {\\n            if (curr->val < x) front->next = curr, front = curr;\\n            else back->next = curr, back = curr;\\n            curr = curr->next;\\n        }\\n        front->next = bdum->next, back->next = nullptr;\\n        return fdum->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar partition = function(head, x) {\\n    let fdum = new ListNode(0), bdum = new ListNode(0),\\n        front = fdum, back = bdum, curr = head\\n    while (curr) {\\n        if (curr.val < x)front.next = curr, front = curr\\n        else back.next = curr, back = curr\\n        curr = curr.next\\n    }\\n    front.next = bdum.next, back.next = null\\n    return fdum.next\\n};\\n```\n```python\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        fdum, bdum = ListNode(0), ListNode(0)\\n        front, back, curr = fdum, bdum, head\\n        while curr:\\n            if curr.val < x:\\n                front.next = curr\\n                front = curr\\n            else:\\n                back.next = curr\\n                back = curr\\n            curr = curr.next\\n        front.next, back.next = bdum.next, None\\n        return fdum.next\\n```\n```java\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode fdum = new ListNode(0), bdum = new ListNode(0),\\n                 front = fdum, back = bdum, curr = head;\\n        while (curr != null) {\\n            if (curr.val < x) {\\n                front.next = curr;\\n                front = curr;\\n            } else {\\n                back.next = curr;\\n                back = curr;\\n            }\\n            curr = curr.next;\\n        }\\n        front.next = bdum.next;\\n        back.next = null;\\n        return fdum.next;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *fdum = new ListNode(0), *bdum = new ListNode(0),\\n                 *front = fdum, *back = bdum, *curr = head;\\n        while (curr) {\\n            if (curr->val < x) front->next = curr, front = curr;\\n            else back->next = curr, back = curr;\\n            curr = curr->next;\\n        }\\n        front->next = bdum->next, back->next = nullptr;\\n        return fdum->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910862,
                "title": "video-ex-amazon-explains-a-solution-with-python-javascript-java-and-c",
                "content": "# Intuition\\nCreate a small list and a big list.\\n\\n---\\n\\n# Solution Video\\n## *** Please upvote for this article. *** \\n# Subscribe to my channel from here. I have 245 videos as of August 15th\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nhttps://youtu.be/rR8weWU-WQM\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. **Initialization**:\\n   - Initialize two dummy nodes: `slist` and `blist`. These will serve as the heads of two separate lists, one for values less than `x` and the other for values greater than or equal to `x`.\\n   - Initialize two pointers `small` and `big` that initially point to the dummy nodes `slist` and `blist`, respectively.\\n\\n2. **Traversing the Linked List**:\\n   - Start traversing the input linked list `head`.\\n   - In each iteration:\\n     - Check if the value of the current node `head.val` is less than `x`.\\n       - If true:\\n         - Connect the current node to the `small.next` and then move the `small` pointer to the newly added node. This effectively appends the current node to the smaller values list.\\n       - If false:\\n         - Connect the current node to the `big.next` and then move the `big` pointer to the newly added node. This effectively appends the current node to the larger values list.\\n\\n3. **Finishing the Partition**:\\n   - Once the traversal is complete, the smaller values list ends with the last node appended to it (pointed to by the `small` pointer), and the larger values list ends with the last node appended to it (pointed to by the `big` pointer).\\n\\n4. **Connecting Lists**:\\n   - Connect the tail of the smaller values list (`small.next`) to the head of the larger values list (`blist.next`), effectively merging the two lists.\\n\\n5. **Finalizing the Larger Values List**:\\n   - Since the larger values list is now connected to the smaller values list, set the `next` pointer of the last node in the larger values list to `None` to prevent any potential circular references in the linked list.\\n\\n6. **Returning the Result**:\\n   - Return the `next` node of the `slist` dummy node, which represents the head of the modified linked list where values less than `x` are on one side and values greater than or equal to `x` are on the other side.\\n\\nThe algorithm efficiently partitions the original linked list into two parts based on the given value `x`. Nodes with values less than `x` are placed on one side, and nodes with values greater than or equal to `x` are placed on the other side, maintaining the relative order of the nodes within each group. The algorithm uses two dummy nodes and two pointers to create and manage the partitioned lists.\\n\\n# Complexity\\n- Time complexity: O(n)\\nThe code iterates through the entire linked list once to partition the nodes into two separate lists based on the value of x.\\n\\n- Space complexity: O(1)\\nThe code uses a constant amount of extra space for the two dummy nodes slist and blist, as well as for the small and big pointers. The additional space used does not scale with the input size (linked list length) but remains constant throughout the execution.\\n\\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n\\n        slist, blist = ListNode(), ListNode()\\n        small, big = slist, blist # dummy lists\\n\\n        while head:\\n            if head.val < x:\\n                small.next = head\\n                small = small.next\\n            else:\\n                big.next = head\\n                big = big.next\\n\\n            head = head.next\\n\\n        small.next = blist.next\\n        big.next = None # prevent linked list circle\\n\\n        return slist.next\\n```\\n```javascript []\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} x\\n * @return {ListNode}\\n */\\nvar partition = function(head, x) {\\n    let slist = new ListNode();\\n    let blist = new ListNode();\\n    let small = slist;\\n    let big = blist;\\n\\n    while (head !== null) {\\n        if (head.val < x) {\\n            small.next = head;\\n            small = small.next;\\n        } else {\\n            big.next = head;\\n            big = big.next;\\n        }\\n\\n        head = head.next;\\n    }\\n\\n    small.next = blist.next;\\n    big.next = null;\\n\\n    return slist.next;    \\n};\\n```\\n```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode slist = new ListNode();\\n        ListNode blist = new ListNode();\\n        ListNode small = slist;\\n        ListNode big = blist;\\n\\n        while (head != null) {\\n            if (head.val < x) {\\n                small.next = head;\\n                small = small.next;\\n            } else {\\n                big.next = head;\\n                big = big.next;\\n            }\\n\\n            head = head.next;\\n        }\\n\\n        small.next = blist.next;\\n        big.next = null;\\n\\n        return slist.next;        \\n    }\\n}\\n```\\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* slist = new ListNode(0, nullptr);\\n        ListNode* blist = new ListNode(0, nullptr);\\n        ListNode* small = slist;\\n        ListNode* big = blist;\\n\\n        while (head != nullptr) {\\n            if (head->val < x) {\\n                small->next = head;\\n                small = small->next;\\n            } else {\\n                big->next = head;\\n                big = big->next;\\n            }\\n\\n            head = head->next;\\n        }\\n\\n        small->next = blist->next;\\n        big->next = nullptr;\\n\\n        return slist->next;        \\n    }\\n};\\n```\\n\\n### Thank you for reading. Please upvote the article and don\\'t forget to subscribe to my youtube channel!\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n\\n        slist, blist = ListNode(), ListNode()\\n        small, big = slist, blist # dummy lists\\n\\n        while head:\\n            if head.val < x:\\n                small.next = head\\n                small = small.next\\n            else:\\n                big.next = head\\n                big = big.next\\n\\n            head = head.next\\n\\n        small.next = blist.next\\n        big.next = None # prevent linked list circle\\n\\n        return slist.next\\n```\n```javascript []\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} x\\n * @return {ListNode}\\n */\\nvar partition = function(head, x) {\\n    let slist = new ListNode();\\n    let blist = new ListNode();\\n    let small = slist;\\n    let big = blist;\\n\\n    while (head !== null) {\\n        if (head.val < x) {\\n            small.next = head;\\n            small = small.next;\\n        } else {\\n            big.next = head;\\n            big = big.next;\\n        }\\n\\n        head = head.next;\\n    }\\n\\n    small.next = blist.next;\\n    big.next = null;\\n\\n    return slist.next;    \\n};\\n```\n```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode slist = new ListNode();\\n        ListNode blist = new ListNode();\\n        ListNode small = slist;\\n        ListNode big = blist;\\n\\n        while (head != null) {\\n            if (head.val < x) {\\n                small.next = head;\\n                small = small.next;\\n            } else {\\n                big.next = head;\\n                big = big.next;\\n            }\\n\\n            head = head.next;\\n        }\\n\\n        small.next = blist.next;\\n        big.next = null;\\n\\n        return slist.next;        \\n    }\\n}\\n```\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* slist = new ListNode(0, nullptr);\\n        ListNode* blist = new ListNode(0, nullptr);\\n        ListNode* small = slist;\\n        ListNode* big = blist;\\n\\n        while (head != nullptr) {\\n            if (head->val < x) {\\n                small->next = head;\\n                small = small->next;\\n            } else {\\n                big->next = head;\\n                big = big->next;\\n            }\\n\\n            head = head->next;\\n        }\\n\\n        small->next = blist->next;\\n        big->next = nullptr;\\n\\n        return slist->next;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315385,
                "title": "python-single-pass-o-1-space-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( N ) space approach**\\n\\nTraverse the list and keep the values in a list that are smaller than ```key``` provided. Traverse again to find the values greater than or equal to ```key```.\\nMake the list and return it.\\n\\n**O ( 1 ) with TWO PASSES**\\n\\nCreate a node with garbage value. *let say **resultant*** -> This prevents us from checking if ```resultant``` linked list is empty or not.\\n*First-pass* -> Traverse and add all the nodes that are ```smaller``` than ```key``` provided.\\n*Secong-pass* -> Traverse again to add nodes that are ```greater than or equal to``` key provided.\\n```return resultant -> next``` *[ next returned to remove garbage node ]*\\n\\n**O ( 1 ) with SINGLE PASS**\\n\\nCreate two nodes with garbage vales.\\n* ```small``` -> to have nodes with value *less* than ```key```\\n* ```large``` -> to have nodes with value *greater than or equal* to ```key```.\\n\\nNow visit each node :\\n* if node smaller -> add to ```small``` and ```small -> next = NULL```\\n* else -> add to ```large``` and ```large -> next = NULL```\\n\\n*[ We make ```small/large -> next = NULL``` to add only a single node and break further connection, if not done , whole list after head will be added to them ]*\\n\\nAt end join two linked lists *[ remember the garbage nodes ]* ->\\n* make ```small -> next = large_head -> next``` : we appending large_head -> **next** because the first node is garbage.\\n\\nSame way while returning remove garbage node from small and return ```return small_head -> next```.\\n\\n**UPVOTE IF HELPFuuL**\\n\\n```\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        \\n        small = ListNode(-1)\\n        large = ListNode(-1)\\n        small_head = small\\n        large_head = large\\n        \\n        while head:\\n            \\n            if head.val < x:\\n                small.next = head\\n                head = head.next\\n                small = small.next\\n                small.next = None\\n            \\n            else:\\n                large.next = head\\n                head = head.next\\n                large = large.next\\n                large.next = None\\n        \\n        small.next = large_head.next\\n        \\n        return small_head.next\\n```\\n![image](https://assets.leetcode.com/users/images/5ffb5fcb-e7b7-479e-b3c0-0097cb44c567_1658455850.354948.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```key```\n```key```\n```resultant```\n```smaller```\n```key```\n```greater than or equal to```\n```return resultant -> next```\n```small```\n```key```\n```large```\n```key```\n```small```\n```small -> next = NULL```\n```large```\n```large -> next = NULL```\n```small/large -> next = NULL```\n```small -> next = large_head -> next```\n```return small_head -> next```\n```\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        \\n        small = ListNode(-1)\\n        large = ListNode(-1)\\n        small_head = small\\n        large_head = large\\n        \\n        while head:\\n            \\n            if head.val < x:\\n                small.next = head\\n                head = head.next\\n                small = small.next\\n                small.next = None\\n            \\n            else:\\n                large.next = head\\n                head = head.next\\n                large = large.next\\n                large.next = None\\n        \\n        small.next = large_head.next\\n        \\n        return small_head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910854,
                "title": "c-c-linked-lists-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDivide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n[Please turn on english subtitles if necessary]\\n[https://youtu.be/LZ6oARGKnZA](https://youtu.be/LZ6oARGKnZA)\\n\\nSince my program uses the constructors, it needs extra O(1) space, that is an extra dummy node. With such extra dummy node makes programming much easier. It is a normal trick to deal pointer question. Why? These 2 ponters smallerhead and greaterhead pointer different addressses! If you won\\'t use extra space, it needs some modification.\\n\\nLet\\'s consider the test case\\n\\n[1,4,3,2,5,2]\\n3\\n\\nUse while loop to traverse and partition\\n\\nsmaller->0->1->2->2\\ngreater->0->4->3->5->NULL\\n\\nthen connect 2 lists by \\n```\\nsmallerTail->next = greaterHead->next;\\n```\\nObtain\\nsmaller->0->1->2->2->4->3->5->NULL\\n\\nFinally\\n```\\nhead = smallerHead->next;\\n```\\nHave\\nhead->1->2->2->4->3->5->NULL\\nReturn head\\n\\nThe whole process shown by modifying submitted code in playground\\n```\\n1<3:smaller\\nsmaller:0->1->4->3->2->5->2\\ngreater:0\\n-------\\n4>=3: greater\\nsmaller:0->1->4->3->2->5->2\\ngreater:0->4->3->2->5->2\\n-------\\n3>=3: greater\\nsmaller:0->1->4->3->2->5->2\\ngreater:0->4->3->2->5->2\\n-------\\n2<3:smaller\\nsmaller:0->1->2->5->2\\ngreater:0->4->3->2->5->2\\n-------\\n5>=3: greater\\nsmaller:0->1->2->5->2\\ngreater:0->4->3->5->2\\n-------\\n2<3:smaller\\nsmaller:0->1->2->2\\ngreater:0->4->3->5->2\\n-------\\nans:\\n1->2->2->4->3->5\\n```\\n<iframe src=\"https://leetcode.com/playground/3ydV9DDY/shared\" frameBorder=\"0\" width=\"600\" height=\"300\"></iframe>\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if (head == NULL) return head;\\n        \\n        ListNode* smallerHead=new ListNode(); //Head of the list with nodes <x\\n        ListNode* smallerTail=smallerHead; //Tail of the list with nodes <x\\n        \\n        ListNode* greaterHead=new ListNode();//Head of the list with nodes >=x\\n        ListNode* greaterTail=greaterHead; //Tail of the list with nodes >=x\\n        \\n        ListNode* curr = head;\\n        while (curr) {//partition into greater & smaller lists\\n            if (curr->val < x) {\\n                smallerTail->next = curr;\\n                smallerTail =smallerTail->next;\\n            } \\n            else {\\n                greaterTail->next = curr;\\n                greaterTail=greaterTail->next;\\n            }\\n            curr = curr->next;\\n        }\\n        \\n        greaterTail->next = NULL; \\n        smallerTail->next = greaterHead->next;//Connect the smaller and the greater lists\\n        delete greaterHead; //avoid of memory leak thx to @heder\\n        head = smallerHead->next; //Update the head of the list\\n        delete smallerHead; //avoid of memory leak thx to @heder\\n        return head;\\n    }\\n};\\n\\n```\\n# C code\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\ntypedef  struct ListNode ListNode;\\nstruct ListNode* partition(struct ListNode* head, int x){\\n    if (head == NULL) return head;\\n    ListNode* smaller=(ListNode*)malloc(sizeof(ListNode)); \\n    smaller->val=0;\\n    ListNode* smallerTail=smaller; //Tail of the list with nodes <x\\n        \\n    ListNode* greater=(ListNode*)malloc(sizeof(ListNode));\\n    greater->val=0;\\n    ListNode* greaterTail=greater; //Tail of the list with nodes >=x\\n        \\n    ListNode* curr = head;\\n    while (curr) {//partition into greater & smaller lists\\n        if (curr->val < x) {\\n            smallerTail->next = curr;\\n            smallerTail =smallerTail->next;\\n        } \\n        else {\\n            greaterTail->next = curr;\\n            greaterTail=greaterTail->next;\\n        }\\n        curr = curr->next;\\n    }\\n        \\n    greaterTail->next = NULL; \\n    smallerTail->next = greater->next;//Connect the smaller and the greater lists\\n    free(greater);   \\n    head = smaller->next; //Update the head of the list\\n    free(smaller);  \\n    return head;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nsmallerTail->next = greaterHead->next;\\n```\n```\\nhead = smallerHead->next;\\n```\n```\\n1<3:smaller\\nsmaller:0->1->4->3->2->5->2\\ngreater:0\\n-------\\n4>=3: greater\\nsmaller:0->1->4->3->2->5->2\\ngreater:0->4->3->2->5->2\\n-------\\n3>=3: greater\\nsmaller:0->1->4->3->2->5->2\\ngreater:0->4->3->2->5->2\\n-------\\n2<3:smaller\\nsmaller:0->1->2->5->2\\ngreater:0->4->3->2->5->2\\n-------\\n5>=3: greater\\nsmaller:0->1->2->5->2\\ngreater:0->4->3->5->2\\n-------\\n2<3:smaller\\nsmaller:0->1->2->2\\ngreater:0->4->3->5->2\\n-------\\nans:\\n1->2->2->4->3->5\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if (head == NULL) return head;\\n        \\n        ListNode* smallerHead=new ListNode(); //Head of the list with nodes <x\\n        ListNode* smallerTail=smallerHead; //Tail of the list with nodes <x\\n        \\n        ListNode* greaterHead=new ListNode();//Head of the list with nodes >=x\\n        ListNode* greaterTail=greaterHead; //Tail of the list with nodes >=x\\n        \\n        ListNode* curr = head;\\n        while (curr) {//partition into greater & smaller lists\\n            if (curr->val < x) {\\n                smallerTail->next = curr;\\n                smallerTail =smallerTail->next;\\n            } \\n            else {\\n                greaterTail->next = curr;\\n                greaterTail=greaterTail->next;\\n            }\\n            curr = curr->next;\\n        }\\n        \\n        greaterTail->next = NULL; \\n        smallerTail->next = greaterHead->next;//Connect the smaller and the greater lists\\n        delete greaterHead; //avoid of memory leak thx to @heder\\n        head = smallerHead->next; //Update the head of the list\\n        delete smallerHead; //avoid of memory leak thx to @heder\\n        return head;\\n    }\\n};\\n\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\ntypedef  struct ListNode ListNode;\\nstruct ListNode* partition(struct ListNode* head, int x){\\n    if (head == NULL) return head;\\n    ListNode* smaller=(ListNode*)malloc(sizeof(ListNode)); \\n    smaller->val=0;\\n    ListNode* smallerTail=smaller; //Tail of the list with nodes <x\\n        \\n    ListNode* greater=(ListNode*)malloc(sizeof(ListNode));\\n    greater->val=0;\\n    ListNode* greaterTail=greater; //Tail of the list with nodes >=x\\n        \\n    ListNode* curr = head;\\n    while (curr) {//partition into greater & smaller lists\\n        if (curr->val < x) {\\n            smallerTail->next = curr;\\n            smallerTail =smallerTail->next;\\n        } \\n        else {\\n            greaterTail->next = curr;\\n            greaterTail=greaterTail->next;\\n        }\\n        curr = curr->next;\\n    }\\n        \\n    greaterTail->next = NULL; \\n    smallerTail->next = greater->next;//Connect the smaller and the greater lists\\n    free(greater);   \\n    head = smaller->next; //Update the head of the list\\n    free(smaller);  \\n    return head;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29263,
                "title": "8ms-c-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        ListNode* partition(ListNode* head, int x) {\\n            ListNode *l1 = new ListNode(0),*l2 = new ListNode(0); /*create two list for two partitions*/\\n            ListNode *p1=l1,*p2=l2,*p=head;\\n            while(p!=NULL){\\n                if((p->val)<x) p1 = p1->next = p;\\n                else p2 = p2->next = p;\\n                p = p->next;\\n            }\\n            p2->next = NULL;\\n            p1->next = l2->next;\\n            return l1->next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* partition(ListNode* head, int x) {\\n            ListNode *l1 = new ListNode(0),*l2 = new ListNode(0); /*create two list for two partitions*/\\n            ListNode *p1=l1,*p2=l2,*p=head;\\n            while(p!=NULL){\\n                if((p->val)<x) p1 = p1->next = p;\\n                else p2 = p2->next = p;\\n                p = p->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1158193,
                "title": "java-explained-solution",
                "content": "**EXPLANATION AND IDEA:**\\n 1->4->3->2->5->2  , x=3\\n make two dummy variable and initail them with 0(to avoid handle null things)\\n left :0\\n right:0\\n \\n iterate over given node. If node value is less than x add it to left else add to right.\\n \\n \\n left : 0 -> 1 -> 2 -> 2 \\n right : 0 -> 4 -> 3 -> 5\\n \\n now connect tail of left to 4(i.e right.next)\\n \\n left : 0->1->2->2->4->3->5\\n    make tail2.next=null;\\n     return left.next;\\n\\t \\n**CODE:** \\n```\\npublic ListNode partition(ListNode head, int x) {\\n        if(head==null) return null;\\n        \\n      \\n        ListNode left=new ListNode(0);\\n        ListNode right=new ListNode(0);\\n        \\n        ListNode tail1=left , tail2=right;\\n      \\n        ListNode iterator=head;\\n        while(iterator!=null){\\n            if(iterator.val<x){\\n                tail1.next=iterator;\\n                tail1=tail1.next;\\n            }else{\\n                tail2.next=iterator;\\n                tail2=tail2.next;\\n            }\\n           iterator=iterator.next;\\n        }\\n        tail1.next=right.next;\\n        tail2.next=null; // important\\n\\n        return left.next;\\n    }\\n```\\n\\n**Complexity:**\\nTime:O(n) \\nSpace:O(1) [ as we are using just 2 pointers and rebuilding given list]\\n\\nPlease **UPVOTE** if found it helpful and feel free to comment down or reach out to me if you have any doubt.",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\npublic ListNode partition(ListNode head, int x) {\\n        if(head==null) return null;\\n        \\n      \\n        ListNode left=new ListNode(0);\\n        ListNode right=new ListNode(0);\\n        \\n        ListNode tail1=left , tail2=right;\\n      \\n        ListNode iterator=head;\\n        while(iterator!=null){\\n            if(iterator.val<x){\\n                tail1.next=iterator;\\n                tail1=tail1.next;\\n            }else{\\n                tail2.next=iterator;\\n                tail2=tail2.next;\\n            }\\n           iterator=iterator.next;\\n        }\\n        tail1.next=right.next;\\n        tail2.next=null; // important\\n\\n        return left.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29335,
                "title": "my-accepted-solution-any-improvement",
                "content": "This is my accepted solution:\\n\\n    public class Solution {\\n        public ListNode partition(ListNode head, int x) {\\n            ListNode cur=head;\\n            \\n            ListNode smaller_sentinel=new ListNode(0);\\n            ListNode smaller_cur=smaller_sentinel;\\n            ListNode larger_sentinel=new ListNode(0);\\n            ListNode larger_cur=larger_sentinel;\\n    //Now, go along the list, partitioning into two halves.        \\n            while(cur!=null){\\n                if(cur.val<x){\\n                        smaller_cur.next=cur;\\n                        smaller_cur=smaller_cur.next;\\n                    \\n                }else{\\n                        larger_cur.next=cur;\\n                        larger_cur=larger_cur.next;\\n                }\\n                cur=cur.next;\\n            }\\n    //Now, do the concatenation of two havles. Make sure the last node points to null \\n            larger_cur.next=null;\\n            smaller_cur.next=larger_sentinel.next;\\n            return smaller_sentinel.next;\\n        }\\n    }\\n\\nIt's pretty straightforward. I used multiple references (including sentinels), first to get the two halves, and then link them together. It took 400+ ms to pass the tests (in Java). I guess it's not the optimal solution. Any idea improving it?",
                "solutionTags": [],
                "code": "class Solution {\\n        public ListNode partition(ListNode head, int x) {\\n            ListNode cur=head;\\n            \\n            ListNode smaller_sentinel=new ListNode(0);\\n            ListNode smaller_cur=smaller_sentinel;\\n            ListNode larger_sentinel=new ListNode(0);\\n            ListNode larger_cur=larger_sentinel;\\n    //Now, go along the list, partitioning into two halves.        \\n            while(cur!=null){\\n                if(cur.val<x){\\n                        smaller_cur.next=cur;\\n                        smaller_cur=smaller_cur.next;\\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1921915,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    func partition(_ head: ListNode?, _ x: Int) -> ListNode? {\\n        var current = head\\n        var left_nodes: [ListNode?] = []\\n        var right_nodes: [ListNode?] = []\\n        var head: ListNode?\\n        var prev: ListNode?\\n        \\n        while current != nil {\\n            if current!.val < x {\\n                left_nodes.append(current)\\n            } else {\\n                right_nodes.append(current)\\n            }\\n            \\n            current = current?.next\\n        }\\n        \\n        for node in left_nodes + right_nodes {\\n            node?.next = nil\\n            \\n            if head == nil {\\n                head = node\\n            } else {\\n                prev?.next = node\\n            }\\n            \\n            prev = node\\n        }\\n        \\n        return head\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    func partition(_ head: ListNode?, _ x: Int) -> ListNode? {\\n        var current = head\\n        var left_nodes: [ListNode?] = []\\n        var right_nodes: [ListNode?] = []\\n        var head: ListNode?\\n        var prev: ListNode?\\n        \\n        while current != nil {\\n            if current!.val < x {\\n                left_nodes.append(current)\\n            } else {\\n                right_nodes.append(current)\\n            }\\n            \\n            current = current?.next\\n        }\\n        \\n        for node in left_nodes + right_nodes {\\n            node?.next = nil\\n            \\n            if head == nil {\\n                head = node\\n            } else {\\n                prev?.next = node\\n            }\\n            \\n            prev = node\\n        }\\n        \\n        return head\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278506,
                "title": "python-simple-and-easy-approach",
                "content": "# Partition List\\n**We basically need to keep track of first and last node of each partioned sub lists, so that we can connect them later.**\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        h1 = l1 = ListNode(0)\\n        h2 = l2 = ListNode(0)\\n        \\n        while head:\\n            if head.val < x:\\n                l1.next = head\\n                l1 = l1.next\\n            else:\\n                l2.next = head\\n                l2 = l2.next\\n            head = head.next\\n            \\n        l2.next = None\\n        l1.next = h2.next\\n        \\n        return h1.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        h1 = l1 = ListNode(0)\\n        h2 = l2 = ListNode(0)\\n        \\n        while head:\\n            if head.val < x:\\n                l1.next = head\\n                l1 = l1.next\\n            else:\\n                l2.next = head\\n                l2 = l2.next\\n            head = head.next\\n            \\n        l2.next = None\\n        l1.next = h2.next\\n        \\n        return h1.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29203,
                "title": "intuitive-javascript-solution",
                "content": "```\\nvar partition = function(head, x) {\\n    const dummyLess = new ListNode();\\n    const dummyMore = new ListNode();\\n    let node = head;\\n    let less = dummyLess;\\n    let more = dummyMore;\\n    while (node) {\\n        if (node.val < x) {\\n            less = less.next = node;\\n        } else {\\n            more = more.next = node;\\n        }\\n        node = node.next;\\n    }\\n    less.next = dummyMore.next;\\n    more.next = null;\\n    return dummyLess.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar partition = function(head, x) {\\n    const dummyLess = new ListNode();\\n    const dummyMore = new ListNode();\\n    let node = head;\\n    let less = dummyLess;\\n    let more = dummyMore;\\n    while (node) {\\n        if (node.val < x) {\\n            less = less.next = node;\\n        } else {\\n            more = more.next = node;\\n        }\\n        node = node.next;\\n    }\\n    less.next = dummyMore.next;\\n    more.next = null;\\n    return dummyLess.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3915216,
                "title": "c-don-t-leak-memory-index-pointer-instead-of-branches",
                "content": "There are a couple of solutions that allocate the dummy heads on the heap like so:\\n\\n```cpp\\n    ListNode* dummy = new ListeNode(0);\\n```\\n\\nIn many of these solutions this dummy head doesn\\'t get deleted, so the solution is leaking memory. This can easly be avoid be allocating the dummy head on the stack like so:\\n\\n```cpp\\n   ListNode dummy;\\n```\\n\\nThis avoids a heap allocation, which is faster. The memory is not leaked and it doesn\\'t require an explict ```delete```.\\n\\n# Approach 1: dummy node on stack and fewer branches\\nIn this solution we use the condition ```head->val >= x``` to index into the list pointers, this avoids a branch which is hard to predict by the CPU and also yields pretty short code.\\n\\n```cpp\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode lt;\\n        ListNode ge;\\n        array<ListNode*, 2> p = {&lt, &ge};\\n        for ( ; head; head = head->next) {\\n            const bool cond = head->val >= x;\\n            p[cond] = p[cond]->next = head;\\n        }\\n        p[1]->next = nullptr;\\n        p[0]->next = ge.next;\\n        return lt.next;\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ be the length of the list then the\\n\\n* Time complexity is $$O(n)$$ as we need to traverse the list once and the\\n\\n* Space comlexity is $$O(1)$$ as we only need dummy heads and two extra pointers.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [],
                "code": "```cpp\\n    ListNode* dummy = new ListeNode(0);\\n```\n```cpp\\n   ListNode dummy;\\n```\n```delete```\n```head->val >= x```\n```cpp\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode lt;\\n        ListNode ge;\\n        array<ListNode*, 2> p = {&lt, &ge};\\n        for ( ; head; head = head->next) {\\n            const bool cond = head->val >= x;\\n            p[cond] = p[cond]->next = head;\\n        }\\n        p[1]->next = nullptr;\\n        p[0]->next = ge.next;\\n        return lt.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3911215,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head==null||head.next==null)\\n            return head;\\n        ListNode start=null,fresh,prev=null;\\n        for(ListNode ptr=head;ptr!=null;ptr=ptr.next)\\n        {\\n            if(ptr.val<x)\\n            {\\n                fresh=new ListNode(ptr.val);\\n                if(start==null)\\n                    start=fresh;\\n                else\\n                    prev.next=fresh;\\n                prev=fresh;\\n            }\\n        }\\n        for(ListNode ptr=head;ptr!=null;ptr=ptr.next)\\n        {\\n            if(ptr.val>=x)\\n            {\\n                fresh=new ListNode(ptr.val);\\n                if(start==null)\\n                    start=fresh;\\n                else\\n                    prev.next=fresh;\\n                prev=fresh;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head==null||head.next==null)\\n            return head;\\n        ListNode start=null,fresh,prev=null;\\n        for(ListNode ptr=head;ptr!=null;ptr=ptr.next)\\n        {\\n            if(ptr.val<x)\\n            {\\n                fresh=new ListNode(ptr.val);\\n                if(start==null)\\n                    start=fresh;\\n                else\\n                    prev.next=fresh;\\n                prev=fresh;\\n            }\\n        }\\n        for(ListNode ptr=head;ptr!=null;ptr=ptr.next)\\n        {\\n            if(ptr.val>=x)\\n            {\\n                fresh=new ListNode(ptr.val);\\n                if(start==null)\\n                    start=fresh;\\n                else\\n                    prev.next=fresh;\\n                prev=fresh;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232034,
                "title": "partition-a-linked-list-around-a-given-value-in-python-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to partition a linked list around a given value `x`, such that all nodes less than `x` come before nodes greater than or equal to `x`, while preserving the original relative order of the nodes in each partition.\\n\\nOne way to approach this problem is to create two new linked lists: one for nodes less than `x` and another for nodes greater than or equal to `x`. We can then iterate over the original linked list and append each node to the appropriate new list based on its value. Finally, we merge the two new lists into one, preserving the relative order of the nodes in each list.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create two new linked lists: one for nodes less than `x` and another for nodes greater than or equal to `x`. Initialize two dummy nodes for the heads of each list, and two tail pointers to the dummy nodes.\\n\\n- Traverse the original linked list and append each node to the appropriate new list based on its value. If a node has a value less than `x`, append it to the `less` list and update `less_tail`. Otherwise, append it to the `greater` list and update `greater_tail`.\\n\\n- Terminate the `greater` list by setting the `next` pointer of `greater_tail` to `None`. Then, link the end of the `less` list to the beginning of the `greater` list by setting the `next` pointer of `less_tail` to the `next` pointer of `greater_head`.\\n\\n- Return the `next` pointer of the `less_head` dummy node, which will skip over the initial dummy node and give us the head of the new linked list.\\n# Complexity\\n- Time complexity: The algorithm makes a single pass over the linked list, so its time complexity is O(N), where N is the length of the linked list.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The algorithm uses a constant amount of extra space for the two dummy nodes and the two tail pointers, so its space complexity is O(1).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        less_head = less_tail = ListNode(0)\\n        greater_head = greater_tail = ListNode(0)\\n    \\n        while head:\\n            if head.val < x:\\n                less_tail.next = head\\n                less_tail = less_tail.next\\n            else:\\n                greater_tail.next = head\\n                greater_tail = greater_tail.next\\n            head = head.next\\n    \\n        greater_tail.next = None\\n        less_tail.next = greater_head.next\\n    \\n        return less_head.next\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        less_head = less_tail = ListNode(0)\\n        greater_head = greater_tail = ListNode(0)\\n    \\n        while head:\\n            if head.val < x:\\n                less_tail.next = head\\n                less_tail = less_tail.next\\n            else:\\n                greater_tail.next = head\\n                greater_tail = greater_tail.next\\n            head = head.next\\n    \\n        greater_tail.next = None\\n        less_tail.next = greater_head.next\\n    \\n        return less_head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157886,
                "title": "partition-list-simple-1-pass-partition-w-2-pointers-explained",
                "content": "There are a few approach using which this question can be solved. In the simplest solution, we can iterate over the list in the first pass and append all nodes less than `x` and in the second pass append all nodes greater than or equal to `x`.\\n\\nLet\\'s try to solve the problem in one-pass and O(1) Space without making duplicate copies of original nodes.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution (2-pointer partition)***\\n\\nWe can easily partition the list if we maintain two pointers -\\n* `lesser` - to store all the nodes from original list which are less than `x`.\\n* `greater` - to store all the nodes from original list which are greater than or equal to `x`.\\n\\nWe initialise both of these pointers to temporary / dummy nodes so that we can easily append to them without having to do any extra checks.\\n\\nWe would also need two more variable to store the heads of these pointers - `lesser_head` and `greater_head` which would be required later to join `lesser` to `greater_head` and finally return the head of partition list which would be `lesser_head -> next` (since lesser_head is dummy node, so return its next).\\n\\n\\n```\\n ListNode* partition(ListNode* head, int x) {\\n \\xA0 \\xA0 ListNode *lesser = new ListNode(-1), *greater = new ListNode(-1), *lesser_head = lesser, *greater_head = greater;\\n \\xA0 \\xA0 while(head){\\n \\xA0 \\xA0 \\xA0 \\xA0 if(head -> val < x) \\n                lesser -> next = head, lesser = lesser -> next;\\n \\xA0 \\xA0 \\xA0 \\xA0 else \\n                greater -> next = head, greater = greater -> next;\\n \\xA0 \\xA0 \\xA0 \\xA0 head = head -> next; \\n \\xA0 \\xA0 }\\n \\xA0 \\xA0 greater -> next = NULL;\\n \\xA0 \\xA0 lesser -> next = greater_head -> next;\\n \\xA0 \\xA0 return lesser_head -> next;\\n }\\n```\\n\\n***Time Complexity :*** **`O(N)`**, where `N` is the total number of nodes in original linked list.\\n***Space Complexity :*** **`O(1)`**. Note that we are not making duplicate nodes, just rearranging the original nodes in our partitioned",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n ListNode* partition(ListNode* head, int x) {\\n \\xA0 \\xA0 ListNode *lesser = new ListNode(-1), *greater = new ListNode(-1), *lesser_head = lesser, *greater_head = greater;\\n \\xA0 \\xA0 while(head){\\n \\xA0 \\xA0 \\xA0 \\xA0 if(head -> val < x) \\n                lesser -> next = head, lesser = lesser -> next;\\n \\xA0 \\xA0 \\xA0 \\xA0 else \\n                greater -> next = head, greater = greater -> next;\\n \\xA0 \\xA0 \\xA0 \\xA0 head = head -> next; \\n \\xA0 \\xA0 }\\n \\xA0 \\xA0 greater -> next = NULL;\\n \\xA0 \\xA0 lesser -> next = greater_head -> next;\\n \\xA0 \\xA0 return lesser_head -> next;\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1157785,
                "title": "c-super-simple-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *smaller_ptr = new ListNode(0), *greater_ptr = new ListNode(0), *ptr = head;\\n        ListNode *smaller = smaller_ptr, *greater = greater_ptr;\\n        \\n        while (ptr) {\\n            if (ptr->val < x) {\\n                smaller_ptr->next = ptr;\\n                smaller_ptr = smaller_ptr->next;\\n            }\\n            \\n            else {\\n                greater_ptr->next = ptr;\\n                greater_ptr = greater_ptr->next;\\n            }\\n            ptr = ptr->next;\\n        }\\n        \\n        greater_ptr->next = NULL;\\n        smaller_ptr->next = greater->next;\\n        return smaller->next;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *smaller_ptr = new ListNode(0), *greater_ptr = new ListNode(0), *ptr = head;\\n        ListNode *smaller = smaller_ptr, *greater = greater_ptr;\\n        \\n        while (ptr) {\\n            if (ptr->val < x) {\\n                smaller_ptr->next = ptr;\\n                smaller_ptr = smaller_ptr->next;\\n            }\\n            \\n            else {\\n                greater_ptr->next = ptr;\\n                greater_ptr = greater_ptr->next;\\n            }\\n            ptr = ptr->next;\\n        }\\n        \\n        greater_ptr->next = NULL;\\n        smaller_ptr->next = greater->next;\\n        return smaller->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29296,
                "title": "c-concise-solution",
                "content": "        \\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *dummy1 = new ListNode(0), *dummy2 = new ListNode(0), *node1, *node2;\\n        node1 = dummy1;\\n        node2 = dummy2;\\n        while (head) {\\n            if (head->val < x) {\\n                node1->next = head;\\n                node1 = node1->next;\\n            } else {\\n                node2->next = head;\\n                node2 = node2->next;\\n            }\\n            head = head->next;\\n        }\\n        node2->next = NULL;\\n        node1->next = dummy2->next;\\n        return dummy1->next;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        \\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *dummy1 = new ListNode(0), *dummy2 = new ListNode(0), *node1, *node2;\\n        node1 = dummy1;\\n        node2 = dummy2;\\n        while (head) {\\n            if (head->val < x) {\\n                node1->next = head;\\n                node1 = node1->next;\\n            } else {\\n                node2->next = head;\\n                node2 = node2->next;\\n            }\\n            head = head->next;\\n        }\\n        node2->next = NULL;\\n        node1->next = dummy2->next;\\n        return dummy1->next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3911378,
                "title": "beats-100-o-n-time-o-1-space-inplace-without-making-new-list",
                "content": "\\n# Approach\\nTraverse the linked list and when you see the node less than target then remove this node and insert it after the previous smaller node.\\nTake care of boundary cases.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1) extra space\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if(head==NULL) return head;\\n        if(head->next == NULL) return head;\\n        if(head->val >= x){\\n            ListNode* k1,*k2;\\n            k2 = head->next;\\n            k1 = head;\\n            while(k2 && k2->val>=x){                            \\n                k1 = k1->next;\\n                k2 = k2->next;\\n            }\\n            if(k2!=NULL){\\n                k1->next = k2->next;\\n                k2->next = head;\\n                head = k2;\\n            }\\n        }\\n        ListNode* l1,*l2,*l3;\\n        l1 = head;\\n        while(l1 && l1->next && l1->next->val < x && l1->val < x){\\n            l1 = l1->next;\\n        }    \\n        if(l1==NULL){\\n            return head;\\n        }                                                                  \\n        l2 = l1;\\n        l3 = l1->next;\\n        while(l3&&l2){\\n            if(l3->val >= x){\\n                l3 = l3->next;\\n                l2 = l2->next;\\n                continue;\\n            }\\n            l2->next = l3->next;\\n            l3->next = l1->next;\\n            l1->next = l3;\\n            l1 = l1->next;\\n            l3 = l2->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if(head==NULL) return head;\\n        if(head->next == NULL) return head;\\n        if(head->val >= x){\\n            ListNode* k1,*k2;\\n            k2 = head->next;\\n            k1 = head;\\n            while(k2 && k2->val>=x){                            \\n                k1 = k1->next;\\n                k2 = k2->next;\\n            }\\n            if(k2!=NULL){\\n                k1->next = k2->next;\\n                k2->next = head;\\n                head = k2;\\n            }\\n        }\\n        ListNode* l1,*l2,*l3;\\n        l1 = head;\\n        while(l1 && l1->next && l1->next->val < x && l1->val < x){\\n            l1 = l1->next;\\n        }    \\n        if(l1==NULL){\\n            return head;\\n        }                                                                  \\n        l2 = l1;\\n        l3 = l1->next;\\n        while(l3&&l2){\\n            if(l3->val >= x){\\n                l3 = l3->next;\\n                l2 = l2->next;\\n                continue;\\n            }\\n            l2->next = l3->next;\\n            l3->next = l1->next;\\n            l1->next = l3;\\n            l1 = l1->next;\\n            l3 = l2->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910919,
                "title": "rust-python-list-fast-solution",
                "content": "# Intuition \\uD83E\\uDD14\\nImagine you\\'re a \\uD83E\\uDD80 sorting pearls and stones from the ocean floor. The pearls (values less than `x`) are precious and you want to keep them close. The stones (values greater than or equal to `x`), while not as valuable, still need to be stored neatly. Now, imagine each pearl and stone is a node in the linked list. Our goal is to reorganize these nodes (or pearls and stones) based on their value relative to `x`.\\n\\n# Approach \\uD83D\\uDE80\\nOur \\uD83E\\uDD80 has two baskets - one for pearls (`before`) and another for stones (`after`). It picks items one-by-one (or traverses the list). Depending on the value of the item, it places it in the appropriate basket. Once all items are sorted, it connects the two baskets to have a neat collection.\\n\\n1. \\uD83D\\uDECD\\uFE0F Create two baskets (`before` and `after`).\\n2. \\uD83C\\uDF0A Dive through the ocean floor (or traverse the list).\\n3. \\uD83C\\uDF10 For each find, decide if it\\'s a pearl or a stone and place it in the appropriate basket.\\n4. \\uD83D\\uDD17 Once all items are collected, connect the two baskets.\\n\\n# Complexity \\uD83D\\uDD0D\\n- Time complexity: $$O(n)$$\\n  - Our \\uD83E\\uDD80 dives through the ocean floor once, collecting each item.\\n\\n- Space complexity: $$O(1)$$\\n  - The \\uD83E\\uDD80 uses only two baskets regardless of the number of pearls and stones.\\n\\n# Code \\uD83D\\uDCDC\\n``` Rust []\\nimpl Solution {\\n    pub fn partition(mut head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\\n        // Initialize two dummy nodes for \\'before\\' and \\'after\\' lists.\\n        let mut before = ListNode::new(0);\\n        let mut after = ListNode::new(0);\\n        \\n        // Pointers to the tails of \\'before\\' and \\'after\\' lists to aid in appending nodes.\\n        let mut before_tail = &mut before;\\n        let mut after_tail = &mut after;\\n\\n        // Traverse the original list.\\n        while let Some(mut node) = head {\\n            head = node.next.take();\\n            \\n            // Compare current node\\'s value with x and append to appropriate list.\\n            if node.val < x {\\n                before_tail.next = Some(node);\\n                before_tail = before_tail.next.as_mut().unwrap();\\n            } else {\\n                after_tail.next = Some(node);\\n                after_tail = after_tail.next.as_mut().unwrap();\\n            }\\n        }\\n\\n        // Connect the end of \\'before\\' list to the start of \\'after\\' list.\\n        before_tail.next = after.next.take();\\n\\n        // Return the merged list.\\n        before.next\\n    }\\n}\\n\\n```\\n``` Go []\\nfunc partition(head *ListNode, x int) *ListNode {\\n    // Initialize two dummy nodes for \\'before\\' and \\'after\\' lists.\\n    before := &ListNode{}\\n    after := &ListNode{}\\n    \\n    // Pointers to help in appending nodes to \\'before\\' and \\'after\\' lists.\\n    before_curr := before\\n    after_curr := after\\n    \\n    // Traverse the original list.\\n    for head != nil {\\n        // Compare current node\\'s value with x and append to appropriate list.\\n        if head.Val < x {\\n            before_curr.Next = head\\n            before_curr = before_curr.Next\\n        } else {\\n            after_curr.Next = head\\n            after_curr = after_curr.Next\\n        }\\n        head = head.Next\\n    }\\n    \\n    // Ensure \\'after\\' list\\'s end points to nil.\\n    after_curr.Next = nil\\n    \\n    // Connect the end of \\'before\\' list to the start of \\'after\\' list.\\n    before_curr.Next = after.Next\\n    \\n    // Return the merged list.\\n    return before.Next\\n}\\n```\\n``` Python []\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        # Initialize two dummy nodes for \\'before\\' and \\'after\\' lists.\\n        before, after = ListNode(0), ListNode(0)\\n        \\n        # Pointers to help in appending nodes to \\'before\\' and \\'after\\' lists.\\n        before_curr, after_curr = before, after\\n        \\n        # Traverse the original list.\\n        while head:\\n            # Compare current node\\'s value with x and append to appropriate list.\\n            if head.val < x:\\n                before_curr.next, before_curr = head, head\\n            else:\\n                after_curr.next, after_curr = head, head\\n            head = head.next\\n        \\n        # Ensure \\'after\\' list\\'s end points to None.\\n        after_curr.next = None\\n        \\n        # Connect the end of \\'before\\' list to the start of \\'after\\' list.\\n        before_curr.next = after.next\\n        \\n        # Return the merged list.\\n        return before.next\\n```\\n\\n\\n# Motivation \\uD83C\\uDF1F\\nGreat job diving deep into the ocean of algorithms with our Rusty \\uD83E\\uDD80, Pythonic \\uD83D\\uDC0D, and Gopher friends! Each problem you tackle not only sharpens your coding skills but also adds a pearl of wisdom to your collection. Remember, every challenge is a step forward. Keep coding, keep collecting pearls, and let\\'s make the ocean shine brighter! \\uD83C\\uDF0A\\uD83C\\uDF1F\\uD83D\\uDE80",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Rust",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "``` Rust []\\nimpl Solution {\\n    pub fn partition(mut head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\\n        // Initialize two dummy nodes for \\'before\\' and \\'after\\' lists.\\n        let mut before = ListNode::new(0);\\n        let mut after = ListNode::new(0);\\n        \\n        // Pointers to the tails of \\'before\\' and \\'after\\' lists to aid in appending nodes.\\n        let mut before_tail = &mut before;\\n        let mut after_tail = &mut after;\\n\\n        // Traverse the original list.\\n        while let Some(mut node) = head {\\n            head = node.next.take();\\n            \\n            // Compare current node\\'s value with x and append to appropriate list.\\n            if node.val < x {\\n                before_tail.next = Some(node);\\n                before_tail = before_tail.next.as_mut().unwrap();\\n            } else {\\n                after_tail.next = Some(node);\\n                after_tail = after_tail.next.as_mut().unwrap();\\n            }\\n        }\\n\\n        // Connect the end of \\'before\\' list to the start of \\'after\\' list.\\n        before_tail.next = after.next.take();\\n\\n        // Return the merged list.\\n        before.next\\n    }\\n}\\n\\n```\n``` Go []\\nfunc partition(head *ListNode, x int) *ListNode {\\n    // Initialize two dummy nodes for \\'before\\' and \\'after\\' lists.\\n    before := &ListNode{}\\n    after := &ListNode{}\\n    \\n    // Pointers to help in appending nodes to \\'before\\' and \\'after\\' lists.\\n    before_curr := before\\n    after_curr := after\\n    \\n    // Traverse the original list.\\n    for head != nil {\\n        // Compare current node\\'s value with x and append to appropriate list.\\n        if head.Val < x {\\n            before_curr.Next = head\\n            before_curr = before_curr.Next\\n        } else {\\n            after_curr.Next = head\\n            after_curr = after_curr.Next\\n        }\\n        head = head.Next\\n    }\\n    \\n    // Ensure \\'after\\' list\\'s end points to nil.\\n    after_curr.Next = nil\\n    \\n    // Connect the end of \\'before\\' list to the start of \\'after\\' list.\\n    before_curr.Next = after.Next\\n    \\n    // Return the merged list.\\n    return before.Next\\n}\\n```\n``` Python []\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        # Initialize two dummy nodes for \\'before\\' and \\'after\\' lists.\\n        before, after = ListNode(0), ListNode(0)\\n        \\n        # Pointers to help in appending nodes to \\'before\\' and \\'after\\' lists.\\n        before_curr, after_curr = before, after\\n        \\n        # Traverse the original list.\\n        while head:\\n            # Compare current node\\'s value with x and append to appropriate list.\\n            if head.val < x:\\n                before_curr.next, before_curr = head, head\\n            else:\\n                after_curr.next, after_curr = head, head\\n            head = head.next\\n        \\n        # Ensure \\'after\\' list\\'s end points to None.\\n        after_curr.next = None\\n        \\n        # Connect the end of \\'before\\' list to the start of \\'after\\' list.\\n        before_curr.next = after.next\\n        \\n        # Return the merged list.\\n        return before.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315449,
                "title": "java-easy-solution-using-stack",
                "content": "PLEASE UPVOTE IF YOU LIKE\\n```\\nclass Solution {\\n  public ListNode partition(ListNode head, int x) {\\n        if (head == null)\\n            return head;\\n        Stack<ListNode> stack1 = new Stack<>();\\n        Stack<ListNode> stack2 = new Stack<>();\\n        while (head != null) {\\n            if (head.val < x) {\\n                stack1.push(head);\\n            } else {\\n                stack2.push(head);\\n            }\\n            head = head.next;\\n        }\\n        head = null;\\n        while (!stack2.isEmpty()) {\\n            ListNode pop = stack2.pop();\\n            pop.next = head;\\n            head = pop;\\n        }\\n        while (!stack1.isEmpty()) {\\n            ListNode pop = stack1.pop();\\n            pop.next = head;\\n            head = pop;\\n        }\\n        return head;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n  public ListNode partition(ListNode head, int x) {\\n        if (head == null)\\n            return head;\\n        Stack<ListNode> stack1 = new Stack<>();\\n        Stack<ListNode> stack2 = new Stack<>();\\n        while (head != null) {\\n            if (head.val < x) {\\n                stack1.push(head);\\n            } else {\\n                stack2.push(head);\\n            }\\n            head = head.next;\\n        }\\n        head = null;\\n        while (!stack2.isEmpty()) {\\n            ListNode pop = stack2.pop();\\n            pop.next = head;\\n            head = pop;\\n        }\\n        while (!stack1.isEmpty()) {\\n            ListNode pop = stack1.pop();\\n            pop.next = head;\\n            head = pop;\\n        }\\n        return head;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315400,
                "title": "c-easy-to-understand-explanined-full-logic-space-o-1",
                "content": "**Approch :-**\\nThe main idea is, Keep track of node that is greater than equal to x, whenever we find a node that has lesser value than x, we shift the value and and increment the pointer.\\nwe have two cases,\\n`->node->val >= x:` In this case, we have to do nothing.\\n`-> node->val < x :` In this case we need replace our value before the nodes that has greater value than x.Our pointer cur represents the node that has greater value than x. So, we initialize a duplicate pointer. and shift the value until dup reaches the temp. At last we update the cur.\\n**Do upvote** if you like the code !!\\n\\n**Code :-**\\n```\\nListNode* partition(ListNode* head, int x) {\\n        if(head == NULL || head->next == NULL) return head;\\n        ListNode* temp = head, *cur = head;\\n        while(temp){\\n            if(temp->val < x){\\n                int value = temp->val;\\n                ListNode* dup = cur;\\n                while(dup){\\n                    int y = dup->val;\\n                    dup->val = value;\\n                    value = y;\\n                    if(dup == temp) break;\\n                    dup=dup->next;\\n                }\\n                cur = cur->next;\\n            }\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n```\\n**Do upvote** if you like the code !!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode* partition(ListNode* head, int x) {\\n        if(head == NULL || head->next == NULL) return head;\\n        ListNode* temp = head, *cur = head;\\n        while(temp){\\n            if(temp->val < x){\\n                int value = temp->val;\\n                ListNode* dup = cur;\\n                while(dup){\\n                    int y = dup->val;\\n                    dup->val = value;\\n                    value = y;\\n                    if(dup == temp) break;\\n                    dup=dup->next;\\n                }\\n                cur = cur->next;\\n            }\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3911466,
                "title": "c-two-pointer-day-15",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* before = new ListNode(0);\\n        ListNode* after = new ListNode(0);\\n        ListNode* temp_before = before;\\n        ListNode* temp_after = after;\\n        while(head!=NULL){\\n            if(head->val < x){\\n                temp_before->next = head;\\n                temp_before = head;\\n            }\\n            else {\\n                 temp_after->next = head;\\n                temp_after = head;\\n            }\\n            head = head->next;\\n        }\\n        temp_after->next = NULL;\\n        temp_before->next = after->next;\\n        return before->next;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/be59d078-846e-4a98-ac54-6e6dfd7f5570_1692075145.9488869.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* before = new ListNode(0);\\n        ListNode* after = new ListNode(0);\\n        ListNode* temp_before = before;\\n        ListNode* temp_after = after;\\n        while(head!=NULL){\\n            if(head->val < x){\\n                temp_before->next = head;\\n                temp_before = head;\\n            }\\n            else {\\n                 temp_after->next = head;\\n                temp_after = head;\\n            }\\n            head = head->next;\\n        }\\n        temp_after->next = NULL;\\n        temp_before->next = after->next;\\n        return before->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2318027,
                "title": "single-pass-o-n-constant-space-o-1-explained",
                "content": "Idea is to create two seperate linked lists,\\n**1. left : list having values < x** and **2. right : list having values >= x**\\n\\nand at last, just **link both of them** and return that list\\n\\nTime Complexity : **O(n)**\\nSpace Complexity : **O(1)**, because *we are **NOT** creating NEW Nodes*, we are just *borrowing Nodes from input list only* and just rearranging them\\n\\nIf you still have any doubts, please *Ask in Comments* \\uD83D\\uDCAC\\n\\n**PLEASE UPVOTE \\u2B06\\uFE0F\\uD83D\\uDD3C\\nIt Really Motivates :) \\u2728**\\n\\n```\\nListNode* partition(ListNode* head, int x) {\\n\\t// two dummy nodes for creating two different lists\\n\\t// 1. left : has values < x\\n\\t// 2. right : has values >= x\\n\\tListNode* left = new ListNode(), *right = new ListNode();\\n\\n\\t// heads for left and right\\n\\tListNode *newHead = left, *mid = right;\\n\\n\\twhile(head) {\\n\\t\\t// add in left list\\n\\t\\tif(head->val < x) {\\n\\t\\t\\tleft->next = head;\\n\\t\\t\\tleft = left->next;\\n\\t\\t} \\n\\t\\t// add in right list\\n\\t\\telse {\\n\\t\\t\\tright->next = head;\\n\\t\\t\\tright = right->next;\\n\\t\\t}\\n\\t\\t// move ahead\\n\\t\\thead = head->next;\\n\\t}\\n\\n\\t// linking left list with right list\\n\\tleft->next = mid->next;\\n\\tright->next = NULL;\\n\\n\\t// newHead is a dummy node, from it\\'s next our list starts\\n\\treturn newHead->next;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nListNode* partition(ListNode* head, int x) {\\n\\t// two dummy nodes for creating two different lists\\n\\t// 1. left : has values < x\\n\\t// 2. right : has values >= x\\n\\tListNode* left = new ListNode(), *right = new ListNode();\\n\\n\\t// heads for left and right\\n\\tListNode *newHead = left, *mid = right;\\n\\n\\twhile(head) {\\n\\t\\t// add in left list\\n\\t\\tif(head->val < x) {\\n\\t\\t\\tleft->next = head;\\n\\t\\t\\tleft = left->next;\\n\\t\\t} \\n\\t\\t// add in right list\\n\\t\\telse {\\n\\t\\t\\tright->next = head;\\n\\t\\t\\tright = right->next;\\n\\t\\t}\\n\\t\\t// move ahead\\n\\t\\thead = head->next;\\n\\t}\\n\\n\\t// linking left list with right list\\n\\tleft->next = mid->next;\\n\\tright->next = NULL;\\n\\n\\t// newHead is a dummy node, from it\\'s next our list starts\\n\\treturn newHead->next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1277292,
                "title": "c-92-faster-easy-to-understand-fast-clean-and-efficient-code",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome***\\n```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *LH=NULL,*LT=NULL,*RH=NULL,*RT=NULL;\\n        ListNode* A=head;\\n        while(A)\\n        {\\n            if(A->val<x)\\n            {\\n             if(LH==NULL)\\n              {\\n                 LH=A;\\n                 LT=A;\\n              } \\n              else \\n              {\\n                  LT->next=A;\\n                  LT=A;\\n              }   \\n            }\\n            else\\n            {\\n                if(RH==NULL)\\n              {\\n                 RH=A;\\n                 RT=A;\\n              } \\n              else \\n              {\\n                  RT->next=A;\\n                  RT=A;\\n              }  \\n            }\\n           A=A->next;        \\n        }\\n        if(LH==NULL&&RH!=NULL)\\n        {\\n            RT->next=NULL;\\n            return RH;\\n        }\\n        else if(LH!=NULL&&RH==NULL)\\n        {\\n            LT->next=NULL;\\n            return LH;\\n        }\\n        else if(LH&&RH)\\n        {\\n            LT->next=RH;\\n            RT->next=NULL;\\n        }\\n        return LH;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *LH=NULL,*LT=NULL,*RH=NULL,*RT=NULL;\\n        ListNode* A=head;\\n        while(A)\\n        {\\n            if(A->val<x)\\n            {\\n             if(LH==NULL)\\n              {\\n                 LH=A;\\n                 LT=A;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 29375,
                "title": "my-o-n-o-1-solution",
                "content": "I use tail to keep track of the end point where the nodes before it are smaller than x.\\n\\n----------\\n\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode dummy=new ListNode(0);\\n        dummy.next=head;\\n        ListNode p=dummy;\\n        ListNode tail=dummy;\\n        while(p!=null && p.next!=null){\\n            if(p.next.val>=x)\\n                p=p.next;\\n            else{\\n                if(p==tail){  // don't forget the edge cases when p==tail\\n                    tail=tail.next;\\n                    p=p.next;\\n                }\\n                else{\\n                    ListNode tmp=p.next;\\n                    p.next=tmp.next;\\n                    tmp.next=tail.next;\\n                    tail.next=tmp;\\n                    tail=tmp; // don't forget to move tail.\\n                }\\n            }\\n        }\\n        return dummy.next;\\n    }",
                "solutionTags": [],
                "code": "I use tail to keep track of the end point where the nodes before it are smaller than x.\\n\\n----------\\n\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode dummy=new ListNode(0);\\n        dummy.next=head;\\n        ListNode p=dummy;\\n        ListNode tail=dummy;\\n        while(p!=null && p.next!=null){\\n            if(p.next.val>=x)\\n                p=p.next;\\n            else{\\n                if(p==tail){  // don't forget the edge cases when p==tail\\n                    tail=tail.next;\\n                    p=p.next;\\n                }\\n                else{\\n                    ListNode tmp=p.next;\\n                    p.next=tmp.next;\\n                    tmp.next=tail.next;\\n                    tail.next=tmp;\\n                    tail=tmp; // don't forget to move tail.\\n                }\\n            }\\n        }\\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3913152,
                "title": "o-n-time-o-1-space-easy-explained-clean",
                "content": "# Intuition\\nWe must rearrange the nodes such that the nodes smaller than x will come before the nodes greater than or equal to x.\\n\\n# Approach\\nWe will create a dummy node and will start attaching nodes to it whenever we encounter nodes with value smaller than x.\\n\\nWe will also maintain a record of second part of the list as well, which contains the node greater than or equal to x.\\n\\n$$SecondPart$$ will contain the head of the list which will have nodes greater than or equal to x in the original order.\\n\\n$$SecondPartExists$$ is a boolean variable which is set to true as soon as first greater or equal element is attached to make sure cases like List = [1] and x = 3 works fine.\\n\\n# Complexity\\n- Time complexity: Since we only traverse the list once, TC is O(n).\\n\\n- Space complexity: We do not use any extra space to store the nodes except some dummy nodes and ListNode* pointers. So SC is also O(n).\\n\\n# **PLEASE UPVOTE :)\\u2705**\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* dummyHead = new ListNode();   //To store head of resulting list\\n        ListNode* dummy = dummyHead; //to point to the tail of resulting list\\n        ListNode* prev = NULL, *curr = head; //to point to the nodes in given list\\n        ListNode* secondPart = new ListNode(); //to maintain track of nodes greater than x\\n        bool secondPartExists = false; //to indicate greater and smaller elements exist\\n\\n        while(curr != NULL){\\n            if(curr->val >= x){\\n                if(prev == NULL){\\n                    secondPartExists = true; //found first greater element\\n                    secondPart = curr; \\n                }\\n                prev = curr;\\n                curr = curr->next;\\n            }\\n            else{\\n                dummy->next = curr;\\n                dummy = dummy->next;\\n                if(prev != NULL)prev->next = curr->next;\\n                curr = curr->next;\\n                dummy->next = NULL;\\n            }\\n        }\\n\\n        if(secondPartExists) dummy->next = secondPart;\\n\\n        return dummyHead->next; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* dummyHead = new ListNode();   //To store head of resulting list\\n        ListNode* dummy = dummyHead; //to point to the tail of resulting list\\n        ListNode* prev = NULL, *curr = head; //to point to the nodes in given list\\n        ListNode* secondPart = new ListNode(); //to maintain track of nodes greater than x\\n        bool secondPartExists = false; //to indicate greater and smaller elements exist\\n\\n        while(curr != NULL){\\n            if(curr->val >= x){\\n                if(prev == NULL){\\n                    secondPartExists = true; //found first greater element\\n                    secondPart = curr; \\n                }\\n                prev = curr;\\n                curr = curr->next;\\n            }\\n            else{\\n                dummy->next = curr;\\n                dummy = dummy->next;\\n                if(prev != NULL)prev->next = curr->next;\\n                curr = curr->next;\\n                dummy->next = NULL;\\n            }\\n        }\\n\\n        if(secondPartExists) dummy->next = secondPart;\\n\\n        return dummyHead->next; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315157,
                "title": "daily-leetcoding-challenge-july-day-22",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/partition-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointer Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/partition-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1630355,
                "title": "c-linked-list-to-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if(!head || !head->next) return head;\\n        \\n        vector<int> nums;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            nums.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        \\n        vector<int> res;\\n        for(int val : nums)\\n            if(val < x)\\n                res.push_back(val);\\n\\n        for(int val : nums)\\n            if(val >= x)\\n                res.push_back(val);\\n        \\n        \\n        temp = head;\\n        int i = 0;\\n        while(temp != NULL){\\n            temp->val = res[i++];\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if(!head || !head->next) return head;\\n        \\n        vector<int> nums;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            nums.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        \\n        vector<int> res;\\n        for(int val : nums)\\n            if(val < x)\\n                res.push_back(val);\\n\\n        for(int val : nums)\\n            if(val >= x)\\n                res.push_back(val);\\n        \\n        \\n        temp = head;\\n        int i = 0;\\n        while(temp != NULL){\\n            temp->val = res[i++];\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492448,
                "title": "rust-0ms-clean",
                "content": "```rust\\npub fn partition(mut head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\\n    let (mut lhead, mut hhead) = (None, None);\\n    let (mut low, mut high) = (&mut lhead, &mut hhead);\\n    while let Some(mut node) = head {\\n        head = node.next.take();\\n        if node.val < x {\\n            *low = Some(node);\\n            low = &mut low.as_deref_mut().unwrap().next;\\n        } else {\\n            *high = Some(node);\\n            high = &mut high.as_deref_mut().unwrap().next;\\n        }\\n    }\\n    *low = hhead;\\n    lhead\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\npub fn partition(mut head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\\n    let (mut lhead, mut hhead) = (None, None);\\n    let (mut low, mut high) = (&mut lhead, &mut hhead);\\n    while let Some(mut node) = head {\\n        head = node.next.take();\\n        if node.val < x {\\n            *low = Some(node);\\n            low = &mut low.as_deref_mut().unwrap().next;\\n        } else {\\n            *high = Some(node);\\n            high = &mut high.as_deref_mut().unwrap().next;\\n        }\\n    }\\n    *low = hhead;\\n    lhead\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 858387,
                "title": "clean-python-100-speed",
                "content": "**Clean Python | 100% Speed**\\n\\n```\\n\\nclass Solution:\\n    def partition(self, head, x):\\n        # h1,h2: Linked Lists with numbers Lower and GEQ (greater or equal) than X respectively\\n        h1, h2 = None, None\\n        # -------------------------------------------------------------------\\n        #     Main Loop (Iterate through Linked List starting at Head)\\n        # -------------------------------------------------------------------\\n        n      = head\\n        while n:\\n            if n.val<x:\\n                if h1:\\n                    n1.next = n\\n                else:\\n                    h1      = n\\n                n1 = n\\n            else:\\n                if h2:\\n                    n2.next = n\\n                else:\\n                    h2      = n\\n                n2 = n\\n            n = n.next\\n        # -------------------------------------------------------------------\\n        #     Fix Tails\\n        # -------------------------------------------------------------------\\n        if h1:\\n            n1.next = h2\\n        if h2:\\n            n2.next = None\\n        # -------------------------------------------------------------------\\n        #     Try to Return Non-Empty Linked List\\n        # -------------------------------------------------------------------\\n        return h1 or h2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def partition(self, head, x):\\n        # h1,h2: Linked Lists with numbers Lower and GEQ (greater or equal) than X respectively\\n        h1, h2 = None, None\\n        # -------------------------------------------------------------------\\n        #     Main Loop (Iterate through Linked List starting at Head)\\n        # -------------------------------------------------------------------\\n        n      = head\\n        while n:\\n            if n.val<x:\\n                if h1:\\n                    n1.next = n\\n                else:\\n                    h1      = n\\n                n1 = n\\n            else:\\n                if h2:\\n                    n2.next = n\\n                else:\\n                    h2      = n\\n                n2 = n\\n            n = n.next\\n        # -------------------------------------------------------------------\\n        #     Fix Tails\\n        # -------------------------------------------------------------------\\n        if h1:\\n            n1.next = h2\\n        if h2:\\n            n2.next = None\\n        # -------------------------------------------------------------------\\n        #     Try to Return Non-Empty Linked List\\n        # -------------------------------------------------------------------\\n        return h1 or h2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 349660,
                "title": "simple-recursive-solution-runtime-and-memory-both-100-with-detailed-explanations",
                "content": "First of all, when using recursion, the function callback loop is effectively the first pointer. And the direction to which this pointer moves is determined by how each function call was made. In the simplest case, if ```head``` was passed in, ```head.next``` is passed in the function call within the current function. Therefore the recursion pointer moves from the end of the linked list to where the very first function call was made.\\n\\nThe tricky part is what to use as the second pointer and how to use it. Either the start of the linked list, the \"head\", (stored by making an assignment outside of the recursion function), or the end of the linked list, the \"tail\", (stored when recursion pointer begins to move), can be used as the second pointer. There are also two operations we can do at this pointer: either repeatedly append the node after the pointer, or repeatedly insert the node before the pointer. Appending keeps the order of nodes and inserting reverse the order of nodes. But since the recursion pointer is moving in reverse, in order to keep the order of the original nodes, we have to use inserting to reverse back.\\nNow at this point, it would appear that both inserting at the head and inserting at the tail would work. But it turns out inserting at the tail is actually easier, at least as far as I\\'m concerned. The reason would become apparent after I lay out my implementation.\\n\\nFirst, we need to trigger the cascading function call backs. This  can be simply done by the recursion function return a value other than the function itself, which naturally is the first line. Next, we need to figure out what needs to be done whenever we encounter a node with val >= x. Sine singly-linked list knows only what\\'s next, inserting a node can only be done by inserting it after a certain node. Since we are inserting the node with val >=x BEFORE the tail to perserve the original order, what we actually store is not the tail itself, but the node right before the tail, call it ```before_tail```. \\nNow inserting the node (call it ```node```) requires two steps: 1. Connect ```node``` to ```before_tail```, by a) ```node.next=before_tail.next```, and b) ```before_tail.next=node```. 2. Sewing back the link from which we took ```node```, by... well, actually we can\\'t do this within the function call because we don\\'t know what\\'s before ```node``` since only ```node``` was passed in, not the previous node. Therefore, this last step has to be done by the function call directly above and this is why the resursion call is ```head.next=partition(head.next, x)```, which reconnect the severed link. \\nNow setting up the tail is not so simple either. We could just store it the first time we encounter the actual tail. But remember what we need to store is ```before_tail```, not tail itself. However, if the tail has val<2, we don\\'t want node with val>=x inserted before it, we want it inserted after it. So in this case, ```null``` is actually new tail and we store the old tail as ```before_tail```. Otherwise, we need to wait one more function call. The good thing though, is that if a lot of nodes adjacent to the tail has val>=x, we don\\'t need to do anything but wait one more function call.\\n\\nNow why was inserting at the head difficult to implement? At least from my few attempts at implementing such algorithm, it seems the problem was that we can\\'t just wrap an additional function call above the initial one. Now hear me out here, it\\'s actually not that complicated. Remember the last step in inserting a node is sewing back the severed link? If the last recursion call (the one you pass in the original head in as the node) returns with the node that needs to be sewed back on, we can\\'t do this unless we store the node that comes before the original head, which should be the first node that was ever inserted. This means storing two nodes at the same time now. You can of course have the operations done on the node after the node in the resursive function, but that creates much more problem than solved. Trust me, I went down that rabbit whole and it was ugly.\\n\\nI hope this has been helpful.\\n\\n\\n```\\nclass Solution{\\n    ListNode before_tail=null;\\n    public ListNode partition(ListNode head, int x){\\n        if (head == null) return null;\\n        head.next = partition(head.next, x);\\n        if (before_tail == null) {\\n            if (head.val < x) before_tail = head;\\n            return head;\\n        }\\n        else{\\n            if (head.val >= x) {\\n                ListNode next = head.next;\\n                head.next = before_tail.next;\\n                before_tail.next = head;\\n                return next;\\n            }\\n            else return head;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```head```\n```head.next```\n```before_tail```\n```node```\n```node```\n```before_tail```\n```node.next=before_tail.next```\n```before_tail.next=node```\n```node```\n```node```\n```node```\n```head.next=partition(head.next, x)```\n```before_tail```\n```null```\n```before_tail```\n```\\nclass Solution{\\n    ListNode before_tail=null;\\n    public ListNode partition(ListNode head, int x){\\n        if (head == null) return null;\\n        head.next = partition(head.next, x);\\n        if (before_tail == null) {\\n            if (head.val < x) before_tail = head;\\n            return head;\\n        }\\n        else{\\n            if (head.val >= x) {\\n                ListNode next = head.next;\\n                head.next = before_tail.next;\\n                before_tail.next = head;\\n                return next;\\n            }\\n            else return head;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911476,
                "title": "easy-solution-by-using-2-linked-list-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince the relative order should remain same, we need to store elements seperately - element<x &element>=x.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe required 2 linked list  to store elements seperate.\\niterate the given linked list -\\nleftTail stores element<x.\\nrightTail stores element>=x.\\nIn the end merge the 2 linked list.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code-JAVA\\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode left= new ListNode(0);\\n        ListNode right = new ListNode(0);\\n\\n        ListNode leftTail = left;\\n        ListNode rightTail = right;\\n\\n        while(head!=null){\\n            if(head.val<x){\\n                leftTail.next = head;\\n                leftTail = leftTail.next;\\n            }\\n            else{\\n                rightTail.next = head;\\n                rightTail = rightTail.next;\\n            }\\n            head=head.next;\\n        }\\n        leftTail.next = right.next;\\n        rightTail.next = null;\\n        return left.next;\\n    }\\n}\\n```\\n\\n# Code-CPP\\n```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *left = new ListNode(0);\\n        ListNode *right = new ListNode(0);\\n        \\n        ListNode *leftTail = left;\\n        ListNode *rightTail = right;\\n        \\n        while(head != NULL){\\n            if(head->val < x){\\n                leftTail->next = head;\\n                leftTail = leftTail->next;\\n            }\\n            else{\\n                rightTail->next = head;\\n                rightTail = rightTail->next;\\n            }\\n            head = head->next;\\n        }\\n        \\n        leftTail->next = right->next;\\n        rightTail->next = NULL;\\n        \\n        return left->next;\\n    }\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode left= new ListNode(0);\\n        ListNode right = new ListNode(0);\\n\\n        ListNode leftTail = left;\\n        ListNode rightTail = right;\\n\\n        while(head!=null){\\n            if(head.val<x){\\n                leftTail.next = head;\\n                leftTail = leftTail.next;\\n            }\\n            else{\\n                rightTail.next = head;\\n                rightTail = rightTail.next;\\n            }\\n            head=head.next;\\n        }\\n        leftTail.next = right.next;\\n        rightTail.next = null;\\n        return left.next;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *left = new ListNode(0);\\n        ListNode *right = new ListNode(0);\\n        \\n        ListNode *leftTail = left;\\n        ListNode *rightTail = right;\\n        \\n        while(head != NULL){\\n            if(head->val < x){\\n                leftTail->next = head;\\n                leftTail = leftTail->next;\\n            }\\n            else{\\n                rightTail->next = head;\\n                rightTail = rightTail->next;\\n            }\\n            head = head->next;\\n        }\\n        \\n        leftTail->next = right->next;\\n        rightTail->next = NULL;\\n        \\n        return left->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316099,
                "title": "beginner-friendly-o-n-two-pointer",
                "content": "Idea is to separate the list into two lists: One of smaller node values (`before` as head) and other for greater than and equal values (`after` as head). And then merge them like this `before` -> `after`\\n\\nTo complete the process in just single traversal, keep track of last node of each of two separated lists, denoted by i(for list with smaller values) and j(for list with greater values).\\n\\n```\\nclass Solution {\\n    \\n    ListNode before, after, i, j;\\n    \\n    public ListNode partition(ListNode head, int x) {\\n        \\n        if(head == null) return head;\\n        ListNode temp = head;\\n        \\n        // Traversing all the nodes to make two separate lists\\n        while(temp != null){\\n            addNode(temp.val, temp.val < x);\\n            temp = temp.next;\\n        }\\n        \\n        // Case if the list with smaller values has no items\\n        if(i == null) return after;\\n        \\n        // Else merge the lists\\n        else i.next = after;\\n        \\n        return before;\\n    }\\n    \\n    private void addNode(int val, boolean isLess){\\n        \\n        // Add node in smaller list (`before`)\\n        if(isLess){\\n            \\n            // Initialize the head of smaller list\\n            if(before == null){\\n                before = new ListNode(val);\\n                i = before;\\n            }\\n            \\n            // Add node at the end of list and move pointer `i` to the last node\\n            else{\\n                i.next = new ListNode(val);\\n                i = i.next;\\n            }\\n        }\\n        \\n        // Add node in greater list (`after`)\\n        else{\\n            \\n            // Initialize the head of greater list\\n            if(after == null){\\n                after = new ListNode(val);\\n                j = after;\\n            }\\n            \\n            // Add node at the end of list and move pointer `j` to the last node\\n            else{\\n                j.next = new ListNode(val);\\n                j = j.next;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    ListNode before, after, i, j;\\n    \\n    public ListNode partition(ListNode head, int x) {\\n        \\n        if(head == null) return head;\\n        ListNode temp = head;\\n        \\n        // Traversing all the nodes to make two separate lists\\n        while(temp != null){\\n            addNode(temp.val, temp.val < x);\\n            temp = temp.next;\\n        }\\n        \\n        // Case if the list with smaller values has no items\\n        if(i == null) return after;\\n        \\n        // Else merge the lists\\n        else i.next = after;\\n        \\n        return before;\\n    }\\n    \\n    private void addNode(int val, boolean isLess){\\n        \\n        // Add node in smaller list (`before`)\\n        if(isLess){\\n            \\n            // Initialize the head of smaller list\\n            if(before == null){\\n                before = new ListNode(val);\\n                i = before;\\n            }\\n            \\n            // Add node at the end of list and move pointer `i` to the last node\\n            else{\\n                i.next = new ListNode(val);\\n                i = i.next;\\n            }\\n        }\\n        \\n        // Add node in greater list (`after`)\\n        else{\\n            \\n            // Initialize the head of greater list\\n            if(after == null){\\n                after = new ListNode(val);\\n                j = after;\\n            }\\n            \\n            // Add node at the end of list and move pointer `j` to the last node\\n            else{\\n                j.next = new ListNode(val);\\n                j = j.next;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2204259,
                "title": "solution-in-c-with-explanation",
                "content": "Idea is very simple. Just make two linked list. Add all elements less than x in less linked list and add all elements higher or equal to x in high linked list. At the end, join the less linked list last element with first element of high linked list.\\n\\n**Code**\\n```\\nstruct ListNode* partition(struct ListNode* head, int x){\\n    struct ListNode* less = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    less->val = 0;\\n    less->next = NULL;\\n    \\n    struct ListNode* high = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    high->val = 0;\\n    high->next = NULL;\\n    \\n    struct ListNode* lessT = less;\\n    struct ListNode* highT = high;\\n    \\n    while(head){\\n        if(head->val < x){\\n            lessT->next = head;\\n            lessT = lessT->next;\\n        }\\n        else{\\n            highT->next = head;\\n            highT = highT->next;\\n        }\\n        head = head->next;\\n    }\\n    lessT->next = high->next;\\n    highT->next = NULL;\\n    \\n    \\n    return less->next;\\n}\\n```\\n**Please upvote if you found the solution helpful**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct ListNode* partition(struct ListNode* head, int x){\\n    struct ListNode* less = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    less->val = 0;\\n    less->next = NULL;\\n    \\n    struct ListNode* high = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    high->val = 0;\\n    high->next = NULL;\\n    \\n    struct ListNode* lessT = less;\\n    struct ListNode* highT = high;\\n    \\n    while(head){\\n        if(head->val < x){\\n            lessT->next = head;\\n            lessT = lessT->next;\\n        }\\n        else{\\n            highT->next = head;\\n            highT = highT->next;\\n        }\\n        head = head->next;\\n    }\\n    lessT->next = high->next;\\n    highT->next = NULL;\\n    \\n    \\n    return less->next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352614,
                "title": "java-one-pass-beats-100-clear-code",
                "content": "Hopefully u will find it useful!\\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode less = new ListNode(0), lessCurr = less;\\n        ListNode greater = new ListNode(0), greaterCurr = greater;\\n        while (head != null) {\\n            if (head.val < x) {\\n                lessCurr.next = new ListNode(head.val);\\n                lessCurr = lessCurr.next;\\n            } else {\\n                greaterCurr.next = new ListNode(head.val);\\n                greaterCurr = greaterCurr.next;\\n            }\\n            head = head.next;\\n        }\\n        lessCurr.next = greater.next;\\n        return less.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode less = new ListNode(0), lessCurr = less;\\n        ListNode greater = new ListNode(0), greaterCurr = greater;\\n        while (head != null) {\\n            if (head.val < x) {\\n                lessCurr.next = new ListNode(head.val);\\n                lessCurr = lessCurr.next;\\n            } else {\\n                greaterCurr.next = new ListNode(head.val);\\n                greaterCurr = greaterCurr.next;\\n            }\\n            head = head.next;\\n        }\\n        lessCurr.next = greater.next;\\n        return less.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351273,
                "title": "intuitive-python-approach",
                "content": "Most of LinkedList problems can be solved easily using extra space.\\n\\nIt is intuitive to maintain two partitions(lists): one for nodes less than x, the other for nodes greater than or equal to x.\\n\\nTo save `None` checks, we create dummy nodes in front of the two partitions\\' heads: `dummy_smaller`, `dummy_larger`.\\n\\nIterating over the original list can preserve original relative order in each of the two partitions.\\n\\nNote that end nodes of two partitions should be processed at last.\\n```\\n        larger_cur.next = None\\n        smaller_cur.next = dummy_larger.next\\n```\\n\\n```\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        dummy_smaller = smaller_cur = ListNode(0)\\n        dummy_larger = larger_cur = ListNode(0)\\n        cur = head\\n        while cur:\\n            if cur.val < x:\\n                smaller_cur.next = cur\\n                smaller_cur = smaller_cur.next\\n            else:\\n                larger_cur.next = cur\\n                larger_cur = larger_cur.next\\n            cur = cur.next\\n        larger_cur.next = None\\n        smaller_cur.next = dummy_larger.next\\n        return dummy_smaller.next\\n\\n```",
                "solutionTags": [],
                "code": "```\\n        larger_cur.next = None\\n        smaller_cur.next = dummy_larger.next\\n```\n```\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        dummy_smaller = smaller_cur = ListNode(0)\\n        dummy_larger = larger_cur = ListNode(0)\\n        cur = head\\n        while cur:\\n            if cur.val < x:\\n                smaller_cur.next = cur\\n                smaller_cur = smaller_cur.next\\n            else:\\n                larger_cur.next = cur\\n                larger_cur = larger_cur.next\\n            cur = cur.next\\n        larger_cur.next = None\\n        smaller_cur.next = dummy_larger.next\\n        return dummy_smaller.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29210,
                "title": "clean-c-6ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode left(0);\\n        ListNode right(0);\\n        ListNode* l = &left;\\n        ListNode* r = &right;\\n        ListNode* cur = head;\\n        while(cur){\\n            if(cur->val < x){\\n                l->next = cur;\\n                l = l->next;\\n            }\\n            else{\\n                r->next = cur;\\n                r = r->next;\\n            }\\n            cur = cur->next;\\n        }\\n        r->next = NULL;\\n        l->next = right.next;\\n        return left.next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode left(0);\\n        ListNode right(0);\\n        ListNode* l = &left;\\n        ListNode* r = &right;\\n        ListNode* cur = head;\\n        while(cur){\\n            if(cur->val < x){\\n                l->next = cur;\\n                l = l->next;\\n            }\\n            else{\\n                r->next = cur;\\n                r = r->next;\\n            }\\n            cur = cur->next;\\n        }\\n        r->next = NULL;\\n        l->next = right.next;\\n        return left.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29272,
                "title": "my-ac-java-code",
                "content": "public ListNode partition(ListNode head, int x) {\\n\\t\\t\\n\\t\\tListNode firstHead = new ListNode(0);\\n\\t\\tfirstHead.next = head;\\n\\t\\tListNode secondHead = new ListNode(x);\\n\\t\\n\\t\\t\\n\\t\\tListNode first = firstHead;\\n\\t\\tListNode second = secondHead;\\n\\t\\tListNode curNode = head;\\n\\t\\twhile(curNode!=null){\\n\\t\\t\\tListNode tmp = curNode.next;\\n\\t\\t\\tif(curNode.val<x){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfirst.next = curNode;\\n\\t\\t\\t\\tfirst = curNode; \\n\\t\\t\\t}else{\\n\\t\\t\\t\\tsecond.next = curNode;\\n\\t\\t\\t\\tsecond = curNode;\\n\\t\\t\\t\\tsecond.next = null;// important\\n\\t\\t\\t}\\n\\t\\t\\tcurNode = tmp;\\n\\t\\t}\\n\\t\\tfirst.next = secondHead.next;\\n\\t\\treturn firstHead.next;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "public ListNode partition(ListNode head, int x) {\\n\\t\\t\\n\\t\\tListNode firstHead = new ListNode(0);\\n\\t\\tfirstHead.next = head;\\n\\t\\tListNode secondHead = new ListNode(x);\\n\\t\\n\\t\\t\\n\\t\\tListNode first = firstHead;\\n\\t\\tListNode second = secondHead;\\n\\t\\tListNode curNode = head;\\n\\t\\twhile(curNode!=null){\\n\\t\\t\\tListNode tmp = curNode.next;\\n\\t\\t\\tif(curNode.val<x){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfirst.next = curNode;\\n\\t\\t\\t\\tfirst = curNode; \\n\\t\\t\\t}else{\\n\\t\\t\\t\\tsecond.next = curNode;\\n\\t\\t\\t\\tsecond = curNode;\\n\\t\\t\\t\\tsecond.next = null;// important\\n\\t\\t\\t}\\n\\t\\t\\tcurNode = tmp;\\n\\t\\t}\\n\\t\\tfirst.next = secondHead.next;\\n\\t\\treturn firstHead.next;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 29325,
                "title": "share-my-solution-10ms-in-c",
                "content": "\\n\\n    class Solution {\\n    public:\\n        ListNode *partition(ListNode *head, int x) {\\n            ListNode *newHead = new ListNode(0);\\n            newHead->next = head;\\n            ListNode *p1 = newHead;\\n            while (p1->next) {    \\n                if((p1->next->val)<x)\\n                    p1 = p1->next;   //find the beginning\\n                else\\n                    break;\\n            }\\n            ListNode *p2 = p1;\\n            \\n            ListNode *nextOne;\\n            while (p2->next) {\\n                nextOne = p2->next;\\n                if (nextOne->val<x){\\n                    p2->next = nextOne->next;\\n                    nextOne->next = p1->next;\\n                    p1->next = nextOne;\\n                    p1 = p1->next;\\n                }else{\\n                    p2 = p2->next;\\n                }\\n            }\\n            return newHead->next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode *partition(ListNode *head, int x) {\\n            ListNode *newHead = new ListNode(0);\\n            newHead->next = head;\\n            ListNode *p1 = newHead;\\n            while (p1->next) {    \\n                if((p1->next->val)<x)\\n                    p1 = p1->next;   //find the beginning\\n                else\\n                    break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3949649,
                "title": "best-o-n-solution",
                "content": "# Approach\\nTwo Pointer\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* dummy1 = new ListNode();\\n        ListNode* temp1 = dummy1;\\n        ListNode* dummy2 = new ListNode();\\n        ListNode* temp2 = dummy2;\\n        while (head != NULL) {\\n            if (head->val < x) {\\n                temp1->next = head;\\n                temp1 = temp1->next;\\n            } else {\\n                temp2->next = head;\\n                temp2 = temp2->next;\\n            }\\n            head = head->next;\\n        }\\n        if (dummy1->next == NULL)\\n            return dummy2->next;\\n        temp1->next = dummy2->next;\\n        temp2->next = NULL;\\n        return dummy1->next;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* dummy1 = new ListNode();\\n        ListNode* temp1 = dummy1;\\n        ListNode* dummy2 = new ListNode();\\n        ListNode* temp2 = dummy2;\\n        while (head != NULL) {\\n            if (head->val < x) {\\n                temp1->next = head;\\n                temp1 = temp1->next;\\n            } else {\\n                temp2->next = head;\\n                temp2 = temp2->next;\\n            }\\n            head = head->next;\\n        }\\n        if (dummy1->next == NULL)\\n            return dummy2->next;\\n        temp1->next = dummy2->next;\\n        temp2->next = NULL;\\n        return dummy1->next;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911684,
                "title": "86-partition-list-c-rust",
                "content": "# Intuition\\nSuppose we have the following linked list:\\n```\\n1 -> 4 -> 3 -> 2 -> 5 -> 2\\n```\\nAnd `x = 3`.\\n\\nWe\\'ll walk through the code step by step:\\n\\n1. Initialize two dummy nodes `d1` and `d2`:\\n   ```\\n   d1: [0]->nullptr\\n   d2: [0]->nullptr\\n   ```\\n\\n2. Initialize `n1` and `n2` pointers to point to the dummy nodes `d1` and `d2`.\\n\\n3. Loop starts:\\n   - Current node: 1\\n     Since 1 < 3, append to the linked list represented by `d1`. Update `n1` to point to 1.\\n     ```\\n     d1: [0]->[1]->nullptr\\n     d2: [0]->nullptr\\n     ```\\n   - Current node: 4\\n     Since 4 >= 3, append to the linked list represented by `d2`. Update `n2` to point to 4.\\n     ```\\n     d1: [0]->[1]->nullptr\\n     d2: [0]->[4]->nullptr\\n     ```\\n   - Current node: 3\\n     Since 3 >= 3, append to the linked list represented by `d2`. Update `n2` to point to 3.\\n     ```\\n     d1: [0]->[1]->nullptr\\n     d2: [0]->[4]->[3]->nullptr\\n     ```\\n   - Current node: 2\\n     Since 2 < 3, append to the linked list represented by `d1`. Update `n1` to point to 2.\\n     ```\\n     d1: [0]->[1]->[2]->nullptr\\n     d2: [0]->[4]->[3]->nullptr\\n     ```\\n   - Current node: 5\\n     Since 5 >= 3, append to the linked list represented by `d2`. Update `n2` to point to 5.\\n     ```\\n     d1: [0]->[1]->[2]->nullptr\\n     d2: [0]->[4]->[3]->[5]->nullptr\\n     ```\\n   - Current node: 2\\n     Since 2 < 3, append to the linked list represented by `d1`. Update `n1` to point to 2.\\n     ```\\n     d1: [0]->[1]->[2]->[2]->nullptr\\n     d2: [0]->[4]->[3]->[5]->nullptr\\n     ```\\n\\n4. The loop ends. Set `n2->next` and `n1->next` to `nullptr` to terminate the partitioned linked lists.\\n   ```\\n   d1: [0]->[1]->[2]->[2]->nullptr\\n   d2: [0]->[4]->[3]->[5]->nullptr\\n   ```\\n\\n5. Connect the partitioned linked lists: Update the `next` pointer of the last node in the linked list represented by `d1` (`n1`) to point to the first node in the linked list represented by `d2` (`d2->next`).\\n   ```\\n   d1: [0]->[1]->[2]->[2]->[4]->[3]->[5]->nullptr\\n   d2: [0]->[4]->[3]->[5]->nullptr\\n   ```\\n\\n6. Return `d1->next`, which points to the head of the partitioned linked list:\\n   ```\\n   1 -> 2 -> 2 -> 4 -> 3 -> 5\\n   ```\\n\\nSo, the final partitioned linked list is `1 -> 2 -> 2 -> 4 -> 3 -> 5`, where nodes with values less than 3 come before nodes with values greater than or equal to 3.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *d1 = new ListNode(0), *d2 = new ListNode(0), *n1, *n2;\\n        n1 = d1;\\n        n2=d2;\\n        while(head!=NULL){\\n            if(head->val < x){\\n                n1->next=head;\\n                n1=n1->next;\\n            } else{\\n                n2->next=head;\\n                n2=n2->next;\\n            }\\n            head=head->next;\\n        }\\n\\n        n2->next=NULL;\\n        n1->next=d2->next;\\n        return d1->next;\\n\\n    }\\n};\\n\\n```\\n\\n```\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\nimpl Solution {\\n    pub fn partition(head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\\n        let mut less_dummy =ListNode::new(0);\\n        let mut greater_or_equal_dummy = ListNode::new(0);\\n        let mut less_tail = &mut less_dummy;\\n        let mut greater_or_equal_tail = &mut greater_or_equal_dummy;\\n        let mut current = head;\\n\\n\\n        while let Some(mut node) = current.take() {\\n            current = node.next.take();\\n            if node.val < x {\\n                less_tail.next = Some(node);\\n                less_tail = less_tail.next.as_mut().unwrap();\\n            } else {\\n                greater_or_equal_tail.next = Some(node);\\n                greater_or_equal_tail = greater_or_equal_tail.next.as_mut().unwrap();\\n            }\\n        }\\n\\n        greater_or_equal_tail.next = None;\\n        less_tail.next = greater_or_equal_dummy.next;\\n        less_dummy.next\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Rust"
                ],
                "code": "```\\n1 -> 4 -> 3 -> 2 -> 5 -> 2\\n```\n```\\n   d1: [0]->nullptr\\n   d2: [0]->nullptr\\n   ```\n```\\n     d1: [0]->[1]->nullptr\\n     d2: [0]->nullptr\\n     ```\n```\\n     d1: [0]->[1]->nullptr\\n     d2: [0]->[4]->nullptr\\n     ```\n```\\n     d1: [0]->[1]->nullptr\\n     d2: [0]->[4]->[3]->nullptr\\n     ```\n```\\n     d1: [0]->[1]->[2]->nullptr\\n     d2: [0]->[4]->[3]->nullptr\\n     ```\n```\\n     d1: [0]->[1]->[2]->nullptr\\n     d2: [0]->[4]->[3]->[5]->nullptr\\n     ```\n```\\n     d1: [0]->[1]->[2]->[2]->nullptr\\n     d2: [0]->[4]->[3]->[5]->nullptr\\n     ```\n```\\n   d1: [0]->[1]->[2]->[2]->nullptr\\n   d2: [0]->[4]->[3]->[5]->nullptr\\n   ```\n```\\n   d1: [0]->[1]->[2]->[2]->[4]->[3]->[5]->nullptr\\n   d2: [0]->[4]->[3]->[5]->nullptr\\n   ```\n```\\n   1 -> 2 -> 2 -> 4 -> 3 -> 5\\n   ```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *d1 = new ListNode(0), *d2 = new ListNode(0), *n1, *n2;\\n        n1 = d1;\\n        n2=d2;\\n        while(head!=NULL){\\n            if(head->val < x){\\n                n1->next=head;\\n                n1=n1->next;\\n            } else{\\n                n2->next=head;\\n                n2=n2->next;\\n            }\\n            head=head->next;\\n        }\\n\\n        n2->next=NULL;\\n        n1->next=d2->next;\\n        return d1->next;\\n\\n    }\\n};\\n\\n```\n```\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\nimpl Solution {\\n    pub fn partition(head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\\n        let mut less_dummy =ListNode::new(0);\\n        let mut greater_or_equal_dummy = ListNode::new(0);\\n        let mut less_tail = &mut less_dummy;\\n        let mut greater_or_equal_tail = &mut greater_or_equal_dummy;\\n        let mut current = head;\\n\\n\\n        while let Some(mut node) = current.take() {\\n            current = node.next.take();\\n            if node.val < x {\\n                less_tail.next = Some(node);\\n                less_tail = less_tail.next.as_mut().unwrap();\\n            } else {\\n                greater_or_equal_tail.next = Some(node);\\n                greater_or_equal_tail = greater_or_equal_tail.next.as_mut().unwrap();\\n            }\\n        }\\n\\n        greater_or_equal_tail.next = None;\\n        less_tail.next = greater_or_equal_dummy.next;\\n        less_dummy.next\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911210,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* partition(ListNode* head, int x) {\\n        \\n        ListNode* small = new ListNode(-1);\\n        ListNode* large = new ListNode(-1);\\n        ListNode* small_head = small;\\n        ListNode* large_head = large;\\n        \\n        while (head){\\n            if (head->val < x){\\n                small->next = head;\\n                small = small -> next;\\n                head = head -> next;\\n                small->next = NULL;\\n            }\\n            else{\\n                large->next = head;\\n                large = large -> next;\\n                head = head -> next;\\n                large -> next = NULL;\\n            }\\n        }\\n        small -> next = large_head -> next;\\n\\n        return small_head -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* partition(ListNode* head, int x) {\\n        \\n        ListNode* small = new ListNode(-1);\\n        ListNode* large = new ListNode(-1);\\n        ListNode* small_head = small;\\n        ListNode* large_head = large;\\n        \\n        while (head){\\n            if (head->val < x){\\n                small->next = head;\\n                small = small -> next;\\n                head = head -> next;\\n                small->next = NULL;\\n            }\\n            else{\\n                large->next = head;\\n                large = large -> next;\\n                head = head -> next;\\n                large -> next = NULL;\\n            }\\n        }\\n        small -> next = large_head -> next;\\n\\n        return small_head -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953901,
                "title": "c-97-runtime-explained-using-queue-and-two-pointers",
                "content": "# Easy and Optimised Approach\\n\\n    Runtime - 97%\\uD83D\\uDD25 \\n\\n# Approach\\n1. Firstly we will point lar the first node whose value >= x.\\n2. Now we will store the node whose value < x in queue.\\n3. Then we will take out all the nodes stored in queue.\\n4. Then we will connect the last node in queue to the lar.\\n5. If there are no nodes in queue then we will return head.\\n\\n#  If you like the solution and understand it then Please Upvote.\\u2B06\\uFE0F\\u2764\\uFE0F \\n\\t* PEACE OUT LUV\\u270C\\uFE0F*\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if(head == NULL || head ->next == NULL){\\n            return head;\\n        }\\n        queue<ListNode*>q;\\n        ListNode* lar = head;\\n        while(lar != NULL){\\n            if(lar ->val >= x){\\n                break;\\n            }\\n            lar = lar ->next;\\n        }\\n        ListNode* temp = head;\\n        ListNode* prev = head;\\n        ListNode* back = NULL;\\n        while(temp != NULL){\\n            temp = temp ->next;\\n            if(prev ->val >=x){\\n                back = prev;\\n            }\\n            if(prev ->val <x){\\n                prev ->next = NULL;\\n                if(back != NULL){\\n                    back ->next = temp;\\n                }\\n                q.push(prev);\\n            }\\n            prev = temp;\\n        }\\n        ListNode* temp1 = NULL;\\n        if(q.empty()==false){\\n            ListNode* l = q.front();\\n            temp1 = l;\\n            q.pop();\\n            while(!q.empty()){\\n                l ->next = q.front();\\n                q.pop();\\n                l = l ->next;\\n            }\\n            if(l != NULL){\\n                l ->next = lar;\\n            }\\n            return temp1;\\n        }\\n        return head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if(head == NULL || head ->next == NULL){\\n            return head;\\n        }\\n        queue<ListNode*>q;\\n        ListNode* lar = head;\\n        while(lar != NULL){\\n            if(lar ->val >= x){\\n                break;\\n            }\\n            lar = lar ->next;\\n        }\\n        ListNode* temp = head;\\n        ListNode* prev = head;\\n        ListNode* back = NULL;\\n        while(temp != NULL){\\n            temp = temp ->next;\\n            if(prev ->val >=x){\\n                back = prev;\\n            }\\n            if(prev ->val <x){\\n                prev ->next = NULL;\\n                if(back != NULL){\\n                    back ->next = temp;\\n                }\\n                q.push(prev);\\n            }\\n            prev = temp;\\n        }\\n        ListNode* temp1 = NULL;\\n        if(q.empty()==false){\\n            ListNode* l = q.front();\\n            temp1 = l;\\n            q.pop();\\n            while(!q.empty()){\\n                l ->next = q.front();\\n                q.pop();\\n                l = l ->next;\\n            }\\n            if(l != NULL){\\n                l ->next = lar;\\n            }\\n            return temp1;\\n        }\\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319240,
                "title": "easy-small-python-solution",
                "content": "Easy small solution\\n\\n```python\\nclass Solution:\\n  def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n    small_head = small = ListNode(-1)\\n    large_head = large = ListNode(-1)\\n\\n    while head:\\n      if head.val < x:\\n        small.next = head\\n        small = small.next\\n      else:\\n        large.next = head \\n        large = large.next\\n      head = head.next\\n    \\n    large.next = None\\n    small.next = large_head.next\\n    return small_head.next\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n  def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n    small_head = small = ListNode(-1)\\n    large_head = large = ListNode(-1)\\n\\n    while head:\\n      if head.val < x:\\n        small.next = head\\n        small = small.next\\n      else:\\n        large.next = head \\n        large = large.next\\n      head = head.next\\n    \\n    large.next = None\\n    small.next = large_head.next\\n    return small_head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319061,
                "title": "2-ms-faster-than-69-53-of-java-online-submissions-for-partition-list",
                "content": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head==null)return head;\\n        Queue<Integer> q_l=new LinkedList<>();\\n        Queue<Integer> q_s=new LinkedList<>();\\n        ListNode cur=head;\\n        while(cur!=null){\\n            if(cur.val<x){\\n                q_s.add(cur.val);\\n            }else{\\n                q_l.add(cur.val);\\n            }\\n            cur=cur.next;\\n        }\\n        ListNode head2=new ListNode(Integer.MIN_VALUE);\\n        ListNode cur2=head2;\\n        while(!q_s.isEmpty()){\\n            ListNode nn=new ListNode(q_s.remove());\\n            cur2.next=nn;\\n            cur2=cur2.next;\\n        }\\n        while(!q_l.isEmpty()){\\n            ListNode nn=new ListNode(q_l.remove());\\n            cur2.next=nn;\\n            cur2=cur2.next;\\n        }\\n        return head2.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head==null)return head;\\n        Queue<Integer> q_l=new LinkedList<>();\\n        Queue<Integer> q_s=new LinkedList<>();\\n        ListNode cur=head;\\n        while(cur!=null){\\n            if(cur.val<x){\\n                q_s.add(cur.val);\\n            }else{\\n                q_l.add(cur.val);\\n            }\\n            cur=cur.next;\\n        }\\n        ListNode head2=new ListNode(Integer.MIN_VALUE);\\n        ListNode cur2=head2;\\n        while(!q_s.isEmpty()){\\n            ListNode nn=new ListNode(q_s.remove());\\n            cur2.next=nn;\\n            cur2=cur2.next;\\n        }\\n        while(!q_l.isEmpty()){\\n            ListNode nn=new ListNode(q_l.remove());\\n            cur2.next=nn;\\n            cur2=cur2.next;\\n        }\\n        return head2.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2318553,
                "title": "c-code-using-dummy-nodes",
                "content": "```\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* dm1 = new ListNode(0);\\n        ListNode* dm2 = new ListNode(0);\\n        ListNode* leftCurr = dm1;\\n        ListNode* rightCurr = dm2;\\n        \\n        while(head != NULL){\\n            if(head -> val < x){\\n                leftCurr->next = head;\\n                leftCurr = head;\\n            }\\n            else {\\n                rightCurr->next=head;\\n                rightCurr = head;\\n            }\\n            head=head->next;\\n        }\\n        \\n        leftCurr->next = dm2->next;\\n        rightCurr->next = NULL;\\n        return dm1->next;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* dm1 = new ListNode(0);\\n        ListNode* dm2 = new ListNode(0);\\n        ListNode* leftCurr = dm1;\\n        ListNode* rightCurr = dm2;\\n        \\n        while(head != NULL){\\n            if(head -> val < x){\\n                leftCurr->next = head;\\n                leftCurr = head;\\n            }\\n            else {\\n                rightCurr->next=head;\\n                rightCurr = head;\\n            }\\n            head=head->next;\\n        }\\n        \\n        leftCurr->next = dm2->next;\\n        rightCurr->next = NULL;\\n        return dm1->next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2316102,
                "title": "c-brute-force-easy-and-readable-code",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        vector<int> Helper;\\n        ListNode* temp=head;\\n        while(temp!=NULL)\\n        {\\n            (Helper.push_back(temp->val));\\n            \\n            temp=temp->next;\\n        }\\n        ListNode* temp1=head;\\n        int nose=0;\\n        for(int i=0;i<Helper.size();i++)\\n        {\\n            \\n            if(Helper[i]<x)\\n            {\\n                temp1->val=Helper[i];\\n                temp1=temp1->next;\\n                nose++;\\n            }\\n         \\n            \\n        }\\n       \\n        for(int i=0;i<Helper.size();i++)\\n        {\\n            if(Helper[i]>=x)\\n            {\\n                cout<<temp1->val;\\n                temp1->val=Helper[i];\\n                temp1=temp1->next;\\n            }\\n\\n            \\n        }\\n        return head;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        vector<int> Helper;\\n        ListNode* temp=head;\\n        while(temp!=NULL)\\n        {\\n            (Helper.push_back(temp->val));\\n            \\n            temp=temp->next;\\n        }\\n        ListNode* temp1=head;\\n        int nose=0;\\n        for(int i=0;i<Helper.size();i++)\\n        {\\n            \\n            if(Helper[i]<x)\\n            {\\n                temp1->val=Helper[i];\\n                temp1=temp1->next;\\n                nose++;\\n            }\\n         \\n            \\n        }\\n       \\n        for(int i=0;i<Helper.size();i++)\\n        {\\n            if(Helper[i]>=x)\\n            {\\n                cout<<temp1->val;\\n                temp1->val=Helper[i];\\n                temp1=temp1->next;\\n            }\\n\\n            \\n        }\\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2312370,
                "title": "partition-list-time-o-n-space-o-1-solution",
                "content": "**Intuition is straightforward.**\\n* We must divide the list so that all nodes with values less than X are on the left side.\\n* As a result, we will create two distinct partitions. One with all nodes with values less than X in the same order and the other nodes in a different list.\\n* Finally, we will connect the smaller list to the larger partition list and return the smaller partition\\'s head.\\n```\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n\\n\\t\\t#Creating DummyNode for Node smaller and (equal or larger) than x. \\n        smallerList=ListNode(0)\\n        largerList=ListNode(0)\\n\\n\\t\\t#Saving pointer of Smaller and larger partition\\n        smallerHead=smallerList\\n        largerHead=largerList\\n        \\n        # Iterate through all Node\\n        while head:\\n            if head.val<x:\\n                #If val of current Node is Smaller than X Link that Node to smaller partition\\n                smallerList.next=head\\n                smallerList=smallerList.next\\n                \\n            else:\\n                # else val of current Node is equal or larger than X Link that Node to larger partition\\n                largerList.next=head\\n                largerList=largerList.next\\n        \\n            # Move head ptr to next Node\\n            head=head.next\\n\\n\\t\\t# Link smaller Partition Last Node to Larger Partition Head Node\\n        smallerList.next=largerHead.next\\n\\t\\t#Larger partition Last Node to None\\n        largerList.next=None\\n\\n        #Return Smaller partition starting Node\\n        return smallerHead.next   \\n```\\n**Vote if you Love the solution**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n\\n\\t\\t#Creating DummyNode for Node smaller and (equal or larger) than x. \\n        smallerList=ListNode(0)\\n        largerList=ListNode(0)\\n\\n\\t\\t#Saving pointer of Smaller and larger partition\\n        smallerHead=smallerList\\n        largerHead=largerList\\n        \\n        # Iterate through all Node\\n        while head:\\n            if head.val<x:\\n                #If val of current Node is Smaller than X Link that Node to smaller partition\\n                smallerList.next=head\\n                smallerList=smallerList.next\\n                \\n            else:\\n                # else val of current Node is equal or larger than X Link that Node to larger partition\\n                largerList.next=head\\n                largerList=largerList.next\\n        \\n            # Move head ptr to next Node\\n            head=head.next\\n\\n\\t\\t# Link smaller Partition Last Node to Larger Partition Head Node\\n        smallerList.next=largerHead.next\\n\\t\\t#Larger partition Last Node to None\\n        largerList.next=None\\n\\n        #Return Smaller partition starting Node\\n        return smallerHead.next   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072641,
                "title": "c-easy-2-list-solution",
                "content": "```\\nclass Solution {\\npublic:\\nListNode* partition(ListNode* head, int x) {\\n\\tListNode* l1 = new ListNode(0);\\n\\tListNode* l2 = new ListNode(0);\\n\\tListNode* ptr1 = l1;\\n\\tListNode* ptr2 = l2;\\n\\n\\t// make 2 lists\\n\\twhile (head) {\\n\\t\\tif (head->val < x) {\\n\\t\\t\\tptr1->next = head;\\n\\t\\t\\tptr1 = ptr1->next;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tptr2->next = head;\\n\\t\\t\\tptr2 = ptr2->next;\\n\\t\\t}\\n\\t\\thead = head->next;\\n\\t}\\n\\t//connect 2 lists\\n\\tptr1->next = l2->next;\\n\\tptr2->next = NULL;\\n\\treturn l1->next;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nListNode* partition(ListNode* head, int x) {\\n\\tListNode* l1 = new ListNode(0);\\n\\tListNode* l2 = new ListNode(0);\\n\\tListNode* ptr1 = l1;\\n\\tListNode* ptr2 = l2;\\n\\n\\t// make 2 lists\\n\\twhile (head) {\\n\\t\\tif (head->val < x) {\\n\\t\\t\\tptr1->next = head;\\n\\t\\t\\tptr1 = ptr1->next;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tptr2->next = head;\\n\\t\\t\\tptr2 = ptr2->next;\\n\\t\\t}\\n\\t\\thead = head->next;\\n\\t}\\n\\t//connect 2 lists\\n\\tptr1->next = l2->next;\\n\\tptr2->next = NULL;\\n\\treturn l1->next;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112598,
                "title": "java-simple-and-easy-to-understand-solution-0-ms-faster-than-100-00-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n\\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode dummyNodeLess = new ListNode();\\n        ListNode currL = dummyNodeLess;\\n        \\n        ListNode dummyNodeGreater = new ListNode();\\n        ListNode currG = dummyNodeGreater;\\n        \\n        \\n        ListNode curr = head;\\n        \\n        //separete less and greater node,\\n        while(curr != null){\\n            \\n            ListNode node = curr;\\n            if(node.val < x){\\n                currL.next = node;\\n                currL = currL.next;\\n            } else {\\n                currG.next = node;\\n                currG = currG.next;\\n            }\\n            \\n            curr = node.next;\\n            node.next = null;\\n        }\\n        \\n        //just append, greater list in last of less node list\\n        currL.next = dummyNodeGreater.next;\\n        \\n        return dummyNodeLess.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode dummyNodeLess = new ListNode();\\n        ListNode currL = dummyNodeLess;\\n        \\n        ListNode dummyNodeGreater = new ListNode();\\n        ListNode currG = dummyNodeGreater;\\n        \\n        \\n        ListNode curr = head;\\n        \\n        //separete less and greater node,\\n        while(curr != null){\\n            \\n            ListNode node = curr;\\n            if(node.val < x){\\n                currL.next = node;\\n                currL = currL.next;\\n            } else {\\n                currG.next = node;\\n                currG = currG.next;\\n            }\\n            \\n            curr = node.next;\\n            node.next = null;\\n        }\\n        \\n        //just append, greater list in last of less node list\\n        currL.next = dummyNodeGreater.next;\\n        \\n        return dummyNodeLess.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29242,
                "title": "11-line-one-pass-easy-to-understand-python-solution",
                "content": "```\\nclass Solution(object):\\n    def partition(self, head, x):\\n        \"\"\"\\n        :type head: ListNode\\n        :type x: int\\n        :rtype: ListNode\\n        \"\"\"\\n        left, right = ListNode(None), ListNode(None)\\n        left_cur, right_cur = left, right\\n        while head:\\n            if head.val < x:\\n                left_cur.next, head = head, head.next\\n                left_cur, left_cur.next = left_cur.next, None\\n            else:\\n                right_cur.next, head = head, head.next\\n                right_cur, right_cur.next = right_cur.next, None\\n        left_cur.next = right.next\\n        return left.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def partition(self, head, x):\\n        \"\"\"\\n        :type head: ListNode\\n        :type x: int\\n        :rtype: ListNode\\n        \"\"\"\\n        left, right = ListNode(None), ListNode(None)\\n        left_cur, right_cur = left, right\\n        while head:\\n            if head.val < x:\\n                left_cur.next, head = head, head.next\\n                left_cur, left_cur.next = left_cur.next, None\\n            else:\\n                right_cur.next, head = head, head.next\\n                right_cur, right_cur.next = right_cur.next, None\\n        left_cur.next = right.next\\n        return left.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29314,
                "title": "java-solution-pick-out-larger-nodes-and-append-to-the-end",
                "content": "    public ListNode partition(ListNode head, int x) {\\n        if(head==null || head.next==null) return head;\\n        \\n        ListNode l1 = new ListNode(0); \\n        ListNode l2 = new ListNode(0);\\n        ListNode p1=l1, p2=l2;\\n        \\n        p1.next = head;\\n        while(p1.next!=null) {\\n            // keep moving larger node to list 2;\\n            \\n            if(p1.next.val>=x) {\\n                ListNode tmp = p1.next;\\n                p1.next = tmp.next;\\n                \\n                p2.next = tmp;\\n                p2 = p2.next;\\n            }\\n            else {\\n                p1 = p1.next;\\n            }\\n        }\\n        \\n        // conbine lists 1 and 2;\\n        p2.next = null;\\n        p1.next = l2.next;\\n        return l1.next;\\n    }",
                "solutionTags": [],
                "code": "    public ListNode partition(ListNode head, int x) {\\n        if(head==null || head.next==null) return head;\\n        \\n        ListNode l1 = new ListNode(0); \\n        ListNode l2 = new ListNode(0);\\n        ListNode p1=l1, p2=l2;\\n        \\n        p1.next = head;\\n        while(p1.next!=null) {\\n            // keep moving larger node to list 2;\\n            \\n            if(p1.next.val>=x) {\\n                ListNode tmp = p1.next;\\n                p1.next = tmp.next;\\n                \\n                p2.next = tmp;\\n                p2 = p2.next;\\n            }\\n            else {\\n                p1 = p1.next;\\n            }\\n        }\\n        \\n        // conbine lists 1 and 2;\\n        p2.next = null;\\n        p1.next = l2.next;\\n        return l1.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3913580,
                "title": "c-linkedlist-two-pointers-beats-100",
                "content": "# Intuition\\n# *The intuition behind this code is that it separates the nodes into two partitions while preserving their original order. Nodes with values less than x are placed in the small partition, and nodes with values greater than or equal to x are placed in the large partition. After processing all nodes, the two partitions are connected, resulting in the desired partitioned linked list*.\\n\\n# Approach\\n1. *Two new nodes, small and large, are created as dummy nodes to serve as the heads of the two partitions: one for nodes with values less than x (small) and another for nodes with values greater than or equal to x (large)*.\\n\\n2. *smallPtr and largePtr are pointers to track the last node in each partition. They are initially set to point to the dummy nodes small and large, respectively*.\\n\\n3. *A loop iterates through the input linked list pointed to by head*.\\n\\nInside the loop:\\n\\n1. *If the current node\\'s value is less than x, it is appended to the small partition by making smallPtr->next point to it, and then smallPtr is moved to the newly added node*.\\n\\n2. *If the current node\\'s value is greater than or equal to x, it is appended to the large partition using similar logic*.\\n\\n3. *After processing all nodes in the original linked list, the next pointers of smallPtr and largePtr are adjusted. The next pointer of smallPtr is connected to the first node of the large partition, effectively merging the two partitions*.\\n\\n\\n5. *Finally, the next pointer of largePtr is set to NULL to terminate the large partition*.\\n\\n6. *The function returns the next pointer of the small dummy node, which points to the beginning of the partitioned linked list*.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1**Bold**)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* small = new ListNode(0);\\n        ListNode* large = new ListNode(0);\\n\\n        ListNode* smallPtr = small;\\n        ListNode* largePtr = large;\\n\\n        while(head != NULL){\\n            if(head->val < x){\\n                smallPtr->next = head;\\n                smallPtr = smallPtr->next;\\n            }\\n            else{\\n                largePtr->next = head;\\n                largePtr = largePtr->next;\\n            }\\n            head = head->next;\\n        }\\n        smallPtr->next = large->next;\\n        largePtr->next = NULL;\\n\\n        return small->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* small = new ListNode(0);\\n        ListNode* large = new ListNode(0);\\n\\n        ListNode* smallPtr = small;\\n        ListNode* largePtr = large;\\n\\n        while(head != NULL){\\n            if(head->val < x){\\n                smallPtr->next = head;\\n                smallPtr = smallPtr->next;\\n            }\\n            else{\\n                largePtr->next = head;\\n                largePtr = largePtr->next;\\n            }\\n            head = head->next;\\n        }\\n        smallPtr->next = large->next;\\n        largePtr->next = NULL;\\n\\n        return small->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911985,
                "title": "simple-beginner-friendly-c-solution-with-intuition-and-explanation",
                "content": "# Intuition\\nIn the problem, we have to partition a singly linked list into two segments: one with elements less than a given value x and the other with elements greater than or equal to x. We accomplish this by iterating through the original list and using two dummy nodes (Prev and Next) to construct the partitioned segments. As each node is examined, we assign it to the appropriate segment based on its value compared to x. After the traversal, the two segments are linked together by updating pointers, resulting in a new linked list that fulfills the partitioning condition.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nFollow the following steps:\\n- Create pointers prev_curr and next_curr to track the current positions in the two dummy nodes.\\n\\n- Loop through the original linked list using the head pointer:\\n\\n- >If the current node\\'s value is greater than or equal to x, add it to the Next partition.\\n- >Otherwise, add it to the Prev partition.\\n- After the loop, set next_curr->next to NULL to terminate the Next partition.\\n\\n- Finally, set prev_curr->next to Next.next to link the Prev partition with the Next partition.\\n\\n- Return Prev.next, which is the head of the partitioned linked list.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nUPVOTE. Glad to help.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode Prev(0),Next(0);\\n        ListNode* prev_curr=&Prev;\\n        ListNode* next_curr=&Next;\\n        while(head){\\n            if(head->val>=x){\\n                next_curr->next=head;\\n                next_curr=head;\\n            } else {\\n                prev_curr->next=head;\\n                prev_curr=head;\\n            }\\n            head=head->next;\\n        }\\n        next_curr->next=NULL;\\n        prev_curr->next=Next.next;\\n        return Prev.next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode Prev(0),Next(0);\\n        ListNode* prev_curr=&Prev;\\n        ListNode* next_curr=&Next;\\n        while(head){\\n            if(head->val>=x){\\n                next_curr->next=head;\\n                next_curr=head;\\n            } else {\\n                prev_curr->next=head;\\n                prev_curr=head;\\n            }\\n            head=head->next;\\n        }\\n        next_curr->next=NULL;\\n        prev_curr->next=Next.next;\\n        return Prev.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911888,
                "title": "my-java-easy-0-ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode first = new ListNode(0);\\n        ListNode sec = new ListNode(0);\\n\\n        ListNode dS = first;\\n        ListNode dL = sec;\\n\\n        while(head != null){\\n            if(head.val < x){\\n                dS.next = new ListNode(head.val);\\n                dS = dS.next;\\n            }else{\\n                dL.next = new ListNode(head.val);\\n                dL = dL.next;\\n            }\\n            head = head.next;\\n        }\\n        dS.next = sec.next;\\n        return first.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode first = new ListNode(0);\\n        ListNode sec = new ListNode(0);\\n\\n        ListNode dS = first;\\n        ListNode dL = sec;\\n\\n        while(head != null){\\n            if(head.val < x){\\n                dS.next = new ListNode(head.val);\\n                dS = dS.next;\\n            }else{\\n                dL.next = new ListNode(head.val);\\n                dL = dL.next;\\n            }\\n            head = head.next;\\n        }\\n        dS.next = sec.next;\\n        return first.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911555,
                "title": "two-approaches-java-python-c",
                "content": "# Approach 1 : \\n> ### *Maintain two queues smallerQueue to store the smaller value nodes and and greaterQueue to store greater or equal value nodes. You can store either the whole Node or just the value in the node. After filling these queues you can manipulate the original linkedlist using these queues. Look at the code for better understanding.*\\n\\n# Code\\n```java []\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head == null || head.next == null)\\n            return head;\\n        Queue<Integer> smaller = new LinkedList<>();\\n        Queue<Integer> greater = new LinkedList<>();\\n        ListNode temp = head;\\n        while(temp!=null)\\n        {\\n            if(temp.val < x)\\n                smaller.add(temp.val);\\n            else\\n                greater.add(temp.val);\\n            temp = temp.next;\\n        }\\n        temp = head;\\n        while(temp!=null)\\n        {\\n            if(smaller.size() > 0)\\n                temp.val = smaller.poll();\\n            else\\n                temp.val = greater.poll();\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n        smaller = []\\n        greater = []\\n        temp = head\\n        while temp:\\n            if temp.val < x:\\n                smaller.append(temp.val)\\n            else:\\n                greater.append(temp.val)\\n            temp = temp.next\\n        \\n        temp = head\\n        while temp:\\n            if smaller:\\n                temp.val = smaller.pop(0)\\n            else:\\n                temp.val = greater.pop(0)\\n            temp = temp.next\\n        \\n        return head\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if (!head || !head->next)\\n            return head;\\n\\n        queue<int> smaller;\\n        queue<int> greater;\\n        ListNode* temp = head;\\n        while (temp) {\\n            if (temp->val < x)\\n                smaller.push(temp->val);\\n            else\\n                greater.push(temp->val);\\n            temp = temp->next;\\n        }\\n\\n        temp = head;\\n        while (temp) {\\n            if (!smaller.empty()) {\\n                temp->val = smaller.front();\\n                smaller.pop();\\n            } else {\\n                temp->val = greater.front();\\n                greater.pop();\\n            }\\n            temp = temp->next;\\n        }\\n\\n        return head;\\n    }\\n};\\n```\\n---\\n> ## *But this is not an optimal approach because space-complexity is O(N) and time complexity is O(N). Can we further optimize the solution to use O(1) space ??* \\n---\\n# Approach 2 : \\n> ### *Instead of maintaing two queues we will maintain two pointers smaller and greater pointers and when we traverse the array if the node value is smaller than given value then we link it to smaller pointer otherwise we link it to the greater pointer. After traversing the whole linkedlist you can attach the smaller List nd greater List and return it. Look at the code for better understanding.*\\n\\n# Code\\n```java []\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head == null || head.next == null)\\n            return head;\\n        ListNode smaller = new ListNode(-1),greater = new ListNode(-1),curr1 = smaller,curr2 = greater,temp = head;\\n        while(temp!=null)\\n        {\\n            if(temp.val < x)\\n            {\\n                curr1.next = temp;\\n                curr1 = curr1.next;\\n            }\\n            else\\n            {\\n                curr2.next = temp;\\n                curr2 = curr2.next;\\n            }\\n            temp = temp.next;\\n        }\\n        curr2.next = null;\\n        curr1.next = greater.next;\\n        return smaller.next;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n        smaller = ListNode(-1)\\n        greater = ListNode(-1)\\n        curr1 = smaller\\n        curr2 = greater\\n        temp = head\\n        \\n        while temp:\\n            if temp.val < x:\\n                curr1.next = temp\\n                curr1 = curr1.next\\n            else:\\n                curr2.next = temp\\n                curr2 = curr2.next\\n            temp = temp.next\\n        \\n        curr2.next = None\\n        curr1.next = greater.next\\n        return smaller.next\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if (!head || !head->next)\\n            return head;\\n        \\n        ListNode* smaller = new ListNode(-1);\\n        ListNode* greater = new ListNode(-1);\\n        ListNode* curr1 = smaller;\\n        ListNode* curr2 = greater;\\n        ListNode* temp = head;\\n        \\n        while (temp) {\\n            if (temp->val < x) {\\n                curr1->next = temp;\\n                curr1 = curr1->next;\\n            } else {\\n                curr2->next = temp;\\n                curr2 = curr2->next;\\n            }\\n            temp = temp->next;\\n        }\\n        \\n        curr2->next = nullptr;\\n        curr1->next = greater->next;\\n        \\n        ListNode* result = smaller->next;\\n        delete smaller;\\n        delete greater;\\n        \\n        return result;\\n    }\\n};\\n```\\n---\\n> ## *Please don\\'t forget to upvote if you\\'ve liked my explanation. Do post your suggestions through the comments.* \\uD83D\\uDCAC",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```java []\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head == null || head.next == null)\\n            return head;\\n        Queue<Integer> smaller = new LinkedList<>();\\n        Queue<Integer> greater = new LinkedList<>();\\n        ListNode temp = head;\\n        while(temp!=null)\\n        {\\n            if(temp.val < x)\\n                smaller.add(temp.val);\\n            else\\n                greater.add(temp.val);\\n            temp = temp.next;\\n        }\\n        temp = head;\\n        while(temp!=null)\\n        {\\n            if(smaller.size() > 0)\\n                temp.val = smaller.poll();\\n            else\\n                temp.val = greater.poll();\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n        smaller = []\\n        greater = []\\n        temp = head\\n        while temp:\\n            if temp.val < x:\\n                smaller.append(temp.val)\\n            else:\\n                greater.append(temp.val)\\n            temp = temp.next\\n        \\n        temp = head\\n        while temp:\\n            if smaller:\\n                temp.val = smaller.pop(0)\\n            else:\\n                temp.val = greater.pop(0)\\n            temp = temp.next\\n        \\n        return head\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if (!head || !head->next)\\n            return head;\\n\\n        queue<int> smaller;\\n        queue<int> greater;\\n        ListNode* temp = head;\\n        while (temp) {\\n            if (temp->val < x)\\n                smaller.push(temp->val);\\n            else\\n                greater.push(temp->val);\\n            temp = temp->next;\\n        }\\n\\n        temp = head;\\n        while (temp) {\\n            if (!smaller.empty()) {\\n                temp->val = smaller.front();\\n                smaller.pop();\\n            } else {\\n                temp->val = greater.front();\\n                greater.pop();\\n            }\\n            temp = temp->next;\\n        }\\n\\n        return head;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head == null || head.next == null)\\n            return head;\\n        ListNode smaller = new ListNode(-1),greater = new ListNode(-1),curr1 = smaller,curr2 = greater,temp = head;\\n        while(temp!=null)\\n        {\\n            if(temp.val < x)\\n            {\\n                curr1.next = temp;\\n                curr1 = curr1.next;\\n            }\\n            else\\n            {\\n                curr2.next = temp;\\n                curr2 = curr2.next;\\n            }\\n            temp = temp.next;\\n        }\\n        curr2.next = null;\\n        curr1.next = greater.next;\\n        return smaller.next;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n        smaller = ListNode(-1)\\n        greater = ListNode(-1)\\n        curr1 = smaller\\n        curr2 = greater\\n        temp = head\\n        \\n        while temp:\\n            if temp.val < x:\\n                curr1.next = temp\\n                curr1 = curr1.next\\n            else:\\n                curr2.next = temp\\n                curr2 = curr2.next\\n            temp = temp.next\\n        \\n        curr2.next = None\\n        curr1.next = greater.next\\n        return smaller.next\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if (!head || !head->next)\\n            return head;\\n        \\n        ListNode* smaller = new ListNode(-1);\\n        ListNode* greater = new ListNode(-1);\\n        ListNode* curr1 = smaller;\\n        ListNode* curr2 = greater;\\n        ListNode* temp = head;\\n        \\n        while (temp) {\\n            if (temp->val < x) {\\n                curr1->next = temp;\\n                curr1 = curr1->next;\\n            } else {\\n                curr2->next = temp;\\n                curr2 = curr2->next;\\n            }\\n            temp = temp->next;\\n        }\\n        \\n        curr2->next = nullptr;\\n        curr1->next = greater->next;\\n        \\n        ListNode* result = smaller->next;\\n        delete smaller;\\n        delete greater;\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911070,
                "title": "video-solution-with-drawings-c-java-in-depth",
                "content": "# Intuition, approach and complexity discussed in video solution in detail\\nhttps://youtu.be/0ROu_XHnop4\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if(head == NULL)return head;\\n        ListNode *dummyHeadSml = new ListNode();\\n        ListNode *curSmlNode = dummyHeadSml;\\n\\n        ListNode *dummyHeadEg = new ListNode();\\n        ListNode *curEgNode = dummyHeadEg;\\n\\n        for(ListNode *curr = head; curr != NULL;){\\n            ListNode *next = curr->next;\\n            curr->next = NULL;\\n            if(curr->val < x){\\n                curSmlNode->next = curr;\\n                curSmlNode = curr;\\n            }else{\\n                curEgNode->next = curr;\\n                curEgNode = curr;\\n            }\\n            curr = next;\\n        }\\n        \\n        curSmlNode->next = dummyHeadEg->next;\\n        return dummyHeadSml->next;\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head == null)return head;\\n        ListNode dummyHeadSml = new ListNode();\\n        ListNode curSmlNode = dummyHeadSml;\\n\\n        ListNode dummyHeadEg = new ListNode();\\n        ListNode curEgNode = dummyHeadEg;\\n\\n        for(ListNode curr = head; curr != null;){\\n            ListNode next = curr.next;\\n            curr.next = null;\\n            if(curr.val < x){\\n                curSmlNode.next = curr;\\n                curSmlNode = curr;\\n            }else{\\n                curEgNode.next = curr;\\n                curEgNode = curr;\\n            }\\n            curr = next;\\n        }\\n        \\n        curSmlNode.next = dummyHeadEg.next;\\n        return dummyHeadSml.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if(head == NULL)return head;\\n        ListNode *dummyHeadSml = new ListNode();\\n        ListNode *curSmlNode = dummyHeadSml;\\n\\n        ListNode *dummyHeadEg = new ListNode();\\n        ListNode *curEgNode = dummyHeadEg;\\n\\n        for(ListNode *curr = head; curr != NULL;){\\n            ListNode *next = curr->next;\\n            curr->next = NULL;\\n            if(curr->val < x){\\n                curSmlNode->next = curr;\\n                curSmlNode = curr;\\n            }else{\\n                curEgNode->next = curr;\\n                curEgNode = curr;\\n            }\\n            curr = next;\\n        }\\n        \\n        curSmlNode->next = dummyHeadEg->next;\\n        return dummyHeadSml->next;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head == null)return head;\\n        ListNode dummyHeadSml = new ListNode();\\n        ListNode curSmlNode = dummyHeadSml;\\n\\n        ListNode dummyHeadEg = new ListNode();\\n        ListNode curEgNode = dummyHeadEg;\\n\\n        for(ListNode curr = head; curr != null;){\\n            ListNode next = curr.next;\\n            curr.next = null;\\n            if(curr.val < x){\\n                curSmlNode.next = curr;\\n                curSmlNode = curr;\\n            }else{\\n                curEgNode.next = curr;\\n                curEgNode = curr;\\n            }\\n            curr = next;\\n        }\\n        \\n        curSmlNode.next = dummyHeadEg.next;\\n        return dummyHeadSml.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910908,
                "title": "c-solution-with-explanation-optimal-solution-o-n-time-and-o-1-space-complexity-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo Pointer Approach\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Take two pointers, one is pointing to the list in which the vlaue is less then x and the other one pointing to the list in which the value is greater than equal to the x.\\n2. if the second list is non empty then update the link of last node to NULL\\n3. if the first list is empty then simply return the second list otherwise connect the first and second list and return the combined list.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if (head == NULL) return head;\\n        ListNode *first = NULL, *l1 = NULL, *l2 = NULL, *second = NULL;\\n        while(head != NULL){\\n            if (head->val < x){\\n                if (first == NULL){\\n                    first = head;\\n                    l1 = first;\\n                }\\n                else {\\n                    l1->next = head;\\n                    l1 = l1->next;\\n                }\\n            }\\n            else{\\n                if (second == NULL){\\n                    second = head;\\n                    l2 = second;\\n                }\\n                else{\\n                    l2->next = head;\\n                    l2 = l2->next;\\n                }\\n            }\\n            head = head->next;\\n        }\\n        // if second list is not empty then update the last node link to NULL\\n        if (l2 != NULL)\\n        l2->next = NULL;\\n        // if the first list is not empty then connect the first and second list otherwise return the second list \\n        if (l1 != NULL)\\n        l1->next = second;\\n        else return second;\\n        return first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if (head == NULL) return head;\\n        ListNode *first = NULL, *l1 = NULL, *l2 = NULL, *second = NULL;\\n        while(head != NULL){\\n            if (head->val < x){\\n                if (first == NULL){\\n                    first = head;\\n                    l1 = first;\\n                }\\n                else {\\n                    l1->next = head;\\n                    l1 = l1->next;\\n                }\\n            }\\n            else{\\n                if (second == NULL){\\n                    second = head;\\n                    l2 = second;\\n                }\\n                else{\\n                    l2->next = head;\\n                    l2 = l2->next;\\n                }\\n            }\\n            head = head->next;\\n        }\\n        // if second list is not empty then update the last node link to NULL\\n        if (l2 != NULL)\\n        l2->next = NULL;\\n        // if the first list is not empty then connect the first and second list otherwise return the second list \\n        if (l1 != NULL)\\n        l1->next = second;\\n        else return second;\\n        return first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862218,
                "title": "best-c-solution-time-o-n-space-o-1-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(ListNode* &first, ListNode* &second, ListNode* &curr, int x){\\n        while(curr != NULL){\\n            if(curr->val < x){\\n                first->next = curr;\\n                first = curr;\\n            }\\n            else{\\n                second->next = curr;\\n                second = curr;\\n            }\\n            curr = curr->next;\\n        }\\n    }\\n\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *smallHead = head, *largeHead = head;\\n        \\n        // Step 1 - Find the first small node and first large node\\n        // Also calculate the position at which they occur\\n        int sCount = 1, lCount = 1;\\n        while(smallHead != NULL && smallHead->val >= x){\\n            smallHead = smallHead->next;\\n            sCount++;\\n        }\\n        while(largeHead != NULL && largeHead->val < x){\\n            largeHead = largeHead->next;\\n            lCount++;\\n        }\\n        if(smallHead == NULL || largeHead == NULL)   \\n            return head;\\n        \\n        // Step 2 - Traverse the LL such that the two heads are adjacent\\n        // based on which head occurs first\\n        ListNode *first = smallHead, *second = largeHead, *curr;\\n        if(sCount < lCount){\\n            while(first->next != second)\\n                first = first->next;\\n            curr = second->next;\\n        }\\n        else{\\n            while(second->next != first)\\n                second = second->next;\\n            curr = first->next;\\n        }\\n        \\n        // Step 3 - Use solve() to form two separate LL and then merge them\\n        solve(first, second, curr, x);\\n        first->next = largeHead;\\n        second->next = NULL;\\n        return smallHead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(ListNode* &first, ListNode* &second, ListNode* &curr, int x){\\n        while(curr != NULL){\\n            if(curr->val < x){\\n                first->next = curr;\\n                first = curr;\\n            }\\n            else{\\n                second->next = curr;\\n                second = curr;\\n            }\\n            curr = curr->next;\\n        }\\n    }\\n\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *smallHead = head, *largeHead = head;\\n        \\n        // Step 1 - Find the first small node and first large node\\n        // Also calculate the position at which they occur\\n        int sCount = 1, lCount = 1;\\n        while(smallHead != NULL && smallHead->val >= x){\\n            smallHead = smallHead->next;\\n            sCount++;\\n        }\\n        while(largeHead != NULL && largeHead->val < x){\\n            largeHead = largeHead->next;\\n            lCount++;\\n        }\\n        if(smallHead == NULL || largeHead == NULL)   \\n            return head;\\n        \\n        // Step 2 - Traverse the LL such that the two heads are adjacent\\n        // based on which head occurs first\\n        ListNode *first = smallHead, *second = largeHead, *curr;\\n        if(sCount < lCount){\\n            while(first->next != second)\\n                first = first->next;\\n            curr = second->next;\\n        }\\n        else{\\n            while(second->next != first)\\n                second = second->next;\\n            curr = first->next;\\n        }\\n        \\n        // Step 3 - Use solve() to form two separate LL and then merge them\\n        solve(first, second, curr, x);\\n        first->next = largeHead;\\n        second->next = NULL;\\n        return smallHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685462,
                "title": "c-solution-easy-to-understand",
                "content": "# Approach\\n1. create two lists - one for nodes with value less than x and one for nodes with value greater than x.\\n2. Join the left list to right and right ends with NULL.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* left = new ListNode();\\n        ListNode* right = new ListNode();\\n        ListNode* head1 = left;\\n        ListNode* head2 = right;\\n        ListNode* curr = head;\\n        while(curr!=NULL){\\n            if(curr->val>=x){\\n                right->next = curr;\\n                right = right->next;\\n                curr = curr->next;\\n            }\\n            else{\\n                left->next = curr; \\n                left= left->next;\\n                curr = curr->next;\\n            }\\n        }\\n        left->next = head2->next;\\n        right->next = NULL;\\n        return head1->next;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* left = new ListNode();\\n        ListNode* right = new ListNode();\\n        ListNode* head1 = left;\\n        ListNode* head2 = right;\\n        ListNode* curr = head;\\n        while(curr!=NULL){\\n            if(curr->val>=x){\\n                right->next = curr;\\n                right = right->next;\\n                curr = curr->next;\\n            }\\n            else{\\n                left->next = curr; \\n                left= left->next;\\n                curr = curr->next;\\n            }\\n        }\\n        left->next = head2->next;\\n        right->next = NULL;\\n        return head1->next;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622187,
                "title": "easy-c-solution-with-pseudocode",
                "content": "We can solve this problem by the following steps-\\n1) Make a temp variable which points towards head in the begging ; \\n2) Make Two new node which will start as the dummy head for the beginning of the two new linked list \\n3) The First LinkedList consists of all the node which are smaller than the the value x\\n4) Meanwhile the other one consists of all which are larger or equal to x ; \\n5) We check the value at temp and add that desired node to one of the newly made list and then perform temp = temp->next while temp!=NULL ; \\n6) Now if temp reaches null that means we have iterated throught the linkedlist completely so \\n7) We connected the Smaller element LL with the Biggest Element LinkedList \\n\\nHere Is the code of the above pseudocode ; \\nUpvote if you found this helpful \\n\\n    class Solution {\\n     public:\\n     ListNode* partition(ListNode* head, int x) {\\n        ListNode* temp = head  ; \\n        \\n        ListNode* left = new ListNode(0);\\n        ListNode* right = new ListNode(0) ; \\n        ListNode* dummy1 = left  ;\\n        ListNode* dummy2 = right ; \\n        while(temp!=NULL){\\n            if(temp->val < x){\\n                dummy1->next = temp ; \\n                dummy1 = dummy1->next ; \\n             }\\n            else {\\n                dummy2->next = temp ; \\n                dummy2 = dummy2->next ; \\n                \\n            }\\n            temp = temp->next ; \\n        }\\n        dummy1->next = right->next ; \\n        dummy2->next = NULL;\\n        \\n        return left->next ; \\n    }\\n    };\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\n     public:\\n     ListNode* partition(ListNode* head, int x) {\\n        ListNode* temp = head  ; \\n        \\n        ListNode* left = new ListNode(0);\\n        ListNode* right = new ListNode(0) ; \\n        ListNode* dummy1 = left  ;\\n        ListNode* dummy2 = right ; \\n        while(temp!=NULL){\\n            if(temp->val < x){\\n                dummy1->next = temp ; \\n                dummy1 = dummy1->next ; \\n             }",
                "codeTag": "Java"
            },
            {
                "id": 3529295,
                "title": "java-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode list1=new ListNode(0);\\n        ListNode list2=new ListNode(0);\\n\\n        ListNode l1=list1;\\n        ListNode l2=list2;\\n\\n        while(head!=null){\\n            if(head.val<x){\\n                l1.next=head;\\n                l1=l1.next;\\n            }\\n            else{\\n                l2.next=head;\\n                l2=l2.next;\\n            }\\n            head=head.next;\\n\\n        }\\n        l1.next=list2.next;\\n        l2.next=null;\\n        return list1.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode list1=new ListNode(0);\\n        ListNode list2=new ListNode(0);\\n\\n        ListNode l1=list1;\\n        ListNode l2=list2;\\n\\n        while(head!=null){\\n            if(head.val<x){\\n                l1.next=head;\\n                l1=l1.next;\\n            }\\n            else{\\n                l2.next=head;\\n                l2=l2.next;\\n            }\\n            head=head.next;\\n\\n        }\\n        l1.next=list2.next;\\n        l2.next=null;\\n        return list1.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185253,
                "title": "partition-list-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution uses two dummy nodes to keep track of the partitioned linked list. It traverses the original linked list and adds each node to either the \"before\" partition (nodes with values less than x) or the \"after\" partition (nodes with values greater than or equal to x). After the partitioning, the two partitioned linked lists are combined and the head of the combined linked list is returned as the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        # Create two dummy nodes for partitioned list\\n        before_head = ListNode(0)\\n        before = before_head\\n        after_head = ListNode(0)\\n        after = after_head\\n        \\n        # Traverse the original list and add each node to either \\n        # the before partition or after partition\\n        while head:\\n            if head.val < x:\\n                before.next = head\\n                before = before.next\\n            else:\\n                after.next = head\\n                after = after.next\\n            head = head.next\\n        \\n        # End the after partition list\\n        after.next = None\\n        # Combine the before and after partitions\\n        before.next = after_head.next\\n        return before_head.next\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        # Create two dummy nodes for partitioned list\\n        before_head = ListNode(0)\\n        before = before_head\\n        after_head = ListNode(0)\\n        after = after_head\\n        \\n        # Traverse the original list and add each node to either \\n        # the before partition or after partition\\n        while head:\\n            if head.val < x:\\n                before.next = head\\n                before = before.next\\n            else:\\n                after.next = head\\n                after = after.next\\n            head = head.next\\n        \\n        # End the after partition list\\n        after.next = None\\n        # Combine the before and after partitions\\n        before.next = after_head.next\\n        return before_head.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011516,
                "title": "linear-time-solution-for-partitioning-a-linked-list-two-stacks",
                "content": "# Intuition\\nI solved this problem by using two lists to partition the elements of the linked list. My approach involved using two stacks in JavaScript to store the elements of the linked list.\\n\\n# Approach\\n1. Initialized two empty stacks, called left and right.\\n2. Traversed the linked list, adding elements less than x to the left stack and the rest of the elements to the right stack.\\n3. Created an empty ListNode to serve as the head of the new linked list that I would build.\\n4. Used a while loop to iterate through the right stack, adding each element to the new linked list in reverse order.\\n5. Used another while loop to iterate through the left stack, adding each element to the new linked list in reverse order.\\n6. Returned the head of the new linked list as the result.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is ***O(n)***, because it takes a single pass through the linked list to partition the elements into the left and right stacks.\\n\\n- Space complexity:\\nThe space complexity of this solution is also ***O(n)***, because it uses two stacks to store the elements of the linked list. The maximum size of the stacks is equal to the number of elements in the linked list, so the space complexity is O(n).\\n\\nOverall, this solution has efficient time and space complexity, as it is linear in the number of elements in the linked list.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} x\\n * @return {ListNode}\\n */\\nvar partition = function(head, x) {\\n    let left = [];\\n    let right = [];\\n    while(head){\\n        if(head.val < x){\\n            left.push(head.val);\\n        }else{\\n            right.push(head.val)\\n        }\\n        head = head.next;\\n    }\\n    \\n    head = null;\\n\\n    while(right.length !== 0){\\n        let node = new ListNode(right.pop());\\n        node.next = head;\\n        head = node;\\n    }\\n    while(left.length !== 0){\\n        let node = new ListNode(left.pop());\\n        node.next = head;\\n        head = node;\\n    }\\n    return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} x\\n * @return {ListNode}\\n */\\nvar partition = function(head, x) {\\n    let left = [];\\n    let right = [];\\n    while(head){\\n        if(head.val < x){\\n            left.push(head.val);\\n        }else{\\n            right.push(head.val)\\n        }\\n        head = head.next;\\n    }\\n    \\n    head = null;\\n\\n    while(right.length !== 0){\\n        let node = new ListNode(right.pop());\\n        node.next = head;\\n        head = node;\\n    }\\n    while(left.length !== 0){\\n        let node = new ListNode(left.pop());\\n        node.next = head;\\n        head = node;\\n    }\\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2971103,
                "title": "c-two-solutions",
                "content": "# Complexity:\\n- Time complexity: O(n)<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 1: Without Space\\n```\\nclass Solution\\n{\\npublic:\\n    ListNode *partition(ListNode *head, int x)\\n    {\\n        ListNode *list1 = new ListNode(0);\\n        ListNode *list2 = new ListNode(0);\\n\\n        ListNode *l1 = list1;\\n        ListNode *l2 = list2;\\n\\n        while (head)\\n        {\\n            if (head->val < x)\\n            {\\n                l1->next = head;\\n                l1 = l1->next;\\n            }\\n\\n            else\\n            {\\n                l2->next = head;\\n                l2 = l2->next;\\n            }\\n\\n            head = head->next;\\n        }\\n\\n        l1->next = list2->next;\\n        l2->next = NULL;\\n\\n        return list1->next;\\n    }\\n};\\n```\\n# Complexity:\\n- Time complexity: O(2n)<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 2: With Space\\n```\\nclass Solution\\n{\\npublic:\\n    ListNode *partition(ListNode *head, int x)\\n    {\\n        vector<int> left;\\n        vector<int> right;\\n        ListNode *temp = head;\\n\\n        while (temp)\\n        {\\n            if (temp->val < x)\\n                left.push_back(temp->val);\\n\\n            else\\n                right.push_back(temp->val);\\n\\n            temp = temp->next;\\n        }\\n\\n        ListNode *node = new ListNode();\\n        ListNode *t = node;\\n\\n        for (auto i : left)\\n        {\\n            node->next = new ListNode(i);\\n            node = node->next;\\n        }\\n\\n        for (auto i : right)\\n        {\\n            node->next = new ListNode(i);\\n            node = node->next;\\n        }\\n\\n        return t->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    ListNode *partition(ListNode *head, int x)\\n    {\\n        ListNode *list1 = new ListNode(0);\\n        ListNode *list2 = new ListNode(0);\\n\\n        ListNode *l1 = list1;\\n        ListNode *l2 = list2;\\n\\n        while (head)\\n        {\\n            if (head->val < x)\\n            {\\n                l1->next = head;\\n                l1 = l1->next;\\n            }\\n\\n            else\\n            {\\n                l2->next = head;\\n                l2 = l2->next;\\n            }\\n\\n            head = head->next;\\n        }\\n\\n        l1->next = list2->next;\\n        l2->next = NULL;\\n\\n        return list1->next;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    ListNode *partition(ListNode *head, int x)\\n    {\\n        vector<int> left;\\n        vector<int> right;\\n        ListNode *temp = head;\\n\\n        while (temp)\\n        {\\n            if (temp->val < x)\\n                left.push_back(temp->val);\\n\\n            else\\n                right.push_back(temp->val);\\n\\n            temp = temp->next;\\n        }\\n\\n        ListNode *node = new ListNode();\\n        ListNode *t = node;\\n\\n        for (auto i : left)\\n        {\\n            node->next = new ListNode(i);\\n            node = node->next;\\n        }\\n\\n        for (auto i : right)\\n        {\\n            node->next = new ListNode(i);\\n            node = node->next;\\n        }\\n\\n        return t->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320001,
                "title": "java-c-solution-explained-tc-o-n-sc-o-1-100",
                "content": "```\\nLeft will have values smaller then x & Right will have value greater or equal to x.\\n```\\n\\n\\n```\\n     /* \\n     2 seprate linkedLists there by preserving the order in which they appear in the original list \\n     after creating 2 different partition of 2 LL \\n     we have to combine 2 sub LL to create resultant LL\\n     */\\n```\\n```\\nSo, to do that. Create 2 sublists.\\n\\nsmaller dummy linked list\\nhigher dummy linked list\\nsmaller LL will have values smaller then x & higher LL will have value greater or equal to x.\\n```\\n\\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode smaller =new ListNode(Integer.MIN_VALUE);\\n        ListNode higher  =new ListNode(Integer.MIN_VALUE);\\n        \\n        ListNode smallHead=smaller ;\\n        ListNode highHead = higher;\\n        \\n        while(head!=null){\\n            if(head.val<x){\\n\\t\\t\\t\\n                //1 partition which are lesser than x value \\n                //smaller list\\n                smallHead.next=head;\\n                smallHead=smallHead.next;\\n                \\n            }\\n            else{\\n\\t\\t\\t\\n                //2 partition >= x\\n                //higher list\\n                highHead.next=head;\\n                highHead=highHead.next;\\n            }\\n            head=head.next;\\n        }\\n```\\n\\t\\t\\n```\\nwe have seperated the list\\'s as per the questions, our final job is to merge them into one list.\\n\\nSo, to do that , tecnically smaller list end i.e. 2 is pointing to null and higher list \\nend i.e.\\n\\n5 pointing to 2. But we want 2 to point to the beginning of higher list not null.\\nthats why we already created a infine[never ending] loop. \\n\\n```\\n\\n```\\n\\t\\t\\n        highHead.next=null;   // higher Lists\\'s last node now pointing to null\\n        smallHead.next=higher.next;     //small\\'s last node pointing to first node of higher node\\n        return smaller.next;\\n    }\\n\\n}\\n```\\nCPP Solution\\nhttps://leetcode.com/problems/partition-list/discuss/2320042/Java-C%2B%2B-Solution-Explained-TC-O(N)-SC-O(1)-100\\n",
                "solutionTags": [],
                "code": "```\\nLeft will have values smaller then x & Right will have value greater or equal to x.\\n```\n```\\n     /* \\n     2 seprate linkedLists there by preserving the order in which they appear in the original list \\n     after creating 2 different partition of 2 LL \\n     we have to combine 2 sub LL to create resultant LL\\n     */\\n```\n```\\nSo, to do that. Create 2 sublists.\\n\\nsmaller dummy linked list\\nhigher dummy linked list\\nsmaller LL will have values smaller then x & higher LL will have value greater or equal to x.\\n```\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode smaller =new ListNode(Integer.MIN_VALUE);\\n        ListNode higher  =new ListNode(Integer.MIN_VALUE);\\n        \\n        ListNode smallHead=smaller ;\\n        ListNode highHead = higher;\\n        \\n        while(head!=null){\\n            if(head.val<x){\\n\\t\\t\\t\\n                //1 partition which are lesser than x value \\n                //smaller list\\n                smallHead.next=head;\\n                smallHead=smallHead.next;\\n                \\n            }\\n            else{\\n\\t\\t\\t\\n                //2 partition >= x\\n                //higher list\\n                highHead.next=head;\\n                highHead=highHead.next;\\n            }\\n            head=head.next;\\n        }\\n```\n```\\nwe have seperated the list\\'s as per the questions, our final job is to merge them into one list.\\n\\nSo, to do that , tecnically smaller list end i.e. 2 is pointing to null and higher list \\nend i.e.\\n\\n5 pointing to 2. But we want 2 to point to the beginning of higher list not null.\\nthats why we already created a infine[never ending] loop. \\n\\n```\n```\\n\\t\\t\\n        highHead.next=null;   // higher Lists\\'s last node now pointing to null\\n        smallHead.next=higher.next;     //small\\'s last node pointing to first node of higher node\\n        return smaller.next;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2318859,
                "title": "c-easy-to-understand-commented-fully-explained-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n    //we will make two list list1 contain element lesser than x and list two contain element bigger than x\\n        //and after that put list 2 in list1->next\\n        ListNode*list1=new ListNode(0);  //initially  given 0 to list 1\\n        ListNode*list2=new ListNode(0);  //initially  given 0 to list 2\\n        \\n        ListNode*l1=list1; //l1=0 initially\\n        ListNode*l2=list2;  //l2=0  initially\\n        \\n        while(head){  //while head!=null ITERATE OVER THE ll\\n            if(head->val<x){   //IF val of head <x \\n                l1->next=head;  //put head in l1->next   0->1->2->2->NULL\\n                l1=l1->next; //move next of l1\\n            }\\n            else{  //if head->val not less than x \\n                l2->next=head;  //put in l2->next      0->4->3->5->NULL     \\n                l2=l2->next;   //move l2->next\\n            }\\n            \\n            head=head->next; //iterating over the ll\\n        }\\n        l1->next=list2->next;  //first element of list2 is 0 so we have to put 4 3 5 so putting next of list2\\n        l2->next=NULL; \\n        return list1->next;  // return  1->2->2->4 >2->5->NULL  so we call next of list1\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n    //we will make two list list1 contain element lesser than x and list two contain element bigger than x\\n        //and after that put list 2 in list1->next\\n        ListNode*list1=new ListNode(0);  //initially  given 0 to list 1\\n        ListNode*list2=new ListNode(0);  //initially  given 0 to list 2\\n        \\n        ListNode*l1=list1; //l1=0 initially\\n        ListNode*l2=list2;  //l2=0  initially\\n        \\n        while(head){  //while head!=null ITERATE OVER THE ll\\n            if(head->val<x){   //IF val of head <x \\n                l1->next=head;  //put head in l1->next   0->1->2->2->NULL\\n                l1=l1->next; //move next of l1\\n            }\\n            else{  //if head->val not less than x \\n                l2->next=head;  //put in l2->next      0->4->3->5->NULL     \\n                l2=l2->next;   //move l2->next\\n            }\\n            \\n            head=head->next; //iterating over the ll\\n        }\\n        l1->next=list2->next;  //first element of list2 is 0 so we have to put 4 3 5 so putting next of list2\\n        l2->next=NULL; \\n        return list1->next;  // return  1->2->2->4 >2->5->NULL  so we call next of list1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316652,
                "title": "easy-to-code",
                "content": "```\\nclass Solution {\\n\\tpublic ListNode partition(ListNode head, int x) {\\n\\t\\tListNode temp1 = new ListNode(0);\\n\\t\\tListNode temp2 = new ListNode(0);\\n\\t\\ttemp1.next = head;\\n\\n\\t\\tListNode first = temp1;\\n\\t\\tListNode second = temp2;\\n\\t\\tListNode curr = head;\\n\\n\\t\\twhile (curr != null) {\\n\\t\\t\\tListNode temp = curr.next;\\n\\t\\t\\tif (curr.val < x) {\\n\\t\\t\\t\\tfirst.next = curr;\\n\\t\\t\\t\\tfirst = curr;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsecond.next = curr;\\n\\t\\t\\t\\tsecond = curr;\\n\\t\\t\\t\\tsecond.next = null;\\n\\t\\t\\t}\\n\\t\\t\\tcurr = temp;\\n\\t\\t}\\n\\t\\tfirst.next = temp2.next;\\n\\t\\treturn temp1.next;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic ListNode partition(ListNode head, int x) {\\n\\t\\tListNode temp1 = new ListNode(0);\\n\\t\\tListNode temp2 = new ListNode(0);\\n\\t\\ttemp1.next = head;\\n\\n\\t\\tListNode first = temp1;\\n\\t\\tListNode second = temp2;\\n\\t\\tListNode curr = head;\\n\\n\\t\\twhile (curr != null) {\\n\\t\\t\\tListNode temp = curr.next;\\n\\t\\t\\tif (curr.val < x) {\\n\\t\\t\\t\\tfirst.next = curr;\\n\\t\\t\\t\\tfirst = curr;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsecond.next = curr;\\n\\t\\t\\t\\tsecond = curr;\\n\\t\\t\\t\\tsecond.next = null;\\n\\t\\t\\t}\\n\\t\\t\\tcurr = temp;\\n\\t\\t}\\n\\t\\tfirst.next = temp2.next;\\n\\t\\treturn temp1.next;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316244,
                "title": "python-linear-time-three-steps-with-explanation",
                "content": "PYTHON | Linear Time | Three Steps | With Explanation\\n\\n* Step-1: Before and after are the two pointers used to create two list, before_head and after_head are used to save the heads of the two lists. All of these are initialized with the dummy nodes created.\\n* Step-2: Iterate through the Linked List.\\nIf the original list node is lesser than the given x, assign it to the before list, else if the original list node is greater or equal to the given x, assign it to the after list.\\n* Step-3: Once all the nodes are correctly assigned to the two lists, combine them to form a single list which would be returned.\\n\\nCode:               \\n```\\ndef partition( head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n\\n        # Step-1\\n        before = before_head = ListNode(0)\\n        after = after_head = ListNode(0)\\n\\n\\t    # Step-2\\n        while head:\\n            if head.val < x:\\n                before.next = head\\n                before = before.next\\n            else:\\n                after.next = head\\n                after = after.next\\n            head = head.next\\n\\t\\t\\n\\t\\t# Step-3\\n        # Last node of \"after\" list would also be ending node of the reformed list\\n        after.next = None\\n        # combine the nodes to form a single list which would be returned.\\n        before.next = after_head.next\\n\\t\\t\\n\\t\\t# Lastly,\\n\\t\\t# return the final head of the Linked List\\n        return before_head.next\\n```\\n\\n*Complexity Analysis\\nTime Complexity: O(N); N is the number of nodes in the original linked list and we iterate the original list.\\nSpace Complexity: O(1); we have not utilized any extra space, the point to note is that we are reforming the original list, by moving the original nodes, we have not used any extra space as such.\\n\\np.s:- you can also have a look at the alternative solution, which might be a little easier to understand for Beginners [here](https://leetcode.com/problems/partition-list/discuss/2316178/PYTHON-or-For-Beginners-or-With-Explanation-or-Linear-Time).\\n\\n*The only difference is that in the above solution, we are playing with the nodes directly, and reforming the original list, whereas in the alternate solution, we are forming a new LinkedList.\\nTherefore, the Time-Complexity remains the same for both the solutions, but the Space-Complexity is Constant here, whereas it is Linear in the alternative one.*",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef partition( head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n\\n        # Step-1\\n        before = before_head = ListNode(0)\\n        after = after_head = ListNode(0)\\n\\n\\t    # Step-2\\n        while head:\\n            if head.val < x:\\n                before.next = head\\n                before = before.next\\n            else:\\n                after.next = head\\n                after = after.next\\n            head = head.next\\n\\t\\t\\n\\t\\t# Step-3\\n        # Last node of \"after\" list would also be ending node of the reformed list\\n        after.next = None\\n        # combine the nodes to form a single list which would be returned.\\n        before.next = after_head.next\\n\\t\\t\\n\\t\\t# Lastly,\\n\\t\\t# return the final head of the Linked List\\n        return before_head.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2315450,
                "title": "python3-easy-clean-code-explained",
                "content": "```\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        \\n        temp=[]                             # to store the values in temp\\n        curr = head\\n        while curr:\\n            temp.append(curr.val)\\n            curr = curr.next\\n        \\n        # check and replace the values which are < x and mark used values as -1e9\\n        curr = head\\n        for i in range(len(temp)):\\n            if temp[i] < x:\\n                curr.val = temp[i]\\n                curr = curr.next\\n                temp[i] = -1e9\\n        \\n        \\n        # remaining unused values can be replaced in list\\n        for e in temp:\\n            if e != -1e9:\\n                curr.val = e\\n                curr = curr.next\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        \\n        temp=[]                             # to store the values in temp\\n        curr = head\\n        while curr:\\n            temp.append(curr.val)\\n            curr = curr.next\\n        \\n        # check and replace the values which are < x and mark used values as -1e9\\n        curr = head\\n        for i in range(len(temp)):\\n            if temp[i] < x:\\n                curr.val = temp[i]\\n                curr = curr.next\\n                temp[i] = -1e9\\n        \\n        \\n        # remaining unused values can be replaced in list\\n        for e in temp:\\n            if e != -1e9:\\n                curr.val = e\\n                curr = curr.next\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315339,
                "title": "python3-14-lines-w-explanation-t-m-99-56",
                "content": "Here\\'s a linked list with k for the sake of example:\\n```\\n                     -1-> 4-> 3-> 2-> 5 -> 2, k = 3\\n```               \\n\\nHere\\'s the plan:\\n1. We initialize two linked lists, one for each node for which `node.val` is less than `k` and another for each node for which `node.val` is not less than `k`.\\n    \\n1. We traverse the given linked list, and append each node to its appropriate  `more` or `less` list. In our example,\\n```\\n                    less: 1-> 2-> 2       more: 3->5\\n```   \\n3. We attach more to less. In our example,\\n```\\n                        less = 1-> 2-> 2-> 3-> 5\\n```\\n4. We return joined list \\n```\\nclass Solution:    \\n    def partition(self, head: ListNode, k: int) -> ListNode:\\n    \\n        if not head: return None           \\n        less, more = ListNode(), ListNode()         # <-- 1\\n        lNode, mNode = less, more\\n        \\n        while head :                                # <-- 2                 \\n            if head.val < k :\\n                lNode.next = head\\n                lNode = lNode.next\\n            else:\\n                mNode.next = head\\n                mNode = mNode.next\\n            head=head.next\\n\\n        lNode.next, mNode.next = more.next, None    # <-- 3\\n\\n        return less.next                            # <-- 4\\n```\\n[https://leetcode.com/problems/partition-list/submissions/1021575874/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1), in which *N* ~ the numer of nodes in the list`.\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n                     -1-> 4-> 3-> 2-> 5 -> 2, k = 3\\n```\n```\\n                    less: 1-> 2-> 2       more: 3->5\\n```\n```\\n                        less = 1-> 2-> 2-> 3-> 5\\n```\n```\\nclass Solution:    \\n    def partition(self, head: ListNode, k: int) -> ListNode:\\n    \\n        if not head: return None           \\n        less, more = ListNode(), ListNode()         # <-- 1\\n        lNode, mNode = less, more\\n        \\n        while head :                                # <-- 2                 \\n            if head.val < k :\\n                lNode.next = head\\n                lNode = lNode.next\\n            else:\\n                mNode.next = head\\n                mNode = mNode.next\\n            head=head.next\\n\\n        lNode.next, mNode.next = more.next, None    # <-- 3\\n\\n        return less.next                            # <-- 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315214,
                "title": "o-1-space-c-easy-solution",
                "content": "class Solution {\\npublic:\\n\\nListNode* partition(ListNode* head, int x) {\\n\\n    if(head == NULL) return head;\\n    \\n    ListNode* temp = head;\\n    ListNode* list1 = NULL;\\n    ListNode* list2 = NULL;\\n    ListNode* head1 = NULL;\\n    ListNode* head2 = NULL;\\n    \\n    while(temp != NULL){\\n        \\n        if(temp->val < x){\\n            \\n            if(head1 == NULL){\\n                head1 = temp;\\n                list1 = temp;\\n            }\\n            else{\\n                list1->next = temp;\\n                list1 = list1->next;\\n            }\\n            \\n        }\\n        else{\\n            \\n            \\n            if(head2 == NULL){\\n                head2 = temp;\\n                list2 = temp;\\n            }\\n            else{\\n                list2->next = temp;\\n                list2 = list2->next;\\n            }\\n            \\n        }\\n        \\n        \\n        temp = temp->next;\\n    }\\n    \\n    \\n    if(head1 == NULL) return head2;\\n    \\n    list1->next = NULL;\\n    \\n    if(list2 != NULL ) list2->next = NULL;\\n    \\n    list1->next = head2;\\n    \\n    return head1;\\n}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\nListNode* partition(ListNode* head, int x) {\\n\\n    if(head == NULL) return head;\\n    \\n    ListNode* temp = head;\\n    ListNode* list1 = NULL;\\n    ListNode* list2 = NULL;\\n    ListNode* head1 = NULL;\\n    ListNode* head2 = NULL;\\n    \\n    while(temp != NULL){\\n        \\n        if(temp->val < x){\\n            \\n            if(head1 == NULL){\\n                head1 = temp;\\n                list1 = temp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2315209,
                "title": "partition-list-basic-to-be-used-when-in-some-oa-coding-contest",
                "content": "Solution : Initially I had thought of using a vector of nodes,could have been solved that way too.But when someone is under time pressure, these solutions come handy.\\n   ```/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* curr=head;\\n        vector< int > v1;\\n        vector< int >  v2;\\n        while(curr!=NULL){\\n            if(curr->val>=x)\\n                v1.push_back(curr->val);\\n            else\\n                v2.push_back(curr->val);\\n            curr=curr->next;\\n        }\\n        curr=head;\\n        for(int i=0;i < v2.size();i++){\\n            curr->val=v2[i];\\n            curr=curr->next;\\n        }\\n        for(int i=0;i < v1.size();i++){\\n            curr->val=v1[i];\\n            curr=curr->next;\\n        }\\n        return head;\\n       \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* curr=head;\\n        vector< int > v1;\\n        vector< int >  v2;\\n        while(curr!=NULL){\\n            if(curr->val>=x)\\n                v1.push_back(curr->val);\\n            else\\n                v2.push_back(curr->val);\\n            curr=curr->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1947124,
                "title": "python3-simple-to-understand-o-1-space",
                "content": "```\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        h1=l1=ListNode(0)\\n        h2=l2=ListNode(0)\\n        while head:\\n            if head.val<x:\\n                l1.next=head\\n                l1=l1.next\\n            else:\\n                l2.next=head\\n                l2=l2.next\\n            head=head.next\\n        l2.next=None\\n        l1.next=h2.next\\n        return h1.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        h1=l1=ListNode(0)\\n        h2=l2=ListNode(0)\\n        while head:\\n            if head.val<x:\\n                l1.next=head\\n                l1=l1.next\\n            else:\\n                l2.next=head\\n                l2=l2.next\\n            head=head.next\\n        l2.next=None\\n        l1.next=h2.next\\n        return h1.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636573,
                "title": "c-o-n-time-and-o-1-space-solution-very-simple-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        //special cases for length = 0,1 and 2\\n        if(!head) return head;\\n        if(!head->next) return head;\\n        if(!head->next->next){\\n            if(head->val>=x and head->next->val<x){\\n                ListNode* temp=head->next;\\n                head->next->next=head;\\n                head->next=NULL;\\n                head = temp;\\n                return head;\\n            }\\n            else return head;\\n        }\\n        \\n        ListNode* p1=head;\\n        ListNode* p2=head->next;\\n        ListNode* tail=head;\\n        int n=1;\\n        while(tail->next){\\n            n++;\\n            tail=tail->next;\\n        }\\n        //cout<<tail->val<<\" \"<<n;\\n        \\n        \\n        for(int i=1; i<n; i++){\\n            if(head->val>=x){\\n                //1st node should be sent to last node\\n                p1=p2; p2=p2->next;\\n                tail->next=head;\\n                tail=tail->next;\\n                head->next=NULL;\\n                head=p1;\\n            }\\n            else if(p2->val>=x){\\n                //those values >= x go to the last of the list one by one to maintain their order\\n                tail->next=p2;\\n                p1->next=p2->next;\\n                p2->next=NULL;\\n                tail=tail->next;\\n                p2=p1->next;\\n            }\\n            else {\\n                p1=p1->next; p2=p2->next; //going to next node\\n            }\\n        }\\n        //we have to run 1 more iteration if all val >= x\\n        if(head->val>=x){\\n            ListNode* temp = head->next;\\n            tail->next=head;\\n            head->next=NULL;\\n            tail=tail->next; //unnecessary\\n            head=temp;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        //special cases for length = 0,1 and 2\\n        if(!head) return head;\\n        if(!head->next) return head;\\n        if(!head->next->next){\\n            if(head->val>=x and head->next->val<x){\\n                ListNode* temp=head->next;\\n                head->next->next=head;\\n                head->next=NULL;\\n                head = temp;\\n                return head;\\n            }\\n            else return head;\\n        }\\n        \\n        ListNode* p1=head;\\n        ListNode* p2=head->next;\\n        ListNode* tail=head;\\n        int n=1;\\n        while(tail->next){\\n            n++;\\n            tail=tail->next;\\n        }\\n        //cout<<tail->val<<\" \"<<n;\\n        \\n        \\n        for(int i=1; i<n; i++){\\n            if(head->val>=x){\\n                //1st node should be sent to last node\\n                p1=p2; p2=p2->next;\\n                tail->next=head;\\n                tail=tail->next;\\n                head->next=NULL;\\n                head=p1;\\n            }\\n            else if(p2->val>=x){\\n                //those values >= x go to the last of the list one by one to maintain their order\\n                tail->next=p2;\\n                p1->next=p2->next;\\n                p2->next=NULL;\\n                tail=tail->next;\\n                p2=p1->next;\\n            }\\n            else {\\n                p1=p1->next; p2=p2->next; //going to next node\\n            }\\n        }\\n        //we have to run 1 more iteration if all val >= x\\n        if(head->val>=x){\\n            ListNode* temp = head->next;\\n            tail->next=head;\\n            head->next=NULL;\\n            tail=tail->next; //unnecessary\\n            head=temp;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1473271,
                "title": "easy-to-understand-c-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* curr, int x) {\\n        ListNode *dummy1 = new ListNode(-1);\\n        ListNode *dummy2 = new ListNode(-1);;\\n        \\n        ListNode *h2 = dummy2, *h1 = dummy1;\\n        \\n        while(curr) {\\n            if(curr->val < x) {\\n                dummy1->next = curr;\\n                dummy1 = dummy1->next;\\n            }\\n            else {\\n                dummy2->next = curr;\\n                dummy2 = dummy2->next;\\n            }\\n            curr = curr->next;\\n        }\\n        \\n        \\n        dummy1->next = h2->next;\\n        dummy2->next = NULL;\\n        \\n        return h1->next;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* curr, int x) {\\n        ListNode *dummy1 = new ListNode(-1);\\n        ListNode *dummy2 = new ListNode(-1);;\\n        \\n        ListNode *h2 = dummy2, *h1 = dummy1;\\n        \\n        while(curr) {\\n            if(curr->val < x) {\\n                dummy1->next = curr;\\n                dummy1 = dummy1->next;\\n            }\\n            else {\\n                dummy2->next = curr;\\n                dummy2 = dummy2->next;\\n            }\\n            curr = curr->next;\\n        }\\n        \\n        \\n        dummy1->next = h2->next;\\n        dummy2->next = NULL;\\n        \\n        return h1->next;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299805,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* left = new ListNode(0);\\n         ListNode* right = new ListNode(0);\\n         ListNode* ltail = left;\\n         ListNode* rtail = right;\\nwhile(head != NULL){\\n           if(head->val < x ){\\n                 ltail->next = head;\\n                 ltail = ltail->next;\\n            }else{\\n              rtail->next = head;\\n              rtail = rtail->next;\\n            }\\n           head= head->next;\\n      }\\n           ltail->next= right->next;  \\n           rtail->next = NULL;\\nreturn left->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* left = new ListNode(0);\\n         ListNode* right = new ListNode(0);\\n         ListNode* ltail = left;\\n         ListNode* rtail = right;\\nwhile(head != NULL){\\n           if(head->val < x ){\\n                 ltail->next = head;\\n                 ltail = ltail->next;\\n            }else{\\n              rtail->next = head;\\n              rtail = rtail->next;\\n            }\\n           head= head->next;\\n      }\\n           ltail->next= right->next;  \\n           rtail->next = NULL;\\nreturn left->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243649,
                "title": "very-simple-and-understandable-java-soln",
                "content": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        ListNode small = new ListNode(-1);\\n        ListNode greater = new ListNode(-1);\\n        ListNode sp = small, gp =greater, cur = head;\\n        while(cur != null){\\n            if(cur.val < x){\\n                sp.next = cur;\\n                sp = sp.next;\\n            }\\n            else{\\n                gp.next = cur;\\n                gp = gp.next;\\n            }\\n            cur = cur.next;\\n        }\\n        sp.next = greater.next;\\n        gp.next = null;\\n        \\n        head = small.next;\\n        small = greater = null; //Not necessary to do this\\n        return head;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        ListNode small = new ListNode(-1);\\n        ListNode greater = new ListNode(-1);\\n        ListNode sp = small, gp =greater, cur = head;\\n        while(cur != null){\\n            if(cur.val < x){\\n                sp.next = cur;\\n                sp = sp.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1157838,
                "title": "partition-list-simple-solution-easy-to-understand-explained",
                "content": "The main idea is, Keep track of node that is greater than equal to `x`, whenever we find a node that has lesser value than `x`, we shift the value and and increment the pointer.\\nwe have two cases,\\n->` node->val >= x`: In this case, we have to do nothing. \\n-> `node->val < x` : In this case we need replace our value before the nodes that has greater value than x.Our pointer `cur` represents the node that has greater value than `x`. So, we initialize a duplicate pointer. and shift the value until `dup` reaches the temp. At last we update the `cur`.\\n\\n**Do upvote** if you like the code !!\\n```\\nListNode* partition(ListNode* head, int x) {\\n        if(head == NULL || head->next == NULL) return head;\\n        ListNode* temp = head, *cur = head;\\n        while(temp){\\n            if(temp->val < x){\\n                int value = temp->val;\\n                ListNode* dup = cur;\\n                while(dup){\\n                    int y = dup->val;\\n                    dup->val = value;\\n                    value = y;\\n                    if(dup == temp) break;\\n                    dup=dup->next;\\n                }\\n                cur = cur->next;\\n            }\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n```\\nAny other ways to solve ?? Comment down below !!",
                "solutionTags": [],
                "code": "```\\nListNode* partition(ListNode* head, int x) {\\n        if(head == NULL || head->next == NULL) return head;\\n        ListNode* temp = head, *cur = head;\\n        while(temp){\\n            if(temp->val < x){\\n                int value = temp->val;\\n                ListNode* dup = cur;\\n                while(dup){\\n                    int y = dup->val;\\n                    dup->val = value;\\n                    value = y;\\n                    if(dup == temp) break;\\n                    dup=dup->next;\\n                }\\n                cur = cur->next;\\n            }\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 826370,
                "title": "rust-safe-time-complexity-o-n-space-complexity-o-1-0ms-2mb",
                "content": "```\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\nimpl Solution {\\n    pub fn partition(mut head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\\n        if head.is_none() {\\n            return head;\\n        }\\n\\n        // before and after are the two pointers used to create the two list\\n        // before_head and after_head are used to save the heads of the two lists.\\n        // All of these are initialized with the dummy nodes created.\\n        let mut before_head = Box::new(ListNode {\\n            val: -1,\\n            next: None,\\n        });\\n        let mut after_head = Box::new(ListNode::new(-1));\\n\\n        let mut before = &mut before_head;\\n        let mut after = &mut after_head;\\n        while let Some(mut node) = head {\\n            // If the original list node is lesser than the given x,\\n            // assign it to the before list.\\n            if node.val < x {\\n                // move ahead in the original list\\n                head = node.next.take();\\n                before.next = Some(node);\\n                before = before.next.as_mut().unwrap();\\n            } else {\\n                // move ahead in the original list\\n                head = node.next.take();\\n                // If the original list node is greater or equal to the given x,\\n                // assign it to the after list.\\n                after.next = Some(node);\\n                after = after.next.as_mut().unwrap();\\n            }\\n        }\\n        after.next = None;\\n\\n        // Once all the nodes are correctly assigned to the two lists,\\n        // combine them to form a single list which would be returned.\\n        before.next = after_head.next;\\n        before_head.next\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\nimpl Solution {\\n    pub fn partition(mut head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\\n        if head.is_none() {\\n            return head;\\n        }\\n\\n        // before and after are the two pointers used to create the two list\\n        // before_head and after_head are used to save the heads of the two lists.\\n        // All of these are initialized with the dummy nodes created.\\n        let mut before_head = Box::new(ListNode {\\n            val: -1,\\n            next: None,\\n        });\\n        let mut after_head = Box::new(ListNode::new(-1));\\n\\n        let mut before = &mut before_head;\\n        let mut after = &mut after_head;\\n        while let Some(mut node) = head {\\n            // If the original list node is lesser than the given x,\\n            // assign it to the before list.\\n            if node.val < x {\\n                // move ahead in the original list\\n                head = node.next.take();\\n                before.next = Some(node);\\n                before = before.next.as_mut().unwrap();\\n            } else {\\n                // move ahead in the original list\\n                head = node.next.take();\\n                // If the original list node is greater or equal to the given x,\\n                // assign it to the after list.\\n                after.next = Some(node);\\n                after = after.next.as_mut().unwrap();\\n            }\\n        }\\n        after.next = None;\\n\\n        // Once all the nodes are correctly assigned to the two lists,\\n        // combine them to form a single list which would be returned.\\n        before.next = after_head.next;\\n        before_head.next\\n    }\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 719013,
                "title": "rust-100-fast-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn partition(head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\\n        if head.is_none() {\\n            return None;\\n        }\\n        let mut before_head = Some(Box::new(ListNode::new(0)));\\n        let mut after_head = Some(Box::new(ListNode::new(0)));\\n        let mut before = before_head.as_mut();\\n        let mut after = after_head.as_mut();\\n        let mut curr = head;\\n\\n        while let Some(node) = curr {\\n            if node.val < x {\\n                if let Some(b) = before {\\n                    b.next = Some(node.clone());\\n                    before = b.next.as_mut();\\n                }\\n            } else {\\n                if let Some(a) = after {\\n                    a.next = Some(node.clone());\\n                    after = a.next.as_mut();\\n                }\\n            }\\n            curr = node.next;\\n        }\\n        if let Some(a) = after {\\n            a.next = None;\\n        }\\n        if let Some(b) = before {\\n            b.next = after_head.unwrap().next;\\n        }\\n        before_head.unwrap().next\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn partition(head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\\n        if head.is_none() {\\n            return None;\\n        }\\n        let mut before_head = Some(Box::new(ListNode::new(0)));\\n        let mut after_head = Some(Box::new(ListNode::new(0)));\\n        let mut before = before_head.as_mut();\\n        let mut after = after_head.as_mut();\\n        let mut curr = head;\\n\\n        while let Some(node) = curr {\\n            if node.val < x {\\n                if let Some(b) = before {\\n                    b.next = Some(node.clone());\\n                    before = b.next.as_mut();\\n                }\\n            } else {\\n                if let Some(a) = after {\\n                    a.next = Some(node.clone());\\n                    after = a.next.as_mut();\\n                }\\n            }\\n            curr = node.next;\\n        }\\n        if let Some(a) = after {\\n            a.next = None;\\n        }\\n        if let Some(b) = before {\\n            b.next = after_head.unwrap().next;\\n        }\\n        before_head.unwrap().next\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 466152,
                "title": "java-o-n-time-o-1-space-w-explanation",
                "content": "The idea is to create two separate lists that we will link together at the end.\\n\\nWe will create the ListNodes lessNodes (for nodes with a val < x) and grEqNodes (for nodes with a val >= x). Note that lessNodes and grEqNodes are initialized with dummy nodes of value 0. Additionally, lessHead and grEqHead initially point to these dummy nodes.\\n\\nWe set curr equal to head as our starting point.\\n\\nWe iterate through the list in a while loop, using curr to move forward along our list until curr equals null. If curr.val is less than x, we make lessNodes.next point to curr and move lessNodes forward. Else, we make grEqNodes.next point to curr and move greaterEqNodes forward.\\n\\nNow, we eliminate the dummy nodes we initially used. We link the lessNodes list to the node after grEqHead, since the first node is a placeholder. We then set the end of the grEqNodes list to null, thus terminating the list.\\n\\nWe return the node after lessHead, since the first node is a placeholder.\\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode lessNodes = new ListNode(0);\\n        ListNode grEqNodes = new ListNode(0);\\n        \\n        ListNode lessHead = lessNodes;\\n        ListNode grEqHead = grEqNodes;\\n        \\n        ListNode curr = head;\\n        \\n        while(curr != null){\\n\\n            if(curr.val < x){\\n                lessNodes.next = curr;\\n                lessNodes = lessNodes.next;\\n            }\\n            else {\\n                grEqNodes.next = curr;\\n                grEqNodes = grEqNodes.next;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        lessNodes.next = grEqHead.next;\\n        grEqNodes.next = null;\\n        \\n        return lessHead.next;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode lessNodes = new ListNode(0);\\n        ListNode grEqNodes = new ListNode(0);\\n        \\n        ListNode lessHead = lessNodes;\\n        ListNode grEqHead = grEqNodes;\\n        \\n        ListNode curr = head;\\n        \\n        while(curr != null){\\n\\n            if(curr.val < x){\\n                lessNodes.next = curr;\\n                lessNodes = lessNodes.next;\\n            }\\n            else {\\n                grEqNodes.next = curr;\\n                grEqNodes = grEqNodes.next;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        lessNodes.next = grEqHead.next;\\n        grEqNodes.next = null;\\n        \\n        return lessHead.next;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287896,
                "title": "0ms-java-easy-to-understand-solution",
                "content": "Inline comments for explanation\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        \\n        ListNode sList = new ListNode(0); //Dummy head for smaller elements list\\n        ListNode gList = new ListNode(0);//Dummy head for >= element list\\n        ListNode sptr = sList; //pointer for current element in sList\\n        ListNode gptr = gList; // pointer for current element in gList\\n        \\n        while(head !=null){\\n            if(head.val<x){\\n                //add element to first sList\\n                sptr.next = head;\\n                head = head.next;\\n                sptr = sptr.next;\\n                sptr.next = null;\\n                \\n            }else{\\n                //add element to larger element list\\n                gptr.next = head;\\n                head = head.next;\\n                gptr = gptr.next;\\n                gptr.next = null;\\n            }\\n        }\\n        //Merge both list joining last element for sList to first element of gList\\n        sptr.next = gList.next;\\n        return sList.next; \\n                \\n    }\\n        \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        \\n        ListNode sList = new ListNode(0); //Dummy head for smaller elements list\\n        ListNode gList = new ListNode(0);//Dummy head for >= element list\\n        ListNode sptr = sList; //pointer for current element in sList\\n        ListNode gptr = gList; // pointer for current element in gList\\n        \\n        while(head !=null){\\n            if(head.val<x){\\n                //add element to first sList\\n                sptr.next = head;\\n                head = head.next;\\n                sptr = sptr.next;\\n                sptr.next = null;\\n                \\n            }else{\\n                //add element to larger element list\\n                gptr.next = head;\\n                head = head.next;\\n                gptr = gptr.next;\\n                gptr.next = null;\\n            }\\n        }\\n        //Merge both list joining last element for sList to first element of gList\\n        sptr.next = gList.next;\\n        return sList.next; \\n                \\n    }\\n        \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 155293,
                "title": "c-c-short-single-pass-iterative-solution-no-allocation-or-dummy-o-n-time-o-1-space",
                "content": "# TL;DR\\n**C++ solution**\\n```cpp\\n  ListNode* partition(ListNode* head, int x) {\\n    ListNode* larger = nullptr;\\n    ListNode** larger_next = &larger;\\n    ListNode** prev = &head;\\n    while (*prev) {\\n      if ((*prev)->val >= x) { // Node needs to be moved to greater list\\n        *larger_next = *prev;\\n        larger_next = &((*larger_next)->next);\\n        *prev = (*prev)->next;\\n      } else { // Node can be left in place\\n        prev = &((*prev)->next);\\n      }\\n    }\\n\\n    *larger_next = nullptr;\\n    *prev = larger; \\n    \\n    return head;\\n  }  \\n```\\n**C Solution**\\nBasically as the above c++ solution with a few syntax changes\\n```c\\nstruct ListNode* partition(struct ListNode* head, int x){\\n  struct ListNode* larger = NULL;\\n  struct ListNode** larger_next = &larger;\\n  struct ListNode** prev = &head;\\n  while (*prev) {\\n    if ((*prev)->val >= x) { /* Node needs to be moved to greater list */\\n      *larger_next = *prev;\\n      larger_next = &((*larger_next)->next);\\n      *prev = (*prev)->next;\\n    } else { /* Node can be left in place */\\n      prev = &((*prev)->next);\\n    }\\n  }\\n\\n  *larger_next = NULL;\\n  *prev = larger; \\n\\n  return head;\\n}\\n```\\n# Details\\nHold two pointers to pointers. One holds the previous node\\'s next pointer (or the _head_ pointer) and is advanced whenever the node is in the correct location. The other holds a list of those greater than or equal to _x_.\\n\\nProcess the list and if a node greater or equal to _x_ is encounted, move to the end of our _larger_ list. At the end, join the two lists back together and return the _head_. With a few more comments to help explain the pointer to pointer.\\n\\n```cpp\\n  ListNode* partition(ListNode* head, int x) {\\n    // Will hold the nodes greater than or equal to x\\t\\n    ListNode* larger = nullptr;\\n    ListNode** larger_next = &larger;\\n\\n    ListNode** prev = &head;\\n    while (*prev) {\\n      if ((*prev)->val >= x) {\\n        // Move the found node to the end of the list of larger nodes\\n        *larger_next = *prev;\\n        larger_next = &((*larger_next)->next);\\n        \\n        // Update the less than list to skip over the node we\\'ve moved\\n        *prev = (*prev)->next;\\n      } else {\\n        // Node is in the correct place, skip over it\\n        prev = &((*prev)->next);\\n      }\\n    }\\n    \\n    // Terminate the equal or larger than x list\\n    *larger_next = nullptr;\\n    \\n    // Attach those less than x to those greater than x\\n    *prev = larger; \\n    \\n    return head;\\n  }  \\n```\\n# Alternative\\nAn alternative approach that reduces the number of pointer updates could remove consecutive larger than nodes in a single update. Things like [2, 4, 5, 6, 7, 8, 1] with _x_ of 3 would move 4, 5, 6, 7, 8 in a single update.\\n```cpp\\n  ListNode* partition(ListNode* head, int x) {\\n    ListNode* larger = nullptr;\\n    ListNode** larger_next = &larger;\\n\\n    ListNode** prev = &head;\\n    while (*prev) {\\n      if ((*prev)->val >= x) {\\n        // Move the found node to the end of the list of larger nodes\\n        *larger_next = *prev;\\n        do {\\n          larger_next = &((*larger_next)->next);\\n        }\\n        while (*larger_next && (*larger_next)->val >= x);\\n        \\n        // Update the less than list to skip over the nodes we\\'ve \\'moved\\'\\n        *prev = *larger_next;\\n      } else {\\n        // Node is in correct place, skip over it\\n        prev = &((*prev)->next);\\n      }\\n    }\\n    \\n    // Terminate the equal or larger than x list\\n    *larger_next = nullptr;\\n    \\n    // Attach those less than x to those greater than x\\n    *prev = larger; \\n    \\n    return head;\\n  }\\n```\\t\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n  ListNode* partition(ListNode* head, int x) {\\n    ListNode* larger = nullptr;\\n    ListNode** larger_next = &larger;\\n    ListNode** prev = &head;\\n    while (*prev) {\\n      if ((*prev)->val >= x) { // Node needs to be moved to greater list\\n        *larger_next = *prev;\\n        larger_next = &((*larger_next)->next);\\n        *prev = (*prev)->next;\\n      } else { // Node can be left in place\\n        prev = &((*prev)->next);\\n      }\\n    }\\n\\n    *larger_next = nullptr;\\n    *prev = larger; \\n    \\n    return head;\\n  }  \\n```\n```c\\nstruct ListNode* partition(struct ListNode* head, int x){\\n  struct ListNode* larger = NULL;\\n  struct ListNode** larger_next = &larger;\\n  struct ListNode** prev = &head;\\n  while (*prev) {\\n    if ((*prev)->val >= x) { /* Node needs to be moved to greater list */\\n      *larger_next = *prev;\\n      larger_next = &((*larger_next)->next);\\n      *prev = (*prev)->next;\\n    } else { /* Node can be left in place */\\n      prev = &((*prev)->next);\\n    }\\n  }\\n\\n  *larger_next = NULL;\\n  *prev = larger; \\n\\n  return head;\\n}\\n```\n```cpp\\n  ListNode* partition(ListNode* head, int x) {\\n    // Will hold the nodes greater than or equal to x\\t\\n    ListNode* larger = nullptr;\\n    ListNode** larger_next = &larger;\\n\\n    ListNode** prev = &head;\\n    while (*prev) {\\n      if ((*prev)->val >= x) {\\n        // Move the found node to the end of the list of larger nodes\\n        *larger_next = *prev;\\n        larger_next = &((*larger_next)->next);\\n        \\n        // Update the less than list to skip over the node we\\'ve moved\\n        *prev = (*prev)->next;\\n      } else {\\n        // Node is in the correct place, skip over it\\n        prev = &((*prev)->next);\\n      }\\n    }\\n    \\n    // Terminate the equal or larger than x list\\n    *larger_next = nullptr;\\n    \\n    // Attach those less than x to those greater than x\\n    *prev = larger; \\n    \\n    return head;\\n  }  \\n```\n```cpp\\n  ListNode* partition(ListNode* head, int x) {\\n    ListNode* larger = nullptr;\\n    ListNode** larger_next = &larger;\\n\\n    ListNode** prev = &head;\\n    while (*prev) {\\n      if ((*prev)->val >= x) {\\n        // Move the found node to the end of the list of larger nodes\\n        *larger_next = *prev;\\n        do {\\n          larger_next = &((*larger_next)->next);\\n        }\\n        while (*larger_next && (*larger_next)->val >= x);\\n        \\n        // Update the less than list to skip over the nodes we\\'ve \\'moved\\'\\n        *prev = *larger_next;\\n      } else {\\n        // Node is in correct place, skip over it\\n        prev = &((*prev)->next);\\n      }\\n    }\\n    \\n    // Terminate the equal or larger than x list\\n    *larger_next = nullptr;\\n    \\n    // Attach those less than x to those greater than x\\n    *prev = larger; \\n    \\n    return head;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29188,
                "title": "please-help-understand",
                "content": "can someone explain why the 4 isnt after the 3??\\n\\n```\\nGiven 1->4->3->2->5->2 and x = 3,\\nreturn 1->2->2->4->3->5.\\n```",
                "solutionTags": [],
                "code": "```\\nGiven 1->4->3->2->5->2 and x = 3,\\nreturn 1->2->2->4->3->5.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29269,
                "title": "java-concise-solution",
                "content": "        \\n    public ListNode partition(ListNode head, int x) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode head1, p1 = new ListNode(0), head2, p2 = new ListNode(0);\\n        head1 = p1;\\n        head2 = p2;\\n        while (head != null) {\\n            if (head.val < x) {\\n                p1.next = head;\\n                p1 = p1.next;\\n            } else {\\n                p2.next = head;\\n                p2 = p2.next;\\n            }\\n            head = head.next;\\n        }\\n        p2.next = null;\\n        p1.next = head2.next;\\n        return head1.next;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "        \\n    public ListNode partition(ListNode head, int x) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode head1, p1 = new ListNode(0), head2, p2 = new ListNode(0);\\n        head1 = p1;\\n        head2 = p2;\\n        while (head != null) {\\n            if (head.val < x) {\\n                p1.next = head;\\n                p1 = p1.next;\\n            } else {\\n                p2.next = head;\\n                p2 = p2.next;\\n            }\\n            head = head.next;\\n        }\\n        p2.next = null;\\n        p1.next = head2.next;\\n        return head1.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 29292,
                "title": "simple-c-solution",
                "content": "The idea is to keep adding the nodes to two different list which I have maintained it as head1 and head2.\\nHead1 list contains the value which are smaller than x and head 2 which has greater than or equal to x.\\ntemp1 and temp2 are used to keep track of the last element that has been added to the end . We traverse the given input list and keep changing the next pointer accordingly. At the end if there were no elements in head 1 we just return head2, otherwise we link the list head1(smaller elemets) to head2 and return head1\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        \\n        if(head == NULL)\\n            return head;\\n            \\n        ListNode *head1=NULL,*temp1,*head2=NULL,*temp2;\\n        ListNode *curr=head;\\n        \\n        while(curr!=NULL){\\n            if(curr->val<x){\\n                //for the list with smaller than number\\n                if(head1 == NULL){\\n                    //checking condition if the first element of this list\\n                    head1=curr;\\n                    curr=curr->next;\\n                    temp1=head1;\\n                    \\n                }else{\\n                    temp1->next=curr;\\n                    curr=curr->next;\\n                    temp1=temp1->next;\\n                    }\\n                \\n            }else{\\n                //for the list with greater than or equal to number\\n                if(head2 == NULL){\\n                    //checking condition if the first element of this list\\n                    head2=curr;\\n                    curr=curr->next;\\n                    temp2=head2;\\n                    temp2->next=NULL;\\n                    \\n                }else{\\n                    temp2->next=curr;\\n                    curr=curr->next;\\n                    temp2=temp2->next;\\n                    temp2->next=NULL;\\n                }\\n                \\n            }\\n        }\\n        if(head1!=NULL ){\\n            temp1->next = head2;\\n            return head1;\\n        }else if(head2!=NULL){\\n              return head2;\\n        }\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        \\n        if(head == NULL)\\n            return head;\\n            \\n        ListNode *head1=NULL,*temp1,*head2=NULL,*temp2;\\n        ListNode *curr=head;\\n        \\n        while(curr!=NULL){\\n            if(curr->val<x){\\n                //for the list with smaller than number\\n                if(head1 == NULL){\\n                    //checking condition if the first element of this list\\n                    head1=curr;\\n                    curr=curr->next;\\n                    temp1=head1;\\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 29352,
                "title": "simple-python-solution-and-easy-to-understand",
                "content": "    def partition(self, head, x):\\n        if not head:\\n            return None\\n        dy = ListNode(0)\\n        dy.next = head\\n        a = dy\\n        while a.next and a.next.val < x:\\n            a = a.next\\n        b = a.next\\n        c = b\\n        while c and c.next:\\n            if c.next.val < x:\\n                d = c.next\\n                c.next = c.next.next\\n                a.next = d\\n                d.next = b\\n                a = d\\n            else:\\n                c = c.next\\n        return dy.next",
                "solutionTags": [],
                "code": "    def partition(self, head, x):\\n        if not head:\\n            return None\\n        dy = ListNode(0)\\n        dy.next = head\\n        a = dy\\n        while a.next and a.next.val < x:\\n            a = a.next\\n        b = a.next\\n        c = b\\n        while c and c.next:\\n            if c.next.val < x:\\n                d = c.next\\n                c.next = c.next.next\\n                a.next = d\\n                d.next = b\\n                a = d\\n            else:\\n                c = c.next\\n        return dy.next",
                "codeTag": "Python3"
            },
            {
                "id": 29377,
                "title": "my-accepted-solution-using-pointer-to-pointers",
                "content": "It looks as simple as i could think of. Going along our list, all nodes with a value less than x are appended to  list left, while nodes with a value greater than or equal to x are appended to list right. Finally join right to the tail of left and left is the answer.\\n\\n    ListNode *partition(ListNode *head, int x)\\n     {\\n            ListNode *left = NULL, *right = NULL, **p = &left, **q = &right, *entry = head;\\n    \\t\\n        \\twhile (entry) {\\n    \\t\\t    if (entry->val < x) {\\n    \\t\\t    \\t*p = entry; p = &(entry->next); entry = *p;\\n    \\t    \\t    }\\n    \\t    \\t    else {\\n    \\t\\t    \\t*q = entry; q = &(entry->next); entry = *q;\\n    \\t    \\t}\\n        \\t}\\n    \\t    *p = right; *q = NULL;\\n            return left;\\n     }",
                "solutionTags": [],
                "code": "It looks as simple as i could think of. Going along our list, all nodes with a value less than x are appended to  list left, while nodes with a value greater than or equal to x are appended to list right. Finally join right to the tail of left and left is the answer.\\n\\n    ListNode *partition(ListNode *head, int x)\\n     {\\n            ListNode *left = NULL, *right = NULL, **p = &left, **q = &right, *entry = head;\\n    \\t\\n        \\twhile (entry) {\\n    \\t\\t    if (entry->val < x) {\\n    \\t\\t    \\t*p = entry; p = &(entry->next); entry = *p;\\n    \\t    \\t    }\\n    \\t    \\t    else {\\n    \\t\\t    \\t*q = entry; q = &(entry->next); entry = *q;\\n    \\t    \\t}\\n        \\t}\\n    \\t    *p = right; *q = NULL;\\n            return left;\\n     }",
                "codeTag": "Unknown"
            },
            {
                "id": 29380,
                "title": "my-accepted-solution",
                "content": "Solution:\\n \\nKeep going along our list.  When we at node that greater or equal x, we remove this node from our list and move it to list of nodes greater than x.\\n\\nThen we need connect tail our list and list of nodes greater than x.\\n\\n    class Solution {\\n    public:\\n        ListNode *partition(ListNode *head, int x) {\\n            if (!head) return NULL;\\n            ListNode * iterator = head; \\n            \\n            ListNode * start = new ListNode(0); // list of nodes greater than x\\n            ListNode * tail = start;\\n            \\n            ListNode * newHead = new ListNode(0); \\n            newHead -> next = head;\\n            ListNode * pre = newHead; // previous node, we need it for removing\\n            \\n            \\n            while (iterator) {\\n                if (iterator -> val >= x) {\\n                    pre -> next = iterator -> next; // remove from our list\\n                    tail -> next = iterator; // add to list of nodes greater than x\\n                    tail = tail -> next;\\n                    iterator = iterator -> next;\\n                    tail -> next = NULL;\\n                }\\n                else\\n                    pre = iterator, iterator = iterator -> next;\\n            }\\n            pre -> next = start -> next;\\n            return newHead -> next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode *partition(ListNode *head, int x) {\\n            if (!head) return NULL;\\n            ListNode * iterator = head; \\n            \\n            ListNode * start = new ListNode(0); // list of nodes greater than x\\n            ListNode * tail = start;\\n            \\n            ListNode * newHead = new ListNode(0); \\n            newHead -> next = head;\\n            ListNode * pre = newHead; // previous node, we need it for removing\\n            \\n            \\n            while (iterator) {\\n                if (iterator -> val >= x) {\\n                    pre -> next = iterator -> next; // remove from our list\\n                    tail -> next = iterator; // add to list of nodes greater than x\\n                    tail = tail -> next;\\n                    iterator = iterator -> next;\\n                    tail -> next = NULL;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4022004,
                "title": "partition-list-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* dummy1 = new ListNode();\\n        ListNode* temp1 = dummy1;\\n        ListNode* dummy2 = new ListNode();\\n        ListNode* temp2 = dummy2;\\n        while (head != NULL) {\\n            if (head->val < x) {\\n                temp1->next = head;\\n                temp1 = temp1->next;\\n            } else {\\n                temp2->next = head;\\n                temp2 = temp2->next;\\n            }\\n            head = head->next;\\n        }\\n        if (dummy1->next == NULL)\\n            return dummy2->next;\\n        temp1->next = dummy2->next;\\n        temp2->next = NULL;\\n        return dummy1->next;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* dummy1 = new ListNode();\\n        ListNode* temp1 = dummy1;\\n        ListNode* dummy2 = new ListNode();\\n        ListNode* temp2 = dummy2;\\n        while (head != NULL) {\\n            if (head->val < x) {\\n                temp1->next = head;\\n                temp1 = temp1->next;\\n            } else {\\n                temp2->next = head;\\n                temp2 = temp2->next;\\n            }\\n            head = head->next;\\n        }\\n        if (dummy1->next == NULL)\\n            return dummy2->next;\\n        temp1->next = dummy2->next;\\n        temp2->next = NULL;\\n        return dummy1->next;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913088,
                "title": "beats-99-memory",
                "content": "# Intuition\\nTo solve this problem, you can create two separate linked lists: one for nodes less than x and another for nodes greater than or equal to x. Traverse the original linked list and insert nodes into the appropriate partitions based on their values. Finally, connect the tail of the \"less than x\" partition to the head of the \"greater than or equal to x\" partition. \\n\\n# Approach\\nThis code creates two separate partitions for nodes less than x and nodes greater than or equal to x, then connects them together while preserving their relative order.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def partition(self, head, x):\\n        \"\"\"\\n        :type head: ListNode\\n        :type x: int\\n        :rtype: ListNode\\n        \"\"\"\\n        greater_than_x_head=ListNode()\\n        greater_than_x_tail=greater_than_x_head\\n        less_than_x_head=ListNode()\\n        less_than_x_tail=less_than_x_head\\n\\n        current=head\\n        while current:\\n            if current.val<x:\\n                less_than_x_tail.next=current\\n                less_than_x_tail= less_than_x_tail.next\\n            else:\\n                greater_than_x_tail.next=current\\n                greater_than_x_tail=greater_than_x_tail.next\\n            current=current.next\\n        greater_than_x_tail.next=None\\n        less_than_x_tail.next=greater_than_x_head.next\\n        return less_than_x_head.next\\n\\n        \\n\\n```\\n# **PLEASE DO UPVOTE!!!\\uD83E\\uDD79**",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def partition(self, head, x):\\n        \"\"\"\\n        :type head: ListNode\\n        :type x: int\\n        :rtype: ListNode\\n        \"\"\"\\n        greater_than_x_head=ListNode()\\n        greater_than_x_tail=greater_than_x_head\\n        less_than_x_head=ListNode()\\n        less_than_x_tail=less_than_x_head\\n\\n        current=head\\n        while current:\\n            if current.val<x:\\n                less_than_x_tail.next=current\\n                less_than_x_tail= less_than_x_tail.next\\n            else:\\n                greater_than_x_tail.next=current\\n                greater_than_x_tail=greater_than_x_tail.next\\n            current=current.next\\n        greater_than_x_tail.next=None\\n        less_than_x_tail.next=greater_than_x_head.next\\n        return less_than_x_head.next\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912915,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n    \\n        before_x = ListNode(0)\\n        after_x = ListNode(0)\\n        \\n        before = before_x\\n        after = after_x\\n        \\n        current = head\\n        while current:\\n            if current.val < x:\\n                before.next = current\\n                before = before.next\\n            else:\\n                after.next = current\\n                after = after.next\\n            current = current.next\\n        \\n        \\n        before.next = after_x.next\\n        after.next = None\\n        \\n        return before_x.next\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n    \\n        before_x = ListNode(0)\\n        after_x = ListNode(0)\\n        \\n        before = before_x\\n        after = after_x\\n        \\n        current = head\\n        while current:\\n            if current.val < x:\\n                before.next = current\\n                before = before.next\\n            else:\\n                after.next = current\\n                after = after.next\\n            current = current.next\\n        \\n        \\n        before.next = after_x.next\\n        after.next = None\\n        \\n        return before_x.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912465,
                "title": "kotlin-solution",
                "content": "# Code\\n```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n\\n    var headLeft: ListNode? = null\\n    var tailLeft: ListNode? = null\\n    var headRight: ListNode? = null\\n    var tailRight: ListNode? = null\\n\\n    fun addLeft(node: ListNode?) {\\n        if(headLeft == null){\\n            headLeft = node\\n        } else {\\n            tailLeft!!.next = node\\n        }\\n        tailLeft = node\\n    }\\n\\n    fun addRight(node: ListNode?) {\\n        if(headRight == null){\\n            headRight = node\\n        } else {\\n            tailRight!!.next = node\\n        }\\n        tailRight = node\\n    }\\n\\n    fun partition(head: ListNode?, x: Int): ListNode? {\\n        var current = head\\n        while(current != null){\\n            if(current.`val` < x){\\n                addLeft(current)\\n            } else {\\n                addRight(current)\\n            }\\n            current = current.next\\n        }\\n\\n        return if(tailLeft != null) {\\n            tailLeft?.next = headRight\\n            tailRight?.next = null\\n            headLeft\\n        } else {\\n            headRight\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n\\n    var headLeft: ListNode? = null\\n    var tailLeft: ListNode? = null\\n    var headRight: ListNode? = null\\n    var tailRight: ListNode? = null\\n\\n    fun addLeft(node: ListNode?) {\\n        if(headLeft == null){\\n            headLeft = node\\n        } else {\\n            tailLeft!!.next = node\\n        }\\n        tailLeft = node\\n    }\\n\\n    fun addRight(node: ListNode?) {\\n        if(headRight == null){\\n            headRight = node\\n        } else {\\n            tailRight!!.next = node\\n        }\\n        tailRight = node\\n    }\\n\\n    fun partition(head: ListNode?, x: Int): ListNode? {\\n        var current = head\\n        while(current != null){\\n            if(current.`val` < x){\\n                addLeft(current)\\n            } else {\\n                addRight(current)\\n            }\\n            current = current.next\\n        }\\n\\n        return if(tailLeft != null) {\\n            tailLeft?.next = headRight\\n            tailRight?.next = null\\n            headLeft\\n        } else {\\n            headRight\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911700,
                "title": "c-cut-and-paste-beats-100-tc-well-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n***Cut and paste***\\nCut from the later part of the list and add to the initial part of the list. \\nRearranging linked list by moving nodes with values less than x to the beginning of the list while maintaining their relative order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n***Two Pointers:*** \\nYou maintain two pointers: one that tracks the end of the first part of the list (containing elements less than x), and another that traverses the later part of the list.\\n\\n***Rearranging Nodes:*** \\nWhile traversing the later part of the list with the second pointer, if you encounter a node with a value less than x, you detach it from its current position and insert it at the end of the first part of the list. This operation essentially \"cuts and pastes\" the node.\\n\\n***Maintaining Relative Order:*** \\nIt\\'s important to note that while you\\'re moving nodes from the later part of the list to the first part, you should maintain their relative order. This means that if the later part of the list contains nodes with values in the order A -> B -> C, and you encounter node B with a value less than x, you should move B to the end of the first part without disrupting the order of A and C.\\n\\n***Completion:*** \\nOnce you\\'ve traversed the entire list with the second pointer, all nodes with values less than x should be moved to the beginning of the list. The second part of the list will now only contain nodes with values greater than or equal to x.\\n\\n**NO NEED TO MAKE 2 NEW LIST AND THEN JOIN THEM JUST CUT AND PASTE.**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n        O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* new_head = new ListNode(0);\\n        new_head->next = head;\\n        head = new_head;\\n        ListNode* after = new_head;\\n        while(head->next != NULL && head->next->val < x){\\n            head = head->next;\\n            after = after->next;\\n        }\\n        while(after->next != NULL){\\n            while(after->next != NULL && after->next->val >= x){\\n                after = after->next;\\n            }\\n            if(after->next != NULL){\\n                ListNode* temp = after->next;\\n                after->next = after->next->next;\\n                temp->next = head->next;\\n                head->next = temp;\\n                head = temp;\\n            }\\n        }\\n        return new_head->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* new_head = new ListNode(0);\\n        new_head->next = head;\\n        head = new_head;\\n        ListNode* after = new_head;\\n        while(head->next != NULL && head->next->val < x){\\n            head = head->next;\\n            after = after->next;\\n        }\\n        while(after->next != NULL){\\n            while(after->next != NULL && after->next->val >= x){\\n                after = after->next;\\n            }\\n            if(after->next != NULL){\\n                ListNode* temp = after->next;\\n                after->next = after->next->next;\\n                temp->next = head->next;\\n                head->next = temp;\\n                head = temp;\\n            }\\n        }\\n        return new_head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911630,
                "title": "c-faster-than-100-readable-code-intuition-explained",
                "content": "# Intuition\\nThe idea in here is really very simple. The total problem is divided into two equal parts.\\nFinding the nodes which are lesser than the key value, and finding the nodes which are greater than or equal to key value.\\n\\nAs, an initial step we will in total maintain 4 pointers lesser, greater, startLesser, startGreater.\\n\\nlesser and greater stores the current values of lesser and greater values and the start pointers stores the start values. We will traverse and then store the values.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *lesser = NULL;\\n        ListNode *greater = NULL;\\n        ListNode *startLesser = NULL;\\n        ListNode *startGreater = NULL;\\n\\n        ListNode *prev;\\n\\n        while(head != NULL){\\n            prev = head;\\n            head = head->next;\\n            prev->next = NULL;\\n\\n            if(prev->val < x){\\n                if(lesser == NULL){\\n                    lesser = prev;\\n                    startLesser = lesser;\\n                }\\n                else{\\n                    lesser->next = prev;\\n                    lesser = lesser->next;\\n                }\\n            }\\n\\n            else{\\n                if(greater == NULL){\\n                    greater = prev;\\n                    startGreater = greater;\\n                }\\n                else{\\n                    greater->next = prev;\\n                    greater = greater->next;\\n                }\\n            }\\n\\n        }\\n\\n        if(!startLesser) return startGreater;\\n        if(!startGreater) return startLesser;\\n        lesser->next = startGreater;\\n\\n        return startLesser;\\n\\n    }\\n};\\n```\\n**Please upvote if you like the solution**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *lesser = NULL;\\n        ListNode *greater = NULL;\\n        ListNode *startLesser = NULL;\\n        ListNode *startGreater = NULL;\\n\\n        ListNode *prev;\\n\\n        while(head != NULL){\\n            prev = head;\\n            head = head->next;\\n            prev->next = NULL;\\n\\n            if(prev->val < x){\\n                if(lesser == NULL){\\n                    lesser = prev;\\n                    startLesser = lesser;\\n                }\\n                else{\\n                    lesser->next = prev;\\n                    lesser = lesser->next;\\n                }\\n            }\\n\\n            else{\\n                if(greater == NULL){\\n                    greater = prev;\\n                    startGreater = greater;\\n                }\\n                else{\\n                    greater->next = prev;\\n                    greater = greater->next;\\n                }\\n            }\\n\\n        }\\n\\n        if(!startLesser) return startGreater;\\n        if(!startGreater) return startLesser;\\n        lesser->next = startGreater;\\n\\n        return startLesser;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911381,
                "title": "c-solution-for-partition-list-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires partitioning a linked list into two parts: one containing nodes with values less than a given x, and the other containing nodes with values greater than or equal to x. The relative order of nodes within each partition should be preserved. To achieve this, we can iterate through the original list, creating two new lists: one for nodes less than x and another for nodes greater than or equal to x. After processing all nodes, we can connect the two new lists and return the modified linked list.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We\\'ll maintain two new linked lists: one for nodes less than x and another for nodes greater than or equal to x.\\n- We\\'ll iterate through the original linked list, and for each node:\\n1. If the node\\'s value is less than x, we\\'ll add it to the \"less\" list.\\n1. Otherwise, we\\'ll add it to the \"greater\" list.\\n- After processing all nodes, we\\'ll connect the end of the \"less\" list to the start of the \"greater\" list.\\n- Finally, we\\'ll return the head of the \"less\" list as the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n), where n is the number of nodes in the original linked list. This is because we traverse the original linked list once and perform constant-time operations for each node (addition to the \"less\" or \"greater\" list). The final step of connecting the two lists also takes constant time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n) as well. We create two new linked lists to hold the nodes less than x and nodes greater than or equal to x. In the worst case, all nodes could belong to one of these lists, resulting in O(n) additional space usage. Additionally, the space required for the original linked list traversal is negligible compared to the space used for the new lists.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode Partition(ListNode head, int x) {\\n        ListNode lessHead = new ListNode(); // Head of the list for nodes less than x\\n        ListNode less = lessHead; // Current pointer for nodes less than x\\n        ListNode greaterHead = new ListNode(); // Head of the list for nodes greater than or equal to x\\n        ListNode greater = greaterHead; // Current pointer for nodes greater than or equal to x\\n        \\n        while (head != null) {\\n            if (head.val < x) {\\n                less.next = head;\\n                less = less.next;\\n            } else {\\n                greater.next = head;\\n                greater = greater.next;\\n            }\\n            head = head.next;\\n        }\\n        \\n        greater.next = null; // Set the end of greater list to null\\n        less.next = greaterHead.next; // Connect the less list to the greater list\\n        \\n        return lessHead.next; // The final partitioned list\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode Partition(ListNode head, int x) {\\n        ListNode lessHead = new ListNode(); // Head of the list for nodes less than x\\n        ListNode less = lessHead; // Current pointer for nodes less than x\\n        ListNode greaterHead = new ListNode(); // Head of the list for nodes greater than or equal to x\\n        ListNode greater = greaterHead; // Current pointer for nodes greater than or equal to x\\n        \\n        while (head != null) {\\n            if (head.val < x) {\\n                less.next = head;\\n                less = less.next;\\n            } else {\\n                greater.next = head;\\n                greater = greater.next;\\n            }\\n            head = head.next;\\n        }\\n        \\n        greater.next = null; // Set the end of greater list to null\\n        less.next = greaterHead.next; // Connect the less list to the greater list\\n        \\n        return lessHead.next; // The final partitioned list\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911165,
                "title": "easy-solution-explained-line-by-line-beats-95-33-90-11",
                "content": "`code`# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n```\\n\\n---\\n\\nclass Solution:\\n    def partition(self, head, x):\\n        less_head = ListNode()  # Dummy node for the less than x list\\n        greater_head = ListNode()  # Dummy node for the greater than or equal to x list\\n        less_ptr = less_head  # Pointer for the less than x list\\n        greater_ptr = greater_head  # Pointer for the greater than or equal to x list\\n        \\n        current = head\\n        \\n        while current:\\n            if current.val < x:\\n                less_ptr.next = current\\n                less_ptr = less_ptr.next\\n            else:\\n                greater_ptr.next = current\\n                greater_ptr = greater_ptr.next\\n            \\n            current = current.next\\n        \\n        greater_ptr.next = None  # Set the end of the greater list\\n        less_ptr.next = greater_head.next  # Connect the end of the less list to the beginning of the greater list\\n        \\n        return less_head.next\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "C#"
                ],
                "code": "```\\n\\n---\\n\\nclass Solution:\\n    def partition(self, head, x):\\n        less_head = ListNode()  # Dummy node for the less than x list\\n        greater_head = ListNode()  # Dummy node for the greater than or equal to x list\\n        less_ptr = less_head  # Pointer for the less than x list\\n        greater_ptr = greater_head  # Pointer for the greater than or equal to x list\\n        \\n        current = head\\n        \\n        while current:\\n            if current.val < x:\\n                less_ptr.next = current\\n                less_ptr = less_ptr.next\\n            else:\\n                greater_ptr.next = current\\n                greater_ptr = greater_ptr.next\\n            \\n            current = current.next\\n        \\n        greater_ptr.next = None  # Set the end of the greater list\\n        less_ptr.next = greater_head.next  # Connect the end of the less list to the beginning of the greater list\\n        \\n        return less_head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894351,
                "title": "c-o-n-0ms-100-beats-with-proper-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        struct ListNode *left_list = new ListNode(0);\\n        struct ListNode *right_list = new ListNode(0);\\n\\n        struct ListNode *left_pointer = left_list;\\n        struct ListNode *right_pointer = right_list;\\n\\n        while(head)\\n        {\\n            if(head->val < x)\\n            {\\n                left_pointer->next = head;\\n                left_pointer = left_pointer->next;\\n            }\\n            else\\n            {\\n                right_pointer->next = head;\\n                right_pointer = right_pointer->next;\\n            }\\n            head = head->next;   \\n        }\\n        left_pointer->next = right_list->next;\\n        right_pointer->next = NULL;\\n        return left_list->next;       \\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        struct ListNode *left_list = new ListNode(0);\\n        struct ListNode *right_list = new ListNode(0);\\n\\n        struct ListNode *left_pointer = left_list;\\n        struct ListNode *right_pointer = right_list;\\n\\n        while(head)\\n        {\\n            if(head->val < x)\\n            {\\n                left_pointer->next = head;\\n                left_pointer = left_pointer->next;\\n            }\\n            else\\n            {\\n                right_pointer->next = head;\\n                right_pointer = right_pointer->next;\\n            }\\n            head = head->next;   \\n        }\\n        left_pointer->next = right_list->next;\\n        right_pointer->next = NULL;\\n        return left_list->next;       \\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875785,
                "title": "beginners-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->step 1 : create 2 new linked lists , create 2 new pointers which points at head of new lists.\\nstep 2 : traverse the given list and insert the value in both the list according to the given conditions.\\nstep 3 : merge both the list.\\nstep 4 : return the next pointer of th list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* temp1 = new ListNode(0);\\n        ListNode* temp2 = new ListNode(0);\\n\\n        ListNode* l1 = temp1;\\n        ListNode* l2 = temp2;\\n\\n        while(head != NULL){\\n            if(head->val < x){\\n                l1->next = head;\\n                l1 = l1->next;\\n            }\\n            else{\\n                l2->next = head;\\n                l2 = l2->next;\\n            }\\n            head = head->next;\\n        }\\n        //combine both lists\\n        l1->next = temp2->next;\\n        l2->next = NULL;\\n\\n        return temp1->next;\\n    };\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* temp1 = new ListNode(0);\\n        ListNode* temp2 = new ListNode(0);\\n\\n        ListNode* l1 = temp1;\\n        ListNode* l2 = temp2;\\n\\n        while(head != NULL){\\n            if(head->val < x){\\n                l1->next = head;\\n                l1 = l1->next;\\n            }\\n            else{\\n                l2->next = head;\\n                l2 = l2->next;\\n            }\\n            head = head->next;\\n        }\\n        //combine both lists\\n        l1->next = temp2->next;\\n        l2->next = NULL;\\n\\n        return temp1->next;\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774210,
                "title": "easy-java-solution-easy-to-understand-clean-code-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraversing the linked list two times. In the first traversal, adding all the nodes to the answer which are less than x. In the second traversal, adding all the nodes which are greater than or equal to x to the answer.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        \\n        if(head == null || head.next == null) {\\n            return head;\\n        }\\n\\n        ListNode traverse1 = head;\\n        ListNode traverse2 = head;\\n        ListNode temp = new ListNode();\\n        ListNode ans = temp;\\n\\n        while(traverse1 != null) {\\n\\n            if(traverse1.val < x) {\\n                temp.next = new ListNode(traverse1.val);\\n                temp = temp.next;\\n                traverse1 = traverse1.next;\\n            }\\n            else {\\n                traverse1 = traverse1.next;\\n            }\\n        }\\n\\n        while(traverse2 != null) {\\n\\n            if(traverse2.val >= x) {\\n                temp.next = new ListNode(traverse2.val);\\n                temp = temp.next;\\n                traverse2 = traverse2.next;\\n            }\\n            else {\\n                traverse2 = traverse2.next;\\n            }\\n        }\\n\\n        temp.next = null;\\n        return ans.next;\\n\\n    }\\n}\\n```\\n\\n![cat.jpeg](https://assets.leetcode.com/users/images/790808e1-ff70-4d2c-a9bf-6fb030beed05_1689519896.3915954.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        \\n        if(head == null || head.next == null) {\\n            return head;\\n        }\\n\\n        ListNode traverse1 = head;\\n        ListNode traverse2 = head;\\n        ListNode temp = new ListNode();\\n        ListNode ans = temp;\\n\\n        while(traverse1 != null) {\\n\\n            if(traverse1.val < x) {\\n                temp.next = new ListNode(traverse1.val);\\n                temp = temp.next;\\n                traverse1 = traverse1.next;\\n            }\\n            else {\\n                traverse1 = traverse1.next;\\n            }\\n        }\\n\\n        while(traverse2 != null) {\\n\\n            if(traverse2.val >= x) {\\n                temp.next = new ListNode(traverse2.val);\\n                temp = temp.next;\\n                traverse2 = traverse2.next;\\n            }\\n            else {\\n                traverse2 = traverse2.next;\\n            }\\n        }\\n\\n        temp.next = null;\\n        return ans.next;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772710,
                "title": "using-dummy-node-connecting-pointer-linked-list-solution",
                "content": "\\n\\n    class Solution {\\n    public:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* dummy=new ListNode(-1);\\n        ListNode* p=dummy;\\n        ListNode* dummy1=new ListNode(-1);\\n        ListNode* q=dummy1;\\n        ListNode* s=head;\\n        while(s){\\n            if(s->val<x){\\n                dummy->next=s;\\n                dummy=dummy->next;\\n            }\\n            else{\\n                dummy1->next=s;\\n                dummy1=dummy1->next;\\n            }\\n            s=s->next;\\n        }\\n        \\n        dummy1->next=NULL;\\n        dummy->next=q->next;\\n        return p->next;\\n      }\\n     };",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* dummy=new ListNode(-1);\\n        ListNode* p=dummy;\\n        ListNode* dummy1=new ListNode(-1);\\n        ListNode* q=dummy1;\\n        ListNode* s=head;\\n        while(s){\\n            if(s->val<x){\\n                dummy->next=s;\\n                dummy=dummy->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3740668,
                "title": "easy-implementation-using-linkedlist-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* lower = new ListNode();\\n        ListNode* ans = lower;\\n        ListNode* higher = new ListNode();\\n        ListNode* temp = higher;\\n\\n        while(head){\\n            if(head->val < x) lower->next = new ListNode(head->val), lower = lower->next;\\n            else higher->next = new ListNode(head->val), higher = higher->next;\\n            head = head->next;\\n        }\\n\\n        lower->next = temp->next;\\n        return ans->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* lower = new ListNode();\\n        ListNode* ans = lower;\\n        ListNode* higher = new ListNode();\\n        ListNode* temp = higher;\\n\\n        while(head){\\n            if(head->val < x) lower->next = new ListNode(head->val), lower = lower->next;\\n            else higher->next = new ListNode(head->val), higher = higher->next;\\n            head = head->next;\\n        }\\n\\n        lower->next = temp->next;\\n        return ans->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524027,
                "title": "c-beats-100-easiest-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode left(0), right(0);\\n        ListNode *l = &left, *r = &right;\\n        while(head){\\n            ListNode* & ref = head->val < x ? l : r;\\n            ref->next = head;\\n            ref = ref->next;\\n            head = head->next;\\n        }\\n        l->next = right.next;\\n        r->next = NULL;\\n        return left.next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode left(0), right(0);\\n        ListNode *l = &left, *r = &right;\\n        while(head){\\n            ListNode* & ref = head->val < x ? l : r;\\n            ref->next = head;\\n            ref = ref->next;\\n            head = head->next;\\n        }\\n        l->next = right.next;\\n        r->next = NULL;\\n        return left.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442825,
                "title": "86-partition-list-java",
                "content": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n       ListNode list1=new ListNode(0);\\n       ListNode list2=new ListNode(0);\\n       ListNode l1=list1;\\n       ListNode l2=list2;\\n       while(head!=null)\\n       {\\n           if(x<=head.val)\\n           {\\n               l2.next=head;\\n               l2=l2.next;\\n           }\\n           else\\n           {\\n                l1.next=head;\\n               l1=l1.next;\\n           }\\n           head=head.next;\\n       }\\n        l1.next=list2.next;\\n         l2.next=null;\\n        return list1.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n       ListNode list1=new ListNode(0);\\n       ListNode list2=new ListNode(0);\\n       ListNode l1=list1;\\n       ListNode l2=list2;\\n       while(head!=null)\\n       {\\n           if(x<=head.val)\\n           {\\n               l2.next=head;\\n               l2=l2.next;\\n           }\\n           else\\n           {\\n                l1.next=head;\\n               l1=l1.next;\\n           }\\n           head=head.next;\\n       }\\n        l1.next=list2.next;\\n         l2.next=null;\\n        return list1.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348462,
                "title": "easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* left=new ListNode();\\n        ListNode* right= new ListNode();\\n        ListNode* ptr=right;\\n        ListNode* ptr2=left;\\n        ListNode*curr=head;\\n        while(curr){\\n            if(curr->val>=x){\\n                //right\\n                ptr->next=new ListNode(curr->val);\\n                ptr=ptr->next;\\n            }\\n            else{\\n                //left\\n                ptr2->next=new ListNode(curr->val);\\n                ptr2=ptr2->next;\\n            }\\n            curr=curr->next;\\n        }\\n        ptr2->next=right->next;\\n        \\n        return left->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* left=new ListNode();\\n        ListNode* right= new ListNode();\\n        ListNode* ptr=right;\\n        ListNode* ptr2=left;\\n        ListNode*curr=head;\\n        while(curr){\\n            if(curr->val>=x){\\n                //right\\n                ptr->next=new ListNode(curr->val);\\n                ptr=ptr->next;\\n            }\\n            else{\\n                //left\\n                ptr2->next=new ListNode(curr->val);\\n                ptr2=ptr2->next;\\n            }\\n            curr=curr->next;\\n        }\\n        ptr2->next=right->next;\\n        \\n        return left->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254043,
                "title": "python3-by-linkedlist-into-list-conversion-easy-solution",
                "content": "Please upvote if you find the solution helpful.\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        lst=[]\\n        lowlst=[]\\n        highlst=[]\\n        x_index = 0\\n        while head:\\n            lst.append(head.val)\\n            head = head.next\\n        for i in range(len(lst)):\\n            if lst[i]<x:\\n                lowlst.append(lst[i])\\n            else:\\n                highlst.append(lst[i])\\n        a = ListNode(0)\\n        temp = a\\n        for i in lowlst+highlst:\\n            temp.next = ListNode(i)\\n            temp = temp.next\\n        return a.next\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\\n        lst=[]\\n        lowlst=[]\\n        highlst=[]\\n        x_index = 0\\n        while head:\\n            lst.append(head.val)\\n            head = head.next\\n        for i in range(len(lst)):\\n            if lst[i]<x:\\n                lowlst.append(lst[i])\\n            else:\\n                highlst.append(lst[i])\\n        a = ListNode(0)\\n        temp = a\\n        for i in lowlst+highlst:\\n            temp.next = ListNode(i)\\n            temp = temp.next\\n        return a.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196949,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if(!head){return NULL;}\\n        vector<int>v;\\n        while(head){\\n            v.push_back(head->val);\\n            head=head->next;\\n        }\\n        vector<int>v1;\\n        for(int i=0; i<v.size(); i++){\\n            if(v[i]<x){\\n                v1.push_back(v[i]);\\n                v.erase(v.begin()+i);\\n                i--;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n        for(int i=v1.size()-1; i>=0; i--){\\n            v.push_back(v1[i]);\\n        }\\n        reverse(v.begin(), v.end());\\n        ListNode* root=NULL;\\n        for(int i=v.size()-1; i>=0; i--){\\n            ListNode* temp=new ListNode;\\n            temp->val=v[i];\\n            temp->next=root;\\n            root=temp;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if(!head){return NULL;}\\n        vector<int>v;\\n        while(head){\\n            v.push_back(head->val);\\n            head=head->next;\\n        }\\n        vector<int>v1;\\n        for(int i=0; i<v.size(); i++){\\n            if(v[i]<x){\\n                v1.push_back(v[i]);\\n                v.erase(v.begin()+i);\\n                i--;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n        for(int i=v1.size()-1; i>=0; i--){\\n            v.push_back(v1[i]);\\n        }\\n        reverse(v.begin(), v.end());\\n        ListNode* root=NULL;\\n        for(int i=v.size()-1; i>=0; i--){\\n            ListNode* temp=new ListNode;\\n            temp->val=v[i];\\n            temp->next=root;\\n            root=temp;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128330,
                "title": "0ms-beats-100-java-solution-with-explanation",
                "content": "# Intuition\\nAlgorithm:\\n1. Keep two dummy nodes named smallerHead and largerHead.\\n2. Make curr point to head.\\n3. If (curr.val<x) , then make smallerHead\\'s next to point to currr.\\n4. Otherwise, make largerHead\\'s next to point to currr.\\n5. After reaching the end of the list, make current largerHead\\'s next node to point to null (to avoid cycle-found-in-linkedlist error).\\n6. Join the largerHead to the smallerHead.\\n7. Return smallerHead.next.\\n\\n![answer.jpeg](https://assets.leetcode.com/users/images/2644d90b-e167-45b7-b4f3-1deda5d42c14_1675275035.2494404.jpeg)\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode smallerHead = new ListNode(0);\\n        ListNode smaller=smallerHead;\\n        ListNode largerHead = new ListNode(0);\\n        ListNode larger=largerHead;\\n\\n        ListNode curr=head;\\n\\n        while(curr!=null) {\\n            if(curr.val<x) {\\n                smaller.next=curr;\\n                smaller=smaller.next;\\n            }\\n            else {\\n                larger.next=curr;\\n                larger=larger.next;\\n                \\n            }\\n            curr=curr.next;\\n        }\\n        larger.next=null;\\n        smaller.next=largerHead.next;\\n        return smallerHead.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode smallerHead = new ListNode(0);\\n        ListNode smaller=smallerHead;\\n        ListNode largerHead = new ListNode(0);\\n        ListNode larger=largerHead;\\n\\n        ListNode curr=head;\\n\\n        while(curr!=null) {\\n            if(curr.val<x) {\\n                smaller.next=curr;\\n                smaller=smaller.next;\\n            }\\n            else {\\n                larger.next=curr;\\n                larger=larger.next;\\n                \\n            }\\n            curr=curr.next;\\n        }\\n        larger.next=null;\\n        smaller.next=largerHead.next;\\n        return smallerHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062779,
                "title": "100-0-ms-4-pointers-trick-simple",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\npublic ListNode partition(ListNode head, int x) {\\n  ListNode leftHead=new ListNode(),rightHead=new ListNode();\\n  ListNode leftTailPointer=leftHead,rightTailPointer=rightHead;\\n  while(head!=null){\\n      if(head.val<x){\\n          leftTailPointer.next=head;\\n          leftTailPointer=leftTailPointer.next;\\n      }else{\\n          rightTailPointer.next=head;\\n          rightTailPointer=rightTailPointer.next;\\n      }\\n      head=head.next;\\n  }\\n  rightTailPointer.next=null;\\n  leftTailPointer.next=rightHead.next;\\n  return leftHead.next;\\n}\\n```\\n```c++ [] \\nListNode* partition(ListNode* head, int x) {\\n  ListNode* leftHead = new ListNode();\\n  ListNode* rightHead = new ListNode();\\n  ListNode* leftTailPointer = leftHead;\\n  ListNode* rightTailPointer = rightHead;\\n  while (head != nullptr) {\\n    if (head->val < x) {\\n      leftTailPointer->next = head;\\n      leftTailPointer = leftTailPointer->next;\\n    } else {\\n      rightTailPointer->next = head;\\n      rightTailPointer = rightTailPointer->next;\\n    }\\n    head = head->next;\\n  }\\n  rightTailPointer->next = nullptr;\\n  leftTailPointer->next = rightHead->next;\\n  return leftHead->next;\\n}\\n```\\n```python [] \\ndef partition(head, x):\\n  leftHead = ListNode()\\n  rightHead = ListNode()\\n  leftTail = leftHead\\n  rightTail = rightHead\\n  while head is not None:\\n    if head.val < x:\\n      leftTail.next = head\\n      leftTail = leftTail.next\\n    else:\\n      rightTail.next = head\\n      rightTail = rightTail.next\\n    head = head.next\\n  rightTail.next = None\\n  leftTail.next = rightHead.next\\n  return leftHead.next\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```java []\\npublic ListNode partition(ListNode head, int x) {\\n  ListNode leftHead=new ListNode(),rightHead=new ListNode();\\n  ListNode leftTailPointer=leftHead,rightTailPointer=rightHead;\\n  while(head!=null){\\n      if(head.val<x){\\n          leftTailPointer.next=head;\\n          leftTailPointer=leftTailPointer.next;\\n      }else{\\n          rightTailPointer.next=head;\\n          rightTailPointer=rightTailPointer.next;\\n      }\\n      head=head.next;\\n  }\\n  rightTailPointer.next=null;\\n  leftTailPointer.next=rightHead.next;\\n  return leftHead.next;\\n}\\n```\n```c++ [] \\nListNode* partition(ListNode* head, int x) {\\n  ListNode* leftHead = new ListNode();\\n  ListNode* rightHead = new ListNode();\\n  ListNode* leftTailPointer = leftHead;\\n  ListNode* rightTailPointer = rightHead;\\n  while (head != nullptr) {\\n    if (head->val < x) {\\n      leftTailPointer->next = head;\\n      leftTailPointer = leftTailPointer->next;\\n    } else {\\n      rightTailPointer->next = head;\\n      rightTailPointer = rightTailPointer->next;\\n    }\\n    head = head->next;\\n  }\\n  rightTailPointer->next = nullptr;\\n  leftTailPointer->next = rightHead->next;\\n  return leftHead->next;\\n}\\n```\n```python [] \\ndef partition(head, x):\\n  leftHead = ListNode()\\n  rightHead = ListNode()\\n  leftTail = leftHead\\n  rightTail = rightHead\\n  while head is not None:\\n    if head.val < x:\\n      leftTail.next = head\\n      leftTail = leftTail.next\\n    else:\\n      rightTail.next = head\\n      rightTail = rightTail.next\\n    head = head.next\\n  rightTail.next = None\\n  leftTail.next = rightHead.next\\n  return leftHead.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3053084,
                "title": "c-using-queue-beginner-friendly-solution",
                "content": "\\n\\n### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        queue<ListNode*> before;\\n        queue<ListNode*> after;\\n\\n        while(head) {\\n            if(head-> val >= x) before.push(head);\\n            else after.push(head);\\n            head = head->next;\\n        }\\n\\n        ListNode *answer = nullptr;\\n        ListNode *curr = nullptr;\\n\\n        while(!after.empty()) {\\n            auto f = after.front(); after.pop();\\n            if(!answer) {\\n                answer = f;\\n                curr = f;\\n            }else {\\n                curr -> next = f;\\n                curr = f;\\n            }\\n        }\\n\\n        while(!before.empty()) {\\n            auto f = before.front(); before.pop();\\n            if(!answer) {\\n                answer = f;\\n                curr = f;\\n            }else {\\n                curr -> next = f;\\n                curr = f;\\n            }\\n        }\\n\\n        if(curr) curr -> next = nullptr;\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        queue<ListNode*> before;\\n        queue<ListNode*> after;\\n\\n        while(head) {\\n            if(head-> val >= x) before.push(head);\\n            else after.push(head);\\n            head = head->next;\\n        }\\n\\n        ListNode *answer = nullptr;\\n        ListNode *curr = nullptr;\\n\\n        while(!after.empty()) {\\n            auto f = after.front(); after.pop();\\n            if(!answer) {\\n                answer = f;\\n                curr = f;\\n            }else {\\n                curr -> next = f;\\n                curr = f;\\n            }\\n        }\\n\\n        while(!before.empty()) {\\n            auto f = before.front(); before.pop();\\n            if(!answer) {\\n                answer = f;\\n                curr = f;\\n            }else {\\n                curr -> next = f;\\n                curr = f;\\n            }\\n        }\\n\\n        if(curr) curr -> next = nullptr;\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985105,
                "title": "c-faster-than-85-using-2-new-copy-nodes-beginner-friendly-clean-code",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    ListNode* partition(ListNode* head, int x) {\\n\\n      \\n      if(head == NULL || head->next == NULL) return head;\\n\\n\\n       ListNode *node1 = new ListNode(), *node2 = new ListNode(NULL);\\n       ListNode *l = node1, *r = node2, *ptr = head;\\n\\n       while(ptr!=NULL)\\n       {\\n           if(ptr->val < x)\\n           {\\n               ListNode *curr = new ListNode(ptr->val);\\n               l->next = curr;\\n               l = l->next;    \\n           }\\n\\n            ptr = ptr->next;\\n       }\\n       \\n       ptr = head;\\n\\n       while(ptr!=NULL)\\n       {\\n           if(ptr->val >= x)\\n           {\\n               ListNode *curr = new ListNode(ptr->val);\\n               r->next = curr;\\n               r = r->next;\\n               \\n           }\\n\\n            ptr = ptr->next;\\n       }\\n\\n\\n        node2 = node2->next;\\n        node1 = node1->next;\\n\\n\\n        if(node1 == NULL) return node2;\\n\\n        l->next = node2;\\n       \\n    \\n        return node1;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    ListNode* partition(ListNode* head, int x) {\\n\\n      \\n      if(head == NULL || head->next == NULL) return head;\\n\\n\\n       ListNode *node1 = new ListNode(), *node2 = new ListNode(NULL);\\n       ListNode *l = node1, *r = node2, *ptr = head;\\n\\n       while(ptr!=NULL)\\n       {\\n           if(ptr->val < x)\\n           {\\n               ListNode *curr = new ListNode(ptr->val);\\n               l->next = curr;\\n               l = l->next;    \\n           }\\n\\n            ptr = ptr->next;\\n       }\\n       \\n       ptr = head;\\n\\n       while(ptr!=NULL)\\n       {\\n           if(ptr->val >= x)\\n           {\\n               ListNode *curr = new ListNode(ptr->val);\\n               r->next = curr;\\n               r = r->next;\\n               \\n           }\\n\\n            ptr = ptr->next;\\n       }\\n\\n\\n        node2 = node2->next;\\n        node1 = node1->next;\\n\\n\\n        if(node1 == NULL) return node2;\\n\\n        l->next = node2;\\n       \\n    \\n        return node1;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974188,
                "title": "java-100-faster-solution-o-n",
                "content": "# Approach\\nTwo pointers approach\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if (head == null || head.next == null) return head;\\n        ListNode lessCurr = null, xCurr = null, current = head;\\n        ListNode lessHead = null, xHead = null;\\n        while (current != null) {\\n            if (current.val < x) {\\n                if (lessCurr == null) {\\n                    lessCurr = current;\\n                    lessHead = lessCurr;\\n                }\\n                else {\\n                    lessCurr.next = current;\\n                    lessCurr = lessCurr.next;\\n                }\\n            } else {\\n                if (xCurr == null) {\\n                    xCurr = current;\\n                    xHead = xCurr;\\n                }\\n                else {\\n                    xCurr.next = current;\\n                    xCurr = xCurr.next;\\n                }\\n            }\\n            current = current.next;\\n        }\\n        if (xCurr != null) xCurr.next = null;\\n        if (lessCurr != null) lessCurr.next = xHead;\\n        return lessHead != null ? lessHead : xHead;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if (head == null || head.next == null) return head;\\n        ListNode lessCurr = null, xCurr = null, current = head;\\n        ListNode lessHead = null, xHead = null;\\n        while (current != null) {\\n            if (current.val < x) {\\n                if (lessCurr == null) {\\n                    lessCurr = current;\\n                    lessHead = lessCurr;\\n                }\\n                else {\\n                    lessCurr.next = current;\\n                    lessCurr = lessCurr.next;\\n                }\\n            } else {\\n                if (xCurr == null) {\\n                    xCurr = current;\\n                    xHead = xCurr;\\n                }\\n                else {\\n                    xCurr.next = current;\\n                    xCurr = xCurr.next;\\n                }\\n            }\\n            current = current.next;\\n        }\\n        if (xCurr != null) xCurr.next = null;\\n        if (lessCurr != null) lessCurr.next = xHead;\\n        return lessHead != null ? lessHead : xHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906962,
                "title": "easy-solution-beats-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        vector<int> v1;\\n        vector<int> v2;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            int y = temp->val;\\n            if(y>=x){\\n                v2.push_back(y);\\n            }\\n            else{\\n                v1.push_back(y);\\n            }\\n            temp = temp->next;\\n        }\\n        temp = head;\\n        for(int i =0; i<v1.size();i++){\\n            temp->val = v1[i];\\n            temp = temp->next;\\n        }\\n        for(int i =0; i<v2.size();i++){\\n            temp->val = v2[i];\\n            temp = temp->next;\\n        }\\n        return head;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        vector<int> v1;\\n        vector<int> v2;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            int y = temp->val;\\n            if(y>=x){\\n                v2.push_back(y);\\n            }\\n            else{\\n                v1.push_back(y);\\n            }\\n            temp = temp->next;\\n        }\\n        temp = head;\\n        for(int i =0; i<v1.size();i++){\\n            temp->val = v1[i];\\n            temp = temp->next;\\n        }\\n        for(int i =0; i<v2.size();i++){\\n            temp->val = v2[i];\\n            temp = temp->next;\\n        }\\n        return head;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900084,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe two parts have their own pseudo heads\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\ntypedef struct ListNode List_t;\\n\\nstruct ListNode *partition(struct ListNode *head, int x)\\n{\\n    List_t small, great;\\n    List_t *shead = &small;\\n    List_t *ghead = &great;\\n    List_t *iter = head;\\n\\n    while (iter) {\\n        List_t *tmp = iter;\\n        iter = iter->next;\\n        if (tmp->val < x) {\\n            shead->next = tmp;\\n            shead = shead->next;\\n        }\\n        else {\\n            ghead->next = tmp;\\n            ghead = ghead->next;\\n        }\\n    }\\n    ghead->next = NULL;\\n    shead->next = great.next;\\n    return small.next;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\ntypedef struct ListNode List_t;\\n\\nstruct ListNode *partition(struct ListNode *head, int x)\\n{\\n    List_t small, great;\\n    List_t *shead = &small;\\n    List_t *ghead = &great;\\n    List_t *iter = head;\\n\\n    while (iter) {\\n        List_t *tmp = iter;\\n        iter = iter->next;\\n        if (tmp->val < x) {\\n            shead->next = tmp;\\n            shead = shead->next;\\n        }\\n        else {\\n            ghead->next = tmp;\\n            ghead = ghead->next;\\n        }\\n    }\\n    ghead->next = NULL;\\n    shead->next = great.next;\\n    return small.next;\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2886350,
                "title": "java-one-pass-0-ms-100-easy",
                "content": "## **Please Upvote** :D\\n\\n``` Java []\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if (head == null) {\\n            return head;\\n        }\\n\\n        ListNode less = new ListNode();\\n        ListNode greater = new ListNode();\\n        ListNode lessHead = less, greaterHead = greater;\\n\\n        while (head != null) {\\n            if (head.val < x) {\\n                lessHead.next = head;\\n                lessHead = lessHead.next;\\n            } else {\\n                greaterHead.next = head;\\n                greaterHead = greaterHead.next;\\n            }\\n            head = head.next;\\n        }\\n\\n        lessHead.next = greater.next;\\n        greaterHead.next = null;\\n        return less.next;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` Java []\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if (head == null) {\\n            return head;\\n        }\\n\\n        ListNode less = new ListNode();\\n        ListNode greater = new ListNode();\\n        ListNode lessHead = less, greaterHead = greater;\\n\\n        while (head != null) {\\n            if (head.val < x) {\\n                lessHead.next = head;\\n                lessHead = lessHead.next;\\n            } else {\\n                greaterHead.next = head;\\n                greaterHead = greaterHead.next;\\n            }\\n            head = head.next;\\n        }\\n\\n        lessHead.next = greater.next;\\n        greaterHead.next = null;\\n        return less.next;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694276,
                "title": "java-simple-solution-without-using-dummy-nodes",
                "content": "```\\n public ListNode partition(ListNode head, int x) {\\n        if(head==null || head.next==null) return head;\\n\\t\\t\\n\\t\\t//head1  refers to head of another list with elements greater than x and prev1 refers to its previous node\\n        ListNode curr=head, prev=null, head1=null, prev1=null;\\n        while(curr!=null){\\n            if(curr.val<x){\\n                if(prev==null) {head=curr;prev=curr;}\\n                else{prev.next=curr;\\n                prev=curr;}\\n            }else{\\n                if(head1==null) {head1=curr;prev1=curr;}\\n                else{prev1.next=curr;\\n                prev1=curr;}\\n            }\\n          curr=curr.next;\\n        }\\n        if(prev!=null) prev.next=head1;\\n        if(prev1!=null) prev1.next=null;\\n        return head;\\n```",
                "solutionTags": [],
                "code": "```\\n public ListNode partition(ListNode head, int x) {\\n        if(head==null || head.next==null) return head;\\n\\t\\t\\n\\t\\t//head1  refers to head of another list with elements greater than x and prev1 refers to its previous node\\n        ListNode curr=head, prev=null, head1=null, prev1=null;\\n        while(curr!=null){\\n            if(curr.val<x){\\n                if(prev==null) {head=curr;prev=curr;}\\n                else{prev.next=curr;\\n                prev=curr;}\\n            }else{\\n                if(head1==null) {head1=curr;prev1=curr;}\\n                else{prev1.next=curr;\\n                prev1=curr;}\\n            }\\n          curr=curr.next;\\n        }\\n        if(prev!=null) prev.next=head1;\\n        if(prev1!=null) prev1.next=null;\\n        return head;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2582938,
                "title": "c-solution-partition-list",
                "content": "```\\nclass Solution {\\nprivate:\\n    void insertAtTail(ListNode * &tail , ListNode *curr){\\n        tail->next = curr;\\n        tail = curr;\\n    }\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* lessHead = new ListNode(-1);\\n        ListNode *moreHead = new ListNode(-1);\\n        ListNode *lessTail = lessHead;\\n        ListNode *moreTail = moreHead;\\n        \\n        ListNode *temp = head;\\n        \\n        while(temp != NULL){\\n            if(temp->val < x){\\n                insertAtTail(lessTail , temp);\\n            }\\n            else\\n                insertAtTail(moreTail , temp);\\n            \\n            temp = temp->next;\\n        }\\n        \\n        if(lessHead->next == NULL){\\n            head = moreHead->next;\\n            moreTail->next = NULL;\\n        }\\n        else{\\n            lessTail->next = moreHead->next;\\n            moreTail->next = NULL;\\n            head = lessHead->next;\\n        }\\n        delete(lessHead);\\n        delete(moreHead);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void insertAtTail(ListNode * &tail , ListNode *curr){\\n        tail->next = curr;\\n        tail = curr;\\n    }\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* lessHead = new ListNode(-1);\\n        ListNode *moreHead = new ListNode(-1);\\n        ListNode *lessTail = lessHead;\\n        ListNode *moreTail = moreHead;\\n        \\n        ListNode *temp = head;\\n        \\n        while(temp != NULL){\\n            if(temp->val < x){\\n                insertAtTail(lessTail , temp);\\n            }\\n            else\\n                insertAtTail(moreTail , temp);\\n            \\n            temp = temp->next;\\n        }\\n        \\n        if(lessHead->next == NULL){\\n            head = moreHead->next;\\n            moreTail->next = NULL;\\n        }\\n        else{\\n            lessTail->next = moreHead->next;\\n            moreTail->next = NULL;\\n            head = lessHead->next;\\n        }\\n        delete(lessHead);\\n        delete(moreHead);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535429,
                "title": "c-easy-hai-bro-you-got-this-buddy",
                "content": "class Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        \\n     ListNode* left= new ListNode(0);\\n     ListNode* right= new  ListNode(0);   \\n        \\n      ListNode* lefttail=left;\\n      ListNode* righttail=right;\\n        \\n        while(head!=NULL)\\n        {\\n            if(head->val<x)\\n            {\\n                lefttail->next=head;\\n                lefttail=lefttail->next;\\n                \\n            }\\n            \\n            else\\n            {\\n                righttail->next=head;\\n                righttail=righttail->next;\\n                \\n            }\\n            \\n            head=head->next;\\n        }\\n         righttail->next=NULL;\\n        lefttail->next=right->next;\\n        \\n        return left->next;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        \\n     ListNode* left= new ListNode(0);\\n     ListNode* right= new  ListNode(0);   \\n        \\n      ListNode* lefttail=left;\\n      ListNode* righttail=right;\\n        \\n        while(head!=NULL)\\n        {\\n            if(head->val<x)\\n            {\\n                lefttail->next=head;\\n                lefttail=lefttail->next;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2335492,
                "title": "java-easy-implementation",
                "content": "Approach:\\n* We will take two node left and right and intiate them with zero\\n* The intution here is to iterate the list if the current node value is less than x\\n* Then point the next of left to current and move the left node\\'s pointer\\n* Else point the next or right to current and move the right node\\'s pointer\\n* After the loop we just need to set the end of left node to start of the right node\\n* And the end of the right node to null\\n* And return the next of left (since we initiated the list with zero so return values next to zero)\\n\\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head == null) return null;\\n        \\n        ListNode left = new ListNode(0), tempL = left, right = new ListNode(0), tempR = right;\\n        \\n        while(head != null){\\n            \\n            if(head.val < x){ \\n                tempL.next = head;\\n                tempL = tempL.next;\\n            }\\n            else {\\n                tempR.next = head;\\n                tempR = tempR.next;\\n            }\\n            head = head.next;\\n        }\\n        \\n        tempL.next = right.next;\\n        tempR.next = null;\\n        return left.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        if(head == null) return null;\\n        \\n        ListNode left = new ListNode(0), tempL = left, right = new ListNode(0), tempR = right;\\n        \\n        while(head != null){\\n            \\n            if(head.val < x){ \\n                tempL.next = head;\\n                tempL = tempL.next;\\n            }\\n            else {\\n                tempR.next = head;\\n                tempR = tempR.next;\\n            }\\n            head = head.next;\\n        }\\n        \\n        tempL.next = right.next;\\n        tempR.next = null;\\n        return left.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320042,
                "title": "java-c-solution-explained-tc-o-n-sc-o-1-100",
                "content": "JAVA Solution\\nhttps://leetcode.com/problems/partition-list/discuss/2320001/Java-C%2B%2B-Solution-Explained-TC-O(N)-SC-O(1)-100\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode node1(0) ,node2(0);\\n        ListNode *p1=&node1 ,*p2 =&node2;\\n        \\n        while(head)\\n        {\\n            if(head->val < x)\\n            {\\n                \\n                //p1=p1->next=head; \\n                p1->next=head;\\n                p1=p1->next;\\n            }\\n            else\\n            {\\n                \\n                p2->next=head;\\n                p2=p2->next;\\n            }\\n            head=head->next;\\n        }        \\n        p2->next=NULL;\\n        p1->next=node2.next;;\\n        return node1.next;\\n        \\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode node1(0) ,node2(0);\\n        ListNode *p1=&node1 ,*p2 =&node2;\\n        \\n        while(head)\\n        {\\n            if(head->val < x)\\n            {\\n                \\n                //p1=p1->next=head; \\n                p1->next=head;\\n                p1=p1->next;\\n            }\\n            else\\n            {\\n                \\n                p2->next=head;\\n                p2=p2->next;\\n            }\\n            head=head->next;\\n        }        \\n        p2->next=NULL;\\n        p1->next=node2.next;;\\n        return node1.next;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319304,
                "title": "java-best-solution-possible",
                "content": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n     ListNode less = new ListNode(0);\\n      ListNode greater = new ListNode(0);\\n      ListNode curr1 = less;\\n      ListNode curr2 = greater;\\n      while(head != null) {\\n        if(head.val < x) {\\n          curr1.next = new ListNode(head.val);\\n          curr1 = curr1.next;\\n        }\\n        else {\\n          curr2.next = new ListNode(head.val);\\n          curr2 = curr2.next;\\n        }\\n        head = head.next;\\n      }\\n      curr1.next = greater.next;\\n      return less.next;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n     ListNode less = new ListNode(0);\\n      ListNode greater = new ListNode(0);\\n      ListNode curr1 = less;\\n      ListNode curr2 = greater;\\n      while(head != null) {\\n        if(head.val < x) {\\n          curr1.next = new ListNode(head.val);\\n          curr1 = curr1.next;\\n        }\\n        else {\\n          curr2.next = new ListNode(head.val);\\n          curr2 = curr2.next;\\n        }\\n        head = head.next;\\n      }\\n      curr1.next = greater.next;\\n      return less.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317462,
                "title": "easy-understanding-c-solution-with-explanation",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if(!head) return nullptr;\\n        ListNode *fast = head,*slow = nullptr;\\n        \\n        // Find first greater element.\\n        \\n        while(fast)\\n        {\\n            if(fast->val >= x) break;\\n            slow = fast;\\n            fast = fast->next;\\n        }\\n        \\n        // If no greater element return head.\\n        \\n        if(!fast) return head;\\n        \\n        // Start from greater elemnts next and traverse the full list.\\n        \\n        ListNode *temp = fast->next,*slow1 = fast,*ans;\\n        \\n        int flag = 0;\\n        \\n        while(temp)\\n        {\\n            if(temp->val >= x)          // If not a smaller element just skip.\\n            {\\n                slow1 = temp;\\n                temp = temp->next;\\n            }\\n            else\\n            { \\n                slow1->next = temp->next;     //Break\\n                ListNode* copy = temp;        //The \\n                copy->next = fast;            //Link of smaller elements\\n                temp = temp -> next;          // with it\\'s preducesor and successor\\n                \\n                if(!slow)           //If first element is greater\\n                {\\n                    slow = copy;\\n                    ans = slow;\\n                    flag = 1;\\n                }\\n                else\\n                {\\n                    copy->next = slow->next;\\n                    slow->next = copy;\\n                    slow = copy;\\n                }\\n            }\\n        }\\n        return flag==0?head:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        if(!head) return nullptr;\\n        ListNode *fast = head,*slow = nullptr;\\n        \\n        // Find first greater element.\\n        \\n        while(fast)\\n        {\\n            if(fast->val >= x) break;\\n            slow = fast;\\n            fast = fast->next;\\n        }\\n        \\n        // If no greater element return head.\\n        \\n        if(!fast) return head;\\n        \\n        // Start from greater elemnts next and traverse the full list.\\n        \\n        ListNode *temp = fast->next,*slow1 = fast,*ans;\\n        \\n        int flag = 0;\\n        \\n        while(temp)\\n        {\\n            if(temp->val >= x)          // If not a smaller element just skip.\\n            {\\n                slow1 = temp;\\n                temp = temp->next;\\n            }\\n            else\\n            { \\n                slow1->next = temp->next;     //Break\\n                ListNode* copy = temp;        //The \\n                copy->next = fast;            //Link of smaller elements\\n                temp = temp -> next;          // with it\\'s preducesor and successor\\n                \\n                if(!slow)           //If first element is greater\\n                {\\n                    slow = copy;\\n                    ans = slow;\\n                    flag = 1;\\n                }\\n                else\\n                {\\n                    copy->next = slow->next;\\n                    slow->next = copy;\\n                    slow = copy;\\n                }\\n            }\\n        }\\n        return flag==0?head:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316951,
                "title": "faster-solution-8ms-c-detailed-explanation",
                "content": "I have tried to approach the problem by the following approach :(though i know its a noob approach but still, i think we should think in all possible directions)\\n\\nso what i have did is... first of all i have declared two vector.. one having values greater than or equal to x and the other one is storing the value smaller than x.\\nAfter that i am reversing both vectors so that i can get the values in original order.\\nThen i\\'m traversing the linked list and modifying the values from smaller to greater one.\\n\\n/**********/\\n\\noriginal : 1 - 4 - 3 - 2 - 5 - 2\\ngreater : (5 3 4)\\nsmaller(2 2 1)\\nAfter reversing :\\ngreater : (4 3 5)\\nsmaller : (1 2 2)\\nNow modifying the linked list values\\n\\nnew : 1 - 2 - 2 - 4 - 3 - 5\\n\\nBut this solution will give you MEMORY LIMIT EXCEEDED !\\nDon\\'t spam that this is a noob approach and all...i\\'m just trying to share what i have thinked so that if any beginner is reading this then he/she will get a clear idea how things work.\\n\\nBelow, i have attached the efficient solution that beats around 50% of the CPP submissions...if you can optimise it more then share it.\\n\\nHappy Learning guys !!!\\n\\n/-------CODE ----------/\\n\\nclass Solution {\\npublic:\\nListNode partition(ListNode* head, int x) {\\n\\n/*Approach 1 : Make 2 vectors.. one having values greater than or equal to x\\nand other having values less than x. Now reverse the both vectors\\nand modify the value of the linked list correspondingly */\\n// MEMORY LIMIT EXCEEDED problem !!\\n// ListNode *temp1 = head,*temp2 = head;\\n// int size=0;\\n// ListNode *trav = head;\\n// while(trav !=NULL) {\\n// trav = trav->next;\\n// size++;\\n// }\\n\\n// vector smaller,greater;\\n\\n// while(temp1 !=NULL) {\\n// if(temp1->val >= x ) greater.pb(temp1->val);\\n// else smaller.pb(temp1->val);\\n// }\\n// reverse(beg2end(smaller));\\n// reverse(beg2end(greater));\\n\\n// loop(i,0,smaller.size()) {\\n// temp2->val = smaller[i];\\n// temp2 = temp2->next;\\n// }\\n// loop(i,0,greater.size()) {\\n// temp2->val = greater[i];\\n// temp2 = temp2->next;\\n// }\\n// return head;\\n\\n/*Approach 2 : Make 2 new linked lists, one with values greater than equal to x\\n               and other having values smaller than x;\\n               Now add the last point of smaller linked list to the head of the \\n               greater linked list.\\n*/\\n\\nListNode *greater = new ListNode(0);\\nListNode *smaller = new ListNode(0);\\n\\nListNode *storegreater = greater, *storesmaller = smaller;\\n\\nListNode *temp = head;\\nwhile(temp!=NULL) {\\n    if(temp->val >= x) {\\n       greater->next = temp;\\n       greater = greater->next;\\n    }\\n    else {\\n        smaller->next = temp;\\n        smaller = smaller->next;\\n    }\\n    temp = temp->next;\\n}\\n\\nsmaller->next = storegreater->next; \\ngreater->next = NULL;\\n\\n\\nreturn storesmaller->next;\\n}\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\nListNode partition(ListNode* head, int x) {\\n\\n/*Approach 1 : Make 2 vectors.. one having values greater than or equal to x\\nand other having values less than x. Now reverse the both vectors\\nand modify the value of the linked list correspondingly */\\n// MEMORY LIMIT EXCEEDED problem !!\\n// ListNode *temp1 = head,*temp2 = head;\\n// int size=0;\\n// ListNode *trav = head;\\n// while(trav !=NULL) {\\n// trav = trav->next;\\n// size++;\\n// }",
                "codeTag": "Java"
            },
            {
                "id": 2316332,
                "title": "java-easy-fast-small-iterative-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Partition List.\\nMemory Usage: 43.2 MB, less than 9.67% of Java online submissions for Partition List.\\n```\\nclass Solution {\\n  public ListNode partition(ListNode head, int x) {\\n    ListNode less = new ListNode(), grea = new ListNode();\\n    ListNode ans = less, fh = grea;\\n    \\n    for(; head != null; head = head.next)\\n      if(head.val < x) less = less.next = head;\\n      else             grea = grea.next = head;\\n    \\n    less.next = fh.next;\\n    grea.next = null;\\n    return ans.next;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public ListNode partition(ListNode head, int x) {\\n    ListNode less = new ListNode(), grea = new ListNode();\\n    ListNode ans = less, fh = grea;\\n    \\n    for(; head != null; head = head.next)\\n      if(head.val < x) less = less.next = head;\\n      else             grea = grea.next = head;\\n    \\n    less.next = fh.next;\\n    grea.next = null;\\n    return ans.next;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315786,
                "title": "java-easy-to-understand",
                "content": "In order to solve the given problem we can declare two ListNode left and right and have two pointer nodes h1 and h2 pointing to left and right respectively. Now we will traverse through the given linked list and check if head.val<x put head in h1.next and then point h1 and head  to next. Similar steps to be followed with h2 when head.val>=x.\\n \\n![image](https://assets.leetcode.com/users/images/449f1a91-718f-4aaf-b355-7fbb8a75bb99_1658463139.474912.png)\\n\\nNow if we consider the above shown example and try our logic we observe that \\n\\n*if(head.val<x)*\\n*  h1=left\\n*  left->1=h1\\n*  left->1->2=h1\\n*  left->1->2->2=h1\\n\\n*else* \\n* h2=right\\n* right->4 = h2\\n* right->4->3 = h2\\n* right->4->3->5 = h2\\n\\nNow we have two linked lists as follows:\\n**[left,1,2,2] and [right,4,3,5]**\\n\\nonly steps left are to connect them as follows \\n* h1.next = right.next ( Now list will be [left,1,2,2,4,3,5] )\\n* But a linkedlist ends with a null so we need to do h2.next=null\\n\\nWith this we have successfully done the required operation on Linked List given.\\n### *The code is as follows:*\\n```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        \\n        //case when list is null or only one node \\n        if(head==null || head.next==null) return head;\\n        \\n        ListNode left = new ListNode();\\n        ListNode h1 = left;\\n        \\n        ListNode right = new ListNode();\\n        ListNode h2 = right;\\n        \\n        while(head!=null){\\n            \\n            //when node val is less than x\\n            if(head.val<x){\\n                h1.next=head;\\n                head=head.next;\\n                h1=h1.next;\\n            }\\n            \\n            //when node val is greater or equal to x\\n             else{\\n                h2.next=head;\\n                head=head.next;\\n                h2=h2.next;\\n            }\\n            \\n        }\\n        \\n        //connecting the right and left lists\\n        h1.next=right.next;\\n        h2.next=null;\\n        \\n        return left.next;\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        \\n        //case when list is null or only one node \\n        if(head==null || head.next==null) return head;\\n        \\n        ListNode left = new ListNode();\\n        ListNode h1 = left;\\n        \\n        ListNode right = new ListNode();\\n        ListNode h2 = right;\\n        \\n        while(head!=null){\\n            \\n            //when node val is less than x\\n            if(head.val<x){\\n                h1.next=head;\\n                head=head.next;\\n                h1=h1.next;\\n            }\\n            \\n            //when node val is greater or equal to x\\n             else{\\n                h2.next=head;\\n                head=head.next;\\n                h2=h2.next;\\n            }\\n            \\n        }\\n        \\n        //connecting the right and left lists\\n        h1.next=right.next;\\n        h2.next=null;\\n        \\n        return left.next;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315500,
                "title": "javascript-beats-80-memory-o-n",
                "content": "This is very easy problem to solve.\\n\\n**There can 2 approaches:**\\n**Approach 1 - o(n) and use 2 extra pointers**\\n1. Iterate through the list once, take out node, append it in `less` list, otherwise in `greater` list. \\n2. Later before returning, connect them\\n```\\nvar partition = function(head, x) {\\n    \\n    let ptr = head;\\n    let less = new ListNode();\\n    let greater = new ListNode();\\n    const startPtrOfLess = less;\\n    const startPtrOfGreater = greater;\\n    let basePtr;\\n    \\n    let nextPtr;\\n    \\n    while(ptr) {        \\n        nextPtr = ptr.next;\\n        \\n        if (ptr.val < x) {\\n            less.next = ptr;            \\n            less = ptr;\\n        } else {\\n            greater.next = ptr;           \\n            greater = ptr;\\n        }\\n        \\n        ptr.next = null;\\n        ptr = nextPtr;\\n    }\\n    \\n    less.next = startPtrOfGreater.next;\\n    \\n    return startPtrOfLess.next;\\n};\\n```\\n\\n**Approach 2 - Run the n loop twice, use an arrary to separate and merge**\\n1. Filter out nodes in 2 separate list\\n2. Merge those list. Make sure smaller nodes appear first.\\n3. Iterate through merged list, and update the next pointer.... simple :)\\n4. Make sure the last node is set to null to avoid cyclic reference. \\n\\n```\\nvar partition = function(head, x) {\\n    \\n    let ptr = head;\\n    let less = [];\\n    let greater = [];\\n    let basePtr;\\n    \\n    while(ptr) {\\n        if (ptr.val < x) {\\n            less.push(ptr);\\n        } else {\\n            greater.push(ptr);\\n        }\\n        \\n        ptr = ptr.next;\\n    }\\n    \\n    const final = [...less, ...greater];\\n    \\n    for(let i = 1; i < final.length; i++) {\\n        final[i - 1].next = final[i];\\n    }    \\n    \\n    const lastNode = final.at(-1);\\n    \\n    if (lastNode) {\\n        lastNode.next = null;\\n    }\\n    \\n    return final.at(0) || null;\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nvar partition = function(head, x) {\\n    \\n    let ptr = head;\\n    let less = new ListNode();\\n    let greater = new ListNode();\\n    const startPtrOfLess = less;\\n    const startPtrOfGreater = greater;\\n    let basePtr;\\n    \\n    let nextPtr;\\n    \\n    while(ptr) {        \\n        nextPtr = ptr.next;\\n        \\n        if (ptr.val < x) {\\n            less.next = ptr;            \\n            less = ptr;\\n        } else {\\n            greater.next = ptr;           \\n            greater = ptr;\\n        }\\n        \\n        ptr.next = null;\\n        ptr = nextPtr;\\n    }\\n    \\n    less.next = startPtrOfGreater.next;\\n    \\n    return startPtrOfLess.next;\\n};\\n```\n```\\nvar partition = function(head, x) {\\n    \\n    let ptr = head;\\n    let less = [];\\n    let greater = [];\\n    let basePtr;\\n    \\n    while(ptr) {\\n        if (ptr.val < x) {\\n            less.push(ptr);\\n        } else {\\n            greater.push(ptr);\\n        }\\n        \\n        ptr = ptr.next;\\n    }\\n    \\n    const final = [...less, ...greater];\\n    \\n    for(let i = 1; i < final.length; i++) {\\n        final[i - 1].next = final[i];\\n    }    \\n    \\n    const lastNode = final.at(-1);\\n    \\n    if (lastNode) {\\n        lastNode.next = null;\\n    }\\n    \\n    return final.at(0) || null;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2315384,
                "title": "c-two-pointers-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* small = new ListNode(0);\\n        ListNode* great = new ListNode(0);\\n        \\n        ListNode* smalltail  = small;\\n        ListNode* greattail = great;\\n        \\n        while(head!=NULL){\\n            if(head->val < x){\\n                smalltail->next = head;\\n                smalltail = smalltail->next;\\n            }\\n            else{\\n                greattail->next = head;\\n                greattail = greattail->next;\\n            }\\n            head = head -> next;\\n        }\\n        greattail->next = NULL;\\n        smalltail->next = great->next;\\n        \\n        return small->next;\\n    }\\n};\\n```\\n\\n# ****Please Upvote\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode* small = new ListNode(0);\\n        ListNode* great = new ListNode(0);\\n        \\n        ListNode* smalltail  = small;\\n        ListNode* greattail = great;\\n        \\n        while(head!=NULL){\\n            if(head->val < x){\\n                smalltail->next = head;\\n                smalltail = smalltail->next;\\n            }\\n            else{\\n                greattail->next = head;\\n                greattail = greattail->next;\\n            }\\n            head = head -> next;\\n        }\\n        greattail->next = NULL;\\n        smalltail->next = great->next;\\n        \\n        return small->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315357,
                "title": "easy-to-understand-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode*dummy=new ListNode(-1);\\n        ListNode*s=dummy;\\n        ListNode*dummy2=new ListNode(-1);\\n        ListNode*l=dummy2;\\n        while(head!=NULL)\\n        {\\n            if(head->val<x)\\n            {\\n                s->next=head;\\n                s=s->next;\\n            }\\n            else\\n            {\\n                l->next=head;\\n                l=l->next; \\n            }\\n            head =head->next;\\n        }\\n        l->next=NULL;\\n        s->next=dummy2->next;\\n        return dummy->next;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode*dummy=new ListNode(-1);\\n        ListNode*s=dummy;\\n        ListNode*dummy2=new ListNode(-1);\\n        ListNode*l=dummy2;\\n        while(head!=NULL)\\n        {\\n            if(head->val<x)\\n            {\\n                s->next=head;\\n                s=s->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2315342,
                "title": "c-iterative-approach-o-n-time-complexity",
                "content": "\\t// in this approach we create 2 independent lists and connect them after traversing all the nodes, just simple logic and linkedlist traversal gives us the appropriate solution\\n\\t\\tListNode* partition(ListNode* head, int x) {\\n\\t\\t\\tif(head == NULL or head->next == NULL) return head;\\n\\t\\t\\tListNode *partition1 = new ListNode(0); //smaller than x\\n\\t\\t\\tListNode *partition2 = new ListNode(0); // greater than or equal to x\\n\\t\\t\\tListNode *iterator1 = partition1;        \\n\\t\\t\\tListNode *iterator2 = partition2;\\n\\t\\t\\tListNode *temp = head;\\n\\t\\t\\twhile(temp!=NULL){\\n\\t\\t\\t\\tif(temp->val < x){\\n\\t\\t\\t\\t\\titerator1->next = new ListNode(temp->val);\\n\\t\\t\\t\\t\\titerator1 = iterator1->next;\\n\\t\\t\\t\\t}else if(temp->val >= x){\\n\\t\\t\\t\\t\\titerator2->next = new ListNode(temp->val);\\n\\t\\t\\t\\t\\titerator2 = iterator2->next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttemp = temp->next;\\n\\t\\t\\t}\\n\\t\\t\\t// connect end of partition1 to start of partition2\\n\\t\\t\\titerator1->next = partition2->next;\\n\\t\\t\\treturn partition1->next;\\n\\t\\t}",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "\\t// in this approach we create 2 independent lists and connect them after traversing all the nodes, just simple logic and linkedlist traversal gives us the appropriate solution\\n\\t\\tListNode* partition(ListNode* head, int x) {\\n\\t\\t\\tif(head == NULL or head->next == NULL) return head;\\n\\t\\t\\tListNode *partition1 = new ListNode(0); //smaller than x\\n\\t\\t\\tListNode *partition2 = new ListNode(0); // greater than or equal to x\\n\\t\\t\\tListNode *iterator1 = partition1;        \\n\\t\\t\\tListNode *iterator2 = partition2;\\n\\t\\t\\tListNode *temp = head;\\n\\t\\t\\twhile(temp!=NULL){\\n\\t\\t\\t\\tif(temp->val < x){\\n\\t\\t\\t\\t\\titerator1->next = new ListNode(temp->val);\\n\\t\\t\\t\\t\\titerator1 = iterator1->next;\\n\\t\\t\\t\\t}else if(temp->val >= x){\\n\\t\\t\\t\\t\\titerator2->next = new ListNode(temp->val);\\n\\t\\t\\t\\t\\titerator2 = iterator2->next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttemp = temp->next;\\n\\t\\t\\t}\\n\\t\\t\\t// connect end of partition1 to start of partition2\\n\\t\\t\\titerator1->next = partition2->next;\\n\\t\\t\\treturn partition1->next;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2255105,
                "title": "java-solution-tc-o-n-sc-o-1-100-faster",
                "content": "/* Please upvote if you find it helpful. It will encourage me too help you guys. Happy Coding!\\n\\nIn this question, we need to partition a linked list such that all nodes less than x come before nodes greater than or equal to x.\\nNow what does that mean, this means that relative order of linked list should not be lost and to be preserved and how do we maintain that!\\n\\nSuppose, Input : 1 --> 4 --> 3 --> 2 --> 5 --> 2, x = 3\\nOutput :  1 --> 2 --> 2 --> 4 --> 3 --> 5.\\n***In this we can clearly see that 1 is coming before 2 and less than x so they are in their order. But 4 is greater than equal to 3 and first thing that will come in our mind that output should be of this order 1 --> 2 --> 2 --> 3 --> 4 --> 5 but we should not forget about the point \"all nodes less than x come before nodes greater than or equal to x.\"***\\n\\n***And their relative order should not be disturbed, hence the output is : 1 --> 2 --> 2 --> 4 --> 3 --> 5, in this 4 is coming before 3 and it doesn\\'t matter if it is greater than equal to 3 or not but they are in their relative order in which they should be.***\\n\\nNow comes to the solution, how to approach this problem.\\n\\nTo approach this problem, we can think our output as two different lists one with nodes less than x and other list with nodes greater than equal to x with their relative order.\\n\\nWe will take list1 as \"**smaller**\" and list2 as \"**higher**\", one for nodes less than x and other for nodes greater than equal to x and in order maintain these lists we also need their heads so we take \"**smallerHead**\" and \"**higherHead**\" variables which will point to smaller and higher respectively. In this end we need to concatenate these two lists.\\nThen we will traverse through the given head and check the condition within it and add our smallerHead and higherHead according to conditions. At the end our smallerHead will point to last of smaller list and higherHead will point to end of higher list.\\n\\nIn order to concatenate them, we will do **smallerHead.next = higher** and as we know that in our linked list last node should point to null and as we know in this our last node will be higherHead which will be in the end of higher list so we will do **higherHead.next = null**. And finally we return the head of concatenated list by doing **smalller.next** because smaller.next will be pointing to the first node of concatenated list.\\n*/\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode smaller = new ListNode(0);\\n        ListNode higher = new ListNode(0);\\n        \\n        ListNode smallerHead = smaller;\\n        ListNode higherHead = higher;\\n        \\n        while (head != null) {\\n            if (head.val < x) {\\n                // smaller list\\n                smallerHead.next = head;\\n                smallerHead = smallerHead.next;\\n            } else {\\n                // higher list\\n                higherHead.next = head;\\n                higherHead = higherHead.next;\\n            }\\n            head = head.next;\\n        }\\n        \\n        smallerHead.next = higher.next;\\n        higherHead.next = null;\\n        \\n        return smaller.next;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode smaller = new ListNode(0);\\n        ListNode higher = new ListNode(0);\\n        \\n        ListNode smallerHead = smaller;\\n        ListNode higherHead = higher;\\n        \\n        while (head != null) {\\n            if (head.val < x) {\\n                // smaller list\\n                smallerHead.next = head;\\n                smallerHead = smallerHead.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2250164,
                "title": "c-implementation-using-map-explanation",
                "content": "1. First of all I am making a new linked list (dummy), then I am placing the prev node on dummy\\'s head.\\n2. Then I am keeping a curr pointer on the head of original linked list.\\n3. Then I am traversing through the original linked list and checking which node\\'s value is less than \\'x\\', if I found an element less than \\'x\\', I make a new temp node with that curr\\'s value, the I will connect prev->next (prev is on the dummy\\'s head) to temp node, then I will move prev pointer to the new temp\\'s node, I will also store curr\\'s value in a map.\\n4. Then in the second while loop i am traversing once again through the original Linked List and checking if the curr node\\'s element is present in the map, and if is not present, make a new node temp and connect prev\\'s next to temp.\\n5. Then I am returning dummy\\'s next.\\n6. Dry run the code for better understanding.\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        \\n        if(head==NULL)return head;\\n        \\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* prev = dummy;  //1st point\\n        ListNode* curr = head;  //2nd point\\n        unordered_map<int, int> m;\\n        while(curr){\\n            \\n            if(curr->val<x){     //3rd point\\n                ListNode* temp = new ListNode(curr->val);\\n                m[curr->val]++;\\n                prev->next = temp;\\n                prev = temp;\\n            }\\n            \\n            curr = curr->next;\\n            \\n        }\\n        curr=head;\\n        while(curr){\\n            \\n            if(m.find(curr->val)==m.end()){   //4th point\\n                ListNode* temp = new ListNode(curr->val);\\n                prev->next = temp;\\n                prev = temp;\\n            }\\n            curr = curr->next;\\n        }\\n        return dummy->next;         //5th point\\n    } \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        \\n        if(head==NULL)return head;\\n        \\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* prev = dummy;  //1st point\\n        ListNode* curr = head;  //2nd point\\n        unordered_map<int, int> m;\\n        while(curr){\\n            \\n            if(curr->val<x){     //3rd point\\n                ListNode* temp = new ListNode(curr->val);\\n                m[curr->val]++;\\n                prev->next = temp;\\n                prev = temp;\\n            }\\n            \\n            curr = curr->next;\\n            \\n        }\\n        curr=head;\\n        while(curr){\\n            \\n            if(m.find(curr->val)==m.end()){   //4th point\\n                ListNode* temp = new ListNode(curr->val);\\n                prev->next = temp;\\n                prev = temp;\\n            }\\n            curr = curr->next;\\n        }\\n        return dummy->next;         //5th point\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128797,
                "title": "c-solution-using-stack",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        queue<ListNode*>s;\\n        ListNode*prev=new ListNode(0),*p=head,*dummy=prev;\\n        while(p){\\n            if(p->val<x){\\n                prev->next=p;\\n                prev=p;\\n            }\\n            else{\\n                s.push(p);\\n            }\\n            \\n            p=p->next;\\n        }\\n                while(!s.empty()){\\n                    cout<<s.front()->val<<s.size()<<endl;\\n                    prev->next=s.front();\\n                    prev=prev->next;\\n                    s.pop();\\n                }\\n        prev->next=nullptr;\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        queue<ListNode*>s;\\n        ListNode*prev=new ListNode(0),*p=head,*dummy=prev;\\n        while(p){\\n            if(p->val<x){\\n                prev->next=p;\\n                prev=p;\\n            }\\n            else{\\n                s.push(p);\\n            }\\n            \\n            p=p->next;\\n        }\\n                while(!s.empty()){\\n                    cout<<s.front()->val<<s.size()<<endl;\\n                    prev->next=s.front();\\n                    prev=prev->next;\\n                    s.pop();\\n                }\\n        prev->next=nullptr;\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1963214,
                "title": "c-o-1-space-complexity-and-o-n-time-complexity",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        \\n        ListNode *leftNode=new ListNode(0);\\n        ListNode *leftHead=leftNode;\\n        ListNode *rightNode=new ListNode(0);\\n        ListNode *rightHead=rightNode;\\n        ListNode *temp=head;\\n        \\n        while(temp!=NULL){\\n            if(temp->val<x){\\n               leftNode->next=temp;\\n                leftNode=leftNode->next;\\n            }\\n            else{\\n                rightNode->next=temp;\\n                rightNode=rightNode->next;  \\n            }\\n            temp=temp->next;\\n        }\\n        rightNode->next=NULL;\\n        leftNode->next=rightHead->next;\\n        \\n        return leftHead->next;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        \\n        ListNode *leftNode=new ListNode(0);\\n        ListNode *leftHead=leftNode;\\n        ListNode *rightNode=new ListNode(0);\\n        ListNode *rightHead=rightNode;\\n        ListNode *temp=head;\\n        \\n        while(temp!=NULL){\\n            if(temp->val<x){\\n               leftNode->next=temp;\\n                leftNode=leftNode->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1932533,
                "title": "java-100-faster",
                "content": "class Solution {\\n    public ListNode partition(ListNode head, int x) {\\n     ListNode before_head = new ListNode(0);\\n     ListNode before  = before_head;\\n     ListNode after_head = new ListNode(0);\\n     ListNode after  = after_head;   \\n        \\n        while(head!= null){\\n            if(head.val <x){\\n              before.next = head;\\n              before = before.next;  \\n            }else{\\n                after.next = head;\\n                after = after.next; \\n            }\\n            head= head.next;\\n        }\\n        after.next = null;\\n        before.next = after_head.next;\\n        \\n        return before_head.next;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public ListNode partition(ListNode head, int x) {\\n     ListNode before_head = new ListNode(0);\\n     ListNode before  = before_head;\\n     ListNode after_head = new ListNode(0);\\n     ListNode after  = after_head;   \\n        \\n        while(head!= null){\\n            if(head.val <x){\\n              before.next = head;\\n              before = before.next;  \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1820349,
                "title": "100-faster-java-solution-0ms-solution",
                "content": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode before_head= new ListNode(0);\\n        ListNode before= before_head;\\n        ListNode after_head= new ListNode(0);\\n        ListNode after= after_head;\\n        \\n        while(head!=null){\\n            if(head.val< x){\\n                before.next= head;\\n                before= before.next;\\n            }\\n            else{\\n                after.next= head;\\n                after= after.next;\\n            }\\n            head= head.next;\\n        }\\n        after.next=null;\\n        before.next= after_head.next;\\n        return before_head.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode partition(ListNode head, int x) {\\n        ListNode before_head= new ListNode(0);\\n        ListNode before= before_head;\\n        ListNode after_head= new ListNode(0);\\n        ListNode after= after_head;\\n        \\n        while(head!=null){\\n            if(head.val< x){\\n                before.next= head;\\n                before= before.next;\\n            }\\n            else{\\n                after.next= head;\\n                after= after.next;\\n            }\\n            head= head.next;\\n        }\\n        after.next=null;\\n        before.next= after_head.next;\\n        return before_head.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770086,
                "title": "partition-list-solution-java",
                "content": "class Solution {\\n  public ListNode partition(ListNode head, int x) {\\n    ListNode beforeHead = new ListNode(0);\\n    ListNode afterHead = new ListNode(0);\\n    ListNode before = beforeHead;\\n    ListNode after = afterHead;\\n\\n    for (; head != null; head = head.next)\\n      if (head.val < x) {\\n        before.next = head;\\n        before = head;\\n      } else {\\n        after.next = head;\\n        after = head;\\n      }\\n\\n    after.next = null;\\n    before.next = afterHead.next;\\n\\n    return beforeHead.next;\\n  }\\n}\\n",
                "solutionTags": [
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n  public ListNode partition(ListNode head, int x) {\\n    ListNode beforeHead = new ListNode(0);\\n    ListNode afterHead = new ListNode(0);\\n    ListNode before = beforeHead;\\n    ListNode after = afterHead;\\n\\n    for (; head != null; head = head.next)\\n      if (head.val < x) {\\n        before.next = head;\\n        before = head;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1528469,
                "title": "c-solution-two-pointers-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *node1 = new ListNode();\\n        ListNode *node2 = new ListNode();\\n        \\n        ListNode *ptr1 = node1;\\n        ListNode *ptr2 = node2;\\n        \\n        while(head){\\n            if(head->val < x){\\n                node1->next = head;\\n                node1 = node1->next;\\n            }\\n            else{\\n                node2->next = head;\\n                node2 = node2->next;\\n            }\\n            \\n            head = head->next;\\n        }\\n        \\n        node2->next = NULL;\\n        node1->next = ptr2->next;\\n        \\n        return ptr1->next;\\n    }\\n};\\n```\\n\\n**UPVOTE this solution, if you find it useful.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *node1 = new ListNode();\\n        ListNode *node2 = new ListNode();\\n        \\n        ListNode *ptr1 = node1;\\n        ListNode *ptr2 = node2;\\n        \\n        while(head){\\n            if(head->val < x){\\n                node1->next = head;\\n                node1 = node1->next;\\n            }\\n            else{\\n                node2->next = head;\\n                node2 = node2->next;\\n            }\\n            \\n            head = head->next;\\n        }\\n        \\n        node2->next = NULL;\\n        node1->next = ptr2->next;\\n        \\n        return ptr1->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565050,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 2014762,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1564789,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1750971,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 2014581,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 2014671,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1570330,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1568102,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1570499,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1574465,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1565050,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 2014762,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1564789,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1750971,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 2014581,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 2014671,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1570330,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1568102,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1570499,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 1574465,
                "content": [
                    {
                        "username": "zdf826504558",
                        "content": "The description for this problem is somewhat very misleading. \\nI took at least 15 min and tested serval test cases so that I understood what it was asking for.\\n\\nLet me briefly explain it to relieve your pain.\\n\\nBasically, it asks us:\\n`reorder the sequence by the given number x`\\n\\nThe rules are:\\n1. Any number that is `less than x` has to be before `x`, and maintain the relative order with thoese that are less than `x` but already before `x`.\\ne.g. `[3,4,1,2], target = 4` -> `[3,1,2,4]`, so the order of `[3,1,2]` is maintained.\\n2. Any number that is `greater than x` but already before `x` will still be before `x`, but all of them come after those that are less than `x` and at the same time maintain their relative order.\\ne.g. `[3,6,5,4,1,2] target = 4` -> `[3,1,2,6,5,4]`\\n3. Any number that is `greater than x` and after `x` will only need to maintain their relative order\\ne.g. `[3,6,5,4,8,1,7,2] target = 4` -> `[3,1,2,6,5,4,8,7]`\\n\\nHope this helps those who have a difficulty time understanding **\"all nodes less than x come before nodes greater than or equal to x.\"** like me.  \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n"
                    },
                    {
                        "username": "kishore_001",
                        "content": "[@The_Laughing_Storm](/The_Laughing_Storm)  i understand the question now"
                    },
                    {
                        "username": "ahad7792",
                        "content": "Maximum leetcode  question\\'s description is very unclear"
                    },
                    {
                        "username": "pavan9100",
                        "content": "Haha!...They explained about the place and you explained about the directions"
                    },
                    {
                        "username": "dporwal985",
                        "content": "I was confused for a second and got into the discussion section about that particular line. Seeing your detailed discussion helped. Thanks man!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "[@diksm0ker](/diksm0ker) if relative order was important then in first test case \\nInput: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\nwhy the output is not 1,4,2,2,3,5. the relative order got changed for 2 and 4 in the description\\'s output"
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "[@normanlmfung](/normanlmfung) Relative order means that the orignal order given. So in [3,4,1,2] the order is 3->4->1->2 so after target is 4 the order should be 3->1->2->4 because in the orignal order 3 was before 1 and 1 was before 2. Relative order means wrt to the question. These are linked lists here not arrays so order here is wierd"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "It's still unclear [3,4,1,2], target = 4 -> [3,1,2,4] \n\nWhy not \n     [1,2,3,4]? <-- 1 appear before 2 so \"relative order\" still maintained\nor even \n    [1,3,2,4] <-- same here, 1 apear before 2 and \"relative order\" still maintained.\n\nAnother example,\n    [3,6,5,4,1,2] target = 4 -> [3,1,2,6,5,4]\n\n    Why not \n        [1,2,3,6,5,4]           <-- \"preserve the original relative order of the nodes in each of the two partitions\" does not explains why 1,2 should appear after 3\n        [3,6,5,1,2,4]           <-- \"all nodes less than x come before nodes greater than or equal to x\" explains why 1,2 should appear BEFORE 6,5 so this is fine\n\nQuestion poorly written. So I think developers are expected to try different test cases to understand pick up things that's not specified in problem statement."
                    },
                    {
                        "username": "comanea",
                        "content": "You understood that statement correctly. The description adds right below `You should preserve the original relative order of the nodes in each of the two partitions.`. If that wasn\\'t there when you wrote the comment, then that\\'s on the problem maker, but it looks correct now. Fortunately it\\'s an easy fix anyway."
                    },
                    {
                        "username": "Jaiff",
                        "content": "Happy Independence Day Indian bros. \\nWe live young, \\nWe live free!!!"
                    },
                    {
                        "username": "vinnnu",
                        "content": "Jai Hind!!! Onwards and Upwards"
                    },
                    {
                        "username": "ckvb18",
                        "content": "YES GLORY TO INDIA !!!"
                    },
                    {
                        "username": "codewithnavneet",
                        "content": "Happy independence day brother JAY HIND"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "same to u bro Jai Hind "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "jai hind"
                    },
                    {
                        "username": "kandalachetan",
                        "content": "same to you bro"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "JAI HIND! upwards and onwards, always!"
                    },
                    {
                        "username": "homer_simpson",
                        "content": "\"For example,\\n\\nGiven 1->4->3->2->5->2 and x = 3,\\n\\nreturn 1->2->2->4->3->5.\"\\n\\nIn the return, why does 4 come before 3 if it's larger???\\n\\n\\nAlso, my code fails this test:\\n\"Input:\\t{2,1}, 1\\n\\nOutput:\\t{1,2}\\n\\nExpected:\\t{2,1}\"\\n\\nIf x is 1, why would the expected output have 2 come before 1?\\n\\nThanks."
                    },
                    {
                        "username": "rahulkasula23",
                        "content": "bro I done this question 8 years after your submission"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No, no sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "powerup7",
                        "content": "[@Anand_On_Leet](/Anand_On_Leet) No. No sorting of the list is required. That\\'s how you keep relative order."
                    },
                    {
                        "username": "brb715",
                        "content": "In the first eg, since 4 is greater than or equal to 3(i.e x), all the nodes that are less than 3 will come before 4 and the order of the nodes should be same."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes thankfully they covered that case in the examples, right?\n\n4 comes before 3 because relative order must be preserved.\n\n3 doesn't require being moved because it is >= x.\n\nhope that wasn't too much of a spoiler."
                    },
                    {
                        "username": "Anand_On_Leet",
                        "content": "Then , we should only sort that list."
                    },
                    {
                        "username": "1ort",
                        "content": "tip: Don\\'t forget to clear the Next of the last element of the list if you are spreading elements across two lists. I tried for half an hour to figure out why my solution fails with an error until I realized that I was returning a list with a loop"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Divide the given list head into 2 linked lists, greater & smaller. Then connect these 2 lists and return the result. One more hint:\nThe whole process shown by modifying submitted code in playground\n```\n1<3:smaller\nsmaller:0->1->4->3->2->5->2\ngreater:0\n-------\n4>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n3>=3: greater\nsmaller:0->1->4->3->2->5->2\ngreater:0->4->3->2->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->5->2\ngreater:0->4->3->2->5->2\n-------\n5>=3: greater\nsmaller:0->1->2->5->2\ngreater:0->4->3->5->2\n-------\n2<3:smaller\nsmaller:0->1->2->2\ngreater:0->4->3->5->2\n-------\nans:\n1->2->2->4->3->5\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@omeirr13](/omeirr13) Since my program uses the constructors, it needs extra O(1) space, that is an extra dummy node.  With such extra dummy node makes programming easier. If you won't use extra space, it needs some modification which may lead to an error."
                    },
                    {
                        "username": "omeirr13",
                        "content": "wont this use extra space"
                    },
                    {
                        "username": "anuron_das",
                        "content": "It is an interesting problem, at least to me. If I were to explain the problem statement to anyone in the simplest terms, I would go like this:\n\nYou are given a linked list and a target number `x`.  You have to reorder the list in such a way that any node with a value `strictly less than x` appears `in the beginning` of the list, such that their relative order `among themselves` is preserved.\n\nFor example: `[1,4,3,2,5,2]` and `x=3`. All the numbers `strictly smaller than x` are `[1,2,2]`. So preserve only their relative order and add them in the beginning of the list.\n\nAfter that you have to preserve the relative order of all the `remaining elements` as well, and after that you can return the list `head`.\n\nFor example, let us consider the above example only, in `[1,4,3,2,5,2]` and `x=3`, after removing all the numbers `strictly less than x`, the remaining list is `[4,3,5]`. So their relative order is preserved accordingly.\n\nIn the end just concatenate the two and return the result.\n\nSo if the problem statement is clear, then one can appreciate the importance of `two pointers` approach, as this problem involves the use of `two pointers` on linked lists. I hope the reader finds this helpful. "
                    },
                    {
                        "username": "valige7091",
                        "content": "All the problem asks one to do is loop through a list and add each element to one of two lists, before combining the two then returning."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sameer89](/sameer89) well, as i understood valige, he meant to say take 2 separate lists of all nodes < x and nodes >= x, and then in the end join the tail of one to head of another which will take O(n). "
                    },
                    {
                        "username": "sameer89",
                        "content": "[@2uringTested](/2uringTested) No it wont.  Since these are linked lists it can be done in O(1) space like \"merge\" in mergesort."
                    },
                    {
                        "username": "2uringTested",
                        "content": "that will use extra space, thats not the best solution, you can do the partition in the same list and in one pass."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Input: head = 1->4->3->2->5->2, x = 3\\nOutput: 1->2->2->4->3->5\\n\\nwhy 4 is exist before than 3 not after ?\\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Because we also have to maintane  the relative order of elements and we have to compare with greater or eqaul to \\'x\\' "
                    },
                    {
                        "username": "sairam852",
                        "content": "because problem description was all nodes less than x come before nodes greater than or equal to x i.e., we no need to move the greater values to after of that targeted value"
                    },
                    {
                        "username": "Abhishen99",
                        "content": "\\n[328. Odd Even Linked List ](https://leetcode.com/problems/odd-even-linked-list/)\\n\\nabove problem is quite similiar to this problem after trying this you can solve that too.\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wanted to comment the same thing, that one is a nice follow up, requiring O(1) space and O(n) time"
                    },
                    {
                        "username": "Ausho_Roup",
                        "content": "Anyone please explain this question. I am unable to get it. I am trying to understand nearly from two days still not able to figure it out ."
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "checkout the discussion section again, ig you\\'ll have it cleared this time"
                    }
                ]
            },
            {
                "id": 2014946,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting and cute problem. Simply use 4 pointers that hold the reference to 2 new linked list segments: lessThanX and greaterOrEqualThanX.\\nTraverse the whole list and append each node to one of these two. At the end, carefully link the tail of the first segment to the head of the 2nd segment."
                    },
                    {
                        "username": "sorcererwdj",
                        "content": "Input: {2,1}, 1  \\nOutput: {1,2}  \\nExpected: {2,1} \\n\\nWhy?"
                    },
                    {
                        "username": "greedycat",
                        "content": "![image](https://assets.leetcode.com/users/images/95a69de4-8e62-470c-b232-98de668b0481_1630418462.159717.png)\\n"
                    },
                    {
                        "username": "aryan1113",
                        "content": "This is just a way of taking in the input in python3"
                    },
                    {
                        "username": "SG-C",
                        "content": "no leetcode no partition today "
                    },
                    {
                        "username": "sam_cee",
                        "content": "Can anyone help me to understand why this is wrong please?\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@Gauravkr007](/Gauravkr007) because 4 is greater than k(3). Any number less than k should stay where it is relative to other numbers less than k but be moved to the left of 'k' (and any number greater than 'k'.\neg, k = 4\n[*2,*3,5,7,4,*0,*1]\nnumbers < k ( *) must be on the left of 4 so result would be\n[*2,*3,*0,*1,5,7,4]\nnumbers < k ( *) now on the left of 'k' in their same relative positions."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@sameer89](/sameer89) ok then 4 also came before 0 and 2 why 4 is shifted but 1 is not ?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@sameer89](/sameer89) thanks for your reply,  it helped me to figure it out in the end!"
                    },
                    {
                        "username": "sameer89",
                        "content": "The question mentions that you need to preserve the relative order. Since 1 comes before 0, it has to come before zero in the answer too! And both of them should come before 3."
                    },
                    {
                        "username": "namanchandak",
                        "content": "for test case\\n[1,4,3,2,5,2]\\nx =\\n3  \\nbelow answer should also be valid.?\\n[2,2,1,4,3,5]"
                    },
                    {
                        "username": "Simon_Noble",
                        "content": "The original order of the list should be the same, just split into a section that is less than x (in the order they originally appeared), then the elements greater than or equal to x (in the original order they appeared)."
                    },
                    {
                        "username": "oops_moment",
                        "content": "If handling the swapping with a double pointer feels tricky, here\\'s a hint: consider using two linked lists. In one list, gather elements less than x, and in the other, store elements greater than x. Then, simply connect these two lists together. Happy coding!"
                    },
                    {
                        "username": "exquiro",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is  - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "A: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "For those who want tip or unable to understand the question\\nCreate a list with minimum number than X\\nCreate the list with remaining numbers\\nmerger both and return the head."
                    }
                ]
            },
            {
                "id": 1568906,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting and cute problem. Simply use 4 pointers that hold the reference to 2 new linked list segments: lessThanX and greaterOrEqualThanX.\\nTraverse the whole list and append each node to one of these two. At the end, carefully link the tail of the first segment to the head of the 2nd segment."
                    },
                    {
                        "username": "sorcererwdj",
                        "content": "Input: {2,1}, 1  \\nOutput: {1,2}  \\nExpected: {2,1} \\n\\nWhy?"
                    },
                    {
                        "username": "greedycat",
                        "content": "![image](https://assets.leetcode.com/users/images/95a69de4-8e62-470c-b232-98de668b0481_1630418462.159717.png)\\n"
                    },
                    {
                        "username": "aryan1113",
                        "content": "This is just a way of taking in the input in python3"
                    },
                    {
                        "username": "SG-C",
                        "content": "no leetcode no partition today "
                    },
                    {
                        "username": "sam_cee",
                        "content": "Can anyone help me to understand why this is wrong please?\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@Gauravkr007](/Gauravkr007) because 4 is greater than k(3). Any number less than k should stay where it is relative to other numbers less than k but be moved to the left of 'k' (and any number greater than 'k'.\neg, k = 4\n[*2,*3,5,7,4,*0,*1]\nnumbers < k ( *) must be on the left of 4 so result would be\n[*2,*3,*0,*1,5,7,4]\nnumbers < k ( *) now on the left of 'k' in their same relative positions."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@sameer89](/sameer89) ok then 4 also came before 0 and 2 why 4 is shifted but 1 is not ?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@sameer89](/sameer89) thanks for your reply,  it helped me to figure it out in the end!"
                    },
                    {
                        "username": "sameer89",
                        "content": "The question mentions that you need to preserve the relative order. Since 1 comes before 0, it has to come before zero in the answer too! And both of them should come before 3."
                    },
                    {
                        "username": "namanchandak",
                        "content": "for test case\\n[1,4,3,2,5,2]\\nx =\\n3  \\nbelow answer should also be valid.?\\n[2,2,1,4,3,5]"
                    },
                    {
                        "username": "Simon_Noble",
                        "content": "The original order of the list should be the same, just split into a section that is less than x (in the order they originally appeared), then the elements greater than or equal to x (in the original order they appeared)."
                    },
                    {
                        "username": "oops_moment",
                        "content": "If handling the swapping with a double pointer feels tricky, here\\'s a hint: consider using two linked lists. In one list, gather elements less than x, and in the other, store elements greater than x. Then, simply connect these two lists together. Happy coding!"
                    },
                    {
                        "username": "exquiro",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is  - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "A: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "For those who want tip or unable to understand the question\\nCreate a list with minimum number than X\\nCreate the list with remaining numbers\\nmerger both and return the head."
                    }
                ]
            },
            {
                "id": 1567653,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting and cute problem. Simply use 4 pointers that hold the reference to 2 new linked list segments: lessThanX and greaterOrEqualThanX.\\nTraverse the whole list and append each node to one of these two. At the end, carefully link the tail of the first segment to the head of the 2nd segment."
                    },
                    {
                        "username": "sorcererwdj",
                        "content": "Input: {2,1}, 1  \\nOutput: {1,2}  \\nExpected: {2,1} \\n\\nWhy?"
                    },
                    {
                        "username": "greedycat",
                        "content": "![image](https://assets.leetcode.com/users/images/95a69de4-8e62-470c-b232-98de668b0481_1630418462.159717.png)\\n"
                    },
                    {
                        "username": "aryan1113",
                        "content": "This is just a way of taking in the input in python3"
                    },
                    {
                        "username": "SG-C",
                        "content": "no leetcode no partition today "
                    },
                    {
                        "username": "sam_cee",
                        "content": "Can anyone help me to understand why this is wrong please?\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@Gauravkr007](/Gauravkr007) because 4 is greater than k(3). Any number less than k should stay where it is relative to other numbers less than k but be moved to the left of 'k' (and any number greater than 'k'.\neg, k = 4\n[*2,*3,5,7,4,*0,*1]\nnumbers < k ( *) must be on the left of 4 so result would be\n[*2,*3,*0,*1,5,7,4]\nnumbers < k ( *) now on the left of 'k' in their same relative positions."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@sameer89](/sameer89) ok then 4 also came before 0 and 2 why 4 is shifted but 1 is not ?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@sameer89](/sameer89) thanks for your reply,  it helped me to figure it out in the end!"
                    },
                    {
                        "username": "sameer89",
                        "content": "The question mentions that you need to preserve the relative order. Since 1 comes before 0, it has to come before zero in the answer too! And both of them should come before 3."
                    },
                    {
                        "username": "namanchandak",
                        "content": "for test case\\n[1,4,3,2,5,2]\\nx =\\n3  \\nbelow answer should also be valid.?\\n[2,2,1,4,3,5]"
                    },
                    {
                        "username": "Simon_Noble",
                        "content": "The original order of the list should be the same, just split into a section that is less than x (in the order they originally appeared), then the elements greater than or equal to x (in the original order they appeared)."
                    },
                    {
                        "username": "oops_moment",
                        "content": "If handling the swapping with a double pointer feels tricky, here\\'s a hint: consider using two linked lists. In one list, gather elements less than x, and in the other, store elements greater than x. Then, simply connect these two lists together. Happy coding!"
                    },
                    {
                        "username": "exquiro",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is  - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "A: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "For those who want tip or unable to understand the question\\nCreate a list with minimum number than X\\nCreate the list with remaining numbers\\nmerger both and return the head."
                    }
                ]
            },
            {
                "id": 2015494,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting and cute problem. Simply use 4 pointers that hold the reference to 2 new linked list segments: lessThanX and greaterOrEqualThanX.\\nTraverse the whole list and append each node to one of these two. At the end, carefully link the tail of the first segment to the head of the 2nd segment."
                    },
                    {
                        "username": "sorcererwdj",
                        "content": "Input: {2,1}, 1  \\nOutput: {1,2}  \\nExpected: {2,1} \\n\\nWhy?"
                    },
                    {
                        "username": "greedycat",
                        "content": "![image](https://assets.leetcode.com/users/images/95a69de4-8e62-470c-b232-98de668b0481_1630418462.159717.png)\\n"
                    },
                    {
                        "username": "aryan1113",
                        "content": "This is just a way of taking in the input in python3"
                    },
                    {
                        "username": "SG-C",
                        "content": "no leetcode no partition today "
                    },
                    {
                        "username": "sam_cee",
                        "content": "Can anyone help me to understand why this is wrong please?\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@Gauravkr007](/Gauravkr007) because 4 is greater than k(3). Any number less than k should stay where it is relative to other numbers less than k but be moved to the left of 'k' (and any number greater than 'k'.\neg, k = 4\n[*2,*3,5,7,4,*0,*1]\nnumbers < k ( *) must be on the left of 4 so result would be\n[*2,*3,*0,*1,5,7,4]\nnumbers < k ( *) now on the left of 'k' in their same relative positions."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@sameer89](/sameer89) ok then 4 also came before 0 and 2 why 4 is shifted but 1 is not ?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@sameer89](/sameer89) thanks for your reply,  it helped me to figure it out in the end!"
                    },
                    {
                        "username": "sameer89",
                        "content": "The question mentions that you need to preserve the relative order. Since 1 comes before 0, it has to come before zero in the answer too! And both of them should come before 3."
                    },
                    {
                        "username": "namanchandak",
                        "content": "for test case\\n[1,4,3,2,5,2]\\nx =\\n3  \\nbelow answer should also be valid.?\\n[2,2,1,4,3,5]"
                    },
                    {
                        "username": "Simon_Noble",
                        "content": "The original order of the list should be the same, just split into a section that is less than x (in the order they originally appeared), then the elements greater than or equal to x (in the original order they appeared)."
                    },
                    {
                        "username": "oops_moment",
                        "content": "If handling the swapping with a double pointer feels tricky, here\\'s a hint: consider using two linked lists. In one list, gather elements less than x, and in the other, store elements greater than x. Then, simply connect these two lists together. Happy coding!"
                    },
                    {
                        "username": "exquiro",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is  - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "A: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "For those who want tip or unable to understand the question\\nCreate a list with minimum number than X\\nCreate the list with remaining numbers\\nmerger both and return the head."
                    }
                ]
            },
            {
                "id": 1987373,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting and cute problem. Simply use 4 pointers that hold the reference to 2 new linked list segments: lessThanX and greaterOrEqualThanX.\\nTraverse the whole list and append each node to one of these two. At the end, carefully link the tail of the first segment to the head of the 2nd segment."
                    },
                    {
                        "username": "sorcererwdj",
                        "content": "Input: {2,1}, 1  \\nOutput: {1,2}  \\nExpected: {2,1} \\n\\nWhy?"
                    },
                    {
                        "username": "greedycat",
                        "content": "![image](https://assets.leetcode.com/users/images/95a69de4-8e62-470c-b232-98de668b0481_1630418462.159717.png)\\n"
                    },
                    {
                        "username": "aryan1113",
                        "content": "This is just a way of taking in the input in python3"
                    },
                    {
                        "username": "SG-C",
                        "content": "no leetcode no partition today "
                    },
                    {
                        "username": "sam_cee",
                        "content": "Can anyone help me to understand why this is wrong please?\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@Gauravkr007](/Gauravkr007) because 4 is greater than k(3). Any number less than k should stay where it is relative to other numbers less than k but be moved to the left of 'k' (and any number greater than 'k'.\neg, k = 4\n[*2,*3,5,7,4,*0,*1]\nnumbers < k ( *) must be on the left of 4 so result would be\n[*2,*3,*0,*1,5,7,4]\nnumbers < k ( *) now on the left of 'k' in their same relative positions."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@sameer89](/sameer89) ok then 4 also came before 0 and 2 why 4 is shifted but 1 is not ?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@sameer89](/sameer89) thanks for your reply,  it helped me to figure it out in the end!"
                    },
                    {
                        "username": "sameer89",
                        "content": "The question mentions that you need to preserve the relative order. Since 1 comes before 0, it has to come before zero in the answer too! And both of them should come before 3."
                    },
                    {
                        "username": "namanchandak",
                        "content": "for test case\\n[1,4,3,2,5,2]\\nx =\\n3  \\nbelow answer should also be valid.?\\n[2,2,1,4,3,5]"
                    },
                    {
                        "username": "Simon_Noble",
                        "content": "The original order of the list should be the same, just split into a section that is less than x (in the order they originally appeared), then the elements greater than or equal to x (in the original order they appeared)."
                    },
                    {
                        "username": "oops_moment",
                        "content": "If handling the swapping with a double pointer feels tricky, here\\'s a hint: consider using two linked lists. In one list, gather elements less than x, and in the other, store elements greater than x. Then, simply connect these two lists together. Happy coding!"
                    },
                    {
                        "username": "exquiro",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is  - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "A: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "For those who want tip or unable to understand the question\\nCreate a list with minimum number than X\\nCreate the list with remaining numbers\\nmerger both and return the head."
                    }
                ]
            },
            {
                "id": 2015652,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting and cute problem. Simply use 4 pointers that hold the reference to 2 new linked list segments: lessThanX and greaterOrEqualThanX.\\nTraverse the whole list and append each node to one of these two. At the end, carefully link the tail of the first segment to the head of the 2nd segment."
                    },
                    {
                        "username": "sorcererwdj",
                        "content": "Input: {2,1}, 1  \\nOutput: {1,2}  \\nExpected: {2,1} \\n\\nWhy?"
                    },
                    {
                        "username": "greedycat",
                        "content": "![image](https://assets.leetcode.com/users/images/95a69de4-8e62-470c-b232-98de668b0481_1630418462.159717.png)\\n"
                    },
                    {
                        "username": "aryan1113",
                        "content": "This is just a way of taking in the input in python3"
                    },
                    {
                        "username": "SG-C",
                        "content": "no leetcode no partition today "
                    },
                    {
                        "username": "sam_cee",
                        "content": "Can anyone help me to understand why this is wrong please?\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@Gauravkr007](/Gauravkr007) because 4 is greater than k(3). Any number less than k should stay where it is relative to other numbers less than k but be moved to the left of 'k' (and any number greater than 'k'.\neg, k = 4\n[*2,*3,5,7,4,*0,*1]\nnumbers < k ( *) must be on the left of 4 so result would be\n[*2,*3,*0,*1,5,7,4]\nnumbers < k ( *) now on the left of 'k' in their same relative positions."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@sameer89](/sameer89) ok then 4 also came before 0 and 2 why 4 is shifted but 1 is not ?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@sameer89](/sameer89) thanks for your reply,  it helped me to figure it out in the end!"
                    },
                    {
                        "username": "sameer89",
                        "content": "The question mentions that you need to preserve the relative order. Since 1 comes before 0, it has to come before zero in the answer too! And both of them should come before 3."
                    },
                    {
                        "username": "namanchandak",
                        "content": "for test case\\n[1,4,3,2,5,2]\\nx =\\n3  \\nbelow answer should also be valid.?\\n[2,2,1,4,3,5]"
                    },
                    {
                        "username": "Simon_Noble",
                        "content": "The original order of the list should be the same, just split into a section that is less than x (in the order they originally appeared), then the elements greater than or equal to x (in the original order they appeared)."
                    },
                    {
                        "username": "oops_moment",
                        "content": "If handling the swapping with a double pointer feels tricky, here\\'s a hint: consider using two linked lists. In one list, gather elements less than x, and in the other, store elements greater than x. Then, simply connect these two lists together. Happy coding!"
                    },
                    {
                        "username": "exquiro",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is  - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "A: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "For those who want tip or unable to understand the question\\nCreate a list with minimum number than X\\nCreate the list with remaining numbers\\nmerger both and return the head."
                    }
                ]
            },
            {
                "id": 2015429,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting and cute problem. Simply use 4 pointers that hold the reference to 2 new linked list segments: lessThanX and greaterOrEqualThanX.\\nTraverse the whole list and append each node to one of these two. At the end, carefully link the tail of the first segment to the head of the 2nd segment."
                    },
                    {
                        "username": "sorcererwdj",
                        "content": "Input: {2,1}, 1  \\nOutput: {1,2}  \\nExpected: {2,1} \\n\\nWhy?"
                    },
                    {
                        "username": "greedycat",
                        "content": "![image](https://assets.leetcode.com/users/images/95a69de4-8e62-470c-b232-98de668b0481_1630418462.159717.png)\\n"
                    },
                    {
                        "username": "aryan1113",
                        "content": "This is just a way of taking in the input in python3"
                    },
                    {
                        "username": "SG-C",
                        "content": "no leetcode no partition today "
                    },
                    {
                        "username": "sam_cee",
                        "content": "Can anyone help me to understand why this is wrong please?\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@Gauravkr007](/Gauravkr007) because 4 is greater than k(3). Any number less than k should stay where it is relative to other numbers less than k but be moved to the left of 'k' (and any number greater than 'k'.\neg, k = 4\n[*2,*3,5,7,4,*0,*1]\nnumbers < k ( *) must be on the left of 4 so result would be\n[*2,*3,*0,*1,5,7,4]\nnumbers < k ( *) now on the left of 'k' in their same relative positions."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@sameer89](/sameer89) ok then 4 also came before 0 and 2 why 4 is shifted but 1 is not ?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@sameer89](/sameer89) thanks for your reply,  it helped me to figure it out in the end!"
                    },
                    {
                        "username": "sameer89",
                        "content": "The question mentions that you need to preserve the relative order. Since 1 comes before 0, it has to come before zero in the answer too! And both of them should come before 3."
                    },
                    {
                        "username": "namanchandak",
                        "content": "for test case\\n[1,4,3,2,5,2]\\nx =\\n3  \\nbelow answer should also be valid.?\\n[2,2,1,4,3,5]"
                    },
                    {
                        "username": "Simon_Noble",
                        "content": "The original order of the list should be the same, just split into a section that is less than x (in the order they originally appeared), then the elements greater than or equal to x (in the original order they appeared)."
                    },
                    {
                        "username": "oops_moment",
                        "content": "If handling the swapping with a double pointer feels tricky, here\\'s a hint: consider using two linked lists. In one list, gather elements less than x, and in the other, store elements greater than x. Then, simply connect these two lists together. Happy coding!"
                    },
                    {
                        "username": "exquiro",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is  - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "A: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "For those who want tip or unable to understand the question\\nCreate a list with minimum number than X\\nCreate the list with remaining numbers\\nmerger both and return the head."
                    }
                ]
            },
            {
                "id": 2015323,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting and cute problem. Simply use 4 pointers that hold the reference to 2 new linked list segments: lessThanX and greaterOrEqualThanX.\\nTraverse the whole list and append each node to one of these two. At the end, carefully link the tail of the first segment to the head of the 2nd segment."
                    },
                    {
                        "username": "sorcererwdj",
                        "content": "Input: {2,1}, 1  \\nOutput: {1,2}  \\nExpected: {2,1} \\n\\nWhy?"
                    },
                    {
                        "username": "greedycat",
                        "content": "![image](https://assets.leetcode.com/users/images/95a69de4-8e62-470c-b232-98de668b0481_1630418462.159717.png)\\n"
                    },
                    {
                        "username": "aryan1113",
                        "content": "This is just a way of taking in the input in python3"
                    },
                    {
                        "username": "SG-C",
                        "content": "no leetcode no partition today "
                    },
                    {
                        "username": "sam_cee",
                        "content": "Can anyone help me to understand why this is wrong please?\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@Gauravkr007](/Gauravkr007) because 4 is greater than k(3). Any number less than k should stay where it is relative to other numbers less than k but be moved to the left of 'k' (and any number greater than 'k'.\neg, k = 4\n[*2,*3,5,7,4,*0,*1]\nnumbers < k ( *) must be on the left of 4 so result would be\n[*2,*3,*0,*1,5,7,4]\nnumbers < k ( *) now on the left of 'k' in their same relative positions."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@sameer89](/sameer89) ok then 4 also came before 0 and 2 why 4 is shifted but 1 is not ?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@sameer89](/sameer89) thanks for your reply,  it helped me to figure it out in the end!"
                    },
                    {
                        "username": "sameer89",
                        "content": "The question mentions that you need to preserve the relative order. Since 1 comes before 0, it has to come before zero in the answer too! And both of them should come before 3."
                    },
                    {
                        "username": "namanchandak",
                        "content": "for test case\\n[1,4,3,2,5,2]\\nx =\\n3  \\nbelow answer should also be valid.?\\n[2,2,1,4,3,5]"
                    },
                    {
                        "username": "Simon_Noble",
                        "content": "The original order of the list should be the same, just split into a section that is less than x (in the order they originally appeared), then the elements greater than or equal to x (in the original order they appeared)."
                    },
                    {
                        "username": "oops_moment",
                        "content": "If handling the swapping with a double pointer feels tricky, here\\'s a hint: consider using two linked lists. In one list, gather elements less than x, and in the other, store elements greater than x. Then, simply connect these two lists together. Happy coding!"
                    },
                    {
                        "username": "exquiro",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is  - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "A: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "For those who want tip or unable to understand the question\\nCreate a list with minimum number than X\\nCreate the list with remaining numbers\\nmerger both and return the head."
                    }
                ]
            },
            {
                "id": 2015255,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting and cute problem. Simply use 4 pointers that hold the reference to 2 new linked list segments: lessThanX and greaterOrEqualThanX.\\nTraverse the whole list and append each node to one of these two. At the end, carefully link the tail of the first segment to the head of the 2nd segment."
                    },
                    {
                        "username": "sorcererwdj",
                        "content": "Input: {2,1}, 1  \\nOutput: {1,2}  \\nExpected: {2,1} \\n\\nWhy?"
                    },
                    {
                        "username": "greedycat",
                        "content": "![image](https://assets.leetcode.com/users/images/95a69de4-8e62-470c-b232-98de668b0481_1630418462.159717.png)\\n"
                    },
                    {
                        "username": "aryan1113",
                        "content": "This is just a way of taking in the input in python3"
                    },
                    {
                        "username": "SG-C",
                        "content": "no leetcode no partition today "
                    },
                    {
                        "username": "sam_cee",
                        "content": "Can anyone help me to understand why this is wrong please?\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@Gauravkr007](/Gauravkr007) because 4 is greater than k(3). Any number less than k should stay where it is relative to other numbers less than k but be moved to the left of 'k' (and any number greater than 'k'.\neg, k = 4\n[*2,*3,5,7,4,*0,*1]\nnumbers < k ( *) must be on the left of 4 so result would be\n[*2,*3,*0,*1,5,7,4]\nnumbers < k ( *) now on the left of 'k' in their same relative positions."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@sameer89](/sameer89) ok then 4 also came before 0 and 2 why 4 is shifted but 1 is not ?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@sameer89](/sameer89) thanks for your reply,  it helped me to figure it out in the end!"
                    },
                    {
                        "username": "sameer89",
                        "content": "The question mentions that you need to preserve the relative order. Since 1 comes before 0, it has to come before zero in the answer too! And both of them should come before 3."
                    },
                    {
                        "username": "namanchandak",
                        "content": "for test case\\n[1,4,3,2,5,2]\\nx =\\n3  \\nbelow answer should also be valid.?\\n[2,2,1,4,3,5]"
                    },
                    {
                        "username": "Simon_Noble",
                        "content": "The original order of the list should be the same, just split into a section that is less than x (in the order they originally appeared), then the elements greater than or equal to x (in the original order they appeared)."
                    },
                    {
                        "username": "oops_moment",
                        "content": "If handling the swapping with a double pointer feels tricky, here\\'s a hint: consider using two linked lists. In one list, gather elements less than x, and in the other, store elements greater than x. Then, simply connect these two lists together. Happy coding!"
                    },
                    {
                        "username": "exquiro",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is  - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "A: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "For those who want tip or unable to understand the question\\nCreate a list with minimum number than X\\nCreate the list with remaining numbers\\nmerger both and return the head."
                    }
                ]
            },
            {
                "id": 2015245,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting and cute problem. Simply use 4 pointers that hold the reference to 2 new linked list segments: lessThanX and greaterOrEqualThanX.\\nTraverse the whole list and append each node to one of these two. At the end, carefully link the tail of the first segment to the head of the 2nd segment."
                    },
                    {
                        "username": "sorcererwdj",
                        "content": "Input: {2,1}, 1  \\nOutput: {1,2}  \\nExpected: {2,1} \\n\\nWhy?"
                    },
                    {
                        "username": "greedycat",
                        "content": "![image](https://assets.leetcode.com/users/images/95a69de4-8e62-470c-b232-98de668b0481_1630418462.159717.png)\\n"
                    },
                    {
                        "username": "aryan1113",
                        "content": "This is just a way of taking in the input in python3"
                    },
                    {
                        "username": "SG-C",
                        "content": "no leetcode no partition today "
                    },
                    {
                        "username": "sam_cee",
                        "content": "Can anyone help me to understand why this is wrong please?\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@Gauravkr007](/Gauravkr007) because 4 is greater than k(3). Any number less than k should stay where it is relative to other numbers less than k but be moved to the left of 'k' (and any number greater than 'k'.\neg, k = 4\n[*2,*3,5,7,4,*0,*1]\nnumbers < k ( *) must be on the left of 4 so result would be\n[*2,*3,*0,*1,5,7,4]\nnumbers < k ( *) now on the left of 'k' in their same relative positions."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@sameer89](/sameer89) ok then 4 also came before 0 and 2 why 4 is shifted but 1 is not ?"
                    },
                    {
                        "username": "sam_cee",
                        "content": "[@sameer89](/sameer89) thanks for your reply,  it helped me to figure it out in the end!"
                    },
                    {
                        "username": "sameer89",
                        "content": "The question mentions that you need to preserve the relative order. Since 1 comes before 0, it has to come before zero in the answer too! And both of them should come before 3."
                    },
                    {
                        "username": "namanchandak",
                        "content": "for test case\\n[1,4,3,2,5,2]\\nx =\\n3  \\nbelow answer should also be valid.?\\n[2,2,1,4,3,5]"
                    },
                    {
                        "username": "Simon_Noble",
                        "content": "The original order of the list should be the same, just split into a section that is less than x (in the order they originally appeared), then the elements greater than or equal to x (in the original order they appeared)."
                    },
                    {
                        "username": "oops_moment",
                        "content": "If handling the swapping with a double pointer feels tricky, here\\'s a hint: consider using two linked lists. In one list, gather elements less than x, and in the other, store elements greater than x. Then, simply connect these two lists together. Happy coding!"
                    },
                    {
                        "username": "exquiro",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is  - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "A: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It should be easy?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "For those who want tip or unable to understand the question\\nCreate a list with minimum number than X\\nCreate the list with remaining numbers\\nmerger both and return the head."
                    }
                ]
            },
            {
                "id": 2015005,
                "content": [
                    {
                        "username": "alokranjanjha10",
                        "content": "Happy Independence Day "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Lower Medium Class question, not that tough. We can do it guys. \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s some edge cases you might consider before submitting your solution.\\n\\n- list is empty\\n[]\\n0\\n\\n- x is not in the linked list: \\n[1]\\n0\\n[1]\\n2\\n[1,1]\\n2\\n[1,1]\\n0\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "Input -> [2,2,3,1,5,0]\nExpected -> [2,2,1,0,3,5]\nPivot is takes as '3'\nwhy is it not [0,1,2,2,3,5]?\n\nCan someone please explain how should the elements be placed in the left part of the list? Should they be in sorted order or any random order works?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`You should preserve the original relative order of the nodes in each of the two partitions.`\n\nsince the 2 come first before 1 and 0 in the input, you have to put 2 at the front"
                    },
                    {
                        "username": "booleanbit1",
                        "content": "I was able to submit after the 9th submission, the description is misleading, and so many test cases need to be considered,\\ntry below ones to test your code -\\n1. [2,1]   x=2\\n2. [3,6,5,4,8,1,7,2,4,5,6,7,2,1,2,3,4,5,77,88,3,3,3,4,4,4], x=4\\n3.  [] , x=0\\n4. [3,1], x=2\\n5. [2,4,1,1,2,3,4,2,2] , x=3\\n6. [2,0,4,1,3,1,4,0,3], x=4\\n\\nAlso try changing values of x, there could be test cases where x is not even in the list, so take care of that as well.\\n\\nThe idea behind the solution is - keep tracking the list before you get your number x, and make sure to put all the numbers strictly less than x before the numbers greater than x, and then continue the same for the list after finding x in the list.\\n"
                    },
                    {
                        "username": "Suhasumesh",
                        "content": "Tip :\\nCreate 2 dummy listnodes and two pointers pointing to them and use one listnode to store values less than x and other listnode to store value greater than x and join them and return dummy1\\'s listnode.\\nPlease do upvote if you like it. Thank you!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is not a tip, this is literally the solution"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "This is pretty straightforward:\\n1. create list1 with values lower than x while maintaining the order\\n2. create list2 with values grater or equals to x while maintaining the order\\n3. join list1 and list2\\n4. return list1 head"
                    },
                    {
                        "username": "skydodle",
                        "content": "The key here is to recognize there are two groups. One group (nodes with value less than x) should be in the front of the result list, and the other group (nodes with value >= x) should be in the latter part of result list. Therefore we can break it down to left group and right group.\\n\\nThe rest is easy. As we traverse the list, we check each node to see if it belong to left group or right group, and update left or right group along the way. In the end, connect left to right and we have a result list."
                    },
                    {
                        "username": "omeirr13",
                        "content": "but this uses extra space right?"
                    },
                    {
                        "username": "user5630Yg",
                        "content": "Are we allowed to change the val of the node? Or we need to move the node."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "It takes 2hr to solve this problem but at end it is a part of problem solving  \n\nhint for this problem:\ncreate a two different such that\n\nlst  = [1,4,3,2,5,2]\nx = 3\n\nsList = [1,2,2]  // small list contains smaller element in list than x .\nlList = [4,3,5]  // large list contains bigger or equal elemet to x.\n\nand done !\n\nmerge and return result."
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "[@omeirr13](/omeirr13)  ok i will try to solve without extra space\\n"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to do without extra space"
                    }
                ]
            },
            {
                "id": 2014797,
                "content": [
                    {
                        "username": "alokranjanjha10",
                        "content": "Happy Independence Day "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Lower Medium Class question, not that tough. We can do it guys. \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s some edge cases you might consider before submitting your solution.\\n\\n- list is empty\\n[]\\n0\\n\\n- x is not in the linked list: \\n[1]\\n0\\n[1]\\n2\\n[1,1]\\n2\\n[1,1]\\n0\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "Input -> [2,2,3,1,5,0]\nExpected -> [2,2,1,0,3,5]\nPivot is takes as '3'\nwhy is it not [0,1,2,2,3,5]?\n\nCan someone please explain how should the elements be placed in the left part of the list? Should they be in sorted order or any random order works?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`You should preserve the original relative order of the nodes in each of the two partitions.`\n\nsince the 2 come first before 1 and 0 in the input, you have to put 2 at the front"
                    },
                    {
                        "username": "booleanbit1",
                        "content": "I was able to submit after the 9th submission, the description is misleading, and so many test cases need to be considered,\\ntry below ones to test your code -\\n1. [2,1]   x=2\\n2. [3,6,5,4,8,1,7,2,4,5,6,7,2,1,2,3,4,5,77,88,3,3,3,4,4,4], x=4\\n3.  [] , x=0\\n4. [3,1], x=2\\n5. [2,4,1,1,2,3,4,2,2] , x=3\\n6. [2,0,4,1,3,1,4,0,3], x=4\\n\\nAlso try changing values of x, there could be test cases where x is not even in the list, so take care of that as well.\\n\\nThe idea behind the solution is - keep tracking the list before you get your number x, and make sure to put all the numbers strictly less than x before the numbers greater than x, and then continue the same for the list after finding x in the list.\\n"
                    },
                    {
                        "username": "Suhasumesh",
                        "content": "Tip :\\nCreate 2 dummy listnodes and two pointers pointing to them and use one listnode to store values less than x and other listnode to store value greater than x and join them and return dummy1\\'s listnode.\\nPlease do upvote if you like it. Thank you!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is not a tip, this is literally the solution"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "This is pretty straightforward:\\n1. create list1 with values lower than x while maintaining the order\\n2. create list2 with values grater or equals to x while maintaining the order\\n3. join list1 and list2\\n4. return list1 head"
                    },
                    {
                        "username": "skydodle",
                        "content": "The key here is to recognize there are two groups. One group (nodes with value less than x) should be in the front of the result list, and the other group (nodes with value >= x) should be in the latter part of result list. Therefore we can break it down to left group and right group.\\n\\nThe rest is easy. As we traverse the list, we check each node to see if it belong to left group or right group, and update left or right group along the way. In the end, connect left to right and we have a result list."
                    },
                    {
                        "username": "omeirr13",
                        "content": "but this uses extra space right?"
                    },
                    {
                        "username": "user5630Yg",
                        "content": "Are we allowed to change the val of the node? Or we need to move the node."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "It takes 2hr to solve this problem but at end it is a part of problem solving  \n\nhint for this problem:\ncreate a two different such that\n\nlst  = [1,4,3,2,5,2]\nx = 3\n\nsList = [1,2,2]  // small list contains smaller element in list than x .\nlList = [4,3,5]  // large list contains bigger or equal elemet to x.\n\nand done !\n\nmerge and return result."
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "[@omeirr13](/omeirr13)  ok i will try to solve without extra space\\n"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to do without extra space"
                    }
                ]
            },
            {
                "id": 2014753,
                "content": [
                    {
                        "username": "alokranjanjha10",
                        "content": "Happy Independence Day "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Lower Medium Class question, not that tough. We can do it guys. \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s some edge cases you might consider before submitting your solution.\\n\\n- list is empty\\n[]\\n0\\n\\n- x is not in the linked list: \\n[1]\\n0\\n[1]\\n2\\n[1,1]\\n2\\n[1,1]\\n0\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "Input -> [2,2,3,1,5,0]\nExpected -> [2,2,1,0,3,5]\nPivot is takes as '3'\nwhy is it not [0,1,2,2,3,5]?\n\nCan someone please explain how should the elements be placed in the left part of the list? Should they be in sorted order or any random order works?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`You should preserve the original relative order of the nodes in each of the two partitions.`\n\nsince the 2 come first before 1 and 0 in the input, you have to put 2 at the front"
                    },
                    {
                        "username": "booleanbit1",
                        "content": "I was able to submit after the 9th submission, the description is misleading, and so many test cases need to be considered,\\ntry below ones to test your code -\\n1. [2,1]   x=2\\n2. [3,6,5,4,8,1,7,2,4,5,6,7,2,1,2,3,4,5,77,88,3,3,3,4,4,4], x=4\\n3.  [] , x=0\\n4. [3,1], x=2\\n5. [2,4,1,1,2,3,4,2,2] , x=3\\n6. [2,0,4,1,3,1,4,0,3], x=4\\n\\nAlso try changing values of x, there could be test cases where x is not even in the list, so take care of that as well.\\n\\nThe idea behind the solution is - keep tracking the list before you get your number x, and make sure to put all the numbers strictly less than x before the numbers greater than x, and then continue the same for the list after finding x in the list.\\n"
                    },
                    {
                        "username": "Suhasumesh",
                        "content": "Tip :\\nCreate 2 dummy listnodes and two pointers pointing to them and use one listnode to store values less than x and other listnode to store value greater than x and join them and return dummy1\\'s listnode.\\nPlease do upvote if you like it. Thank you!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is not a tip, this is literally the solution"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "This is pretty straightforward:\\n1. create list1 with values lower than x while maintaining the order\\n2. create list2 with values grater or equals to x while maintaining the order\\n3. join list1 and list2\\n4. return list1 head"
                    },
                    {
                        "username": "skydodle",
                        "content": "The key here is to recognize there are two groups. One group (nodes with value less than x) should be in the front of the result list, and the other group (nodes with value >= x) should be in the latter part of result list. Therefore we can break it down to left group and right group.\\n\\nThe rest is easy. As we traverse the list, we check each node to see if it belong to left group or right group, and update left or right group along the way. In the end, connect left to right and we have a result list."
                    },
                    {
                        "username": "omeirr13",
                        "content": "but this uses extra space right?"
                    },
                    {
                        "username": "user5630Yg",
                        "content": "Are we allowed to change the val of the node? Or we need to move the node."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "It takes 2hr to solve this problem but at end it is a part of problem solving  \n\nhint for this problem:\ncreate a two different such that\n\nlst  = [1,4,3,2,5,2]\nx = 3\n\nsList = [1,2,2]  // small list contains smaller element in list than x .\nlList = [4,3,5]  // large list contains bigger or equal elemet to x.\n\nand done !\n\nmerge and return result."
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "[@omeirr13](/omeirr13)  ok i will try to solve without extra space\\n"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to do without extra space"
                    }
                ]
            },
            {
                "id": 2014711,
                "content": [
                    {
                        "username": "alokranjanjha10",
                        "content": "Happy Independence Day "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Lower Medium Class question, not that tough. We can do it guys. \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s some edge cases you might consider before submitting your solution.\\n\\n- list is empty\\n[]\\n0\\n\\n- x is not in the linked list: \\n[1]\\n0\\n[1]\\n2\\n[1,1]\\n2\\n[1,1]\\n0\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "Input -> [2,2,3,1,5,0]\nExpected -> [2,2,1,0,3,5]\nPivot is takes as '3'\nwhy is it not [0,1,2,2,3,5]?\n\nCan someone please explain how should the elements be placed in the left part of the list? Should they be in sorted order or any random order works?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`You should preserve the original relative order of the nodes in each of the two partitions.`\n\nsince the 2 come first before 1 and 0 in the input, you have to put 2 at the front"
                    },
                    {
                        "username": "booleanbit1",
                        "content": "I was able to submit after the 9th submission, the description is misleading, and so many test cases need to be considered,\\ntry below ones to test your code -\\n1. [2,1]   x=2\\n2. [3,6,5,4,8,1,7,2,4,5,6,7,2,1,2,3,4,5,77,88,3,3,3,4,4,4], x=4\\n3.  [] , x=0\\n4. [3,1], x=2\\n5. [2,4,1,1,2,3,4,2,2] , x=3\\n6. [2,0,4,1,3,1,4,0,3], x=4\\n\\nAlso try changing values of x, there could be test cases where x is not even in the list, so take care of that as well.\\n\\nThe idea behind the solution is - keep tracking the list before you get your number x, and make sure to put all the numbers strictly less than x before the numbers greater than x, and then continue the same for the list after finding x in the list.\\n"
                    },
                    {
                        "username": "Suhasumesh",
                        "content": "Tip :\\nCreate 2 dummy listnodes and two pointers pointing to them and use one listnode to store values less than x and other listnode to store value greater than x and join them and return dummy1\\'s listnode.\\nPlease do upvote if you like it. Thank you!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is not a tip, this is literally the solution"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "This is pretty straightforward:\\n1. create list1 with values lower than x while maintaining the order\\n2. create list2 with values grater or equals to x while maintaining the order\\n3. join list1 and list2\\n4. return list1 head"
                    },
                    {
                        "username": "skydodle",
                        "content": "The key here is to recognize there are two groups. One group (nodes with value less than x) should be in the front of the result list, and the other group (nodes with value >= x) should be in the latter part of result list. Therefore we can break it down to left group and right group.\\n\\nThe rest is easy. As we traverse the list, we check each node to see if it belong to left group or right group, and update left or right group along the way. In the end, connect left to right and we have a result list."
                    },
                    {
                        "username": "omeirr13",
                        "content": "but this uses extra space right?"
                    },
                    {
                        "username": "user5630Yg",
                        "content": "Are we allowed to change the val of the node? Or we need to move the node."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "It takes 2hr to solve this problem but at end it is a part of problem solving  \n\nhint for this problem:\ncreate a two different such that\n\nlst  = [1,4,3,2,5,2]\nx = 3\n\nsList = [1,2,2]  // small list contains smaller element in list than x .\nlList = [4,3,5]  // large list contains bigger or equal elemet to x.\n\nand done !\n\nmerge and return result."
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "[@omeirr13](/omeirr13)  ok i will try to solve without extra space\\n"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to do without extra space"
                    }
                ]
            },
            {
                "id": 2014615,
                "content": [
                    {
                        "username": "alokranjanjha10",
                        "content": "Happy Independence Day "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Lower Medium Class question, not that tough. We can do it guys. \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s some edge cases you might consider before submitting your solution.\\n\\n- list is empty\\n[]\\n0\\n\\n- x is not in the linked list: \\n[1]\\n0\\n[1]\\n2\\n[1,1]\\n2\\n[1,1]\\n0\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "Input -> [2,2,3,1,5,0]\nExpected -> [2,2,1,0,3,5]\nPivot is takes as '3'\nwhy is it not [0,1,2,2,3,5]?\n\nCan someone please explain how should the elements be placed in the left part of the list? Should they be in sorted order or any random order works?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`You should preserve the original relative order of the nodes in each of the two partitions.`\n\nsince the 2 come first before 1 and 0 in the input, you have to put 2 at the front"
                    },
                    {
                        "username": "booleanbit1",
                        "content": "I was able to submit after the 9th submission, the description is misleading, and so many test cases need to be considered,\\ntry below ones to test your code -\\n1. [2,1]   x=2\\n2. [3,6,5,4,8,1,7,2,4,5,6,7,2,1,2,3,4,5,77,88,3,3,3,4,4,4], x=4\\n3.  [] , x=0\\n4. [3,1], x=2\\n5. [2,4,1,1,2,3,4,2,2] , x=3\\n6. [2,0,4,1,3,1,4,0,3], x=4\\n\\nAlso try changing values of x, there could be test cases where x is not even in the list, so take care of that as well.\\n\\nThe idea behind the solution is - keep tracking the list before you get your number x, and make sure to put all the numbers strictly less than x before the numbers greater than x, and then continue the same for the list after finding x in the list.\\n"
                    },
                    {
                        "username": "Suhasumesh",
                        "content": "Tip :\\nCreate 2 dummy listnodes and two pointers pointing to them and use one listnode to store values less than x and other listnode to store value greater than x and join them and return dummy1\\'s listnode.\\nPlease do upvote if you like it. Thank you!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is not a tip, this is literally the solution"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "This is pretty straightforward:\\n1. create list1 with values lower than x while maintaining the order\\n2. create list2 with values grater or equals to x while maintaining the order\\n3. join list1 and list2\\n4. return list1 head"
                    },
                    {
                        "username": "skydodle",
                        "content": "The key here is to recognize there are two groups. One group (nodes with value less than x) should be in the front of the result list, and the other group (nodes with value >= x) should be in the latter part of result list. Therefore we can break it down to left group and right group.\\n\\nThe rest is easy. As we traverse the list, we check each node to see if it belong to left group or right group, and update left or right group along the way. In the end, connect left to right and we have a result list."
                    },
                    {
                        "username": "omeirr13",
                        "content": "but this uses extra space right?"
                    },
                    {
                        "username": "user5630Yg",
                        "content": "Are we allowed to change the val of the node? Or we need to move the node."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "It takes 2hr to solve this problem but at end it is a part of problem solving  \n\nhint for this problem:\ncreate a two different such that\n\nlst  = [1,4,3,2,5,2]\nx = 3\n\nsList = [1,2,2]  // small list contains smaller element in list than x .\nlList = [4,3,5]  // large list contains bigger or equal elemet to x.\n\nand done !\n\nmerge and return result."
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "[@omeirr13](/omeirr13)  ok i will try to solve without extra space\\n"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to do without extra space"
                    }
                ]
            },
            {
                "id": 1707670,
                "content": [
                    {
                        "username": "alokranjanjha10",
                        "content": "Happy Independence Day "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Lower Medium Class question, not that tough. We can do it guys. \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s some edge cases you might consider before submitting your solution.\\n\\n- list is empty\\n[]\\n0\\n\\n- x is not in the linked list: \\n[1]\\n0\\n[1]\\n2\\n[1,1]\\n2\\n[1,1]\\n0\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "Input -> [2,2,3,1,5,0]\nExpected -> [2,2,1,0,3,5]\nPivot is takes as '3'\nwhy is it not [0,1,2,2,3,5]?\n\nCan someone please explain how should the elements be placed in the left part of the list? Should they be in sorted order or any random order works?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`You should preserve the original relative order of the nodes in each of the two partitions.`\n\nsince the 2 come first before 1 and 0 in the input, you have to put 2 at the front"
                    },
                    {
                        "username": "booleanbit1",
                        "content": "I was able to submit after the 9th submission, the description is misleading, and so many test cases need to be considered,\\ntry below ones to test your code -\\n1. [2,1]   x=2\\n2. [3,6,5,4,8,1,7,2,4,5,6,7,2,1,2,3,4,5,77,88,3,3,3,4,4,4], x=4\\n3.  [] , x=0\\n4. [3,1], x=2\\n5. [2,4,1,1,2,3,4,2,2] , x=3\\n6. [2,0,4,1,3,1,4,0,3], x=4\\n\\nAlso try changing values of x, there could be test cases where x is not even in the list, so take care of that as well.\\n\\nThe idea behind the solution is - keep tracking the list before you get your number x, and make sure to put all the numbers strictly less than x before the numbers greater than x, and then continue the same for the list after finding x in the list.\\n"
                    },
                    {
                        "username": "Suhasumesh",
                        "content": "Tip :\\nCreate 2 dummy listnodes and two pointers pointing to them and use one listnode to store values less than x and other listnode to store value greater than x and join them and return dummy1\\'s listnode.\\nPlease do upvote if you like it. Thank you!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is not a tip, this is literally the solution"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "This is pretty straightforward:\\n1. create list1 with values lower than x while maintaining the order\\n2. create list2 with values grater or equals to x while maintaining the order\\n3. join list1 and list2\\n4. return list1 head"
                    },
                    {
                        "username": "skydodle",
                        "content": "The key here is to recognize there are two groups. One group (nodes with value less than x) should be in the front of the result list, and the other group (nodes with value >= x) should be in the latter part of result list. Therefore we can break it down to left group and right group.\\n\\nThe rest is easy. As we traverse the list, we check each node to see if it belong to left group or right group, and update left or right group along the way. In the end, connect left to right and we have a result list."
                    },
                    {
                        "username": "omeirr13",
                        "content": "but this uses extra space right?"
                    },
                    {
                        "username": "user5630Yg",
                        "content": "Are we allowed to change the val of the node? Or we need to move the node."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "It takes 2hr to solve this problem but at end it is a part of problem solving  \n\nhint for this problem:\ncreate a two different such that\n\nlst  = [1,4,3,2,5,2]\nx = 3\n\nsList = [1,2,2]  // small list contains smaller element in list than x .\nlList = [4,3,5]  // large list contains bigger or equal elemet to x.\n\nand done !\n\nmerge and return result."
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "[@omeirr13](/omeirr13)  ok i will try to solve without extra space\\n"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to do without extra space"
                    }
                ]
            },
            {
                "id": 2060561,
                "content": [
                    {
                        "username": "alokranjanjha10",
                        "content": "Happy Independence Day "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Lower Medium Class question, not that tough. We can do it guys. \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s some edge cases you might consider before submitting your solution.\\n\\n- list is empty\\n[]\\n0\\n\\n- x is not in the linked list: \\n[1]\\n0\\n[1]\\n2\\n[1,1]\\n2\\n[1,1]\\n0\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "Input -> [2,2,3,1,5,0]\nExpected -> [2,2,1,0,3,5]\nPivot is takes as '3'\nwhy is it not [0,1,2,2,3,5]?\n\nCan someone please explain how should the elements be placed in the left part of the list? Should they be in sorted order or any random order works?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`You should preserve the original relative order of the nodes in each of the two partitions.`\n\nsince the 2 come first before 1 and 0 in the input, you have to put 2 at the front"
                    },
                    {
                        "username": "booleanbit1",
                        "content": "I was able to submit after the 9th submission, the description is misleading, and so many test cases need to be considered,\\ntry below ones to test your code -\\n1. [2,1]   x=2\\n2. [3,6,5,4,8,1,7,2,4,5,6,7,2,1,2,3,4,5,77,88,3,3,3,4,4,4], x=4\\n3.  [] , x=0\\n4. [3,1], x=2\\n5. [2,4,1,1,2,3,4,2,2] , x=3\\n6. [2,0,4,1,3,1,4,0,3], x=4\\n\\nAlso try changing values of x, there could be test cases where x is not even in the list, so take care of that as well.\\n\\nThe idea behind the solution is - keep tracking the list before you get your number x, and make sure to put all the numbers strictly less than x before the numbers greater than x, and then continue the same for the list after finding x in the list.\\n"
                    },
                    {
                        "username": "Suhasumesh",
                        "content": "Tip :\\nCreate 2 dummy listnodes and two pointers pointing to them and use one listnode to store values less than x and other listnode to store value greater than x and join them and return dummy1\\'s listnode.\\nPlease do upvote if you like it. Thank you!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is not a tip, this is literally the solution"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "This is pretty straightforward:\\n1. create list1 with values lower than x while maintaining the order\\n2. create list2 with values grater or equals to x while maintaining the order\\n3. join list1 and list2\\n4. return list1 head"
                    },
                    {
                        "username": "skydodle",
                        "content": "The key here is to recognize there are two groups. One group (nodes with value less than x) should be in the front of the result list, and the other group (nodes with value >= x) should be in the latter part of result list. Therefore we can break it down to left group and right group.\\n\\nThe rest is easy. As we traverse the list, we check each node to see if it belong to left group or right group, and update left or right group along the way. In the end, connect left to right and we have a result list."
                    },
                    {
                        "username": "omeirr13",
                        "content": "but this uses extra space right?"
                    },
                    {
                        "username": "user5630Yg",
                        "content": "Are we allowed to change the val of the node? Or we need to move the node."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "It takes 2hr to solve this problem but at end it is a part of problem solving  \n\nhint for this problem:\ncreate a two different such that\n\nlst  = [1,4,3,2,5,2]\nx = 3\n\nsList = [1,2,2]  // small list contains smaller element in list than x .\nlList = [4,3,5]  // large list contains bigger or equal elemet to x.\n\nand done !\n\nmerge and return result."
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "[@omeirr13](/omeirr13)  ok i will try to solve without extra space\\n"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to do without extra space"
                    }
                ]
            },
            {
                "id": 2041513,
                "content": [
                    {
                        "username": "alokranjanjha10",
                        "content": "Happy Independence Day "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Lower Medium Class question, not that tough. We can do it guys. \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s some edge cases you might consider before submitting your solution.\\n\\n- list is empty\\n[]\\n0\\n\\n- x is not in the linked list: \\n[1]\\n0\\n[1]\\n2\\n[1,1]\\n2\\n[1,1]\\n0\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "Input -> [2,2,3,1,5,0]\nExpected -> [2,2,1,0,3,5]\nPivot is takes as '3'\nwhy is it not [0,1,2,2,3,5]?\n\nCan someone please explain how should the elements be placed in the left part of the list? Should they be in sorted order or any random order works?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`You should preserve the original relative order of the nodes in each of the two partitions.`\n\nsince the 2 come first before 1 and 0 in the input, you have to put 2 at the front"
                    },
                    {
                        "username": "booleanbit1",
                        "content": "I was able to submit after the 9th submission, the description is misleading, and so many test cases need to be considered,\\ntry below ones to test your code -\\n1. [2,1]   x=2\\n2. [3,6,5,4,8,1,7,2,4,5,6,7,2,1,2,3,4,5,77,88,3,3,3,4,4,4], x=4\\n3.  [] , x=0\\n4. [3,1], x=2\\n5. [2,4,1,1,2,3,4,2,2] , x=3\\n6. [2,0,4,1,3,1,4,0,3], x=4\\n\\nAlso try changing values of x, there could be test cases where x is not even in the list, so take care of that as well.\\n\\nThe idea behind the solution is - keep tracking the list before you get your number x, and make sure to put all the numbers strictly less than x before the numbers greater than x, and then continue the same for the list after finding x in the list.\\n"
                    },
                    {
                        "username": "Suhasumesh",
                        "content": "Tip :\\nCreate 2 dummy listnodes and two pointers pointing to them and use one listnode to store values less than x and other listnode to store value greater than x and join them and return dummy1\\'s listnode.\\nPlease do upvote if you like it. Thank you!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is not a tip, this is literally the solution"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "This is pretty straightforward:\\n1. create list1 with values lower than x while maintaining the order\\n2. create list2 with values grater or equals to x while maintaining the order\\n3. join list1 and list2\\n4. return list1 head"
                    },
                    {
                        "username": "skydodle",
                        "content": "The key here is to recognize there are two groups. One group (nodes with value less than x) should be in the front of the result list, and the other group (nodes with value >= x) should be in the latter part of result list. Therefore we can break it down to left group and right group.\\n\\nThe rest is easy. As we traverse the list, we check each node to see if it belong to left group or right group, and update left or right group along the way. In the end, connect left to right and we have a result list."
                    },
                    {
                        "username": "omeirr13",
                        "content": "but this uses extra space right?"
                    },
                    {
                        "username": "user5630Yg",
                        "content": "Are we allowed to change the val of the node? Or we need to move the node."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "It takes 2hr to solve this problem but at end it is a part of problem solving  \n\nhint for this problem:\ncreate a two different such that\n\nlst  = [1,4,3,2,5,2]\nx = 3\n\nsList = [1,2,2]  // small list contains smaller element in list than x .\nlList = [4,3,5]  // large list contains bigger or equal elemet to x.\n\nand done !\n\nmerge and return result."
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "[@omeirr13](/omeirr13)  ok i will try to solve without extra space\\n"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to do without extra space"
                    }
                ]
            },
            {
                "id": 2034321,
                "content": [
                    {
                        "username": "alokranjanjha10",
                        "content": "Happy Independence Day "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Lower Medium Class question, not that tough. We can do it guys. \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s some edge cases you might consider before submitting your solution.\\n\\n- list is empty\\n[]\\n0\\n\\n- x is not in the linked list: \\n[1]\\n0\\n[1]\\n2\\n[1,1]\\n2\\n[1,1]\\n0\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "Input -> [2,2,3,1,5,0]\nExpected -> [2,2,1,0,3,5]\nPivot is takes as '3'\nwhy is it not [0,1,2,2,3,5]?\n\nCan someone please explain how should the elements be placed in the left part of the list? Should they be in sorted order or any random order works?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`You should preserve the original relative order of the nodes in each of the two partitions.`\n\nsince the 2 come first before 1 and 0 in the input, you have to put 2 at the front"
                    },
                    {
                        "username": "booleanbit1",
                        "content": "I was able to submit after the 9th submission, the description is misleading, and so many test cases need to be considered,\\ntry below ones to test your code -\\n1. [2,1]   x=2\\n2. [3,6,5,4,8,1,7,2,4,5,6,7,2,1,2,3,4,5,77,88,3,3,3,4,4,4], x=4\\n3.  [] , x=0\\n4. [3,1], x=2\\n5. [2,4,1,1,2,3,4,2,2] , x=3\\n6. [2,0,4,1,3,1,4,0,3], x=4\\n\\nAlso try changing values of x, there could be test cases where x is not even in the list, so take care of that as well.\\n\\nThe idea behind the solution is - keep tracking the list before you get your number x, and make sure to put all the numbers strictly less than x before the numbers greater than x, and then continue the same for the list after finding x in the list.\\n"
                    },
                    {
                        "username": "Suhasumesh",
                        "content": "Tip :\\nCreate 2 dummy listnodes and two pointers pointing to them and use one listnode to store values less than x and other listnode to store value greater than x and join them and return dummy1\\'s listnode.\\nPlease do upvote if you like it. Thank you!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is not a tip, this is literally the solution"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "This is pretty straightforward:\\n1. create list1 with values lower than x while maintaining the order\\n2. create list2 with values grater or equals to x while maintaining the order\\n3. join list1 and list2\\n4. return list1 head"
                    },
                    {
                        "username": "skydodle",
                        "content": "The key here is to recognize there are two groups. One group (nodes with value less than x) should be in the front of the result list, and the other group (nodes with value >= x) should be in the latter part of result list. Therefore we can break it down to left group and right group.\\n\\nThe rest is easy. As we traverse the list, we check each node to see if it belong to left group or right group, and update left or right group along the way. In the end, connect left to right and we have a result list."
                    },
                    {
                        "username": "omeirr13",
                        "content": "but this uses extra space right?"
                    },
                    {
                        "username": "user5630Yg",
                        "content": "Are we allowed to change the val of the node? Or we need to move the node."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "It takes 2hr to solve this problem but at end it is a part of problem solving  \n\nhint for this problem:\ncreate a two different such that\n\nlst  = [1,4,3,2,5,2]\nx = 3\n\nsList = [1,2,2]  // small list contains smaller element in list than x .\nlList = [4,3,5]  // large list contains bigger or equal elemet to x.\n\nand done !\n\nmerge and return result."
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "[@omeirr13](/omeirr13)  ok i will try to solve without extra space\\n"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to do without extra space"
                    }
                ]
            },
            {
                "id": 2019561,
                "content": [
                    {
                        "username": "alokranjanjha10",
                        "content": "Happy Independence Day "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Lower Medium Class question, not that tough. We can do it guys. \\uD83D\\uDE42"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s some edge cases you might consider before submitting your solution.\\n\\n- list is empty\\n[]\\n0\\n\\n- x is not in the linked list: \\n[1]\\n0\\n[1]\\n2\\n[1,1]\\n2\\n[1,1]\\n0\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "Input -> [2,2,3,1,5,0]\nExpected -> [2,2,1,0,3,5]\nPivot is takes as '3'\nwhy is it not [0,1,2,2,3,5]?\n\nCan someone please explain how should the elements be placed in the left part of the list? Should they be in sorted order or any random order works?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`You should preserve the original relative order of the nodes in each of the two partitions.`\n\nsince the 2 come first before 1 and 0 in the input, you have to put 2 at the front"
                    },
                    {
                        "username": "booleanbit1",
                        "content": "I was able to submit after the 9th submission, the description is misleading, and so many test cases need to be considered,\\ntry below ones to test your code -\\n1. [2,1]   x=2\\n2. [3,6,5,4,8,1,7,2,4,5,6,7,2,1,2,3,4,5,77,88,3,3,3,4,4,4], x=4\\n3.  [] , x=0\\n4. [3,1], x=2\\n5. [2,4,1,1,2,3,4,2,2] , x=3\\n6. [2,0,4,1,3,1,4,0,3], x=4\\n\\nAlso try changing values of x, there could be test cases where x is not even in the list, so take care of that as well.\\n\\nThe idea behind the solution is - keep tracking the list before you get your number x, and make sure to put all the numbers strictly less than x before the numbers greater than x, and then continue the same for the list after finding x in the list.\\n"
                    },
                    {
                        "username": "Suhasumesh",
                        "content": "Tip :\\nCreate 2 dummy listnodes and two pointers pointing to them and use one listnode to store values less than x and other listnode to store value greater than x and join them and return dummy1\\'s listnode.\\nPlease do upvote if you like it. Thank you!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is not a tip, this is literally the solution"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "This is pretty straightforward:\\n1. create list1 with values lower than x while maintaining the order\\n2. create list2 with values grater or equals to x while maintaining the order\\n3. join list1 and list2\\n4. return list1 head"
                    },
                    {
                        "username": "skydodle",
                        "content": "The key here is to recognize there are two groups. One group (nodes with value less than x) should be in the front of the result list, and the other group (nodes with value >= x) should be in the latter part of result list. Therefore we can break it down to left group and right group.\\n\\nThe rest is easy. As we traverse the list, we check each node to see if it belong to left group or right group, and update left or right group along the way. In the end, connect left to right and we have a result list."
                    },
                    {
                        "username": "omeirr13",
                        "content": "but this uses extra space right?"
                    },
                    {
                        "username": "user5630Yg",
                        "content": "Are we allowed to change the val of the node? Or we need to move the node."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "It takes 2hr to solve this problem but at end it is a part of problem solving  \n\nhint for this problem:\ncreate a two different such that\n\nlst  = [1,4,3,2,5,2]\nx = 3\n\nsList = [1,2,2]  // small list contains smaller element in list than x .\nlList = [4,3,5]  // large list contains bigger or equal elemet to x.\n\nand done !\n\nmerge and return result."
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "[@omeirr13](/omeirr13)  ok i will try to solve without extra space\\n"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to do without extra space"
                    }
                ]
            },
            {
                "id": 2016039,
                "content": [
                    {
                        "username": "SubomiSultan",
                        "content": "whenever i click submit it gives an error and says solution is not defined im using python 3"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "What a Joke is this TestCase ? \\n\\n\\nInput\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\n\\nUse Testcase\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Gauravkr007](/Gauravkr007) The relative order in a partition order should remain the same, but all numbers smaller than x should come before all the numbers larger than x. Those will be your two partitions.\\nSo 0 and 2 get pulled to the front. But all other numbers keep the same order."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Mister_CK](/Mister_CK) then why 0 and 2 came before 4 if relative order should remain same."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "why do change the order of 1 and 0. The relative order should remain the same as it occurs in the original list"
                    },
                    {
                        "username": "layyy",
                        "content": "Taking two lists and two dummy heads would work"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It would, but then try this one, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Thank you leetCode, with tickets like this I see the light on the end of my learning way!"
                    },
                    {
                        "username": "RupinderKaur484",
                        "content": "So , I was confused about the statement  at first, basically all the numbers less than x should be before x, and the sequence of the rest (the numbers greater than or equal to x) should be unchanged."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the relative sequence of the numbers smaller than x should also remain the same as in the original list"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "problem say-> \\nfirst check less then x (head.val<x) value  and store a new list .\\n& again check greater then or equle  x (head.val>=x) value  and connect previous list."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then try this one as a follow up, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Hello All!\\nThis is my approach\\n\\n1. Create a new list with value -1;\\n2. First loop on the Linked list and keep adding the elements less than value \\'x\\'\\n3. Loop on the LL again and now keep adding the elements greater than and equal to value \\'x\\' in the same list.\\n4. Return the list\\n\\nI hope this help you all. Thanks...!!!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?\\n\\nSolution :-\\nA: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "deusdev",
                        "content": "I still remember the time when I couldn\\'t make any linked list problems without seeing any solutions first. I still have to improve the efficiency, but it feels good that I can do it now :D"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Me too, I HATED linked lists, just didn\\'t understand them at all. I still don\\'t like them but did manage to pass on the first go in reasonable time :) "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Works fine like this , but gives runtime error when , dummy1=node1, dummy2=node2, is written, on 5th and 6th line, instead of node1=dummy1;  node2=dummy2; . Why is this happening, how does it make a difference??\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *dummy1= new ListNode(0), *dummy2=new ListNode(0),*node1,*node2;\\n        node1=dummy1;\\n        node2=dummy2;\\n\\n        while(head)\\n        {\\n            if(head->val<x){\\n            node1->next=head;\\n            node1=node1->next;\\n        }\\n        else\\n        {\\n            node2->next=head;\\n            node2=node2->next;\\n        }\\n        \\n        head=head->next;\\n        }\\n\\n        node2->next=NULL;\\n        node1->next=dummy2->next;\\n        return dummy1->next;\\n    }\\n};\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2015881,
                "content": [
                    {
                        "username": "SubomiSultan",
                        "content": "whenever i click submit it gives an error and says solution is not defined im using python 3"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "What a Joke is this TestCase ? \\n\\n\\nInput\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\n\\nUse Testcase\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Gauravkr007](/Gauravkr007) The relative order in a partition order should remain the same, but all numbers smaller than x should come before all the numbers larger than x. Those will be your two partitions.\\nSo 0 and 2 get pulled to the front. But all other numbers keep the same order."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Mister_CK](/Mister_CK) then why 0 and 2 came before 4 if relative order should remain same."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "why do change the order of 1 and 0. The relative order should remain the same as it occurs in the original list"
                    },
                    {
                        "username": "layyy",
                        "content": "Taking two lists and two dummy heads would work"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It would, but then try this one, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Thank you leetCode, with tickets like this I see the light on the end of my learning way!"
                    },
                    {
                        "username": "RupinderKaur484",
                        "content": "So , I was confused about the statement  at first, basically all the numbers less than x should be before x, and the sequence of the rest (the numbers greater than or equal to x) should be unchanged."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the relative sequence of the numbers smaller than x should also remain the same as in the original list"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "problem say-> \\nfirst check less then x (head.val<x) value  and store a new list .\\n& again check greater then or equle  x (head.val>=x) value  and connect previous list."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then try this one as a follow up, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Hello All!\\nThis is my approach\\n\\n1. Create a new list with value -1;\\n2. First loop on the Linked list and keep adding the elements less than value \\'x\\'\\n3. Loop on the LL again and now keep adding the elements greater than and equal to value \\'x\\' in the same list.\\n4. Return the list\\n\\nI hope this help you all. Thanks...!!!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?\\n\\nSolution :-\\nA: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "deusdev",
                        "content": "I still remember the time when I couldn\\'t make any linked list problems without seeing any solutions first. I still have to improve the efficiency, but it feels good that I can do it now :D"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Me too, I HATED linked lists, just didn\\'t understand them at all. I still don\\'t like them but did manage to pass on the first go in reasonable time :) "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Works fine like this , but gives runtime error when , dummy1=node1, dummy2=node2, is written, on 5th and 6th line, instead of node1=dummy1;  node2=dummy2; . Why is this happening, how does it make a difference??\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *dummy1= new ListNode(0), *dummy2=new ListNode(0),*node1,*node2;\\n        node1=dummy1;\\n        node2=dummy2;\\n\\n        while(head)\\n        {\\n            if(head->val<x){\\n            node1->next=head;\\n            node1=node1->next;\\n        }\\n        else\\n        {\\n            node2->next=head;\\n            node2=node2->next;\\n        }\\n        \\n        head=head->next;\\n        }\\n\\n        node2->next=NULL;\\n        node1->next=dummy2->next;\\n        return dummy1->next;\\n    }\\n};\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2015878,
                "content": [
                    {
                        "username": "SubomiSultan",
                        "content": "whenever i click submit it gives an error and says solution is not defined im using python 3"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "What a Joke is this TestCase ? \\n\\n\\nInput\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\n\\nUse Testcase\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Gauravkr007](/Gauravkr007) The relative order in a partition order should remain the same, but all numbers smaller than x should come before all the numbers larger than x. Those will be your two partitions.\\nSo 0 and 2 get pulled to the front. But all other numbers keep the same order."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Mister_CK](/Mister_CK) then why 0 and 2 came before 4 if relative order should remain same."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "why do change the order of 1 and 0. The relative order should remain the same as it occurs in the original list"
                    },
                    {
                        "username": "layyy",
                        "content": "Taking two lists and two dummy heads would work"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It would, but then try this one, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Thank you leetCode, with tickets like this I see the light on the end of my learning way!"
                    },
                    {
                        "username": "RupinderKaur484",
                        "content": "So , I was confused about the statement  at first, basically all the numbers less than x should be before x, and the sequence of the rest (the numbers greater than or equal to x) should be unchanged."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the relative sequence of the numbers smaller than x should also remain the same as in the original list"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "problem say-> \\nfirst check less then x (head.val<x) value  and store a new list .\\n& again check greater then or equle  x (head.val>=x) value  and connect previous list."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then try this one as a follow up, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Hello All!\\nThis is my approach\\n\\n1. Create a new list with value -1;\\n2. First loop on the Linked list and keep adding the elements less than value \\'x\\'\\n3. Loop on the LL again and now keep adding the elements greater than and equal to value \\'x\\' in the same list.\\n4. Return the list\\n\\nI hope this help you all. Thanks...!!!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?\\n\\nSolution :-\\nA: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "deusdev",
                        "content": "I still remember the time when I couldn\\'t make any linked list problems without seeing any solutions first. I still have to improve the efficiency, but it feels good that I can do it now :D"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Me too, I HATED linked lists, just didn\\'t understand them at all. I still don\\'t like them but did manage to pass on the first go in reasonable time :) "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Works fine like this , but gives runtime error when , dummy1=node1, dummy2=node2, is written, on 5th and 6th line, instead of node1=dummy1;  node2=dummy2; . Why is this happening, how does it make a difference??\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *dummy1= new ListNode(0), *dummy2=new ListNode(0),*node1,*node2;\\n        node1=dummy1;\\n        node2=dummy2;\\n\\n        while(head)\\n        {\\n            if(head->val<x){\\n            node1->next=head;\\n            node1=node1->next;\\n        }\\n        else\\n        {\\n            node2->next=head;\\n            node2=node2->next;\\n        }\\n        \\n        head=head->next;\\n        }\\n\\n        node2->next=NULL;\\n        node1->next=dummy2->next;\\n        return dummy1->next;\\n    }\\n};\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2015667,
                "content": [
                    {
                        "username": "SubomiSultan",
                        "content": "whenever i click submit it gives an error and says solution is not defined im using python 3"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "What a Joke is this TestCase ? \\n\\n\\nInput\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\n\\nUse Testcase\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Gauravkr007](/Gauravkr007) The relative order in a partition order should remain the same, but all numbers smaller than x should come before all the numbers larger than x. Those will be your two partitions.\\nSo 0 and 2 get pulled to the front. But all other numbers keep the same order."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Mister_CK](/Mister_CK) then why 0 and 2 came before 4 if relative order should remain same."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "why do change the order of 1 and 0. The relative order should remain the same as it occurs in the original list"
                    },
                    {
                        "username": "layyy",
                        "content": "Taking two lists and two dummy heads would work"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It would, but then try this one, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Thank you leetCode, with tickets like this I see the light on the end of my learning way!"
                    },
                    {
                        "username": "RupinderKaur484",
                        "content": "So , I was confused about the statement  at first, basically all the numbers less than x should be before x, and the sequence of the rest (the numbers greater than or equal to x) should be unchanged."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the relative sequence of the numbers smaller than x should also remain the same as in the original list"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "problem say-> \\nfirst check less then x (head.val<x) value  and store a new list .\\n& again check greater then or equle  x (head.val>=x) value  and connect previous list."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then try this one as a follow up, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Hello All!\\nThis is my approach\\n\\n1. Create a new list with value -1;\\n2. First loop on the Linked list and keep adding the elements less than value \\'x\\'\\n3. Loop on the LL again and now keep adding the elements greater than and equal to value \\'x\\' in the same list.\\n4. Return the list\\n\\nI hope this help you all. Thanks...!!!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?\\n\\nSolution :-\\nA: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "deusdev",
                        "content": "I still remember the time when I couldn\\'t make any linked list problems without seeing any solutions first. I still have to improve the efficiency, but it feels good that I can do it now :D"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Me too, I HATED linked lists, just didn\\'t understand them at all. I still don\\'t like them but did manage to pass on the first go in reasonable time :) "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Works fine like this , but gives runtime error when , dummy1=node1, dummy2=node2, is written, on 5th and 6th line, instead of node1=dummy1;  node2=dummy2; . Why is this happening, how does it make a difference??\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *dummy1= new ListNode(0), *dummy2=new ListNode(0),*node1,*node2;\\n        node1=dummy1;\\n        node2=dummy2;\\n\\n        while(head)\\n        {\\n            if(head->val<x){\\n            node1->next=head;\\n            node1=node1->next;\\n        }\\n        else\\n        {\\n            node2->next=head;\\n            node2=node2->next;\\n        }\\n        \\n        head=head->next;\\n        }\\n\\n        node2->next=NULL;\\n        node1->next=dummy2->next;\\n        return dummy1->next;\\n    }\\n};\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2015666,
                "content": [
                    {
                        "username": "SubomiSultan",
                        "content": "whenever i click submit it gives an error and says solution is not defined im using python 3"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "What a Joke is this TestCase ? \\n\\n\\nInput\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\n\\nUse Testcase\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Gauravkr007](/Gauravkr007) The relative order in a partition order should remain the same, but all numbers smaller than x should come before all the numbers larger than x. Those will be your two partitions.\\nSo 0 and 2 get pulled to the front. But all other numbers keep the same order."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Mister_CK](/Mister_CK) then why 0 and 2 came before 4 if relative order should remain same."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "why do change the order of 1 and 0. The relative order should remain the same as it occurs in the original list"
                    },
                    {
                        "username": "layyy",
                        "content": "Taking two lists and two dummy heads would work"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It would, but then try this one, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Thank you leetCode, with tickets like this I see the light on the end of my learning way!"
                    },
                    {
                        "username": "RupinderKaur484",
                        "content": "So , I was confused about the statement  at first, basically all the numbers less than x should be before x, and the sequence of the rest (the numbers greater than or equal to x) should be unchanged."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the relative sequence of the numbers smaller than x should also remain the same as in the original list"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "problem say-> \\nfirst check less then x (head.val<x) value  and store a new list .\\n& again check greater then or equle  x (head.val>=x) value  and connect previous list."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then try this one as a follow up, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Hello All!\\nThis is my approach\\n\\n1. Create a new list with value -1;\\n2. First loop on the Linked list and keep adding the elements less than value \\'x\\'\\n3. Loop on the LL again and now keep adding the elements greater than and equal to value \\'x\\' in the same list.\\n4. Return the list\\n\\nI hope this help you all. Thanks...!!!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?\\n\\nSolution :-\\nA: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "deusdev",
                        "content": "I still remember the time when I couldn\\'t make any linked list problems without seeing any solutions first. I still have to improve the efficiency, but it feels good that I can do it now :D"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Me too, I HATED linked lists, just didn\\'t understand them at all. I still don\\'t like them but did manage to pass on the first go in reasonable time :) "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Works fine like this , but gives runtime error when , dummy1=node1, dummy2=node2, is written, on 5th and 6th line, instead of node1=dummy1;  node2=dummy2; . Why is this happening, how does it make a difference??\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *dummy1= new ListNode(0), *dummy2=new ListNode(0),*node1,*node2;\\n        node1=dummy1;\\n        node2=dummy2;\\n\\n        while(head)\\n        {\\n            if(head->val<x){\\n            node1->next=head;\\n            node1=node1->next;\\n        }\\n        else\\n        {\\n            node2->next=head;\\n            node2=node2->next;\\n        }\\n        \\n        head=head->next;\\n        }\\n\\n        node2->next=NULL;\\n        node1->next=dummy2->next;\\n        return dummy1->next;\\n    }\\n};\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2015621,
                "content": [
                    {
                        "username": "SubomiSultan",
                        "content": "whenever i click submit it gives an error and says solution is not defined im using python 3"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "What a Joke is this TestCase ? \\n\\n\\nInput\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\n\\nUse Testcase\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Gauravkr007](/Gauravkr007) The relative order in a partition order should remain the same, but all numbers smaller than x should come before all the numbers larger than x. Those will be your two partitions.\\nSo 0 and 2 get pulled to the front. But all other numbers keep the same order."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Mister_CK](/Mister_CK) then why 0 and 2 came before 4 if relative order should remain same."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "why do change the order of 1 and 0. The relative order should remain the same as it occurs in the original list"
                    },
                    {
                        "username": "layyy",
                        "content": "Taking two lists and two dummy heads would work"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It would, but then try this one, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Thank you leetCode, with tickets like this I see the light on the end of my learning way!"
                    },
                    {
                        "username": "RupinderKaur484",
                        "content": "So , I was confused about the statement  at first, basically all the numbers less than x should be before x, and the sequence of the rest (the numbers greater than or equal to x) should be unchanged."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the relative sequence of the numbers smaller than x should also remain the same as in the original list"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "problem say-> \\nfirst check less then x (head.val<x) value  and store a new list .\\n& again check greater then or equle  x (head.val>=x) value  and connect previous list."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then try this one as a follow up, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Hello All!\\nThis is my approach\\n\\n1. Create a new list with value -1;\\n2. First loop on the Linked list and keep adding the elements less than value \\'x\\'\\n3. Loop on the LL again and now keep adding the elements greater than and equal to value \\'x\\' in the same list.\\n4. Return the list\\n\\nI hope this help you all. Thanks...!!!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?\\n\\nSolution :-\\nA: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "deusdev",
                        "content": "I still remember the time when I couldn\\'t make any linked list problems without seeing any solutions first. I still have to improve the efficiency, but it feels good that I can do it now :D"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Me too, I HATED linked lists, just didn\\'t understand them at all. I still don\\'t like them but did manage to pass on the first go in reasonable time :) "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Works fine like this , but gives runtime error when , dummy1=node1, dummy2=node2, is written, on 5th and 6th line, instead of node1=dummy1;  node2=dummy2; . Why is this happening, how does it make a difference??\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *dummy1= new ListNode(0), *dummy2=new ListNode(0),*node1,*node2;\\n        node1=dummy1;\\n        node2=dummy2;\\n\\n        while(head)\\n        {\\n            if(head->val<x){\\n            node1->next=head;\\n            node1=node1->next;\\n        }\\n        else\\n        {\\n            node2->next=head;\\n            node2=node2->next;\\n        }\\n        \\n        head=head->next;\\n        }\\n\\n        node2->next=NULL;\\n        node1->next=dummy2->next;\\n        return dummy1->next;\\n    }\\n};\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2015554,
                "content": [
                    {
                        "username": "SubomiSultan",
                        "content": "whenever i click submit it gives an error and says solution is not defined im using python 3"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "What a Joke is this TestCase ? \\n\\n\\nInput\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\n\\nUse Testcase\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Gauravkr007](/Gauravkr007) The relative order in a partition order should remain the same, but all numbers smaller than x should come before all the numbers larger than x. Those will be your two partitions.\\nSo 0 and 2 get pulled to the front. But all other numbers keep the same order."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Mister_CK](/Mister_CK) then why 0 and 2 came before 4 if relative order should remain same."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "why do change the order of 1 and 0. The relative order should remain the same as it occurs in the original list"
                    },
                    {
                        "username": "layyy",
                        "content": "Taking two lists and two dummy heads would work"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It would, but then try this one, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Thank you leetCode, with tickets like this I see the light on the end of my learning way!"
                    },
                    {
                        "username": "RupinderKaur484",
                        "content": "So , I was confused about the statement  at first, basically all the numbers less than x should be before x, and the sequence of the rest (the numbers greater than or equal to x) should be unchanged."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the relative sequence of the numbers smaller than x should also remain the same as in the original list"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "problem say-> \\nfirst check less then x (head.val<x) value  and store a new list .\\n& again check greater then or equle  x (head.val>=x) value  and connect previous list."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then try this one as a follow up, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Hello All!\\nThis is my approach\\n\\n1. Create a new list with value -1;\\n2. First loop on the Linked list and keep adding the elements less than value \\'x\\'\\n3. Loop on the LL again and now keep adding the elements greater than and equal to value \\'x\\' in the same list.\\n4. Return the list\\n\\nI hope this help you all. Thanks...!!!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?\\n\\nSolution :-\\nA: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "deusdev",
                        "content": "I still remember the time when I couldn\\'t make any linked list problems without seeing any solutions first. I still have to improve the efficiency, but it feels good that I can do it now :D"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Me too, I HATED linked lists, just didn\\'t understand them at all. I still don\\'t like them but did manage to pass on the first go in reasonable time :) "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Works fine like this , but gives runtime error when , dummy1=node1, dummy2=node2, is written, on 5th and 6th line, instead of node1=dummy1;  node2=dummy2; . Why is this happening, how does it make a difference??\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *dummy1= new ListNode(0), *dummy2=new ListNode(0),*node1,*node2;\\n        node1=dummy1;\\n        node2=dummy2;\\n\\n        while(head)\\n        {\\n            if(head->val<x){\\n            node1->next=head;\\n            node1=node1->next;\\n        }\\n        else\\n        {\\n            node2->next=head;\\n            node2=node2->next;\\n        }\\n        \\n        head=head->next;\\n        }\\n\\n        node2->next=NULL;\\n        node1->next=dummy2->next;\\n        return dummy1->next;\\n    }\\n};\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2015480,
                "content": [
                    {
                        "username": "SubomiSultan",
                        "content": "whenever i click submit it gives an error and says solution is not defined im using python 3"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "What a Joke is this TestCase ? \\n\\n\\nInput\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\n\\nUse Testcase\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Gauravkr007](/Gauravkr007) The relative order in a partition order should remain the same, but all numbers smaller than x should come before all the numbers larger than x. Those will be your two partitions.\\nSo 0 and 2 get pulled to the front. But all other numbers keep the same order."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Mister_CK](/Mister_CK) then why 0 and 2 came before 4 if relative order should remain same."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "why do change the order of 1 and 0. The relative order should remain the same as it occurs in the original list"
                    },
                    {
                        "username": "layyy",
                        "content": "Taking two lists and two dummy heads would work"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It would, but then try this one, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Thank you leetCode, with tickets like this I see the light on the end of my learning way!"
                    },
                    {
                        "username": "RupinderKaur484",
                        "content": "So , I was confused about the statement  at first, basically all the numbers less than x should be before x, and the sequence of the rest (the numbers greater than or equal to x) should be unchanged."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the relative sequence of the numbers smaller than x should also remain the same as in the original list"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "problem say-> \\nfirst check less then x (head.val<x) value  and store a new list .\\n& again check greater then or equle  x (head.val>=x) value  and connect previous list."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then try this one as a follow up, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Hello All!\\nThis is my approach\\n\\n1. Create a new list with value -1;\\n2. First loop on the Linked list and keep adding the elements less than value \\'x\\'\\n3. Loop on the LL again and now keep adding the elements greater than and equal to value \\'x\\' in the same list.\\n4. Return the list\\n\\nI hope this help you all. Thanks...!!!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?\\n\\nSolution :-\\nA: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "deusdev",
                        "content": "I still remember the time when I couldn\\'t make any linked list problems without seeing any solutions first. I still have to improve the efficiency, but it feels good that I can do it now :D"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Me too, I HATED linked lists, just didn\\'t understand them at all. I still don\\'t like them but did manage to pass on the first go in reasonable time :) "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Works fine like this , but gives runtime error when , dummy1=node1, dummy2=node2, is written, on 5th and 6th line, instead of node1=dummy1;  node2=dummy2; . Why is this happening, how does it make a difference??\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *dummy1= new ListNode(0), *dummy2=new ListNode(0),*node1,*node2;\\n        node1=dummy1;\\n        node2=dummy2;\\n\\n        while(head)\\n        {\\n            if(head->val<x){\\n            node1->next=head;\\n            node1=node1->next;\\n        }\\n        else\\n        {\\n            node2->next=head;\\n            node2=node2->next;\\n        }\\n        \\n        head=head->next;\\n        }\\n\\n        node2->next=NULL;\\n        node1->next=dummy2->next;\\n        return dummy1->next;\\n    }\\n};\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2015425,
                "content": [
                    {
                        "username": "SubomiSultan",
                        "content": "whenever i click submit it gives an error and says solution is not defined im using python 3"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "What a Joke is this TestCase ? \\n\\n\\nInput\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\n\\nUse Testcase\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Gauravkr007](/Gauravkr007) The relative order in a partition order should remain the same, but all numbers smaller than x should come before all the numbers larger than x. Those will be your two partitions.\\nSo 0 and 2 get pulled to the front. But all other numbers keep the same order."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Mister_CK](/Mister_CK) then why 0 and 2 came before 4 if relative order should remain same."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "why do change the order of 1 and 0. The relative order should remain the same as it occurs in the original list"
                    },
                    {
                        "username": "layyy",
                        "content": "Taking two lists and two dummy heads would work"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It would, but then try this one, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Thank you leetCode, with tickets like this I see the light on the end of my learning way!"
                    },
                    {
                        "username": "RupinderKaur484",
                        "content": "So , I was confused about the statement  at first, basically all the numbers less than x should be before x, and the sequence of the rest (the numbers greater than or equal to x) should be unchanged."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the relative sequence of the numbers smaller than x should also remain the same as in the original list"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "problem say-> \\nfirst check less then x (head.val<x) value  and store a new list .\\n& again check greater then or equle  x (head.val>=x) value  and connect previous list."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then try this one as a follow up, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Hello All!\\nThis is my approach\\n\\n1. Create a new list with value -1;\\n2. First loop on the Linked list and keep adding the elements less than value \\'x\\'\\n3. Loop on the LL again and now keep adding the elements greater than and equal to value \\'x\\' in the same list.\\n4. Return the list\\n\\nI hope this help you all. Thanks...!!!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?\\n\\nSolution :-\\nA: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "deusdev",
                        "content": "I still remember the time when I couldn\\'t make any linked list problems without seeing any solutions first. I still have to improve the efficiency, but it feels good that I can do it now :D"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Me too, I HATED linked lists, just didn\\'t understand them at all. I still don\\'t like them but did manage to pass on the first go in reasonable time :) "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Works fine like this , but gives runtime error when , dummy1=node1, dummy2=node2, is written, on 5th and 6th line, instead of node1=dummy1;  node2=dummy2; . Why is this happening, how does it make a difference??\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *dummy1= new ListNode(0), *dummy2=new ListNode(0),*node1,*node2;\\n        node1=dummy1;\\n        node2=dummy2;\\n\\n        while(head)\\n        {\\n            if(head->val<x){\\n            node1->next=head;\\n            node1=node1->next;\\n        }\\n        else\\n        {\\n            node2->next=head;\\n            node2=node2->next;\\n        }\\n        \\n        head=head->next;\\n        }\\n\\n        node2->next=NULL;\\n        node1->next=dummy2->next;\\n        return dummy1->next;\\n    }\\n};\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2015407,
                "content": [
                    {
                        "username": "SubomiSultan",
                        "content": "whenever i click submit it gives an error and says solution is not defined im using python 3"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "What a Joke is this TestCase ? \\n\\n\\nInput\\nhead =\\n[1,4,3,0,2,5,2]\\nx =\\n3\\n\\nUse Testcase\\nOutput\\n[0,1,2,2,4,3,5]\\nExpected\\n[1,0,2,2,4,3,5]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Gauravkr007](/Gauravkr007) The relative order in a partition order should remain the same, but all numbers smaller than x should come before all the numbers larger than x. Those will be your two partitions.\\nSo 0 and 2 get pulled to the front. But all other numbers keep the same order."
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "[@Mister_CK](/Mister_CK) then why 0 and 2 came before 4 if relative order should remain same."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "why do change the order of 1 and 0. The relative order should remain the same as it occurs in the original list"
                    },
                    {
                        "username": "layyy",
                        "content": "Taking two lists and two dummy heads would work"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It would, but then try this one, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Thank you leetCode, with tickets like this I see the light on the end of my learning way!"
                    },
                    {
                        "username": "RupinderKaur484",
                        "content": "So , I was confused about the statement  at first, basically all the numbers less than x should be before x, and the sequence of the rest (the numbers greater than or equal to x) should be unchanged."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "the relative sequence of the numbers smaller than x should also remain the same as in the original list"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "problem say-> \\nfirst check less then x (head.val<x) value  and store a new list .\\n& again check greater then or equle  x (head.val>=x) value  and connect previous list."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then try this one as a follow up, where you should come up with an O(n) timen and O(1) space solution: https://leetcode.com/problems/odd-even-linked-list/"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Hello All!\\nThis is my approach\\n\\n1. Create a new list with value -1;\\n2. First loop on the Linked list and keep adding the elements less than value \\'x\\'\\n3. Loop on the LL again and now keep adding the elements greater than and equal to value \\'x\\' in the same list.\\n4. Return the list\\n\\nI hope this help you all. Thanks...!!!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "For the test case - [3,6,5,2,4,8,1,7], target = 4\\nExpected answer is - [3,2,1,6,5,4,8,7]\\n\\nWhy 2\\'s position is changed, if it is less than target and is in left of it?\\n\\nSolution :-\\nA: Numbers less than 4 (in input order) = [3, 2, 1]\\nB: Numbers greater than or equal to 4 (in input order) = [6, 5, 4, 8, 7]\\nA + B = [3, 2, 1, 6, 5, 4, 8, 7]"
                    },
                    {
                        "username": "deusdev",
                        "content": "I still remember the time when I couldn\\'t make any linked list problems without seeing any solutions first. I still have to improve the efficiency, but it feels good that I can do it now :D"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Me too, I HATED linked lists, just didn\\'t understand them at all. I still don\\'t like them but did manage to pass on the first go in reasonable time :) "
                    },
                    {
                        "username": "Utsarg",
                        "content": "Works fine like this , but gives runtime error when , dummy1=node1, dummy2=node2, is written, on 5th and 6th line, instead of node1=dummy1;  node2=dummy2; . Why is this happening, how does it make a difference??\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode *dummy1= new ListNode(0), *dummy2=new ListNode(0),*node1,*node2;\\n        node1=dummy1;\\n        node2=dummy2;\\n\\n        while(head)\\n        {\\n            if(head->val<x){\\n            node1->next=head;\\n            node1=node1->next;\\n        }\\n        else\\n        {\\n            node2->next=head;\\n            node2=node2->next;\\n        }\\n        \\n        head=head->next;\\n        }\\n\\n        node2->next=NULL;\\n        node1->next=dummy2->next;\\n        return dummy1->next;\\n    }\\n};\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2015330,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "________listOfNodes=[2,2]\\n________temp2=head\\n________i=0\\n________while i<len(listOfNodes) and temp2 is not None:\\n____________if temp2.val<=listOfNodes[i]:\\n________________t3=deepcopy(temp2)\\n________________temp2=temp2.next\\n____________elif temp2.val>listOfNodes[i]:\\n________________newNode=ListNode()\\n////////////////newNode.next=t3.next\\n________________t3.next=newNode\\n________________i+=1\\n________________temp2=temp2.next\\n\\nWhy the /// comment is causing the function to run 2 times?  Can anyone please explain. listOfNodes are all the smallest nodes present at the right of the x. i have put _ because it was not allowing indentation in comments."
                    },
                    {
                        "username": "aditi61",
                        "content": "Line 15: Char 16: runtime error: member access within misaligned address 0x00000000000d for type \\'ListNode\\', which requires 8 byte alignment (__ListNodeUtils__.cpp)\\n0x00000000000d: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior __ListNodeUtils__.cpp:24:16 I am getting this error anyone knows the reason?\\n\\nListNode* partition(ListNode* head, int x) {\\n        vector<int>smaller;\\n        vector<int>greater;\\n        ListNode* curr = head;\\n        while(curr){\\n            if(curr->val>=x) greater.push_back(curr->val);\\n            else smaller.push_back(curr->val);\\n            curr= curr->next;\\n        }\\n        for(int i=0;i<greater.size();i++){\\n            smaller.push_back(greater[i]);\\n        }\\n        ListNode* ans;\\n        ListNode* temp = ans;\\n      for(int i=0;i<smaller.size();i++){\\n            temp= new ListNode(smaller[i]);\\n            temp = temp->next;\\n            \\n        }\\n        return ans;\\n\\n        \\n    }"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "I found implementation confusing. :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy Independence Day \\uD83D\\uDD05"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "ListNode* partition(ListNode* head, int x) {\\n        if(head  == NULL || head->next == NULL) return head;\\n        ListNode *temp = head,*prev = head ,*temp1=head;\\n        temp = temp->next;\\n        while(temp != NULL){\\n            if(temp->val >= x){\\n                temp1 = temp;\\n                temp = temp->next;\\n            }\\n            else{\\n                temp1->next = temp->next;\\n                temp->next = prev->next;\\n                prev->next = temp;\\n                prev = prev->next;\\n                temp=temp1->next;\\n            }\\n        }\\n        return head;\\n    }\\n\\nwhy it is  giving TLE !!!!\\ncan anyone tell me where it went wrong"
                    },
                    {
                        "username": "imtiaj007",
                        "content": "The description is pretty much tricky and examples are not very much sufficient. It took me 4 wrong submissions to understand the problem. Actually the problem is -\\n\\nCheck from the starting node, if the node is less than X then, place it before the nodes that are greater than or equal to X. And one thing to keep in mind you must maintain the relative order of the nodes even if some node values are smaller than previous nodes.\\n\\nHere are some example test cases for your reference - \\n\\n`1 -> 4 -> 3-> 2-> 5 -> 2`     ----  k = 3  ----      `1 -> 2 -> 2 -> 4 -> 3 -> 5`\\n`1 -> 4 -> 3-> 0-> 5 -> 2`     ----  k = 2  ----      `1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 0-> 5 -> 2 -> 1`    ----  k = 2  ----      `1 -> 0 -> 1 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 1-> 5 -> 2 -> 0`    ----  k = 2  ----      `1 -> 1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`4 -> 8 -> 6-> 5-> 1 -> 7 -> 2`    ----  k = 5  ----      `4 -> 1 -> 2 -> 8 -> 6 -> 5 -> 7`\\n\\nHope this will be helpful....... If you like please upvote.......!!!!!!"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "[4,3,2,5,2]\\nx =3\\nhere x = 3 and on right hand side we have 2 , 5 , 2\\nnow preserving order ans will be\\n[4,2,2,3,5]\\nexpected answer is : [2,2,4,3,5] .. how this preserve order ???"
                    },
                    {
                        "username": "rashapredator",
                        "content": "Input: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\n\\nIs sol [2, 2, 1, 4, 3, 5] correct?"
                    },
                    {
                        "username": "rahil1202",
                        "content": "Here, we start by defining the ListNode structure which is a basic structure for a singly-linked list node.\\nThe Solution class contains the partition function, which takes the head of the linked list and the value x as inputs.\\n\\nWe create two dummy nodes, lessDummy and greaterDummy, to serve as the heads of the partitions for nodes less than x and nodes greater than or equal to x.\\nlessCurrent and greaterCurrent are pointers that will keep track of the current positions in their respective partitions.\\n\\nIn this loop, we iterate through the original linked list pointed to by head.\\nIf the current node\\'s value is less than x, we update lessCurrent to point to the current node and also update its next pointer to the current node. This effectively adds the current node to the \"less than x\" partition.\\n\\nIf the current node\\'s value is greater than or equal to x, we do the same for the greaterCurrent and the \"greater than or equal to x\" partition.\\nThe code combines the pointer assignment and node connection steps into a single line to optimize the process.\\n\\nAfter the loop completes, we need to connect the two partitions.\\nWe set the next pointer of greaterCurrent (last node in the \"greater than or equal to x\" partition) to nullptr to terminate the end of that partition.\\n\\nThen, we set the next pointer of lessCurrent (last node in the \"less than x\" partition) to point to the beginning of the \"greater than or equal to x\" partition.\\n\\nFinally, we return lessDummy.next, which is the head of the linked list containing the partitioned nodes.\\n"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy "
                    }
                ]
            },
            {
                "id": 2015311,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "________listOfNodes=[2,2]\\n________temp2=head\\n________i=0\\n________while i<len(listOfNodes) and temp2 is not None:\\n____________if temp2.val<=listOfNodes[i]:\\n________________t3=deepcopy(temp2)\\n________________temp2=temp2.next\\n____________elif temp2.val>listOfNodes[i]:\\n________________newNode=ListNode()\\n////////////////newNode.next=t3.next\\n________________t3.next=newNode\\n________________i+=1\\n________________temp2=temp2.next\\n\\nWhy the /// comment is causing the function to run 2 times?  Can anyone please explain. listOfNodes are all the smallest nodes present at the right of the x. i have put _ because it was not allowing indentation in comments."
                    },
                    {
                        "username": "aditi61",
                        "content": "Line 15: Char 16: runtime error: member access within misaligned address 0x00000000000d for type \\'ListNode\\', which requires 8 byte alignment (__ListNodeUtils__.cpp)\\n0x00000000000d: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior __ListNodeUtils__.cpp:24:16 I am getting this error anyone knows the reason?\\n\\nListNode* partition(ListNode* head, int x) {\\n        vector<int>smaller;\\n        vector<int>greater;\\n        ListNode* curr = head;\\n        while(curr){\\n            if(curr->val>=x) greater.push_back(curr->val);\\n            else smaller.push_back(curr->val);\\n            curr= curr->next;\\n        }\\n        for(int i=0;i<greater.size();i++){\\n            smaller.push_back(greater[i]);\\n        }\\n        ListNode* ans;\\n        ListNode* temp = ans;\\n      for(int i=0;i<smaller.size();i++){\\n            temp= new ListNode(smaller[i]);\\n            temp = temp->next;\\n            \\n        }\\n        return ans;\\n\\n        \\n    }"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "I found implementation confusing. :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy Independence Day \\uD83D\\uDD05"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "ListNode* partition(ListNode* head, int x) {\\n        if(head  == NULL || head->next == NULL) return head;\\n        ListNode *temp = head,*prev = head ,*temp1=head;\\n        temp = temp->next;\\n        while(temp != NULL){\\n            if(temp->val >= x){\\n                temp1 = temp;\\n                temp = temp->next;\\n            }\\n            else{\\n                temp1->next = temp->next;\\n                temp->next = prev->next;\\n                prev->next = temp;\\n                prev = prev->next;\\n                temp=temp1->next;\\n            }\\n        }\\n        return head;\\n    }\\n\\nwhy it is  giving TLE !!!!\\ncan anyone tell me where it went wrong"
                    },
                    {
                        "username": "imtiaj007",
                        "content": "The description is pretty much tricky and examples are not very much sufficient. It took me 4 wrong submissions to understand the problem. Actually the problem is -\\n\\nCheck from the starting node, if the node is less than X then, place it before the nodes that are greater than or equal to X. And one thing to keep in mind you must maintain the relative order of the nodes even if some node values are smaller than previous nodes.\\n\\nHere are some example test cases for your reference - \\n\\n`1 -> 4 -> 3-> 2-> 5 -> 2`     ----  k = 3  ----      `1 -> 2 -> 2 -> 4 -> 3 -> 5`\\n`1 -> 4 -> 3-> 0-> 5 -> 2`     ----  k = 2  ----      `1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 0-> 5 -> 2 -> 1`    ----  k = 2  ----      `1 -> 0 -> 1 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 1-> 5 -> 2 -> 0`    ----  k = 2  ----      `1 -> 1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`4 -> 8 -> 6-> 5-> 1 -> 7 -> 2`    ----  k = 5  ----      `4 -> 1 -> 2 -> 8 -> 6 -> 5 -> 7`\\n\\nHope this will be helpful....... If you like please upvote.......!!!!!!"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "[4,3,2,5,2]\\nx =3\\nhere x = 3 and on right hand side we have 2 , 5 , 2\\nnow preserving order ans will be\\n[4,2,2,3,5]\\nexpected answer is : [2,2,4,3,5] .. how this preserve order ???"
                    },
                    {
                        "username": "rashapredator",
                        "content": "Input: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\n\\nIs sol [2, 2, 1, 4, 3, 5] correct?"
                    },
                    {
                        "username": "rahil1202",
                        "content": "Here, we start by defining the ListNode structure which is a basic structure for a singly-linked list node.\\nThe Solution class contains the partition function, which takes the head of the linked list and the value x as inputs.\\n\\nWe create two dummy nodes, lessDummy and greaterDummy, to serve as the heads of the partitions for nodes less than x and nodes greater than or equal to x.\\nlessCurrent and greaterCurrent are pointers that will keep track of the current positions in their respective partitions.\\n\\nIn this loop, we iterate through the original linked list pointed to by head.\\nIf the current node\\'s value is less than x, we update lessCurrent to point to the current node and also update its next pointer to the current node. This effectively adds the current node to the \"less than x\" partition.\\n\\nIf the current node\\'s value is greater than or equal to x, we do the same for the greaterCurrent and the \"greater than or equal to x\" partition.\\nThe code combines the pointer assignment and node connection steps into a single line to optimize the process.\\n\\nAfter the loop completes, we need to connect the two partitions.\\nWe set the next pointer of greaterCurrent (last node in the \"greater than or equal to x\" partition) to nullptr to terminate the end of that partition.\\n\\nThen, we set the next pointer of lessCurrent (last node in the \"less than x\" partition) to point to the beginning of the \"greater than or equal to x\" partition.\\n\\nFinally, we return lessDummy.next, which is the head of the linked list containing the partitioned nodes.\\n"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy "
                    }
                ]
            },
            {
                "id": 2015230,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "________listOfNodes=[2,2]\\n________temp2=head\\n________i=0\\n________while i<len(listOfNodes) and temp2 is not None:\\n____________if temp2.val<=listOfNodes[i]:\\n________________t3=deepcopy(temp2)\\n________________temp2=temp2.next\\n____________elif temp2.val>listOfNodes[i]:\\n________________newNode=ListNode()\\n////////////////newNode.next=t3.next\\n________________t3.next=newNode\\n________________i+=1\\n________________temp2=temp2.next\\n\\nWhy the /// comment is causing the function to run 2 times?  Can anyone please explain. listOfNodes are all the smallest nodes present at the right of the x. i have put _ because it was not allowing indentation in comments."
                    },
                    {
                        "username": "aditi61",
                        "content": "Line 15: Char 16: runtime error: member access within misaligned address 0x00000000000d for type \\'ListNode\\', which requires 8 byte alignment (__ListNodeUtils__.cpp)\\n0x00000000000d: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior __ListNodeUtils__.cpp:24:16 I am getting this error anyone knows the reason?\\n\\nListNode* partition(ListNode* head, int x) {\\n        vector<int>smaller;\\n        vector<int>greater;\\n        ListNode* curr = head;\\n        while(curr){\\n            if(curr->val>=x) greater.push_back(curr->val);\\n            else smaller.push_back(curr->val);\\n            curr= curr->next;\\n        }\\n        for(int i=0;i<greater.size();i++){\\n            smaller.push_back(greater[i]);\\n        }\\n        ListNode* ans;\\n        ListNode* temp = ans;\\n      for(int i=0;i<smaller.size();i++){\\n            temp= new ListNode(smaller[i]);\\n            temp = temp->next;\\n            \\n        }\\n        return ans;\\n\\n        \\n    }"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "I found implementation confusing. :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy Independence Day \\uD83D\\uDD05"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "ListNode* partition(ListNode* head, int x) {\\n        if(head  == NULL || head->next == NULL) return head;\\n        ListNode *temp = head,*prev = head ,*temp1=head;\\n        temp = temp->next;\\n        while(temp != NULL){\\n            if(temp->val >= x){\\n                temp1 = temp;\\n                temp = temp->next;\\n            }\\n            else{\\n                temp1->next = temp->next;\\n                temp->next = prev->next;\\n                prev->next = temp;\\n                prev = prev->next;\\n                temp=temp1->next;\\n            }\\n        }\\n        return head;\\n    }\\n\\nwhy it is  giving TLE !!!!\\ncan anyone tell me where it went wrong"
                    },
                    {
                        "username": "imtiaj007",
                        "content": "The description is pretty much tricky and examples are not very much sufficient. It took me 4 wrong submissions to understand the problem. Actually the problem is -\\n\\nCheck from the starting node, if the node is less than X then, place it before the nodes that are greater than or equal to X. And one thing to keep in mind you must maintain the relative order of the nodes even if some node values are smaller than previous nodes.\\n\\nHere are some example test cases for your reference - \\n\\n`1 -> 4 -> 3-> 2-> 5 -> 2`     ----  k = 3  ----      `1 -> 2 -> 2 -> 4 -> 3 -> 5`\\n`1 -> 4 -> 3-> 0-> 5 -> 2`     ----  k = 2  ----      `1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 0-> 5 -> 2 -> 1`    ----  k = 2  ----      `1 -> 0 -> 1 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 1-> 5 -> 2 -> 0`    ----  k = 2  ----      `1 -> 1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`4 -> 8 -> 6-> 5-> 1 -> 7 -> 2`    ----  k = 5  ----      `4 -> 1 -> 2 -> 8 -> 6 -> 5 -> 7`\\n\\nHope this will be helpful....... If you like please upvote.......!!!!!!"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "[4,3,2,5,2]\\nx =3\\nhere x = 3 and on right hand side we have 2 , 5 , 2\\nnow preserving order ans will be\\n[4,2,2,3,5]\\nexpected answer is : [2,2,4,3,5] .. how this preserve order ???"
                    },
                    {
                        "username": "rashapredator",
                        "content": "Input: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\n\\nIs sol [2, 2, 1, 4, 3, 5] correct?"
                    },
                    {
                        "username": "rahil1202",
                        "content": "Here, we start by defining the ListNode structure which is a basic structure for a singly-linked list node.\\nThe Solution class contains the partition function, which takes the head of the linked list and the value x as inputs.\\n\\nWe create two dummy nodes, lessDummy and greaterDummy, to serve as the heads of the partitions for nodes less than x and nodes greater than or equal to x.\\nlessCurrent and greaterCurrent are pointers that will keep track of the current positions in their respective partitions.\\n\\nIn this loop, we iterate through the original linked list pointed to by head.\\nIf the current node\\'s value is less than x, we update lessCurrent to point to the current node and also update its next pointer to the current node. This effectively adds the current node to the \"less than x\" partition.\\n\\nIf the current node\\'s value is greater than or equal to x, we do the same for the greaterCurrent and the \"greater than or equal to x\" partition.\\nThe code combines the pointer assignment and node connection steps into a single line to optimize the process.\\n\\nAfter the loop completes, we need to connect the two partitions.\\nWe set the next pointer of greaterCurrent (last node in the \"greater than or equal to x\" partition) to nullptr to terminate the end of that partition.\\n\\nThen, we set the next pointer of lessCurrent (last node in the \"less than x\" partition) to point to the beginning of the \"greater than or equal to x\" partition.\\n\\nFinally, we return lessDummy.next, which is the head of the linked list containing the partitioned nodes.\\n"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy "
                    }
                ]
            },
            {
                "id": 2015215,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "________listOfNodes=[2,2]\\n________temp2=head\\n________i=0\\n________while i<len(listOfNodes) and temp2 is not None:\\n____________if temp2.val<=listOfNodes[i]:\\n________________t3=deepcopy(temp2)\\n________________temp2=temp2.next\\n____________elif temp2.val>listOfNodes[i]:\\n________________newNode=ListNode()\\n////////////////newNode.next=t3.next\\n________________t3.next=newNode\\n________________i+=1\\n________________temp2=temp2.next\\n\\nWhy the /// comment is causing the function to run 2 times?  Can anyone please explain. listOfNodes are all the smallest nodes present at the right of the x. i have put _ because it was not allowing indentation in comments."
                    },
                    {
                        "username": "aditi61",
                        "content": "Line 15: Char 16: runtime error: member access within misaligned address 0x00000000000d for type \\'ListNode\\', which requires 8 byte alignment (__ListNodeUtils__.cpp)\\n0x00000000000d: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior __ListNodeUtils__.cpp:24:16 I am getting this error anyone knows the reason?\\n\\nListNode* partition(ListNode* head, int x) {\\n        vector<int>smaller;\\n        vector<int>greater;\\n        ListNode* curr = head;\\n        while(curr){\\n            if(curr->val>=x) greater.push_back(curr->val);\\n            else smaller.push_back(curr->val);\\n            curr= curr->next;\\n        }\\n        for(int i=0;i<greater.size();i++){\\n            smaller.push_back(greater[i]);\\n        }\\n        ListNode* ans;\\n        ListNode* temp = ans;\\n      for(int i=0;i<smaller.size();i++){\\n            temp= new ListNode(smaller[i]);\\n            temp = temp->next;\\n            \\n        }\\n        return ans;\\n\\n        \\n    }"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "I found implementation confusing. :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy Independence Day \\uD83D\\uDD05"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "ListNode* partition(ListNode* head, int x) {\\n        if(head  == NULL || head->next == NULL) return head;\\n        ListNode *temp = head,*prev = head ,*temp1=head;\\n        temp = temp->next;\\n        while(temp != NULL){\\n            if(temp->val >= x){\\n                temp1 = temp;\\n                temp = temp->next;\\n            }\\n            else{\\n                temp1->next = temp->next;\\n                temp->next = prev->next;\\n                prev->next = temp;\\n                prev = prev->next;\\n                temp=temp1->next;\\n            }\\n        }\\n        return head;\\n    }\\n\\nwhy it is  giving TLE !!!!\\ncan anyone tell me where it went wrong"
                    },
                    {
                        "username": "imtiaj007",
                        "content": "The description is pretty much tricky and examples are not very much sufficient. It took me 4 wrong submissions to understand the problem. Actually the problem is -\\n\\nCheck from the starting node, if the node is less than X then, place it before the nodes that are greater than or equal to X. And one thing to keep in mind you must maintain the relative order of the nodes even if some node values are smaller than previous nodes.\\n\\nHere are some example test cases for your reference - \\n\\n`1 -> 4 -> 3-> 2-> 5 -> 2`     ----  k = 3  ----      `1 -> 2 -> 2 -> 4 -> 3 -> 5`\\n`1 -> 4 -> 3-> 0-> 5 -> 2`     ----  k = 2  ----      `1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 0-> 5 -> 2 -> 1`    ----  k = 2  ----      `1 -> 0 -> 1 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 1-> 5 -> 2 -> 0`    ----  k = 2  ----      `1 -> 1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`4 -> 8 -> 6-> 5-> 1 -> 7 -> 2`    ----  k = 5  ----      `4 -> 1 -> 2 -> 8 -> 6 -> 5 -> 7`\\n\\nHope this will be helpful....... If you like please upvote.......!!!!!!"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "[4,3,2,5,2]\\nx =3\\nhere x = 3 and on right hand side we have 2 , 5 , 2\\nnow preserving order ans will be\\n[4,2,2,3,5]\\nexpected answer is : [2,2,4,3,5] .. how this preserve order ???"
                    },
                    {
                        "username": "rashapredator",
                        "content": "Input: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\n\\nIs sol [2, 2, 1, 4, 3, 5] correct?"
                    },
                    {
                        "username": "rahil1202",
                        "content": "Here, we start by defining the ListNode structure which is a basic structure for a singly-linked list node.\\nThe Solution class contains the partition function, which takes the head of the linked list and the value x as inputs.\\n\\nWe create two dummy nodes, lessDummy and greaterDummy, to serve as the heads of the partitions for nodes less than x and nodes greater than or equal to x.\\nlessCurrent and greaterCurrent are pointers that will keep track of the current positions in their respective partitions.\\n\\nIn this loop, we iterate through the original linked list pointed to by head.\\nIf the current node\\'s value is less than x, we update lessCurrent to point to the current node and also update its next pointer to the current node. This effectively adds the current node to the \"less than x\" partition.\\n\\nIf the current node\\'s value is greater than or equal to x, we do the same for the greaterCurrent and the \"greater than or equal to x\" partition.\\nThe code combines the pointer assignment and node connection steps into a single line to optimize the process.\\n\\nAfter the loop completes, we need to connect the two partitions.\\nWe set the next pointer of greaterCurrent (last node in the \"greater than or equal to x\" partition) to nullptr to terminate the end of that partition.\\n\\nThen, we set the next pointer of lessCurrent (last node in the \"less than x\" partition) to point to the beginning of the \"greater than or equal to x\" partition.\\n\\nFinally, we return lessDummy.next, which is the head of the linked list containing the partitioned nodes.\\n"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy "
                    }
                ]
            },
            {
                "id": 2015202,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "________listOfNodes=[2,2]\\n________temp2=head\\n________i=0\\n________while i<len(listOfNodes) and temp2 is not None:\\n____________if temp2.val<=listOfNodes[i]:\\n________________t3=deepcopy(temp2)\\n________________temp2=temp2.next\\n____________elif temp2.val>listOfNodes[i]:\\n________________newNode=ListNode()\\n////////////////newNode.next=t3.next\\n________________t3.next=newNode\\n________________i+=1\\n________________temp2=temp2.next\\n\\nWhy the /// comment is causing the function to run 2 times?  Can anyone please explain. listOfNodes are all the smallest nodes present at the right of the x. i have put _ because it was not allowing indentation in comments."
                    },
                    {
                        "username": "aditi61",
                        "content": "Line 15: Char 16: runtime error: member access within misaligned address 0x00000000000d for type \\'ListNode\\', which requires 8 byte alignment (__ListNodeUtils__.cpp)\\n0x00000000000d: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior __ListNodeUtils__.cpp:24:16 I am getting this error anyone knows the reason?\\n\\nListNode* partition(ListNode* head, int x) {\\n        vector<int>smaller;\\n        vector<int>greater;\\n        ListNode* curr = head;\\n        while(curr){\\n            if(curr->val>=x) greater.push_back(curr->val);\\n            else smaller.push_back(curr->val);\\n            curr= curr->next;\\n        }\\n        for(int i=0;i<greater.size();i++){\\n            smaller.push_back(greater[i]);\\n        }\\n        ListNode* ans;\\n        ListNode* temp = ans;\\n      for(int i=0;i<smaller.size();i++){\\n            temp= new ListNode(smaller[i]);\\n            temp = temp->next;\\n            \\n        }\\n        return ans;\\n\\n        \\n    }"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "I found implementation confusing. :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy Independence Day \\uD83D\\uDD05"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "ListNode* partition(ListNode* head, int x) {\\n        if(head  == NULL || head->next == NULL) return head;\\n        ListNode *temp = head,*prev = head ,*temp1=head;\\n        temp = temp->next;\\n        while(temp != NULL){\\n            if(temp->val >= x){\\n                temp1 = temp;\\n                temp = temp->next;\\n            }\\n            else{\\n                temp1->next = temp->next;\\n                temp->next = prev->next;\\n                prev->next = temp;\\n                prev = prev->next;\\n                temp=temp1->next;\\n            }\\n        }\\n        return head;\\n    }\\n\\nwhy it is  giving TLE !!!!\\ncan anyone tell me where it went wrong"
                    },
                    {
                        "username": "imtiaj007",
                        "content": "The description is pretty much tricky and examples are not very much sufficient. It took me 4 wrong submissions to understand the problem. Actually the problem is -\\n\\nCheck from the starting node, if the node is less than X then, place it before the nodes that are greater than or equal to X. And one thing to keep in mind you must maintain the relative order of the nodes even if some node values are smaller than previous nodes.\\n\\nHere are some example test cases for your reference - \\n\\n`1 -> 4 -> 3-> 2-> 5 -> 2`     ----  k = 3  ----      `1 -> 2 -> 2 -> 4 -> 3 -> 5`\\n`1 -> 4 -> 3-> 0-> 5 -> 2`     ----  k = 2  ----      `1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 0-> 5 -> 2 -> 1`    ----  k = 2  ----      `1 -> 0 -> 1 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 1-> 5 -> 2 -> 0`    ----  k = 2  ----      `1 -> 1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`4 -> 8 -> 6-> 5-> 1 -> 7 -> 2`    ----  k = 5  ----      `4 -> 1 -> 2 -> 8 -> 6 -> 5 -> 7`\\n\\nHope this will be helpful....... If you like please upvote.......!!!!!!"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "[4,3,2,5,2]\\nx =3\\nhere x = 3 and on right hand side we have 2 , 5 , 2\\nnow preserving order ans will be\\n[4,2,2,3,5]\\nexpected answer is : [2,2,4,3,5] .. how this preserve order ???"
                    },
                    {
                        "username": "rashapredator",
                        "content": "Input: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\n\\nIs sol [2, 2, 1, 4, 3, 5] correct?"
                    },
                    {
                        "username": "rahil1202",
                        "content": "Here, we start by defining the ListNode structure which is a basic structure for a singly-linked list node.\\nThe Solution class contains the partition function, which takes the head of the linked list and the value x as inputs.\\n\\nWe create two dummy nodes, lessDummy and greaterDummy, to serve as the heads of the partitions for nodes less than x and nodes greater than or equal to x.\\nlessCurrent and greaterCurrent are pointers that will keep track of the current positions in their respective partitions.\\n\\nIn this loop, we iterate through the original linked list pointed to by head.\\nIf the current node\\'s value is less than x, we update lessCurrent to point to the current node and also update its next pointer to the current node. This effectively adds the current node to the \"less than x\" partition.\\n\\nIf the current node\\'s value is greater than or equal to x, we do the same for the greaterCurrent and the \"greater than or equal to x\" partition.\\nThe code combines the pointer assignment and node connection steps into a single line to optimize the process.\\n\\nAfter the loop completes, we need to connect the two partitions.\\nWe set the next pointer of greaterCurrent (last node in the \"greater than or equal to x\" partition) to nullptr to terminate the end of that partition.\\n\\nThen, we set the next pointer of lessCurrent (last node in the \"less than x\" partition) to point to the beginning of the \"greater than or equal to x\" partition.\\n\\nFinally, we return lessDummy.next, which is the head of the linked list containing the partitioned nodes.\\n"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy "
                    }
                ]
            },
            {
                "id": 2015198,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "________listOfNodes=[2,2]\\n________temp2=head\\n________i=0\\n________while i<len(listOfNodes) and temp2 is not None:\\n____________if temp2.val<=listOfNodes[i]:\\n________________t3=deepcopy(temp2)\\n________________temp2=temp2.next\\n____________elif temp2.val>listOfNodes[i]:\\n________________newNode=ListNode()\\n////////////////newNode.next=t3.next\\n________________t3.next=newNode\\n________________i+=1\\n________________temp2=temp2.next\\n\\nWhy the /// comment is causing the function to run 2 times?  Can anyone please explain. listOfNodes are all the smallest nodes present at the right of the x. i have put _ because it was not allowing indentation in comments."
                    },
                    {
                        "username": "aditi61",
                        "content": "Line 15: Char 16: runtime error: member access within misaligned address 0x00000000000d for type \\'ListNode\\', which requires 8 byte alignment (__ListNodeUtils__.cpp)\\n0x00000000000d: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior __ListNodeUtils__.cpp:24:16 I am getting this error anyone knows the reason?\\n\\nListNode* partition(ListNode* head, int x) {\\n        vector<int>smaller;\\n        vector<int>greater;\\n        ListNode* curr = head;\\n        while(curr){\\n            if(curr->val>=x) greater.push_back(curr->val);\\n            else smaller.push_back(curr->val);\\n            curr= curr->next;\\n        }\\n        for(int i=0;i<greater.size();i++){\\n            smaller.push_back(greater[i]);\\n        }\\n        ListNode* ans;\\n        ListNode* temp = ans;\\n      for(int i=0;i<smaller.size();i++){\\n            temp= new ListNode(smaller[i]);\\n            temp = temp->next;\\n            \\n        }\\n        return ans;\\n\\n        \\n    }"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "I found implementation confusing. :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy Independence Day \\uD83D\\uDD05"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "ListNode* partition(ListNode* head, int x) {\\n        if(head  == NULL || head->next == NULL) return head;\\n        ListNode *temp = head,*prev = head ,*temp1=head;\\n        temp = temp->next;\\n        while(temp != NULL){\\n            if(temp->val >= x){\\n                temp1 = temp;\\n                temp = temp->next;\\n            }\\n            else{\\n                temp1->next = temp->next;\\n                temp->next = prev->next;\\n                prev->next = temp;\\n                prev = prev->next;\\n                temp=temp1->next;\\n            }\\n        }\\n        return head;\\n    }\\n\\nwhy it is  giving TLE !!!!\\ncan anyone tell me where it went wrong"
                    },
                    {
                        "username": "imtiaj007",
                        "content": "The description is pretty much tricky and examples are not very much sufficient. It took me 4 wrong submissions to understand the problem. Actually the problem is -\\n\\nCheck from the starting node, if the node is less than X then, place it before the nodes that are greater than or equal to X. And one thing to keep in mind you must maintain the relative order of the nodes even if some node values are smaller than previous nodes.\\n\\nHere are some example test cases for your reference - \\n\\n`1 -> 4 -> 3-> 2-> 5 -> 2`     ----  k = 3  ----      `1 -> 2 -> 2 -> 4 -> 3 -> 5`\\n`1 -> 4 -> 3-> 0-> 5 -> 2`     ----  k = 2  ----      `1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 0-> 5 -> 2 -> 1`    ----  k = 2  ----      `1 -> 0 -> 1 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 1-> 5 -> 2 -> 0`    ----  k = 2  ----      `1 -> 1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`4 -> 8 -> 6-> 5-> 1 -> 7 -> 2`    ----  k = 5  ----      `4 -> 1 -> 2 -> 8 -> 6 -> 5 -> 7`\\n\\nHope this will be helpful....... If you like please upvote.......!!!!!!"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "[4,3,2,5,2]\\nx =3\\nhere x = 3 and on right hand side we have 2 , 5 , 2\\nnow preserving order ans will be\\n[4,2,2,3,5]\\nexpected answer is : [2,2,4,3,5] .. how this preserve order ???"
                    },
                    {
                        "username": "rashapredator",
                        "content": "Input: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\n\\nIs sol [2, 2, 1, 4, 3, 5] correct?"
                    },
                    {
                        "username": "rahil1202",
                        "content": "Here, we start by defining the ListNode structure which is a basic structure for a singly-linked list node.\\nThe Solution class contains the partition function, which takes the head of the linked list and the value x as inputs.\\n\\nWe create two dummy nodes, lessDummy and greaterDummy, to serve as the heads of the partitions for nodes less than x and nodes greater than or equal to x.\\nlessCurrent and greaterCurrent are pointers that will keep track of the current positions in their respective partitions.\\n\\nIn this loop, we iterate through the original linked list pointed to by head.\\nIf the current node\\'s value is less than x, we update lessCurrent to point to the current node and also update its next pointer to the current node. This effectively adds the current node to the \"less than x\" partition.\\n\\nIf the current node\\'s value is greater than or equal to x, we do the same for the greaterCurrent and the \"greater than or equal to x\" partition.\\nThe code combines the pointer assignment and node connection steps into a single line to optimize the process.\\n\\nAfter the loop completes, we need to connect the two partitions.\\nWe set the next pointer of greaterCurrent (last node in the \"greater than or equal to x\" partition) to nullptr to terminate the end of that partition.\\n\\nThen, we set the next pointer of lessCurrent (last node in the \"less than x\" partition) to point to the beginning of the \"greater than or equal to x\" partition.\\n\\nFinally, we return lessDummy.next, which is the head of the linked list containing the partitioned nodes.\\n"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy "
                    }
                ]
            },
            {
                "id": 2015030,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "________listOfNodes=[2,2]\\n________temp2=head\\n________i=0\\n________while i<len(listOfNodes) and temp2 is not None:\\n____________if temp2.val<=listOfNodes[i]:\\n________________t3=deepcopy(temp2)\\n________________temp2=temp2.next\\n____________elif temp2.val>listOfNodes[i]:\\n________________newNode=ListNode()\\n////////////////newNode.next=t3.next\\n________________t3.next=newNode\\n________________i+=1\\n________________temp2=temp2.next\\n\\nWhy the /// comment is causing the function to run 2 times?  Can anyone please explain. listOfNodes are all the smallest nodes present at the right of the x. i have put _ because it was not allowing indentation in comments."
                    },
                    {
                        "username": "aditi61",
                        "content": "Line 15: Char 16: runtime error: member access within misaligned address 0x00000000000d for type \\'ListNode\\', which requires 8 byte alignment (__ListNodeUtils__.cpp)\\n0x00000000000d: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior __ListNodeUtils__.cpp:24:16 I am getting this error anyone knows the reason?\\n\\nListNode* partition(ListNode* head, int x) {\\n        vector<int>smaller;\\n        vector<int>greater;\\n        ListNode* curr = head;\\n        while(curr){\\n            if(curr->val>=x) greater.push_back(curr->val);\\n            else smaller.push_back(curr->val);\\n            curr= curr->next;\\n        }\\n        for(int i=0;i<greater.size();i++){\\n            smaller.push_back(greater[i]);\\n        }\\n        ListNode* ans;\\n        ListNode* temp = ans;\\n      for(int i=0;i<smaller.size();i++){\\n            temp= new ListNode(smaller[i]);\\n            temp = temp->next;\\n            \\n        }\\n        return ans;\\n\\n        \\n    }"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "I found implementation confusing. :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy Independence Day \\uD83D\\uDD05"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "ListNode* partition(ListNode* head, int x) {\\n        if(head  == NULL || head->next == NULL) return head;\\n        ListNode *temp = head,*prev = head ,*temp1=head;\\n        temp = temp->next;\\n        while(temp != NULL){\\n            if(temp->val >= x){\\n                temp1 = temp;\\n                temp = temp->next;\\n            }\\n            else{\\n                temp1->next = temp->next;\\n                temp->next = prev->next;\\n                prev->next = temp;\\n                prev = prev->next;\\n                temp=temp1->next;\\n            }\\n        }\\n        return head;\\n    }\\n\\nwhy it is  giving TLE !!!!\\ncan anyone tell me where it went wrong"
                    },
                    {
                        "username": "imtiaj007",
                        "content": "The description is pretty much tricky and examples are not very much sufficient. It took me 4 wrong submissions to understand the problem. Actually the problem is -\\n\\nCheck from the starting node, if the node is less than X then, place it before the nodes that are greater than or equal to X. And one thing to keep in mind you must maintain the relative order of the nodes even if some node values are smaller than previous nodes.\\n\\nHere are some example test cases for your reference - \\n\\n`1 -> 4 -> 3-> 2-> 5 -> 2`     ----  k = 3  ----      `1 -> 2 -> 2 -> 4 -> 3 -> 5`\\n`1 -> 4 -> 3-> 0-> 5 -> 2`     ----  k = 2  ----      `1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 0-> 5 -> 2 -> 1`    ----  k = 2  ----      `1 -> 0 -> 1 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 1-> 5 -> 2 -> 0`    ----  k = 2  ----      `1 -> 1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`4 -> 8 -> 6-> 5-> 1 -> 7 -> 2`    ----  k = 5  ----      `4 -> 1 -> 2 -> 8 -> 6 -> 5 -> 7`\\n\\nHope this will be helpful....... If you like please upvote.......!!!!!!"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "[4,3,2,5,2]\\nx =3\\nhere x = 3 and on right hand side we have 2 , 5 , 2\\nnow preserving order ans will be\\n[4,2,2,3,5]\\nexpected answer is : [2,2,4,3,5] .. how this preserve order ???"
                    },
                    {
                        "username": "rashapredator",
                        "content": "Input: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\n\\nIs sol [2, 2, 1, 4, 3, 5] correct?"
                    },
                    {
                        "username": "rahil1202",
                        "content": "Here, we start by defining the ListNode structure which is a basic structure for a singly-linked list node.\\nThe Solution class contains the partition function, which takes the head of the linked list and the value x as inputs.\\n\\nWe create two dummy nodes, lessDummy and greaterDummy, to serve as the heads of the partitions for nodes less than x and nodes greater than or equal to x.\\nlessCurrent and greaterCurrent are pointers that will keep track of the current positions in their respective partitions.\\n\\nIn this loop, we iterate through the original linked list pointed to by head.\\nIf the current node\\'s value is less than x, we update lessCurrent to point to the current node and also update its next pointer to the current node. This effectively adds the current node to the \"less than x\" partition.\\n\\nIf the current node\\'s value is greater than or equal to x, we do the same for the greaterCurrent and the \"greater than or equal to x\" partition.\\nThe code combines the pointer assignment and node connection steps into a single line to optimize the process.\\n\\nAfter the loop completes, we need to connect the two partitions.\\nWe set the next pointer of greaterCurrent (last node in the \"greater than or equal to x\" partition) to nullptr to terminate the end of that partition.\\n\\nThen, we set the next pointer of lessCurrent (last node in the \"less than x\" partition) to point to the beginning of the \"greater than or equal to x\" partition.\\n\\nFinally, we return lessDummy.next, which is the head of the linked list containing the partitioned nodes.\\n"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy "
                    }
                ]
            },
            {
                "id": 2015028,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "________listOfNodes=[2,2]\\n________temp2=head\\n________i=0\\n________while i<len(listOfNodes) and temp2 is not None:\\n____________if temp2.val<=listOfNodes[i]:\\n________________t3=deepcopy(temp2)\\n________________temp2=temp2.next\\n____________elif temp2.val>listOfNodes[i]:\\n________________newNode=ListNode()\\n////////////////newNode.next=t3.next\\n________________t3.next=newNode\\n________________i+=1\\n________________temp2=temp2.next\\n\\nWhy the /// comment is causing the function to run 2 times?  Can anyone please explain. listOfNodes are all the smallest nodes present at the right of the x. i have put _ because it was not allowing indentation in comments."
                    },
                    {
                        "username": "aditi61",
                        "content": "Line 15: Char 16: runtime error: member access within misaligned address 0x00000000000d for type \\'ListNode\\', which requires 8 byte alignment (__ListNodeUtils__.cpp)\\n0x00000000000d: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior __ListNodeUtils__.cpp:24:16 I am getting this error anyone knows the reason?\\n\\nListNode* partition(ListNode* head, int x) {\\n        vector<int>smaller;\\n        vector<int>greater;\\n        ListNode* curr = head;\\n        while(curr){\\n            if(curr->val>=x) greater.push_back(curr->val);\\n            else smaller.push_back(curr->val);\\n            curr= curr->next;\\n        }\\n        for(int i=0;i<greater.size();i++){\\n            smaller.push_back(greater[i]);\\n        }\\n        ListNode* ans;\\n        ListNode* temp = ans;\\n      for(int i=0;i<smaller.size();i++){\\n            temp= new ListNode(smaller[i]);\\n            temp = temp->next;\\n            \\n        }\\n        return ans;\\n\\n        \\n    }"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "I found implementation confusing. :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy Independence Day \\uD83D\\uDD05"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "ListNode* partition(ListNode* head, int x) {\\n        if(head  == NULL || head->next == NULL) return head;\\n        ListNode *temp = head,*prev = head ,*temp1=head;\\n        temp = temp->next;\\n        while(temp != NULL){\\n            if(temp->val >= x){\\n                temp1 = temp;\\n                temp = temp->next;\\n            }\\n            else{\\n                temp1->next = temp->next;\\n                temp->next = prev->next;\\n                prev->next = temp;\\n                prev = prev->next;\\n                temp=temp1->next;\\n            }\\n        }\\n        return head;\\n    }\\n\\nwhy it is  giving TLE !!!!\\ncan anyone tell me where it went wrong"
                    },
                    {
                        "username": "imtiaj007",
                        "content": "The description is pretty much tricky and examples are not very much sufficient. It took me 4 wrong submissions to understand the problem. Actually the problem is -\\n\\nCheck from the starting node, if the node is less than X then, place it before the nodes that are greater than or equal to X. And one thing to keep in mind you must maintain the relative order of the nodes even if some node values are smaller than previous nodes.\\n\\nHere are some example test cases for your reference - \\n\\n`1 -> 4 -> 3-> 2-> 5 -> 2`     ----  k = 3  ----      `1 -> 2 -> 2 -> 4 -> 3 -> 5`\\n`1 -> 4 -> 3-> 0-> 5 -> 2`     ----  k = 2  ----      `1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 0-> 5 -> 2 -> 1`    ----  k = 2  ----      `1 -> 0 -> 1 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 1-> 5 -> 2 -> 0`    ----  k = 2  ----      `1 -> 1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`4 -> 8 -> 6-> 5-> 1 -> 7 -> 2`    ----  k = 5  ----      `4 -> 1 -> 2 -> 8 -> 6 -> 5 -> 7`\\n\\nHope this will be helpful....... If you like please upvote.......!!!!!!"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "[4,3,2,5,2]\\nx =3\\nhere x = 3 and on right hand side we have 2 , 5 , 2\\nnow preserving order ans will be\\n[4,2,2,3,5]\\nexpected answer is : [2,2,4,3,5] .. how this preserve order ???"
                    },
                    {
                        "username": "rashapredator",
                        "content": "Input: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\n\\nIs sol [2, 2, 1, 4, 3, 5] correct?"
                    },
                    {
                        "username": "rahil1202",
                        "content": "Here, we start by defining the ListNode structure which is a basic structure for a singly-linked list node.\\nThe Solution class contains the partition function, which takes the head of the linked list and the value x as inputs.\\n\\nWe create two dummy nodes, lessDummy and greaterDummy, to serve as the heads of the partitions for nodes less than x and nodes greater than or equal to x.\\nlessCurrent and greaterCurrent are pointers that will keep track of the current positions in their respective partitions.\\n\\nIn this loop, we iterate through the original linked list pointed to by head.\\nIf the current node\\'s value is less than x, we update lessCurrent to point to the current node and also update its next pointer to the current node. This effectively adds the current node to the \"less than x\" partition.\\n\\nIf the current node\\'s value is greater than or equal to x, we do the same for the greaterCurrent and the \"greater than or equal to x\" partition.\\nThe code combines the pointer assignment and node connection steps into a single line to optimize the process.\\n\\nAfter the loop completes, we need to connect the two partitions.\\nWe set the next pointer of greaterCurrent (last node in the \"greater than or equal to x\" partition) to nullptr to terminate the end of that partition.\\n\\nThen, we set the next pointer of lessCurrent (last node in the \"less than x\" partition) to point to the beginning of the \"greater than or equal to x\" partition.\\n\\nFinally, we return lessDummy.next, which is the head of the linked list containing the partitioned nodes.\\n"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy "
                    }
                ]
            },
            {
                "id": 2014901,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "________listOfNodes=[2,2]\\n________temp2=head\\n________i=0\\n________while i<len(listOfNodes) and temp2 is not None:\\n____________if temp2.val<=listOfNodes[i]:\\n________________t3=deepcopy(temp2)\\n________________temp2=temp2.next\\n____________elif temp2.val>listOfNodes[i]:\\n________________newNode=ListNode()\\n////////////////newNode.next=t3.next\\n________________t3.next=newNode\\n________________i+=1\\n________________temp2=temp2.next\\n\\nWhy the /// comment is causing the function to run 2 times?  Can anyone please explain. listOfNodes are all the smallest nodes present at the right of the x. i have put _ because it was not allowing indentation in comments."
                    },
                    {
                        "username": "aditi61",
                        "content": "Line 15: Char 16: runtime error: member access within misaligned address 0x00000000000d for type \\'ListNode\\', which requires 8 byte alignment (__ListNodeUtils__.cpp)\\n0x00000000000d: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior __ListNodeUtils__.cpp:24:16 I am getting this error anyone knows the reason?\\n\\nListNode* partition(ListNode* head, int x) {\\n        vector<int>smaller;\\n        vector<int>greater;\\n        ListNode* curr = head;\\n        while(curr){\\n            if(curr->val>=x) greater.push_back(curr->val);\\n            else smaller.push_back(curr->val);\\n            curr= curr->next;\\n        }\\n        for(int i=0;i<greater.size();i++){\\n            smaller.push_back(greater[i]);\\n        }\\n        ListNode* ans;\\n        ListNode* temp = ans;\\n      for(int i=0;i<smaller.size();i++){\\n            temp= new ListNode(smaller[i]);\\n            temp = temp->next;\\n            \\n        }\\n        return ans;\\n\\n        \\n    }"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "I found implementation confusing. :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy Independence Day \\uD83D\\uDD05"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "ListNode* partition(ListNode* head, int x) {\\n        if(head  == NULL || head->next == NULL) return head;\\n        ListNode *temp = head,*prev = head ,*temp1=head;\\n        temp = temp->next;\\n        while(temp != NULL){\\n            if(temp->val >= x){\\n                temp1 = temp;\\n                temp = temp->next;\\n            }\\n            else{\\n                temp1->next = temp->next;\\n                temp->next = prev->next;\\n                prev->next = temp;\\n                prev = prev->next;\\n                temp=temp1->next;\\n            }\\n        }\\n        return head;\\n    }\\n\\nwhy it is  giving TLE !!!!\\ncan anyone tell me where it went wrong"
                    },
                    {
                        "username": "imtiaj007",
                        "content": "The description is pretty much tricky and examples are not very much sufficient. It took me 4 wrong submissions to understand the problem. Actually the problem is -\\n\\nCheck from the starting node, if the node is less than X then, place it before the nodes that are greater than or equal to X. And one thing to keep in mind you must maintain the relative order of the nodes even if some node values are smaller than previous nodes.\\n\\nHere are some example test cases for your reference - \\n\\n`1 -> 4 -> 3-> 2-> 5 -> 2`     ----  k = 3  ----      `1 -> 2 -> 2 -> 4 -> 3 -> 5`\\n`1 -> 4 -> 3-> 0-> 5 -> 2`     ----  k = 2  ----      `1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 0-> 5 -> 2 -> 1`    ----  k = 2  ----      `1 -> 0 -> 1 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 1-> 5 -> 2 -> 0`    ----  k = 2  ----      `1 -> 1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`4 -> 8 -> 6-> 5-> 1 -> 7 -> 2`    ----  k = 5  ----      `4 -> 1 -> 2 -> 8 -> 6 -> 5 -> 7`\\n\\nHope this will be helpful....... If you like please upvote.......!!!!!!"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "[4,3,2,5,2]\\nx =3\\nhere x = 3 and on right hand side we have 2 , 5 , 2\\nnow preserving order ans will be\\n[4,2,2,3,5]\\nexpected answer is : [2,2,4,3,5] .. how this preserve order ???"
                    },
                    {
                        "username": "rashapredator",
                        "content": "Input: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\n\\nIs sol [2, 2, 1, 4, 3, 5] correct?"
                    },
                    {
                        "username": "rahil1202",
                        "content": "Here, we start by defining the ListNode structure which is a basic structure for a singly-linked list node.\\nThe Solution class contains the partition function, which takes the head of the linked list and the value x as inputs.\\n\\nWe create two dummy nodes, lessDummy and greaterDummy, to serve as the heads of the partitions for nodes less than x and nodes greater than or equal to x.\\nlessCurrent and greaterCurrent are pointers that will keep track of the current positions in their respective partitions.\\n\\nIn this loop, we iterate through the original linked list pointed to by head.\\nIf the current node\\'s value is less than x, we update lessCurrent to point to the current node and also update its next pointer to the current node. This effectively adds the current node to the \"less than x\" partition.\\n\\nIf the current node\\'s value is greater than or equal to x, we do the same for the greaterCurrent and the \"greater than or equal to x\" partition.\\nThe code combines the pointer assignment and node connection steps into a single line to optimize the process.\\n\\nAfter the loop completes, we need to connect the two partitions.\\nWe set the next pointer of greaterCurrent (last node in the \"greater than or equal to x\" partition) to nullptr to terminate the end of that partition.\\n\\nThen, we set the next pointer of lessCurrent (last node in the \"less than x\" partition) to point to the beginning of the \"greater than or equal to x\" partition.\\n\\nFinally, we return lessDummy.next, which is the head of the linked list containing the partitioned nodes.\\n"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy "
                    }
                ]
            },
            {
                "id": 2014900,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "________listOfNodes=[2,2]\\n________temp2=head\\n________i=0\\n________while i<len(listOfNodes) and temp2 is not None:\\n____________if temp2.val<=listOfNodes[i]:\\n________________t3=deepcopy(temp2)\\n________________temp2=temp2.next\\n____________elif temp2.val>listOfNodes[i]:\\n________________newNode=ListNode()\\n////////////////newNode.next=t3.next\\n________________t3.next=newNode\\n________________i+=1\\n________________temp2=temp2.next\\n\\nWhy the /// comment is causing the function to run 2 times?  Can anyone please explain. listOfNodes are all the smallest nodes present at the right of the x. i have put _ because it was not allowing indentation in comments."
                    },
                    {
                        "username": "aditi61",
                        "content": "Line 15: Char 16: runtime error: member access within misaligned address 0x00000000000d for type \\'ListNode\\', which requires 8 byte alignment (__ListNodeUtils__.cpp)\\n0x00000000000d: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior __ListNodeUtils__.cpp:24:16 I am getting this error anyone knows the reason?\\n\\nListNode* partition(ListNode* head, int x) {\\n        vector<int>smaller;\\n        vector<int>greater;\\n        ListNode* curr = head;\\n        while(curr){\\n            if(curr->val>=x) greater.push_back(curr->val);\\n            else smaller.push_back(curr->val);\\n            curr= curr->next;\\n        }\\n        for(int i=0;i<greater.size();i++){\\n            smaller.push_back(greater[i]);\\n        }\\n        ListNode* ans;\\n        ListNode* temp = ans;\\n      for(int i=0;i<smaller.size();i++){\\n            temp= new ListNode(smaller[i]);\\n            temp = temp->next;\\n            \\n        }\\n        return ans;\\n\\n        \\n    }"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "I found implementation confusing. :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy Independence Day \\uD83D\\uDD05"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "ListNode* partition(ListNode* head, int x) {\\n        if(head  == NULL || head->next == NULL) return head;\\n        ListNode *temp = head,*prev = head ,*temp1=head;\\n        temp = temp->next;\\n        while(temp != NULL){\\n            if(temp->val >= x){\\n                temp1 = temp;\\n                temp = temp->next;\\n            }\\n            else{\\n                temp1->next = temp->next;\\n                temp->next = prev->next;\\n                prev->next = temp;\\n                prev = prev->next;\\n                temp=temp1->next;\\n            }\\n        }\\n        return head;\\n    }\\n\\nwhy it is  giving TLE !!!!\\ncan anyone tell me where it went wrong"
                    },
                    {
                        "username": "imtiaj007",
                        "content": "The description is pretty much tricky and examples are not very much sufficient. It took me 4 wrong submissions to understand the problem. Actually the problem is -\\n\\nCheck from the starting node, if the node is less than X then, place it before the nodes that are greater than or equal to X. And one thing to keep in mind you must maintain the relative order of the nodes even if some node values are smaller than previous nodes.\\n\\nHere are some example test cases for your reference - \\n\\n`1 -> 4 -> 3-> 2-> 5 -> 2`     ----  k = 3  ----      `1 -> 2 -> 2 -> 4 -> 3 -> 5`\\n`1 -> 4 -> 3-> 0-> 5 -> 2`     ----  k = 2  ----      `1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 0-> 5 -> 2 -> 1`    ----  k = 2  ----      `1 -> 0 -> 1 -> 4 -> 3 -> 5 -> 2`\\n`1 -> 4 -> 3-> 1-> 5 -> 2 -> 0`    ----  k = 2  ----      `1 -> 1 -> 0 -> 4 -> 3 -> 5 -> 2`\\n`4 -> 8 -> 6-> 5-> 1 -> 7 -> 2`    ----  k = 5  ----      `4 -> 1 -> 2 -> 8 -> 6 -> 5 -> 7`\\n\\nHope this will be helpful....... If you like please upvote.......!!!!!!"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "[4,3,2,5,2]\\nx =3\\nhere x = 3 and on right hand side we have 2 , 5 , 2\\nnow preserving order ans will be\\n[4,2,2,3,5]\\nexpected answer is : [2,2,4,3,5] .. how this preserve order ???"
                    },
                    {
                        "username": "rashapredator",
                        "content": "Input: head = [1,4,3,2,5,2], x = 3\\nOutput: [1,2,2,4,3,5]\\n\\nIs sol [2, 2, 1, 4, 3, 5] correct?"
                    },
                    {
                        "username": "rahil1202",
                        "content": "Here, we start by defining the ListNode structure which is a basic structure for a singly-linked list node.\\nThe Solution class contains the partition function, which takes the head of the linked list and the value x as inputs.\\n\\nWe create two dummy nodes, lessDummy and greaterDummy, to serve as the heads of the partitions for nodes less than x and nodes greater than or equal to x.\\nlessCurrent and greaterCurrent are pointers that will keep track of the current positions in their respective partitions.\\n\\nIn this loop, we iterate through the original linked list pointed to by head.\\nIf the current node\\'s value is less than x, we update lessCurrent to point to the current node and also update its next pointer to the current node. This effectively adds the current node to the \"less than x\" partition.\\n\\nIf the current node\\'s value is greater than or equal to x, we do the same for the greaterCurrent and the \"greater than or equal to x\" partition.\\nThe code combines the pointer assignment and node connection steps into a single line to optimize the process.\\n\\nAfter the loop completes, we need to connect the two partitions.\\nWe set the next pointer of greaterCurrent (last node in the \"greater than or equal to x\" partition) to nullptr to terminate the end of that partition.\\n\\nThen, we set the next pointer of lessCurrent (last node in the \"less than x\" partition) to point to the beginning of the \"greater than or equal to x\" partition.\\n\\nFinally, we return lessDummy.next, which is the head of the linked list containing the partitioned nodes.\\n"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy "
                    }
                ]
            },
            {
                "id": 2014872,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "I am facing very weird situation, even after I am done with function definition (partition here), it is running 2 times. Even if I am making any mistake, why is it running 2 times as it should run only once in driver program. I have faced it many times.\nIf anyone knows why please let me know.\nPS: There is not even any loop.\n"
                    },
                    {
                        "username": "Sam_Sundar",
                        "content": "How is this a Medium level problem ??"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Leetcode never fails to confuse us with the description of question.\\nIn this question, as you read the question you would  be easy question but after running the code damn I did wrong interpretation of the question.(so read the question again carefully)"
                    },
                    {
                        "username": "vaibhav6265",
                        "content": "Simple Explanation of Problem Statement:\\n\\nExample:\\nhead = [1,4,3,2,5,2] , x = 3\\n\\nYou are a value x. There can be any number of nodes from [0,n] of this value x in the list.\\n\\nNow you have to arrange the nodes in such a way, that all the nodes with value `less than x` should be `together` and `relative order` between them is `maintained`. Lets call this group `A`.\\nA = [1,2,2]\\n\\nSimilarly, all the nodes with value `greater than equal to x` should be `together` and `relative order` between them is `maintained`. Lets call this group `B`.\\nB = [4,3,2,2]\\n4 comes before 3, 3 comes before 2 same as in the problem statement.\\n\\nNote: relative order between all nodes in A and B are maintained.\\n\\nFinally, `A should be before B`."
                    },
                    {
                        "username": "swo0sh",
                        "content": "Happy Independence Day \\uD83C\\uDDEE\\uD83C\\uDDF3"
                    },
                    {
                        "username": "satyam47",
                        "content": "I have solved Linked List questions, but it took me many submissions with incorrect answers."
                    },
                    {
                        "username": "jazelly",
                        "content": "I have the solution, dividing them to 2 list and join them after a linear scan, but I really couldn\\'t figure out why I got oom in golang. I have 0 allocation on memory, but just operations on pointers. Is this a bug?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "FOR the people who are getting the memory limit exceeded just like I tried for the first time this question by taking two vectors and storing before less than x and one with more than x values .\\nI would say the reason behind we are getting the memory limit exceeded is because we are runnin two traversals in the linked list itself .Rather we  should first copy all the elements in a single vector and then copy all the required numbers into another array .\\n\\nBy doing that we can get the easy results of desired array\\ngood luck for the approach ,Hare krishna !  "
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing a quickselect problem, so the solution struck me right away."
                    },
                    {
                        "username": "user1914GI",
                        "content": "I didnt understand the question properly... can u explain how the first sample output came "
                    }
                ]
            },
            {
                "id": 2014836,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "I am facing very weird situation, even after I am done with function definition (partition here), it is running 2 times. Even if I am making any mistake, why is it running 2 times as it should run only once in driver program. I have faced it many times.\nIf anyone knows why please let me know.\nPS: There is not even any loop.\n"
                    },
                    {
                        "username": "Sam_Sundar",
                        "content": "How is this a Medium level problem ??"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Leetcode never fails to confuse us with the description of question.\\nIn this question, as you read the question you would  be easy question but after running the code damn I did wrong interpretation of the question.(so read the question again carefully)"
                    },
                    {
                        "username": "vaibhav6265",
                        "content": "Simple Explanation of Problem Statement:\\n\\nExample:\\nhead = [1,4,3,2,5,2] , x = 3\\n\\nYou are a value x. There can be any number of nodes from [0,n] of this value x in the list.\\n\\nNow you have to arrange the nodes in such a way, that all the nodes with value `less than x` should be `together` and `relative order` between them is `maintained`. Lets call this group `A`.\\nA = [1,2,2]\\n\\nSimilarly, all the nodes with value `greater than equal to x` should be `together` and `relative order` between them is `maintained`. Lets call this group `B`.\\nB = [4,3,2,2]\\n4 comes before 3, 3 comes before 2 same as in the problem statement.\\n\\nNote: relative order between all nodes in A and B are maintained.\\n\\nFinally, `A should be before B`."
                    },
                    {
                        "username": "swo0sh",
                        "content": "Happy Independence Day \\uD83C\\uDDEE\\uD83C\\uDDF3"
                    },
                    {
                        "username": "satyam47",
                        "content": "I have solved Linked List questions, but it took me many submissions with incorrect answers."
                    },
                    {
                        "username": "jazelly",
                        "content": "I have the solution, dividing them to 2 list and join them after a linear scan, but I really couldn\\'t figure out why I got oom in golang. I have 0 allocation on memory, but just operations on pointers. Is this a bug?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "FOR the people who are getting the memory limit exceeded just like I tried for the first time this question by taking two vectors and storing before less than x and one with more than x values .\\nI would say the reason behind we are getting the memory limit exceeded is because we are runnin two traversals in the linked list itself .Rather we  should first copy all the elements in a single vector and then copy all the required numbers into another array .\\n\\nBy doing that we can get the easy results of desired array\\ngood luck for the approach ,Hare krishna !  "
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing a quickselect problem, so the solution struck me right away."
                    },
                    {
                        "username": "user1914GI",
                        "content": "I didnt understand the question properly... can u explain how the first sample output came "
                    }
                ]
            },
            {
                "id": 2014776,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "I am facing very weird situation, even after I am done with function definition (partition here), it is running 2 times. Even if I am making any mistake, why is it running 2 times as it should run only once in driver program. I have faced it many times.\nIf anyone knows why please let me know.\nPS: There is not even any loop.\n"
                    },
                    {
                        "username": "Sam_Sundar",
                        "content": "How is this a Medium level problem ??"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Leetcode never fails to confuse us with the description of question.\\nIn this question, as you read the question you would  be easy question but after running the code damn I did wrong interpretation of the question.(so read the question again carefully)"
                    },
                    {
                        "username": "vaibhav6265",
                        "content": "Simple Explanation of Problem Statement:\\n\\nExample:\\nhead = [1,4,3,2,5,2] , x = 3\\n\\nYou are a value x. There can be any number of nodes from [0,n] of this value x in the list.\\n\\nNow you have to arrange the nodes in such a way, that all the nodes with value `less than x` should be `together` and `relative order` between them is `maintained`. Lets call this group `A`.\\nA = [1,2,2]\\n\\nSimilarly, all the nodes with value `greater than equal to x` should be `together` and `relative order` between them is `maintained`. Lets call this group `B`.\\nB = [4,3,2,2]\\n4 comes before 3, 3 comes before 2 same as in the problem statement.\\n\\nNote: relative order between all nodes in A and B are maintained.\\n\\nFinally, `A should be before B`."
                    },
                    {
                        "username": "swo0sh",
                        "content": "Happy Independence Day \\uD83C\\uDDEE\\uD83C\\uDDF3"
                    },
                    {
                        "username": "satyam47",
                        "content": "I have solved Linked List questions, but it took me many submissions with incorrect answers."
                    },
                    {
                        "username": "jazelly",
                        "content": "I have the solution, dividing them to 2 list and join them after a linear scan, but I really couldn\\'t figure out why I got oom in golang. I have 0 allocation on memory, but just operations on pointers. Is this a bug?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "FOR the people who are getting the memory limit exceeded just like I tried for the first time this question by taking two vectors and storing before less than x and one with more than x values .\\nI would say the reason behind we are getting the memory limit exceeded is because we are runnin two traversals in the linked list itself .Rather we  should first copy all the elements in a single vector and then copy all the required numbers into another array .\\n\\nBy doing that we can get the easy results of desired array\\ngood luck for the approach ,Hare krishna !  "
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing a quickselect problem, so the solution struck me right away."
                    },
                    {
                        "username": "user1914GI",
                        "content": "I didnt understand the question properly... can u explain how the first sample output came "
                    }
                ]
            },
            {
                "id": 2014750,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "I am facing very weird situation, even after I am done with function definition (partition here), it is running 2 times. Even if I am making any mistake, why is it running 2 times as it should run only once in driver program. I have faced it many times.\nIf anyone knows why please let me know.\nPS: There is not even any loop.\n"
                    },
                    {
                        "username": "Sam_Sundar",
                        "content": "How is this a Medium level problem ??"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Leetcode never fails to confuse us with the description of question.\\nIn this question, as you read the question you would  be easy question but after running the code damn I did wrong interpretation of the question.(so read the question again carefully)"
                    },
                    {
                        "username": "vaibhav6265",
                        "content": "Simple Explanation of Problem Statement:\\n\\nExample:\\nhead = [1,4,3,2,5,2] , x = 3\\n\\nYou are a value x. There can be any number of nodes from [0,n] of this value x in the list.\\n\\nNow you have to arrange the nodes in such a way, that all the nodes with value `less than x` should be `together` and `relative order` between them is `maintained`. Lets call this group `A`.\\nA = [1,2,2]\\n\\nSimilarly, all the nodes with value `greater than equal to x` should be `together` and `relative order` between them is `maintained`. Lets call this group `B`.\\nB = [4,3,2,2]\\n4 comes before 3, 3 comes before 2 same as in the problem statement.\\n\\nNote: relative order between all nodes in A and B are maintained.\\n\\nFinally, `A should be before B`."
                    },
                    {
                        "username": "swo0sh",
                        "content": "Happy Independence Day \\uD83C\\uDDEE\\uD83C\\uDDF3"
                    },
                    {
                        "username": "satyam47",
                        "content": "I have solved Linked List questions, but it took me many submissions with incorrect answers."
                    },
                    {
                        "username": "jazelly",
                        "content": "I have the solution, dividing them to 2 list and join them after a linear scan, but I really couldn\\'t figure out why I got oom in golang. I have 0 allocation on memory, but just operations on pointers. Is this a bug?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "FOR the people who are getting the memory limit exceeded just like I tried for the first time this question by taking two vectors and storing before less than x and one with more than x values .\\nI would say the reason behind we are getting the memory limit exceeded is because we are runnin two traversals in the linked list itself .Rather we  should first copy all the elements in a single vector and then copy all the required numbers into another array .\\n\\nBy doing that we can get the easy results of desired array\\ngood luck for the approach ,Hare krishna !  "
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing a quickselect problem, so the solution struck me right away."
                    },
                    {
                        "username": "user1914GI",
                        "content": "I didnt understand the question properly... can u explain how the first sample output came "
                    }
                ]
            },
            {
                "id": 2014745,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "I am facing very weird situation, even after I am done with function definition (partition here), it is running 2 times. Even if I am making any mistake, why is it running 2 times as it should run only once in driver program. I have faced it many times.\nIf anyone knows why please let me know.\nPS: There is not even any loop.\n"
                    },
                    {
                        "username": "Sam_Sundar",
                        "content": "How is this a Medium level problem ??"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Leetcode never fails to confuse us with the description of question.\\nIn this question, as you read the question you would  be easy question but after running the code damn I did wrong interpretation of the question.(so read the question again carefully)"
                    },
                    {
                        "username": "vaibhav6265",
                        "content": "Simple Explanation of Problem Statement:\\n\\nExample:\\nhead = [1,4,3,2,5,2] , x = 3\\n\\nYou are a value x. There can be any number of nodes from [0,n] of this value x in the list.\\n\\nNow you have to arrange the nodes in such a way, that all the nodes with value `less than x` should be `together` and `relative order` between them is `maintained`. Lets call this group `A`.\\nA = [1,2,2]\\n\\nSimilarly, all the nodes with value `greater than equal to x` should be `together` and `relative order` between them is `maintained`. Lets call this group `B`.\\nB = [4,3,2,2]\\n4 comes before 3, 3 comes before 2 same as in the problem statement.\\n\\nNote: relative order between all nodes in A and B are maintained.\\n\\nFinally, `A should be before B`."
                    },
                    {
                        "username": "swo0sh",
                        "content": "Happy Independence Day \\uD83C\\uDDEE\\uD83C\\uDDF3"
                    },
                    {
                        "username": "satyam47",
                        "content": "I have solved Linked List questions, but it took me many submissions with incorrect answers."
                    },
                    {
                        "username": "jazelly",
                        "content": "I have the solution, dividing them to 2 list and join them after a linear scan, but I really couldn\\'t figure out why I got oom in golang. I have 0 allocation on memory, but just operations on pointers. Is this a bug?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "FOR the people who are getting the memory limit exceeded just like I tried for the first time this question by taking two vectors and storing before less than x and one with more than x values .\\nI would say the reason behind we are getting the memory limit exceeded is because we are runnin two traversals in the linked list itself .Rather we  should first copy all the elements in a single vector and then copy all the required numbers into another array .\\n\\nBy doing that we can get the easy results of desired array\\ngood luck for the approach ,Hare krishna !  "
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing a quickselect problem, so the solution struck me right away."
                    },
                    {
                        "username": "user1914GI",
                        "content": "I didnt understand the question properly... can u explain how the first sample output came "
                    }
                ]
            },
            {
                "id": 2014721,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "I am facing very weird situation, even after I am done with function definition (partition here), it is running 2 times. Even if I am making any mistake, why is it running 2 times as it should run only once in driver program. I have faced it many times.\nIf anyone knows why please let me know.\nPS: There is not even any loop.\n"
                    },
                    {
                        "username": "Sam_Sundar",
                        "content": "How is this a Medium level problem ??"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Leetcode never fails to confuse us with the description of question.\\nIn this question, as you read the question you would  be easy question but after running the code damn I did wrong interpretation of the question.(so read the question again carefully)"
                    },
                    {
                        "username": "vaibhav6265",
                        "content": "Simple Explanation of Problem Statement:\\n\\nExample:\\nhead = [1,4,3,2,5,2] , x = 3\\n\\nYou are a value x. There can be any number of nodes from [0,n] of this value x in the list.\\n\\nNow you have to arrange the nodes in such a way, that all the nodes with value `less than x` should be `together` and `relative order` between them is `maintained`. Lets call this group `A`.\\nA = [1,2,2]\\n\\nSimilarly, all the nodes with value `greater than equal to x` should be `together` and `relative order` between them is `maintained`. Lets call this group `B`.\\nB = [4,3,2,2]\\n4 comes before 3, 3 comes before 2 same as in the problem statement.\\n\\nNote: relative order between all nodes in A and B are maintained.\\n\\nFinally, `A should be before B`."
                    },
                    {
                        "username": "swo0sh",
                        "content": "Happy Independence Day \\uD83C\\uDDEE\\uD83C\\uDDF3"
                    },
                    {
                        "username": "satyam47",
                        "content": "I have solved Linked List questions, but it took me many submissions with incorrect answers."
                    },
                    {
                        "username": "jazelly",
                        "content": "I have the solution, dividing them to 2 list and join them after a linear scan, but I really couldn\\'t figure out why I got oom in golang. I have 0 allocation on memory, but just operations on pointers. Is this a bug?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "FOR the people who are getting the memory limit exceeded just like I tried for the first time this question by taking two vectors and storing before less than x and one with more than x values .\\nI would say the reason behind we are getting the memory limit exceeded is because we are runnin two traversals in the linked list itself .Rather we  should first copy all the elements in a single vector and then copy all the required numbers into another array .\\n\\nBy doing that we can get the easy results of desired array\\ngood luck for the approach ,Hare krishna !  "
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing a quickselect problem, so the solution struck me right away."
                    },
                    {
                        "username": "user1914GI",
                        "content": "I didnt understand the question properly... can u explain how the first sample output came "
                    }
                ]
            },
            {
                "id": 2014696,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "I am facing very weird situation, even after I am done with function definition (partition here), it is running 2 times. Even if I am making any mistake, why is it running 2 times as it should run only once in driver program. I have faced it many times.\nIf anyone knows why please let me know.\nPS: There is not even any loop.\n"
                    },
                    {
                        "username": "Sam_Sundar",
                        "content": "How is this a Medium level problem ??"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Leetcode never fails to confuse us with the description of question.\\nIn this question, as you read the question you would  be easy question but after running the code damn I did wrong interpretation of the question.(so read the question again carefully)"
                    },
                    {
                        "username": "vaibhav6265",
                        "content": "Simple Explanation of Problem Statement:\\n\\nExample:\\nhead = [1,4,3,2,5,2] , x = 3\\n\\nYou are a value x. There can be any number of nodes from [0,n] of this value x in the list.\\n\\nNow you have to arrange the nodes in such a way, that all the nodes with value `less than x` should be `together` and `relative order` between them is `maintained`. Lets call this group `A`.\\nA = [1,2,2]\\n\\nSimilarly, all the nodes with value `greater than equal to x` should be `together` and `relative order` between them is `maintained`. Lets call this group `B`.\\nB = [4,3,2,2]\\n4 comes before 3, 3 comes before 2 same as in the problem statement.\\n\\nNote: relative order between all nodes in A and B are maintained.\\n\\nFinally, `A should be before B`."
                    },
                    {
                        "username": "swo0sh",
                        "content": "Happy Independence Day \\uD83C\\uDDEE\\uD83C\\uDDF3"
                    },
                    {
                        "username": "satyam47",
                        "content": "I have solved Linked List questions, but it took me many submissions with incorrect answers."
                    },
                    {
                        "username": "jazelly",
                        "content": "I have the solution, dividing them to 2 list and join them after a linear scan, but I really couldn\\'t figure out why I got oom in golang. I have 0 allocation on memory, but just operations on pointers. Is this a bug?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "FOR the people who are getting the memory limit exceeded just like I tried for the first time this question by taking two vectors and storing before less than x and one with more than x values .\\nI would say the reason behind we are getting the memory limit exceeded is because we are runnin two traversals in the linked list itself .Rather we  should first copy all the elements in a single vector and then copy all the required numbers into another array .\\n\\nBy doing that we can get the easy results of desired array\\ngood luck for the approach ,Hare krishna !  "
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing a quickselect problem, so the solution struck me right away."
                    },
                    {
                        "username": "user1914GI",
                        "content": "I didnt understand the question properly... can u explain how the first sample output came "
                    }
                ]
            },
            {
                "id": 2014692,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "I am facing very weird situation, even after I am done with function definition (partition here), it is running 2 times. Even if I am making any mistake, why is it running 2 times as it should run only once in driver program. I have faced it many times.\nIf anyone knows why please let me know.\nPS: There is not even any loop.\n"
                    },
                    {
                        "username": "Sam_Sundar",
                        "content": "How is this a Medium level problem ??"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Leetcode never fails to confuse us with the description of question.\\nIn this question, as you read the question you would  be easy question but after running the code damn I did wrong interpretation of the question.(so read the question again carefully)"
                    },
                    {
                        "username": "vaibhav6265",
                        "content": "Simple Explanation of Problem Statement:\\n\\nExample:\\nhead = [1,4,3,2,5,2] , x = 3\\n\\nYou are a value x. There can be any number of nodes from [0,n] of this value x in the list.\\n\\nNow you have to arrange the nodes in such a way, that all the nodes with value `less than x` should be `together` and `relative order` between them is `maintained`. Lets call this group `A`.\\nA = [1,2,2]\\n\\nSimilarly, all the nodes with value `greater than equal to x` should be `together` and `relative order` between them is `maintained`. Lets call this group `B`.\\nB = [4,3,2,2]\\n4 comes before 3, 3 comes before 2 same as in the problem statement.\\n\\nNote: relative order between all nodes in A and B are maintained.\\n\\nFinally, `A should be before B`."
                    },
                    {
                        "username": "swo0sh",
                        "content": "Happy Independence Day \\uD83C\\uDDEE\\uD83C\\uDDF3"
                    },
                    {
                        "username": "satyam47",
                        "content": "I have solved Linked List questions, but it took me many submissions with incorrect answers."
                    },
                    {
                        "username": "jazelly",
                        "content": "I have the solution, dividing them to 2 list and join them after a linear scan, but I really couldn\\'t figure out why I got oom in golang. I have 0 allocation on memory, but just operations on pointers. Is this a bug?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "FOR the people who are getting the memory limit exceeded just like I tried for the first time this question by taking two vectors and storing before less than x and one with more than x values .\\nI would say the reason behind we are getting the memory limit exceeded is because we are runnin two traversals in the linked list itself .Rather we  should first copy all the elements in a single vector and then copy all the required numbers into another array .\\n\\nBy doing that we can get the easy results of desired array\\ngood luck for the approach ,Hare krishna !  "
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing a quickselect problem, so the solution struck me right away."
                    },
                    {
                        "username": "user1914GI",
                        "content": "I didnt understand the question properly... can u explain how the first sample output came "
                    }
                ]
            },
            {
                "id": 2014655,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "I am facing very weird situation, even after I am done with function definition (partition here), it is running 2 times. Even if I am making any mistake, why is it running 2 times as it should run only once in driver program. I have faced it many times.\nIf anyone knows why please let me know.\nPS: There is not even any loop.\n"
                    },
                    {
                        "username": "Sam_Sundar",
                        "content": "How is this a Medium level problem ??"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Leetcode never fails to confuse us with the description of question.\\nIn this question, as you read the question you would  be easy question but after running the code damn I did wrong interpretation of the question.(so read the question again carefully)"
                    },
                    {
                        "username": "vaibhav6265",
                        "content": "Simple Explanation of Problem Statement:\\n\\nExample:\\nhead = [1,4,3,2,5,2] , x = 3\\n\\nYou are a value x. There can be any number of nodes from [0,n] of this value x in the list.\\n\\nNow you have to arrange the nodes in such a way, that all the nodes with value `less than x` should be `together` and `relative order` between them is `maintained`. Lets call this group `A`.\\nA = [1,2,2]\\n\\nSimilarly, all the nodes with value `greater than equal to x` should be `together` and `relative order` between them is `maintained`. Lets call this group `B`.\\nB = [4,3,2,2]\\n4 comes before 3, 3 comes before 2 same as in the problem statement.\\n\\nNote: relative order between all nodes in A and B are maintained.\\n\\nFinally, `A should be before B`."
                    },
                    {
                        "username": "swo0sh",
                        "content": "Happy Independence Day \\uD83C\\uDDEE\\uD83C\\uDDF3"
                    },
                    {
                        "username": "satyam47",
                        "content": "I have solved Linked List questions, but it took me many submissions with incorrect answers."
                    },
                    {
                        "username": "jazelly",
                        "content": "I have the solution, dividing them to 2 list and join them after a linear scan, but I really couldn\\'t figure out why I got oom in golang. I have 0 allocation on memory, but just operations on pointers. Is this a bug?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "FOR the people who are getting the memory limit exceeded just like I tried for the first time this question by taking two vectors and storing before less than x and one with more than x values .\\nI would say the reason behind we are getting the memory limit exceeded is because we are runnin two traversals in the linked list itself .Rather we  should first copy all the elements in a single vector and then copy all the required numbers into another array .\\n\\nBy doing that we can get the easy results of desired array\\ngood luck for the approach ,Hare krishna !  "
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing a quickselect problem, so the solution struck me right away."
                    },
                    {
                        "username": "user1914GI",
                        "content": "I didnt understand the question properly... can u explain how the first sample output came "
                    }
                ]
            },
            {
                "id": 2014611,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "I am facing very weird situation, even after I am done with function definition (partition here), it is running 2 times. Even if I am making any mistake, why is it running 2 times as it should run only once in driver program. I have faced it many times.\nIf anyone knows why please let me know.\nPS: There is not even any loop.\n"
                    },
                    {
                        "username": "Sam_Sundar",
                        "content": "How is this a Medium level problem ??"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Leetcode never fails to confuse us with the description of question.\\nIn this question, as you read the question you would  be easy question but after running the code damn I did wrong interpretation of the question.(so read the question again carefully)"
                    },
                    {
                        "username": "vaibhav6265",
                        "content": "Simple Explanation of Problem Statement:\\n\\nExample:\\nhead = [1,4,3,2,5,2] , x = 3\\n\\nYou are a value x. There can be any number of nodes from [0,n] of this value x in the list.\\n\\nNow you have to arrange the nodes in such a way, that all the nodes with value `less than x` should be `together` and `relative order` between them is `maintained`. Lets call this group `A`.\\nA = [1,2,2]\\n\\nSimilarly, all the nodes with value `greater than equal to x` should be `together` and `relative order` between them is `maintained`. Lets call this group `B`.\\nB = [4,3,2,2]\\n4 comes before 3, 3 comes before 2 same as in the problem statement.\\n\\nNote: relative order between all nodes in A and B are maintained.\\n\\nFinally, `A should be before B`."
                    },
                    {
                        "username": "swo0sh",
                        "content": "Happy Independence Day \\uD83C\\uDDEE\\uD83C\\uDDF3"
                    },
                    {
                        "username": "satyam47",
                        "content": "I have solved Linked List questions, but it took me many submissions with incorrect answers."
                    },
                    {
                        "username": "jazelly",
                        "content": "I have the solution, dividing them to 2 list and join them after a linear scan, but I really couldn\\'t figure out why I got oom in golang. I have 0 allocation on memory, but just operations on pointers. Is this a bug?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "FOR the people who are getting the memory limit exceeded just like I tried for the first time this question by taking two vectors and storing before less than x and one with more than x values .\\nI would say the reason behind we are getting the memory limit exceeded is because we are runnin two traversals in the linked list itself .Rather we  should first copy all the elements in a single vector and then copy all the required numbers into another array .\\n\\nBy doing that we can get the easy results of desired array\\ngood luck for the approach ,Hare krishna !  "
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing a quickselect problem, so the solution struck me right away."
                    },
                    {
                        "username": "user1914GI",
                        "content": "I didnt understand the question properly... can u explain how the first sample output came "
                    }
                ]
            },
            {
                "id": 1944225,
                "content": [
                    {
                        "username": "Himatheja",
                        "content": "   ListNode* temp = head;\\n        ListNode* curr1 = head;\\n        ListNode* curr2 = head;\\n        ListNode* head1;\\n        ListNode* head2;\\n        bool pass1,pass2 = true;\\n        while(temp!=NULL){\\n            if(temp->val<x){\\n                 if(pass1){\\n                     pass1 = false;\\n                     head1 = temp;\\n                     curr1 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr1->next = temp;\\n                     curr1=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            else{\\n                if(pass2){\\n                     pass2 = false;\\n                     head2 = temp;\\n                     curr2 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr2->next = temp;\\n                     curr2=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            \\n        }\\n        curr1->next = head2;\\n        return\\xA0head1;\\nI still don\\'t get why it is giving tle;"
                    },
                    {
                        "username": "tifv",
                        "content": "There are several errors here. For starters, one can observe that `bool pass1,pass2 = true;` only initializes the second variable. Other problems include the end of resulting list not necessarily being set to `NULL`."
                    },
                    {
                        "username": "swapniljk14",
                        "content": "why it showing time limit exceeded?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "A tip for those of you who recognized quicksort partitioning, and are trying to implement it this way: don't.\nYou would get there eventually (I did), but quicksort partitioning is designed for arrays, not linked lists. \nFor a linked list there is a much more straightforward way to do it that will save you a lot of headaches with pointer management and edge cases. Good luck!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my Straightforward approach:-\n\n1. Create an ArrayList<Integer> to store the values of the input ListNode.\n2. Traverse the input ListNode, adding each value to the ArrayList<Integer>.\n3. Sort the ArrayList<Integer> using a Comparator that prioritizes values less than 3.\n4. Create a new ListNode from the sorted ArrayList<Integer>.\n5. Return the new ListNode.\n\n- Constraints friendly"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for help:-\\nhttps://leetcode.com/problems/partition-list/solutions/3303261/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "I feel so stupid.... :(\\nI know the logic but it took me almost 3 damn hours to code this"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Statement is hella confusing. Think of it as you\\'re only allowed to move nodes with node.val<x while maintaining the relative order and leave the rest as it is."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Nice problem"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "The problem description doesn\\'t say, but I assume you can only manipulate the pointers of the original list nodes, and are not allowed to create new list nodes to copy the values over?"
                    },
                    {
                        "username": "aniketdali",
                        "content": "rearrange the list such that we can create  two logical partitions one < x and another x <="
                    }
                ]
            },
            {
                "id": 1938529,
                "content": [
                    {
                        "username": "Himatheja",
                        "content": "   ListNode* temp = head;\\n        ListNode* curr1 = head;\\n        ListNode* curr2 = head;\\n        ListNode* head1;\\n        ListNode* head2;\\n        bool pass1,pass2 = true;\\n        while(temp!=NULL){\\n            if(temp->val<x){\\n                 if(pass1){\\n                     pass1 = false;\\n                     head1 = temp;\\n                     curr1 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr1->next = temp;\\n                     curr1=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            else{\\n                if(pass2){\\n                     pass2 = false;\\n                     head2 = temp;\\n                     curr2 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr2->next = temp;\\n                     curr2=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            \\n        }\\n        curr1->next = head2;\\n        return\\xA0head1;\\nI still don\\'t get why it is giving tle;"
                    },
                    {
                        "username": "tifv",
                        "content": "There are several errors here. For starters, one can observe that `bool pass1,pass2 = true;` only initializes the second variable. Other problems include the end of resulting list not necessarily being set to `NULL`."
                    },
                    {
                        "username": "swapniljk14",
                        "content": "why it showing time limit exceeded?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "A tip for those of you who recognized quicksort partitioning, and are trying to implement it this way: don't.\nYou would get there eventually (I did), but quicksort partitioning is designed for arrays, not linked lists. \nFor a linked list there is a much more straightforward way to do it that will save you a lot of headaches with pointer management and edge cases. Good luck!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my Straightforward approach:-\n\n1. Create an ArrayList<Integer> to store the values of the input ListNode.\n2. Traverse the input ListNode, adding each value to the ArrayList<Integer>.\n3. Sort the ArrayList<Integer> using a Comparator that prioritizes values less than 3.\n4. Create a new ListNode from the sorted ArrayList<Integer>.\n5. Return the new ListNode.\n\n- Constraints friendly"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for help:-\\nhttps://leetcode.com/problems/partition-list/solutions/3303261/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "I feel so stupid.... :(\\nI know the logic but it took me almost 3 damn hours to code this"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Statement is hella confusing. Think of it as you\\'re only allowed to move nodes with node.val<x while maintaining the relative order and leave the rest as it is."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Nice problem"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "The problem description doesn\\'t say, but I assume you can only manipulate the pointers of the original list nodes, and are not allowed to create new list nodes to copy the values over?"
                    },
                    {
                        "username": "aniketdali",
                        "content": "rearrange the list such that we can create  two logical partitions one < x and another x <="
                    }
                ]
            },
            {
                "id": 1852881,
                "content": [
                    {
                        "username": "Himatheja",
                        "content": "   ListNode* temp = head;\\n        ListNode* curr1 = head;\\n        ListNode* curr2 = head;\\n        ListNode* head1;\\n        ListNode* head2;\\n        bool pass1,pass2 = true;\\n        while(temp!=NULL){\\n            if(temp->val<x){\\n                 if(pass1){\\n                     pass1 = false;\\n                     head1 = temp;\\n                     curr1 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr1->next = temp;\\n                     curr1=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            else{\\n                if(pass2){\\n                     pass2 = false;\\n                     head2 = temp;\\n                     curr2 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr2->next = temp;\\n                     curr2=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            \\n        }\\n        curr1->next = head2;\\n        return\\xA0head1;\\nI still don\\'t get why it is giving tle;"
                    },
                    {
                        "username": "tifv",
                        "content": "There are several errors here. For starters, one can observe that `bool pass1,pass2 = true;` only initializes the second variable. Other problems include the end of resulting list not necessarily being set to `NULL`."
                    },
                    {
                        "username": "swapniljk14",
                        "content": "why it showing time limit exceeded?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "A tip for those of you who recognized quicksort partitioning, and are trying to implement it this way: don't.\nYou would get there eventually (I did), but quicksort partitioning is designed for arrays, not linked lists. \nFor a linked list there is a much more straightforward way to do it that will save you a lot of headaches with pointer management and edge cases. Good luck!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my Straightforward approach:-\n\n1. Create an ArrayList<Integer> to store the values of the input ListNode.\n2. Traverse the input ListNode, adding each value to the ArrayList<Integer>.\n3. Sort the ArrayList<Integer> using a Comparator that prioritizes values less than 3.\n4. Create a new ListNode from the sorted ArrayList<Integer>.\n5. Return the new ListNode.\n\n- Constraints friendly"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for help:-\\nhttps://leetcode.com/problems/partition-list/solutions/3303261/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "I feel so stupid.... :(\\nI know the logic but it took me almost 3 damn hours to code this"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Statement is hella confusing. Think of it as you\\'re only allowed to move nodes with node.val<x while maintaining the relative order and leave the rest as it is."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Nice problem"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "The problem description doesn\\'t say, but I assume you can only manipulate the pointers of the original list nodes, and are not allowed to create new list nodes to copy the values over?"
                    },
                    {
                        "username": "aniketdali",
                        "content": "rearrange the list such that we can create  two logical partitions one < x and another x <="
                    }
                ]
            },
            {
                "id": 1833938,
                "content": [
                    {
                        "username": "Himatheja",
                        "content": "   ListNode* temp = head;\\n        ListNode* curr1 = head;\\n        ListNode* curr2 = head;\\n        ListNode* head1;\\n        ListNode* head2;\\n        bool pass1,pass2 = true;\\n        while(temp!=NULL){\\n            if(temp->val<x){\\n                 if(pass1){\\n                     pass1 = false;\\n                     head1 = temp;\\n                     curr1 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr1->next = temp;\\n                     curr1=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            else{\\n                if(pass2){\\n                     pass2 = false;\\n                     head2 = temp;\\n                     curr2 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr2->next = temp;\\n                     curr2=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            \\n        }\\n        curr1->next = head2;\\n        return\\xA0head1;\\nI still don\\'t get why it is giving tle;"
                    },
                    {
                        "username": "tifv",
                        "content": "There are several errors here. For starters, one can observe that `bool pass1,pass2 = true;` only initializes the second variable. Other problems include the end of resulting list not necessarily being set to `NULL`."
                    },
                    {
                        "username": "swapniljk14",
                        "content": "why it showing time limit exceeded?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "A tip for those of you who recognized quicksort partitioning, and are trying to implement it this way: don't.\nYou would get there eventually (I did), but quicksort partitioning is designed for arrays, not linked lists. \nFor a linked list there is a much more straightforward way to do it that will save you a lot of headaches with pointer management and edge cases. Good luck!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my Straightforward approach:-\n\n1. Create an ArrayList<Integer> to store the values of the input ListNode.\n2. Traverse the input ListNode, adding each value to the ArrayList<Integer>.\n3. Sort the ArrayList<Integer> using a Comparator that prioritizes values less than 3.\n4. Create a new ListNode from the sorted ArrayList<Integer>.\n5. Return the new ListNode.\n\n- Constraints friendly"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for help:-\\nhttps://leetcode.com/problems/partition-list/solutions/3303261/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "I feel so stupid.... :(\\nI know the logic but it took me almost 3 damn hours to code this"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Statement is hella confusing. Think of it as you\\'re only allowed to move nodes with node.val<x while maintaining the relative order and leave the rest as it is."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Nice problem"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "The problem description doesn\\'t say, but I assume you can only manipulate the pointers of the original list nodes, and are not allowed to create new list nodes to copy the values over?"
                    },
                    {
                        "username": "aniketdali",
                        "content": "rearrange the list such that we can create  two logical partitions one < x and another x <="
                    }
                ]
            },
            {
                "id": 1829388,
                "content": [
                    {
                        "username": "Himatheja",
                        "content": "   ListNode* temp = head;\\n        ListNode* curr1 = head;\\n        ListNode* curr2 = head;\\n        ListNode* head1;\\n        ListNode* head2;\\n        bool pass1,pass2 = true;\\n        while(temp!=NULL){\\n            if(temp->val<x){\\n                 if(pass1){\\n                     pass1 = false;\\n                     head1 = temp;\\n                     curr1 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr1->next = temp;\\n                     curr1=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            else{\\n                if(pass2){\\n                     pass2 = false;\\n                     head2 = temp;\\n                     curr2 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr2->next = temp;\\n                     curr2=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            \\n        }\\n        curr1->next = head2;\\n        return\\xA0head1;\\nI still don\\'t get why it is giving tle;"
                    },
                    {
                        "username": "tifv",
                        "content": "There are several errors here. For starters, one can observe that `bool pass1,pass2 = true;` only initializes the second variable. Other problems include the end of resulting list not necessarily being set to `NULL`."
                    },
                    {
                        "username": "swapniljk14",
                        "content": "why it showing time limit exceeded?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "A tip for those of you who recognized quicksort partitioning, and are trying to implement it this way: don't.\nYou would get there eventually (I did), but quicksort partitioning is designed for arrays, not linked lists. \nFor a linked list there is a much more straightforward way to do it that will save you a lot of headaches with pointer management and edge cases. Good luck!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my Straightforward approach:-\n\n1. Create an ArrayList<Integer> to store the values of the input ListNode.\n2. Traverse the input ListNode, adding each value to the ArrayList<Integer>.\n3. Sort the ArrayList<Integer> using a Comparator that prioritizes values less than 3.\n4. Create a new ListNode from the sorted ArrayList<Integer>.\n5. Return the new ListNode.\n\n- Constraints friendly"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for help:-\\nhttps://leetcode.com/problems/partition-list/solutions/3303261/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "I feel so stupid.... :(\\nI know the logic but it took me almost 3 damn hours to code this"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Statement is hella confusing. Think of it as you\\'re only allowed to move nodes with node.val<x while maintaining the relative order and leave the rest as it is."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Nice problem"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "The problem description doesn\\'t say, but I assume you can only manipulate the pointers of the original list nodes, and are not allowed to create new list nodes to copy the values over?"
                    },
                    {
                        "username": "aniketdali",
                        "content": "rearrange the list such that we can create  two logical partitions one < x and another x <="
                    }
                ]
            },
            {
                "id": 1798624,
                "content": [
                    {
                        "username": "Himatheja",
                        "content": "   ListNode* temp = head;\\n        ListNode* curr1 = head;\\n        ListNode* curr2 = head;\\n        ListNode* head1;\\n        ListNode* head2;\\n        bool pass1,pass2 = true;\\n        while(temp!=NULL){\\n            if(temp->val<x){\\n                 if(pass1){\\n                     pass1 = false;\\n                     head1 = temp;\\n                     curr1 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr1->next = temp;\\n                     curr1=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            else{\\n                if(pass2){\\n                     pass2 = false;\\n                     head2 = temp;\\n                     curr2 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr2->next = temp;\\n                     curr2=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            \\n        }\\n        curr1->next = head2;\\n        return\\xA0head1;\\nI still don\\'t get why it is giving tle;"
                    },
                    {
                        "username": "tifv",
                        "content": "There are several errors here. For starters, one can observe that `bool pass1,pass2 = true;` only initializes the second variable. Other problems include the end of resulting list not necessarily being set to `NULL`."
                    },
                    {
                        "username": "swapniljk14",
                        "content": "why it showing time limit exceeded?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "A tip for those of you who recognized quicksort partitioning, and are trying to implement it this way: don't.\nYou would get there eventually (I did), but quicksort partitioning is designed for arrays, not linked lists. \nFor a linked list there is a much more straightforward way to do it that will save you a lot of headaches with pointer management and edge cases. Good luck!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my Straightforward approach:-\n\n1. Create an ArrayList<Integer> to store the values of the input ListNode.\n2. Traverse the input ListNode, adding each value to the ArrayList<Integer>.\n3. Sort the ArrayList<Integer> using a Comparator that prioritizes values less than 3.\n4. Create a new ListNode from the sorted ArrayList<Integer>.\n5. Return the new ListNode.\n\n- Constraints friendly"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for help:-\\nhttps://leetcode.com/problems/partition-list/solutions/3303261/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "I feel so stupid.... :(\\nI know the logic but it took me almost 3 damn hours to code this"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Statement is hella confusing. Think of it as you\\'re only allowed to move nodes with node.val<x while maintaining the relative order and leave the rest as it is."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Nice problem"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "The problem description doesn\\'t say, but I assume you can only manipulate the pointers of the original list nodes, and are not allowed to create new list nodes to copy the values over?"
                    },
                    {
                        "username": "aniketdali",
                        "content": "rearrange the list such that we can create  two logical partitions one < x and another x <="
                    }
                ]
            },
            {
                "id": 1760994,
                "content": [
                    {
                        "username": "Himatheja",
                        "content": "   ListNode* temp = head;\\n        ListNode* curr1 = head;\\n        ListNode* curr2 = head;\\n        ListNode* head1;\\n        ListNode* head2;\\n        bool pass1,pass2 = true;\\n        while(temp!=NULL){\\n            if(temp->val<x){\\n                 if(pass1){\\n                     pass1 = false;\\n                     head1 = temp;\\n                     curr1 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr1->next = temp;\\n                     curr1=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            else{\\n                if(pass2){\\n                     pass2 = false;\\n                     head2 = temp;\\n                     curr2 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr2->next = temp;\\n                     curr2=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            \\n        }\\n        curr1->next = head2;\\n        return\\xA0head1;\\nI still don\\'t get why it is giving tle;"
                    },
                    {
                        "username": "tifv",
                        "content": "There are several errors here. For starters, one can observe that `bool pass1,pass2 = true;` only initializes the second variable. Other problems include the end of resulting list not necessarily being set to `NULL`."
                    },
                    {
                        "username": "swapniljk14",
                        "content": "why it showing time limit exceeded?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "A tip for those of you who recognized quicksort partitioning, and are trying to implement it this way: don't.\nYou would get there eventually (I did), but quicksort partitioning is designed for arrays, not linked lists. \nFor a linked list there is a much more straightforward way to do it that will save you a lot of headaches with pointer management and edge cases. Good luck!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my Straightforward approach:-\n\n1. Create an ArrayList<Integer> to store the values of the input ListNode.\n2. Traverse the input ListNode, adding each value to the ArrayList<Integer>.\n3. Sort the ArrayList<Integer> using a Comparator that prioritizes values less than 3.\n4. Create a new ListNode from the sorted ArrayList<Integer>.\n5. Return the new ListNode.\n\n- Constraints friendly"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for help:-\\nhttps://leetcode.com/problems/partition-list/solutions/3303261/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "I feel so stupid.... :(\\nI know the logic but it took me almost 3 damn hours to code this"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Statement is hella confusing. Think of it as you\\'re only allowed to move nodes with node.val<x while maintaining the relative order and leave the rest as it is."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Nice problem"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "The problem description doesn\\'t say, but I assume you can only manipulate the pointers of the original list nodes, and are not allowed to create new list nodes to copy the values over?"
                    },
                    {
                        "username": "aniketdali",
                        "content": "rearrange the list such that we can create  two logical partitions one < x and another x <="
                    }
                ]
            },
            {
                "id": 1754243,
                "content": [
                    {
                        "username": "Himatheja",
                        "content": "   ListNode* temp = head;\\n        ListNode* curr1 = head;\\n        ListNode* curr2 = head;\\n        ListNode* head1;\\n        ListNode* head2;\\n        bool pass1,pass2 = true;\\n        while(temp!=NULL){\\n            if(temp->val<x){\\n                 if(pass1){\\n                     pass1 = false;\\n                     head1 = temp;\\n                     curr1 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr1->next = temp;\\n                     curr1=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            else{\\n                if(pass2){\\n                     pass2 = false;\\n                     head2 = temp;\\n                     curr2 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr2->next = temp;\\n                     curr2=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            \\n        }\\n        curr1->next = head2;\\n        return\\xA0head1;\\nI still don\\'t get why it is giving tle;"
                    },
                    {
                        "username": "tifv",
                        "content": "There are several errors here. For starters, one can observe that `bool pass1,pass2 = true;` only initializes the second variable. Other problems include the end of resulting list not necessarily being set to `NULL`."
                    },
                    {
                        "username": "swapniljk14",
                        "content": "why it showing time limit exceeded?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "A tip for those of you who recognized quicksort partitioning, and are trying to implement it this way: don't.\nYou would get there eventually (I did), but quicksort partitioning is designed for arrays, not linked lists. \nFor a linked list there is a much more straightforward way to do it that will save you a lot of headaches with pointer management and edge cases. Good luck!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my Straightforward approach:-\n\n1. Create an ArrayList<Integer> to store the values of the input ListNode.\n2. Traverse the input ListNode, adding each value to the ArrayList<Integer>.\n3. Sort the ArrayList<Integer> using a Comparator that prioritizes values less than 3.\n4. Create a new ListNode from the sorted ArrayList<Integer>.\n5. Return the new ListNode.\n\n- Constraints friendly"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for help:-\\nhttps://leetcode.com/problems/partition-list/solutions/3303261/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "I feel so stupid.... :(\\nI know the logic but it took me almost 3 damn hours to code this"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Statement is hella confusing. Think of it as you\\'re only allowed to move nodes with node.val<x while maintaining the relative order and leave the rest as it is."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Nice problem"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "The problem description doesn\\'t say, but I assume you can only manipulate the pointers of the original list nodes, and are not allowed to create new list nodes to copy the values over?"
                    },
                    {
                        "username": "aniketdali",
                        "content": "rearrange the list such that we can create  two logical partitions one < x and another x <="
                    }
                ]
            },
            {
                "id": 1733666,
                "content": [
                    {
                        "username": "Himatheja",
                        "content": "   ListNode* temp = head;\\n        ListNode* curr1 = head;\\n        ListNode* curr2 = head;\\n        ListNode* head1;\\n        ListNode* head2;\\n        bool pass1,pass2 = true;\\n        while(temp!=NULL){\\n            if(temp->val<x){\\n                 if(pass1){\\n                     pass1 = false;\\n                     head1 = temp;\\n                     curr1 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr1->next = temp;\\n                     curr1=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            else{\\n                if(pass2){\\n                     pass2 = false;\\n                     head2 = temp;\\n                     curr2 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr2->next = temp;\\n                     curr2=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            \\n        }\\n        curr1->next = head2;\\n        return\\xA0head1;\\nI still don\\'t get why it is giving tle;"
                    },
                    {
                        "username": "tifv",
                        "content": "There are several errors here. For starters, one can observe that `bool pass1,pass2 = true;` only initializes the second variable. Other problems include the end of resulting list not necessarily being set to `NULL`."
                    },
                    {
                        "username": "swapniljk14",
                        "content": "why it showing time limit exceeded?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "A tip for those of you who recognized quicksort partitioning, and are trying to implement it this way: don't.\nYou would get there eventually (I did), but quicksort partitioning is designed for arrays, not linked lists. \nFor a linked list there is a much more straightforward way to do it that will save you a lot of headaches with pointer management and edge cases. Good luck!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my Straightforward approach:-\n\n1. Create an ArrayList<Integer> to store the values of the input ListNode.\n2. Traverse the input ListNode, adding each value to the ArrayList<Integer>.\n3. Sort the ArrayList<Integer> using a Comparator that prioritizes values less than 3.\n4. Create a new ListNode from the sorted ArrayList<Integer>.\n5. Return the new ListNode.\n\n- Constraints friendly"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for help:-\\nhttps://leetcode.com/problems/partition-list/solutions/3303261/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "I feel so stupid.... :(\\nI know the logic but it took me almost 3 damn hours to code this"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Statement is hella confusing. Think of it as you\\'re only allowed to move nodes with node.val<x while maintaining the relative order and leave the rest as it is."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Nice problem"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "The problem description doesn\\'t say, but I assume you can only manipulate the pointers of the original list nodes, and are not allowed to create new list nodes to copy the values over?"
                    },
                    {
                        "username": "aniketdali",
                        "content": "rearrange the list such that we can create  two logical partitions one < x and another x <="
                    }
                ]
            },
            {
                "id": 1692188,
                "content": [
                    {
                        "username": "Himatheja",
                        "content": "   ListNode* temp = head;\\n        ListNode* curr1 = head;\\n        ListNode* curr2 = head;\\n        ListNode* head1;\\n        ListNode* head2;\\n        bool pass1,pass2 = true;\\n        while(temp!=NULL){\\n            if(temp->val<x){\\n                 if(pass1){\\n                     pass1 = false;\\n                     head1 = temp;\\n                     curr1 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr1->next = temp;\\n                     curr1=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            else{\\n                if(pass2){\\n                     pass2 = false;\\n                     head2 = temp;\\n                     curr2 = temp;\\n                     temp = temp->next;\\n                 }\\n                 else{\\n                     curr2->next = temp;\\n                     curr2=temp;\\n                     temp = temp->next;\\n                 }\\n            }\\n            \\n        }\\n        curr1->next = head2;\\n        return\\xA0head1;\\nI still don\\'t get why it is giving tle;"
                    },
                    {
                        "username": "tifv",
                        "content": "There are several errors here. For starters, one can observe that `bool pass1,pass2 = true;` only initializes the second variable. Other problems include the end of resulting list not necessarily being set to `NULL`."
                    },
                    {
                        "username": "swapniljk14",
                        "content": "why it showing time limit exceeded?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "A tip for those of you who recognized quicksort partitioning, and are trying to implement it this way: don't.\nYou would get there eventually (I did), but quicksort partitioning is designed for arrays, not linked lists. \nFor a linked list there is a much more straightforward way to do it that will save you a lot of headaches with pointer management and edge cases. Good luck!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my Straightforward approach:-\n\n1. Create an ArrayList<Integer> to store the values of the input ListNode.\n2. Traverse the input ListNode, adding each value to the ArrayList<Integer>.\n3. Sort the ArrayList<Integer> using a Comparator that prioritizes values less than 3.\n4. Create a new ListNode from the sorted ArrayList<Integer>.\n5. Return the new ListNode.\n\n- Constraints friendly"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for help:-\\nhttps://leetcode.com/problems/partition-list/solutions/3303261/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "I feel so stupid.... :(\\nI know the logic but it took me almost 3 damn hours to code this"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Statement is hella confusing. Think of it as you\\'re only allowed to move nodes with node.val<x while maintaining the relative order and leave the rest as it is."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "Nice problem"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "The problem description doesn\\'t say, but I assume you can only manipulate the pointers of the original list nodes, and are not allowed to create new list nodes to copy the values over?"
                    },
                    {
                        "username": "aniketdali",
                        "content": "rearrange the list such that we can create  two logical partitions one < x and another x <="
                    }
                ]
            }
        ]
    },
    {
        "title": "Reverse Words in a String II",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1571833,
                "content": [
                    {
                        "username": "Kyochi",
                        "content": "Hello\\n\\ni don't understand why the time complexity is O(n) instead of O(n\\xb2) or O(n+kw) cause of reverse word operation. k number of word."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The loops aren\\'t nested"
                    },
                    {
                        "username": "thepha3drus",
                        "content": "It was an interview question at one of the BIG 4.  \\n\\nAt a high level, this seems like an application of breaking the input in chunks (intermedia files) and then merging the results. \\n\\nBut, I was looking for a solution that is more in-depth."
                    },
                    {
                        "username": "user3801tN",
                        "content": "its so annoying this question says allocate no extraspace, but it really means the space complexity must constant O(1)"
                    }
                ]
            },
            {
                "id": 1571392,
                "content": [
                    {
                        "username": "Kyochi",
                        "content": "Hello\\n\\ni don't understand why the time complexity is O(n) instead of O(n\\xb2) or O(n+kw) cause of reverse word operation. k number of word."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The loops aren\\'t nested"
                    },
                    {
                        "username": "thepha3drus",
                        "content": "It was an interview question at one of the BIG 4.  \\n\\nAt a high level, this seems like an application of breaking the input in chunks (intermedia files) and then merging the results. \\n\\nBut, I was looking for a solution that is more in-depth."
                    },
                    {
                        "username": "user3801tN",
                        "content": "its so annoying this question says allocate no extraspace, but it really means the space complexity must constant O(1)"
                    }
                ]
            },
            {
                "id": 1888564,
                "content": [
                    {
                        "username": "Kyochi",
                        "content": "Hello\\n\\ni don't understand why the time complexity is O(n) instead of O(n\\xb2) or O(n+kw) cause of reverse word operation. k number of word."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The loops aren\\'t nested"
                    },
                    {
                        "username": "thepha3drus",
                        "content": "It was an interview question at one of the BIG 4.  \\n\\nAt a high level, this seems like an application of breaking the input in chunks (intermedia files) and then merging the results. \\n\\nBut, I was looking for a solution that is more in-depth."
                    },
                    {
                        "username": "user3801tN",
                        "content": "its so annoying this question says allocate no extraspace, but it really means the space complexity must constant O(1)"
                    }
                ]
            }
        ]
    }
]