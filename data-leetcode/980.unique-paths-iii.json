[
    {
        "title": "Unique Paths III",
        "question_content": "You are given an m x n integer array grid where grid[i][j] could be:\n\n\t1 representing the starting square. There is exactly one starting square.\n\t2 representing the ending square. There is exactly one ending square.\n\t0 representing empty squares we can walk over.\n\t-1 representing obstacles that we cannot walk over.\n\nReturn the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.\n&nbsp;\nExample 1:\n\nInput: grid = [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]\nOutput: 2\nExplanation: We have the following two paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)\n2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)\n\nExample 2:\n\nInput: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,2]]\nOutput: 4\nExplanation: We have the following four paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)\n2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)\n3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)\n4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)\n\nExample 3:\n\nInput: grid = [[0,1],[2,0]]\nOutput: 0\nExplanation: There is no path that walks over every empty square exactly once.\nNote that the starting and ending square can be anywhere in the grid.\n\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 20\n\t1 <= m * n <= 20\n\t-1 <= grid[i][j] <= 2\n\tThere is exactly one starting cell and one ending cell.",
        "solutions": [
            {
                "id": 221946,
                "title": "java-python-brute-force-backtracking",
                "content": "# Explanation\\nFirst find out where the start and the end is.\\nAlso We need to know the number of empty cells.\\n\\nWe we try to explore a cell,\\nit will change 0 to -2 and do a dfs in 4 direction.\\n\\nIf we hit the target and pass all empty cells, increment the result.\\n<br>\\n\\n# Complexity\\nTime complexity is as good as dp,\\nbut it take less space and easier to implement.\\n<br>\\n\\n**Java:**\\n```java\\n    int res = 0, empty = 1, sx, sy, ex, ey;\\n    public int uniquePathsIII(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == 0) empty++;\\n                else if (grid[i][j] == 1) {\\n                    sx = i;\\n                    sy = j;\\n                }\\n            }\\n        }\\n        dfs(grid, sx, sy);\\n        return res;\\n    }\\n\\n    public void dfs(int[][] grid, int x, int y) {\\n        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] < 0)\\n            return;\\n        if (grid[x][y] == 2) {\\n            if (empty == 0) res++;\\n            return;\\n        }\\n        grid[x][y] = -2;\\n        empty--;\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x - 1, y);\\n        dfs(grid, x, y + 1);\\n        dfs(grid, x, y - 1);\\n        grid[x][y] = 0;\\n        empty++;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def uniquePathsIII(self, A):\\n        self.res = 0\\n        m, n, empty = len(A), len(A[0]), 1\\n        for i in range(m):\\n            for j in range(n):\\n                if A[i][j] == 1:\\n                    x, y = (i, j)\\n                elif A[i][j] == 0:\\n                    empty += 1\\n\\n        def dfs(x, y, empty):\\n            if not (0 <= x < m and 0 <= y < n and A[x][y] >= 0): return\\n            if A[x][y] == 2:\\n                self.res += empty == 0\\n                return\\n            A[x][y] = -2\\n            dfs(x + 1, y, empty - 1)\\n            dfs(x - 1, y, empty - 1)\\n            dfs(x, y + 1, empty - 1)\\n            dfs(x, y - 1, empty - 1)\\n            A[x][y] = 0\\n        dfs(x, y, empty)\\n        return self.res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    int res = 0, empty = 1, sx, sy, ex, ey;\\n    public int uniquePathsIII(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == 0) empty++;\\n                else if (grid[i][j] == 1) {\\n                    sx = i;\\n                    sy = j;\\n                }\\n            }\\n        }\\n        dfs(grid, sx, sy);\\n        return res;\\n    }\\n\\n    public void dfs(int[][] grid, int x, int y) {\\n        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] < 0)\\n            return;\\n        if (grid[x][y] == 2) {\\n            if (empty == 0) res++;\\n            return;\\n        }\\n        grid[x][y] = -2;\\n        empty--;\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x - 1, y);\\n        dfs(grid, x, y + 1);\\n        dfs(grid, x, y - 1);\\n        grid[x][y] = 0;\\n        empty++;\\n    }\\n```\n```py\\n    def uniquePathsIII(self, A):\\n        self.res = 0\\n        m, n, empty = len(A), len(A[0]), 1\\n        for i in range(m):\\n            for j in range(n):\\n                if A[i][j] == 1:\\n                    x, y = (i, j)\\n                elif A[i][j] == 0:\\n                    empty += 1\\n\\n        def dfs(x, y, empty):\\n            if not (0 <= x < m and 0 <= y < n and A[x][y] >= 0): return\\n            if A[x][y] == 2:\\n                self.res += empty == 0\\n                return\\n            A[x][y] = -2\\n            dfs(x + 1, y, empty - 1)\\n            dfs(x - 1, y, empty - 1)\\n            dfs(x, y + 1, empty - 1)\\n            dfs(x, y - 1, empty - 1)\\n            A[x][y] = 0\\n        dfs(x, y, empty)\\n        return self.res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1553805,
                "title": "c-simple-and-clean-dfs-solution-explained-0ms-faster-than-100",
                "content": "**Explanation:**\\nFirst step, we need to know where the starting point is. We also want to know the number of empty cells.\\nSo we iterate through the grid, count empty cells and save the starting point - `start_x` and `start_y`.\\nNow, we do classic DFS, marking the visited cells with -1 and counting the cells we passed.\\nIf we reached the ending point and we passed `empty` number of cells - this means we passed by every non-obstacle cell.\\n```\\nclass Solution {\\npublic:\\n    int res = 0, empty = 1;\\n    void dfs(vector<vector<int>>& grid, int x, int y, int count) {\\n        if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] == -1) return;\\n        \\n        if (grid[x][y] == 2) {\\n            if(empty == count) res++; \\n            return;\\n        }\\n        \\n        grid[x][y] = -1;\\n        \\n        dfs(grid, x+1, y, count+1);\\n        dfs(grid, x-1, y, count+1);\\n        dfs(grid, x, y+1, count+1);\\n        dfs(grid, x, y-1, count+1);\\n        \\n        grid[x][y] = 0;\\n        \\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int start_x, start_y;\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[0].size(); j++) {\\n                if (grid[i][j] == 1) start_x = i, start_y = j;\\n                else if (grid[i][j] == 0) empty++;\\n            }\\n        }\\n        \\n        dfs(grid, start_x, start_y, 0);\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res = 0, empty = 1;\\n    void dfs(vector<vector<int>>& grid, int x, int y, int count) {\\n        if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] == -1) return;\\n        \\n        if (grid[x][y] == 2) {\\n            if(empty == count) res++; \\n            return;\\n        }\\n        \\n        grid[x][y] = -1;\\n        \\n        dfs(grid, x+1, y, count+1);\\n        dfs(grid, x-1, y, count+1);\\n        dfs(grid, x, y+1, count+1);\\n        dfs(grid, x, y-1, count+1);\\n        \\n        grid[x][y] = 0;\\n        \\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int start_x, start_y;\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[0].size(); j++) {\\n                if (grid[i][j] == 1) start_x = i, start_y = j;\\n                else if (grid[i][j] == 0) empty++;\\n            }\\n        }\\n        \\n        dfs(grid, start_x, start_y, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 221941,
                "title": "c-brute-force-dfs",
                "content": "First, we find our startig point (```i1, j1```) and count the number of empty cells. We then do DFS, marking visited elements and tracking number of steps (```s```). If we reach the target, and number of steps matches the number of empty cells (``` s == t_s```) - we found a path.\\n```\\nint dfs(vector<vector<int>>& g, int i, int j, int s, int t_s) {\\n  if (i < 0 || j < 0 || i >= g.size() || j >= g[0].size() || g[i][j] == -1) return 0;\\n  if (g[i][j] == 2) return s == t_s ? 1 : 0;\\n  g[i][j] = -1;\\n  int paths = dfs(g, i + 1, j, s + 1, t_s) + dfs(g, i - 1, j, s + 1, t_s) +\\n    dfs(g, i, j + 1, s + 1, t_s) + dfs(g, i, j - 1, s + 1, t_s);\\n  g[i][j] = 0;\\n  return paths;\\n}\\nint uniquePathsIII(vector<vector<int>>& g) {\\n  auto i1 = 0, j1 = 0, t_steps = 0;\\n  for (auto i = 0; i < g.size(); ++i)\\n    for (auto j = 0; j < g[0].size(); ++j) {\\n      if (g[i][j] == 1) i1 = i, j1 = j;\\n      if (g[i][j] != -1) ++t_steps;\\n    }\\n  return dfs(g, i1, j1, 1, t_steps);\\n}\\n```\\n## Complexity Analysis\\nRuntime: O(3 ^ n), where n is the total number of cells without obstacles.\\nMemory: O(n) for the DFS stack.",
                "solutionTags": [],
                "code": "```i1, j1```\n```s```\n``` s == t_s```\n```\\nint dfs(vector<vector<int>>& g, int i, int j, int s, int t_s) {\\n  if (i < 0 || j < 0 || i >= g.size() || j >= g[0].size() || g[i][j] == -1) return 0;\\n  if (g[i][j] == 2) return s == t_s ? 1 : 0;\\n  g[i][j] = -1;\\n  int paths = dfs(g, i + 1, j, s + 1, t_s) + dfs(g, i - 1, j, s + 1, t_s) +\\n    dfs(g, i, j + 1, s + 1, t_s) + dfs(g, i, j - 1, s + 1, t_s);\\n  g[i][j] = 0;\\n  return paths;\\n}\\nint uniquePathsIII(vector<vector<int>>& g) {\\n  auto i1 = 0, j1 = 0, t_steps = 0;\\n  for (auto i = 0; i < g.size(); ++i)\\n    for (auto j = 0; j < g[0].size(); ++j) {\\n      if (g[i][j] == 1) i1 = i, j1 = j;\\n      if (g[i][j] != -1) ++t_steps;\\n    }\\n  return dfs(g, i1, j1, 1, t_steps);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1535158,
                "title": "python-backtracking-easy-to-understand-with-explanation",
                "content": "### Introduction\\n\\nThe goal is to travel through the ```grid``` from the starting point (```grid[x][y] == 1```) to the ending point (```grid[x][y] == 2```) while visiting every non-obstacle coordinate (```grid[x][y] == 0```). We can split the problem up into 3 parts:\\n\\n1. How do we know where to start and where to end?\\n2. How do we know if we\\'ve visited every non-obstacle coordinate?\\n3. At each coordinate ```(x, y)```, how do we tell where we can move to next?\\n\\n---\\n\\n### Part 1: Finding our starting and ending points\\n\\nYes, admittedly this is very trivial, but its the first thing I want to settle before we move on to tackle the more difficult logic. The reason this part is even needed in the first place is because the starting and ending points can be anywhere in the given grid, unlike most other grid-traversing problems where the starting and ending positions are fixed.\\n\\nThe simplest of implementations to find the starting and ending points would be:\\n\\n```python\\ndef uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\tstart = end = None\\n\\tfor i in range(len(grid)):\\n\\t\\tfor j in range(len(grid[0])):\\n\\t\\t\\tif grid[i][j] == 1:\\n\\t\\t\\t\\tstart = (i, j)\\n\\t\\t\\telif grid[i][j] == 2:\\n\\t\\t\\t\\tend = (i, j)\\n\\tpass  # main logic here\\n```\\n\\nThis is the most brute-force solution with O(mn) time complexity, but it does the job. We could optimise it further of course:\\n\\n- Break after ```start``` and ```end``` are found (i.e. not ```None```)\\n- Flattening the ```grid``` and using basic math to determine the positions of ```start``` and ```end```\\n\\nFor now, let\\'s leave it as it is. (We\\'ll come back to it in Part 2)\\n\\n---\\n\\n### Part 2: Keeping track of the success condition\\n\\nWhen we finally reach the ending point, we need to know if the path we took was valid. Given the criteria that determine the validity of a path, we have the following implications:\\n\\n1. **We need to know the positions of all non-obstacle coordinates before we traverse the grid.**\\n\\nOtherwise, we won\\'t be able to tell if we\\'ve visited all of them. This also implies that we cannot determine the positions dynamically; if we try to check for all adjacent non-obstacle coordinates at every ```(x, y)```, we will end up having to check ```grid``` again once we reach the end to determine path validity.\\n\\nThis means we need some kind of data structure to store the non-obstacle coordinates. Then, at each coordinate ```(x, y)```, we can check if the adjacent coordinates are non-obstacles, and update the data structure accordingly. This helps us when we get to the ending point, since we can check for some property of the data structure (size, most likely) to immediately determine if the path is valid.\\n\\n2. **We need to keep track of the \\'visited status\\' of each non-obstacle coordinate at all times.**\\n\\nOtherwise, we may end up crossing our paths, or miss one non-obstacle coordinate out in our traversion. Since each non-obstacle coordinate only needs to be visited once, the data structure storing these non-obstacle coordinates double up as an array of \\'flags\\': their presence in the data structure can serve to indicate whether or not they have been visited (depending on implementation).\\n\\nIn consideration of these 2 implications, my implementation is to use a set as the data structure. Before traversion, we can store all non-obstacle coordinates into the set. Then, during traversion, we can check if a coordinate is non-obstacle by checking if it is present in the set, and remove each coordinate when we visit it.\\n\\nThe advantage of this implementation is twofold:\\n\\n- **The functions we need from the set data structure can all be done in O(1) average time complexity**. You can read more about the time complexities [here](https://wiki.python.org/moin/TimeComplexity). The operations we are particularly interested in are ```x in s```, insertion, and deletion (from dict). Hence, apart from the O(mn) auxiliary space, there is no considerable overhead to take into consideration.\\n- **We can find all non-obstacle coordinates while finding the starting and ending points simultaneously**. In comparison with potentially faster methods like flattening ```grid```, the brute-force algorithm that we used earlier (see Part 1) is much better for finding multiple coordinates, since we have no idea how many non-obstacle coordinates there are or where to look for them.\\n\\n```python\\ndef uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\tstart = end = None\\n\\tvisit = set()  # non-obstacle coordinates to visit for path to be valid\\n\\tfor i in range(len(grid)):\\n\\t\\tfor j in range(len(grid[0])):\\n\\t\\t\\tif grid[i][j] == 1:\\n\\t\\t\\t\\tstart = (i, j)\\n\\t\\t\\telif grid[i][j] == 2:\\n\\t\\t\\t\\tend = (i, j)\\n\\t\\t\\t\\tvisit.add(end)  # of course, we need to visit the end coordinate too!\\n\\t\\t\\telif grid[i][j] == 0:\\n\\t\\t\\t\\tvisit.add((i, j))  # non-obstacle coordinate; add to visit\\n\\tpass  # main logic here\\n```\\n\\n**EDIT:** I missed this myself, but there is a way to utilise O(1) auxiliary space after all. Simply 1) having a counter to keep track of how many non-obstacle coordinates we have left to visit while 2) modifying `grid` in-place once we visit these coordinates to denote \\'visited\\' status is good enough. Credit to [@pedro](https://leetcode.com/pedro/) for spotting this improvement. You can view the edited implementation below.\\n\\n---\\n\\n### Part 3: Moving through the grid\\n\\nObviously, we don\\'t actually know if a particular adjacent non-obstacle coordinate will be good or not (i.e. part of the valid path, if any) until we actually try to traverse through the coordinate. This is where backtracking comes in: We can just move to any adjacent non-obstacle coordinate, and if it (eventually) leads to a dead end or an invalid path, we can \\'return\\' (backtrack) to the current coordinate and try again with a different non-obstacle coordinate.\\n\\nThere are a few considerations:\\n\\n- A given coordinate can be the diverging point for multiple valid paths. In other words, for a given coordinate ```(x, y)```, any combination of the adjacent coordinates ```(x-1, y)```, ```(x+1, y)```, ```(x, y-1)```, ```(x, y+1)``` can lead to valid paths (if those coordinates are non-obstacles). This means that **even if we do find a valid path, we still need to \\'return\\' back to the current coordinate and try again for all possible adjacent coordinates**.\\n- Upon \\'returning\\' to a given coordinate, we need to likewise \\'un-visit\\' the coordinate we came from. This means that **we need to add the coordinate back into the set before we try a different path**.\\n- The success condition in all of this backtracking is when we reach the ending point with no more coordinates to visit (i.e. the set is empty). We then need to **relay this information back to previous coordinates to consolidate all possible paths, all the way until we backtrack back to the starting point**.\\n\\n---\\n\\n### Implementation\\n\\nOriginal Answer (using set):\\n\\n```python\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\t\\t# first, prepare the starting and ending points\\n\\t\\t# simultaneously, record all the non-obstacle coordinates\\n        start = end = None\\n        visit = set()\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 0:\\n                    visit.add((i, j))\\n                elif grid[i][j] == 1:\\n                    start = (i, j)\\n                elif grid[i][j] == 2:\\n                    end = (i, j)\\n                    visit.add((i, j))\\n        \\n        def backtrack(x, y, visit):\\n            if (x, y) == end:\\n\\t\\t\\t\\t# implement success condition: valid only if there are no more coordinates to visit\\n                return len(visit) == 0\\n            result = 0  # assume no valid paths by default\\n\\t\\t\\t\\n\\t\\t\\t# we need to try every possible path from this coordinate\\n            if (x-1, y) in visit:\\n\\t\\t\\t\\t# the coordinate directly above this one is non-obstacle, try that path\\n                visit.remove((x-1, y))  # first, note down the \\'visited status\\' of the coordinate\\n                result += backtrack(x-1, y, visit)  # then, DFS to find all valid paths from that coordinate\\n                visit.add((x-1, y))  # last, reset the \\'visited status\\' of the coordinate\\n            if (x+1, y) in visit:\\n\\t\\t\\t\\t# the coordinate directly below this one is non-obstacle, try that path\\n                visit.remove((x+1, y))\\n                result += backtrack(x+1, y, visit)\\n                visit.add((x+1, y))\\n            if (x, y-1) in visit:\\n\\t\\t\\t\\t# the coordinate directly to the left of this one is non-obstacle, try that path\\n                visit.remove((x, y-1))\\n                result += backtrack(x, y-1, visit)\\n                visit.add((x, y-1))\\n            if (x, y+1) in visit:\\n\\t\\t\\t\\t# the coordinate directly to the right of this one is non-obstacle, try that path\\n                visit.remove((x, y+1))\\n                result += backtrack(x, y+1, visit)\\n                visit.add((x, y+1))\\n            return result\\n        \\n        return backtrack(start[0], start[1], visit)  # we start from the starting point, backtrack all the way back, and consolidate the result\\n```\\n\\n**EDIT:** Optimised answer (based on comments):\\n\\n```python\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        # iterate through the grid to get relevant info\\n        start = None  # to store starting point\\n        count = 0  # to count number of squares to walk over\\n        for i in range(m):\\n            for j in range(n):\\n                count += grid[i][j] == 0\\n                if not start and grid[i][j] == 1:\\n                    start = (i, j)\\n        \\n        def backtrack(i: int, j: int) -> int:\\n            \"\"\"\\n            Backtracking algo to find all valid paths from (i, j).\\n            :param i: Index of row (where top = 0) of coordinate.\\n            :param j: Index of column (where left = 0) of coordinate.\\n            :returns: Total number of valid paths from (i, j).\\n            \"\"\"\\n            nonlocal count\\n            result = 0\\n            for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\\n                # border check\\n                if 0 <= x < m and 0 <= y < n:\\n                    if grid[x][y] == 0:\\n                        # traverse down this path\\n                        grid[x][y] = -1\\n                        count -= 1\\n                        result += backtrack(x, y)\\n                        # backtrack and reset\\n                        grid[x][y] = 0\\n                        count += 1\\n                    elif grid[x][y] == 2:\\n                        # check if all squares have been walked over\\n                        result += count == 0\\n            return result\\n        \\n        # perform DFS + backtracking to find valid paths\\n        return backtrack(start[0], start[1])\\n```\\n\\nBased on my submission results, there seems to be a slight improvement in both runtime and memory usage.\\n\\n---\\n\\n### Final Result\\n\\n![image](https://assets.leetcode.com/users/images/140c97c4-599e-407a-be5d-b6dc90620dc6_1634923959.5940614.png)\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```grid```\n```grid[x][y] == 1```\n```grid[x][y] == 2```\n```grid[x][y] == 0```\n```(x, y)```\n```python\\ndef uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\tstart = end = None\\n\\tfor i in range(len(grid)):\\n\\t\\tfor j in range(len(grid[0])):\\n\\t\\t\\tif grid[i][j] == 1:\\n\\t\\t\\t\\tstart = (i, j)\\n\\t\\t\\telif grid[i][j] == 2:\\n\\t\\t\\t\\tend = (i, j)\\n\\tpass  # main logic here\\n```\n```start```\n```end```\n```None```\n```grid```\n```start```\n```end```\n```(x, y)```\n```grid```\n```(x, y)```\n```x in s```\n```grid```\n```python\\ndef uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\tstart = end = None\\n\\tvisit = set()  # non-obstacle coordinates to visit for path to be valid\\n\\tfor i in range(len(grid)):\\n\\t\\tfor j in range(len(grid[0])):\\n\\t\\t\\tif grid[i][j] == 1:\\n\\t\\t\\t\\tstart = (i, j)\\n\\t\\t\\telif grid[i][j] == 2:\\n\\t\\t\\t\\tend = (i, j)\\n\\t\\t\\t\\tvisit.add(end)  # of course, we need to visit the end coordinate too!\\n\\t\\t\\telif grid[i][j] == 0:\\n\\t\\t\\t\\tvisit.add((i, j))  # non-obstacle coordinate; add to visit\\n\\tpass  # main logic here\\n```\n```(x, y)```\n```(x-1, y)```\n```(x+1, y)```\n```(x, y-1)```\n```(x, y+1)```\n```python\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\t\\t# first, prepare the starting and ending points\\n\\t\\t# simultaneously, record all the non-obstacle coordinates\\n        start = end = None\\n        visit = set()\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 0:\\n                    visit.add((i, j))\\n                elif grid[i][j] == 1:\\n                    start = (i, j)\\n                elif grid[i][j] == 2:\\n                    end = (i, j)\\n                    visit.add((i, j))\\n        \\n        def backtrack(x, y, visit):\\n            if (x, y) == end:\\n\\t\\t\\t\\t# implement success condition: valid only if there are no more coordinates to visit\\n                return len(visit) == 0\\n            result = 0  # assume no valid paths by default\\n\\t\\t\\t\\n\\t\\t\\t# we need to try every possible path from this coordinate\\n            if (x-1, y) in visit:\\n\\t\\t\\t\\t# the coordinate directly above this one is non-obstacle, try that path\\n                visit.remove((x-1, y))  # first, note down the \\'visited status\\' of the coordinate\\n                result += backtrack(x-1, y, visit)  # then, DFS to find all valid paths from that coordinate\\n                visit.add((x-1, y))  # last, reset the \\'visited status\\' of the coordinate\\n            if (x+1, y) in visit:\\n\\t\\t\\t\\t# the coordinate directly below this one is non-obstacle, try that path\\n                visit.remove((x+1, y))\\n                result += backtrack(x+1, y, visit)\\n                visit.add((x+1, y))\\n            if (x, y-1) in visit:\\n\\t\\t\\t\\t# the coordinate directly to the left of this one is non-obstacle, try that path\\n                visit.remove((x, y-1))\\n                result += backtrack(x, y-1, visit)\\n                visit.add((x, y-1))\\n            if (x, y+1) in visit:\\n\\t\\t\\t\\t# the coordinate directly to the right of this one is non-obstacle, try that path\\n                visit.remove((x, y+1))\\n                result += backtrack(x, y+1, visit)\\n                visit.add((x, y+1))\\n            return result\\n        \\n        return backtrack(start[0], start[1], visit)  # we start from the starting point, backtrack all the way back, and consolidate the result\\n```\n```python\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        # iterate through the grid to get relevant info\\n        start = None  # to store starting point\\n        count = 0  # to count number of squares to walk over\\n        for i in range(m):\\n            for j in range(n):\\n                count += grid[i][j] == 0\\n                if not start and grid[i][j] == 1:\\n                    start = (i, j)\\n        \\n        def backtrack(i: int, j: int) -> int:\\n            \"\"\"\\n            Backtracking algo to find all valid paths from (i, j).\\n            :param i: Index of row (where top = 0) of coordinate.\\n            :param j: Index of column (where left = 0) of coordinate.\\n            :returns: Total number of valid paths from (i, j).\\n            \"\"\"\\n            nonlocal count\\n            result = 0\\n            for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\\n                # border check\\n                if 0 <= x < m and 0 <= y < n:\\n                    if grid[x][y] == 0:\\n                        # traverse down this path\\n                        grid[x][y] = -1\\n                        count -= 1\\n                        result += backtrack(x, y)\\n                        # backtrack and reset\\n                        grid[x][y] = 0\\n                        count += 1\\n                    elif grid[x][y] == 2:\\n                        # check if all squares have been walked over\\n                        result += count == 0\\n            return result\\n        \\n        # perform DFS + backtracking to find valid paths\\n        return backtrack(start[0], start[1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973622,
                "title": "java-code-with-dfs-and-backtracking-100-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int zero = 0 , a = 0, b = 0 ;\\n        for(int r = 0; r < grid.length ; r++){\\n            for(int c = 0; c < grid[0].length; c++){\\n                if(grid[r][c] == 0)   zero++;\\n                   else if(grid[r][c] == 1){\\n                    a = r;\\n                    b = c;\\n                }\\n            }\\n        }\\n        return path(grid, a, b, zero);\\n    }\\n    private int path(int[][] grid, int x, int y, int zero){\\n        if(x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == -1)\\n           return 0;\\n        if(grid[x][y] == 2)\\n           return zero == -1 ? 1 : 0;\\n        grid[x][y] = -1;\\n        zero--;\\n        int totalCount = path(grid, x + 1, y, zero) + path(grid, x, y + 1, zero) +\\n                         path(grid, x - 1, y, zero) + path(grid, x, y - 1, zero);\\n        grid[x][y] = 0;\\n        zero++;\\n\\n        return totalCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int zero = 0 , a = 0, b = 0 ;\\n        for(int r = 0; r < grid.length ; r++){\\n            for(int c = 0; c < grid[0].length; c++){\\n                if(grid[r][c] == 0)   zero++;\\n                   else if(grid[r][c] == 1){\\n                    a = r;\\n                    b = c;\\n                }\\n            }\\n        }\\n        return path(grid, a, b, zero);\\n    }\\n    private int path(int[][] grid, int x, int y, int zero){\\n        if(x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == -1)\\n           return 0;\\n        if(grid[x][y] == 2)\\n           return zero == -1 ? 1 : 0;\\n        grid[x][y] = -1;\\n        zero--;\\n        int totalCount = path(grid, x + 1, y, zero) + path(grid, x, y + 1, zero) +\\n                         path(grid, x - 1, y, zero) + path(grid, x, y - 1, zero);\\n        grid[x][y] = 0;\\n        zero++;\\n\\n        return totalCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554054,
                "title": "c-dfs-backtracking-bit-manipulation-short-simple-w-explanation-beats-100",
                "content": "\\nWe are given a `m x n` grid in which we need to find the number of distinct paths visiting every cell exactly once (except obstacle cells with value -1) starting from cell with value 1 and ending at cell with value 2.\\n\\n\\n<details open>\\n<summary><b>Try Solving using Hint</b></summary>\\n\\n1. Observe that we need to explore all adjacent cells from current cell since we dont which cell might be valid. Try brute-force\\n2. Recursively explore from each cell. Discard invalid paths (reached obstacle, visited multiple times, etc)\\n</details>\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Backtracking + DFS)***\\n\\n\\nThere isn\\'t a specific strategy that we can apply to choose our paths since we dont initially know what a cell value might be and so we must **explore the whole grid exhaustively**, visiting one cell after another, starting from `G[i][j] = 1`. If at any point we -\\n* reach an obstacle or,\\n* visit an empty cell twice or,\\n* reach end cell without visiting each empty cells,\\n\\nthen we know that we have **reached an invalid path**. We will discard this path or in other words, we will **backtrack** from the current point and explore other options.  We also need to mark a cell so that we know that this cell is visited. We do this by changing a visited cell value to `3` (if input modification isn\\'t allowed - see below). We change it back to `0` if we backtrack.\\n\\nWe continue the above process till we reach the end cell and have visited all empty cells once. At this point, we have found a valid path and we increment the resultant count.\\n\\nWe don\\'t know the starting cell of the grid nor do we know the number of empty cells. So, we iterate over the grid once to find the start cell and number of cells to visit. Then we call our **backtracking DFS function from start cell** and follow the process described above.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& G) {\\n        int startRow, startCol, cellsToVisit = 0;\\n        for(int i = 0; i < size(G); i++)\\n            for(int j = 0; j < size(G[0]); j++) \\n                if(G[i][j] == 1) startRow = i, startCol = j;\\n                else if(G[i][j] != -1) cellsToVisit++;\\n\\t\\t\\t\\t\\n        dfs(G, startRow, startCol, cellsToVisit);\\n        return ans;\\n    }\\nprivate:\\n    int ans = 0, dir[5] {0, 1, 0, -1, 0};  // <- a common way to make 4-way exploration in dfs concise\\n\\t\\n\\t// checks if cell is valid. If none of 3 points mentioned in post is satisfied, it is a valid cell\\n    bool isValidCell(vector<vector<int>>& G, int i, int j) {\\n        return i >= 0 && j >= 0 && i < size(G) && j < size(G[0]) && G[i][j] != -1 && G[i][j] != 3;\\n    }\\n\\t\\n    void dfs(vector<vector<int>>& G, int i, int j, int cellsToVisit) {\\n        if(not isValidCell(G, i, j)) return;   // return if cell is invalid\\n        if(G[i][j] == 2) {                     // reached end cell\\n            if(cellsToVisit == 0) ans++;       // if all cells are visited, increment valid path count\\n            return;                            // no further exploration possible after reaching end cell\\n        }\\n        G[i][j] = 3;                           // mark cell as visited\\n        for(int k = 0; k < 4; k++)             // explore path futher 4-directionally\\n            dfs(G, i + dir[k], j + dir[k+1], cellsToVisit - 1);    \\n        G[i][j] = 0;                           // backtrack\\n    }        \\n};\\n```\\n\\n***Time Complexity :*** **<code>O(3<sup>m * n</sup>)</code>**. At every cell (except the start cell), we can continue the path exploration in 3 direction (after excuding previous visited cell) and there can be `O(m*n)` cells in total to be visited. In reality, the number of recursions required is much less due to dead-ends.\\n***Space Complexity :*** **`O(m*n)`** required for implicit recursive stack in `dfs`.\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - II (Backtracking + DFS + Bit Manipulation)***\\n\\nIn the above solution, we were marking a visited cell by changing the grid\\'s cell value. If the input grid cannot be modified, we can use auxillary boolean matrix or make a copy of grid. However, an elegant solution is to use bitmask. This works because the grid is small enough to fit within integer bits (`m * n <= 20`).\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& G) {\\n        int startRow, startCol, mask = 0;\\n        m = size(G), n = size(G[0]);\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++) {\\n                if(G[i][j] == 1) startRow = i, startCol = j;\\n                if(G[i][j] != -1) mask |= 1 << i*n+j;       // set bits of cells that need to be visited\\n            }\\n\\n        dfs(G, startRow, startCol, mask);\\n        return ans;\\n    }\\nprivate:\\n    int m, n, ans = 0, dir[5] {0, 1, 0, -1, 0}; \\n    bool isValidCell(vector<vector<int>>& G, int i, int j, int mask) {\\n        return i >= 0 && j >= 0 && i < size(G) && j < size(G[0]) && G[i][j] != -1 && mask & 1 << i*n+j;\\n    }\\n\\t\\n    void dfs(vector<vector<int>>& G, int i, int j, int mask) {\\n        if(not isValidCell(G, i, j, mask)) return;\\n        mask ^= 1 << i*n+j;                                  // mark as visited by unsetting bit\\n        if(G[i][j] == 2) {       \\n            if(!mask) ans++;                                 // valid path if all required cells are visited\\n            return;              \\n        }\\n        for(int k = 0; k < 4; k++)\\n            dfs(G, i + dir[k], j + dir[k+1], mask);\\n    }        \\n};\\n```\\n\\n***Time Complexity :*** **<code>O(3<sup>m * n</sup>)</code>**\\n***Space Complexity :*** **`O(m*n)`** \\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Bit Manipulation",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& G) {\\n        int startRow, startCol, cellsToVisit = 0;\\n        for(int i = 0; i < size(G); i++)\\n            for(int j = 0; j < size(G[0]); j++) \\n                if(G[i][j] == 1) startRow = i, startCol = j;\\n                else if(G[i][j] != -1) cellsToVisit++;\\n\\t\\t\\t\\t\\n        dfs(G, startRow, startCol, cellsToVisit);\\n        return ans;\\n    }\\nprivate:\\n    int ans = 0, dir[5] {0, 1, 0, -1, 0};  // <- a common way to make 4-way exploration in dfs concise\\n\\t\\n\\t// checks if cell is valid. If none of 3 points mentioned in post is satisfied, it is a valid cell\\n    bool isValidCell(vector<vector<int>>& G, int i, int j) {\\n        return i >= 0 && j >= 0 && i < size(G) && j < size(G[0]) && G[i][j] != -1 && G[i][j] != 3;\\n    }\\n\\t\\n    void dfs(vector<vector<int>>& G, int i, int j, int cellsToVisit) {\\n        if(not isValidCell(G, i, j)) return;   // return if cell is invalid\\n        if(G[i][j] == 2) {                     // reached end cell\\n            if(cellsToVisit == 0) ans++;       // if all cells are visited, increment valid path count\\n            return;                            // no further exploration possible after reaching end cell\\n        }\\n        G[i][j] = 3;                           // mark cell as visited\\n        for(int k = 0; k < 4; k++)             // explore path futher 4-directionally\\n            dfs(G, i + dir[k], j + dir[k+1], cellsToVisit - 1);    \\n        G[i][j] = 0;                           // backtrack\\n    }        \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& G) {\\n        int startRow, startCol, mask = 0;\\n        m = size(G), n = size(G[0]);\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++) {\\n                if(G[i][j] == 1) startRow = i, startCol = j;\\n                if(G[i][j] != -1) mask |= 1 << i*n+j;       // set bits of cells that need to be visited\\n            }\\n\\n        dfs(G, startRow, startCol, mask);\\n        return ans;\\n    }\\nprivate:\\n    int m, n, ans = 0, dir[5] {0, 1, 0, -1, 0}; \\n    bool isValidCell(vector<vector<int>>& G, int i, int j, int mask) {\\n        return i >= 0 && j >= 0 && i < size(G) && j < size(G[0]) && G[i][j] != -1 && mask & 1 << i*n+j;\\n    }\\n\\t\\n    void dfs(vector<vector<int>>& G, int i, int j, int mask) {\\n        if(not isValidCell(G, i, j, mask)) return;\\n        mask ^= 1 << i*n+j;                                  // mark as visited by unsetting bit\\n        if(G[i][j] == 2) {       \\n            if(!mask) ans++;                                 // valid path if all required cells are visited\\n            return;              \\n        }\\n        for(int k = 0; k < 4; k++)\\n            dfs(G, i + dir[k], j + dir[k+1], mask);\\n    }        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1553873,
                "title": "java-easy-solution-dfs-backtracking-explanation-simplified",
                "content": "Hey Programmers,\\nI solve this problem using DFS + Backtracking approach\\n\\n* First find out where the start and the end is.\\n* Also We need to know the number of empty cells.\\n* We try to explore a cell,\\n* Let\\'s understand it using an example :- \\n\\n![image](https://assets.leetcode.com/users/images/cab2469b-d1b5-4b6a-9b26-31c641fe9608_1635817324.7521498.png)\\n\\n* it will change 0 to -1 and do a dfs in 4 direction.\\n\\n* If we hit the target and pass all empty cells, increment the result.\\n\\n![image](https://assets.leetcode.com/users/images/83e606a6-26fd-4ef4-9ce0-45625d353d4b_1635817420.0894692.png)\\n\\n\\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int zero = 0; // Count the 0\\'s\\n        int sx = 0; // starting x index\\n        int sy = 0; // starting y index\\n        \\n        for(int r = 0; r < grid.length; r++){ // r = row\\n            for(int c = 0; c < grid[0].length; c++){ // c = column\\n                if(grid[r][c] == 0) zero++; // if current cell is 0, count it.\\n                else if(grid[r][c] == 1){\\n                    sx = r; // starting x co-ordinate\\n                    sy = c; // starting y co-ordinate\\n                }\\n            }\\n        }\\n        return dfs(grid, sx, sy, zero);\\n    }\\n    public int dfs(int grid[][], int x, int y, int zero){\\n        // Base Condition\\n        if(x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == -1){\\n            return 0;\\n        }\\n        if(grid[x][y] == 2){\\n            return zero == -1 ? 1 : 0; // Why zero = -1, because in above example we have 9 zero\\'s. So, when we reach the final cell we are covering one cell extra then the zero count. \\n            // If that\\'s the case we find the path and return \\'1\\' otherwise return \\'0\\';\\n        }\\n        grid[x][y] = -1; // mark the visited cells as -1;\\n        zero--; // and reduce the zero by 1\\n        \\n        int totalPaths = dfs(grid, x + 1, y, zero) + // calculating all the paths available in 4 directions\\n            dfs(grid, x - 1, y, zero) + \\n            dfs(grid, x, y + 1, zero) + \\n            dfs(grid, x, y - 1, zero);\\n        \\n        // Let\\'s say if we are not able to count all the paths. Now we use Backtracking over here\\n        grid[x][y] = 0;\\n        zero++;\\n        \\n        return totalPaths; // if we get all the paths, simply return it.\\n    }\\n}\\n```\\n\\nI hope this will help you to understand. Thanks (:",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int zero = 0; // Count the 0\\'s\\n        int sx = 0; // starting x index\\n        int sy = 0; // starting y index\\n        \\n        for(int r = 0; r < grid.length; r++){ // r = row\\n            for(int c = 0; c < grid[0].length; c++){ // c = column\\n                if(grid[r][c] == 0) zero++; // if current cell is 0, count it.\\n                else if(grid[r][c] == 1){\\n                    sx = r; // starting x co-ordinate\\n                    sy = c; // starting y co-ordinate\\n                }\\n            }\\n        }\\n        return dfs(grid, sx, sy, zero);\\n    }\\n    public int dfs(int grid[][], int x, int y, int zero){\\n        // Base Condition\\n        if(x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == -1){\\n            return 0;\\n        }\\n        if(grid[x][y] == 2){\\n            return zero == -1 ? 1 : 0; // Why zero = -1, because in above example we have 9 zero\\'s. So, when we reach the final cell we are covering one cell extra then the zero count. \\n            // If that\\'s the case we find the path and return \\'1\\' otherwise return \\'0\\';\\n        }\\n        grid[x][y] = -1; // mark the visited cells as -1;\\n        zero--; // and reduce the zero by 1\\n        \\n        int totalPaths = dfs(grid, x + 1, y, zero) + // calculating all the paths available in 4 directions\\n            dfs(grid, x - 1, y, zero) + \\n            dfs(grid, x, y + 1, zero) + \\n            dfs(grid, x, y - 1, zero);\\n        \\n        // Let\\'s say if we are not able to count all the paths. Now we use Backtracking over here\\n        grid[x][y] = 0;\\n        zero++;\\n        \\n        return totalPaths; // if we get all the paths, simply return it.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855647,
                "title": "python-simple-dfs-backtracking-explained",
                "content": "If you look carefully at your problem constraints: `m*n <= 20`, where `m` and `n` your grid sizes, we can guess, that we need to use dfs in this problem: that is try to check all possible options. So, we need to do several steps:\\n\\n1. Find our starting point: traverse all grid and find cell with value `1`. Also count number of cells we need to visit, I denoted them `empty`.\\n2. Now, use recursive `dfs(x,y, rest)` function, where `x` and `y` are current coordinates in our cell and `rest` is how many empty cells we need to traverse.\\n2.1 First we check if we can move to the current cell: if it is outside our grid and it is already visited or have obstacle, we return\\n2.2 If current cell is end cell and we already visited all cells, we add `1` to `self.ans`.\\n2.3 Define list of neighbours and for each of them run our `dfs`: mark visited cell with `-2` and then mark it back when we go outside recursion. It is important to do this, because in python `grid` is global variable and we need to change it back.\\n3. FInally, we just run `dfs(sx, sy, empty - 1)`, where `(sx, sy)` is coordinates of starting cell and return `self.ans`.\\n\\n**Complexity**: Space complexity is `O(mn)`, this is the possible biggest length of our recursion stack. Time complexity is `O(3^(mn))`, because on each step (except first) we have no more than `3` options to go: all directions except direction we came from. In practice however it will work much faster than this estimate because of big number of dead-ends\\n\\n```\\nclass Solution:\\n    def uniquePathsIII(self, grid):\\n        self.ans, empty = 0, 0\\n        m, n = len(grid[0]), len(grid)\\n        def dfs(x, y, rest):\\n            if x < 0 or x >= n or y < 0 or y >= m or  grid[x][y] < 0: return\\n            if grid[x][y] == 2 and rest == 0:\\n                self.ans += 1\\n            \\n            neibs = [[0,1],[0,-1],[1,0],[-1,0]]\\n            for dx, dy in neibs:\\n                save = grid[x][y]\\n                grid[x][y] = -2\\n                dfs(x+dx, y+dy, rest - 1)\\n                grid[x][y] = save\\n            \\n        for i,j in product(range(n), range(m)):\\n            if grid[i][j] == 1: (sx, sy) = (i,j)\\n            empty += (grid[i][j] != -1)\\n\\n        dfs(sx, sy, empty-1)\\n        return self.ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid):\\n        self.ans, empty = 0, 0\\n        m, n = len(grid[0]), len(grid)\\n        def dfs(x, y, rest):\\n            if x < 0 or x >= n or y < 0 or y >= m or  grid[x][y] < 0: return\\n            if grid[x][y] == 2 and rest == 0:\\n                self.ans += 1\\n            \\n            neibs = [[0,1],[0,-1],[1,0],[-1,0]]\\n            for dx, dy in neibs:\\n                save = grid[x][y]\\n                grid[x][y] = -2\\n                dfs(x+dx, y+dy, rest - 1)\\n                grid[x][y] = save\\n            \\n        for i,j in product(range(n), range(m)):\\n            if grid[i][j] == 1: (sx, sy) = (i,j)\\n            empty += (grid[i][j] != -1)\\n\\n        dfs(sx, sy, empty-1)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974068,
                "title": "c-dfs-backtracking-with-intuition-approach-and-comments",
                "content": "# Intuition\\nAs constraints are very less, we will try to implement it by exploring all possibilities from the each cell.\\n\\n# Approach\\nWe will keep count of empty cell `grid[i][j] == 0` in the variable `empty` and will have the start and end destination stored in the pair of integers `src` and `dest`.\\n\\nWe start the call from `{src.first, src.second, empty}`. Now for all `grid[i][j]` we have 4 possible directions. We will try all that and will see that anyone of that is yielding the desired solution or not. \\n\\n### State = `dfs(i, j, left)`\\n\\nAt this state, we are currently on the cell {i, j} and have the emplty cells as `left`. \\n\\nFirst of all let\\'s mark this cell as visited by assigning it the value of an obstacle. (for backtracking)\\n\\nNow initialize the `ans as 0` and iterate over all possible direction from the current cell. if the direction is valid and is not an obstacle then we will add the ans of that direction our current ans. Remember we have taken this cell in the path so the empty cell would now be equal to `left - 1`.\\n\\nIn short, `ans += dfs(x, y, left - 1);`\\n\\nAfter enumerating all the direction, we have to mark current cell as empty cell for the process of `backtracking`.\\n\\n### Base Case = `dfs(i, j, left)`\\nIf we have used all the empty cell i.e., `left == -1` and are at the destination, then we found the correct 4-directional walks. So return 1 for this state.\\n\\n# Code\\n```\\nclass Solution {\\n    // Dimensions \\n    int m, n;\\n\\n    // Direction Vectors\\n    vector<int> dx = {-1, 1, 0, 0};\\n    vector<int> dy = {0, 0, -1, 1};\\n\\npublic:\\n    // function to check for the validity of CELLij\\n    bool isvalid(int i, int j)\\n    {\\n        return i >= 0 and j >= 0 and i < m and j < n;\\n    }\\n\\n    int dfs(int i, int j, int left, pair<int, int> dest, vector<vector<int>> &grid)\\n    {\\n        // Base case\\n        if (left == -1 and pair<int, int>(i, j) == dest)\\n            return 1;\\n\\n        // Mark visited\\n        grid[i][j] = -1;\\n\\n        int ans = 0;\\n        for (int k = 0; k < 4; k++)\\n        {\\n            int x = i + dx[k];\\n            int y = j + dy[k];\\n\\n            // Add up all possibilities to answer\\n            if (isvalid(x, y) and grid[x][y] != -1)\\n                ans += dfs(x, y, left - 1, dest, grid);\\n        }\\n\\n        // Backtrack\\n        grid[i][j] = 0;\\n\\n        return ans;\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>> &grid)\\n    {\\n        m = grid.size(), n = grid[0].size();\\n\\n        pair<int, int> src, dest;\\n        int empty = 0;\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 0)\\n                    empty++;\\n                if (grid[i][j] == 1)\\n                    src = {i, j};\\n                if (grid[i][j] == 2)\\n                    dest = {i, j};\\n            }\\n        }\\n\\n        return dfs(src.first, src.second, empty, dest, grid);\\n    }\\n};\\n```\\n\\nIf you like it, Please Upvote !!. Also check my [repo](https://github.com/jatin1510/Templates) for amazing templates of CP and DSA.",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    // Dimensions \\n    int m, n;\\n\\n    // Direction Vectors\\n    vector<int> dx = {-1, 1, 0, 0};\\n    vector<int> dy = {0, 0, -1, 1};\\n\\npublic:\\n    // function to check for the validity of CELLij\\n    bool isvalid(int i, int j)\\n    {\\n        return i >= 0 and j >= 0 and i < m and j < n;\\n    }\\n\\n    int dfs(int i, int j, int left, pair<int, int> dest, vector<vector<int>> &grid)\\n    {\\n        // Base case\\n        if (left == -1 and pair<int, int>(i, j) == dest)\\n            return 1;\\n\\n        // Mark visited\\n        grid[i][j] = -1;\\n\\n        int ans = 0;\\n        for (int k = 0; k < 4; k++)\\n        {\\n            int x = i + dx[k];\\n            int y = j + dy[k];\\n\\n            // Add up all possibilities to answer\\n            if (isvalid(x, y) and grid[x][y] != -1)\\n                ans += dfs(x, y, left - 1, dest, grid);\\n        }\\n\\n        // Backtrack\\n        grid[i][j] = 0;\\n\\n        return ans;\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>> &grid)\\n    {\\n        m = grid.size(), n = grid[0].size();\\n\\n        pair<int, int> src, dest;\\n        int empty = 0;\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 0)\\n                    empty++;\\n                if (grid[i][j] == 1)\\n                    src = {i, j};\\n                if (grid[i][j] == 2)\\n                    dest = {i, j};\\n            }\\n        }\\n\\n        return dfs(src.first, src.second, empty, dest, grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289954,
                "title": "java-solution-dfs-with-backtracking",
                "content": "**Idea**\\nSince the requirement is to touch every empty cell exactly once, we need `dfs` and maintain a step count `count` for the recursive path and when we reach destination, we compare how many empty cells we covered.\\nTo avoid cycles in the path, we mark the cells in the current dfs path as blockers and remove them while coming back.\\n\\n```\\npublic int uniquePathsIII(int[][] g) {\\n        int x = 0, y = 0, empty = 0;\\n        for(int i=0; i < g.length; i++)\\n            for(int j=0; j < g[0].length; j++)\\n                if(g[i][j] == 0)\\n                    ++empty;\\n                else if(g[i][j] == 1){\\n                    x = i;\\n                    y = j;\\n                }\\n\\n        return dfs(g, x, y, -1, empty);\\n    }\\n    private int dfs(int[][] g, int i, int j, int count, int need){\\n        if(i < 0 || i == g.length || j < 0 || j == g[0].length || g[i][j] == -1) return 0;\\n        if(g[i][j] == 2){\\n            if(count == need)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        g[i][j] = -1;\\n        int total = dfs(g, i-1, j, count+1, need);\\n        total += dfs(g, i, j+1, count+1, need);\\n        total += dfs(g, i+1, j, count+1, need);\\n        total += dfs(g, i, j-1, count+1, need);\\n        g[i][j] = 0;\\n        return total;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int uniquePathsIII(int[][] g) {\\n        int x = 0, y = 0, empty = 0;\\n        for(int i=0; i < g.length; i++)\\n            for(int j=0; j < g[0].length; j++)\\n                if(g[i][j] == 0)\\n                    ++empty;\\n                else if(g[i][j] == 1){\\n                    x = i;\\n                    y = j;\\n                }\\n\\n        return dfs(g, x, y, -1, empty);\\n    }\\n    private int dfs(int[][] g, int i, int j, int count, int need){\\n        if(i < 0 || i == g.length || j < 0 || j == g[0].length || g[i][j] == -1) return 0;\\n        if(g[i][j] == 2){\\n            if(count == need)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        g[i][j] = -1;\\n        int total = dfs(g, i-1, j, count+1, need);\\n        total += dfs(g, i, j+1, count+1, need);\\n        total += dfs(g, i+1, j, count+1, need);\\n        total += dfs(g, i, j-1, count+1, need);\\n        g[i][j] = 0;\\n        return total;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1554601,
                "title": "java-simple-and-readable-solution-dfs-backtracking",
                "content": "**Problem statement at a glance:** So, a m x n matrix is given with a \\'1\\', \\'2\\' ,\\'-1\\' and \\'0\\'s. We need to find all valid paths and for a path from 1 -> 2, and we must cover all 0\\'s exactly once.\\n**Approach:**\\n1. First calculate total number of zeros we need to cover and starting cell indices.\\n2. Make a DFS Call. It is used to traverse four directions for every cell.\\n3. Once you find a valid cell, make that cell as invalid and perform dfs for four directions and after that make it as valid (Backtrack), because that cell may be counted in other paths.\\n**Dry run/Pictorial representation of an example:**\\n![image](https://assets.leetcode.com/users/images/a99199e9-cfe4-42c0-95c4-f46b2cd29818_1635841909.3198805.png)\\n![image](https://assets.leetcode.com/users/images/3ceb86c4-34ae-46bd-98dc-79e73da16548_1635841988.6123862.png)\\n\\nCross ticks shows they are invalid. Sorry for the bad drawing\\uD83D\\uDE05\\n\\n**Time Complexity:** If we observe the dry run, atleast 1 cell will be invalid (It may repeat again...visited again). So the number of cells may be as follows:\\n   3 ~ 3^1\\n   3 3 3 ~ 3^2\\n   3 3 3 3 3 3 3 3 3 ~ 3^3\\n   .\\n   .\\n   .\\n   upto 3^n , here n is M * N\\n   So time complexity is O(3^(N * M )) \\n   **Space Complexity:**  O(M* N) - Total number of cells in grid. And it is due to recursive calls.\\n   \\n   **Code:**\\n   ```\\nclass Solution { \\n    // DFS function\\n    public int DFS(int [][]obstacleGrid,int i,int j,int totalZeros,int currentZeros)\\n    {\\n        // Checking whether current position is valid or not\\n        if(i<0 || i>=obstacleGrid.length || j<0 || j>=obstacleGrid[0].length)\\n            return 0;\\n        // If current cell is an obstacle ,then we cant proceed further, hence no path exists\\n        if(obstacleGrid[i][j]==-1)\\n            return 0;\\n        // If we found ending square then we got a path. But also take care of number of zeros traversed.\\n        if(obstacleGrid[i][j]==2 && totalZeros==currentZeros-1)\\n            return 1;\\n        else if(obstacleGrid[i][j]==2)\\n            return 0;\\n        // If all the above conditions were false, it means our cell is having 0 and we can move further, so first make that cell to be invalid.\\n        obstacleGrid[i][j]=-1;\\n        // Now, perform for the four directions of current cell\\n        int totalPaths=DFS(obstacleGrid,i+1,j,totalZeros,currentZeros+1)+\\n                       DFS(obstacleGrid,i-1,j,totalZeros,currentZeros+1)+\\n                       DFS(obstacleGrid,i,j+1,totalZeros,currentZeros+1)+ \\n                       DFS(obstacleGrid,i,j-1,totalZeros,currentZeros+1);\\n        // Backtrack=>Make that cell as valid so that we can use this cell for other paths.\\n        obstacleGrid[i][j]=0;\\n        // Finally return total number of valid paths.\\n        return totalPaths;\\n    }\\n   \\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int totalZeros=0,startX=0,startY=0;\\n        // Find total number of zeros, we should move exactly once and also find starting cell indices.\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]==0)\\n                    totalZeros++;\\n                if(grid[i][j]==1)\\n                {\\n                    startX=i;\\n                    startY=j;\\n                }\\n            }\\n        }\\n        // Calling DFS Function.\\n        return DFS(grid,startX,startY,totalZeros,0);\\n    }\\n}\\n```\\nThanks for reading! Please upvote and comment if you got a clear idea:)\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution { \\n    // DFS function\\n    public int DFS(int [][]obstacleGrid,int i,int j,int totalZeros,int currentZeros)\\n    {\\n        // Checking whether current position is valid or not\\n        if(i<0 || i>=obstacleGrid.length || j<0 || j>=obstacleGrid[0].length)\\n            return 0;\\n        // If current cell is an obstacle ,then we cant proceed further, hence no path exists\\n        if(obstacleGrid[i][j]==-1)\\n            return 0;\\n        // If we found ending square then we got a path. But also take care of number of zeros traversed.\\n        if(obstacleGrid[i][j]==2 && totalZeros==currentZeros-1)\\n            return 1;\\n        else if(obstacleGrid[i][j]==2)\\n            return 0;\\n        // If all the above conditions were false, it means our cell is having 0 and we can move further, so first make that cell to be invalid.\\n        obstacleGrid[i][j]=-1;\\n        // Now, perform for the four directions of current cell\\n        int totalPaths=DFS(obstacleGrid,i+1,j,totalZeros,currentZeros+1)+\\n                       DFS(obstacleGrid,i-1,j,totalZeros,currentZeros+1)+\\n                       DFS(obstacleGrid,i,j+1,totalZeros,currentZeros+1)+ \\n                       DFS(obstacleGrid,i,j-1,totalZeros,currentZeros+1);\\n        // Backtrack=>Make that cell as valid so that we can use this cell for other paths.\\n        obstacleGrid[i][j]=0;\\n        // Finally return total number of valid paths.\\n        return totalPaths;\\n    }\\n   \\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int totalZeros=0,startX=0,startY=0;\\n        // Find total number of zeros, we should move exactly once and also find starting cell indices.\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]==0)\\n                    totalZeros++;\\n                if(grid[i][j]==1)\\n                {\\n                    startX=i;\\n                    startY=j;\\n                }\\n            }\\n        }\\n        // Calling DFS Function.\\n        return DFS(grid,startX,startY,totalZeros,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 221965,
                "title": "java-dfs-with-memo",
                "content": "Some notes:\\n1. `dfs()`: returns the number of valid paths from current status to the destination.\\n2. `cur`: the number of visited squares.\\n3. `total`: the number of squares need to be visited in the grid.\\n\\nTime: N^2 * 2^N, where N is grid.length * grid[0].length\\nSpace: N * 2^N\\n\\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int x = -1, y = -1, m = grid.length, n = grid[0].length, total = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    x = i;\\n                    y = j;\\n                }\\n                if (grid[i][j] == 0) {\\n                    total++;\\n                }\\n            }\\n        }\\n        return dfs(grid, x, y, 0, total + 1, new HashMap<>());\\n    }\\n    private int dfs(int[][] grid, int x, int y, int cur, int total, Map<String, Integer> memo) {\\n        int m = grid.length, n = grid[0].length;\\n        if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == -1) {\\n            return 0;\\n        }\\n        if (grid[x][y] == 2) {\\n            if (total == cur) {\\n                return 1;\\n            } else {\\n                return 0;\\n            }\\n        }\\n        grid[x][y] = -1;\\n        String key = getKey(grid) + \" \" + x + \" \" + y;\\n        if (!memo.containsKey(key)) {\\n            int[][] dirs = new int[][]{{1, 0}, {0, 1}, {0, -1}, {-1, 0}};\\n            int result = 0;\\n            for (int[] dir : dirs) {\\n                result += dfs(grid, x + dir[0], y + dir[1], cur + 1, total, memo);\\n            }\\n            memo.put(key, result);\\n        }\\n        grid[x][y] = 0;\\n        return memo.get(key);\\n    }\\n    private int getKey(int[][] grid) {\\n        int result = 0;\\n        for (int[] row : grid) {\\n            for (int a : row) {\\n                result <<= 1;\\n                if (a != 0) {\\n                    result ^= 1;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int x = -1, y = -1, m = grid.length, n = grid[0].length, total = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    x = i;\\n                    y = j;\\n                }\\n                if (grid[i][j] == 0) {\\n                    total++;\\n                }\\n            }\\n        }\\n        return dfs(grid, x, y, 0, total + 1, new HashMap<>());\\n    }\\n    private int dfs(int[][] grid, int x, int y, int cur, int total, Map<String, Integer> memo) {\\n        int m = grid.length, n = grid[0].length;\\n        if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == -1) {\\n            return 0;\\n        }\\n        if (grid[x][y] == 2) {\\n            if (total == cur) {\\n                return 1;\\n            } else {\\n                return 0;\\n            }\\n        }\\n        grid[x][y] = -1;\\n        String key = getKey(grid) + \" \" + x + \" \" + y;\\n        if (!memo.containsKey(key)) {\\n            int[][] dirs = new int[][]{{1, 0}, {0, 1}, {0, -1}, {-1, 0}};\\n            int result = 0;\\n            for (int[] dir : dirs) {\\n                result += dfs(grid, x + dir[0], y + dir[1], cur + 1, total, memo);\\n            }\\n            memo.put(key, result);\\n        }\\n        grid[x][y] = 0;\\n        return memo.get(key);\\n    }\\n    private int getKey(int[][] grid) {\\n        int result = 0;\\n        for (int[] row : grid) {\\n            for (int a : row) {\\n                result <<= 1;\\n                if (a != 0) {\\n                    result ^= 1;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973375,
                "title": "python-3-15-lines-dfs-w-comments-t-m-98-94",
                "content": "```\\nclass Solution:\\n     def uniquePathsIII(self, grid: list[list[int]]) -> int:\\n\\n        M, N = range(len(grid)), range(len(grid[0]))\\n\\n        zeros = sum(row.count(0) for row in grid)       # count the zeros to ensure all cells visited\\n        start = tuple((r,c) for r in M for c in N       # find start in grid\\n                           if grid[r][c] == 1)[0]\\n        self.ans = 0\\n\\n        def dfs(row, col, zeros):\\n            grid[row][col] = 3                          # change 0 to 3 to avoid returning\\n\\n            for dr, dc in ((-1,0),(0,-1),(1,0),(0,1)):  # explore the grid recursively\\n                R, C = row+dr, col+dc\\n                if R in M and C in N:\\n                    if grid[R][C] == 0: dfs(R, C, zeros-1)\\n                    if grid[R][C] == 2 and zeros == 0: self.ans += 1\\n\\n            grid[row][col] = 0                          # change back\\n            return\\n\\n        dfs(*start, zeros)\\n        return self.ans\\n\\n```\\n[https://leetcode.com/problems/unique-paths-iii/submissions/868318437/](http://)\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n     def uniquePathsIII(self, grid: list[list[int]]) -> int:\\n\\n        M, N = range(len(grid)), range(len(grid[0]))\\n\\n        zeros = sum(row.count(0) for row in grid)       # count the zeros to ensure all cells visited\\n        start = tuple((r,c) for r in M for c in N       # find start in grid\\n                           if grid[r][c] == 1)[0]\\n        self.ans = 0\\n\\n        def dfs(row, col, zeros):\\n            grid[row][col] = 3                          # change 0 to 3 to avoid returning\\n\\n            for dr, dc in ((-1,0),(0,-1),(1,0),(0,1)):  # explore the grid recursively\\n                R, C = row+dr, col+dc\\n                if R in M and C in N:\\n                    if grid[R][C] == 0: dfs(R, C, zeros-1)\\n                    if grid[R][C] == 2 and zeros == 0: self.ans += 1\\n\\n            grid[row][col] = 0                          # change back\\n            return\\n\\n        dfs(*start, zeros)\\n        return self.ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513906,
                "title": "java-tc-o-3-rc-sc-o-rc-simple-dfs-solution-w-backtracking",
                "content": "```java\\n/**\\n * DFS solution with Backtracking\\n *\\n * Here we are using grid array to keep track of visited squares and reset them\\n * back while backtracking.\\n *\\n * Time Complexity:\\n * -> O(R*C) ==> To find the start, end, & number of non-obstacle squares.\\n * -> O(4 * 3^(N-2)) ==> DFS Helper will explore all possible paths. At each square\\n * (except start & end) we will explore at most 3 directions. At start we will\\n * explore 4 directions and at end we will stop the further exploration of that\\n * path. Here N is bounded by R*C.\\n *\\n * Total time complexity: O(R*C + 4 * 3^(N-2)) = O(3^(R*C))\\n *\\n * Space Complexity: O(N) --> For recursion stack. Here N is bounded by R*C.\\n *\\n * R = Number of rows. C = Number of columns. N = Number of non-obstacle\\n * squares.\\n */\\nclass Solution {\\n    private static final int[][] DIRS = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        if (rows == 1 && cols == 1) {\\n            return 0;\\n        }\\n        int[] start = null;\\n        int[] end = null;\\n        int nonObstacleSquares = 0;\\n\\n        // Finding the coordinates of Start and End cell.\\n        // Also, finding the number of Non-Obstacle Squares.\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                switch (grid[i][j]) {\\n                    case 1:\\n\\t\\t\\t\\t\\t\\t// If the input grid has two cells marked as start, then return 0\\n                        if (start != null) {\\n                            return 0;\\n                        }\\n                        start = new int[] { i, j };\\n                        nonObstacleSquares++;\\n                        break;\\n                    case 2:\\n\\t\\t\\t\\t\\t\\t// If the input grid has two cells marked as end, then return 0\\n                        if (end != null) {\\n                            return 0;\\n                        }\\n                        end = new int[] { i, j };\\n                        nonObstacleSquares++;\\n                        break;\\n                    case 0:\\n                        nonObstacleSquares++;\\n                        break;\\n                }\\n            }\\n        }\\n        if (start == null || end == null) {\\n            return 0;\\n        }\\n\\n        return dfsHelper(grid, start[0], start[1], nonObstacleSquares);\\n    }\\n\\n    private int dfsHelper(int[][] grid, int row, int col, int nonObstacleSquares) {\\n        if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || grid[row][col] == -1\\n                || grid[row][col] == 3) {\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t// Found the end square. If number of cells to be visited is 1, then count this path.\\n        if (grid[row][col] == 2) {\\n            return nonObstacleSquares == 1 ? 1 : 0;\\n        }\\n\\n        int preVal = grid[row][col];\\n        grid[row][col] = 3;\\n        int pathCount = 0;\\n        for (int[] d : DIRS) {\\n            pathCount += dfsHelper(grid, row + d[0], col + d[1], nonObstacleSquares - 1);\\n        }\\n        grid[row][col] = preVal;\\n        return pathCount;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Unique Path question on LeetCode:\\n- [62. Unique Paths](https://leetcode.com/problems/unique-paths/discuss/1513886/Java-or-TC:-O(M*N)-or-SC:-O(min(MN))-or-Space-optimized-Dynamic-Programming-solution)\\n- [63. Unique Paths II](https://leetcode.com/problems/unique-paths-ii/discuss/1513891/Java-or-TC:-O(R*C)-or-SC:-O(min(RC))-or-Space-optimized-Dynamic-Programming-solution)\\n- [64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/discuss/1513899/Java-or-TC:-O(R*C)-or-SC:-O(min(RC))-or-Space-optimized-Dynamic-Programming-solution)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```java\\n/**\\n * DFS solution with Backtracking\\n *\\n * Here we are using grid array to keep track of visited squares and reset them\\n * back while backtracking.\\n *\\n * Time Complexity:\\n * -> O(R*C) ==> To find the start, end, & number of non-obstacle squares.\\n * -> O(4 * 3^(N-2)) ==> DFS Helper will explore all possible paths. At each square\\n * (except start & end) we will explore at most 3 directions. At start we will\\n * explore 4 directions and at end we will stop the further exploration of that\\n * path. Here N is bounded by R*C.\\n *\\n * Total time complexity: O(R*C + 4 * 3^(N-2)) = O(3^(R*C))\\n *\\n * Space Complexity: O(N) --> For recursion stack. Here N is bounded by R*C.\\n *\\n * R = Number of rows. C = Number of columns. N = Number of non-obstacle\\n * squares.\\n */\\nclass Solution {\\n    private static final int[][] DIRS = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        if (rows == 1 && cols == 1) {\\n            return 0;\\n        }\\n        int[] start = null;\\n        int[] end = null;\\n        int nonObstacleSquares = 0;\\n\\n        // Finding the coordinates of Start and End cell.\\n        // Also, finding the number of Non-Obstacle Squares.\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                switch (grid[i][j]) {\\n                    case 1:\\n\\t\\t\\t\\t\\t\\t// If the input grid has two cells marked as start, then return 0\\n                        if (start != null) {\\n                            return 0;\\n                        }\\n                        start = new int[] { i, j };\\n                        nonObstacleSquares++;\\n                        break;\\n                    case 2:\\n\\t\\t\\t\\t\\t\\t// If the input grid has two cells marked as end, then return 0\\n                        if (end != null) {\\n                            return 0;\\n                        }\\n                        end = new int[] { i, j };\\n                        nonObstacleSquares++;\\n                        break;\\n                    case 0:\\n                        nonObstacleSquares++;\\n                        break;\\n                }\\n            }\\n        }\\n        if (start == null || end == null) {\\n            return 0;\\n        }\\n\\n        return dfsHelper(grid, start[0], start[1], nonObstacleSquares);\\n    }\\n\\n    private int dfsHelper(int[][] grid, int row, int col, int nonObstacleSquares) {\\n        if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || grid[row][col] == -1\\n                || grid[row][col] == 3) {\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t// Found the end square. If number of cells to be visited is 1, then count this path.\\n        if (grid[row][col] == 2) {\\n            return nonObstacleSquares == 1 ? 1 : 0;\\n        }\\n\\n        int preVal = grid[row][col];\\n        grid[row][col] = 3;\\n        int pathCount = 0;\\n        for (int[] d : DIRS) {\\n            pathCount += dfsHelper(grid, row + d[0], col + d[1], nonObstacleSquares - 1);\\n        }\\n        grid[row][col] = preVal;\\n        return pathCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856162,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n  int uniquePathsIII(vector<vector<int>>& grid) {        \\n    int sx = -1, sy = -1;\\n    int n = 1; // track the total count of empty square need to be visited\\n    for (int i = 0; i < grid.size(); ++i)\\n      for (int j = 0; j < grid[0].size(); ++j)\\n        if (grid[i][j] == 0) ++n;\\n        else if (grid[i][j] == 1) { sx = j; sy = i; } // starting square    \\n    return dfs(grid, sx, sy, n);\\n  }\\n    \\nprivate:\\n  int dfs(vector<vector<int>>& grid, int x, int y, int n) {\\n    if (x < 0 || x == grid[0].size() || y < 0 || y == grid.size() || grid[y][x] == -1) return 0;\\n    if (grid[y][x] == 2) return n == 0;//n=0 means all empty squares are visited=>one path found\\n    grid[y][x] = -1;\\n    int paths = dfs(grid, x + 1, y, n - 1) + dfs(grid, x - 1, y, n - 1) + dfs(grid, x, y + 1, n - 1) + dfs(grid, x, y - 1, n - 1);\\n    grid[y][x] = 0;\\n    return paths;        \\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int uniquePathsIII(vector<vector<int>>& grid) {        \\n    int sx = -1, sy = -1;\\n    int n = 1; // track the total count of empty square need to be visited\\n    for (int i = 0; i < grid.size(); ++i)\\n      for (int j = 0; j < grid[0].size(); ++j)\\n        if (grid[i][j] == 0) ++n;\\n        else if (grid[i][j] == 1) { sx = j; sy = i; } // starting square    \\n    return dfs(grid, sx, sy, n);\\n  }\\n    \\nprivate:\\n  int dfs(vector<vector<int>>& grid, int x, int y, int n) {\\n    if (x < 0 || x == grid[0].size() || y < 0 || y == grid.size() || grid[y][x] == -1) return 0;\\n    if (grid[y][x] == 2) return n == 0;//n=0 means all empty squares are visited=>one path found\\n    grid[y][x] = -1;\\n    int paths = dfs(grid, x + 1, y, n - 1) + dfs(grid, x - 1, y, n - 1) + dfs(grid, x, y + 1, n - 1) + dfs(grid, x, y - 1, n - 1);\\n    grid[y][x] = 0;\\n    return paths;        \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855922,
                "title": "c-simple-dfs-solution-explained-100-time-50-space",
                "content": "I have to admit I \"wasted\" some time over-optimising (or trying to), since I read that the maximum breadth and width of the map might both be `20`, so I was more concerned about performance than a mere map with max 20 overall elements.\\n\\nLesson learnt: take more time to review the specs carefully.\\n\\nBut I digress; going back to business, I knew I had to move with a dfs approach and plenty of backtracking, which is what I did, first of all creating a few class variables (in order to have less memory wasted passing data to my recursive calls:\\n* `x` and `y` will keep track of the initial starting point for the calls (I somehow ended up still passing them in the recursive calls, but in the end at least they still store the starting point);\\n* `xLen` and `yLen` will store the map size and thus also the upper limit (excluded) for our `x` and `y` value;\\n* `countZeros` will keep track of how many \"walkable\" cells we have already visited, while `totalZeros` will keep track of the overall amount of them on the map;\\n* `res` will keep the count of the viable paths found going over all the cells;\\n* `cell` is just a temporary variable to store the value of the currently visited map slot - I might have avoided it with little pain, but still felt it made things a bit more readable; or maybe not - you tell me.\\n\\nIn our main function we first of all proceed to give the right value to most of those class variables at once, starting with the upper limits, and then using nested loops to go at once both finding the starting point (the only `1` on the map) and the total of all the walkable cells (marked with `0`).\\n\\nRemember that in matrixes your first index is the `y`, since they are organised as arrays of rows.\\n\\nNow, a tricky part: you might be tempted (or at least I was) to go and call your `dfs` routine directly on the starting point, but that is a bit of a pain in the ass, since you would need some extra logic in order NOT to backtrack on it (and turn it into a `0`); in order to avoid that, I just called my `dfs` on all the 4 adjacent squares and never looked back - much simpler and moore convenient.\\n\\nBut what does this `dfs` helper function?\\n\\nWell, for starters it checks if we are out of bonds with either `x` or `y` and if so, it just `return`s.\\n\\nIf we are in a valid slot, it gives its value to `cell`, then it checks if it is not a `0` (with `!cell`) and if so it increases `res` IFF the current `cell`  is `2` and if we have actually touched all the available slots (`cell == 2` and `countZeros == totalZeros`, respectively) and in any other case it `return`s out of the recursive calls as well, as in the previous example.\\n\\nIf instead we are still on a valid path, then we flag our current cell a visited with `-1`, increase `countZeros` by `1` (since we have walked another unwalked valid cell) and then proceeds to call itself recurisively to all the adjacent cells.\\n\\nFinally, it backtracks restoring the previous values of `grid[y][x]` and `countZeros`.\\n\\nAfter all the `dfs` calls are done, we go back to the main function and just return `res`  :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int x, y, xLen, yLen, countZeros = 0, totalZeros = 0, res = 0, cell;\\n    void dfs(vector<vector<int>>& grid, int x, int y) {\\n        // exit condition: out of bonds\\n        if (x < 0 || y < 0 || x == xLen || y == yLen) return;\\n        cell = grid[y][x];\\n        if (cell) {\\n            // increasing res if we reached the goal and touched all available cell\\n            res += cell == 2 && countZeros == totalZeros;\\n            return;\\n        }\\n        // marking cell as visited\\n        grid[y][x] = -1;\\n        countZeros++;\\n        // exploring north, east, south, west\\n        dfs(grid, x, y - 1);\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x, y + 1);\\n        dfs(grid, x - 1, y);\\n        // backtracking cell as visitable\\n        grid[y][x] = 0;\\n        countZeros--;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        // setting class variables right\\n        yLen = grid.size();\\n        xLen = grid[0].size();\\n        for (int _y = 0; _y < yLen; _y++) {\\n            for (int _x = 0; _x < xLen; _x++) {\\n                cell = grid[_y][_x];\\n                // finding the starting point\\n                if (cell == 1) {\\n                    x = _x;\\n                    y = _y;\\n                }\\n                // increasing countZeros for each cell == 0\\n                totalZeros += !cell;\\n            }\\n        }\\n        // exploring north, east, south, west of the starting point\\n        dfs(grid, x, y - 1);\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x, y + 1);\\n        dfs(grid, x - 1, y);\\n        return res;\\n    }\\n};\\n```\\nOh, it just occurred to me I did not really need `countZeros`; well, alternative, slightly more efficient version of it, as food for thought:\\n```cpp\\nclass Solution {\\npublic:\\n    int x, y, xLen, yLen, totalZeros = 0, res = 0, cell;\\n    void dfs(vector<vector<int>>& grid, int x, int y) {\\n        // exit condition: out of bonds\\n        if (x < 0 || y < 0 || x == xLen || y == yLen) return;\\n        cell = grid[y][x];\\n        if (cell) {\\n            // increasing res if we reached the goal and touched all available cell\\n            res += cell == 2 && !totalZeros;\\n            return;\\n        }\\n        // marking cell as visited\\n        grid[y][x] = -1;\\n        totalZeros--;\\n        // exploring north, east, south, west\\n        dfs(grid, x, y - 1);\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x, y + 1);\\n        dfs(grid, x - 1, y);\\n        // backtracking cell as visitable\\n        grid[y][x] = 0;\\n        totalZeros++;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        // setting class variable right\\n        yLen = grid.size();\\n        xLen = grid[0].size();\\n        for (int _y = 0; _y < yLen; _y++) {\\n            for (int _x = 0; _x < xLen; _x++) {\\n                cell = grid[_y][_x];\\n                // finding the starting point\\n                if (cell == 1) {\\n                    x = _x;\\n                    y = _y;\\n                }\\n                // increasing countZeros for each cell == 0\\n                totalZeros += !cell;\\n            }\\n        }\\n        // exploring north, east, south, west of the starting point\\n        dfs(grid, x, y - 1);\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x, y + 1);\\n        dfs(grid, x - 1, y);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int x, y, xLen, yLen, countZeros = 0, totalZeros = 0, res = 0, cell;\\n    void dfs(vector<vector<int>>& grid, int x, int y) {\\n        // exit condition: out of bonds\\n        if (x < 0 || y < 0 || x == xLen || y == yLen) return;\\n        cell = grid[y][x];\\n        if (cell) {\\n            // increasing res if we reached the goal and touched all available cell\\n            res += cell == 2 && countZeros == totalZeros;\\n            return;\\n        }\\n        // marking cell as visited\\n        grid[y][x] = -1;\\n        countZeros++;\\n        // exploring north, east, south, west\\n        dfs(grid, x, y - 1);\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x, y + 1);\\n        dfs(grid, x - 1, y);\\n        // backtracking cell as visitable\\n        grid[y][x] = 0;\\n        countZeros--;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        // setting class variables right\\n        yLen = grid.size();\\n        xLen = grid[0].size();\\n        for (int _y = 0; _y < yLen; _y++) {\\n            for (int _x = 0; _x < xLen; _x++) {\\n                cell = grid[_y][_x];\\n                // finding the starting point\\n                if (cell == 1) {\\n                    x = _x;\\n                    y = _y;\\n                }\\n                // increasing countZeros for each cell == 0\\n                totalZeros += !cell;\\n            }\\n        }\\n        // exploring north, east, south, west of the starting point\\n        dfs(grid, x, y - 1);\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x, y + 1);\\n        dfs(grid, x - 1, y);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int x, y, xLen, yLen, totalZeros = 0, res = 0, cell;\\n    void dfs(vector<vector<int>>& grid, int x, int y) {\\n        // exit condition: out of bonds\\n        if (x < 0 || y < 0 || x == xLen || y == yLen) return;\\n        cell = grid[y][x];\\n        if (cell) {\\n            // increasing res if we reached the goal and touched all available cell\\n            res += cell == 2 && !totalZeros;\\n            return;\\n        }\\n        // marking cell as visited\\n        grid[y][x] = -1;\\n        totalZeros--;\\n        // exploring north, east, south, west\\n        dfs(grid, x, y - 1);\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x, y + 1);\\n        dfs(grid, x - 1, y);\\n        // backtracking cell as visitable\\n        grid[y][x] = 0;\\n        totalZeros++;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        // setting class variable right\\n        yLen = grid.size();\\n        xLen = grid[0].size();\\n        for (int _y = 0; _y < yLen; _y++) {\\n            for (int _x = 0; _x < xLen; _x++) {\\n                cell = grid[_y][_x];\\n                // finding the starting point\\n                if (cell == 1) {\\n                    x = _x;\\n                    y = _y;\\n                }\\n                // increasing countZeros for each cell == 0\\n                totalZeros += !cell;\\n            }\\n        }\\n        // exploring north, east, south, west of the starting point\\n        dfs(grid, x, y - 1);\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x, y + 1);\\n        dfs(grid, x - 1, y);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1553847,
                "title": "c-clean-recursive-backtracking-solution-explained",
                "content": "The idea is to do the following:\\n- Find the starting cell (find the 1 in the grid)\\n- Count the number of cells to visit (count the 0s in the grid)\\n- Traverse the grid up/down/left/right recursively from the starting cell. On each step:\\n\\t- if the cell is a 0: flag the current cell as visited (=1), traverse the grid (decreasing the count of cells to visit by 1), and backtrack by removing the cell flag (=0)\\n\\t- if the cell is the ending square (2), check the remaining count of cells to visit. If 0, then increment the number of paths, otherwise, stop traversing.\\n\\t- otherwise (cell is a -1=obstacle or a 1=visited), stop traversing\\n\\t\\n\\n```\\nclass Solution {\\npublic:    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        initVariables( grid );\\n        traverse( grid, xStart, yStart, toVisit );\\n        return nValidPath;\\n    }\\n    \\nprivate:\\n    /*\\n    Get the starting positon in the grid && the number of zeros (cells to visit)\\n    xStart,yStart = start position\\n    toVisit = number of cells to visit\\n    */\\n    void initVariables( vector<vector<int>>& grid )\\n    {\\n        for ( int i = 0; i < grid.size(); ++i )\\n        {\\n            for ( int j = 0; j < grid[0].size(); ++j )\\n            {\\n                int n = grid[i][j];\\n                if ( n == 1 ) \\n                {\\n                    xStart = i; \\n                    yStart = j;\\n                }\\n                else if ( n == 0 ) \\n                    ++toVisit;\\n            }\\n        }\\n    }\\n    \\n    /*\\n    Visit a cell\\n    */\\n    void move( vector<vector<int>>& grid, int x, int y, int toVisit )\\n    {\\n        // Move only if the position is valid \\n        if ( x >= 0 && x < grid.size() && y >= 0 && y < grid[0].size() )\\n        {\\n            // If the cell we are moving to is the ending square and toVisit == 0:\\n            // the path is valid\\n            if ( grid[x][y] == 2 )\\n            {\\n                if ( toVisit == 0 )\\n                    ++nValidPath;\\n            }\\n            // Otherwise, if the cell we are moving to is 0 (<=> not -1 or 1, meaning obstacle or visited),\\n            // flag the cell as visited, traverse the grid again, and backtrack\\n            else if ( grid[x][y] == 0 )\\n            {\\n                grid[x][y] = 1;\\n                traverse( grid, x, y, toVisit - 1 );\\n                grid[x][y] = 0;\\n            }\\n        }\\n    }\\n    \\n    /*\\n    Traverse the grid from a cell (go in 4 directions)\\n    */\\n    void traverse( vector<vector<int>>& grid, int x, int y, int toVisit )\\n    {\\n        // go up\\n        move( grid, x - 1, y, toVisit );\\n        // go down \\n        move( grid, x + 1, y, toVisit );\\n        // go left \\n        move( grid, x, y - 1, toVisit );\\n        // go right \\n        move( grid, x, y + 1, toVisit );\\n    }\\n    \\n    /*\\n    Members\\n    */\\n    int xStart = 0, yStart = 0, toVisit = 0, nValidPath = 0;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        initVariables( grid );\\n        traverse( grid, xStart, yStart, toVisit );\\n        return nValidPath;\\n    }\\n    \\nprivate:\\n    /*\\n    Get the starting positon in the grid && the number of zeros (cells to visit)\\n    xStart,yStart = start position\\n    toVisit = number of cells to visit\\n    */\\n    void initVariables( vector<vector<int>>& grid )\\n    {\\n        for ( int i = 0; i < grid.size(); ++i )\\n        {\\n            for ( int j = 0; j < grid[0].size(); ++j )\\n            {\\n                int n = grid[i][j];\\n                if ( n == 1 ) \\n                {\\n                    xStart = i; \\n                    yStart = j;\\n                }\\n                else if ( n == 0 ) \\n                    ++toVisit;\\n            }\\n        }\\n    }\\n    \\n    /*\\n    Visit a cell\\n    */\\n    void move( vector<vector<int>>& grid, int x, int y, int toVisit )\\n    {\\n        // Move only if the position is valid \\n        if ( x >= 0 && x < grid.size() && y >= 0 && y < grid[0].size() )\\n        {\\n            // If the cell we are moving to is the ending square and toVisit == 0:\\n            // the path is valid\\n            if ( grid[x][y] == 2 )\\n            {\\n                if ( toVisit == 0 )\\n                    ++nValidPath;\\n            }\\n            // Otherwise, if the cell we are moving to is 0 (<=> not -1 or 1, meaning obstacle or visited),\\n            // flag the cell as visited, traverse the grid again, and backtrack\\n            else if ( grid[x][y] == 0 )\\n            {\\n                grid[x][y] = 1;\\n                traverse( grid, x, y, toVisit - 1 );\\n                grid[x][y] = 0;\\n            }\\n        }\\n    }\\n    \\n    /*\\n    Traverse the grid from a cell (go in 4 directions)\\n    */\\n    void traverse( vector<vector<int>>& grid, int x, int y, int toVisit )\\n    {\\n        // go up\\n        move( grid, x - 1, y, toVisit );\\n        // go down \\n        move( grid, x + 1, y, toVisit );\\n        // go left \\n        move( grid, x, y - 1, toVisit );\\n        // go right \\n        move( grid, x, y + 1, toVisit );\\n    }\\n    \\n    /*\\n    Members\\n    */\\n    int xStart = 0, yStart = 0, toVisit = 0, nValidPath = 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108997,
                "title": "backtracking-solution-in-c-with-time-complexity-analysis",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- First, we\\u2019re finding the number of zeros & the starting point, then we\\u2019ll call our recursive function.\\n- There will be 2 base cases:\\n    - `if(x < 0 || y < 0 || x >= grid.size() || y >= grid[0].size() || grid[x][y] == -1)` return 0.\\n    - `if(grid[x][y] == 2)` return 1 if zero=-1 (means we\\u2019ve visited all the zeros present there), else return 0.\\n- Else we\\u2019ll make current 0 to -1(not using visited array to save space) & decrease zero then call the recursive function for next 4 stages (down, right, up, left).\\n- Now after coming back from the recursive call we\\u2019ll backtrack, make current 0 & increase zero.\\n- **Time complexity:** O(4^n) //4calls for every cell.\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int zero = 0, x = 0, y = 0;\\n        \\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j] == 0) zero++;\\n                if(grid[i][j] == 1){\\n                    x = i;\\n                    y = j;\\n                }\\n            }\\n        }\\n        return solve(grid, zero, x, y);\\n    }\\n    \\n    int solve(vector<vector<int>>& grid, int zero, int x, int y){\\n        if(x < 0 || y < 0 || x >= grid.size() || y >= grid[0].size() || grid[x][y] == -1)\\n            return 0;\\n        \\n        if(grid[x][y] == 2){\\n            if(zero == -1) return 1;\\n            else return 0;\\n        }\\n        \\n        grid[x][y] = -1;\\n        zero--;\\n        \\n        int ans = solve(grid, zero, x+1, y) + solve(grid, zero, x, y+1) + solve(grid, zero, x-1, y) + solve(grid, zero, x, y-1);\\n        \\n        grid[x][y] = 0;\\n        zero++;\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int zero = 0, x = 0, y = 0;\\n        \\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j] == 0) zero++;\\n                if(grid[i][j] == 1){\\n                    x = i;\\n                    y = j;\\n                }\\n            }\\n        }\\n        return solve(grid, zero, x, y);\\n    }\\n    \\n    int solve(vector<vector<int>>& grid, int zero, int x, int y){\\n        if(x < 0 || y < 0 || x >= grid.size() || y >= grid[0].size() || grid[x][y] == -1)\\n            return 0;\\n        \\n        if(grid[x][y] == 2){\\n            if(zero == -1) return 1;\\n            else return 0;\\n        }\\n        \\n        grid[x][y] = -1;\\n        zero--;\\n        \\n        int ans = solve(grid, zero, x+1, y) + solve(grid, zero, x, y+1) + solve(grid, zero, x-1, y) + solve(grid, zero, x, y-1);\\n        \\n        grid[x][y] = 0;\\n        zero++;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834105,
                "title": "easy-to-understand-c-dfs-4ms",
                "content": "Here is my code for the problem. It contains comments for better understanding. Open to suggestions and new ideas of solving it. \\n**Please upvote if found helpful**\\n\\n```\\nclass Solution {\\n    int dfs(vector<vector<int>>& grid, int i, int j, int s, int c) {\\n        // invalid indexes or position\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] == -1)\\n            return 0;\\n        \\n        // we reached target, now compare if the number of steps matches the number of empty cells\\n        if(grid[i][j] == 2)\\n            return s == c ? 1 : 0;\\n        \\n        // mark as processed\\n        grid[i][j] = -1;\\n        \\n        // explore all the directions\\n        int path = dfs(grid, i + 1, j, s + 1, c) \\n                 + dfs(grid, i - 1, j, s + 1, c) \\n                 + dfs(grid, i, j + 1, s + 1, c) \\n                 + dfs(grid, i, j - 1, s + 1, c);\\n        \\n        // backtrack and mark as available\\n        grid[i][j] = 0;\\n        \\n        return path;\\n    }\\n    \\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        // starti & startj hold the position of starting square\\n        // count holds the number of empty cells\\n        int starti = 0, startj = 0, count = 0;\\n        \\n        for(int i = 0; i < grid.size(); i++) {\\n            for(int j = 0; j < grid[0].size(); j++) {\\n                if(grid[i][j] == 1) {\\n                    starti = i;\\n                    startj = j;\\n                }\\n                \\n                if(grid[i][j] != -1)\\n                    count++;\\n            }\\n        }\\n        \\n        return dfs(grid, starti, startj, 1, count);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(vector<vector<int>>& grid, int i, int j, int s, int c) {\\n        // invalid indexes or position\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] == -1)\\n            return 0;\\n        \\n        // we reached target, now compare if the number of steps matches the number of empty cells\\n        if(grid[i][j] == 2)\\n            return s == c ? 1 : 0;\\n        \\n        // mark as processed\\n        grid[i][j] = -1;\\n        \\n        // explore all the directions\\n        int path = dfs(grid, i + 1, j, s + 1, c) \\n                 + dfs(grid, i - 1, j, s + 1, c) \\n                 + dfs(grid, i, j + 1, s + 1, c) \\n                 + dfs(grid, i, j - 1, s + 1, c);\\n        \\n        // backtrack and mark as available\\n        grid[i][j] = 0;\\n        \\n        return path;\\n    }\\n    \\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        // starti & startj hold the position of starting square\\n        // count holds the number of empty cells\\n        int starti = 0, startj = 0, count = 0;\\n        \\n        for(int i = 0; i < grid.size(); i++) {\\n            for(int j = 0; j < grid[0].size(); j++) {\\n                if(grid[i][j] == 1) {\\n                    starti = i;\\n                    startj = j;\\n                }\\n                \\n                if(grid[i][j] != -1)\\n                    count++;\\n            }\\n        }\\n        \\n        return dfs(grid, starti, startj, 1, count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222492,
                "title": "backtracking-thinking-process-java",
                "content": ">We are asked to figure out number of paths such that each path starts at 1,  ends at 2, and passes all 0s.\\n\\n> That\\'s natural to backtracking, i.e., exhaustive searching with earlier pruning.\\n\\n> Base case (leaf nodes in backtracking tree): we are at `(endX, endY)` and we have visited `numEmpty + 2` squares.\\n\\n\\n> Recursive cases: we try 4-directional walks to see if it leads to a valid path - which will return 1 finally.\\n\\n****\\n```\\n    private int m, n, numEmpty;\\n    private static final int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n\\n    private int countPaths(int x, int y, Set<Integer> visited, int endX, int endY, int[][] grid) {\\n        if (x == endX && y == endY && visited.size() - 2 == numEmpty) return 1;\\n        \\n        int count = 0;\\n        for (int[] dir : directions) {\\n            int nx = x + dir[0];\\n            int ny = y + dir[1];\\n            if (nx < 0 || ny < 0 || nx >= m | ny >= n || grid[nx][ny] == -1) continue;\\n            int norder = serial(nx, ny);\\n            if (!visited.contains(norder)) {\\n                visited.add(norder);\\n                count += countPaths(nx, ny, visited, endX, endY, grid);\\n                visited.remove(norder);\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        int startX = 0, startY = 0, endX = 0, endY = 0;\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    startX = i;\\n                    startY = j;\\n                } else if (grid[i][j] == 2) {\\n                    endX = i;\\n                    endY = j;\\n                } else if (grid[i][j] == 0) {\\n                    numEmpty++;\\n                }\\n            }\\n        }\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(serial(startX, startY));\\n        \\n        return countPaths(startX, startY, visited, endX, endY, grid);\\n    }\\n\\n    private int serial(int x, int y) {\\n        return x * n + y;\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n    private int m, n, numEmpty;\\n    private static final int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n\\n    private int countPaths(int x, int y, Set<Integer> visited, int endX, int endY, int[][] grid) {\\n        if (x == endX && y == endY && visited.size() - 2 == numEmpty) return 1;\\n        \\n        int count = 0;\\n        for (int[] dir : directions) {\\n            int nx = x + dir[0];\\n            int ny = y + dir[1];\\n            if (nx < 0 || ny < 0 || nx >= m | ny >= n || grid[nx][ny] == -1) continue;\\n            int norder = serial(nx, ny);\\n            if (!visited.contains(norder)) {\\n                visited.add(norder);\\n                count += countPaths(nx, ny, visited, endX, endY, grid);\\n                visited.remove(norder);\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        int startX = 0, startY = 0, endX = 0, endY = 0;\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    startX = i;\\n                    startY = j;\\n                } else if (grid[i][j] == 2) {\\n                    endX = i;\\n                    endY = j;\\n                } else if (grid[i][j] == 0) {\\n                    numEmpty++;\\n                }\\n            }\\n        }\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(serial(startX, startY));\\n        \\n        return countPaths(startX, startY, visited, endX, endY, grid);\\n    }\\n\\n    private int serial(int x, int y) {\\n        return x * n + y;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2974294,
                "title": "c-dfs-backtrack-comments-added-easy-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    int path(int i,int j,int n,int m,int &c,int cnt,vector<vector<int>> &grid)\\n    {\\n        if(i<0 or j<0 or i>=n or j>=m or grid[i][j]==-1 or grid[i][j]==3)\\n            return 0;\\n        \\n        // ending square\\n        if(grid[i][j]==2)\\n        {\\n            //if all empty cells visited then returning 1 else 0\\n            if(cnt-1 == c) return 1;\\n            return 0;\\n        }\\n        \\n        grid[i][j]=3;                                          // mark as visited\\n        \\n        // all possible paths\\n        int up = path(i-1,j,n,m,c,cnt+1,grid);\\n        int down = path(i+1,j,n,m,c,cnt+1,grid);\\n        int left = path(i,j-1,n,m,c,cnt+1,grid);\\n        int right = path(i,j+1,n,m,c,cnt+1,grid);\\n    \\n        grid[i][j]=0;                                          // mark as unvisited\\n        \\n        return up+down+left+right;                             // total count of reaching ending square\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) \\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int st,en;\\n        int c=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                // if it is starting square\\n                if(grid[i][j]==1)\\n                {\\n                    st=i;\\n                    en=j;\\n                }\\n                \\n                // count of empty cells\\n                if(grid[i][j]==0)\\n                {\\n                    c++;\\n                }\\n            }\\n        }\\n        return path(st,en,n,m,c,0,grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int path(int i,int j,int n,int m,int &c,int cnt,vector<vector<int>> &grid)\\n    {\\n        if(i<0 or j<0 or i>=n or j>=m or grid[i][j]==-1 or grid[i][j]==3)\\n            return 0;\\n        \\n        // ending square\\n        if(grid[i][j]==2)\\n        {\\n            //if all empty cells visited then returning 1 else 0\\n            if(cnt-1 == c) return 1;\\n            return 0;\\n        }\\n        \\n        grid[i][j]=3;                                          // mark as visited\\n        \\n        // all possible paths\\n        int up = path(i-1,j,n,m,c,cnt+1,grid);\\n        int down = path(i+1,j,n,m,c,cnt+1,grid);\\n        int left = path(i,j-1,n,m,c,cnt+1,grid);\\n        int right = path(i,j+1,n,m,c,cnt+1,grid);\\n    \\n        grid[i][j]=0;                                          // mark as unvisited\\n        \\n        return up+down+left+right;                             // total count of reaching ending square\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) \\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int st,en;\\n        int c=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                // if it is starting square\\n                if(grid[i][j]==1)\\n                {\\n                    st=i;\\n                    en=j;\\n                }\\n                \\n                // count of empty cells\\n                if(grid[i][j]==0)\\n                {\\n                    c++;\\n                }\\n            }\\n        }\\n        return path(st,en,n,m,c,0,grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222212,
                "title": "c-backtracking",
                "content": "The idea is as follows: let\\'s call a \"complete path\" a path where all 0\\'s are used. The number of complete paths at index (x, y) is equal to the sum of complete paths moving up, down, left and right. We increment the number of zeros encountered each time we go deeper in the recursion tree. If we ever reach the destination cell with the required amont of zeros, then we have encountered a complete path and return 1. \\n\\nThe c++ code below implements the above idea.\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int zeros = 1;\\n        int x_start, y_start, x_end, y_end;\\n        for(int i = 0; i < grid.size(); i++) {\\n            for(int j = 0; j < grid[i].size(); j++) {\\n                if(grid[i][j] == 0) zeros++;\\n                else if(grid[i][j] == 1) {\\n                    x_start = i;\\n                    y_start = j;\\n                }\\n                else if(grid[i][j] == 2) {\\n                    x_end = i;\\n                    y_end = j;\\n                }\\n            }\\n        }\\n        \\n        return paths(grid, x_start, y_start, x_end, y_end, 0, zeros);\\n    }\\n    \\n    int paths(vector<vector<int>> &grid, \\n              int x, int y, int x_end, int y_end, int covered, int required) {\\n        if(x == x_end && y == y_end && covered == required) {\\n            return 1;\\n        }\\n                \\n        grid[x][y] = -1;\\n        int res = 0;\\n        vector<vector<int>> dirs = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\\n        for(auto &dir : dirs) {\\n            int new_x = x + dir[0];\\n            int new_y = y + dir[1];\\n            if(valid_index(new_x, new_y, grid.size(), grid[x].size())\\n              && (grid[new_x][new_y] == 0 || grid[new_x][new_y] == 2)) {\\n                res += paths(grid, new_x, new_y, x_end, y_end, covered + 1, required);\\n            }\\n        }\\n        grid[x][y] = 0;\\n        \\n        return res;\\n    }\\n    \\n    int valid_index(int i, int j, int n, int m) {\\n        return i >= 0 && j >= 0 && i < n && j < m;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int zeros = 1;\\n        int x_start, y_start, x_end, y_end;\\n        for(int i = 0; i < grid.size(); i++) {\\n            for(int j = 0; j < grid[i].size(); j++) {\\n                if(grid[i][j] == 0) zeros++;\\n                else if(grid[i][j] == 1) {\\n                    x_start = i;\\n                    y_start = j;\\n                }\\n                else if(grid[i][j] == 2) {\\n                    x_end = i;\\n                    y_end = j;\\n                }\\n            }\\n        }\\n        \\n        return paths(grid, x_start, y_start, x_end, y_end, 0, zeros);\\n    }\\n    \\n    int paths(vector<vector<int>> &grid, \\n              int x, int y, int x_end, int y_end, int covered, int required) {\\n        if(x == x_end && y == y_end && covered == required) {\\n            return 1;\\n        }\\n                \\n        grid[x][y] = -1;\\n        int res = 0;\\n        vector<vector<int>> dirs = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\\n        for(auto &dir : dirs) {\\n            int new_x = x + dir[0];\\n            int new_y = y + dir[1];\\n            if(valid_index(new_x, new_y, grid.size(), grid[x].size())\\n              && (grid[new_x][new_y] == 0 || grid[new_x][new_y] == 2)) {\\n                res += paths(grid, new_x, new_y, x_end, y_end, covered + 1, required);\\n            }\\n        }\\n        grid[x][y] = 0;\\n        \\n        return res;\\n    }\\n    \\n    int valid_index(int i, int j, int n, int m) {\\n        return i >= 0 && j >= 0 && i < n && j < m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184821,
                "title": "python3-backtracking-bitmask-dp",
                "content": "**Approach 1 -- backtracking**\\n```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0]) # dimensions \\n        empty = 0 \\n        for i in range(m):\\n            for j in range(n): \\n                if grid[i][j] == 1: start = (i, j)\\n                elif grid[i][j] == 0: empty += 1 # empty squares \\n        \\n        def fn(i, j, empty): \\n            \"\"\"Count paths via backtracking.\"\"\"\\n            nonlocal ans \\n            if grid[i][j] == 2: \\n                if empty == -1: ans += 1\\n                return \\n            grid[i][j] = -1 # mark as visited \\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] != -1: \\n                    fn(ii, jj, empty-1)\\n            grid[i][j] = 0 # backtracking\\n        \\n        ans = 0 \\n        fn(*start, empty)\\n        return ans\\n```\\n\\n**Approach 2 -- bitmask dp**\\n```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        mask = 0\\n        for i in range(m):\\n            for j in range(n): \\n                if grid[i][j] == 1: start = (i, j)\\n                if grid[i][j] in (-1, 1): mask ^= 1 << i*n+j\\n        \\n        @cache\\n        def fn(i, j, mask): \\n            \"\"\"Return unique paths from (i, j) to end\"\"\"\\n            if grid[i][j] == 2 and mask == (1<<m*n) - 1: return 1\\n            ans = 0\\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < m and 0 <= jj < n: \\n                    kk = ii*n + jj \\n                    if not mask & 1<<kk: ans += fn(ii, jj, mask ^ 1<<kk)\\n            return ans \\n                \\n        return fn(*start, mask)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0]) # dimensions \\n        empty = 0 \\n        for i in range(m):\\n            for j in range(n): \\n                if grid[i][j] == 1: start = (i, j)\\n                elif grid[i][j] == 0: empty += 1 # empty squares \\n        \\n        def fn(i, j, empty): \\n            \"\"\"Count paths via backtracking.\"\"\"\\n            nonlocal ans \\n            if grid[i][j] == 2: \\n                if empty == -1: ans += 1\\n                return \\n            grid[i][j] = -1 # mark as visited \\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] != -1: \\n                    fn(ii, jj, empty-1)\\n            grid[i][j] = 0 # backtracking\\n        \\n        ans = 0 \\n        fn(*start, empty)\\n        return ans\\n```\n```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        mask = 0\\n        for i in range(m):\\n            for j in range(n): \\n                if grid[i][j] == 1: start = (i, j)\\n                if grid[i][j] in (-1, 1): mask ^= 1 << i*n+j\\n        \\n        @cache\\n        def fn(i, j, mask): \\n            \"\"\"Return unique paths from (i, j) to end\"\"\"\\n            if grid[i][j] == 2 and mask == (1<<m*n) - 1: return 1\\n            ans = 0\\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < m and 0 <= jj < n: \\n                    kk = ii*n + jj \\n                    if not mask & 1<<kk: ans += fn(ii, jj, mask ^ 1<<kk)\\n            return ans \\n                \\n        return fn(*start, mask)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974009,
                "title": "simple-backtracking-solution-c",
                "content": "# Intuition\\nDo whats given . You need to walk over every zero and need to reach the 2 from 1 , So keep track of all the zeros and the zeros you have walked and using backtracking because if we go on a path that is not correct we could backtrack to the path that is actually correct containg all the zeros.\\n\\n# Approach\\nClassical Backtracking Approch\\n1. Keep track of total zeros and the zeros you walked\\n2. When on a zero you increment walked zero and then change it to visited path\\n3. And after moving on those path you set them back to zero as they could help in other path building.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i , int j , int n , int m , vector<vector<int>>& grid , int totalWalk , int doneWalk \\n            , vector<vector<int>>& dir , int& ans){\\n        if(grid[i][j] == -1){\\n            return ;\\n        }\\n        if(grid[i][j] == 2 && doneWalk == totalWalk){\\n            ans++;\\n        }\\n        else{\\n            int val = grid[i][j];\\n            if(val == 0){\\n                doneWalk++;\\n            }\\n            grid[i][j] = -1;\\n            for(auto it : dir){\\n                int x = i + it[0];\\n                int y = j + it[1];\\n                if(x < 0 || x >= n || y < 0 || y >= m || grid[x][y] == -1){\\n                    continue;\\n                }\\n                else{\\n                    dfs(x , y , n , m , grid , totalWalk , doneWalk , dir , ans);\\n                }\\n            }\\n            if(val == 0){\\n                doneWalk--;\\n            }\\n            grid[i][j] = val;\\n        }\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ii = 0 , jj = 0 , totalWalk = 0 , doneWalk = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                if(grid[i][j] == 0){\\n                    totalWalk++;\\n                }\\n                if(grid[i][j] == 1){\\n                    ii = i;\\n                    jj = j;\\n                }\\n            }\\n        }\\n        vector<vector<int>> dir = {{0 , -1} , {0 , 1} , {1 , 0} , {-1 , 0}};\\n        int ans = 0;\\n        dfs(ii , jj , n , m , grid , totalWalk , doneWalk , dir , ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i , int j , int n , int m , vector<vector<int>>& grid , int totalWalk , int doneWalk \\n            , vector<vector<int>>& dir , int& ans){\\n        if(grid[i][j] == -1){\\n            return ;\\n        }\\n        if(grid[i][j] == 2 && doneWalk == totalWalk){\\n            ans++;\\n        }\\n        else{\\n            int val = grid[i][j];\\n            if(val == 0){\\n                doneWalk++;\\n            }\\n            grid[i][j] = -1;\\n            for(auto it : dir){\\n                int x = i + it[0];\\n                int y = j + it[1];\\n                if(x < 0 || x >= n || y < 0 || y >= m || grid[x][y] == -1){\\n                    continue;\\n                }\\n                else{\\n                    dfs(x , y , n , m , grid , totalWalk , doneWalk , dir , ans);\\n                }\\n            }\\n            if(val == 0){\\n                doneWalk--;\\n            }\\n            grid[i][j] = val;\\n        }\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ii = 0 , jj = 0 , totalWalk = 0 , doneWalk = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                if(grid[i][j] == 0){\\n                    totalWalk++;\\n                }\\n                if(grid[i][j] == 1){\\n                    ii = i;\\n                    jj = j;\\n                }\\n            }\\n        }\\n        vector<vector<int>> dir = {{0 , -1} , {0 , 1} , {1 , 0} , {-1 , 0}};\\n        int ans = 0;\\n        dfs(ii , jj , n , m , grid , totalWalk , doneWalk , dir , ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973771,
                "title": "c-7ms-o-n-2-n-dfs-dynamic-programming-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo generate a valid path from a given square to the goal, we\\'re going to need to make one move first, and then generate the rest of the path. However, when we do this, we want to take into account that we\\'ve already visited a square that we came from, so that we don\\'t visit it again. This gives the idea of doing a graph search, where we go down paths using a DFS and counting each time we reach the end on a path of length $$n$$, where $$n$$ is the number of squares in the grid. However, going through all the possible paths might take a while -- although $$n = 20$$ means an exponential time solution is probably OK still. This graph search approach will form the foundation of our solution.\\n\\nOne other thing we can notice is that we might encounter a \"subproblem\" multiple times. In this case, we define a subproblem as finding the number of paths from a given square to the end, for a given set of vertices that we have already visited. There are $$2^n$$ such sets and only $$n$$ squares in the grid, so this will allow us to reuse some work when counting the total number of paths.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start by initializing the grid for a recursive DFS/DP solution. Afterward, we use a memoized solve function, which takes in an x-coordinate and a y-coordinate representing our current location as well as an integer representing which locations we\\'ve already visited. This integer will have 1s at each bit corresponding to a visited square and 0s corresponding to unvisited squares. In this way, we can efficiently check if we\\'ve visited a square using bitwise operations. Additionally, this requires us to number the squares of the grid from 0 to $$n - 1$$, which can be done using the usual row-by-row, column-by-column ordering.\\n\\nIn a given call to the function, we first check if we either are in a base case or a case we\\'ve already solved before. If either of these holds, we just return that result. If not, we add the current square to the visited set and try paths where the next move is up, down, left, and right. Taking the sum of these 4 numbers gives the answer for this case, which we then memoize. Then calling our recursive, memoized solve function for our first square starting with an empty visited set will give us the desired answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIf we let the number of squares in the grid be $$n$$, the original branching search/DFS solution which does not memoize any states has a time complexity of $$O(3^n)$$, since we are trying paths of length up to $$n$$ and each one consists of moves in one of three directions since you can\\'t double back. However, the DP solution reduces this to $$O(n \\\\cdot 2^n)$$ since we only need to evaluate $$n \\\\cdot 2^n$$ states -- there are $$n$$ squares we can currently be on and $$2^n$$ possible sets of squares we have already visited. Each state is evaluated in constant time, since it is just taking the sum of four other states or looking up a memoized solution.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nBy memoizing, we are trading memory usage for an improved runtime. The memory used by this program could potentially end up having to store one integer for every DP state that we check, giving a space complexity of $$O(n \\\\cdot 2^n)$$ as well.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // variables to use in our solution\\n    vector<vector<int>> grid;\\n    int m, n, c;\\n    // memo table - dp[state] = # of paths to end from that state\\n    // C++ doesn\\'t like hashing pairs, so square s with visited set k is represented by (s << 20) + k\\n    // since the maximum size of the visited set is 20.\\n    unordered_map<int, int> dp;\\n    int solve(int x, int y, int visited) {\\n        int a = n * x + y; // find the number of this square\\n        int id = ((n * x + y) << 20) + visited; // generate memo table id\\n        // if we have already solved this state, return value\\n        if(dp.count(id) > 0) return dp[id];\\n        // base case - if we\\'re at the end, check if we have visited enough grid squares before\\n        if(grid[x][y] == 2) return (__builtin_popcount(visited) == c ? 1 : 0);\\n        // output variable\\n        int res = 0;\\n        // new visited set\\n        int nvis = visited | (1 << a);\\n        // try going up\\n        if(x > 0 && grid[x - 1][y] != -1 && (visited & (1 << (a - n))) == 0) {\\n            res += solve(x - 1, y, nvis);\\n        }\\n        // try going down\\n        if(x + 1 < m && grid[x + 1][y] != -1 && (visited & (1 << (a + n))) == 0) {\\n            res += solve(x + 1, y, nvis);\\n        }\\n        // try going left\\n        if(y > 0 && grid[x][y - 1] != -1 && (visited & (1 << (a - 1))) == 0) {\\n            res += solve(x, y - 1, nvis);\\n        }\\n        // try going right\\n        if(y + 1 < n && grid[x][y + 1] != -1 && (visited & (1 << (a + 1))) == 0) {\\n            res += solve(x, y + 1, nvis);\\n        }\\n        // memoize result before we return so that we can reuse it\\n        dp[id] = res;\\n        return res;\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>>& g) {\\n        // initialize some variables for the search\\n        grid = g;\\n        m = grid.size();\\n        n = grid[0].size();\\n        // find starting square\\n        int x, y;\\n        // count number of non-obstacle, non-end squares\\n        c = 0;\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                if(grid[i][j] == 1) {\\n                    x = i;\\n                    y = j;\\n                }\\n                if(grid[i][j] == 1 || grid[i][j] == 0) ++c;\\n            }\\n        }\\n        // call DP solution\\n        return solve(x, y, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // variables to use in our solution\\n    vector<vector<int>> grid;\\n    int m, n, c;\\n    // memo table - dp[state] = # of paths to end from that state\\n    // C++ doesn\\'t like hashing pairs, so square s with visited set k is represented by (s << 20) + k\\n    // since the maximum size of the visited set is 20.\\n    unordered_map<int, int> dp;\\n    int solve(int x, int y, int visited) {\\n        int a = n * x + y; // find the number of this square\\n        int id = ((n * x + y) << 20) + visited; // generate memo table id\\n        // if we have already solved this state, return value\\n        if(dp.count(id) > 0) return dp[id];\\n        // base case - if we\\'re at the end, check if we have visited enough grid squares before\\n        if(grid[x][y] == 2) return (__builtin_popcount(visited) == c ? 1 : 0);\\n        // output variable\\n        int res = 0;\\n        // new visited set\\n        int nvis = visited | (1 << a);\\n        // try going up\\n        if(x > 0 && grid[x - 1][y] != -1 && (visited & (1 << (a - n))) == 0) {\\n            res += solve(x - 1, y, nvis);\\n        }\\n        // try going down\\n        if(x + 1 < m && grid[x + 1][y] != -1 && (visited & (1 << (a + n))) == 0) {\\n            res += solve(x + 1, y, nvis);\\n        }\\n        // try going left\\n        if(y > 0 && grid[x][y - 1] != -1 && (visited & (1 << (a - 1))) == 0) {\\n            res += solve(x, y - 1, nvis);\\n        }\\n        // try going right\\n        if(y + 1 < n && grid[x][y + 1] != -1 && (visited & (1 << (a + 1))) == 0) {\\n            res += solve(x, y + 1, nvis);\\n        }\\n        // memoize result before we return so that we can reuse it\\n        dp[id] = res;\\n        return res;\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>>& g) {\\n        // initialize some variables for the search\\n        grid = g;\\n        m = grid.size();\\n        n = grid[0].size();\\n        // find starting square\\n        int x, y;\\n        // count number of non-obstacle, non-end squares\\n        c = 0;\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                if(grid[i][j] == 1) {\\n                    x = i;\\n                    y = j;\\n                }\\n                if(grid[i][j] == 1 || grid[i][j] == 0) ++c;\\n            }\\n        }\\n        // call DP solution\\n        return solve(x, y, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 390360,
                "title": "python-well-explained-and-simple",
                "content": "# Idea is : Since we need to cover all empty spaces and reach destination, so we increment our pathcount only when we have \\n#   1. reached destination and \\n#   2. emptycell count == 0. \\n# So lets count all empty spaces, start point (i,j) and destination before we start dfs. After that it regular DFS. \\n# NOTE: DFS works best because it goes in depth and finds path until not hit by boundry condition or obstacle. \\n\\n```\\n\\nclass Solution(object):\\n    def uniquePathsIII(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        self.totalPaths = 0\\n        empty = 1\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                \\n                if grid[i][j] == 1: \\n                    x,y = (i, j)        # start point\\n                elif grid[i][j] == 2: \\n                    self.end = (i, j)   # end point\\n                elif grid[i][j] == 0: \\n                    empty += 1          # count no. of empty spaces\\n                    \\n        self.dfs(grid, x, y, empty)\\n        return self.totalPaths\\n    \\n    def dfs(self, grid, x, y, empty):\\n\\n        if not (0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] >= 0): \\n            return\\n\\n        if (x, y) == self.end:\\n            if empty == 0:              # Problem says -> path that walk over every non-obstacle square exactly once.\\n                self.totalPaths += 1\\n            return\\n\\n        grid[x][y] = -2\\n        self.dfs(grid, x + 1, y, empty - 1)\\n        self.dfs(grid, x - 1, y, empty - 1)\\n        self.dfs(grid, x, y + 1, empty - 1)\\n        self.dfs(grid, x, y - 1, empty - 1)\\n        grid[x][y] = 0\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution(object):\\n    def uniquePathsIII(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        self.totalPaths = 0\\n        empty = 1\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                \\n                if grid[i][j] == 1: \\n                    x,y = (i, j)        # start point\\n                elif grid[i][j] == 2: \\n                    self.end = (i, j)   # end point\\n                elif grid[i][j] == 0: \\n                    empty += 1          # count no. of empty spaces\\n                    \\n        self.dfs(grid, x, y, empty)\\n        return self.totalPaths\\n    \\n    def dfs(self, grid, x, y, empty):\\n\\n        if not (0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] >= 0): \\n            return\\n\\n        if (x, y) == self.end:\\n            if empty == 0:              # Problem says -> path that walk over every non-obstacle square exactly once.\\n                self.totalPaths += 1\\n            return\\n\\n        grid[x][y] = -2\\n        self.dfs(grid, x + 1, y, empty - 1)\\n        self.dfs(grid, x - 1, y, empty - 1)\\n        self.dfs(grid, x, y + 1, empty - 1)\\n        self.dfs(grid, x, y - 1, empty - 1)\\n        grid[x][y] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 386273,
                "title": "dfs-solution-with-detailed-explanation-and-comments-python",
                "content": "The idea is to recusively explore all possible paths from the starting cell \\'1\\', stopping exploration as soon as paths are found to be invalid. The trick to ensure each cell is traversed only once is to change its value from \\'0\\' to \\'-1\\' right after its visited, so it is considered a wall. However, after checking valid movements in all 4 directions, **be careful to revert grid values to 0** in order to consider previously unexplored paths (if not, grid will only be traversed once).\\n\\n* First, we loop through all elements of grid to (1) **count all traversable cells** (i.e. 1, 2 and 0s) and (2) **find the starting point** (i.e. cell \\'1\\' coordinates). This information is stored in `to_visit` and `start_r, start_c` respectively.\\n\\n* Next, we implement the `dfs` function, which will **construct the graph of all possible paths**, backtracking whenever we either (1) find a wall or a previously visited cell or (2) reach the ending cell \\'2\\' without having visited all the grid\\'s 0s.\\n\\n```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        self.R, self.C = len(grid), len(grid[0])\\n        self.directions = (0, 1), (0, -1), (1, 0), (-1, 0)\\n        to_visit = 0\\n        for r in range(self.R):\\n            for c in range(self.C):\\n                # count all 0s, 1 and 2 cells to be visited\\n\\t\\t\\t\\tif grid[r][c] != -1: to_visit += 1\\n                # find starting point i.e. cell 1\\n                if grid[r][c] == 1: start_r, start_c = r, c\\n\\n        return self.dfs(grid, start_r, start_c, to_visit)\\n        \\n    def dfs(self, grid, r, c, to_visit):\\n        # check if out of range or wall found\\n        if not (0 <= r < self.R and 0 <= c < self.C) or grid[r][c] == -1: return 0\\n        \\n        # found end cell, valid path if all 0s visited\\n        if grid[r][c] == 2: return to_visit == 1\\n        \\n        # valid movement, keep going\\n        elif grid[r][c] in [0, 1]:\\n            res = 0\\n            # mark as visited\\n            grid[r][c] = -1\\n            # check movements in all 4 directions\\n            for dr, dc in self.directions:\\n                res += self.dfs(grid, r + dr, c + dc, to_visit - 1)\\n            # mark prev explored cell as unvisited\\n            grid[r][c] = 0\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        self.R, self.C = len(grid), len(grid[0])\\n        self.directions = (0, 1), (0, -1), (1, 0), (-1, 0)\\n        to_visit = 0\\n        for r in range(self.R):\\n            for c in range(self.C):\\n                # count all 0s, 1 and 2 cells to be visited\\n\\t\\t\\t\\tif grid[r][c] != -1: to_visit += 1\\n                # find starting point i.e. cell 1\\n                if grid[r][c] == 1: start_r, start_c = r, c\\n\\n        return self.dfs(grid, start_r, start_c, to_visit)\\n        \\n    def dfs(self, grid, r, c, to_visit):\\n        # check if out of range or wall found\\n        if not (0 <= r < self.R and 0 <= c < self.C) or grid[r][c] == -1: return 0\\n        \\n        # found end cell, valid path if all 0s visited\\n        if grid[r][c] == 2: return to_visit == 1\\n        \\n        # valid movement, keep going\\n        elif grid[r][c] in [0, 1]:\\n            res = 0\\n            # mark as visited\\n            grid[r][c] = -1\\n            # check movements in all 4 directions\\n            for dr, dc in self.directions:\\n                res += self.dfs(grid, r + dr, c + dc, to_visit - 1)\\n            # mark prev explored cell as unvisited\\n            grid[r][c] = 0\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222109,
                "title": "screencast-of-weekly-contest-120",
                "content": "https://www.youtube.com/watch?v=EXrh9ZIyuec&t=7s",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=EXrh9ZIyuec&t=7s",
                "codeTag": "Unknown"
            },
            {
                "id": 221913,
                "title": "python-solution-using-bit-with-extra-detailed-chinese-explanation",
                "content": "__update:2019.01.23__\\nyou can get Chinese explanation in \\nhttps://buptwc.com/2019/01/22/Leetcode-980-Unique-Paths-III/\\n\\n`1 <= grid.length * grid[0].length <= 20` just tell us to use bit!\\nI use bit represent the position we need to visit\\nfor grid[i][j], I use `1<<(i*m+j)` represent position(i,j)\\'s status\\n\\nfor instance, grid = [[0,1], [0,2]]\\nthe `start` status should be `0010`, position should be `0,1`(grid[i][j] = 1)\\nthe `final` status should be `1111`, position should be `1,1`(grid[i][j] = 2)\\n\\nnow we use recursion, start from `final` status, the process will be:\\n`1111, 1, 1` -> `0111, 1, 0` -> `0011, 0, 0` -> `0010, 0, 1`(start status)\\nso we find one path!\\n\\n```python\\n# I use sys modue to avoid stack overflow.\\n# but I haven\\'t tried to see if there\\'s a real stack overflow without adding it.\\nimport sys  \\nsys.setrecursionlimit(1000000)\\nclass Solution:\\n    def uniquePathsIII(self, grid):\\n        n,m = len(grid), len(grid[0])\\n        start = 0\\n        final = 0\\n        fi = fj = 0\\n        # record the start status and final status\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] != -1:\\n                    final += 1 << (i*m+j)\\n                if grid[i][j] == 1:\\n                    start += 1 << (i*m+j)\\n                    si, sj = i, j\\n                if grid[i][j] == 2:\\n                    fi, fj = i, j\\n\\n        cache = {(start,si,sj): 1}\\n        def solve(status, i, j):\\n            if (status,i,j) in cache: return cache[status,i,j]\\n            res = 0\\n            now_status = 1 << (i*m + j)\\n            for x,y in [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]:\\n                if 0<=x<n and 0<=y<m and grid[x][y] != -1:\\n                    mask = 1 << (x*m+y)\\n                    if status & mask:\\n                        res += solve(status ^ now_status, x, y)\\n            cache[status,i,j] = res\\n            return res\\n        return solve(final, fi, fj)\\n```",
                "solutionTags": [],
                "code": "```python\\n# I use sys modue to avoid stack overflow.\\n# but I haven\\'t tried to see if there\\'s a real stack overflow without adding it.\\nimport sys  \\nsys.setrecursionlimit(1000000)\\nclass Solution:\\n    def uniquePathsIII(self, grid):\\n        n,m = len(grid), len(grid[0])\\n        start = 0\\n        final = 0\\n        fi = fj = 0\\n        # record the start status and final status\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] != -1:\\n                    final += 1 << (i*m+j)\\n                if grid[i][j] == 1:\\n                    start += 1 << (i*m+j)\\n                    si, sj = i, j\\n                if grid[i][j] == 2:\\n                    fi, fj = i, j\\n\\n        cache = {(start,si,sj): 1}\\n        def solve(status, i, j):\\n            if (status,i,j) in cache: return cache[status,i,j]\\n            res = 0\\n            now_status = 1 << (i*m + j)\\n            for x,y in [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]:\\n                if 0<=x<n and 0<=y<m and grid[x][y] != -1:\\n                    mask = 1 << (x*m+y)\\n                    if status & mask:\\n                        res += solve(status ^ now_status, x, y)\\n            cache[status,i,j] = res\\n            return res\\n        return solve(final, fi, fj)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463043,
                "title": "c-java-python-easy-to-understand-4-directional-walk-w-backtracking",
                "content": "I think the comments are explicit enough to explain the **DFS-based 4-directional walk with backtracking** approach that is used here. We just need to find the starting square and then we do this walk until we reach the ending square and there will only be a valid path if we visited all the empty squares exactly once. \\n\\nWhen we visit an empty square, we mark it as an obstacle and going back (while backtracking) we unmark them.\\n\\n```\\nTime complexity: O(4 ^ (no. of elements in grid))\\nSpace complexity: O(no. of elements in grid)\\n```\\n\\n\\u2714 C++: \\n\\n```\\nclass Solution {\\nprivate:\\n    int dfs(vector<vector<int>> &grid, int x, int y, int emptyCell) {\\n        // base cases -\\n        // 1. out of bounds and obstacles\\n        if(x == -1 or x == grid.size() or y == -1 or y == grid[0].size() or grid[x][y] == -1) \\n            return 0;\\n        // 2. reached the ending square, check if it can be a valid 4-directional walk\\n        if(grid[x][y] == 2)\\n            return emptyCell == 0;\\n        // since it is an empty cell, we visit the current cell\\n        grid[x][y] = -1;\\n        // do the 4-directional dfs walk from here\\n        int walks = \\n              dfs(grid, x + 1, y, emptyCell - 1)   // visit SOUTH\\n            + dfs(grid, x - 1, y, emptyCell - 1)   // visit NORTH\\n            + dfs(grid, x, y + 1, emptyCell - 1)   // visit EAST\\n            + dfs(grid, x, y - 1, emptyCell - 1);  // visit WEST\\n        // coming back we backtrack, un-visit the current cell\\n        grid[x][y] = 0;\\n        return walks;\\n    }\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int emptyCell = 1, xIdx, yIdx;\\n        // counting the no. of empty cells and getting the position of starting square\\n        // x and y coordinate of starting square are xIdx and yIdx respectively\\n        for(int i = 0; i < grid.size(); ++i) {\\n            for(int j = 0; j < grid[0].size(); ++j) {\\n                if(grid[i][j] == 1) \\n                    xIdx = i, yIdx = j;\\n                else if(grid[i][j] == 0)\\n                    ++emptyCell;\\n            }\\n        }\\n        return dfs(grid, xIdx, yIdx, emptyCell);\\n    }\\n};\\n```\\n\\n\\u2714 Java:\\n\\n```\\nclass Solution {\\n    private int dfs(int[][] grid, int x, int y, int emptyCell) {\\n        // base cases -\\n        // 1. out of bounds and obstacles\\n        if(x == -1 || x == grid.length || y == -1 || y == grid[0].length || grid[x][y] == -1)\\n            return 0;\\n        // 2. reached the ending square, check if it can be a valid 4-directional walk\\n        if(grid[x][y] == 2)\\n            return emptyCell == 0 ? 1 : 0;\\n        // since it is an empty cell, we visit the current cell\\n        grid[x][y] = -1;\\n        // do the 4-directional dfs walk from here\\n        int walks = \\n              dfs(grid, x + 1, y, emptyCell - 1)   // visit SOUTH\\n            + dfs(grid, x - 1, y, emptyCell - 1)   // visit NORTH\\n            + dfs(grid, x, y + 1, emptyCell - 1)   // visit EAST\\n            + dfs(grid, x, y - 1, emptyCell - 1);  // visit WEST\\n        // coming back we backtrack, un-visit the current cell\\n        grid[x][y] = 0;\\n        return walks;\\n    }\\n    public int uniquePathsIII(int[][] grid) {\\n        int emptyCell = 1, xIdx = 0, yIdx = 0;\\n        // counting the no. of empty cells and getting the position of starting square\\n        // x and y coordinate of starting square are xIdx and yIdx respectively\\n        for(int i = 0; i < grid.length; ++i) {\\n            for(int j = 0; j < grid[0].length; ++j) {\\n                if(grid[i][j] == 1) {\\n                    xIdx = i;\\n                    yIdx = j;\\n                } else if(grid[i][j] == 0) {\\n                    ++emptyCell;\\n                }\\n            }\\n        }\\n        return dfs(grid, xIdx, yIdx, emptyCell);\\n    }\\n}\\n```\\n\\n\\u2714 Python:\\n\\n```\\nclass Solution:\\n    def dfs(self, grid: List[List[int]], x: int, y: int, emptyCell: int) -> int:\\n        # base cases -\\n        # 1. out of bounds and obstacles\\n        if x == -1 or x == len(grid) or y == -1 or y == len(grid[0]) or grid[x][y] == -1:\\n            return 0\\n        # 2. reached the ending square, check if it can be a valid 4-directional walk\\n        if grid[x][y] == 2:\\n            return emptyCell == 0\\n        # since it is an empty cell, we visit the current cell\\n        grid[x][y] = -1\\n        # do the 4-directional dfs walk from here\\n        walks = (self.dfs(grid, x + 1, y, emptyCell - 1)   # visit SOUTH \\n               + self.dfs(grid, x - 1, y, emptyCell - 1)   # visit NORTH \\n               + self.dfs(grid, x, y + 1, emptyCell - 1)   # visit EAST \\n               + self.dfs(grid, x, y - 1, emptyCell - 1))  # visit WEST \\n        # coming back we backtrack, un-visit the current cell\\n        grid[x][y] = 0\\n        return walks\\n    \\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        emptyCell, xIdx, yIdx = 1, 0, 0\\n        # counting the no. of empty cells and getting the position of starting square\\n        # x and y coordinate of starting square are xIdx and yIdx respectively\\n        for i in range (len(grid)):\\n            for j in range (len(grid[0])):\\n                if grid[i][j] == 1:\\n                    xIdx, yIdx = i, j\\n                elif grid[i][j] == 0:\\n                    emptyCell += 1\\n        return self.dfs(grid, xIdx, yIdx, emptyCell)\\n```\\n\\nThanks a lot for reading! ^_^\\n\\uD83D\\uDCAF An upvote would be appreciated.\\n\\uD83D\\uDC47 Comment down your doubts (if any).",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nTime complexity: O(4 ^ (no. of elements in grid))\\nSpace complexity: O(no. of elements in grid)\\n```\n```\\nclass Solution {\\nprivate:\\n    int dfs(vector<vector<int>> &grid, int x, int y, int emptyCell) {\\n        // base cases -\\n        // 1. out of bounds and obstacles\\n        if(x == -1 or x == grid.size() or y == -1 or y == grid[0].size() or grid[x][y] == -1) \\n            return 0;\\n        // 2. reached the ending square, check if it can be a valid 4-directional walk\\n        if(grid[x][y] == 2)\\n            return emptyCell == 0;\\n        // since it is an empty cell, we visit the current cell\\n        grid[x][y] = -1;\\n        // do the 4-directional dfs walk from here\\n        int walks = \\n              dfs(grid, x + 1, y, emptyCell - 1)   // visit SOUTH\\n            + dfs(grid, x - 1, y, emptyCell - 1)   // visit NORTH\\n            + dfs(grid, x, y + 1, emptyCell - 1)   // visit EAST\\n            + dfs(grid, x, y - 1, emptyCell - 1);  // visit WEST\\n        // coming back we backtrack, un-visit the current cell\\n        grid[x][y] = 0;\\n        return walks;\\n    }\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int emptyCell = 1, xIdx, yIdx;\\n        // counting the no. of empty cells and getting the position of starting square\\n        // x and y coordinate of starting square are xIdx and yIdx respectively\\n        for(int i = 0; i < grid.size(); ++i) {\\n            for(int j = 0; j < grid[0].size(); ++j) {\\n                if(grid[i][j] == 1) \\n                    xIdx = i, yIdx = j;\\n                else if(grid[i][j] == 0)\\n                    ++emptyCell;\\n            }\\n        }\\n        return dfs(grid, xIdx, yIdx, emptyCell);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    private int dfs(int[][] grid, int x, int y, int emptyCell) {\\n        // base cases -\\n        // 1. out of bounds and obstacles\\n        if(x == -1 || x == grid.length || y == -1 || y == grid[0].length || grid[x][y] == -1)\\n            return 0;\\n        // 2. reached the ending square, check if it can be a valid 4-directional walk\\n        if(grid[x][y] == 2)\\n            return emptyCell == 0 ? 1 : 0;\\n        // since it is an empty cell, we visit the current cell\\n        grid[x][y] = -1;\\n        // do the 4-directional dfs walk from here\\n        int walks = \\n              dfs(grid, x + 1, y, emptyCell - 1)   // visit SOUTH\\n            + dfs(grid, x - 1, y, emptyCell - 1)   // visit NORTH\\n            + dfs(grid, x, y + 1, emptyCell - 1)   // visit EAST\\n            + dfs(grid, x, y - 1, emptyCell - 1);  // visit WEST\\n        // coming back we backtrack, un-visit the current cell\\n        grid[x][y] = 0;\\n        return walks;\\n    }\\n    public int uniquePathsIII(int[][] grid) {\\n        int emptyCell = 1, xIdx = 0, yIdx = 0;\\n        // counting the no. of empty cells and getting the position of starting square\\n        // x and y coordinate of starting square are xIdx and yIdx respectively\\n        for(int i = 0; i < grid.length; ++i) {\\n            for(int j = 0; j < grid[0].length; ++j) {\\n                if(grid[i][j] == 1) {\\n                    xIdx = i;\\n                    yIdx = j;\\n                } else if(grid[i][j] == 0) {\\n                    ++emptyCell;\\n                }\\n            }\\n        }\\n        return dfs(grid, xIdx, yIdx, emptyCell);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def dfs(self, grid: List[List[int]], x: int, y: int, emptyCell: int) -> int:\\n        # base cases -\\n        # 1. out of bounds and obstacles\\n        if x == -1 or x == len(grid) or y == -1 or y == len(grid[0]) or grid[x][y] == -1:\\n            return 0\\n        # 2. reached the ending square, check if it can be a valid 4-directional walk\\n        if grid[x][y] == 2:\\n            return emptyCell == 0\\n        # since it is an empty cell, we visit the current cell\\n        grid[x][y] = -1\\n        # do the 4-directional dfs walk from here\\n        walks = (self.dfs(grid, x + 1, y, emptyCell - 1)   # visit SOUTH \\n               + self.dfs(grid, x - 1, y, emptyCell - 1)   # visit NORTH \\n               + self.dfs(grid, x, y + 1, emptyCell - 1)   # visit EAST \\n               + self.dfs(grid, x, y - 1, emptyCell - 1))  # visit WEST \\n        # coming back we backtrack, un-visit the current cell\\n        grid[x][y] = 0\\n        return walks\\n    \\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        emptyCell, xIdx, yIdx = 1, 0, 0\\n        # counting the no. of empty cells and getting the position of starting square\\n        # x and y coordinate of starting square are xIdx and yIdx respectively\\n        for i in range (len(grid)):\\n            for j in range (len(grid[0])):\\n                if grid[i][j] == 1:\\n                    xIdx, yIdx = i, j\\n                elif grid[i][j] == 0:\\n                    emptyCell += 1\\n        return self.dfs(grid, xIdx, yIdx, emptyCell)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478116,
                "title": "java-clean-backtracking-beats-100",
                "content": "Classic backtracking question with a condition that each visitable cell must be visited before we reach destination, we do not need memo as the matrix itself can be used, by marking the visited cells -1, essentially blocking it from further visits, and marking back as 0 as we backtrack. Since we do not have any special condition for int what way destination has to be reached we just want to visit every 0 cell, we can just keep the count of such visitable cells beforehand and subtract 1 as we reach each such cell should give us 0 at the destination if we visited all cells\\n```\\nclass Solution {\\n    int[][] g;\\n    public int uniquePathsIII(int[][] grid) {\\n        g = grid;\\n        int count = 0;\\n        int sr = 0;\\n        int sc = 0;\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 0) count++;\\n                else if(grid[i][j] == 1){\\n                    sr = i;\\n                    sc = j;\\n                }\\n            }\\n        }\\n        return dfs(sr,sc,count+1);\\n        \\n    }\\n    public int dfs(int i , int j , int count){\\n        if(i < 0 || j < 0 || i >= g.length || j >= g[0].length || g[i][j] == -1) return 0;\\n        if(g[i][j] == 2){\\n            if(count == 0)return 1;\\n            return 0;\\n        }\\n        int cc = 0;\\n        g[i][j] = -1;\\n        cc += dfs(i-1,j,count-1);\\n        cc += dfs(i+1,j,count-1);\\n        cc += dfs(i,j-1,count-1);\\n        cc += dfs(i,j+1,count-1);\\n        g[i][j] = 0;\\n        return cc;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] g;\\n    public int uniquePathsIII(int[][] grid) {\\n        g = grid;\\n        int count = 0;\\n        int sr = 0;\\n        int sc = 0;\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 0) count++;\\n                else if(grid[i][j] == 1){\\n                    sr = i;\\n                    sc = j;\\n                }\\n            }\\n        }\\n        return dfs(sr,sc,count+1);\\n        \\n    }\\n    public int dfs(int i , int j , int count){\\n        if(i < 0 || j < 0 || i >= g.length || j >= g[0].length || g[i][j] == -1) return 0;\\n        if(g[i][j] == 2){\\n            if(count == 0)return 1;\\n            return 0;\\n        }\\n        int cc = 0;\\n        g[i][j] = -1;\\n        cc += dfs(i-1,j,count-1);\\n        cc += dfs(i+1,j,count-1);\\n        cc += dfs(i,j-1,count-1);\\n        cc += dfs(i,j+1,count-1);\\n        g[i][j] = 0;\\n        return cc;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856077,
                "title": "unique-paths-c-100-time-simple-dfs-traversal-with-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid, int i, int j, int nobs, int &count){\\n        if (i >= grid.size() || i < 0 || j >= grid[0].size() || j < 0) return;   /* if out of range */\\n        if (grid[i][j] == -1) return;   /* if obstacle */\\n        if (grid[i][j] == 2) {          /* if reached end */\\n            if (nobs == 0) count++;     /* and all non obstacles are included in the path */\\n            return;\\n        }\\n        \\n        grid[i][j] = -1;   /* mark node visited so that it\\'s explored exactly once in the current path */\\n        nobs = nobs - 1;   /* reduce the count of non-obstacle nodes visited so far */\\n        \\n        dfs(grid, i, j-1, nobs, count); // left\\n        dfs(grid, i, j+1, nobs, count); // right\\n        dfs(grid, i-1, j, nobs, count); // up\\n        dfs(grid, i+1, j, nobs, count); // down\\n        \\n        grid[i][j] = 0; /* make the node explorable again for other paths */\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int nobs = 0, i, j;\\n        // calculate start position and non-obstacles count\\n        for (int r = 0; r < grid.size(); r++) {\\n            for (int c = 0; c < grid[0].size(); c++) {\\n                if (grid[r][c] == 1) {\\n                    i = r;\\n                    j = c;\\n                }\\n                else if (grid[r][c] != -1) { // 0 or 2\\n                    nobs++;\\n                }\\n            }\\n        }\\n        int count = 0;\\n        dfs(grid, i, j, nobs, count);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid, int i, int j, int nobs, int &count){\\n        if (i >= grid.size() || i < 0 || j >= grid[0].size() || j < 0) return;   /* if out of range */\\n        if (grid[i][j] == -1) return;   /* if obstacle */\\n        if (grid[i][j] == 2) {          /* if reached end */\\n            if (nobs == 0) count++;     /* and all non obstacles are included in the path */\\n            return;\\n        }\\n        \\n        grid[i][j] = -1;   /* mark node visited so that it\\'s explored exactly once in the current path */\\n        nobs = nobs - 1;   /* reduce the count of non-obstacle nodes visited so far */\\n        \\n        dfs(grid, i, j-1, nobs, count); // left\\n        dfs(grid, i, j+1, nobs, count); // right\\n        dfs(grid, i-1, j, nobs, count); // up\\n        dfs(grid, i+1, j, nobs, count); // down\\n        \\n        grid[i][j] = 0; /* make the node explorable again for other paths */\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int nobs = 0, i, j;\\n        // calculate start position and non-obstacles count\\n        for (int r = 0; r < grid.size(); r++) {\\n            for (int c = 0; c < grid[0].size(); c++) {\\n                if (grid[r][c] == 1) {\\n                    i = r;\\n                    j = c;\\n                }\\n                else if (grid[r][c] != -1) { // 0 or 2\\n                    nobs++;\\n                }\\n            }\\n        }\\n        int count = 0;\\n        dfs(grid, i, j, nobs, count);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 381218,
                "title": "c-dfs-0ms-and-8-6mb",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint uniquePathsIII(vector<vector<int>>& grid) {\\n\\t\\tint res = 0;\\n\\t\\t// find starting positions\\n        for (int i = 0; i < grid.size(); i++){\\n            for (int j = 0; j < grid[0].size(); j++){\\n                if (grid[i][j] == 1){\\n\\t\\t\\t\\t\\tres = getRes(grid, i, j);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    \\n    int getRes(vector<vector<int>>& grid, int i, int j){\\n\\t\\t// check if we can move further\\n        if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size() || grid[i][j] == -1){\\n            return 0;\\n        }\\n\\t\\t// if we found ending square, check whether we visited all empty squares\\n        if (grid[i][j] == 2){\\n            for (int t = 0; t < grid.size(); t++){\\n                for (int k = 0; k < grid[0].size(); k++){\\n                    if (grid[t][k] == 0){\\n                        return 0;\\n                    }\\n                }\\n            }\\n            return 1;\\n        }\\n\\t\\t// we have to mark current positions as visited, and later restore it\\n        auto temp = grid[i][j];\\n        grid[i][j] = -1;\\n        \\n\\t\\t// run dfs for 4 directions\\n        int res = getRes(grid, i - 1, j);\\n        res += getRes(grid, i + 1, j);\\n        res += getRes(grid, i, j - 1);\\n        res += getRes(grid, i, j + 1);\\n        \\n\\t\\t// restore position\\n        grid[i][j] = temp;\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint uniquePathsIII(vector<vector<int>>& grid) {\\n\\t\\tint res = 0;\\n\\t\\t// find starting positions\\n        for (int i = 0; i < grid.size(); i++){\\n            for (int j = 0; j < grid[0].size(); j++){\\n                if (grid[i][j] == 1){\\n\\t\\t\\t\\t\\tres = getRes(grid, i, j);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    \\n    int getRes(vector<vector<int>>& grid, int i, int j){\\n\\t\\t// check if we can move further\\n        if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size() || grid[i][j] == -1){\\n            return 0;\\n        }\\n\\t\\t// if we found ending square, check whether we visited all empty squares\\n        if (grid[i][j] == 2){\\n            for (int t = 0; t < grid.size(); t++){\\n                for (int k = 0; k < grid[0].size(); k++){\\n                    if (grid[t][k] == 0){\\n                        return 0;\\n                    }\\n                }\\n            }\\n            return 1;\\n        }\\n\\t\\t// we have to mark current positions as visited, and later restore it\\n        auto temp = grid[i][j];\\n        grid[i][j] = -1;\\n        \\n\\t\\t// run dfs for 4 directions\\n        int res = getRes(grid, i - 1, j);\\n        res += getRes(grid, i + 1, j);\\n        res += getRes(grid, i, j - 1);\\n        res += getRes(grid, i, j + 1);\\n        \\n\\t\\t// restore position\\n        grid[i][j] = temp;\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554872,
                "title": "step-by-step-explanation-of-maze-problems",
                "content": "## Information from the question:\\n* We have to cover all valid cells : (need to count cells in grid depending on the cell values)\\n* We have to print all paths count :  (Backtracking)\\n* There are some cells which are blocked :  (need to considere this cell while making a call)\\n\\n## Explantion with Code:\\n\\n```\\n// A direction matrix to make call in specified directions (Here 4 directions are needed)\\n  int[][] dir = {{0,-1},{0,1},{-1,0},{1,0}};\\n  //varibales storing gird\\'s information (made global just to avoiding sending them as param in function)\\n    int n=0,m=0,moves=0;\\n   \\n    public int uniquePathsIII(int[][] grid) {\\n        n = grid.length; m = grid[0].length;\\n        int ans = 0, sr = -1,sc=-1;\\n\\t\\t\\n\\t\\t//Step 1 : Count the cells from where you can move(valid cell) and find the starting point\\n\\t\\t//remember starting point is also a valid cell with just an extra identification mark that shows it is a starting point\\n\\t\\t\\n\\t\\t\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    sr = i;\\n                    sc = j;\\n                    moves++; //starting point is also a valid cell for movement\\n                }\\n                if(grid[i][j]==0) moves++;\\n            }\\n        }\\n        \\n        ans = floodfill(grid,sr,sc,moves);\\n        \\n        return ans;\\n    }\\n    \\n    private int floodfill(int[][] grid, int sr,int sc,int moves){\\n\\t// if we have reached the destination by covering all the valid cells \\n\\t// then tell the program you have found 1 path\\n        if(grid[sr][sc]==2 && moves==0) return 1;\\n        \\n\\t\\t//Step 2: (Marking and unmarking)\\n\\t\\t//Telling the program that you have visited the current cell and took a move for other\\n\\t\\t\\n        //mark \\n        int val = grid[sr][sc];\\n        grid[sr][sc] = -1; //making that cell invalid as we have already covered it\\n        moves--;\\n        \\n        int count = 0;\\n\\t\\t\\n\\t\\t// Go to all 4 direction\\n        for(int[] d: dir){\\n            int r = sr + d[0];\\n            int c = sc + d[1];\\n\\t\\t\\t// but only go for the path which profits you.\\n\\t\\t\\t\\n            if(r>=0 && c>=0 && r<n && c<m && grid[r][c]!=-1){\\n\\t\\t\\t//add the path count from all 4 direction\\n                count+=floodfill(grid,r,c,moves);\\n            }\\n        }\\n\\t\\t\\n        //unmark (undoing the changes)\\n\\t\\t// so when you comes here again by different path you can visit it again\\n\\t\\t//(make it a part of your new path again) having your valid move intact\\n\\t\\t\\n        grid[sr][sc]= val;\\n        moves++;\\n        \\n        return count;\\n    }\\n    \\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n// A direction matrix to make call in specified directions (Here 4 directions are needed)\\n  int[][] dir = {{0,-1},{0,1},{-1,0},{1,0}};\\n  //varibales storing gird\\'s information (made global just to avoiding sending them as param in function)\\n    int n=0,m=0,moves=0;\\n   \\n    public int uniquePathsIII(int[][] grid) {\\n        n = grid.length; m = grid[0].length;\\n        int ans = 0, sr = -1,sc=-1;\\n\\t\\t\\n\\t\\t//Step 1 : Count the cells from where you can move(valid cell) and find the starting point\\n\\t\\t//remember starting point is also a valid cell with just an extra identification mark that shows it is a starting point\\n\\t\\t\\n\\t\\t\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    sr = i;\\n                    sc = j;\\n                    moves++; //starting point is also a valid cell for movement\\n                }\\n                if(grid[i][j]==0) moves++;\\n            }\\n        }\\n        \\n        ans = floodfill(grid,sr,sc,moves);\\n        \\n        return ans;\\n    }\\n    \\n    private int floodfill(int[][] grid, int sr,int sc,int moves){\\n\\t// if we have reached the destination by covering all the valid cells \\n\\t// then tell the program you have found 1 path\\n        if(grid[sr][sc]==2 && moves==0) return 1;\\n        \\n\\t\\t//Step 2: (Marking and unmarking)\\n\\t\\t//Telling the program that you have visited the current cell and took a move for other\\n\\t\\t\\n        //mark \\n        int val = grid[sr][sc];\\n        grid[sr][sc] = -1; //making that cell invalid as we have already covered it\\n        moves--;\\n        \\n        int count = 0;\\n\\t\\t\\n\\t\\t// Go to all 4 direction\\n        for(int[] d: dir){\\n            int r = sr + d[0];\\n            int c = sc + d[1];\\n\\t\\t\\t// but only go for the path which profits you.\\n\\t\\t\\t\\n            if(r>=0 && c>=0 && r<n && c<m && grid[r][c]!=-1){\\n\\t\\t\\t//add the path count from all 4 direction\\n                count+=floodfill(grid,r,c,moves);\\n            }\\n        }\\n\\t\\t\\n        //unmark (undoing the changes)\\n\\t\\t// so when you comes here again by different path you can visit it again\\n\\t\\t//(make it a part of your new path again) having your valid move intact\\n\\t\\t\\n        grid[sr][sc]= val;\\n        moves++;\\n        \\n        return count;\\n    }\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1296914,
                "title": "java-100-faster-0ms-dfs-no-memo",
                "content": "count is count of how many zeros in grid\\nand starti and startj is the start poit where grid[starti][startj] == 1\\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int startI = 0;\\n        int startJ = 0;\\n        int count = 0;\\n        for(int i = 0;i < grid.length;i++){\\n            for(int j = 0;j < grid[i].length;j++){\\n                if(grid[i][j] == 1){\\n                    startI = i;\\n                    startJ = j;\\n                }else if(grid[i][j] == 0) count++;\\n            }\\n        }\\n        return howManyPath(grid,startI,startJ,count + 1);\\n    }\\n    \\n    private int howManyPath(int[][] grid,int i,int j,int count){\\n        if(i >= grid.length || i < 0 || j >= grid[i].length || j < 0 || grid[i][j] == -1) return 0;\\n\\n        if(grid[i][j] == 2){\\n            if(count == 0) return 1;\\n            return 0;\\n        }\\n\\n\\n        int temp = grid[i][j];\\n        grid[i][j] = -1;\\n\\n        int result = howManyPath(grid,i + 1,j,count - 1) +\\n              howManyPath(grid,i - 1,j,count - 1) +\\n              howManyPath(grid,i,j + 1,count - 1) +\\n              howManyPath(grid,i,j - 1,count - 1);\\n\\n        grid[i][j] = temp;\\n        return result;\\n    \\n    }\\n \\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int startI = 0;\\n        int startJ = 0;\\n        int count = 0;\\n        for(int i = 0;i < grid.length;i++){\\n            for(int j = 0;j < grid[i].length;j++){\\n                if(grid[i][j] == 1){\\n                    startI = i;\\n                    startJ = j;\\n                }else if(grid[i][j] == 0) count++;\\n            }\\n        }\\n        return howManyPath(grid,startI,startJ,count + 1);\\n    }\\n    \\n    private int howManyPath(int[][] grid,int i,int j,int count){\\n        if(i >= grid.length || i < 0 || j >= grid[i].length || j < 0 || grid[i][j] == -1) return 0;\\n\\n        if(grid[i][j] == 2){\\n            if(count == 0) return 1;\\n            return 0;\\n        }\\n\\n\\n        int temp = grid[i][j];\\n        grid[i][j] = -1;\\n\\n        int result = howManyPath(grid,i + 1,j,count - 1) +\\n              howManyPath(grid,i - 1,j,count - 1) +\\n              howManyPath(grid,i,j + 1,count - 1) +\\n              howManyPath(grid,i,j - 1,count - 1);\\n\\n        grid[i][j] = temp;\\n        return result;\\n    \\n    }\\n \\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 252187,
                "title": "java-2ms-100-faster-dfs",
                "content": "Attempted to try DP for collecting most possible ways to cover all non-obstacle squares from a square but failed. Using DFS with memoize instead.. Hopefully it helps. \\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int startRow = -1;\\n        int startCol = -1;\\n        \\n        int nonObstacles = 0;\\n        \\n        int[][] memoize = new int[grid.length][grid[0].length];\\n        int[] result = {0};\\n        \\n        for(int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                memoize[i][j] = -1;\\n            }\\n        }\\n        \\n\\t\\t// Iterate through the grid to find out where to start and how many non-obs squares should be covered..\\n        for(int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j <grid[0].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    startRow = i;\\n                    startCol = j;\\n                }\\n                \\n                if (grid[i][j] != -1) {\\n                    nonObstacles++;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// Start an definite non-obs square, so better reduce the total by 1 for readability\\n        helper(grid, startRow, startCol,nonObstacles - 1, memoize, result);\\n        return result[0];\\n    }\\n    \\n    public void helper(int[][] grid, int row, int col, int nonObs, int[][] memoizes, int[] result) {\\n        if (row <  0 || col < 0 || row >= grid.length || col >= grid[0].length) {\\n            return;\\n        }\\n        \\n        if (grid[row][col] == 2) {\\n            if (nonObs == 0)\\n                result[0]++;\\n            return;\\n        }\\n        \\n        // Mark the current coordinate as visited \\n        memoizes[row][col] = -2;\\n        \\n        // Try Go left\\n        if (row > 0 && grid[row - 1][col] != -1 && memoizes[row - 1][col] != -2) {\\n            helper(grid, row - 1, col, nonObs - 1, memoizes, result);\\n        }\\n\\n        // Try Go right\\n        if (row < grid.length -1 &&  grid[row + 1][col] != -1 && memoizes[row + 1][col] != -2) {\\n            helper(grid, row + 1, col, nonObs - 1, memoizes, result);\\n        }\\n\\n        // Try Go down\\n        if (col < grid[0].length -1 && grid[row][col + 1] != -1 && memoizes[row][col + 1] != -2) {\\n            helper(grid, row, col + 1, nonObs - 1, memoizes, result);\\n        }\\n\\n        // Try Go up\\n        if (col > 0 && grid[row][col - 1] != -1 && memoizes[row][col - 1] != -2 ) {\\n            helper(grid, row, col - 1, nonObs - 1, memoizes, result);\\n        }\\n        \\n        // Mark the current coordinate as un-visited, OK to go in\\n        memoizes[row][col] = -1;\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int startRow = -1;\\n        int startCol = -1;\\n        \\n        int nonObstacles = 0;\\n        \\n        int[][] memoize = new int[grid.length][grid[0].length];\\n        int[] result = {0};\\n        \\n        for(int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                memoize[i][j] = -1;\\n            }\\n        }\\n        \\n\\t\\t// Iterate through the grid to find out where to start and how many non-obs squares should be covered..\\n        for(int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j <grid[0].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    startRow = i;\\n                    startCol = j;\\n                }\\n                \\n                if (grid[i][j] != -1) {\\n                    nonObstacles++;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// Start an definite non-obs square, so better reduce the total by 1 for readability\\n        helper(grid, startRow, startCol,nonObstacles - 1, memoize, result);\\n        return result[0];\\n    }\\n    \\n    public void helper(int[][] grid, int row, int col, int nonObs, int[][] memoizes, int[] result) {\\n        if (row <  0 || col < 0 || row >= grid.length || col >= grid[0].length) {\\n            return;\\n        }\\n        \\n        if (grid[row][col] == 2) {\\n            if (nonObs == 0)\\n                result[0]++;\\n            return;\\n        }\\n        \\n        // Mark the current coordinate as visited \\n        memoizes[row][col] = -2;\\n        \\n        // Try Go left\\n        if (row > 0 && grid[row - 1][col] != -1 && memoizes[row - 1][col] != -2) {\\n            helper(grid, row - 1, col, nonObs - 1, memoizes, result);\\n        }\\n\\n        // Try Go right\\n        if (row < grid.length -1 &&  grid[row + 1][col] != -1 && memoizes[row + 1][col] != -2) {\\n            helper(grid, row + 1, col, nonObs - 1, memoizes, result);\\n        }\\n\\n        // Try Go down\\n        if (col < grid[0].length -1 && grid[row][col + 1] != -1 && memoizes[row][col + 1] != -2) {\\n            helper(grid, row, col + 1, nonObs - 1, memoizes, result);\\n        }\\n\\n        // Try Go up\\n        if (col > 0 && grid[row][col - 1] != -1 && memoizes[row][col - 1] != -2 ) {\\n            helper(grid, row, col - 1, nonObs - 1, memoizes, result);\\n        }\\n        \\n        // Mark the current coordinate as un-visited, OK to go in\\n        memoizes[row][col] = -1;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975556,
                "title": "c-dfs-backtracking-simple-easy",
                "content": "## DFS with Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    vector<int> dr={-1,0,1,0};\\n    vector<int> dc={0,1,0,-1};\\n\\n    bool check(vector<vector<int>> &grid, vector<vector<bool>> &vis){\\n        int n= grid.size();\\n        int m=grid[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]==0 && vis[i][j]==false) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    void dfs(int i, int j, int x, int y, vector<vector<int>> &grid, vector<vector<bool>> &vis){\\n        int n= grid.size();\\n        int m=grid[0].size();\\n\\n        if(i==x && j==y){\\n            vis[i][j]=true;\\n            if(check(grid,vis)) ans++;\\n            vis[i][j]=false;\\n            return;\\n        }\\n        vis[i][j]=true;\\n        for(int k=0; k<4; k++){\\n            int newr= i+dr[k], newc= j+dc[k];\\n            if(newr<0 || newr>=n || newc<0 || newc>=m || grid[newr][newc]==-1 || vis[newr][newc]) continue;\\n            dfs(newr,newc,x,y,grid,vis);\\n        }\\n        vis[i][j]=false;\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int n= grid.size();\\n        int m=grid[0].size();\\n        vector<vector<bool>> vis(n, vector<bool>(m,false));\\n\\n        int sr,sc,er,ec;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]==1){\\n                    sr=i, sc=j;\\n                }\\n                else if(grid[i][j]==2){\\n                    er=i, ec=j;\\n                }\\n            }\\n        }\\n        dfs(sr,sc,er,ec,grid,vis);\\n        return ans;\\n    }\\n};\\n```\\n## If you like it, Please Upvote !!.\\n\\n![06b76ed5-3118-4975-ac59-5bf422f9c72b_1674524881.1133926.webp](https://assets.leetcode.com/users/images/b2457bc0-1d8d-47d2-b0ca-f42383f0e6db_1682256289.909848.webp)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    vector<int> dr={-1,0,1,0};\\n    vector<int> dc={0,1,0,-1};\\n\\n    bool check(vector<vector<int>> &grid, vector<vector<bool>> &vis){\\n        int n= grid.size();\\n        int m=grid[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]==0 && vis[i][j]==false) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    void dfs(int i, int j, int x, int y, vector<vector<int>> &grid, vector<vector<bool>> &vis){\\n        int n= grid.size();\\n        int m=grid[0].size();\\n\\n        if(i==x && j==y){\\n            vis[i][j]=true;\\n            if(check(grid,vis)) ans++;\\n            vis[i][j]=false;\\n            return;\\n        }\\n        vis[i][j]=true;\\n        for(int k=0; k<4; k++){\\n            int newr= i+dr[k], newc= j+dc[k];\\n            if(newr<0 || newr>=n || newc<0 || newc>=m || grid[newr][newc]==-1 || vis[newr][newc]) continue;\\n            dfs(newr,newc,x,y,grid,vis);\\n        }\\n        vis[i][j]=false;\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int n= grid.size();\\n        int m=grid[0].size();\\n        vector<vector<bool>> vis(n, vector<bool>(m,false));\\n\\n        int sr,sc,er,ec;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]==1){\\n                    sr=i, sc=j;\\n                }\\n                else if(grid[i][j]==2){\\n                    er=i, ec=j;\\n                }\\n            }\\n        }\\n        dfs(sr,sc,er,ec,grid,vis);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973873,
                "title": "dfs-solution-beats-100-shorter-simpler-than-official-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] grid;\\n    int availCells =0;\\n    int answer =0;\\n    \\n    public void dfs(int row, int col, int passedCells){\\n        if(row <0 || col < 0) return; //out of grid\\n        if(row >= grid.length || col >= grid[0].length) return; //out of grid\\n        int cellValue = grid[row][col];\\n        if(cellValue == 1 || cellValue==-1 || cellValue == -2) return; //start, obstacle or visitted cell\\n        if(cellValue == 2){\\n            if(passedCells == availCells) answer++; // we passed all avail cells, success!\\n            return;\\n        }\\n        grid[row][col] = -2; //mark as visitted\\n        passedCells++;\\n        dfs(row, col+1, passedCells);\\n        dfs(row, col-1, passedCells);\\n        dfs(row+1, col, passedCells);\\n        dfs(row-1, col, passedCells);\\n        grid[row][col] = 0;\\n    }\\n    public int uniquePathsIII(int[][] grid) {\\n        this.grid = grid;\\n        int startRow=0,startCol=0;\\n        \\n        for(int row = 0; row < grid.length; row++){\\n            for(int col=0; col < grid[0].length; col++){\\n                if(grid[row][col] == 1){ // find start cell\\n                     startRow = row;\\n                     startCol = col;\\n                }\\n                if(grid[row][col] == 0)  availCells++; \\n            }\\n        }\\n        dfs(startRow+1, startCol,0);\\n        dfs(startRow-1, startCol,0);\\n        dfs(startRow, startCol+1,0);\\n        dfs(startRow, startCol-1,0);\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] grid;\\n    int availCells =0;\\n    int answer =0;\\n    \\n    public void dfs(int row, int col, int passedCells){\\n        if(row <0 || col < 0) return; //out of grid\\n        if(row >= grid.length || col >= grid[0].length) return; //out of grid\\n        int cellValue = grid[row][col];\\n        if(cellValue == 1 || cellValue==-1 || cellValue == -2) return; //start, obstacle or visitted cell\\n        if(cellValue == 2){\\n            if(passedCells == availCells) answer++; // we passed all avail cells, success!\\n            return;\\n        }\\n        grid[row][col] = -2; //mark as visitted\\n        passedCells++;\\n        dfs(row, col+1, passedCells);\\n        dfs(row, col-1, passedCells);\\n        dfs(row+1, col, passedCells);\\n        dfs(row-1, col, passedCells);\\n        grid[row][col] = 0;\\n    }\\n    public int uniquePathsIII(int[][] grid) {\\n        this.grid = grid;\\n        int startRow=0,startCol=0;\\n        \\n        for(int row = 0; row < grid.length; row++){\\n            for(int col=0; col < grid[0].length; col++){\\n                if(grid[row][col] == 1){ // find start cell\\n                     startRow = row;\\n                     startCol = col;\\n                }\\n                if(grid[row][col] == 0)  availCells++; \\n            }\\n        }\\n        dfs(startRow+1, startCol,0);\\n        dfs(startRow-1, startCol,0);\\n        dfs(startRow, startCol+1,0);\\n        dfs(startRow, startCol-1,0);\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973787,
                "title": "c-dfs-easy-solution",
                "content": "\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    bool isValid(int i,int j,int m,int n)\\n    {\\n        return i>=0 and j>=0 and i<m and j<n;\\n    }\\n    void cal(pair<int,int>& start,pair<int,int> &end,vector<vector<bool>> &vis,int emptySquare,int m,int n)\\n    {\\n        emptySquare--;\\n        if(start==end)\\n        {\\n            if(emptySquare==0)\\n            {\\n                ans++;\\n            }\\n            return ;\\n        }\\n        vis[start.first][start.second]=true;\\n        int x[]={1,-1,0,0};\\n        int y[]={0,0,1,-1};\\n        for(int k=0;k<4;k++)\\n        {\\n            int newx=start.first+x[k];\\n            int newy=start.second+y[k];\\n            if(isValid(newx,newy,m,n) and vis[newx][newy]==false)\\n            {\\n                pair<int,int> curr={newx,newy};\\n                cal(curr,end,vis,emptySquare,m,n);\\n            }\\n        }\\n        vis[start.first][start.second]=false;\\n\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        pair<int,int> start,end;\\n        int emptySquare=0;\\n        vector<vector<bool>> vis(m,vector<bool> (n,false));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    start={i,j};\\n                }\\n                if(grid[i][j]==2)\\n                {\\n                    end={i,j};\\n                }\\n                if(grid[i][j]!=-1)\\n                {\\n                    emptySquare++;\\n                }\\n                if(grid[i][j]==-1)\\n                    vis[i][j]=true;\\n            }\\n        }\\n        cal(start,end,vis,emptySquare,m,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    bool isValid(int i,int j,int m,int n)\\n    {\\n        return i>=0 and j>=0 and i<m and j<n;\\n    }\\n    void cal(pair<int,int>& start,pair<int,int> &end,vector<vector<bool>> &vis,int emptySquare,int m,int n)\\n    {\\n        emptySquare--;\\n        if(start==end)\\n        {\\n            if(emptySquare==0)\\n            {\\n                ans++;\\n            }\\n            return ;\\n        }\\n        vis[start.first][start.second]=true;\\n        int x[]={1,-1,0,0};\\n        int y[]={0,0,1,-1};\\n        for(int k=0;k<4;k++)\\n        {\\n            int newx=start.first+x[k];\\n            int newy=start.second+y[k];\\n            if(isValid(newx,newy,m,n) and vis[newx][newy]==false)\\n            {\\n                pair<int,int> curr={newx,newy};\\n                cal(curr,end,vis,emptySquare,m,n);\\n            }\\n        }\\n        vis[start.first][start.second]=false;\\n\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        pair<int,int> start,end;\\n        int emptySquare=0;\\n        vector<vector<bool>> vis(m,vector<bool> (n,false));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    start={i,j};\\n                }\\n                if(grid[i][j]==2)\\n                {\\n                    end={i,j};\\n                }\\n                if(grid[i][j]!=-1)\\n                {\\n                    emptySquare++;\\n                }\\n                if(grid[i][j]==-1)\\n                    vis[i][j]=true;\\n            }\\n        }\\n        cal(start,end,vis,emptySquare,m,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973264,
                "title": "daily-leetcoding-challenge-december-day-31",
                "content": "This problem is the Daily LeetCoding Challenge for December, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2251644,
                "title": "c-well-explained-backtracking-recursion",
                "content": "```\\n/*\\nso here we want to return the number of of 4-directional walks from the starting square\\nto the ending square, that walk over every non-obstacle square exactly once.\\nmeans we have to cover every cell having value 0 ,and also skip the cell with value -1.\\nTherefore we can easily right a recursive function , where we write the sufficent base conditions\\nfollowed by writing a recurrence relation which will explore all the paths i.e LEFT , RIGHT , UP , DOWN \\n___________________________________________________________________________________\\nso talking about base conditions ,\\nif(i>=n || j>=m || i<0 || j<0 || grid[i][j]==-1 )\\n            return 0;\\n            \\nthis will handle the cases where we go out of bounds , and if we come accross a cell having value -1 \\n, therefore we can not pass thorugh it to reach our destination , therefore we will simply return 0\\n, because we have not reached our destination\\n___________________________________________________________________________________\\n\\nif(grid[i][j]==2){\\n            if(zero==-1)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        \\nnow we have reached our destnation which is cell having value 2, now we will check\\nwhether we have travelled across all the cells having value 0 , which is our prerequisite , \\nif yes return 1 , means this path is valid , else return 0\\n___________________________________________________________________________________\\n\\ngrid[i][j]=-1; \\nzero--;\\n\\nthis is done so that we dont travel over a cell more than once and also decreamenting the \\nnumber of zeroes , because we have travelled across a cell having value 0 , \\nand we have to travel all zeroes once \\n___________________________________________________________________________________\\n\\nint l=solve(grid,zero,i,j-1,n,m);\\nint r=solve(grid,zero,i,j+1,n,m);\\nint u=solve(grid,zero,i-1,j,n,m);\\nint d=solve(grid,zero,i+1,j,n,m);\\n\\neasy recurrence relation which will explore all paths from a cell  i.e LEFT , RIGHT , UP , DOWN \\n\\n___________________________________________________________________________________\\n\\nessential step of backtracking \\n grid[i][j]=0;\\n zero++;\\nnow as have completed one path  , we again set grid[i][j]=0; and zeroes++ , so thatwe can utilise the cells again \\n\\n___________________________________________________________________________________\\nreturn l+r+u+d\\n \\n  returning all valid paths\\n*/\\n\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& grid,int zero,int i, int j, int n, int m){\\n        \\n        if(i>=n || j>=m || i<0 || j<0 || grid[i][j]==-1 )\\n            return 0;\\n        \\n        if(grid[i][j]==2){\\n            if(zero==-1)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n            \\n        grid[i][j]=-1; \\n        zero--;\\n        \\n        int l=solve(grid,zero,i,j-1,n,m);\\n        int r=solve(grid,zero,i,j+1,n,m);\\n        int u=solve(grid,zero,i-1,j,n,m);\\n        int d=solve(grid,zero,i+1,j,n,m);\\n        \\n        // bactrack\\n        grid[i][j]=0;\\n        zero++;\\n        \\n        return l+r+u+d;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int startRow=0,startCol=0;\\n        int zero=0;\\n       \\n        \\n        // calculating no of zeroes , which is essential , because\\n        // ATQ walk over every non-obstacle square exactly once.\\n        // also we will save our starting path which is from grid[i][j]=1\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==0)  zero++;\\n                \\n                if(grid[i][j]==1){\\n                    startRow=i;\\n                    startCol=j;\\n                }\\n            }\\n        }\\n        \\n        return solve(grid,zero,startRow,startCol,n,m);\\n\\n    }\\n};\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int solve(vector<vector<int>>& grid,int zero,int i, int j, int n, int m){\\n        \\n        if(i>=n || j>=m || i<0 || j<0 || grid[i][j]==-1 )\\n            return 0;\\n        \\n        if(grid[i][j]==2){\\n            if(zero==-1)\\n                return 1;\\n            else\\n                return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1854228,
                "title": "java-0ms-self-explainatory-easy-backtracking-consise",
                "content": "```\\nclass Solution {\\n    int count = 0;\\n    public int uniquePathsIII(int[][] grid) {\\n        int blocks = 1;\\n        for(int[] arr:grid) for(int a:arr) if(a==0) blocks++;\\n        for(int i=0;i<grid.length;i++) for(int j=0;j<grid[0].length;j++) if(grid[i][j] == 1) dfs(grid,i,j,blocks);\\n        return count;\\n    }\\n    public void dfs(int[][] grid,int i,int j,int blocks){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1 || grid[i][j] == -2) return;\\n        if(grid[i][j] == 2 && blocks == 0){\\n            count++;\\n            return;\\n        }\\n        if(grid[i][j] == 2) return;\\n        grid[i][j] = -2;\\n        dfs(grid,i-1,j,blocks-1);\\n        dfs(grid,i,j+1,blocks-1);\\n        dfs(grid,i+1,j,blocks-1);\\n        dfs(grid,i,j-1,blocks-1);\\n        grid[i][j] = 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public int uniquePathsIII(int[][] grid) {\\n        int blocks = 1;\\n        for(int[] arr:grid) for(int a:arr) if(a==0) blocks++;\\n        for(int i=0;i<grid.length;i++) for(int j=0;j<grid[0].length;j++) if(grid[i][j] == 1) dfs(grid,i,j,blocks);\\n        return count;\\n    }\\n    public void dfs(int[][] grid,int i,int j,int blocks){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1 || grid[i][j] == -2) return;\\n        if(grid[i][j] == 2 && blocks == 0){\\n            count++;\\n            return;\\n        }\\n        if(grid[i][j] == 2) return;\\n        grid[i][j] = -2;\\n        dfs(grid,i-1,j,blocks-1);\\n        dfs(grid,i,j+1,blocks-1);\\n        dfs(grid,i+1,j,blocks-1);\\n        dfs(grid,i,j-1,blocks-1);\\n        grid[i][j] = 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555455,
                "title": "intuition-explained-backtracking-dfs-on-grid-c-clean-code",
                "content": "**Intuition:**\\n\\n* Idea is to traverse from **Start to End** and when all the empty cells are **visited**, we have a path that visits all the empty cells. \\n\\n* So, first of all we identify **starting** coordinate. And also **count** number of empty cells. \\n* Then, we do normal DFS on grid in all **valid directions** and decrement count of empty cells when we visit it. \\n\\n\\t* We visit a cell, move to valid direction & get count of paths. And *decrement empty cell count.*\\n\\t* Then we unvisit that cell and unvisit it. So that we can explore other possible paths. \\n\\n* Base condition is when we reach destination cell, and \\n\\t* if all empty cell are visited i.e **count is zero**, then `return 1` which means we have a unique path.\\n\\t* else we `return 0`,  which means not all empty cell are visited.\\n\\n# Code: \\n```\\nstatic int X[4] = {-1, 0, 1, 0};\\nstatic int Y[4] = {0, -1, 0, 1};\\n\\nclass Solution {\\npublic:\\n    \\n    int countPaths(vector<vector<int>>& grid, int x, int y, int empty, const int& m, const int& n) {\\n        \\n\\t\\t/*\\n\\t\\tfor(int i=0; i<m; i++) {\\n\\t\\t\\tfor(int j=0; j<n; j++) {\\n\\t\\t\\t\\tcout << grid[i][j] << \" \";\\n\\t\\t\\t}\\n\\t\\t\\tcout << endl;\\n\\t\\t}\\n\\t\\tcout << x << \" : \" << y << \" -> \" << empty << endl << endl;\\n\\t\\t*/\\n\\t\\t\\n\\t\\t// If we reach end cell and \\n\\t\\t// All empty cells are visited, then return 1\\n\\t\\t// Else return 0\\n        if(grid[x][y] == 2) {\\n            return (empty == 0);\\n        }\\n                \\n        int count = 0;   // Count of possible paths from current cell {x,y}\\n        grid[x][y] = -1;  // Visit\\n        \\n\\t\\t// Check for all valid directions\\n        for(int k=0; k<4; k++) {\\n\\t\\t\\t// Possible adjacent coordinates\\n            int i = x + X[k];\\n            int j = y + Y[k];\\n\\t\\t\\t\\n\\t\\t\\t// Valid Moves\\n            if(i>=0 && j>=0 && i<m && j<n && grid[i][j] != -1) {\\n                count += countPaths(grid, i, j, empty-1, m, n);  // Add count of possible paths\\n            }\\n        }\\n        \\n\\t\\t// Backtrack \\n        grid[x][y] = 0;  // Unvisit\\n        \\n        return count;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid[0].size(), empty = 1;\\n        \\n        pair<int, int> start;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] == 1) start = {i, j};\\n                else if(grid[i][j] == 0) empty++;  // Count of empty cells\\n            }\\n        }\\n        \\n\\t\\t// Explore grid from start cell\\n        return countPaths(grid, start.first, start.second, empty, m, n);\\n    }\\n};\\n```\\n\\n***If you find this solution helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nstatic int X[4] = {-1, 0, 1, 0};\\nstatic int Y[4] = {0, -1, 0, 1};\\n\\nclass Solution {\\npublic:\\n    \\n    int countPaths(vector<vector<int>>& grid, int x, int y, int empty, const int& m, const int& n) {\\n        \\n\\t\\t/*\\n\\t\\tfor(int i=0; i<m; i++) {\\n\\t\\t\\tfor(int j=0; j<n; j++) {\\n\\t\\t\\t\\tcout << grid[i][j] << \" \";\\n\\t\\t\\t}\\n\\t\\t\\tcout << endl;\\n\\t\\t}\\n\\t\\tcout << x << \" : \" << y << \" -> \" << empty << endl << endl;\\n\\t\\t*/\\n\\t\\t\\n\\t\\t// If we reach end cell and \\n\\t\\t// All empty cells are visited, then return 1\\n\\t\\t// Else return 0\\n        if(grid[x][y] == 2) {\\n            return (empty == 0);\\n        }\\n                \\n        int count = 0;   // Count of possible paths from current cell {x,y}\\n        grid[x][y] = -1;  // Visit\\n        \\n\\t\\t// Check for all valid directions\\n        for(int k=0; k<4; k++) {\\n\\t\\t\\t// Possible adjacent coordinates\\n            int i = x + X[k];\\n            int j = y + Y[k];\\n\\t\\t\\t\\n\\t\\t\\t// Valid Moves\\n            if(i>=0 && j>=0 && i<m && j<n && grid[i][j] != -1) {\\n                count += countPaths(grid, i, j, empty-1, m, n);  // Add count of possible paths\\n            }\\n        }\\n        \\n\\t\\t// Backtrack \\n        grid[x][y] = 0;  // Unvisit\\n        \\n        return count;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid[0].size(), empty = 1;\\n        \\n        pair<int, int> start;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] == 1) start = {i, j};\\n                else if(grid[i][j] == 0) empty++;  // Count of empty cells\\n            }\\n        }\\n        \\n\\t\\t// Explore grid from start cell\\n        return countPaths(grid, start.first, start.second, empty, m, n);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1554256,
                "title": "faster-than-100-of-c-solutions-intuitive-approach-simplified-explanation",
                "content": "Hello everyone, I\\'m new to this post stuff so any feedback is appreciated. Thank you in advance for reading !!!\\n\\n**Summary:** Since, we need to find every possible ways to reach from starting to ending cell while visiting every cell of the grid, we need to find the starting cell first and also need to count the empty cells that can be visited. Then we\\'ll find every path recursively.\\n\\n**Explanation:**\\n\\n1. We first find the starting cell of the grid and count the empty cells (with value 0) that can be visited.\\n\\n2. We will use simple dfs to visit every cell and keep the track of visited cells by a booloean array.\\n\\n3. for any cell (i,j) we check whether it is a valid cell or not (can be visited or not), then we check whether this cell is our ending cell or not and also we have visited all empty cells or not (a simple variable can keep a track of that).\\n\\n4. Then we recursively traverse in all four direction from this cell and try to find ways to reach to our destination.\\n\\n5. Then we backtrack i.e. unmark this cell (change it from visited to unvisited so that other paths can consider this cell for a visit) and return the total ways we can reach to our ending cell from this current cell.\\n\\nBelow is my code for the above approach:\\n\\n```\\nclass Solution {\\npublic:\\n    int startx, starty, tot{1};\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    \\n    int find_ways(int x, int y, int blocks, vector<vector<bool>>& vis, vector<vector<int>>& grid){\\n        \\n        // not a valid cell\\n        if(x < 0 || x >=grid.size() || y >= grid[0].size() || y < 0 || vis[x][y] || grid[x][y] == -1) \\n            return 0;\\n        \\n        // ending cell\\n        if(grid[x][y] == 2){\\n            \\n            if(blocks == tot) return 1;\\n            else return 0;\\n        }\\n        \\n        int res{};\\n        \\n        vis[x][y] = true; // mark this cell as visited\\n        \\n        //Traverse in all 4 directions\\n        for(int i{}; i<4; ++i){\\n            \\n            int new_x = x + dx[i];\\n            int new_y = y + dy[i];\\n            \\n            res += find_ways(new_x, new_y, blocks+1, vis, grid);\\n        }\\n        \\n        // mark this cell as unvisited as we are going back to our previous cell\\n        // so that other paths can consider this cell to visit\\n        vis[x][y] = false; \\n        \\n        return res;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<bool>>vis(n, vector<bool>(m, false));\\n        \\n        // count empty cells and find starting cell\\n        for(int i{}; i<n; ++i){ \\n            for(int j{}; j<m; ++j){\\n                \\n                if(grid[i][j] == 0) tot++;\\n                \\n                if(grid[i][j] == 1) startx = i, starty = j;\\n            }\\n        }\\n        \\n        return find_ways(startx, starty, 0, vis, grid);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int startx, starty, tot{1};\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    \\n    int find_ways(int x, int y, int blocks, vector<vector<bool>>& vis, vector<vector<int>>& grid){\\n        \\n        // not a valid cell\\n        if(x < 0 || x >=grid.size() || y >= grid[0].size() || y < 0 || vis[x][y] || grid[x][y] == -1) \\n            return 0;\\n        \\n        // ending cell\\n        if(grid[x][y] == 2){\\n            \\n            if(blocks == tot) return 1;\\n            else return 0;\\n        }\\n        \\n        int res{};\\n        \\n        vis[x][y] = true; // mark this cell as visited\\n        \\n        //Traverse in all 4 directions\\n        for(int i{}; i<4; ++i){\\n            \\n            int new_x = x + dx[i];\\n            int new_y = y + dy[i];\\n            \\n            res += find_ways(new_x, new_y, blocks+1, vis, grid);\\n        }\\n        \\n        // mark this cell as unvisited as we are going back to our previous cell\\n        // so that other paths can consider this cell to visit\\n        vis[x][y] = false; \\n        \\n        return res;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<bool>>vis(n, vector<bool>(m, false));\\n        \\n        // count empty cells and find starting cell\\n        for(int i{}; i<n; ++i){ \\n            for(int j{}; j<m; ++j){\\n                \\n                if(grid[i][j] == 0) tot++;\\n                \\n                if(grid[i][j] == 1) startx = i, starty = j;\\n            }\\n        }\\n        \\n        return find_ways(startx, starty, 0, vis, grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438002,
                "title": "c-faster-than-100-by-simple-backtracking",
                "content": "It\\'s written in pretty simple manner and with a simple logic that whenever we reach the finishing point we check that every part in the grid is visited or not... if it is then we just increase the count.\\n```\\nclass Solution {\\nprivate:\\n    void helper(vector<vector<int>>& grid, bool**visited,int m,int n,int i,int j,int &count){\\n       \\n        \\n        visited[i][j]=true;\\n        \\n        if(grid[i][j]==2){\\n            for(int a=0;a<m;a++){\\n                for(int b=0;b<n;b++){\\n                    if(visited[a][b]==false){\\n                        visited[i][j]=false;\\n                        return;\\n                    }\\n                }\\n            }\\n            count++;\\n            visited[i][j]=false;\\n            return;\\n        }\\n        \\n        for(int x=i-1;x<=i+1;x++){\\n            if(x>=0 and x<m and visited[x][j]==false){\\n                helper(grid,visited,m,n,x,j,count);\\n            }\\n        }\\n        \\n         for(int y=j-1;y<=j+1;y++){\\n            if(y>=0 and y<n and visited[i][y]==false){\\n                helper(grid,visited,m,n,i,y,count);\\n            }\\n        }\\n        \\n        visited[i][j]=false;\\n\\n    }\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        bool**visited=new bool*[m];\\n        for(int i=0;i<m;i++){\\n            visited[i]=new bool[n];\\n            for(int j=0;j<n;j++){\\n                visited[i][j]=false;\\n                if(grid[i][j]==-1)visited[i][j]=true;\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    helper(grid,visited,m,n,i,j,count);\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n   }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    void helper(vector<vector<int>>& grid, bool**visited,int m,int n,int i,int j,int &count){\\n       \\n        \\n        visited[i][j]=true;\\n        \\n        if(grid[i][j]==2){\\n            for(int a=0;a<m;a++){\\n                for(int b=0;b<n;b++){\\n                    if(visited[a][b]==false){\\n                        visited[i][j]=false;\\n                        return;\\n                    }\\n                }\\n            }\\n            count++;\\n            visited[i][j]=false;\\n            return;\\n        }\\n        \\n        for(int x=i-1;x<=i+1;x++){\\n            if(x>=0 and x<m and visited[x][j]==false){\\n                helper(grid,visited,m,n,x,j,count);\\n            }\\n        }\\n        \\n         for(int y=j-1;y<=j+1;y++){\\n            if(y>=0 and y<n and visited[i][y]==false){\\n                helper(grid,visited,m,n,i,y,count);\\n            }\\n        }\\n        \\n        visited[i][j]=false;\\n\\n    }\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        bool**visited=new bool*[m];\\n        for(int i=0;i<m;i++){\\n            visited[i]=new bool[n];\\n            for(int j=0;j<n;j++){\\n                visited[i][j]=false;\\n                if(grid[i][j]==-1)visited[i][j]=true;\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    helper(grid,visited,m,n,i,j,count);\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 633943,
                "title": "essence-of-backtracking-brief-explanation",
                "content": "```\\nint x[] = {-1,0,1,0};   // direction coordinates for guidance of next move\\nint y[] = {0,1,0,-1};\\nclass Solution {\\npublic:\\n    int start_i, start_j, end_i,end_j,n,m,ob;// ob == no of obstacles\\n    long long ans;\\n    \\n    void sub(vector<vector<int>> &mat , vector<vector<bool>> &vis, int si, int sj, int &mark)\\n    {\\n        if(si==end_i and sj==end_j)\\n        { \\n            if(mark== n*m-ob-1) // total cell - no of obstacle - 1 , why -1 ? as we are not counting for endi,j\\n                ans++ ; \\n            return;\\n        }\\n        \\n        for(int k=0 ; k<4 ; k++)\\n        {\\n            int newi = si+x[k]; // our new i and j\\n            int newj = sj+y[k];\\n            \\n            //we must look that newi,j is valid and not been visited and doesnot have obstacle\\n            if(newi>=0 and newi<n and newj>=0 and newj<m and mat[newi][newj]!=-1 and !vis[newi][newj])\\n            {\\n                vis[newi][newj]=true;\\n                sub(mat,vis,newi, newj, ++mark);\\n                vis[newi][newj]=false,mark--;          // backtracking step\\n            }\\n        }\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& mat) {        \\n        n = mat.size();\\n        m = mat[0].size();\\n        ans = ob = 0;\\n        int mark=0;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            for(int j=0 ; j<m ; j++)\\n            {\\n                if(mat[i][j]==-1) ob++;\\n                if(mat[i][j]==1)\\n                    start_i = i, start_j = j;\\n                if(mat[i][j]==2)\\n                    end_i = i, end_j = j;\\n            }\\n        }\\n        vector<vector<bool>> vis(n,vector<bool>(m));\\n        vis[start_i][start_j] = true;\\n        sub(mat,vis,start_i , start_j,mark);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nint x[] = {-1,0,1,0};   // direction coordinates for guidance of next move\\nint y[] = {0,1,0,-1};\\nclass Solution {\\npublic:\\n    int start_i, start_j, end_i,end_j,n,m,ob;// ob == no of obstacles\\n    long long ans;\\n    \\n    void sub(vector<vector<int>> &mat , vector<vector<bool>> &vis, int si, int sj, int &mark)\\n    {\\n        if(si==end_i and sj==end_j)\\n        { \\n            if(mark== n*m-ob-1) // total cell - no of obstacle - 1 , why -1 ? as we are not counting for endi,j\\n                ans++ ; \\n            return;\\n        }\\n        \\n        for(int k=0 ; k<4 ; k++)\\n        {\\n            int newi = si+x[k]; // our new i and j\\n            int newj = sj+y[k];\\n            \\n            //we must look that newi,j is valid and not been visited and doesnot have obstacle\\n            if(newi>=0 and newi<n and newj>=0 and newj<m and mat[newi][newj]!=-1 and !vis[newi][newj])\\n            {\\n                vis[newi][newj]=true;\\n                sub(mat,vis,newi, newj, ++mark);\\n                vis[newi][newj]=false,mark--;          // backtracking step\\n            }\\n        }\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& mat) {        \\n        n = mat.size();\\n        m = mat[0].size();\\n        ans = ob = 0;\\n        int mark=0;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            for(int j=0 ; j<m ; j++)\\n            {\\n                if(mat[i][j]==-1) ob++;\\n                if(mat[i][j]==1)\\n                    start_i = i, start_j = j;\\n                if(mat[i][j]==2)\\n                    end_i = i, end_j = j;\\n            }\\n        }\\n        vector<vector<bool>> vis(n,vector<bool>(m));\\n        vis[start_i][start_j] = true;\\n        sub(mat,vis,start_i , start_j,mark);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 267094,
                "title": "python3-solution-using-backtracking",
                "content": "## Thought process\\n- backtracking\\n\\t- 4 subroutine calls\\n\\t\\t- backtrack(i, j+1) + backtrack(i, j-1) + backtrack(i+1, j) + backtrack(i-1, j)\\n\\t\\t- need to be aware of the current state (grid)\\n\\t\\t- base cases\\n\\t\\t\\t- i < 0 or i == m or j < 0 or j == n\\n\\t\\t\\t- grid[i][j] == -1: return 0\\n\\t\\t\\t- grid[i][j] == 2: return 1 if all other non-empty cells are visited (by checking the remaining count), otherwise return 0\\n\\t\\t\\t- grid[i][j] == 0: mask current cell to be -1, return sum of 4 subroutine calls (remember to reset the state each subroutine calls)\\n\\n- cannot use DP for cache because of the dynamic state?\\n\\n## Code\\n```py\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        if not grid or not grid[0]:\\n            return 0\\n        m, n = len(grid), len(grid[0])\\n        non_empty_count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != -1:\\n                    non_empty_count += 1\\n                if grid[i][j] == 1:\\n                    start_i, start_j = i, j\\n                    \\n        def backtrack(i, j, remain):\\n            if i < 0 or i == m or j < 0 or j == n or grid[i][j] == -1:\\n                return 0\\n            if grid[i][j] == 2:\\n                return remain == 1\\n            res = 0\\n            grid[i][j] = -1\\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\\n                res += backtrack(x, y, remain-1)\\n            grid[i][j] = 0\\n            return res\\n\\n        return backtrack(start_i, start_j, non_empty_count)\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```py\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        if not grid or not grid[0]:\\n            return 0\\n        m, n = len(grid), len(grid[0])\\n        non_empty_count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != -1:\\n                    non_empty_count += 1\\n                if grid[i][j] == 1:\\n                    start_i, start_j = i, j\\n                    \\n        def backtrack(i, j, remain):\\n            if i < 0 or i == m or j < 0 or j == n or grid[i][j] == -1:\\n                return 0\\n            if grid[i][j] == 2:\\n                return remain == 1\\n            res = 0\\n            grid[i][j] = -1\\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\\n                res += backtrack(x, y, remain-1)\\n            grid[i][j] = 0\\n            return res\\n\\n        return backtrack(start_i, start_j, non_empty_count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222466,
                "title": "python-bit-mask-dp-solution",
                "content": "Similar to [847. Shortest Path Visiting All Nodes](https://leetcode.com/problems/shortest-path-visiting-all-nodes/), we can use DP.\\n\\nThe dp state involves visited positions and current position. The visited positions are marked by a bit mask ---- the `(a*M + b)`-th bit is set if `grid[a][b]` has been visited. The DP state should also include the current position `(i,j)`.\\n\\n`dp[(mask, i, j)]` is the number of unique paths to get to position `(i,j)` by visiting all positions marked by set bits in the `mask`. \\n\\nSay for input grid:\\n```\\n[[2,0,0,1,-1]]\\n```\\nwe start from state `(0b01000, 0, 3)` to reach `(0b01111, 0, 0)`. Initially `dp[(0b01000, 0, 3)] = 1` and we want to find out `dp[(0b01111, 0, 0)]`.\\n\\nWe can do bottom-up style DP by BFS. There are `2^(N*M)` * N * M states and also 4 choices, so O(N * M * 2^(N*M)) time complexity.\\n\\n```\\n    def uniquePathsIII(self, grid):\\n        N, M = len(grid), len(grid[0])\\n        \\n        full = 0\\n        for i, j in itertools.product(range(N), range(M)):\\n                if grid[i][j] != -1: full |= 1 <<(i*M+j)\\n                if grid[i][j] == 1: x, y = i, j\\n                elif grid[i][j] == 2: u, v = i, j\\n        \\n        dp = {(1<<(x*M+y),x,y): 1}\\n        \\n        bfs = set([(1<<(x*M+y),x,y)])\\n        while bfs:\\n            tmp = set()\\n            for mask, i, j in bfs:\\n                if (i, j) == (u, v): continue\\n                for a, b in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                    if 0 <= a < N and 0 <= b < M and grid[a][b] != -1:\\n                        bit = 1 << (a*M + b)\\n                        if mask & bit: continue\\n                        newstate = (mask | bit, a, b)\\n                        dp[newstate] = dp.setdefault(newstate, 0) + dp[mask,i,j]\\n                        tmp.add(newstate)\\n            bfs = tmp\\n        return dp.setdefault((full,u,v), 0)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n[[2,0,0,1,-1]]\\n```\n```\\n    def uniquePathsIII(self, grid):\\n        N, M = len(grid), len(grid[0])\\n        \\n        full = 0\\n        for i, j in itertools.product(range(N), range(M)):\\n                if grid[i][j] != -1: full |= 1 <<(i*M+j)\\n                if grid[i][j] == 1: x, y = i, j\\n                elif grid[i][j] == 2: u, v = i, j\\n        \\n        dp = {(1<<(x*M+y),x,y): 1}\\n        \\n        bfs = set([(1<<(x*M+y),x,y)])\\n        while bfs:\\n            tmp = set()\\n            for mask, i, j in bfs:\\n                if (i, j) == (u, v): continue\\n                for a, b in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                    if 0 <= a < N and 0 <= b < M and grid[a][b] != -1:\\n                        bit = 1 << (a*M + b)\\n                        if mask & bit: continue\\n                        newstate = (mask | bit, a, b)\\n                        dp[newstate] = dp.setdefault(newstate, 0) + dp[mask,i,j]\\n                        tmp.add(newstate)\\n            bfs = tmp\\n        return dp.setdefault((full,u,v), 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2975953,
                "title": "c-easy-and-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nProblem is based on finding an appropriate path from source to destination. \\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\nFirstly using recursion and Backtracking we first find all possible paths from source to destination and then select the path which covers all the cells except the cell on which we cannot walk.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int m,n,o=0;\\n    bool check(int x,int y,vector<vector<int>>& grid,vector<pair<int,int>> visited){\\n        if(x<0||x>=m||y<0||y>=n||grid[x][y]==-1){\\n            return false;\\n        }\\n        for(int i=0;i<visited.size();i++){\\n            if(visited[i].first==x&&visited[i].second==y){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void solution(vector<vector<int>>& grid,int x,int y,vector<pair<int,int>> visited){\\n        if(check(x,y,grid,visited)){\\n            if(grid[x][y]==2&&visited.size()==(m*n)-o-1){b\\n                ans++;\\n                return;\\n            }\\n            if(grid[x][y]==2){\\n                return;\\n            }\\n            visited.push_back({x,y});\\n            solution(grid,x+1,y,visited);\\n            solution(grid,x,y+1,visited);\\n            solution(grid,x-1,y,visited);\\n            solution(grid,x,y-1,visited);\\n        }\\n        return;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        m=grid.size();\\n        n=grid[0].size();\\n        int a,b;\\n        bool k=true;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1&&k){\\n                    k=false;\\n                    a=i;\\n                    b=j;\\n                }\\n                cout<<i<<\" \"<<j<<endl;\\n                if(grid[i][j]==-1){\\n                    o++;\\n                }\\n            }\\n        }\\n        vector<pair<int,int>> visited;\\n        solution(grid,a,b,visited);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int m,n,o=0;\\n    bool check(int x,int y,vector<vector<int>>& grid,vector<pair<int,int>> visited){\\n        if(x<0||x>=m||y<0||y>=n||grid[x][y]==-1){\\n            return false;\\n        }\\n        for(int i=0;i<visited.size();i++){\\n            if(visited[i].first==x&&visited[i].second==y){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void solution(vector<vector<int>>& grid,int x,int y,vector<pair<int,int>> visited){\\n        if(check(x,y,grid,visited)){\\n            if(grid[x][y]==2&&visited.size()==(m*n)-o-1){b\\n                ans++;\\n                return;\\n            }\\n            if(grid[x][y]==2){\\n                return;\\n            }\\n            visited.push_back({x,y});\\n            solution(grid,x+1,y,visited);\\n            solution(grid,x,y+1,visited);\\n            solution(grid,x-1,y,visited);\\n            solution(grid,x,y-1,visited);\\n        }\\n        return;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        m=grid.size();\\n        n=grid[0].size();\\n        int a,b;\\n        bool k=true;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1&&k){\\n                    k=false;\\n                    a=i;\\n                    b=j;\\n                }\\n                cout<<i<<\" \"<<j<<endl;\\n                if(grid[i][j]==-1){\\n                    o++;\\n                }\\n            }\\n        }\\n        vector<pair<int,int>> visited;\\n        solution(grid,a,b,visited);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2975189,
                "title": "python-simple-python-solution-using-dfs-backtracking-recursion",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 61 ms, faster than 87.68% of Python3 online submissions for Unique Paths III.\\n# Memory Usage: 13.9 MB, less than 54.63% of Python3 online submissions for Unique Paths III.\\n\\n\\tclass Solution:\\n\\t\\tdef uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\n\\t\\t\\tdef DFS(row, col, count_zero, grid):\\n\\n\\t\\t\\t\\tif row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]) or grid[row][col] == -1:\\n\\t\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\t\\tif grid[row][col] == 2:\\n\\t\\t\\t\\t\\tif count_zero == -1:\\n\\t\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\t\\tgrid[row][col] = -1\\n\\n\\t\\t\\t\\tcount_zero = count_zero - 1\\n\\n\\t\\t\\t\\ttotal_paths = DFS(row + 1, col, count_zero, grid) + DFS(row, col + 1, count_zero, grid) + DFS(row - 1, col, count_zero, grid) + DFS(row, col - 1, count_zero, grid)\\n\\n\\t\\t\\t\\tgrid[row][col] = 0\\n\\n\\t\\t\\t\\tcount_zero = count_zero + 1\\n\\n\\t\\t\\t\\treturn total_paths\\n\\n\\t\\t\\tcount_zero = 0\\n\\t\\t\\tx,y = 0,0\\n\\n\\t\\t\\tfor r in range(len(grid)):\\n\\t\\t\\t\\tfor c in range(len(grid[0])):\\n\\n\\t\\t\\t\\t\\tif grid[r][c] == 0:\\n\\t\\t\\t\\t\\t\\tcount_zero = count_zero + 1\\n\\n\\t\\t\\t\\t\\telif grid[r][c] == 1:\\n\\t\\t\\t\\t\\t\\tx,y = r,c\\n\\n\\t\\t\\treturn DFS(x, y, count_zero, grid)\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 61 ms, faster than 87.68% of Python3 online submissions for Unique Paths III.\\n# Memory Usage: 13.9 MB, less than 54.63% of Python3 online submissions for Unique Paths III.\\n\\n\\tclass Solution:\\n\\t\\tdef uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\n\\t\\t\\tdef DFS(row, col, count_zero, grid):\\n\\n\\t\\t\\t\\tif row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]) or grid[row][col] == -1:\\n\\t\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\t\\tif grid[row][col] == 2:\\n\\t\\t\\t\\t\\tif count_zero == -1:\\n\\t\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\t\\tgrid[row][col] = -1\\n\\n\\t\\t\\t\\tcount_zero = count_zero - 1\\n\\n\\t\\t\\t\\ttotal_paths = DFS(row + 1, col, count_zero, grid) + DFS(row, col + 1, count_zero, grid) + DFS(row - 1, col, count_zero, grid) + DFS(row, col - 1, count_zero, grid)\\n\\n\\t\\t\\t\\tgrid[row][col] = 0\\n\\n\\t\\t\\t\\tcount_zero = count_zero + 1\\n\\n\\t\\t\\t\\treturn total_paths\\n\\n\\t\\t\\tcount_zero = 0\\n\\t\\t\\tx,y = 0,0\\n\\n\\t\\t\\tfor r in range(len(grid)):\\n\\t\\t\\t\\tfor c in range(len(grid[0])):\\n\\n\\t\\t\\t\\t\\tif grid[r][c] == 0:\\n\\t\\t\\t\\t\\t\\tcount_zero = count_zero + 1\\n\\n\\t\\t\\t\\t\\telif grid[r][c] == 1:\\n\\t\\t\\t\\t\\t\\tx,y = r,c\\n\\n\\t\\t\\treturn DFS(x, y, count_zero, grid)\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 2974852,
                "title": "c-dfs-backtracking-beats-100-0ms-runtime-explained-with-comments",
                "content": "# Intuition\\n\\nIn this problem we have to find the number of paths to reach from some point ```(x1, y1)``` to some point ```(x2, y2)``` and those paths should cover all the available cell exactly one time.\\n\\nSince we can move in all four directions, so we cannot apply any greedy algorithm.\\n\\nSo we should think about some brute-force approch which would cover all the possible paths and we will pick the valid paths.\\n\\nAfter thinking this much, we should always think about recursion and think about implementing it with backtracking.\\n\\nNote : After applying recursion, always try to think about applying Dynamic Programming to the code, in this case, it is not possible.\\n\\n# Approach\\n\\nSo first thing we should do is to find the total number of squares which we have to visit atleast once.\\n\\nAnd we need to find ```x1``` & ```y1``` (the starting coordinates).\\n\\nNow we need to calculate the total number of paths which satisfy the above condition.\\n\\nWe will create a 2-d array with name ```visited``` inwhich we will mark those coordinates as true which are already being included in the path.\\n\\nWe will write a recursive function inwhich first we check whether we are at a valid square or not , i.e., ```row``` and ```col``` should be in the range [0, m-1] and [0, n-1] respectively.\\n\\nIf the square is not valid, then we return, else we will check if the square is available or not. If ```grid[row][col]``` is equal to -1, it means it is not available and we will return.\\n\\nIf the square is already visited then we will return.\\n\\nThen we will check if the square is the ending point or not, if it is ending point then we can check the number of cells which are not being visited by the variable ```stepsRemaining```.\\n\\nIf stepsRemaining is equal to 0 then we can increment the variable ```totalNumberOfWays``` and then return.\\n\\nWe will mark the current square as visited and then call recursive function for all the four adjacent squares.\\n\\nAnd don\\'t forget to unmark the visited square.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> visited;\\n    int totalNumberOfWays = 0;\\n\\n    // Recursive function for traversing all paths\\n    void findPaths(int row, int col, int stepsRemaining, vector<vector<int>> &grid){\\n        \\n        // Checking if the square is valid or not\\n        if(row < 0 || col < 0 || row == grid.size() || col == grid[0].size()){\\n            return;\\n        }\\n\\n        // Checking whether the square is available or not\\n        if(grid[row][col] == -1 || visited[row][col] == 1){\\n            return;\\n        }\\n\\n        // Base Case\\n        if(grid[row][col] == 2){\\n            // checking if the path covered all squares or not\\n            if(stepsRemaining == 0){\\n                totalNumberOfWays++;\\n            }\\n            return;\\n        }\\n\\n        // Marking the square as visited\\n        visited[row][col] = 1;\\n\\n        // Recursive Calls for all adjacent squares\\n        findPaths(row - 1, col, stepsRemaining - 1, grid);\\n        findPaths(row + 1, col, stepsRemaining - 1, grid);\\n        findPaths(row, col - 1, stepsRemaining - 1, grid);\\n        findPaths(row, col + 1, stepsRemaining - 1, grid);\\n\\n        // Unmarking the square\\n        visited[row][col] = 0;\\n\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int x = 0;\\n        int y = 0;\\n        int totalSteps = 0;\\n        visited.resize(m, vector<int>(n, 0));\\n\\n        // counting total number of available squares\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == -1){\\n                    continue;\\n                }\\n                if(grid[i][j] == 1){\\n                    x = i;\\n                    y = j;\\n                }\\n                totalSteps++;\\n            }\\n        }\\n\\n        findPaths(x, y, totalSteps - 1, grid);\\n\\n        return totalNumberOfWays;\\n        \\n    }\\n};\\n```\\n\\nIn case of any queries, feel free to ask in the comment section.\\n\\nIf you like the explanation then please **upvote**. It took me a lot of efforts to write this article.\\n\\nThank you for reading till the end : )",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```(x1, y1)```\n```(x2, y2)```\n```x1```\n```y1```\n```visited```\n```row```\n```col```\n```grid[row][col]```\n```stepsRemaining```\n```totalNumberOfWays```\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> visited;\\n    int totalNumberOfWays = 0;\\n\\n    // Recursive function for traversing all paths\\n    void findPaths(int row, int col, int stepsRemaining, vector<vector<int>> &grid){\\n        \\n        // Checking if the square is valid or not\\n        if(row < 0 || col < 0 || row == grid.size() || col == grid[0].size()){\\n            return;\\n        }\\n\\n        // Checking whether the square is available or not\\n        if(grid[row][col] == -1 || visited[row][col] == 1){\\n            return;\\n        }\\n\\n        // Base Case\\n        if(grid[row][col] == 2){\\n            // checking if the path covered all squares or not\\n            if(stepsRemaining == 0){\\n                totalNumberOfWays++;\\n            }\\n            return;\\n        }\\n\\n        // Marking the square as visited\\n        visited[row][col] = 1;\\n\\n        // Recursive Calls for all adjacent squares\\n        findPaths(row - 1, col, stepsRemaining - 1, grid);\\n        findPaths(row + 1, col, stepsRemaining - 1, grid);\\n        findPaths(row, col - 1, stepsRemaining - 1, grid);\\n        findPaths(row, col + 1, stepsRemaining - 1, grid);\\n\\n        // Unmarking the square\\n        visited[row][col] = 0;\\n\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int x = 0;\\n        int y = 0;\\n        int totalSteps = 0;\\n        visited.resize(m, vector<int>(n, 0));\\n\\n        // counting total number of available squares\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == -1){\\n                    continue;\\n                }\\n                if(grid[i][j] == 1){\\n                    x = i;\\n                    y = j;\\n                }\\n                totalSteps++;\\n            }\\n        }\\n\\n        findPaths(x, y, totalSteps - 1, grid);\\n\\n        return totalNumberOfWays;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974379,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    DFS + Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> grids;\\n    int n, m, ans, zero;\\n\\n    void dfs(int x, int y) {\\n        if(x < 0 or x >= n or y < 0 or y >= m or grids[x][y] == -1) {\\n            return;\\n        }\\n        if(grids[x][y] == 2) {\\n            if(zero == -1) ans++;\\n            return;\\n        }\\n        grids[x][y] = -1;\\n        zero--;\\n        dfs(x-1, y);\\n        dfs(x+1, y);\\n        dfs(x, y-1);\\n        dfs(x, y+1);\\n        zero++;\\n        grids[x][y] = 0;\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        grids = grid;\\n        n = grid.size(), m = grid[0].size();\\n        int sx, sy;;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j] == 1) sx = i, sy = j;\\n                else if(grid[i][j] == 0) zero++;\\n            }\\n        }\\n        dfs(sx, sy);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> grids;\\n    int n, m, ans, zero;\\n\\n    void dfs(int x, int y) {\\n        if(x < 0 or x >= n or y < 0 or y >= m or grids[x][y] == -1) {\\n            return;\\n        }\\n        if(grids[x][y] == 2) {\\n            if(zero == -1) ans++;\\n            return;\\n        }\\n        grids[x][y] = -1;\\n        zero--;\\n        dfs(x-1, y);\\n        dfs(x+1, y);\\n        dfs(x, y-1);\\n        dfs(x, y+1);\\n        zero++;\\n        grids[x][y] = 0;\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        grids = grid;\\n        n = grid.size(), m = grid[0].size();\\n        int sx, sy;;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j] == 1) sx = i, sy = j;\\n                else if(grid[i][j] == 0) zero++;\\n            }\\n        }\\n        dfs(sx, sy);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974071,
                "title": "c-simple-dfs-logic-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,0,1,0};\\n    int dy[4]={0,1,0,-1};\\n   int f(int i,int j,vector<vector<int>> &grid,int &c,int cnt)\\n   {\\n       if(i<0 or j<0 or i>=grid.size() or j>=grid[0].size() or grid[i][j]==-1)\\n           return 0;\\n       if(grid[i][j]==2)\\n       {\\n           cnt-=1;//-1 since we have also included start cell\\n           return (cnt==c)?1:0;//if all empty cells visited then returning 1 else 0\\n       }\\n       grid[i][j]=-1;\\n       int sum=0;\\n       sum=f(i+1,j,grid,c,cnt+1)+f(i,j+1,grid,c,cnt+1)+f(i-1,j,grid,c,cnt+1)+f(i,j-1,grid,c,cnt+1);\\n       grid[i][j]=0;\\n       return sum;\\n   }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<pair<int,int>> s;\\n        int c=0;//for counting no of empty cells\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                    s.push_back({i,j});//for storing starting indexes\\n                if(grid[i][j]==0)\\n                    c++;\\n            }\\n        }\\n       return f(s[0].first,s[0].second,grid,c,0); \\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,0,1,0};\\n    int dy[4]={0,1,0,-1};\\n   int f(int i,int j,vector<vector<int>> &grid,int &c,int cnt)\\n   {\\n       if(i<0 or j<0 or i>=grid.size() or j>=grid[0].size() or grid[i][j]==-1)\\n           return 0;\\n       if(grid[i][j]==2)\\n       {\\n           cnt-=1;//-1 since we have also included start cell\\n           return (cnt==c)?1:0;//if all empty cells visited then returning 1 else 0\\n       }\\n       grid[i][j]=-1;\\n       int sum=0;\\n       sum=f(i+1,j,grid,c,cnt+1)+f(i,j+1,grid,c,cnt+1)+f(i-1,j,grid,c,cnt+1)+f(i,j-1,grid,c,cnt+1);\\n       grid[i][j]=0;\\n       return sum;\\n   }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<pair<int,int>> s;\\n        int c=0;//for counting no of empty cells\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                    s.push_back({i,j});//for storing starting indexes\\n                if(grid[i][j]==0)\\n                    c++;\\n            }\\n        }\\n       return f(s[0].first,s[0].second,grid,c,0); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057209,
                "title": "c-2-solution-recursive-to-memoization-easy",
                "content": "**Recursive Solution :**\\n```\\nclass Solution {\\npublic:\\n    int f(int i,int j,int c,int& empty,vector<vector<int>>& grid){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==-1) return 0;\\n        if(grid[i][j]==2){\\n            if(c==empty)\\n                return 1;\\n            return 0;\\n        }\\n        grid[i][j]=-1;\\n        int up=f(i-1,j,c+1,empty,grid);\\n        int down=f(i+1,j,c+1,empty,grid);\\n        int right=f(i,j+1,c+1,empty,grid);\\n        int left=f(i,j-1,c+1,empty,grid);\\n        grid[i][j]=0;\\n        return up+down+right+left;        \\n        \\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int i=0,j=0,empty=1,start_x=0,start_y=0;\\n        for(i;i<grid.size();i++){\\n            for(j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    start_x=i;\\n                    start_y=j;                    \\n                }\\n                if(grid[i][j]==0)\\n                    empty++;\\n            }\\n        }\\n        return f(start_x,start_y,0,empty,grid);\\n    }\\n};\\n```\\n\\n**Memoization Solution :**\\n```\\nclass Solution {\\npublic:\\n    int f(int i,int j,int c,int& empty,vector<vector<int>>& grid,vector<vector<vector<int>>>& dp){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==-1) return 0;        \\n        if(grid[i][j]==2){\\n            if(c==empty)\\n                return 1;\\n            return 0;\\n        }\\n        if(dp[i][j][c]!=-1)return dp[i][j][c];\\n        \\n        grid[i][j]=-1;\\n        int up=f(i-1,j,c+1,empty,grid,dp);\\n        int down=f(i+1,j,c+1,empty,grid,dp);\\n        int right=f(i,j+1,c+1,empty,grid,dp);\\n        int left=f(i,j-1,c+1,empty,grid,dp);\\n        grid[i][j]=0;\\n        return dp[i][j][c+1]=(up+down+right+left);        \\n        \\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int i=0,j=0,empty=1,start_x=0,start_y=0;\\n        for(i;i<grid.size();i++){\\n            for(j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    start_x=i;\\n                    start_y=j;                    \\n                }\\n                if(grid[i][j]==0)\\n                    empty++;\\n            }\\n        }\\n        vector<vector<vector<int>>> dp(grid.size(), vector<vector<int>> (grid[0].size(),vector<int> (empty+1,-1)));\\n        return f(start_x,start_y,0,empty,grid,dp);\\n    }\\n};\\n```\\n\\n**Please Upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i,int j,int c,int& empty,vector<vector<int>>& grid){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==-1) return 0;\\n        if(grid[i][j]==2){\\n            if(c==empty)\\n                return 1;\\n            return 0;\\n        }\\n        grid[i][j]=-1;\\n        int up=f(i-1,j,c+1,empty,grid);\\n        int down=f(i+1,j,c+1,empty,grid);\\n        int right=f(i,j+1,c+1,empty,grid);\\n        int left=f(i,j-1,c+1,empty,grid);\\n        grid[i][j]=0;\\n        return up+down+right+left;        \\n        \\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int i=0,j=0,empty=1,start_x=0,start_y=0;\\n        for(i;i<grid.size();i++){\\n            for(j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    start_x=i;\\n                    start_y=j;                    \\n                }\\n                if(grid[i][j]==0)\\n                    empty++;\\n            }\\n        }\\n        return f(start_x,start_y,0,empty,grid);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(int i,int j,int c,int& empty,vector<vector<int>>& grid,vector<vector<vector<int>>>& dp){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==-1) return 0;        \\n        if(grid[i][j]==2){\\n            if(c==empty)\\n                return 1;\\n            return 0;\\n        }\\n        if(dp[i][j][c]!=-1)return dp[i][j][c];\\n        \\n        grid[i][j]=-1;\\n        int up=f(i-1,j,c+1,empty,grid,dp);\\n        int down=f(i+1,j,c+1,empty,grid,dp);\\n        int right=f(i,j+1,c+1,empty,grid,dp);\\n        int left=f(i,j-1,c+1,empty,grid,dp);\\n        grid[i][j]=0;\\n        return dp[i][j][c+1]=(up+down+right+left);        \\n        \\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int i=0,j=0,empty=1,start_x=0,start_y=0;\\n        for(i;i<grid.size();i++){\\n            for(j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    start_x=i;\\n                    start_y=j;                    \\n                }\\n                if(grid[i][j]==0)\\n                    empty++;\\n            }\\n        }\\n        vector<vector<vector<int>>> dp(grid.size(), vector<vector<int>> (grid[0].size(),vector<int> (empty+1,-1)));\\n        return f(start_x,start_y,0,empty,grid,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842954,
                "title": "clean-python-dfs-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        row_movements = [1, -1, 0, 0] # Possible changes in row index\\n        col_movements = [0, 0, 1, -1] # Possible changes in row index\\n        ways = 0 # Answer variable\\n        max_row = len(grid)\\n        max_col = len(grid[0])\\n        total = max_row * max_col # Total number of blocks to cover\\n        for r in range(max_row):\\n            for c in range(max_col):\\n                if grid[r][c] == -1: # Remove the blocks which are obstacles\\n                    total -= 1\\n\\n        def backtrack(row, col, visited, current_count): # Current row, col, visited indices and number of blocks traversed so far.\\n            nonlocal ways\\n            if grid[row][col] == 2 and current_count >= total: # Breaking conditions met\\n                ways += 1\\n\\t\\t\\t\\treturn\\n            for i in range(4): # 4 Possible movements from a certain row, column index\\n                r = row + row_movements[i]\\n                c = col + col_movements[i]\\n                if 0 <= r < max_row and 0 <= c < max_col and grid[r][c] != -1 and not visited[r][c]: # If the new r, c index is in range, is not an obstacle and is not yet visited\\n                    visited[r][c] = True # Traverse forward with visited set to true\\n                    backtrack(r, c, visited, current_count + 1) # DFS traversal\\n                    visited[r][c] = False # Backtrack by setting visited to false\\n\\n        for r in range(max_row):\\n            for c in range(max_col):\\n                if grid[r][c] == 1: # Starting index found\\n                    visited = [[False] * max_col for _ in range(max_row)]\\n                    visited[r][c] = True # Set starting index to True\\n                    backtrack(r, c, visited, 1) # Start DFS from starting index\\n                    return ways\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        row_movements = [1, -1, 0, 0] # Possible changes in row index\\n        col_movements = [0, 0, 1, -1] # Possible changes in row index\\n        ways = 0 # Answer variable\\n        max_row = len(grid)\\n        max_col = len(grid[0])\\n        total = max_row * max_col # Total number of blocks to cover\\n        for r in range(max_row):\\n            for c in range(max_col):\\n                if grid[r][c] == -1: # Remove the blocks which are obstacles\\n                    total -= 1\\n\\n        def backtrack(row, col, visited, current_count): # Current row, col, visited indices and number of blocks traversed so far.\\n            nonlocal ways\\n            if grid[row][col] == 2 and current_count >= total: # Breaking conditions met\\n                ways += 1\\n\\t\\t\\t\\treturn\\n            for i in range(4): # 4 Possible movements from a certain row, column index\\n                r = row + row_movements[i]\\n                c = col + col_movements[i]\\n                if 0 <= r < max_row and 0 <= c < max_col and grid[r][c] != -1 and not visited[r][c]: # If the new r, c index is in range, is not an obstacle and is not yet visited\\n                    visited[r][c] = True # Traverse forward with visited set to true\\n                    backtrack(r, c, visited, current_count + 1) # DFS traversal\\n                    visited[r][c] = False # Backtrack by setting visited to false\\n\\n        for r in range(max_row):\\n            for c in range(max_col):\\n                if grid[r][c] == 1: # Starting index found\\n                    visited = [[False] * max_col for _ in range(max_row)]\\n                    visited[r][c] = True # Set starting index to True\\n                    backtrack(r, c, visited, 1) # Start DFS from starting index\\n                    return ways\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821266,
                "title": "one-of-the-easiest-and-simplest-explanation",
                "content": "**First Try to understand the algo of Code**![image](https://assets.leetcode.com/users/images/a8bdc530-b192-4e98-819a-acba136a730a_1646474710.3266397.jpeg)\\n\\n# Let see the code\\n\\'\\'\\'\\n\\n      public int uniquePathsIII(int[][] grid) {\\n        boolean[][] path = new boolean[grid.length][grid[0].length];\\n\\n        // Total Number of boxes in Matrix\\n        int totalBlock=grid.length * grid[0].length;\\n\\n        int minusblock=0;\\n        int a=0;\\n        int b=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==1){\\n                    // To find the starting position of Robot\\n                    a=i;\\n                    b=j;\\n                }\\n                if(grid[i][j]==-1){\\n                    // Number of Minus Block\\n                    minusblock++;\\n                }\\n\\n            }\\n\\n        }\\n        // -1 to exclude its position\\n        totalBlock=totalBlock-minusblock-1;\\n\\n\\n        return uniquePathsIII(grid,a,b,path,totalBlock,0);\\n\\n\\n    }\\n\\n    public int uniquePathsIII(int[][] grid,int row,int column,boolean[][] path,int totalblock,int achivedblock) {\\n\\n        // Base Case\\n        if(row<0||column<0||row>=grid.length||column>=grid[row].length){\\n            return 0;\\n        }\\n        // if robot come at -1 box and come twice at same box return 0;\\n        if(grid[row][column]==-1||path[row][column]){\\n            return 0;\\n        }\\n        //  ---- If robot reach at destination but ! did not caver all Boxex then return0\\n        if(grid[row][column]==2&&achivedblock!=totalblock){\\n            return 0;\\n\\n        }\\n\\n        // ----If robot reach at destination and caver all Boxex then return 1\\n        if(grid[row][column]==2&&achivedblock==totalblock){\\n\\n\\n            return 1;\\n        }\\n\\n        path[row][column]=true;\\n\\n       // In recursion we passes acheivedblock +1 Because we cover 1 box;\\n\\n        int option1= uniquePathsIII(grid,row+1,column,path,totalblock,achivedblock+1);\\n        int option2= uniquePathsIII(grid,row-1,column,path,totalblock,achivedblock+1);\\n        int option3= uniquePathsIII(grid,row,column+1,path,totalblock,achivedblock+1);\\n        int option4= uniquePathsIII(grid,row,column-1,path,totalblock,achivedblock+1);\\n        path[row][column]=false;\\n\\n        int ans=option1+option3+option4+option2;\\n\\n        return ans;\\n    }\\n\\n\\n\\n\\'\\'\\'\\nUpvote if you like\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "**First Try to understand the algo of Code**![image](https://assets.leetcode.com/users/images/a8bdc530-b192-4e98-819a-acba136a730a_1646474710.3266397.jpeg)\\n\\n# Let see the code\\n\\'\\'\\'\\n\\n      public int uniquePathsIII(int[][] grid) {\\n        boolean[][] path = new boolean[grid.length][grid[0].length];\\n\\n        // Total Number of boxes in Matrix\\n        int totalBlock=grid.length * grid[0].length;\\n\\n        int minusblock=0;\\n        int a=0;\\n        int b=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==1){\\n                    // To find the starting position of Robot\\n                    a=i;\\n                    b=j;\\n                }\\n                if(grid[i][j]==-1){\\n                    // Number of Minus Block\\n                    minusblock++;\\n                }\\n\\n            }\\n\\n        }\\n        // -1 to exclude its position\\n        totalBlock=totalBlock-minusblock-1;\\n\\n\\n        return uniquePathsIII(grid,a,b,path,totalBlock,0);\\n\\n\\n    }\\n\\n    public int uniquePathsIII(int[][] grid,int row,int column,boolean[][] path,int totalblock,int achivedblock) {\\n\\n        // Base Case\\n        if(row<0||column<0||row>=grid.length||column>=grid[row].length){\\n            return 0;\\n        }\\n        // if robot come at -1 box and come twice at same box return 0;\\n        if(grid[row][column]==-1||path[row][column]){\\n            return 0;\\n        }\\n        //  ---- If robot reach at destination but ! did not caver all Boxex then return0\\n        if(grid[row][column]==2&&achivedblock!=totalblock){\\n            return 0;\\n\\n        }\\n\\n        // ----If robot reach at destination and caver all Boxex then return 1\\n        if(grid[row][column]==2&&achivedblock==totalblock){\\n\\n\\n            return 1;\\n        }\\n\\n        path[row][column]=true;\\n\\n       // In recursion we passes acheivedblock +1 Because we cover 1 box;\\n\\n        int option1= uniquePathsIII(grid,row+1,column,path,totalblock,achivedblock+1);\\n        int option2= uniquePathsIII(grid,row-1,column,path,totalblock,achivedblock+1);\\n        int option3= uniquePathsIII(grid,row,column+1,path,totalblock,achivedblock+1);\\n        int option4= uniquePathsIII(grid,row,column-1,path,totalblock,achivedblock+1);\\n        path[row][column]=false;\\n\\n        int ans=option1+option3+option4+option2;\\n\\n        return ans;\\n    }\\n\\n\\n\\n\\'\\'\\'\\nUpvote if you like\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1554979,
                "title": "c-dfs-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir={{0,-1},{0,1},{1,0},{-1,0}};\\n    int fx,fy;\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int result=0;\\n        vector<vector<int>> visited(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==2)\\n                {\\n                    fx=i;\\n                    fy=j;\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    result=DFS(grid,visited,i,j,n,m);\\n                    break;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    int DFS(vector<vector<int>>& grid,vector<vector<int>>& visited,int i,int j,int n,int m)\\n    {\\n        if(fx==i && fy==j)\\n         { bool flag=true;\\n          visited[i][j]=1;\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    if(visited[i][j]==0 && grid[i][j]!=-1)\\n                        flag=false;\\n                }\\n            }\\n          visited[i][j]=0;\\n           if(flag)\\n            return 1;\\n           return 0;\\n         }\\n        visited[i][j]=1;\\n        int ans=0;\\n        for(int k=0;k<4;k++)\\n        {\\n            int x=i+dir[k][0];\\n            int y=j+dir[k][1];\\n            if(x<0 || x==n || y<0 || y==m)\\n                continue;\\n            if(visited[x][y]==1)\\n                continue;\\n            if(grid[x][y]==-1)\\n                continue;\\n            ans+=DFS(grid,visited,x,y,n,m);\\n        }\\n        visited[i][j]=0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir={{0,-1},{0,1},{1,0},{-1,0}};\\n    int fx,fy;\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int result=0;\\n        vector<vector<int>> visited(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==2)\\n                {\\n                    fx=i;\\n                    fy=j;\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    result=DFS(grid,visited,i,j,n,m);\\n                    break;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    int DFS(vector<vector<int>>& grid,vector<vector<int>>& visited,int i,int j,int n,int m)\\n    {\\n        if(fx==i && fy==j)\\n         { bool flag=true;\\n          visited[i][j]=1;\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    if(visited[i][j]==0 && grid[i][j]!=-1)\\n                        flag=false;\\n                }\\n            }\\n          visited[i][j]=0;\\n           if(flag)\\n            return 1;\\n           return 0;\\n         }\\n        visited[i][j]=1;\\n        int ans=0;\\n        for(int k=0;k<4;k++)\\n        {\\n            int x=i+dir[k][0];\\n            int y=j+dir[k][1];\\n            if(x<0 || x==n || y<0 || y==m)\\n                continue;\\n            if(visited[x][y]==1)\\n                continue;\\n            if(grid[x][y]==-1)\\n                continue;\\n            ans+=DFS(grid,visited,x,y,n,m);\\n        }\\n        visited[i][j]=0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554970,
                "title": "dfs-with-python-beats-100-in-time",
                "content": "```\\ndef uniquePathsIII(self, grid: List[List[int]]) -> int:\\n    m, n = len(grid), len(grid[0])\\n    start, cell = [0, 0], 0\\n    for i in range(m):\\n        for j in range(n):\\n            if grid[i][j] == 1: start = [i, j]\\n            if grid[i][j] == 0: cell += 1\\n    dir = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n\\n    def move_next(step, x, y):\\n        ans = 0\\n        for i, j in dir:\\n            x_, y_ = x + i, y + j\\n            if n > y_ >= 0 <= x_ < m:\\n                if grid[x_][y_] == 0:\\n                    grid[x_][y_] = -1 # move one step. set it to obstacle, preventing from re-visit this cell\\n                    ans += move_next(step + 1, x_, y_)\\n                    grid[x_][y_] = 0\\n                if grid[x_][y_] == 2 and step == cell:\\n                    ans += 1\\n        return ans\\n    return move_next(0, start[0], start[1])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef uniquePathsIII(self, grid: List[List[int]]) -> int:\\n    m, n = len(grid), len(grid[0])\\n    start, cell = [0, 0], 0\\n    for i in range(m):\\n        for j in range(n):\\n            if grid[i][j] == 1: start = [i, j]\\n            if grid[i][j] == 0: cell += 1\\n    dir = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n\\n    def move_next(step, x, y):\\n        ans = 0\\n        for i, j in dir:\\n            x_, y_ = x + i, y + j\\n            if n > y_ >= 0 <= x_ < m:\\n                if grid[x_][y_] == 0:\\n                    grid[x_][y_] = -1 # move one step. set it to obstacle, preventing from re-visit this cell\\n                    ans += move_next(step + 1, x_, y_)\\n                    grid[x_][y_] = 0\\n                if grid[x_][y_] == 2 and step == cell:\\n                    ans += 1\\n        return ans\\n    return move_next(0, start[0], start[1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1055598,
                "title": "python-backtracking",
                "content": "```\\nclass Solution:\\n    def uniquePathsIII(self, G: List[List[int]]) -> int:\\n        m,n = len(G), len(G[0])\\n        count = m*n\\n        for i in range(m):\\n            for j in range(n):\\n                if G[i][j]==1: start = (i,j)\\n                if G[i][j] == 2: end = (i,j)\\n                if G[i][j]==-1: count -= 1\\n        \\n        self.ans = 0\\n        def backtrack(i,j,path):\\n            if path[-1]==end:\\n                if len(path)==count: self.ans+=1\\n                return\\n            for x,y in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:\\n                if 0<=x<m and 0<=y<n and G[x][y] != -1 and (x,y) not in path:\\n                    backtrack(x,y,path + [(x,y)])\\n        backtrack(start[0],start[1],[start])\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsIII(self, G: List[List[int]]) -> int:\\n        m,n = len(G), len(G[0])\\n        count = m*n\\n        for i in range(m):\\n            for j in range(n):\\n                if G[i][j]==1: start = (i,j)\\n                if G[i][j] == 2: end = (i,j)\\n                if G[i][j]==-1: count -= 1\\n        \\n        self.ans = 0\\n        def backtrack(i,j,path):\\n            if path[-1]==end:\\n                if len(path)==count: self.ans+=1\\n                return\\n            for x,y in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:\\n                if 0<=x<m and 0<=y<n and G[x][y] != -1 and (x,y) not in path:\\n                    backtrack(x,y,path + [(x,y)])\\n        backtrack(start[0],start[1],[start])\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 904897,
                "title": "python-easy-backtracking-dfs-beats-98-time-and-100-memory",
                "content": "```\\n\\nclass Solution:\\n    def uniquePathsIII(self, grid) -> int:\\n\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        non_obs = 0\\n\\n        for i, line in enumerate(grid):\\n            for j, cell in enumerate(line):\\n                if cell == 1:\\n\\t\\t\\t\\t    grid[st_row][st_col] = 0\\n                    st_row, st_col = i, j\\n                    non_obs += 1\\n                elif cell == 0:\\n                    non_obs += 1\\n        \\n        def count_paths(row, col, crossed):\\n\\n            if row < 0 or row >= rows or col < 0 or col >= cols:\\n                return 0\\n\\n            if grid[row][col] == 2 and crossed == non_obs:\\n                return 1\\n\\n            if grid[row][col] != 0:\\n                return 0\\n\\n            grid[row][col] = -1\\n            cnt = sum([count_paths(row+1, col, crossed + 1),\\n                       count_paths(row-1, col, crossed + 1),\\n                       count_paths(row, col+1, crossed + 1),\\n                       count_paths(row, col-1, crossed + 1)])\\n            grid[row][col] = 0\\n            return cnt\\n\\n        return count_paths(st_row, st_col, 0)\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\n\\nclass Solution:\\n    def uniquePathsIII(self, grid) -> int:\\n\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        non_obs = 0\\n\\n        for i, line in enumerate(grid):\\n            for j, cell in enumerate(line):\\n                if cell == 1:\\n\\t\\t\\t\\t    grid[st_row][st_col] = 0\\n                    st_row, st_col = i, j\\n                    non_obs += 1\\n                elif cell == 0:\\n                    non_obs += 1\\n        \\n        def count_paths(row, col, crossed):\\n\\n            if row < 0 or row >= rows or col < 0 or col >= cols:\\n                return 0\\n\\n            if grid[row][col] == 2 and crossed == non_obs:\\n                return 1\\n\\n            if grid[row][col] != 0:\\n                return 0\\n\\n            grid[row][col] = -1\\n            cnt = sum([count_paths(row+1, col, crossed + 1),\\n                       count_paths(row-1, col, crossed + 1),\\n                       count_paths(row, col+1, crossed + 1),\\n                       count_paths(row, col-1, crossed + 1)])\\n            grid[row][col] = 0\\n            return cnt\\n\\n        return count_paths(st_row, st_col, 0)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856245,
                "title": "python-clean-99-6-no-boundary-checks",
                "content": "I like to avoid checking boundary conditions, hence the solution below:\\n```\\ndef uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\trows, cols = len(grid), len(grid[0])\\n\\tdirections = [(1, 0), (0, 1), (-1, 0), (0, -1)]\\n\\tstart_cell, end_cell = None, None\\n\\tempty_cells = {} # the set of neighbors\\' positions for each cell\\n\\n\\t# collect empty cells\\n\\tfor i in range(rows):\\n\\t\\tfor j in range(cols):\\n\\t\\t\\tif grid[i][j] in [0, 1]:\\n\\t\\t\\t\\tempty_cells[(i, j)] = set()\\n\\t\\t\\t\\tif grid[i][j] == 1: start_cell = (i, j)\\n\\t\\t\\telif grid[i][j] == 2: end_cell = (i, j)\\n\\n\\t# collect their neighbors\\n\\tfor x, y in empty_cells:\\n\\t\\tfor xch, ych in directions:\\n\\t\\t\\tneighbor = (x + xch, y + ych)\\n\\t\\t\\tif neighbor in empty_cells: empty_cells[(x, y)].add(neighbor)\\n\\n\\tnext_to_finish = set((end_cell[0] + xch, end_cell[1] + ych) for xch, ych in directions)\\n\\tvisited=set([start_cell])\\n\\tdef count_routes(cell=start_cell):\\n\\t\\tleft_to_visit = len(empty_cells) - len(visited)\\n\\t\\tif not left_to_visit: return int(cell in next_to_finish)\\n\\t\\troutes_to_end = 0\\n\\t\\tfor neighbor in (empty_cells[cell] - visited):\\n\\t\\t\\tvisited.add(neighbor)\\n\\t\\t\\troutes_to_end += count_routes(neighbor)\\n\\t\\t\\tvisited.remove(neighbor)\\n\\t\\treturn routes_to_end\\n\\n\\treturn count_routes()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\ndef uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\trows, cols = len(grid), len(grid[0])\\n\\tdirections = [(1, 0), (0, 1), (-1, 0), (0, -1)]\\n\\tstart_cell, end_cell = None, None\\n\\tempty_cells = {} # the set of neighbors\\' positions for each cell\\n\\n\\t# collect empty cells\\n\\tfor i in range(rows):\\n\\t\\tfor j in range(cols):\\n\\t\\t\\tif grid[i][j] in [0, 1]:\\n\\t\\t\\t\\tempty_cells[(i, j)] = set()\\n\\t\\t\\t\\tif grid[i][j] == 1: start_cell = (i, j)\\n\\t\\t\\telif grid[i][j] == 2: end_cell = (i, j)\\n\\n\\t# collect their neighbors\\n\\tfor x, y in empty_cells:\\n\\t\\tfor xch, ych in directions:\\n\\t\\t\\tneighbor = (x + xch, y + ych)\\n\\t\\t\\tif neighbor in empty_cells: empty_cells[(x, y)].add(neighbor)\\n\\n\\tnext_to_finish = set((end_cell[0] + xch, end_cell[1] + ych) for xch, ych in directions)\\n\\tvisited=set([start_cell])\\n\\tdef count_routes(cell=start_cell):\\n\\t\\tleft_to_visit = len(empty_cells) - len(visited)\\n\\t\\tif not left_to_visit: return int(cell in next_to_finish)\\n\\t\\troutes_to_end = 0\\n\\t\\tfor neighbor in (empty_cells[cell] - visited):\\n\\t\\t\\tvisited.add(neighbor)\\n\\t\\t\\troutes_to_end += count_routes(neighbor)\\n\\t\\t\\tvisited.remove(neighbor)\\n\\t\\treturn routes_to_end\\n\\n\\treturn count_routes()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 753062,
                "title": "c-dfs-easy-explain-and-with-well-commented-100-faster",
                "content": "Once again this problem just the combination of dfs and backtracking so...\\nlet\\'s jump to the algo..\\nWe are allowed to go for any i,j\\n1. i+1,j\\n2. i-1 ,j\\n3. i,j+1\\n4. i,j-1\\nif and only if target grid has 0..\\nif any how we reach the end square i.e. grid[i][j]==2 then check weather all empty square visited or not if any not visited then this is not a valid path...\\n```\\nclass Solution {\\nvector<vector<int>> table;\\nint n,m;\\ninline bool isValidPath(){\\n\\tfor(int i=0 ; i<n ; i++){\\n\\t\\tfor(int j=0 ; j<m ; j++)\\n\\t\\t\\tif(table[i][j]==0) return false;\\n\\t}\\n\\treturn true;\\n}\\ninline bool isValidDir(int row , int col){\\n\\treturn (row<n && row>=0 && col<m && col>=0 && (table[row][col]==0 || table[row][col]==2));\\n}\\nint dfs(int row , int col){\\n//if we are at end square just check weather all empy square is visited or not\\n//if all visited then the path by which we reached here is a valid path else not valid path\\n\\tif(table[row][col]==2) return isValidPath();\\n\\ttable[row][col]=-1;//make it blocked \\n\\tint ans=0;\\n\\t//explore all the possible direction\\n\\tif(isValidDir(row+1,col)){\\n\\t\\tans+=dfs(row+1,col);\\n\\t}\\n\\tif(isValidDir(row-1,col)){\\n\\t\\tans+=dfs(row-1 , col);\\n\\t}\\n\\tif(isValidDir(row , col+1)){\\n\\t\\tans+=dfs(row , col+1);\\n\\t}\\n\\tif(isValidDir(row , col-1)){\\n\\t\\tans+=dfs(row , col-1);\\n\\t}\\n\\t//while backtracking we are going to reset because the path which has given valid or invalide\\n\\t//path then partial path can be use for other\\'s too\\n\\ttable[row][col]=0;\\n\\treturn ans;\\n}\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n    n=grid.size();\\n    m=grid[0].size();\\n    int row=-1,col=-1;\\n    table=grid;\\n\\t//find the position of start square\\n    for(int i=0 ; i<n &&row==-1 ; i++){\\n    \\tfor(int j=0 ; j<m && row==-1;j++){\\n    \\t\\tif(grid[i][j]==1) row=i,col=j;\\n    \\t}\\n    }\\n    int ans=dfs(row , col);\\n    return ans; \\n    }\\n};\\n```\\n## We can optimise it bit more\\nfor a valid path we just need to check weather we have any empty cell which is not visited yet so we can do in constant time instead of O(N^2)..\\nlook bellow implimentation\\n```\\nclass Solution {\\nvector<vector<int>> table;\\nint n,m;\\ninline bool isValidDir(int row , int col){\\n\\treturn (row<n && row>=0 && col<m && col>=0 && (table[row][col]==0 || table[row][col]==2));\\n}\\nint dfs(int row , int col,int nEmptyCell){\\n\\tif(table[row][col]==2) return (nEmptyCell<0);//(nEmptyCell<0) because we have incuded table[row][col] also as a empty square \\n\\tint x=table[row][col];\\n\\ttable[row][col]=-1;\\n\\tint ans=0;\\n\\tif(isValidDir(row+1,col)){\\n\\t\\tans+=dfs(row+1,col,nEmptyCell-1);\\n\\t}\\n\\tif(isValidDir(row-1,col)){\\n\\t\\tans+=dfs(row-1 , col,nEmptyCell-1);\\n\\t}\\n\\tif(isValidDir(row , col+1)){\\n\\t\\tans+=dfs(row , col+1,nEmptyCell-1);\\n\\t}\\n\\tif(isValidDir(row , col-1)){\\n\\t\\tans+=dfs(row , col-1,nEmptyCell-1);\\n\\t}\\n\\ttable[row][col]=x;\\n\\treturn ans;\\n}\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n    n=grid.size();\\n    m=grid[0].size();\\n    int row=-1,col=-1;\\n    table=grid;\\n      int nEmptyCell=0;\\n    for(int i=0 ; i<n  ; i++){\\n    \\tfor(int j=0 ; j<m ;j++){\\n    \\t\\tif(grid[i][j]==1) row=i,col=j;\\n        if(grid[i][j]==0) nEmptyCell++;\\n    \\t}\\n    }\\n    int ans=dfs(row , col,nEmptyCell);\\n    return ans; \\n    }\\n};\\n```\\n### Time complexity analysis\\nfor any i,j we have total 3 way to go because from one way we reached current i,j\\nso total 3 way... so for n it would be 3^n\\ntime complexity: O(3^N)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nvector<vector<int>> table;\\nint n,m;\\ninline bool isValidPath(){\\n\\tfor(int i=0 ; i<n ; i++){\\n\\t\\tfor(int j=0 ; j<m ; j++)\\n\\t\\t\\tif(table[i][j]==0) return false;\\n\\t}\\n\\treturn true;\\n}\\ninline bool isValidDir(int row , int col){\\n\\treturn (row<n && row>=0 && col<m && col>=0 && (table[row][col]==0 || table[row][col]==2));\\n}\\nint dfs(int row , int col){\\n//if we are at end square just check weather all empy square is visited or not\\n//if all visited then the path by which we reached here is a valid path else not valid path\\n\\tif(table[row][col]==2) return isValidPath();\\n\\ttable[row][col]=-1;//make it blocked \\n\\tint ans=0;\\n\\t//explore all the possible direction\\n\\tif(isValidDir(row+1,col)){\\n\\t\\tans+=dfs(row+1,col);\\n\\t}\\n\\tif(isValidDir(row-1,col)){\\n\\t\\tans+=dfs(row-1 , col);\\n\\t}\\n\\tif(isValidDir(row , col+1)){\\n\\t\\tans+=dfs(row , col+1);\\n\\t}\\n\\tif(isValidDir(row , col-1)){\\n\\t\\tans+=dfs(row , col-1);\\n\\t}\\n\\t//while backtracking we are going to reset because the path which has given valid or invalide\\n\\t//path then partial path can be use for other\\'s too\\n\\ttable[row][col]=0;\\n\\treturn ans;\\n}\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n    n=grid.size();\\n    m=grid[0].size();\\n    int row=-1,col=-1;\\n    table=grid;\\n\\t//find the position of start square\\n    for(int i=0 ; i<n &&row==-1 ; i++){\\n    \\tfor(int j=0 ; j<m && row==-1;j++){\\n    \\t\\tif(grid[i][j]==1) row=i,col=j;\\n    \\t}\\n    }\\n    int ans=dfs(row , col);\\n    return ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\nvector<vector<int>> table;\\nint n,m;\\ninline bool isValidDir(int row , int col){\\n\\treturn (row<n && row>=0 && col<m && col>=0 && (table[row][col]==0 || table[row][col]==2));\\n}\\nint dfs(int row , int col,int nEmptyCell){\\n\\tif(table[row][col]==2) return (nEmptyCell<0);//(nEmptyCell<0) because we have incuded table[row][col] also as a empty square \\n\\tint x=table[row][col];\\n\\ttable[row][col]=-1;\\n\\tint ans=0;\\n\\tif(isValidDir(row+1,col)){\\n\\t\\tans+=dfs(row+1,col,nEmptyCell-1);\\n\\t}\\n\\tif(isValidDir(row-1,col)){\\n\\t\\tans+=dfs(row-1 , col,nEmptyCell-1);\\n\\t}\\n\\tif(isValidDir(row , col+1)){\\n\\t\\tans+=dfs(row , col+1,nEmptyCell-1);\\n\\t}\\n\\tif(isValidDir(row , col-1)){\\n\\t\\tans+=dfs(row , col-1,nEmptyCell-1);\\n\\t}\\n\\ttable[row][col]=x;\\n\\treturn ans;\\n}\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n    n=grid.size();\\n    m=grid[0].size();\\n    int row=-1,col=-1;\\n    table=grid;\\n      int nEmptyCell=0;\\n    for(int i=0 ; i<n  ; i++){\\n    \\tfor(int j=0 ; j<m ;j++){\\n    \\t\\tif(grid[i][j]==1) row=i,col=j;\\n        if(grid[i][j]==0) nEmptyCell++;\\n    \\t}\\n    }\\n    int ans=dfs(row , col,nEmptyCell);\\n    return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899681,
                "title": "recursion-backtracking-beats-100-detailed-explanation-clean-code",
                "content": "# Complexity\\n- Time complexity: Exponential\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m * n)\\nBecause we are using extra used 2D array of size m * n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n**CLEAN CODE :**\\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int row = 0;\\n        int col = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    row = i;\\n                    col = j;\\n                    break;\\n                }\\n            }\\n        }\\n        boolean[][] used = new boolean[grid.length][grid[0].length];\\n        return count(grid, used, row, col);\\n    }\\n\\n    int count(int[][] grid, boolean[][] used, int row, int col) {\\n\\n        used[row][col] = true;\\n        if(grid[row][col] == 2) {\\n            if(isValid(used, grid) && grid[row][col] != -1) {\\n                used[row][col] = false;\\n                return 1;\\n            }\\n            used[row][col] = false;\\n            return 0;\\n        }\\n        if(grid[row][col] == -1) {\\n            used[row][col] = false;\\n            return 0;\\n        }\\n\\n        int paths = 0;\\n\\n        //DOWN\\n        if(row < grid.length - 1 && !used[row + 1][col]) {\\n            paths += count(grid, used, row + 1, col);\\n        }\\n        //RIGHT\\n        if(col < grid[0].length - 1 && !used[row][col + 1]) {\\n            paths += count(grid, used, row, col + 1);\\n        }\\n        //UP\\n        if(row > 0 && !used[row - 1][col]) {\\n            paths += count(grid, used, row - 1, col);\\n        }\\n        //LEFT\\n        if(col > 0 && !used[row][col - 1]) {\\n            paths += count(grid, used, row, col - 1);\\n        }\\n\\n        used[row][col] = false;\\n        return paths;\\n    }\\n\\n    boolean isValid(boolean[][] used, int[][] grid) {\\n\\n        for(int i = 0; i < used.length; i++) {\\n            for(int j = 0; j < used[0].length; j++) {\\n                if(grid[i][j] == 0) {\\n                    if(!used[i][j]) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n**CODE WITH EXPLANATION :**\\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int row = 0;\\n        int col = 0;\\n\\n        //finding the starting square\\'s row and column\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    row = i;\\n                    col = j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        //boolean array named (used) is used to store the squares which have already been used\\n        //till now in a particular path\\n\\n        boolean[][] used = new boolean[grid.length][grid[0].length];\\n\\n        return count(grid, used, row, col);\\n    }\\n\\n    int count(int[][] grid, boolean[][] used, int row, int col) {\\n\\n        used[row][col] = true;\\n\\n        //we have arrived at the ending square. Now, it might be possible, that the path we \\n        //followed till here from starting position, does not contain all the 0 squares\\n        //therefore to decide this we call the isValid function\\n        //Also, it might happen that there\\'s an obstacle on the same ending square, in this\\n        //case we won\\'t find any path because the destination square is itself an obstacle\\n        //so we return 0. and to check this only we have put another \\n        //condition grid[row][col] != -1\\n\\n        if(grid[row][col] == 2) {\\n            if(isValid(used, grid) && grid[row][col] != -1) {\\n                used[row][col] = false;\\n                return 1;\\n            }\\n            used[row][col] = false;\\n            return 0;\\n        }\\n\\n        //if we have arrived at an obstacle square, then return 0, because we can\\'t obtain \\n        //any further paths including this square, because this is an obstacle\\n        //while returning, unmark this square as used, i.e. mark it as unused\\n\\n        if(grid[row][col] == -1) {\\n            used[row][col] = false;\\n            return 0;\\n        }\\n\\n        int paths = 0;\\n\\n        //DOWN\\n        if(row < grid.length - 1 && !used[row + 1][col]) {\\n            paths += count(grid, used, row + 1, col);\\n        }\\n        //RIGHT\\n        if(col < grid[0].length - 1 && !used[row][col + 1]) {\\n            paths += count(grid, used, row, col + 1);\\n        }\\n        //UP\\n        if(row > 0 && !used[row - 1][col]) {\\n            paths += count(grid, used, row - 1, col);\\n        }\\n        //LEFT\\n        if(col > 0 && !used[row][col - 1]) {\\n            paths += count(grid, used, row, col - 1);\\n        }\\n\\n        //backtrack, mark the square as unused now!\\n        used[row][col] = false;\\n\\n        return paths;\\n    }\\n\\n    //to check whether the path which we have travelled from starting square to ending square\\n    //contains all the 0 squares in it or not. If the path does not contain all the 0 sqaures\\n    //then isValid return false, and we do not count this path and hence return 0 in the count\\n    //function.\\n    //if the path contains all the 0 squares, then isValid return true, and hence \\n    //we count this path and hence in count function we return 1, as we got one path\\n    //which contains all the 0 squares.\\n\\n    boolean isValid(boolean[][] used, int[][] grid) {\\n\\n        for(int i = 0; i < used.length; i++) {\\n            for(int j = 0; j < used[0].length; j++) {\\n                if(grid[i][j] == 0) {\\n                    if(!used[i][j]) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n**NO NEED OF ISVALID FUNCTION :**\\n\\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int row = 0;\\n        int col = 0;\\n        int countZeros = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    row = i;\\n                    col = j;\\n                }\\n                if(grid[i][j] == 0) {\\n                    countZeros++;\\n                }\\n            }\\n        }\\n        boolean[][] used = new boolean[grid.length][grid[0].length];\\n        return count(grid, used, row, col, countZeros + 1);\\n    }\\n\\n    int count(int[][] grid, boolean[][] used, int row, int col, int countZeros) {\\n\\n        used[row][col] = true;\\n        if(grid[row][col] == 2) {\\n            if(countZeros == 0 && grid[row][col] != -1) {\\n                used[row][col] = false;\\n                return 1;\\n            }\\n            used[row][col] = false;\\n            return 0;\\n        }\\n        if(grid[row][col] == -1) {\\n            used[row][col] = false;\\n            return 0;\\n        }\\n\\n        int paths = 0;\\n\\n        //DOWN\\n        if(row < grid.length - 1 && !used[row + 1][col]) {\\n            paths += count(grid, used, row + 1, col, countZeros - 1);\\n        }\\n        //RIGHT\\n        if(col < grid[0].length - 1 && !used[row][col + 1]) {\\n            paths += count(grid, used, row, col + 1, countZeros - 1);\\n        }\\n        //UP\\n        if(row > 0 && !used[row - 1][col]) {\\n            paths += count(grid, used, row - 1, col, countZeros - 1);\\n        }\\n        //LEFT\\n        if(col > 0 && !used[row][col - 1]) {\\n            paths += count(grid, used, row, col - 1, countZeros - 1);\\n        }\\n\\n        used[row][col] = false;\\n        return paths;\\n    }\\n}\\n```\\n![cat.jpeg](https://assets.leetcode.com/users/images/dbaf10c4-ebb1-47e6-abb2-32d99d5c3a38_1691850467.298222.jpeg)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int row = 0;\\n        int col = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    row = i;\\n                    col = j;\\n                    break;\\n                }\\n            }\\n        }\\n        boolean[][] used = new boolean[grid.length][grid[0].length];\\n        return count(grid, used, row, col);\\n    }\\n\\n    int count(int[][] grid, boolean[][] used, int row, int col) {\\n\\n        used[row][col] = true;\\n        if(grid[row][col] == 2) {\\n            if(isValid(used, grid) && grid[row][col] != -1) {\\n                used[row][col] = false;\\n                return 1;\\n            }\\n            used[row][col] = false;\\n            return 0;\\n        }\\n        if(grid[row][col] == -1) {\\n            used[row][col] = false;\\n            return 0;\\n        }\\n\\n        int paths = 0;\\n\\n        //DOWN\\n        if(row < grid.length - 1 && !used[row + 1][col]) {\\n            paths += count(grid, used, row + 1, col);\\n        }\\n        //RIGHT\\n        if(col < grid[0].length - 1 && !used[row][col + 1]) {\\n            paths += count(grid, used, row, col + 1);\\n        }\\n        //UP\\n        if(row > 0 && !used[row - 1][col]) {\\n            paths += count(grid, used, row - 1, col);\\n        }\\n        //LEFT\\n        if(col > 0 && !used[row][col - 1]) {\\n            paths += count(grid, used, row, col - 1);\\n        }\\n\\n        used[row][col] = false;\\n        return paths;\\n    }\\n\\n    boolean isValid(boolean[][] used, int[][] grid) {\\n\\n        for(int i = 0; i < used.length; i++) {\\n            for(int j = 0; j < used[0].length; j++) {\\n                if(grid[i][j] == 0) {\\n                    if(!used[i][j]) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int row = 0;\\n        int col = 0;\\n\\n        //finding the starting square\\'s row and column\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    row = i;\\n                    col = j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        //boolean array named (used) is used to store the squares which have already been used\\n        //till now in a particular path\\n\\n        boolean[][] used = new boolean[grid.length][grid[0].length];\\n\\n        return count(grid, used, row, col);\\n    }\\n\\n    int count(int[][] grid, boolean[][] used, int row, int col) {\\n\\n        used[row][col] = true;\\n\\n        //we have arrived at the ending square. Now, it might be possible, that the path we \\n        //followed till here from starting position, does not contain all the 0 squares\\n        //therefore to decide this we call the isValid function\\n        //Also, it might happen that there\\'s an obstacle on the same ending square, in this\\n        //case we won\\'t find any path because the destination square is itself an obstacle\\n        //so we return 0. and to check this only we have put another \\n        //condition grid[row][col] != -1\\n\\n        if(grid[row][col] == 2) {\\n            if(isValid(used, grid) && grid[row][col] != -1) {\\n                used[row][col] = false;\\n                return 1;\\n            }\\n            used[row][col] = false;\\n            return 0;\\n        }\\n\\n        //if we have arrived at an obstacle square, then return 0, because we can\\'t obtain \\n        //any further paths including this square, because this is an obstacle\\n        //while returning, unmark this square as used, i.e. mark it as unused\\n\\n        if(grid[row][col] == -1) {\\n            used[row][col] = false;\\n            return 0;\\n        }\\n\\n        int paths = 0;\\n\\n        //DOWN\\n        if(row < grid.length - 1 && !used[row + 1][col]) {\\n            paths += count(grid, used, row + 1, col);\\n        }\\n        //RIGHT\\n        if(col < grid[0].length - 1 && !used[row][col + 1]) {\\n            paths += count(grid, used, row, col + 1);\\n        }\\n        //UP\\n        if(row > 0 && !used[row - 1][col]) {\\n            paths += count(grid, used, row - 1, col);\\n        }\\n        //LEFT\\n        if(col > 0 && !used[row][col - 1]) {\\n            paths += count(grid, used, row, col - 1);\\n        }\\n\\n        //backtrack, mark the square as unused now!\\n        used[row][col] = false;\\n\\n        return paths;\\n    }\\n\\n    //to check whether the path which we have travelled from starting square to ending square\\n    //contains all the 0 squares in it or not. If the path does not contain all the 0 sqaures\\n    //then isValid return false, and we do not count this path and hence return 0 in the count\\n    //function.\\n    //if the path contains all the 0 squares, then isValid return true, and hence \\n    //we count this path and hence in count function we return 1, as we got one path\\n    //which contains all the 0 squares.\\n\\n    boolean isValid(boolean[][] used, int[][] grid) {\\n\\n        for(int i = 0; i < used.length; i++) {\\n            for(int j = 0; j < used[0].length; j++) {\\n                if(grid[i][j] == 0) {\\n                    if(!used[i][j]) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int row = 0;\\n        int col = 0;\\n        int countZeros = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    row = i;\\n                    col = j;\\n                }\\n                if(grid[i][j] == 0) {\\n                    countZeros++;\\n                }\\n            }\\n        }\\n        boolean[][] used = new boolean[grid.length][grid[0].length];\\n        return count(grid, used, row, col, countZeros + 1);\\n    }\\n\\n    int count(int[][] grid, boolean[][] used, int row, int col, int countZeros) {\\n\\n        used[row][col] = true;\\n        if(grid[row][col] == 2) {\\n            if(countZeros == 0 && grid[row][col] != -1) {\\n                used[row][col] = false;\\n                return 1;\\n            }\\n            used[row][col] = false;\\n            return 0;\\n        }\\n        if(grid[row][col] == -1) {\\n            used[row][col] = false;\\n            return 0;\\n        }\\n\\n        int paths = 0;\\n\\n        //DOWN\\n        if(row < grid.length - 1 && !used[row + 1][col]) {\\n            paths += count(grid, used, row + 1, col, countZeros - 1);\\n        }\\n        //RIGHT\\n        if(col < grid[0].length - 1 && !used[row][col + 1]) {\\n            paths += count(grid, used, row, col + 1, countZeros - 1);\\n        }\\n        //UP\\n        if(row > 0 && !used[row - 1][col]) {\\n            paths += count(grid, used, row - 1, col, countZeros - 1);\\n        }\\n        //LEFT\\n        if(col > 0 && !used[row][col - 1]) {\\n            paths += count(grid, used, row, col - 1, countZeros - 1);\\n        }\\n\\n        used[row][col] = false;\\n        return paths;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975638,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int empty=1;\\n    void path(vector<vector<int>>& grid, int i, int j, int c)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==-1)\\n        return;\\n        if(grid[i][j]==2)\\n        {\\n            if(c==empty)\\n            ans++;\\n            return;\\n        }\\n        grid[i][j]=-1;\\n        path(grid, i+1, j, c+1);\\n        path(grid, i, j+1, c+1);\\n        path(grid, i-1, j, c+1);\\n        path(grid, i, j-1, c+1);\\n        grid[i][j]=0;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int r, c;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==0)\\n                empty++;\\n                if(grid[i][j]==1)\\n                r=i, c=j;\\n            }\\n        }\\n        path(grid, r, c, 0);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int empty=1;\\n    void path(vector<vector<int>>& grid, int i, int j, int c)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==-1)\\n        return;\\n        if(grid[i][j]==2)\\n        {\\n            if(c==empty)\\n            ans++;\\n            return;\\n        }\\n        grid[i][j]=-1;\\n        path(grid, i+1, j, c+1);\\n        path(grid, i, j+1, c+1);\\n        path(grid, i-1, j, c+1);\\n        path(grid, i, j-1, c+1);\\n        grid[i][j]=0;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int r, c;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==0)\\n                empty++;\\n                if(grid[i][j]==1)\\n                r=i, c=j;\\n            }\\n        }\\n        path(grid, r, c, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974414,
                "title": "c-backtracking-dfs-100-faster-easy-understanding-commented-code",
                "content": "**Approach:**\\n1. First of all , we need to identify start and end cell coordinates and number of steps to move to end cell.\\n \\t*No. of steps to move to end cell = No. of empty squares + 1*\\n1. Now start dfs from the start cell with visited array to keep track of visited cells\\ni) If we reached to end cell and we have visited all empty cells exactly once , then return 1 else return 0\\nii) Mark the current cell as *visited*\\niii) Move to all four directions which are feasible to go and count the number of feasible from the current cell\\niv) Mark the current cell as *unvisited* to backtrack and return the *res*\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    // function to check if the cell coordinates are valid and is feasible to visit that cell\\n    bool isSafe(vector<vector<int>>& grid,int i,int j,vector<bool>&vis){\\n        return i<grid.size() && i>=0 && j>=0 && j<grid[0].size() && !vis[i*grid[0].size()+j] && grid[i][j]!=-1;\\n    }\\n    \\n\\t// helper function to dfs and backtrack\\n    int helper(vector<vector<int>>& grid,pair<int,int> curr,pair<int,int> end,int steps,vector<bool> &vis,int n){\\n        // if we reached the end cell\\n\\t\\tif(curr==end){\\n\\t\\t\\t// if steps is 0, it means we visited every non-obstacle cell so will 1 from here i.e. 1 way else return 0\\n            return steps==0?1:0;\\n        }\\n\\t\\t// destructuring the current cell coordinates\\n        auto [i,j]=curr;\\n\\t\\t\\n\\t\\t// mark the current cell as visited\\n        vis[i*n+j]=true;\\n        \\n        int res = 0;\\n\\t\\t// direction array for four directions {0,-1},{-1,0},{0,1},{1,0}\\n        int dir[5]={0,-1,0,1,0};\\n        \\n        for(int k=0;k<4;k++){\\n            int newX = i + dir[k];\\n            int newY = j + dir[k+1];\\n\\t\\t\\t\\n\\t\\t\\t// if the moving to the cell with coordinates (newX,newY) is feasible then move to that cell\\n            if(isSafe(grid,newX,newY,vis)){\\n                res+=helper(grid,{newX,newY},end,steps-1,vis,n);\\n            }\\n        }\\n\\t\\t\\n\\t\\t// marking cell after doing dfs to backtrack\\n        vis[i*n+j]=false;\\n\\t\\t\\n\\t\\t// returning number of ways\\n        return res;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m = grid.size(); // # of rows\\n        int n = grid[0].size(); // # of columns\\n        int steps = 1; // steps need to be covered to reach end\\n        pair<int,int> start,end; // to store coordinates of start and end cell\\n\\t\\t\\n\\t\\t// counting steps needed and getting start and end cell coordinates\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0) steps++;\\n                else if(grid[i][j]==1) start={i,j};\\n                else if(grid[i][j]==2) end={i,j};\\n            }\\n        }\\n\\t\\t// 1-d array for keep track of visited cells\\n        vector<bool> vis(n*m,false);\\n        return helper(grid,start,end,steps,vis,n);\\n    }\\n};\\n```\\n\\n**Time Complexity** : O(3^max(m,n))\\n**Space Complexity**: O(m\\\\*n) as visited array occupies space m\\\\*n , *which can be further optimised to O(max(m,n)) i.e. recursion call stack only if we modify the grid cells to keep track of visited cells*\\n\\t\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // function to check if the cell coordinates are valid and is feasible to visit that cell\\n    bool isSafe(vector<vector<int>>& grid,int i,int j,vector<bool>&vis){\\n        return i<grid.size() && i>=0 && j>=0 && j<grid[0].size() && !vis[i*grid[0].size()+j] && grid[i][j]!=-1;\\n    }\\n    \\n\\t// helper function to dfs and backtrack\\n    int helper(vector<vector<int>>& grid,pair<int,int> curr,pair<int,int> end,int steps,vector<bool> &vis,int n){\\n        // if we reached the end cell\\n\\t\\tif(curr==end){\\n\\t\\t\\t// if steps is 0, it means we visited every non-obstacle cell so will 1 from here i.e. 1 way else return 0\\n            return steps==0?1:0;\\n        }\\n\\t\\t// destructuring the current cell coordinates\\n        auto [i,j]=curr;\\n\\t\\t\\n\\t\\t// mark the current cell as visited\\n        vis[i*n+j]=true;\\n        \\n        int res = 0;\\n\\t\\t// direction array for four directions {0,-1},{-1,0},{0,1},{1,0}\\n        int dir[5]={0,-1,0,1,0};\\n        \\n        for(int k=0;k<4;k++){\\n            int newX = i + dir[k];\\n            int newY = j + dir[k+1];\\n\\t\\t\\t\\n\\t\\t\\t// if the moving to the cell with coordinates (newX,newY) is feasible then move to that cell\\n            if(isSafe(grid,newX,newY,vis)){\\n                res+=helper(grid,{newX,newY},end,steps-1,vis,n);\\n            }\\n        }\\n\\t\\t\\n\\t\\t// marking cell after doing dfs to backtrack\\n        vis[i*n+j]=false;\\n\\t\\t\\n\\t\\t// returning number of ways\\n        return res;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m = grid.size(); // # of rows\\n        int n = grid[0].size(); // # of columns\\n        int steps = 1; // steps need to be covered to reach end\\n        pair<int,int> start,end; // to store coordinates of start and end cell\\n\\t\\t\\n\\t\\t// counting steps needed and getting start and end cell coordinates\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0) steps++;\\n                else if(grid[i][j]==1) start={i,j};\\n                else if(grid[i][j]==2) end={i,j};\\n            }\\n        }\\n\\t\\t// 1-d array for keep track of visited cells\\n        vector<bool> vis(n*m,false);\\n        return helper(grid,start,end,steps,vis,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974263,
                "title": "3d-dp-recursion-memoaization-easy-code-commented-with-explaination",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis initially looks like a hard problem , but trust me it is not.\\nThanks to striver on YouTube for making DP on grids and 3D DP so easy to solve and understand.\\n\\nBasically find the starting points of x and y using iteration and stop when grid[i][j]==1, because thats our starting point for the recursion, then call the recursive function, add the pretty simple base cases(one is out of bounds ,  and other one is if we reach the end) , then do the recursive calls for all 4 traversable directions.\\n*Note: dont forget to backtrack(yes i did forget initially :p)\\n\\nThen just return the sum of all possibilities from the directions!\\nYes, its that simple.\\nAdditionally I have memoaized the solution by creating a DP array, you can tabulate your answer too but no one would expect tabulation or space optimization at on 3D DP(although both are simple to do)\\n\\n\\nInteger c basically here kinda checks how many nodes we have visited till now , so if the count of c is equal to empty then we can say that we have reached our destination(ofc destination node needs to be checked for being == 2 at first).\\nInstead of c one could have had used an additional function for checking if visited or not! Thats totally Upto you :D\\n\\n# PLEASE UPVOTE IF FOUND HELPFUL , IT KEEPS ME MOTIVATED TO HELP THIS COMMUNITY <3\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lol(int i,int j,int c,int& empty,vector<vector<int>>& grid,vector<vector<vector<int>>>& dp){\\n        //base case1\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==-1) return 0;        \\n        //base case2\\n        if(grid[i][j]==2){\\n            //sees if visited\\n            if(c==empty)\\n                return 1;\\n            return 0;\\n        }\\n        if(dp[i][j][c]!=-1)return dp[i][j][c];\\n        \\n        grid[i][j]=-1;\\n        //running down all 4 possibilities \\n        int up=lol(i-1,j,c+1,empty,grid,dp);\\n        int down=lol(i+1,j,c+1,empty,grid,dp);\\n        int right=lol(i,j+1,c+1,empty,grid,dp);\\n        int left=lol(i,j-1,c+1,empty,grid,dp);\\n        //backtracking \\n        grid[i][j]=0;\\n        //store answer in dp and return\\n        return dp[i][j][c+1]=(up+down+right+left);        \\n        \\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int empty=1,x=0,y=0;\\n        //empty is cells with 0\\n        //x and y are coordinates of starting point marked with 1 in grid\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    x=i;\\n                    y=j;                    \\n                }\\n                if(grid[i][j]==0)\\n                    empty++;\\n            }\\n        }\\n        vector<vector<vector<int>>> dp(grid.size(), vector<vector<int>> (grid[0].size(),vector<int> (empty+1,-1)));\\n        return lol(x,y,0,empty,grid,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lol(int i,int j,int c,int& empty,vector<vector<int>>& grid,vector<vector<vector<int>>>& dp){\\n        //base case1\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==-1) return 0;        \\n        //base case2\\n        if(grid[i][j]==2){\\n            //sees if visited\\n            if(c==empty)\\n                return 1;\\n            return 0;\\n        }\\n        if(dp[i][j][c]!=-1)return dp[i][j][c];\\n        \\n        grid[i][j]=-1;\\n        //running down all 4 possibilities \\n        int up=lol(i-1,j,c+1,empty,grid,dp);\\n        int down=lol(i+1,j,c+1,empty,grid,dp);\\n        int right=lol(i,j+1,c+1,empty,grid,dp);\\n        int left=lol(i,j-1,c+1,empty,grid,dp);\\n        //backtracking \\n        grid[i][j]=0;\\n        //store answer in dp and return\\n        return dp[i][j][c+1]=(up+down+right+left);        \\n        \\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int empty=1,x=0,y=0;\\n        //empty is cells with 0\\n        //x and y are coordinates of starting point marked with 1 in grid\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==1){\\n                    x=i;\\n                    y=j;                    \\n                }\\n                if(grid[i][j]==0)\\n                    empty++;\\n            }\\n        }\\n        vector<vector<vector<int>>> dp(grid.size(), vector<vector<int>> (grid[0].size(),vector<int> (empty+1,-1)));\\n        return lol(x,y,0,empty,grid,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973494,
                "title": "100-easy-dfs",
                "content": "# Approach\\nFind start point and count all empty cell including start, use DFS to reach end cell, if cell covers all empty cell count that path. To avoid repeat mark cell visited and unmark.\\n\\n# Code\\n```\\n\\nclass Solution {\\n    int M, N, eCount=1, res=0;\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        M = grid.size(), N=grid[0].size();\\n        int x, y;\\n        for (int i=0; i < M; i++)\\n            for (int j=0; j<N; j++){\\n                if (grid[i][j] ==1) x= i, y=j;\\n                else if (grid[i][j] ==0) eCount++;\\n            }\\n\\n        DFS(grid, x,y,0);\\n        return res;        \\n    }\\n\\n    void DFS(vector<vector<int>>& g, int i, int j,int count){\\n        if ( i < 0 || i >= M ||  j < 0 || j >= N || g[i][j] == -1) return;\\n\\n        if(g[i][j] == 2){\\n            if (count == eCount) res++;\\n            return;\\n        }\\n        g[i][j] = -1;\\n        count++;\\n        DFS(g,i+1,j,count);\\n        DFS(g,i-1,j,count);\\n        DFS(g,i,j+1,count);\\n        DFS(g,i,j-1,count);\\n        g[i][j] = 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\n    int M, N, eCount=1, res=0;\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        M = grid.size(), N=grid[0].size();\\n        int x, y;\\n        for (int i=0; i < M; i++)\\n            for (int j=0; j<N; j++){\\n                if (grid[i][j] ==1) x= i, y=j;\\n                else if (grid[i][j] ==0) eCount++;\\n            }\\n\\n        DFS(grid, x,y,0);\\n        return res;        \\n    }\\n\\n    void DFS(vector<vector<int>>& g, int i, int j,int count){\\n        if ( i < 0 || i >= M ||  j < 0 || j >= N || g[i][j] == -1) return;\\n\\n        if(g[i][j] == 2){\\n            if (count == eCount) res++;\\n            return;\\n        }\\n        g[i][j] = -1;\\n        count++;\\n        DFS(g,i+1,j,count);\\n        DFS(g,i-1,j,count);\\n        DFS(g,i,j+1,count);\\n        DFS(g,i,j-1,count);\\n        g[i][j] = 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664159,
                "title": "easy-c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<int>>&grid, set<pair<int,int>>&vis, int &f, int cu, int r, int c, pair<int,int>&tar ,int &m, int &n, int &ans){\\n        if(r<0 or r==m or c<0 or c==n or grid[r][c]==-1 or vis.count({r,c})) return;\\n        if(r==tar.first and c==tar.second){\\n            if(cu==f) ++ans;\\n            return;\\n        }\\n        vis.insert({r,c});\\n        solve(grid,vis,f,cu+1,r+1,c,tar,m,n,ans);\\n        solve(grid,vis,f,cu+1,r-1,c,tar,m,n,ans);\\n        solve(grid,vis,f,cu+1,r,c+1,tar,m,n,ans);\\n        solve(grid,vis,f,cu+1,r,c-1,tar,m,n,ans);\\n        vis.erase({r,c});\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        pair<int,int> start, tar;\\n        int obs=1, m=grid.size(), n=grid[0].size(), ans=0;\\n        for(int i=0; i<m; ++i)\\n            for(int j=0; j<n; ++j){\\n                if(grid[i][j]==1) start={i,j};\\n                else if(grid[i][j]==2) tar={i,j};\\n                else if(grid[i][j]==0) ++obs;\\n            }\\n        set<pair<int,int>> vis;\\n        solve(grid,vis,obs,0,start.first,start.second,tar,m,n,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<int>>&grid, set<pair<int,int>>&vis, int &f, int cu, int r, int c, pair<int,int>&tar ,int &m, int &n, int &ans){\\n        if(r<0 or r==m or c<0 or c==n or grid[r][c]==-1 or vis.count({r,c})) return;\\n        if(r==tar.first and c==tar.second){\\n            if(cu==f) ++ans;\\n            return;\\n        }\\n        vis.insert({r,c});\\n        solve(grid,vis,f,cu+1,r+1,c,tar,m,n,ans);\\n        solve(grid,vis,f,cu+1,r-1,c,tar,m,n,ans);\\n        solve(grid,vis,f,cu+1,r,c+1,tar,m,n,ans);\\n        solve(grid,vis,f,cu+1,r,c-1,tar,m,n,ans);\\n        vis.erase({r,c});\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        pair<int,int> start, tar;\\n        int obs=1, m=grid.size(), n=grid[0].size(), ans=0;\\n        for(int i=0; i<m; ++i)\\n            for(int j=0; j<n; ++j){\\n                if(grid[i][j]==1) start={i,j};\\n                else if(grid[i][j]==2) tar={i,j};\\n                else if(grid[i][j]==0) ++obs;\\n            }\\n        set<pair<int,int>> vis;\\n        solve(grid,vis,obs,0,start.first,start.second,tar,m,n,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448355,
                "title": "easy-c-solution-with-backtracking-3ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int helper(vector<vector<int>>& grid, int i, int j, int cellsToVisit){\\n        if(i<0 || j<0 || i>=n || j>=m || grid[i][j]==-1 || grid[i][j]==3) \\n            return 0;\\n        if(grid[i][j]==2){\\n            if(cellsToVisit==0)\\n                return 1;\\n            return 0;\\n        } \\n        \\n        int ans = 0;\\n        // mark as visited\\n        grid[i][j] = 3;\\n        ans += helper(grid,i+1,j,cellsToVisit-1);\\n        ans += helper(grid,i,j+1,cellsToVisit-1);\\n        ans += helper(grid,i-1,j,cellsToVisit-1);\\n        ans += helper(grid,i,j-1,cellsToVisit-1);\\n        grid[i][j] = 0;\\n        \\n        return ans;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        int cellsToVisit = 0;\\n        int startx,starty;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    startx = i;\\n                    starty = j;\\n                }\\n                else if(grid[i][j] != -1) \\n                    cellsToVisit++;\\n            }\\n            \\n        return helper(grid, startx, starty, cellsToVisit);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int helper(vector<vector<int>>& grid, int i, int j, int cellsToVisit){\\n        if(i<0 || j<0 || i>=n || j>=m || grid[i][j]==-1 || grid[i][j]==3) \\n            return 0;\\n        if(grid[i][j]==2){\\n            if(cellsToVisit==0)\\n                return 1;\\n            return 0;\\n        } \\n        \\n        int ans = 0;\\n        // mark as visited\\n        grid[i][j] = 3;\\n        ans += helper(grid,i+1,j,cellsToVisit-1);\\n        ans += helper(grid,i,j+1,cellsToVisit-1);\\n        ans += helper(grid,i-1,j,cellsToVisit-1);\\n        ans += helper(grid,i,j-1,cellsToVisit-1);\\n        grid[i][j] = 0;\\n        \\n        return ans;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        int cellsToVisit = 0;\\n        int startx,starty;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    startx = i;\\n                    starty = j;\\n                }\\n                else if(grid[i][j] != -1) \\n                    cellsToVisit++;\\n            }\\n            \\n        return helper(grid, startx, starty, cellsToVisit);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998935,
                "title": "dp-backtracking-faster-than-100-recursion-c",
                "content": "I traverse through cell making it value equal to INT_MIN, so if I visit same cell again it returns. And at last in function fonc I make value of cell (which we traversed) equal to 0, so as to get any other path (if exist).\\t\\nTake a look at code, You will understand yourself.\\n\\n\\t\\tint ans=0;\\n    void fonc(vector<vector<int>>& grid,int total,int x,int i,int j){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size()) return;\\n        if(grid[i][j]==INT_MIN) return;\\n        if(grid[i][j]==2 ){\\n            if(x==total)\\n                ans++;\\n            return ;\\n        }\\n        if(grid[i][j]==-1) return;\\n        grid[i][j]=INT_MIN;\\n       \\n        fonc(grid,total,x+1,i+1,j);\\n        fonc(grid,total,x+1,i-1,j);\\n        fonc(grid,total,x+1,i,j+1);\\n        fonc(grid,total,x+1,i,j-1);\\n        grid[i][j]=0;\\n        \\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int total=0;\\n        int x,y;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]!=-1 && grid[i][j]!=2) total++;\\n                if(grid[i][j]==1){\\n                    x=i;\\n                    y=j;\\n                }\\n            }\\n        }\\n        fonc(grid,total,0,x,y);\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "I traverse through cell making it value equal to INT_MIN, so if I visit same cell again it returns. And at last in function fonc I make value of cell (which we traversed) equal to 0, so as to get any other path (if exist).\\t\\nTake a look at code, You will understand yourself.\\n\\n\\t\\tint ans=0;\\n    void fonc(vector<vector<int>>& grid,int total,int x,int i,int j){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size()) return;\\n        if(grid[i][j]==INT_MIN) return;\\n        if(grid[i][j]==2 ){\\n            if(x==total)\\n                ans++;\\n            return ;\\n        }\\n        if(grid[i][j]==-1) return;\\n        grid[i][j]=INT_MIN;\\n       \\n        fonc(grid,total,x+1,i+1,j);\\n        fonc(grid,total,x+1,i-1,j);\\n        fonc(grid,total,x+1,i,j+1);\\n        fonc(grid,total,x+1,i,j-1);\\n        grid[i][j]=0;\\n        \\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int total=0;\\n        int x,y;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]!=-1 && grid[i][j]!=2) total++;\\n                if(grid[i][j]==1){\\n                    x=i;\\n                    y=j;\\n                }\\n            }\\n        }\\n        fonc(grid,total,0,x,y);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1926876,
                "title": "c-backtracking-with-graphs-in-depth-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/d1ec8a00-adca-491b-8ac2-a4761be599be_1649438593.232334.png)\\n\\nHere\\'s a step-by-step explanation for how one could approach and solve this problem. First thing is to identify an approach:\\n\\nThere\\'s no real way to avoid testing every path, so that\\'s the best we\\'ll be able to do; testing every path from start to end and tallying the ones that traverse through every square. We can optimize this, however, which saves us a lot of time. There could theoretically be some mathematical solution to this problem, but to my knowledge that hasn\\'t been discovered yet. A couple notes about the approach:\\n\\n1. Using Graphs\\n\\tWorth mentioning first: the big thing to make this problem *significantly* easier is to use Graphs. The nature of the problem is that you are stepping from one square to another, which begs the use of connected nodes, or Graphs. You could stick to using arrays, which many people mistakenly try. While the time/space complexity is about the same, using arrays is very unintuitive, and it gets very convoluted very quickly. The best and worst case performances are pretty much the same for any approach: having to test every single path. Therefore our choice of data structure between Graphs and Arrays doesn\\'t matter much for time/space, and we\\'re left to choose the option that\\'s easier to code.\\n\\t\\n\\tA friend of mine conducts FAANG interviews, and uses pathfinding questions very similar to this problem. He\\'s mentioned that the #1 mistake prospective employees make is using Arrays to keep track of everything instead of Graphs. The vast majority of the time it leads to them getting caught up in a nightmare of Array debugging. Given that you would need to create other Arrays to keep track of things like what squares have been traversed, Graphs are as good or better for space complexity and even time complexity. However in my approach, I\\'m content to keep an unneccessary Graph[][] array, for the sake of readability and simplicity.\\n\\n2. DFS vs BFS:\\n\\tThis is a pathfinding algorithm. With pathfinding, two terms that should always come to mind are DFS, and BFS. DFS (Depth First Search) is the approach of building every path individually to their end, as opposed to BFS (Breadth First Search), which explores every path simultaneously. If the question asked us to find the *shortest* path, then we would want BFS. We would expand in every direction from Start, until a path hits End, at which point we could immediately return. However in this problem, we need to explore *every* path from Start to End, as well as keeping track of certain qualities about each of those paths. Mainly, does a given path from Start to End traverse through every square? So the strategy of choice is DFS.\\n\\n3. DFS vs BackTracking\\n\\tBacktracking and DFS are very similar approaches; arguably identical. DFS implies that you\\'re exploring every single path to its end, whereas Backtracking implies that you\\'ll immediately give up on an incomplete path under certain conditions. Indeed there are certain ways to tell that a path will not satisfy the problem\\'s stipulations (that it goes from Start to End and traverses through every square). This is why this code is better categorized as Backtracking then just DFS (although it\\'s both). This is where we get to optimize.\\n\\t\\n* Optimizations:\\n\\t* Before any Backtracking, we can immediately tell if there are 0 viable paths: if there\\'s a dead end anywhere other than the End and Start squares (e.g. a square with only 1 open square). That would mean our paths would all have to either end there, or skip that square, meaning that no paths could traverse every square from Start to End.\\n\\t* If a path reaches the End square prematurely, we immediately stop exploring. That means if a path ever traverses every square, we know it also ends on End, and we can add 1 to the number of viable paths.\\n\\t* If a path is ever next to a dead-end square, then the path can *only* go that way. This is similar to the first optimization, though we can create these \"dead-end\" squares by using all but 1 of the squares around them. If the path branched to any square *other* than that one, then we would leave a dead-end square, meaning all paths from then on won\\'t work.\\n\\t* If a path ever reaches an edge, and we\\'ve already traversed an edge, we could split our remaining available squares. If there are two squares left and they\\'re opposite one another (e.g. our path hits an edge and we can either go left or right along the edge) then we immediately return 0, because either way the path turns, it will never be able to traverse any squares on the other side.\\n\\t* When creating our Graph of nodes, we do so iteratively, through the Array of Graphs all[][]. If you wanted to further optimize you could remove this and fill the Graph recursively. However, this is simple and easy to read, allows us to immediately check for dead-ends easily, and most importantly here, allows for the easy use of print statements. Notice that all[][] isn\\'t used at all in BackTrack(), other than for the Write function.\\n\\t\\n\\t\\nSo now we know we\\'re using an Optimized DFS (or BackTracking) to search through every square. And we\\'re using Graphs to keep track of everything. Time to start coding.\\n\\nFirst thing is to declare our Graph data structure:\\n\\n```\\n\\n    public class Graph {\\n\\t\\t//To keep track of whether we\\'ve traversed this square.\\n        public bool used;\\n\\t\\t\\n\\t\\t//A collection of all adjacent squares, represented by their respective Graphs.\\n        public Graph[] nodes;\\n\\t\\t\\n\\t\\t//How many usable nodes are left from the collection above.\\n        public int count;\\n\\t\\t\\n\\t\\t//Default constructor. All nodes start off as unused, with a count of 0.\\n\\t\\t//this.nodes always has a length of 4, since every square has at most 4 adjacent squares.\\n        public Graph() {\\n            this.used = false;\\n            this.nodes = new Graph[4];\\n            this.count = 0;\\n        }\\n    }\\n```\\nWhile this.used always starts false, we actually instantiate all obstacles as nodes that are already used prior to BackTracking. The *could* stay null, however this would mean we wouldn\\'t be able to implement the wall-optimization above, since we wouldn\\'t be able to differentiate between nodes along a wall, and nodes that are adjacent to an obstacle. Therefore obstacles are instantiated as used Graphs.\\nthis.nodes[] is also a Graph[4], rather than a List< Graph>[4], since each index nodes[i] corresponds to a direction. If nodes were a List< Graph>, it would be easier to deal with Null nodes (squares on the edge/corner), but the variable length would throw off the directionality. Therefore it\\'s easier to use an Array over a List.\\nFinally, this.count is initialized to 0, and then appropriately set when we build the Graph.\\n\\nNext we declare start and end as global variables, and define our main function, UniquePathsIII(int[][] grid):\\n\\n```\\n    Graph start, end;\\n\\t\\n    public int UniquePathsIII(int[][] grid) {\\n\\t\\t//Our grid of Graph nodes.\\n        Graph[][] all = new Graph[grid.Length][];\\n\\t\\t\\n\\t\\t//The total number of squares available.\\n\\t\\t//This is different from a given Graph.count, which is the total squares that node has available to it.\\n        int count = 0;\\n\\t\\t\\n\\t\\t//Building the Graph.\\n        for (int i = 0; i < grid.Length; i++) {\\n            all[i] = new Graph[grid[0].Length];\\n            for (int j = 0; j < grid[0].Length; j++) {\\n                all[i][j] = new Graph();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//If the square is an Obstacle, we set it to used.\\n\\t\\t\\t\\t//We also continue to the next square *before* adding to count or adding to any adjacent Graph nodes\\' counts\\n                if (grid[i][j] == -1) {\\n                    all[i][j].used = true;\\n                    continue;\\n                }\\n                count++;\\n\\t\\t\\t\\t//If we come across the Start or End, we set the global variables.\\n                if (grid[i][j] == 1) start = all[i][j];\\n                if (grid[i][j] == 2) end = all[i][j];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//We increase the node\\'s count if there are adjacent squares that aren\\'t used (i.e. that aren\\'t obstacles)\\n                if (i != 0 && !all[i-1][j].used) {\\n                    all[i][j].nodes[0] = all[i-1][j];\\n                    all[i][j].count++;\\n                    all[i-1][j].nodes[2] = all[i][j];\\n                    all[i-1][j].count++;\\n                }\\n                if (j != 0 && !all[i][j-1].used) {\\n                    all[i][j].nodes[3] = all[i][j-1];\\n                    all[i][j].count++;\\n                    all[i][j-1].nodes[1] = all[i][j];\\n                    all[i][j-1].count++;\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t//After building the entire Graph, we then iterate through and look for any square that\\'s a dead end (Graph.count == 1).\\n\\t\\t//If it\\'s Start or End then there are still possible paths, but otherwise we immediately return 0.\\n        foreach (Graph[] i in all) {\\n            foreach (Graph g in i) {\\n                if (g != null && g.count == 1 && g != start && g != end) return 0;\\n            }\\n        }\\n\\t\\t\\n\\t\\t//We then begin building a path, starting at Start.\\n        return BackTrack(grid, all, start, count-1, false);\\n    }\\n```\\nThe main function really only built the Graph, set the global variables, and then checked to make sure there weren\\'t dead ends.\\n\\nThe meat of the code is in BackTrack():\\n```\\n\\t//The only reason BackTrack() takes grid and all is for the Write statement.\\n\\t//If Write() is commented out, you can completely remove grid and all.\\n\\t//BackTrack() takes s, representing the current square, and count, representing how many squares are left.\\n\\t//It also takes wall, which simply records whether or not the current path has ever touched the edge of the grid.\\n    private int BackTrack(int[][] grid, Graph[][] all, Graph s, int count, bool wall) {\\n\\t\\t\\n\\t\\t//Prints the grid, with x\\'s for traversed squares/obstacles, and numbers in each open square\\n\\t\\t//representing how many available squares are adjacent to it.\\n        Write(grid, all, s, count, wall);\\n\\t\\t\\n\\t\\t//Return 1 if we traverse every path. This will only be satisfied if the current, last square is End.\\n        if (count == 0) return 1;\\n\\t\\t//If we reach the end before that, immediately return 0.\\n        if (s == end) return 0;\\n\\t\\t\\n        int sum = 0;\\n        s.used = true;\\n\\t\\t\\n\\t\\t//We use d (direction) in case there\\'s an adjacent square that\\'s a dead end.\\n        Graph d = null;\\n        for (int i = 0; i < s.nodes.Length; i++) if (s.nodes[i] != null) {\\n            Graph g = s.nodes[i];\\n\\t\\t\\t//Every adjacent node\\'s count is decreased by 1 when the current node s is used.\\n            g.count--;\\n            //This is what creates the dead ends that we can optimize for with d.\\n\\t\\t\\tif (!g.used && g != end && g.count == 1) d = g;\\n        } else {\\n\\t\\t\\n\\t\\t\\t//This in case we hit an edge (s.nodes[i] == null)\\n\\t\\t\\t//If we have only opposite squares available to turn, the path returns 0.\\n            if (wall && s.count == 2 && (s.nodes[(i+2)%4] == null || s.nodes[(i+2)%4].used)) {\\n                return 0;\\n            }\\n            wall = true;\\n        }\\n\\t\\t\\n\\t\\t//If we didn\\'t create a dead-end, we explore all of the curren\\'t square\\'s available adjacent squares (Graph g in s.nodes).\\n        if (d == null) {\\n            foreach (Graph g in s.nodes) {\\n                if (g != null && !g.used) {\\n                    sum += BackTrack(grid, all, g, count-1, false);\\n                }\\n            }\\n\\t\\t\\t//If a dead-end was found, we ignore all other possible paths, since any valid path *must* traverse through d.\\n        } else sum += BackTrack(grid, all, d, count-1, false);\\n\\t\\t\\n\\t\\t//Finally, when we\\'ve explored every path that uses s, we set it to unused again and add 1 back to its adjacent squares\\' counts.\\n        foreach (Graph g in s.nodes) if (g != null) g.count++;\\n        s.used = false;\\n\\t\\t\\n\\t\\t//Finally we return sum, which is added to the previous path\\'s sum, and so-on,\\n\\t\\t//until we get to the top BackTrack() call, from Start, which has a total sum of all possible paths.\\n        return sum;\\n    }\\n```\\n\\nIn total this is roughly O(3<sup>n</sup>) Time complexity, since each square has at most 3 possible squares to step to. Other than Start, one of its adjacent squares is already used. Space complexity is O(n), since every Graph node is O(1) space complexity, and there are n nodes. I hope this helped someone. Feel free to copy paste this and look at the print statements. It helps quite a bit to see the DFS step-by-step.\\n\\nHere is all of the code together, along with Write():\\n```\\npublic class Solution {\\n    \\n    public class Graph {\\n        public bool used;\\n        public Graph[] nodes;\\n        public int count;\\n        public Graph() {\\n            this.used = false;\\n            this.nodes = new Graph[4];\\n            this.count = 0;\\n        }\\n    }\\n    \\n    Graph start, end;\\n    \\n    public int UniquePathsIII(int[][] grid) {\\n        Graph[][] all = new Graph[grid.Length][];\\n        int count = 0;\\n        for (int i = 0; i < grid.Length; i++) {\\n            all[i] = new Graph[grid[0].Length];\\n            for (int j = 0; j < grid[0].Length; j++) {\\n                all[i][j] = new Graph();\\n                if (grid[i][j] == -1) {\\n                    all[i][j].used = true;\\n                    continue;\\n                }\\n                count++;\\n                if (grid[i][j] == 1) start = all[i][j];\\n                if (grid[i][j] == 2) end = all[i][j];\\n                if (i != 0 && !all[i-1][j].used) {\\n                    all[i][j].nodes[0] = all[i-1][j];\\n                    all[i][j].count++;\\n                    all[i-1][j].nodes[2] = all[i][j];\\n                    all[i-1][j].count++;\\n                }\\n                if (j != 0 && !all[i][j-1].used) {\\n                    all[i][j].nodes[3] = all[i][j-1];\\n                    all[i][j].count++;\\n                    all[i][j-1].nodes[1] = all[i][j];\\n                    all[i][j-1].count++;\\n                }\\n            }\\n        }\\n        foreach (Graph[] i in all) {\\n            foreach (Graph g in i) {\\n                if (g != null && g.count == 1 && g != start && g != end) return 0;\\n            }\\n        }\\n        return BackTrack(grid, all, start, count-1, false);\\n    }\\n    \\n    private int BackTrack(int[][] grid, Graph[][] all, Graph s, int count, bool wall) {\\n        //Write(grid, all, s, count, wall);\\n        if (count == 0) return 1;\\n        if (s == end) return 0;\\n        int sum = 0;\\n        s.used = true;\\n        Graph d = null;\\n        for (int i = 0; i < s.nodes.Length; i++) if (s.nodes[i] != null) {\\n            Graph g = s.nodes[i];\\n            g.count--;\\n            if (!g.used && g != end && g.count == 1) d = g;\\n        } else {\\n            if (wall && s.count == 2 && (s.nodes[(i+2)%4] == null || s.nodes[(i+2)%4].used)) {\\n                return 0;\\n            }\\n            wall = true;\\n        }\\n        if (d == null) {\\n            foreach (Graph g in s.nodes) {\\n                if (g != null && !g.used) {\\n                    sum += BackTrack(grid, all, g, count-1, false);\\n                }\\n            }\\n        } else sum += BackTrack(grid, all, d, count-1, false);\\n        foreach (Graph g in s.nodes) if (g != null) g.count++;\\n        s.used = false;\\n        return sum;\\n    }\\n    private void Write(int[][] grid, Graph[][] all, Graph s, int count, bool wall) {\\n        foreach (Graph[] i in all) {\\n            foreach (Graph g in i) {\\n                if (g == null) {\\n                    Console.Write(0 + \", \");\\n                    continue;\\n                }\\n                Console.Write((s == g || g.used? \"x\" : g.count) + \", \");\\n            }\\n            Console.WriteLine();\\n        }\\n        Console.WriteLine(\"Total Nodes: \" + count);\\n        if (s == end) Console.WriteLine(\"Reached the end with \" + count + \" nodes left.\");\\n        Console.WriteLine();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    public class Graph {\\n\\t\\t//To keep track of whether we\\'ve traversed this square.\\n        public bool used;\\n\\t\\t\\n\\t\\t//A collection of all adjacent squares, represented by their respective Graphs.\\n        public Graph[] nodes;\\n\\t\\t\\n\\t\\t//How many usable nodes are left from the collection above.\\n        public int count;\\n\\t\\t\\n\\t\\t//Default constructor. All nodes start off as unused, with a count of 0.\\n\\t\\t//this.nodes always has a length of 4, since every square has at most 4 adjacent squares.\\n        public Graph() {\\n            this.used = false;\\n            this.nodes = new Graph[4];\\n            this.count = 0;\\n        }\\n    }\\n```\n```\\n    Graph start, end;\\n\\t\\n    public int UniquePathsIII(int[][] grid) {\\n\\t\\t//Our grid of Graph nodes.\\n        Graph[][] all = new Graph[grid.Length][];\\n\\t\\t\\n\\t\\t//The total number of squares available.\\n\\t\\t//This is different from a given Graph.count, which is the total squares that node has available to it.\\n        int count = 0;\\n\\t\\t\\n\\t\\t//Building the Graph.\\n        for (int i = 0; i < grid.Length; i++) {\\n            all[i] = new Graph[grid[0].Length];\\n            for (int j = 0; j < grid[0].Length; j++) {\\n                all[i][j] = new Graph();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//If the square is an Obstacle, we set it to used.\\n\\t\\t\\t\\t//We also continue to the next square *before* adding to count or adding to any adjacent Graph nodes\\' counts\\n                if (grid[i][j] == -1) {\\n                    all[i][j].used = true;\\n                    continue;\\n                }\\n                count++;\\n\\t\\t\\t\\t//If we come across the Start or End, we set the global variables.\\n                if (grid[i][j] == 1) start = all[i][j];\\n                if (grid[i][j] == 2) end = all[i][j];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//We increase the node\\'s count if there are adjacent squares that aren\\'t used (i.e. that aren\\'t obstacles)\\n                if (i != 0 && !all[i-1][j].used) {\\n                    all[i][j].nodes[0] = all[i-1][j];\\n                    all[i][j].count++;\\n                    all[i-1][j].nodes[2] = all[i][j];\\n                    all[i-1][j].count++;\\n                }\\n                if (j != 0 && !all[i][j-1].used) {\\n                    all[i][j].nodes[3] = all[i][j-1];\\n                    all[i][j].count++;\\n                    all[i][j-1].nodes[1] = all[i][j];\\n                    all[i][j-1].count++;\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t//After building the entire Graph, we then iterate through and look for any square that\\'s a dead end (Graph.count == 1).\\n\\t\\t//If it\\'s Start or End then there are still possible paths, but otherwise we immediately return 0.\\n        foreach (Graph[] i in all) {\\n            foreach (Graph g in i) {\\n                if (g != null && g.count == 1 && g != start && g != end) return 0;\\n            }\\n        }\\n\\t\\t\\n\\t\\t//We then begin building a path, starting at Start.\\n        return BackTrack(grid, all, start, count-1, false);\\n    }\\n```\n```\\n\\t//The only reason BackTrack() takes grid and all is for the Write statement.\\n\\t//If Write() is commented out, you can completely remove grid and all.\\n\\t//BackTrack() takes s, representing the current square, and count, representing how many squares are left.\\n\\t//It also takes wall, which simply records whether or not the current path has ever touched the edge of the grid.\\n    private int BackTrack(int[][] grid, Graph[][] all, Graph s, int count, bool wall) {\\n\\t\\t\\n\\t\\t//Prints the grid, with x\\'s for traversed squares/obstacles, and numbers in each open square\\n\\t\\t//representing how many available squares are adjacent to it.\\n        Write(grid, all, s, count, wall);\\n\\t\\t\\n\\t\\t//Return 1 if we traverse every path. This will only be satisfied if the current, last square is End.\\n        if (count == 0) return 1;\\n\\t\\t//If we reach the end before that, immediately return 0.\\n        if (s == end) return 0;\\n\\t\\t\\n        int sum = 0;\\n        s.used = true;\\n\\t\\t\\n\\t\\t//We use d (direction) in case there\\'s an adjacent square that\\'s a dead end.\\n        Graph d = null;\\n        for (int i = 0; i < s.nodes.Length; i++) if (s.nodes[i] != null) {\\n            Graph g = s.nodes[i];\\n\\t\\t\\t//Every adjacent node\\'s count is decreased by 1 when the current node s is used.\\n            g.count--;\\n            //This is what creates the dead ends that we can optimize for with d.\\n\\t\\t\\tif (!g.used && g != end && g.count == 1) d = g;\\n        } else {\\n\\t\\t\\n\\t\\t\\t//This in case we hit an edge (s.nodes[i] == null)\\n\\t\\t\\t//If we have only opposite squares available to turn, the path returns 0.\\n            if (wall && s.count == 2 && (s.nodes[(i+2)%4] == null || s.nodes[(i+2)%4].used)) {\\n                return 0;\\n            }\\n            wall = true;\\n        }\\n\\t\\t\\n\\t\\t//If we didn\\'t create a dead-end, we explore all of the curren\\'t square\\'s available adjacent squares (Graph g in s.nodes).\\n        if (d == null) {\\n            foreach (Graph g in s.nodes) {\\n                if (g != null && !g.used) {\\n                    sum += BackTrack(grid, all, g, count-1, false);\\n                }\\n            }\\n\\t\\t\\t//If a dead-end was found, we ignore all other possible paths, since any valid path *must* traverse through d.\\n        } else sum += BackTrack(grid, all, d, count-1, false);\\n\\t\\t\\n\\t\\t//Finally, when we\\'ve explored every path that uses s, we set it to unused again and add 1 back to its adjacent squares\\' counts.\\n        foreach (Graph g in s.nodes) if (g != null) g.count++;\\n        s.used = false;\\n\\t\\t\\n\\t\\t//Finally we return sum, which is added to the previous path\\'s sum, and so-on,\\n\\t\\t//until we get to the top BackTrack() call, from Start, which has a total sum of all possible paths.\\n        return sum;\\n    }\\n```\n```\\npublic class Solution {\\n    \\n    public class Graph {\\n        public bool used;\\n        public Graph[] nodes;\\n        public int count;\\n        public Graph() {\\n            this.used = false;\\n            this.nodes = new Graph[4];\\n            this.count = 0;\\n        }\\n    }\\n    \\n    Graph start, end;\\n    \\n    public int UniquePathsIII(int[][] grid) {\\n        Graph[][] all = new Graph[grid.Length][];\\n        int count = 0;\\n        for (int i = 0; i < grid.Length; i++) {\\n            all[i] = new Graph[grid[0].Length];\\n            for (int j = 0; j < grid[0].Length; j++) {\\n                all[i][j] = new Graph();\\n                if (grid[i][j] == -1) {\\n                    all[i][j].used = true;\\n                    continue;\\n                }\\n                count++;\\n                if (grid[i][j] == 1) start = all[i][j];\\n                if (grid[i][j] == 2) end = all[i][j];\\n                if (i != 0 && !all[i-1][j].used) {\\n                    all[i][j].nodes[0] = all[i-1][j];\\n                    all[i][j].count++;\\n                    all[i-1][j].nodes[2] = all[i][j];\\n                    all[i-1][j].count++;\\n                }\\n                if (j != 0 && !all[i][j-1].used) {\\n                    all[i][j].nodes[3] = all[i][j-1];\\n                    all[i][j].count++;\\n                    all[i][j-1].nodes[1] = all[i][j];\\n                    all[i][j-1].count++;\\n                }\\n            }\\n        }\\n        foreach (Graph[] i in all) {\\n            foreach (Graph g in i) {\\n                if (g != null && g.count == 1 && g != start && g != end) return 0;\\n            }\\n        }\\n        return BackTrack(grid, all, start, count-1, false);\\n    }\\n    \\n    private int BackTrack(int[][] grid, Graph[][] all, Graph s, int count, bool wall) {\\n        //Write(grid, all, s, count, wall);\\n        if (count == 0) return 1;\\n        if (s == end) return 0;\\n        int sum = 0;\\n        s.used = true;\\n        Graph d = null;\\n        for (int i = 0; i < s.nodes.Length; i++) if (s.nodes[i] != null) {\\n            Graph g = s.nodes[i];\\n            g.count--;\\n            if (!g.used && g != end && g.count == 1) d = g;\\n        } else {\\n            if (wall && s.count == 2 && (s.nodes[(i+2)%4] == null || s.nodes[(i+2)%4].used)) {\\n                return 0;\\n            }\\n            wall = true;\\n        }\\n        if (d == null) {\\n            foreach (Graph g in s.nodes) {\\n                if (g != null && !g.used) {\\n                    sum += BackTrack(grid, all, g, count-1, false);\\n                }\\n            }\\n        } else sum += BackTrack(grid, all, d, count-1, false);\\n        foreach (Graph g in s.nodes) if (g != null) g.count++;\\n        s.used = false;\\n        return sum;\\n    }\\n    private void Write(int[][] grid, Graph[][] all, Graph s, int count, bool wall) {\\n        foreach (Graph[] i in all) {\\n            foreach (Graph g in i) {\\n                if (g == null) {\\n                    Console.Write(0 + \", \");\\n                    continue;\\n                }\\n                Console.Write((s == g || g.used? \"x\" : g.count) + \", \");\\n            }\\n            Console.WriteLine();\\n        }\\n        Console.WriteLine(\"Total Nodes: \" + count);\\n        if (s == end) Console.WriteLine(\"Reached the end with \" + count + \" nodes left.\");\\n        Console.WriteLine();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807446,
                "title": "easy-sol-beats-100-of-solution-on-leetcode-with-comments",
                "content": "class Solution {\\npublic:\\n    int help(vector<vector<int>>& g,int i,int j,int n,int m,int c,int t){\\n    \\n        if(i<0||j<0||i>=n||j>=m||g[i][j]==-1)//i and j cannot be outside of grid and here i am not \\n            return 0;                                      //using extra space just using grid to mark whether \\n\\t  \\t                                                     //we have visited a cell or not by making it -1;\\n        if(g[i][j]==2){\\n           if(c==t)\\n            return 1;\\n            return 0;\\n        }\\n        g[i][j]=-1;                             //marking current cell as visited\\n        int a=0;\\n         a+=help(g,i+1,j,n,m,c+1,t);\\n         a+=help(g,i,j+1,n,m,c+1,t);\\n         a+=help(g,i-1,j,n,m,c+1,t);\\n         a+=help(g,i,j-1,n,m,c+1,t);\\n        g[i][j]=0;                        //backtracking and then marking cell as unvisited\\n        return a;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int s1=-1,s2=-1,b=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){// finding the starting postion of robot \\n                    s1=i;\\n                    s2=j;\\n                }\\n                if(grid[i][j]==-1)//finding total number of blocks in grid\\n                    b++;\\n            }\\n        }\\n        int t=n*m-b;//total number of free cells that we have travel before reaching final state i.e. 2\\n        if(s1==-1)\\n            return 0;\\n        return help(grid,s1,s2,n,m,1,t);//function call\\n    }\\n};",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int help(vector<vector<int>>& g,int i,int j,int n,int m,int c,int t){\\n    \\n        if(i<0||j<0||i>=n||j>=m||g[i][j]==-1)//i and j cannot be outside of grid and here i am not \\n            return 0;                                      //using extra space just using grid to mark whether \\n\\t  \\t                                                     //we have visited a cell or not by making it -1;\\n        if(g[i][j]==2){\\n           if(c==t)\\n            return 1;\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1752390,
                "title": "recursive-backtracking-solution-java-runtime-1ms",
                "content": "**Approach:**\\n* We can move in four directions: up, down, left, right\\n* Each non-obstacle square has to be visited exactly once. Hence, we keep a count of all the safe squares  and as we visit them we reduce the count.\\n* We keep a visited array to keep track of all the visited square to prevent stack overflow and also to visit each safe square exactly once.\\n* We find the indices of the starting position and send them to the recursive function to count all the possible paths.\\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        //to keep a track of all the visited squares\\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        //count of all the safe squares\\n        int nonObstacles = 0;\\n        int row = 0;\\n        int col = 0;\\n        for(int i=0; i<grid.length; i++) {\\n            for(int j=0; j<grid[0].length; j++) {\\n                //finding the coords of starting position\\n                if(grid[i][j] == 1) {\\n                    row = i;\\n                    col = j;\\n                } else if(grid[i][j]==0)\\n                    nonObstacles++;\\n            }\\n        }\\n        return uniquePaths(row, col, vis, grid, nonObstacles);\\n    }\\n    \\n    public int uniquePaths(int row, int col, boolean[][] vis, int[][] grid, int nonObstacles) {\\n        //reaching the destination\\n        if(grid[row][col] == 2) {\\n            //visited all safe squares\\n            if(nonObstacles < 0) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        //keeping a count of all the paths\\n        int paths = 0;\\n        \\n        //to avoid visiting the already visited squares\\n        if(!vis[row][col]) {\\n            //marking the square as visited\\n            vis[row][col] = true;\\n            \\n            //move up\\n            if(row > 0 && grid[row-1][col]!=-1)\\n                paths += uniquePaths(row-1, col, vis, grid, nonObstacles-1);\\n             \\n            //move down\\n            if(row < grid.length-1 && grid[row+1][col]!=-1)\\n                paths += uniquePaths(row+1, col, vis, grid, nonObstacles-1);\\n            \\n            //move left\\n            if(col > 0 && grid[row][col-1]!=-1)\\n                paths += uniquePaths(row, col-1, vis, grid, nonObstacles-1);\\n            \\n            //move right\\n            if(col < grid[0].length-1 && grid[row][col+1]!=-1)\\n                paths += uniquePaths(row, col+1, vis, grid, nonObstacles-1);\\n            \\n            //backtracking\\n            vis[row][col] = false;\\n        }\\n        return paths;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        //to keep a track of all the visited squares\\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        //count of all the safe squares\\n        int nonObstacles = 0;\\n        int row = 0;\\n        int col = 0;\\n        for(int i=0; i<grid.length; i++) {\\n            for(int j=0; j<grid[0].length; j++) {\\n                //finding the coords of starting position\\n                if(grid[i][j] == 1) {\\n                    row = i;\\n                    col = j;\\n                } else if(grid[i][j]==0)\\n                    nonObstacles++;\\n            }\\n        }\\n        return uniquePaths(row, col, vis, grid, nonObstacles);\\n    }\\n    \\n    public int uniquePaths(int row, int col, boolean[][] vis, int[][] grid, int nonObstacles) {\\n        //reaching the destination\\n        if(grid[row][col] == 2) {\\n            //visited all safe squares\\n            if(nonObstacles < 0) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        //keeping a count of all the paths\\n        int paths = 0;\\n        \\n        //to avoid visiting the already visited squares\\n        if(!vis[row][col]) {\\n            //marking the square as visited\\n            vis[row][col] = true;\\n            \\n            //move up\\n            if(row > 0 && grid[row-1][col]!=-1)\\n                paths += uniquePaths(row-1, col, vis, grid, nonObstacles-1);\\n             \\n            //move down\\n            if(row < grid.length-1 && grid[row+1][col]!=-1)\\n                paths += uniquePaths(row+1, col, vis, grid, nonObstacles-1);\\n            \\n            //move left\\n            if(col > 0 && grid[row][col-1]!=-1)\\n                paths += uniquePaths(row, col-1, vis, grid, nonObstacles-1);\\n            \\n            //move right\\n            if(col < grid[0].length-1 && grid[row][col+1]!=-1)\\n                paths += uniquePaths(row, col+1, vis, grid, nonObstacles-1);\\n            \\n            //backtracking\\n            vis[row][col] = false;\\n        }\\n        return paths;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555177,
                "title": "c-o-rc-2-rc-top-down-dp-memoization",
                "content": "**\\u2714\\uFE0F Solution 1 (Top-Down DP, Memoization)**\\nThis is a DP problem. We can use a top-down approach to solve it.\\n\\n**Main idea**\\ndp\\\\[row\\\\]\\\\[col\\\\]\\\\[emptyCellsMask\\\\] is the number of valid paths starting at (row, col) such that currently empty cells of the grid are encoded as 1-bits in emptyCellsMask;\\n\\nBase cases:\\ndp\\\\[row\\\\]\\\\[col\\\\]\\\\[0\\\\] = 0, if (row, col) is not the ending cell;\\ndp\\\\[row\\\\]\\\\[col\\\\]\\\\[0\\\\] = 1, if (row, col) is the ending cell;\\n\\nRecurrence:\\ndp\\\\[row\\\\]\\\\[col\\\\]\\\\[emptyCellsMask\\\\] =\\ndp\\\\[row_1\\\\]\\\\[col_1\\\\]\\\\[emptyCellsMask - (1 << getIdx(row_1, col_1)\\\\] +\\ndp\\\\[row_2\\\\]\\\\[col_2\\\\]\\\\[emptyCellsMask - (1 << getIdx(row_2, col_2)\\\\] +\\ndp\\\\[row_3\\\\]\\\\[col_3\\\\]\\\\[emptyCellsMask - (1 << getIdx(row_3, col_3)\\\\] +\\ndp\\\\[row_4\\\\]\\\\[col_4\\\\]\\\\[emptyCellsMask - (1 << getIdx(row_4, col_4)\\\\];\\n\\n(row_1, col_1), (row_2, col_2), (row_3, col_3), (row_4, col_4) are neighbors of (row, col) cell;\\nContribution of a neghboring cell (row_i, col_i) is added to dp\\\\[row\\\\]\\\\[col\\\\]\\\\[emptyCellsMask\\\\] if and only if (row_i, col_i) cell is encoded as empty in emptyCellsMask or is the ending cell;\\n\\ngetIdx(row, col) returns the index of (row, col) cell in a grid of size (R, C);\\ngetIdx(row, col) => row * C + col;\\n\\n**Some implementation details**\\n* To avoid redundant computations, we cache all (row, col, emptyCellsMask) states in `memo`.\\nThis reduces the time complexity of DP solution from O(3^(RC)) to O(RC * 2^(RC)).\\n* In below implementation, a state (row, col, emptyCellsMask) is represented with a single 32-bit signed integer as `(getIdx(row, col, COLS) << 20) | emptyCellsMask`.\\n\\n**Time Complexity:** `O(RC * 2^(RC))`\\n**Space Complexity:** `O(RC * 2^(RC))`\\nR is the number of rows and C is the number of columns of the grid;\\n\\n**Code**\\n```\\nclass Solution {\\nprivate:\\n    int getIdx(int row, int col, const int& COLS){\\n        return row * COLS + col;\\n    }\\n    \\n    int solve(int row, int col, int emptyCellsMask, vector<vector<int>>& grid, unordered_map<int, int>& memo){\\n        static const vector<pair<int, int>> DIRECTIONS = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n        const int ROWS = grid.size();\\n        const int COLS = grid[0].size();\\n        \\n        int totalWalks = 0;\\n        int state = (getIdx(row, col, COLS) << 20) | emptyCellsMask;\\n        if(memo.count(state)){\\n            totalWalks = memo[state];\\n        }else if(grid[row][col] == 2){\\n            if(emptyCellsMask == 0){\\n                totalWalks = 1;\\n            }\\n        }else{\\n            for(const pair<int, int>& DIRECTION: DIRECTIONS){\\n                int nextRow = row + DIRECTION.first;\\n                int nextCol = col + DIRECTION.second;\\n                int nextIdx = getIdx(nextRow, nextCol, COLS);\\n                if(0 <= nextRow && nextRow < ROWS && 0 <= nextCol && nextCol < COLS && grid[nextRow][nextCol] != -1){\\n                    if(((emptyCellsMask >> nextIdx) & 1) || grid[nextRow][nextCol] == 2){\\n                        int nextEmptyCellsMask = emptyCellsMask - (int)(grid[nextRow][nextCol] != 2) * (1 << nextIdx);\\n                        totalWalks += solve(nextRow, nextCol, nextEmptyCellsMask, grid, memo);\\n                    }\\n                }\\n            }\\n        }\\n        memo[state] = totalWalks;\\n        return totalWalks;\\n    }\\n    \\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        const int ROWS = grid.size();\\n        const int COLS = grid[0].size();\\n        \\n        int startRow = 0;\\n        int startCol = 0;\\n        int emptyCellsMask = 0;\\n        for(int row = 0; row < ROWS; ++row){\\n            for(int col = 0; col < COLS; ++col){\\n                if(grid[row][col] == 1){\\n                    startRow = row;\\n                    startCol = col;\\n                }else if(grid[row][col] == 0){\\n                    emptyCellsMask |= (1 << getIdx(row, col, COLS));\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int, int> memo;\\n        return solve(startRow, startCol, emptyCellsMask, grid, memo);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int getIdx(int row, int col, const int& COLS){\\n        return row * COLS + col;\\n    }\\n    \\n    int solve(int row, int col, int emptyCellsMask, vector<vector<int>>& grid, unordered_map<int, int>& memo){\\n        static const vector<pair<int, int>> DIRECTIONS = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n        const int ROWS = grid.size();\\n        const int COLS = grid[0].size();\\n        \\n        int totalWalks = 0;\\n        int state = (getIdx(row, col, COLS) << 20) | emptyCellsMask;\\n        if(memo.count(state)){\\n            totalWalks = memo[state];\\n        }else if(grid[row][col] == 2){\\n            if(emptyCellsMask == 0){\\n                totalWalks = 1;\\n            }\\n        }else{\\n            for(const pair<int, int>& DIRECTION: DIRECTIONS){\\n                int nextRow = row + DIRECTION.first;\\n                int nextCol = col + DIRECTION.second;\\n                int nextIdx = getIdx(nextRow, nextCol, COLS);\\n                if(0 <= nextRow && nextRow < ROWS && 0 <= nextCol && nextCol < COLS && grid[nextRow][nextCol] != -1){\\n                    if(((emptyCellsMask >> nextIdx) & 1) || grid[nextRow][nextCol] == 2){\\n                        int nextEmptyCellsMask = emptyCellsMask - (int)(grid[nextRow][nextCol] != 2) * (1 << nextIdx);\\n                        totalWalks += solve(nextRow, nextCol, nextEmptyCellsMask, grid, memo);\\n                    }\\n                }\\n            }\\n        }\\n        memo[state] = totalWalks;\\n        return totalWalks;\\n    }\\n    \\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        const int ROWS = grid.size();\\n        const int COLS = grid[0].size();\\n        \\n        int startRow = 0;\\n        int startCol = 0;\\n        int emptyCellsMask = 0;\\n        for(int row = 0; row < ROWS; ++row){\\n            for(int col = 0; col < COLS; ++col){\\n                if(grid[row][col] == 1){\\n                    startRow = row;\\n                    startCol = col;\\n                }else if(grid[row][col] == 0){\\n                    emptyCellsMask |= (1 << getIdx(row, col, COLS));\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int, int> memo;\\n        return solve(startRow, startCol, emptyCellsMask, grid, memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554765,
                "title": "c-4ms-dfs-backtracking-code-explaination",
                "content": "### **Statement Deduction**\\n<hr>\\n\\nGiven a grid, we must count paths those start at index `i,j` such that `grid[i][j] = 1` and end at `grid[i][j] = 2` such that `steps taken = no. of 0s + 2 (for beginning and ending cells)`\\n\\n### **Approach**\\n<hr>\\n\\nNaively, we can see that from the set of all the paths starting at `grid[i][j] = 1` and ending at `grid[i][j] = 2`, we need a subset that satisfies the condition given above.\\n\\nmodelling the problem as a DFS + backtracking problem:\\n\\n1. We need to check every path from start cell to end cell - Use DFS\\n2. We want all the cells to be visited exactly once for a path - Use `vector<vector<bool>> visited`\\n3. We want to check for the above condition - Use a variable in the method and subtract 1 every time we visit a new cell\\n\\n### **Code**\\n<hr>\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long ans = 0; // A global variable that keeps track of no of paths those visite all nodes\\n    \\n    void dfsmod(vector<vector<int>>& grid, int n, int m, int si, int sj, int ei, int ej, int total, vector<vector<bool>>& visited){\\n        if(si < 0 || si >= n || sj < 0 || sj >= m) return; // out of grid\\n        if(si == ei && sj == ej){\\n            if(total == 0) ans++; // if all cells visited\\n            return;\\n        }\\n        if(visited[si][sj] || grid[si][sj] == -1) return; // obstacle or already visited cell\\n        visited[si][sj] = 1;\\n        dfsmod(grid, n, m, si+1, sj, ei, ej, total-1, visited); // go down\\n        dfsmod(grid, n, m, si-1, sj, ei, ej, total-1, visited); // go up\\n        dfsmod(grid, n, m, si, sj+1, ei, ej, total-1, visited); // go right\\n        dfsmod(grid, n, m, si, sj-1, ei, ej, total-1, visited); // go left\\n        visited[si][sj] = 0; // marked as 0 so that the cell can be visited for other paths\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int si, sj, ei, ej, total = 0;\\n        int n = grid.size(), m = grid[0].size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(grid[i][j] == 0) total++;\\n                else if(grid[i][j] == 1){\\n                    si = i;\\n                    sj = j;\\n                    total++;\\n                }else if(grid[i][j] == 2){\\n                    ei = i;\\n                    ej = j;\\n                    total++;\\n                }\\n            }\\n        }\\n        vector<vector<bool>> visited(n, vector<bool> (m, 0));\\n        dfsmod(grid, n, m, si, sj, ei, ej, total-1, visited);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long ans = 0; // A global variable that keeps track of no of paths those visite all nodes\\n    \\n    void dfsmod(vector<vector<int>>& grid, int n, int m, int si, int sj, int ei, int ej, int total, vector<vector<bool>>& visited){\\n        if(si < 0 || si >= n || sj < 0 || sj >= m) return; // out of grid\\n        if(si == ei && sj == ej){\\n            if(total == 0) ans++; // if all cells visited\\n            return;\\n        }\\n        if(visited[si][sj] || grid[si][sj] == -1) return; // obstacle or already visited cell\\n        visited[si][sj] = 1;\\n        dfsmod(grid, n, m, si+1, sj, ei, ej, total-1, visited); // go down\\n        dfsmod(grid, n, m, si-1, sj, ei, ej, total-1, visited); // go up\\n        dfsmod(grid, n, m, si, sj+1, ei, ej, total-1, visited); // go right\\n        dfsmod(grid, n, m, si, sj-1, ei, ej, total-1, visited); // go left\\n        visited[si][sj] = 0; // marked as 0 so that the cell can be visited for other paths\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int si, sj, ei, ej, total = 0;\\n        int n = grid.size(), m = grid[0].size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(grid[i][j] == 0) total++;\\n                else if(grid[i][j] == 1){\\n                    si = i;\\n                    sj = j;\\n                    total++;\\n                }else if(grid[i][j] == 2){\\n                    ei = i;\\n                    ej = j;\\n                    total++;\\n                }\\n            }\\n        }\\n        vector<vector<bool>> visited(n, vector<bool> (m, 0));\\n        dfsmod(grid, n, m, si, sj, ei, ej, total-1, visited);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554549,
                "title": "c-easy-to-understand-dfs-100-faster",
                "content": "**Please Support Me, I\\'m Only 11! Thank You Very Much!**\\nI promise I did not read any other solutions when writing my code. \\nMy first idea was to convert to 1D but that would be not be efficient because make two other vectors. It runs but not very quickly. \\nThe Idea:\\n* Count the number of \\'0\\' cells.\\n* Recurse through the grid mark visited cells as \\'-1\\' or something else so we never repeat it again.\\n* If we reach the end(\\'2\\') we will see if the number of \\'0\\' cells we have visited is the total of \\'0\\' cells in the whole grid.\\n* If the statement above is correct we have another way. \\n\\nWe do not need to worry about repeats because we never go in the same direction. Meaning we do not need to implement ```unordered_set``` or ```unordered_map```.\\n\\nTime Complexity --> O(N * M * 4)\\nSpace Complexity --> O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int solutions = 0;//We will the number of solutions here.\\n    int empty = 1;//We will store the number of \\'0\\' cell here.\\n    \\n    void DFS(vector<vector<int>>& grid, int x, int y, int count) {\\n        if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] == -1){\\n            //If grid[x][y] doesn\\'t exist OR grid[x][y] has already been visited we will stop.\\n            return;\\n        }\\n        \\n        if (grid[x][y] == 2) {\\n            //If we\\'ve reached the end ...\\n            if(empty == count){\\n                //... and we\\'ve crossed every single \\'0\\' we\\'ve found another solution.\\n                solutions++; \\n            }\\n            //If not return anyway.\\n            return;\\n        }\\n        \\n        //If we haven\\'t reached the end and it\\'s valid.\\n        //Mark grid[x][y] as \\'-1\\'.\\n        grid[x][y] = -1;\\n        \\n        //Recurse to the next 4 positions.\\n        DFS(grid, x+1, y, count+1);\\n        DFS(grid, x-1, y, count+1);\\n        DFS(grid, x, y+1, count+1);\\n        DFS(grid, x, y-1, count+1);\\n        \\n        //Reset grid[x][y] because we are using the actual grid, not a copy.\\n        grid[x][y] = 0;        \\n        \\n        \\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n        int start_x = 0;\\n        int start_y = 0;\\n        \\n        //Find start_x and start_y and initialise empty, the number of \\'0\\' cells.\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[0].size(); j++) {\\n                if (grid[i][j] == 1){ \\n                    start_x = i, start_y = j;\\n                }\\n                if (grid[i][j] == 0) {\\n                    empty++;\\n                }                     \\n                 \\n            }\\n        }\\n        //Run the DFS.\\n        DFS(grid, start_x, start_y, 0);\\n        //Return the number of solutions.\\n        return solutions;\\n    }\\n};\\n```\\n\\u263AThanks for reading this! \\u263B\\n\\u2705 Please Upvote! \\u2705\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```unordered_set```\n```unordered_map```\n```\\nclass Solution {\\npublic:\\n    int solutions = 0;//We will the number of solutions here.\\n    int empty = 1;//We will store the number of \\'0\\' cell here.\\n    \\n    void DFS(vector<vector<int>>& grid, int x, int y, int count) {\\n        if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] == -1){\\n            //If grid[x][y] doesn\\'t exist OR grid[x][y] has already been visited we will stop.\\n            return;\\n        }\\n        \\n        if (grid[x][y] == 2) {\\n            //If we\\'ve reached the end ...\\n            if(empty == count){\\n                //... and we\\'ve crossed every single \\'0\\' we\\'ve found another solution.\\n                solutions++; \\n            }\\n            //If not return anyway.\\n            return;\\n        }\\n        \\n        //If we haven\\'t reached the end and it\\'s valid.\\n        //Mark grid[x][y] as \\'-1\\'.\\n        grid[x][y] = -1;\\n        \\n        //Recurse to the next 4 positions.\\n        DFS(grid, x+1, y, count+1);\\n        DFS(grid, x-1, y, count+1);\\n        DFS(grid, x, y+1, count+1);\\n        DFS(grid, x, y-1, count+1);\\n        \\n        //Reset grid[x][y] because we are using the actual grid, not a copy.\\n        grid[x][y] = 0;        \\n        \\n        \\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n        int start_x = 0;\\n        int start_y = 0;\\n        \\n        //Find start_x and start_y and initialise empty, the number of \\'0\\' cells.\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[0].size(); j++) {\\n                if (grid[i][j] == 1){ \\n                    start_x = i, start_y = j;\\n                }\\n                if (grid[i][j] == 0) {\\n                    empty++;\\n                }                     \\n                 \\n            }\\n        }\\n        //Run the DFS.\\n        DFS(grid, start_x, start_y, 0);\\n        //Return the number of solutions.\\n        return solutions;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554434,
                "title": "simple-dfs-solution-commented-self-explanatory-code",
                "content": "Idea is to do standard dfs to visit every cell. Since every cell can be visited only once, we will mark that cell as -1 and do dfs for other 4-direction adjacent cells, then backtrack for checking other possibilities.\\n```\\nclass Solution {\\npublic:\\n    int ans=0,empty=1;\\n    void dfs(vector<vector<int>>& grid,int x,int y,int count){\\n        // base case\\n        if(x<0 or x>=grid.size() or y<0 or y>=grid[0].size() or grid[x][y]==-1)\\n            return;\\n        \\n        // termination case when robot reaches the cell marked 2\\n        if(grid[x][y]==2){\\n            // increment ans only when all the cells have been visited (as per the question)\\n            if(empty==count)\\n                ans++;\\n            return;\\n        }\\n        \\n        // mark the cell as visited (-1 as it cannot be walked over again (as per the ques))\\n        grid[x][y] = -1;\\n        \\n        dfs(grid,x+1,y,count+1);\\n        dfs(grid,x-1,y,count+1);\\n        dfs(grid,x,y+1,count+1);\\n        dfs(grid,x,y-1,count+1);\\n        \\n        // backtrack\\n        grid[x][y] = 0;\\n        \\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int startX,startY;\\n        \\n        // traverse the grid\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                if(grid[i][j]==1){\\n                    startX = i;\\n                    startY = j;\\n                }\\n                else if(grid[i][j]==0){\\n                    empty++;\\n                }\\n            }\\n        }\\n        \\n        dfs(grid,startX,startY,0);\\n        \\n        return ans;\\n    }\\n};\\n```\\nif you found this useful please upvote.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0,empty=1;\\n    void dfs(vector<vector<int>>& grid,int x,int y,int count){\\n        // base case\\n        if(x<0 or x>=grid.size() or y<0 or y>=grid[0].size() or grid[x][y]==-1)\\n            return;\\n        \\n        // termination case when robot reaches the cell marked 2\\n        if(grid[x][y]==2){\\n            // increment ans only when all the cells have been visited (as per the question)\\n            if(empty==count)\\n                ans++;\\n            return;\\n        }\\n        \\n        // mark the cell as visited (-1 as it cannot be walked over again (as per the ques))\\n        grid[x][y] = -1;\\n        \\n        dfs(grid,x+1,y,count+1);\\n        dfs(grid,x-1,y,count+1);\\n        dfs(grid,x,y+1,count+1);\\n        dfs(grid,x,y-1,count+1);\\n        \\n        // backtrack\\n        grid[x][y] = 0;\\n        \\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int startX,startY;\\n        \\n        // traverse the grid\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                if(grid[i][j]==1){\\n                    startX = i;\\n                    startY = j;\\n                }\\n                else if(grid[i][j]==0){\\n                    empty++;\\n                }\\n            }\\n        }\\n        \\n        dfs(grid,startX,startY,0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554119,
                "title": "unique-paths-iii-c-dfs-easy-solution",
                "content": "class Solution {\\npublic:\\n    int ans=0;\\n    void findcount(vector<vector<int>>& grid,int sr,int sc,vector<vector<int>>&dir,int cnt)\\n    {    \\n         \\n        if(sr<0 or sc<0 or sr>=grid.size() or sc>=grid[0].size() or grid[sr][sc]==-10 or grid[sr][sc]==-1) return;\\n        \\n        if(cnt==0 and grid[sr][sc]==2)\\n        {\\n            ans++;\\n            return;\\n        }\\n        if(grid[sr][sc]==0)\\n            cnt--;\\n        \\n        int temp=grid[sr][sc];\\n        grid[sr][sc]=-10;\\n        for(auto ele:dir){\\n            int r=sr+ele[0];\\n            int c=sc+ele[1];\\n            \\n            findcount(grid,r,c,dir,cnt);\\n        }\\n        grid[sr][sc]=temp;\\n        return;\\n        \\n        \\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n        if(grid[0][0]==2 or grid[0][0]==-1) return 0;\\n        \\n        int cnt=0; // count of all places from where robot can walk through\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        int sr=0,sc=0;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==0)\\n                    cnt++;\\n                if(grid[i][j]==1)\\n                {\\n                    sr=i;\\n                    sc=j;\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> dir={{1,0},{-1,0},{0,1},{0,-1}};\\n        \\n        findcount(grid,sr,sc,dir,cnt);\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int ans=0;\\n    void findcount(vector<vector<int>>& grid,int sr,int sc,vector<vector<int>>&dir,int cnt)\\n    {    \\n         \\n        if(sr<0 or sc<0 or sr>=grid.size() or sc>=grid[0].size() or grid[sr][sc]==-10 or grid[sr][sc]==-1) return;\\n        \\n        if(cnt==0 and grid[sr][sc]==2)\\n        {\\n            ans++;\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1553971,
                "title": "simple-c-backtracting-solution",
                "content": "class Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>>& grid,int i,int j,int n,int m,int count,int curr,int &total)\\n    {\\n        if(i>=n or j>=m or i<0 or j<0 or grid[i][j]==-1)\\n            return;\\n        \\n        if(grid[i][j]==2)\\n        {\\n            if(count==curr)\\n            {\\n                total++;\\n            }\\n            return;\\n        }\\n        \\n        grid[i][j] = -1;\\n        \\n        dfs(grid,i,j+1,n,m,count,curr+1,total);\\n        dfs(grid,i,j-1,n,m,count,curr+1,total);\\n        dfs(grid,i+1,j,n,m,count,curr+1,total);\\n        dfs(grid,i-1,j,n,m,count,curr+1,total);\\n        \\n        grid[i][j] = 0;\\n        \\n        return;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        int x,y;\\n        \\n        int count = 0; // total number of empty squares we can walk over + one final destination\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    x = i;\\n                    y = j;\\n                }\\n                else if(grid[i][j]==0 or grid[i][j]==2)\\n                    count++;\\n            }\\n        }\\n        \\n        int total = 0;  // total number of ways we have\\n        int curr = 0;   //currently how many empty squares we have passed\\n        dfs(grid,x,y,n,m,count,curr,total);\\n        return total;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>>& grid,int i,int j,int n,int m,int count,int curr,int &total)\\n    {\\n        if(i>=n or j>=m or i<0 or j<0 or grid[i][j]==-1)\\n            return;\\n        \\n        if(grid[i][j]==2)\\n        {\\n            if(count==curr)\\n            {\\n                total++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1491985,
                "title": "simple-java-backtracking-soln-similar-to-no-of-islands-ques-concept",
                "content": "**Explanation**:\\n1. Count totalSteps needed to reach dest using all valid blocks.\\n2. Also store start position, in the same loop.\\n3. Using recursive func, find the path to dest with steps == totalSteps.\\n4. Once found, don\\'t end recursion completely here. Stop that branch only, then do backtracking and find new paths if available using the for loop of direction vector.\\n\\nIf you couldn\\'t understand now, believe me, just go through the code once, it will become absolutely clear...\\n\\n**Code**:\\n```\\nclass Solution {\\n    int m, n;\\n    int totalSteps = 0;\\n    int count = 0;\\n    \\n    public int uniquePathsIII(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        \\n        int startX = -1, startY = -1;   \\n        \\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 0 || grid[i][j] == 2)\\n                    totalSteps++;\\n                if(grid[i][j] == 1){\\n                    startX = i;\\n                    startY = j;\\n                } \\n            }\\n                \\n        path(grid, startX, startY, 0);\\n        \\n        return count;\\n    }\\n    \\n    public void path(int[][] grid, int r, int c, int steps){\\n        \\n        if(steps == totalSteps && grid[r][c] == 2){\\n            count++;\\n            return;\\n        }\\n        \\n        if(grid[r][c] == 2)     // to stops path which pass through \"2\" twice & satisfying\\n            return;             // steps cond fianlly, & hence increasing count falsely.\\n        \\n\\t\\t//Direction Vector\\n        int DIR[] = {0, -1, 0, 1, 0};\\n        for(int i = 0; i < 4; i++){\\n            int nr = r + DIR[i], nc = c + DIR[i+1];\\n            \\n            if(nr >= 0 && nr < m && nc >= 0 && nc < n && grid[nr][nc] != -1 && grid[nr][nc] != 1){\\n                steps++;\\n                if(grid[nr][nc] != 2)\\n                    grid[nr][nc] = -1;\\n                \\n                path(grid, nr, nc, steps);\\n                \\n                //backtracking lines: \\n                steps--;\\n                if(grid[nr][nc] == -1)\\n                    grid[nr][nc] = 0;\\n            }\\n        }\\n    }\\n}\\n```\\n\\nPlease upvote if you are able to understand the solution and it helped in clearing your doubts.\\nThanks!!",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int m, n;\\n    int totalSteps = 0;\\n    int count = 0;\\n    \\n    public int uniquePathsIII(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        \\n        int startX = -1, startY = -1;   \\n        \\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 0 || grid[i][j] == 2)\\n                    totalSteps++;\\n                if(grid[i][j] == 1){\\n                    startX = i;\\n                    startY = j;\\n                } \\n            }\\n                \\n        path(grid, startX, startY, 0);\\n        \\n        return count;\\n    }\\n    \\n    public void path(int[][] grid, int r, int c, int steps){\\n        \\n        if(steps == totalSteps && grid[r][c] == 2){\\n            count++;\\n            return;\\n        }\\n        \\n        if(grid[r][c] == 2)     // to stops path which pass through \"2\" twice & satisfying\\n            return;             // steps cond fianlly, & hence increasing count falsely.\\n        \\n\\t\\t//Direction Vector\\n        int DIR[] = {0, -1, 0, 1, 0};\\n        for(int i = 0; i < 4; i++){\\n            int nr = r + DIR[i], nc = c + DIR[i+1];\\n            \\n            if(nr >= 0 && nr < m && nc >= 0 && nc < n && grid[nr][nc] != -1 && grid[nr][nc] != 1){\\n                steps++;\\n                if(grid[nr][nc] != 2)\\n                    grid[nr][nc] = -1;\\n                \\n                path(grid, nr, nc, steps);\\n                \\n                //backtracking lines: \\n                steps--;\\n                if(grid[nr][nc] == -1)\\n                    grid[nr][nc] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465949,
                "title": "super-easy-java-backtracking-implementation-100",
                "content": "```\\nclass Solution { int totalCount = 0;\\n    public int uniquePathsIII(int[][] grid) {\\n        int starti=-1,startj=-1, zeros = 0;\\n        \\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    starti = i;\\n                    startj = j;\\n                }\\n                else if(grid[i][j] == 0)\\n                    zeros++;\\n            }\\n        }\\n        \\n        solve(grid,starti,startj,0,zeros);\\n        \\n        return totalCount;\\n    }\\n    \\n    public void solve(int[][] grid, int i, int j, int count,int zeros)\\n    {\\n        if(i > grid.length-1 || j > grid[0].length-1 || i < 0 || j < 0 || grid[i][j] == -1)\\n            return;\\n        \\n        if(grid[i][j] == 2)\\n        {\\n            if(count == zeros+1)\\n                totalCount++;\\n            \\n            return;\\n        }\\n        \\n        grid[i][j] = -1;\\n        count++;\\n        \\n        solve(grid,i,j+1,count,zeros);\\n        solve(grid,i+1,j,count,zeros);\\n        solve(grid,i-1,j,count,zeros);\\n        solve(grid,i,j-1,count,zeros);\\n        \\n        grid[i][j] = 0;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution { int totalCount = 0;\\n    public int uniquePathsIII(int[][] grid) {\\n        int starti=-1,startj=-1, zeros = 0;\\n        \\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    starti = i;\\n                    startj = j;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1417373,
                "title": "c-easy-sol-with-dfs-commented",
                "content": "we have to traverse all the squares except obstacles, i.e -1\\n```\\nclass Solution {\\npublic:\\n    int startx;\\n    int starty;\\n    int endx;\\n    int endy;\\n    int ans=0;\\n    int squares_which_are_path;//squares which we have to travel\\n    int m;\\n    int n;\\n    vector<int> dx = {0,0,1,-1};\\n    vector<int> dy = {1,-1,0,0};\\n    void dfs(vector<vector<int>> &grid, int i, int j, int path)\\n    {\\n        //we have reached ending point i.e 2 after walking all squares\\n        if(i==endx && j==endy && path == squares_which_are_path)\\n        {\\n            ans++;\\n            return;\\n        }\\n        grid[i][j] = -1;//marking current as visited, so we don\\'t calculate calculated values again\\n        \\n        for(int k=0; k<4; k++)\\n        {\\n            int x = i+dx[k];\\n            int y = j+dy[k];\\n            //we can walk all the paths excluding obstacles i.e -1\\n            if(x>=0 and x<m and y>=0 and y<n and grid[x][y] != -1)\\n                dfs(grid, x, y, path+1);  \\n        }\\n        grid[i][j] = 0;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) \\n    {\\n        m = grid.size();\\n        n = grid[0].size();\\n        squares_which_are_path = m*n;//total if we also include -1\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j] == 1)//our starting point\\n                {\\n                    startx = i;\\n                    starty = j;\\n                }\\n                else if(grid[i][j] == 2)//our ending point\\n                {\\n                    endx = i;\\n                    endy = j;\\n                }\\n                else if(grid[i][j] == -1)\\n                {\\n                    squares_which_are_path--;\\n                    //subtract as -1 will not form a path, it is obstacle\\n                }\\n            }\\n        }\\n        dfs(grid, startx, starty,1);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int startx;\\n    int starty;\\n    int endx;\\n    int endy;\\n    int ans=0;\\n    int squares_which_are_path;//squares which we have to travel\\n    int m;\\n    int n;\\n    vector<int> dx = {0,0,1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 1131802,
                "title": "rust-0ms-dfs-back-tracking",
                "content": "```\\nimpl Solution {\\n    pub fn unique_paths_iii(mut grid: Vec<Vec<i32>>) -> i32 {\\n        let (start_x, start_y) = (0..grid.len())\\n            .flat_map(|y| (0..grid[0].len()).map(move |x| (x, y)))\\n            .find(|&(x, y)| grid[y][x] == 1)\\n            .expect(\"grid doesn\\'t have a starting square!\");\\n        let num_empty = grid\\n            .iter()\\n            .flat_map(|r| r.iter().filter(|&&c| c != -1))\\n            .count();\\n\\n        Self::dfs(&mut grid, start_x, start_y, num_empty - 1) as _\\n    }\\n\\n    fn dfs(grid: &mut Vec<Vec<i32>>, x: usize, y: usize, num_empty_unvisited: usize) -> usize {\\n        if x >= grid[0].len() || y >= grid.len() {\\n            return 0;\\n        }\\n        match grid[y][x] {\\n            0 | 1 => {\\n                grid[y][x] = -1; // mark as visited\\n                let num_valid_paths_from_here = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n                    .iter()\\n                    .map(|&(dx, dy)| ((x as isize + dx) as _, (y as isize + dy) as _))\\n                    .map(|(nx, ny)| Self::dfs(grid, nx, ny, num_empty_unvisited - 1))\\n                    .sum();\\n                grid[y][x] = 0; // backtrack and un-mark\\n\\n                num_valid_paths_from_here\\n            }\\n            2 if num_empty_unvisited == 0 => 1,\\n            _ => 0,\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn unique_paths_iii(mut grid: Vec<Vec<i32>>) -> i32 {\\n        let (start_x, start_y) = (0..grid.len())\\n            .flat_map(|y| (0..grid[0].len()).map(move |x| (x, y)))\\n            .find(|&(x, y)| grid[y][x] == 1)\\n            .expect(\"grid doesn\\'t have a starting square!\");\\n        let num_empty = grid\\n            .iter()\\n            .flat_map(|r| r.iter().filter(|&&c| c != -1))\\n            .count();\\n\\n        Self::dfs(&mut grid, start_x, start_y, num_empty - 1) as _\\n    }\\n\\n    fn dfs(grid: &mut Vec<Vec<i32>>, x: usize, y: usize, num_empty_unvisited: usize) -> usize {\\n        if x >= grid[0].len() || y >= grid.len() {\\n            return 0;\\n        }\\n        match grid[y][x] {\\n            0 | 1 => {\\n                grid[y][x] = -1; // mark as visited\\n                let num_valid_paths_from_here = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n                    .iter()\\n                    .map(|&(dx, dy)| ((x as isize + dx) as _, (y as isize + dy) as _))\\n                    .map(|(nx, ny)| Self::dfs(grid, nx, ny, num_empty_unvisited - 1))\\n                    .sum();\\n                grid[y][x] = 0; // backtrack and un-mark\\n\\n                num_valid_paths_from_here\\n            }\\n            2 if num_empty_unvisited == 0 => 1,\\n            _ => 0,\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1121327,
                "title": "java-backtracking-easy-understanding",
                "content": "Hint -> **1 <= grid.length * grid[0].length <= 20** , if  **length is less , Backtracking** is one of the **acceptable** solution .\\n\\nStore the starting point indexes and count the no of empty cells in the matrix;\\nPerform DFS , if we reach the ending square and visited all empty cells, considered it into the result otherwise ignore.\\n\\n```\\nclass Solution {\\n    int empty =1;// starting square considered as empty too\\n    public int uniquePathsIII(int[][] grid) {    \\n        int tR = grid.length;int tC = grid[0].length;int sR=-1,sC=-1;\\n        for( int i =0 ; i < tR; i++ ){\\n            for( int j =0; j< tC; j++ )\\n\\t\\t\\t{\\n                if( grid[i][j] == 1 ) { sR = i; sC = j;}\\n                else if( grid[i][j] == 0 )   empty++;\\n            }\\n        }\\n    return dfs( sR,sC, grid );\\n    }\\n    public int dfs( int i, int j,int[][] grid )\\n    {\\n        int count = 0;\\n        if( i < 0  || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == -2 || grid[i][j] == -1 ) // ignoring obstacles and visiting square\\n            return 0 ;\\n        \\n        if( grid[i][j]== 2 ) //ending square\\n            if( empty == 0 ) return 1; //visited all empty cells\\n        \\n        int temp = grid[i][j]; //before marking as visited save the value so that we can assign it after recursion calls\\n        grid[i][j] =-2; // no need of visited 2d array, -2 value means we have visited it\\n        empty--;\\n        count += dfs( i+1,j,grid) + dfs( i-1,j,grid) + dfs( i,j+1,grid) + dfs( i,j-1,grid); // 4 direction walk\\n        grid[i][j] = temp;\\n        empty++;\\n     return count;       \\n    }   \\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    int empty =1;// starting square considered as empty too\\n    public int uniquePathsIII(int[][] grid) {    \\n        int tR = grid.length;int tC = grid[0].length;int sR=-1,sC=-1;\\n        for( int i =0 ; i < tR; i++ ){\\n            for( int j =0; j< tC; j++ )\\n\\t\\t\\t{\\n                if( grid[i][j] == 1 ) { sR = i; sC = j;}",
                "codeTag": "Java"
            },
            {
                "id": 857773,
                "title": "easy-to-understand-backtracking-solution-video-explanation-c",
                "content": "[Drop a like if you find this helpful <3](https://www.youtube.com/watch?v=tnVl8hFLPc4)\\n\\n```\\npublic class Solution {\\n    int count;\\n    public int UniquePathsIII(int[][] grid) {\\n        int startX = 0;\\n        int startY = 0;\\n        int countZeros = 1;\\n        count = 0;\\n        \\n        for(int i = 0; i < grid.Length; i++) {\\n            for(int j = 0; j < grid[0].Length; j++) {\\n                if(grid[i][j] == 0) countZeros++;\\n                else if(grid[i][j] == 1) { startX = i; startY = j;}\\n            }\\n        }\\n        \\n        UniquePathsIIIUtil(grid, startX, startY, countZeros);\\n        \\n        return count;\\n    }\\n    \\n    private void UniquePathsIIIUtil(int[][] grid, int row, int col, int countZeros) {\\n        if(row < 0 || col < 0 ||\\n           row >= grid.Length ||\\n           col >= grid[0].Length ||\\n           countZeros < 0 || grid[row][col] == -1)\\n            return;\\n        \\n        if(grid[row][col] == 2) {\\n            if(countZeros == 0) count++;\\n            return;\\n        }\\n        \\n        grid[row][col] = -1;\\n        \\n        UniquePathsIIIUtil(grid, row + 1, col, countZeros - 1);\\n        UniquePathsIIIUtil(grid, row, col + 1, countZeros - 1);\\n        UniquePathsIIIUtil(grid, row - 1, col, countZeros - 1);\\n        UniquePathsIIIUtil(grid, row, col - 1, countZeros - 1);\\n        \\n        grid[row][col] = 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    int count;\\n    public int UniquePathsIII(int[][] grid) {\\n        int startX = 0;\\n        int startY = 0;\\n        int countZeros = 1;\\n        count = 0;\\n        \\n        for(int i = 0; i < grid.Length; i++) {\\n            for(int j = 0; j < grid[0].Length; j++) {\\n                if(grid[i][j] == 0) countZeros++;\\n                else if(grid[i][j] == 1) { startX = i; startY = j;}\\n            }\\n        }\\n        \\n        UniquePathsIIIUtil(grid, startX, startY, countZeros);\\n        \\n        return count;\\n    }\\n    \\n    private void UniquePathsIIIUtil(int[][] grid, int row, int col, int countZeros) {\\n        if(row < 0 || col < 0 ||\\n           row >= grid.Length ||\\n           col >= grid[0].Length ||\\n           countZeros < 0 || grid[row][col] == -1)\\n            return;\\n        \\n        if(grid[row][col] == 2) {\\n            if(countZeros == 0) count++;\\n            return;\\n        }\\n        \\n        grid[row][col] = -1;\\n        \\n        UniquePathsIIIUtil(grid, row + 1, col, countZeros - 1);\\n        UniquePathsIIIUtil(grid, row, col + 1, countZeros - 1);\\n        UniquePathsIIIUtil(grid, row - 1, col, countZeros - 1);\\n        UniquePathsIIIUtil(grid, row, col - 1, countZeros - 1);\\n        \\n        grid[row][col] = 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856885,
                "title": "go-golang-dfs-solution",
                "content": ">Runtime: 0 ms, faster than 100.00% of Go online submissions for Unique Paths III.\\nMemory Usage: 2 MB, less than 100.00% of Go online submissions for Unique Paths III.\\n\\n```go\\nfunc uniquePathsIII(grid [][]int) int {\\n    x, y, n := -1, -1, 0\\n    for i := 0; i < len(grid); i++ {\\n        for j := 0; j < len(grid[0]); j++ {\\n            if grid[i][j] == 0 { n++ }\\n            if grid[i][j] == 1 { x, y, n = i, j, n + 1 }\\n        }\\n    }\\n    return dfs(&grid, x, y, n)\\n}\\n\\nfunc dfs(grid *[][]int, x, y, n int) int {\\n    if x < 0 || x >= len(*grid) || y < 0 || y >= len((*grid)[0]) || (*grid)[x][y] == -1 { return 0 }\\n    if (*grid)[x][y] == 2 { if n == 0 { return 1 }; return 0 }\\n    (*grid)[x][y] = -1\\n    paths := dfs(grid, x + 1, y, n - 1) +\\n             dfs(grid, x - 1, y, n - 1) + \\n             dfs(grid, x, y + 1, n - 1) +\\n             dfs(grid, x, y - 1, n - 1)\\n    (*grid)[x][y] = 0\\n    return paths\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc uniquePathsIII(grid [][]int) int {\\n    x, y, n := -1, -1, 0\\n    for i := 0; i < len(grid); i++ {\\n        for j := 0; j < len(grid[0]); j++ {\\n            if grid[i][j] == 0 { n++ }\\n            if grid[i][j] == 1 { x, y, n = i, j, n + 1 }\\n        }\\n    }\\n    return dfs(&grid, x, y, n)\\n}\\n\\nfunc dfs(grid *[][]int, x, y, n int) int {\\n    if x < 0 || x >= len(*grid) || y < 0 || y >= len((*grid)[0]) || (*grid)[x][y] == -1 { return 0 }\\n    if (*grid)[x][y] == 2 { if n == 0 { return 1 }; return 0 }\\n    (*grid)[x][y] = -1\\n    paths := dfs(grid, x + 1, y, n - 1) +\\n             dfs(grid, x - 1, y, n - 1) + \\n             dfs(grid, x, y + 1, n - 1) +\\n             dfs(grid, x, y - 1, n - 1)\\n    (*grid)[x][y] = 0\\n    return paths\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 855927,
                "title": "unique-paths-python",
                "content": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        output=0\\n        squares=0\\n        h=len(grid)\\n        w=len(grid[0])\\n        for i in range(h):\\n            for j in range(w):\\n                if grid[i][j]==1:\\n                    start=(j,i)\\n                elif grid[i][j]==2:\\n                    end=(j,i)\\n                elif grid[i][j]==0:\\n                    squares+=1\\n        \\n        dire=[(1,0),(0,1),(-1,0),(0,-1)]\\n        \\n        def dfs(cur,his):\\n            nonlocal output\\n            x,y=cur\\n            for dx,dy in dire:\\n                x_=x+dx\\n                y_=y+dy\\n                if 0<=x_<w and 0<=y_<h and (x_,y_) not in his and grid[y_][x_]!=-1:\\n                    if (x_,y_)==end:\\n                        if len(his)==squares+1:\\n                            output+=1\\n                            break\\n                        else:\\n                            continue\\n                    else:\\n                        dfs((x_,y_),his+[(x_,y_)])\\n                        \\n        dfs(start,[start])   \\n        return output\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        output=0\\n        squares=0\\n        h=len(grid)\\n        w=len(grid[0])\\n        for i in range(h):\\n            for j in range(w):\\n                if grid[i][j]==1:\\n                    start=(j,i)\\n                elif grid[i][j]==2:\\n                    end=(j,i)\\n                elif grid[i][j]==0:\\n                    squares+=1\\n        \\n        dire=[(1,0),(0,1),(-1,0),(0,-1)]\\n        \\n        def dfs(cur,his):\\n            nonlocal output\\n            x,y=cur\\n            for dx,dy in dire:\\n                x_=x+dx\\n                y_=y+dy\\n                if 0<=x_<w and 0<=y_<h and (x_,y_) not in his and grid[y_][x_]!=-1:\\n                    if (x_,y_)==end:\\n                        if len(his)==squares+1:\\n                            output+=1\\n                            break\\n                        else:\\n                            continue\\n                    else:\\n                        dfs((x_,y_),his+[(x_,y_)])\\n                        \\n        dfs(start,[start])   \\n        return output\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 855754,
                "title": "c-0ms-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int sol=0;\\n    void dfs(int x,int y,vector<vector<int>>& grid, int count,int total)\\n    {\\n        if(x<0 || y<0 || x>=grid.size() || y>=grid[0].size() || grid[x][y]==-1)\\n        {\\n            return;\\n        }\\n        if(grid[x][y]==2 && total==count)\\n        {\\n            sol++;\\n            return;\\n        }\\n        if(grid[x][y]==2 && total!=count)\\n            return;\\n        if(total>=count)\\n            return;\\n        grid[x][y]=-1;\\n        dfs(x+1,y,grid,count,total+1);\\n        dfs(x-1,y,grid,count,total+1);\\n        dfs(x,y+1,grid,count,total+1);\\n        dfs(x,y-1,grid,count,total+1);\\n        grid[x][y]=0;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int count=0;\\n        int x,y;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    x=i;\\n                    y=j;\\n                }\\n                if(grid[i][j]==0)\\n                    count++;\\n            }\\n        }\\n        dfs(x,y,grid,count+1,0);\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sol=0;\\n    void dfs(int x,int y,vector<vector<int>>& grid, int count,int total)\\n    {\\n        if(x<0 || y<0 || x>=grid.size() || y>=grid[0].size() || grid[x][y]==-1)\\n        {\\n            return;\\n        }\\n        if(grid[x][y]==2 && total==count)\\n        {\\n            sol++;\\n            return;\\n        }\\n        if(grid[x][y]==2 && total!=count)\\n            return;\\n        if(total>=count)\\n            return;\\n        grid[x][y]=-1;\\n        dfs(x+1,y,grid,count,total+1);\\n        dfs(x-1,y,grid,count,total+1);\\n        dfs(x,y+1,grid,count,total+1);\\n        dfs(x,y-1,grid,count,total+1);\\n        grid[x][y]=0;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int count=0;\\n        int x,y;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    x=i;\\n                    y=j;\\n                }\\n                if(grid[i][j]==0)\\n                    count++;\\n            }\\n        }\\n        dfs(x,y,grid,count+1,0);\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899529,
                "title": "a-c-solution",
                "content": "another way to write the same idea as the others :(\\n# Code\\n```\\nint traverse(int** grid, int row, int col, int rLimit, int cLimit, int spaces) {\\n    if(row < 0 || row > rLimit || col < 0 || col > cLimit || grid[row][col] == -1) return 0;\\n    if(grid[row][col] == 2) return (spaces == 0)? 1 : 0;\\n\\n    int ans = 0;\\n    grid[row][col] = -1;\\n    ans += traverse(grid, row - 1, col, rLimit, cLimit, spaces - 1);\\n    ans += traverse(grid, row + 1, col, rLimit, cLimit, spaces - 1);\\n    ans += traverse(grid, row, col - 1, rLimit, cLimit, spaces - 1);\\n    ans += traverse(grid, row, col + 1, rLimit, cLimit, spaces - 1);\\n    grid[row][col] = 0;\\n\\n    return ans;\\n}\\n\\nint uniquePathsIII(int** grid, int gridSize, int* gridColSize){\\n    int startRow = 0, startCol = 0;\\n    int spaces = 1;\\n    int rLimit = gridSize - 1;\\n    int cLimit = *gridColSize - 1;\\n    for(int i = 0; i < gridSize; i++) {\\n        for(int j = 0; j < *gridColSize; j++) {\\n            if(grid[i][j] == 1) {\\n                startRow = i;\\n                startCol = j;\\n            }\\n            else if(!grid[i][j]) spaces++;\\n        }\\n    }\\n    \\n    return traverse(grid, startRow, startCol, rLimit, cLimit, spaces);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint traverse(int** grid, int row, int col, int rLimit, int cLimit, int spaces) {\\n    if(row < 0 || row > rLimit || col < 0 || col > cLimit || grid[row][col] == -1) return 0;\\n    if(grid[row][col] == 2) return (spaces == 0)? 1 : 0;\\n\\n    int ans = 0;\\n    grid[row][col] = -1;\\n    ans += traverse(grid, row - 1, col, rLimit, cLimit, spaces - 1);\\n    ans += traverse(grid, row + 1, col, rLimit, cLimit, spaces - 1);\\n    ans += traverse(grid, row, col - 1, rLimit, cLimit, spaces - 1);\\n    ans += traverse(grid, row, col + 1, rLimit, cLimit, spaces - 1);\\n    grid[row][col] = 0;\\n\\n    return ans;\\n}\\n\\nint uniquePathsIII(int** grid, int gridSize, int* gridColSize){\\n    int startRow = 0, startCol = 0;\\n    int spaces = 1;\\n    int rLimit = gridSize - 1;\\n    int cLimit = *gridColSize - 1;\\n    for(int i = 0; i < gridSize; i++) {\\n        for(int j = 0; j < *gridColSize; j++) {\\n            if(grid[i][j] == 1) {\\n                startRow = i;\\n                startCol = j;\\n            }\\n            else if(!grid[i][j]) spaces++;\\n        }\\n    }\\n    \\n    return traverse(grid, startRow, startCol, rLimit, cLimit, spaces);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3617462,
                "title": "100-beats-c-dfs",
                "content": "# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int dfs(vector<vector<int>> &g, int i, int j, int s, int t_s)\\n    {\\n        if (i < 0 || j < 0 || i >= g.size() || j >= g[0].size() || g[i][j] == -1)\\n            return 0;\\n        if (g[i][j] == 2)\\n            return s == t_s ? 1 : 0;\\n        g[i][j] = -1;\\n        int paths = dfs(g, i + 1, j, s + 1, t_s) + dfs(g, i - 1, j, s + 1, t_s) +\\n                    dfs(g, i, j + 1, s + 1, t_s) + dfs(g, i, j - 1, s + 1, t_s);\\n        g[i][j] = 0;\\n        return paths;\\n    }\\n    int uniquePathsIII(vector<vector<int>> &g)\\n    {\\n        auto i1 = 0, j1 = 0, t_steps = 0;\\n        for (auto i = 0; i < g.size(); ++i)\\n            for (auto j = 0; j < g[0].size(); ++j)\\n            {\\n                if (g[i][j] == 1)\\n                    i1 = i, j1 = j;\\n                if (g[i][j] != -1)\\n                    ++t_steps;\\n            }\\n        return dfs(g, i1, j1, 1, t_steps);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int dfs(vector<vector<int>> &g, int i, int j, int s, int t_s)\\n    {\\n        if (i < 0 || j < 0 || i >= g.size() || j >= g[0].size() || g[i][j] == -1)\\n            return 0;\\n        if (g[i][j] == 2)\\n            return s == t_s ? 1 : 0;\\n        g[i][j] = -1;\\n        int paths = dfs(g, i + 1, j, s + 1, t_s) + dfs(g, i - 1, j, s + 1, t_s) +\\n                    dfs(g, i, j + 1, s + 1, t_s) + dfs(g, i, j - 1, s + 1, t_s);\\n        g[i][j] = 0;\\n        return paths;\\n    }\\n    int uniquePathsIII(vector<vector<int>> &g)\\n    {\\n        auto i1 = 0, j1 = 0, t_steps = 0;\\n        for (auto i = 0; i < g.size(); ++i)\\n            for (auto j = 0; j < g[0].size(); ++j)\\n            {\\n                if (g[i][j] == 1)\\n                    i1 = i, j1 = j;\\n                if (g[i][j] != -1)\\n                    ++t_steps;\\n            }\\n        return dfs(g, i1, j1, 1, t_steps);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310059,
                "title": "100-faster-make-a-counter-dfs-brute-force-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(int sr,int sc,int &er,int &ec,int &m,int &n,int &ans,vector<vector<int>> &g,int x,int k){\\n        if(sr<0||sc<0||sr>=m||sc>=n||g[sr][sc]==3||g[sr][sc]==-1){\\n            return;\\n        }\\n        if(sr==er&&sc==ec){\\n            if(k==-1)\\n            ans++;\\n            return;\\n        }\\n        g[sr][sc] = 3;\\n        solve(sr+1,sc,er,ec,m,n,ans,g,x,k-1);\\n        solve(sr,sc+1,er,ec,m,n,ans,g,x,k-1);\\n        solve(sr-1,sc,er,ec,m,n,ans,g,x,k-1);\\n        solve(sr,sc-1,er,ec,m,n,ans,g,x,k-1);\\n        g[sr][sc] = 0;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int i = 0, j = 0, m = grid.size(), n = grid[0].size(),sr,sc,er,ec,k=0;\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(grid[i][j]==1){\\n                    sr = i;\\n                    sc = j;\\n                }else if(grid[i][j] == 2){\\n                    er = i;\\n                    ec = j;\\n                }else if(grid[i][j]==0){\\n                    k++;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        solve(sr,sc,er,ec,m,n,ans,grid,0,k);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int sr,int sc,int &er,int &ec,int &m,int &n,int &ans,vector<vector<int>> &g,int x,int k){\\n        if(sr<0||sc<0||sr>=m||sc>=n||g[sr][sc]==3||g[sr][sc]==-1){\\n            return;\\n        }\\n        if(sr==er&&sc==ec){\\n            if(k==-1)\\n            ans++;\\n            return;\\n        }\\n        g[sr][sc] = 3;\\n        solve(sr+1,sc,er,ec,m,n,ans,g,x,k-1);\\n        solve(sr,sc+1,er,ec,m,n,ans,g,x,k-1);\\n        solve(sr-1,sc,er,ec,m,n,ans,g,x,k-1);\\n        solve(sr,sc-1,er,ec,m,n,ans,g,x,k-1);\\n        g[sr][sc] = 0;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int i = 0, j = 0, m = grid.size(), n = grid[0].size(),sr,sc,er,ec,k=0;\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(grid[i][j]==1){\\n                    sr = i;\\n                    sc = j;\\n                }else if(grid[i][j] == 2){\\n                    er = i;\\n                    ec = j;\\n                }else if(grid[i][j]==0){\\n                    k++;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        solve(sr,sc,er,ec,m,n,ans,grid,0,k);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229428,
                "title": "python-approch-99-beat",
                "content": "# Intuition\\n this is not really a hard problem you have first solve island perimeter question the approach this problem. -->\\nthis code beat 99%\\n\\n# Approach\\n   just using backtracking concept \\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n   it just taking stack memory not any extra memory O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        def infy(row,col,zero):\\n            if row < 0 or col < 0 or row >=m or col >= n or grid[row][col] == -1:\\n                return 0\\n            if grid[row][col] == 2:\\n                return 1 if zero == -1 else 0 \\n\\n            grid[row][col] = -1\\n            zero -= 1\\n            peri = infy(row+1,col,zero) +infy(row,col+1,zero) + infy(row-1,col,zero)+infy(row,col-1,zero)\\n            grid[row][col] = 1\\n            zero += 1\\n            return peri\\n\\n        x ,y,zero = 0,0,0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 0:\\n                    zero+=1\\n                elif grid[i][j] == 1:\\n                    x = i\\n                    y = j\\n        return infy(x,y,zero)\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        def infy(row,col,zero):\\n            if row < 0 or col < 0 or row >=m or col >= n or grid[row][col] == -1:\\n                return 0\\n            if grid[row][col] == 2:\\n                return 1 if zero == -1 else 0 \\n\\n            grid[row][col] = -1\\n            zero -= 1\\n            peri = infy(row+1,col,zero) +infy(row,col+1,zero) + infy(row-1,col,zero)+infy(row,col-1,zero)\\n            grid[row][col] = 1\\n            zero += 1\\n            return peri\\n\\n        x ,y,zero = 0,0,0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 0:\\n                    zero+=1\\n                elif grid[i][j] == 1:\\n                    x = i\\n                    y = j\\n        return infy(x,y,zero)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221990,
                "title": "java-using-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static int count=0;\\n    static int[] dx = {-1, 0, 1, 0};\\n    static int[] dy = {0, 1, 0, -1};\\n    public int uniquePathsIII(int[][] grid) {\\n        int zero = 0; \\n        int sx = 0; \\n        int sy = 0; \\n        int m=grid.length;\\n        int n=grid[0].length;\\n        boolean v[][]=new boolean[m][n];\\n        for(int r = 0; r < grid.length; r++){ \\n            for(int c = 0; c < grid[0].length; c++){ \\n                if(grid[r][c] == 0) zero++;\\n                else if(grid[r][c] == 1){\\n                    sx = r; \\n                    sy = c;\\n                }\\n                else if(grid[r][c]==-1){\\n                    v[r][c]=true;\\n                }\\n            }\\n        }\\n        count=0;\\n        backtrack(grid, sx, sy, zero,v);\\n        return count;\\n    }\\n    public void backtrack(int grid[][], int x, int y, int zero,boolean v[][]){\\n       \\n        if(x < 0 || y < 0 || x >= grid.length || y >= grid[0].length \\n         ||v[x][y]) return ;\\n\\n        if(grid[x][y] == 2 && zero==-1)\\n        {\\n           count++;\\n           return;\\n        }\\n\\n        v[x][y]=true;\\n        zero--; \\n        // up right down left\\n        for (int i = 0; i < 4; i++) {\\n            int nx = x + dx[i];\\n            int ny = y + dy[i];\\n            backtrack(grid,nx,ny,zero,v);\\n        }\\n       \\n        v[x][y]=false;\\n        zero++;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int count=0;\\n    static int[] dx = {-1, 0, 1, 0};\\n    static int[] dy = {0, 1, 0, -1};\\n    public int uniquePathsIII(int[][] grid) {\\n        int zero = 0; \\n        int sx = 0; \\n        int sy = 0; \\n        int m=grid.length;\\n        int n=grid[0].length;\\n        boolean v[][]=new boolean[m][n];\\n        for(int r = 0; r < grid.length; r++){ \\n            for(int c = 0; c < grid[0].length; c++){ \\n                if(grid[r][c] == 0) zero++;\\n                else if(grid[r][c] == 1){\\n                    sx = r; \\n                    sy = c;\\n                }\\n                else if(grid[r][c]==-1){\\n                    v[r][c]=true;\\n                }\\n            }\\n        }\\n        count=0;\\n        backtrack(grid, sx, sy, zero,v);\\n        return count;\\n    }\\n    public void backtrack(int grid[][], int x, int y, int zero,boolean v[][]){\\n       \\n        if(x < 0 || y < 0 || x >= grid.length || y >= grid[0].length \\n         ||v[x][y]) return ;\\n\\n        if(grid[x][y] == 2 && zero==-1)\\n        {\\n           count++;\\n           return;\\n        }\\n\\n        v[x][y]=true;\\n        zero--; \\n        // up right down left\\n        for (int i = 0; i < 4; i++) {\\n            int nx = x + dx[i];\\n            int ny = y + dy[i];\\n            backtrack(grid,nx,ny,zero,v);\\n        }\\n       \\n        v[x][y]=false;\\n        zero++;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975900,
                "title": "c-begineer-friendly-easy-understanding-dfs-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/172yYUwdf-I\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n \\u2003int ans = 0;\\n    int nonObstacle = 1;\\n    // dfs from the starting position.\\n   void dfs(int i,int j,vector<vector<int>>&grid,int count){\\n    //    base condtion.\\n    if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() ||grid[i][j] == -1){\\n        return ;\\n    }\\n    if(grid[i][j] == 2){\\n        // if we got all the nonobstacle cover.\\n       if(count == nonObstacle){\\n            ans++;\\n       }\\n       return;\\n    }\\n\\n    // make current node visited.\\n    grid[i][j] = -1;\\n\\n    // Traversal.\\n    dfs(i+1,j,grid,count+1);\\n    dfs(i-1,j,grid,count+1);\\n    dfs(i,j+1,grid,count+1);\\n    dfs(i,j-1,grid,count+1);\\n\\n\\n    // backtracking make it non-visited.\\n    grid[i][j] = 0;\\n   }\\n\\n\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n\\n        // store the starting position.\\n        int startX = 0;\\n        int startY = 0;\\n        // find the starting location and number of non-obstacle square.\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++){\\n                // if we got the starting position.\\n                if(grid[i][j] == 1){startX = i; startY =j;}\\n                else if(grid[i][j] == 0){nonObstacle++;}\\n            }\\n        }\\n\\n        // call the dfs from the starting position.\\n        dfs(startX,startY,grid,0);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\u2003int ans = 0;\\n    int nonObstacle = 1;\\n    // dfs from the starting position.\\n   void dfs(int i,int j,vector<vector<int>>&grid,int count){\\n    //    base condtion.\\n    if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() ||grid[i][j] == -1){\\n        return ;\\n    }\\n    if(grid[i][j] == 2){\\n        // if we got all the nonobstacle cover.\\n       if(count == nonObstacle){\\n            ans++;\\n       }\\n       return;\\n    }\\n\\n    // make current node visited.\\n    grid[i][j] = -1;\\n\\n    // Traversal.\\n    dfs(i+1,j,grid,count+1);\\n    dfs(i-1,j,grid,count+1);\\n    dfs(i,j+1,grid,count+1);\\n    dfs(i,j-1,grid,count+1);\\n\\n\\n    // backtracking make it non-visited.\\n    grid[i][j] = 0;\\n   }\\n\\n\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n\\n        // store the starting position.\\n        int startX = 0;\\n        int startY = 0;\\n        // find the starting location and number of non-obstacle square.\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++){\\n                // if we got the starting position.\\n                if(grid[i][j] == 1){startX = i; startY =j;}\\n                else if(grid[i][j] == 0){nonObstacle++;}\\n            }\\n        }\\n\\n        // call the dfs from the starting position.\\n        dfs(startX,startY,grid,0);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974790,
                "title": "c-and-java-solution",
                "content": "# BruteForce DFS+BackTracking Soluion\\n\\n# Java Code\\n```\\nclass Solution {\\n    private int dfs(int[][] grid, int x, int y, int zero){\\n        if(x>=grid.length || y >= grid[0].length || x<0 || y<0 || grid[x][y]==-1) return 0;\\n        if(grid[x][y]==2){\\n            return (zero==-1) ? 1 : 0;\\n        }\\n        grid[x][y]=-1;\\n        zero--;\\n        int totpath = dfs(grid, x+1, y, zero) + dfs(grid, x, y+1, zero) + dfs(grid, x-1, y, zero) + dfs(grid, x, y-1, zero);\\n        grid[x][y]=0;\\n        zero++;\\n        return totpath;\\n\\n    }\\n    public int uniquePathsIII(int[][] grid) {\\n        int zero=0, sx=0, sy=0;\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j]==0)zero++;\\n                if(grid[i][j]==1){\\n                    sx=i;\\n                    sy=j;\\n                }\\n            }\\n        }\\n        return dfs(grid, sx, sy, zero);\\n    }\\n}\\n```\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& grid, int x, int y, int zero){\\n        if(x>=grid.size() || y >= grid[0].size() || x<0 || y<0 || grid[x][y]==-1) return 0;\\n        if(grid[x][y]==2){\\n            return (zero==-1) ? 1 : 0;\\n        }\\n        grid[x][y]=-1;\\n        zero--;\\n        int totpath = dfs(grid, x+1, y, zero) + dfs(grid, x, y+1, zero) + dfs(grid, x-1, y, zero) + dfs(grid, x, y-1, zero);\\n        grid[x][y]=0;\\n        zero++;\\n        return totpath;\\n\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int zero=0, sx, sy;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j]==0)zero++;\\n                if(grid[i][j]==1){\\n                    sx=i;\\n                    sy=j;\\n                }\\n            }\\n        }\\n        return dfs(grid, sx, sy, zero);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private int dfs(int[][] grid, int x, int y, int zero){\\n        if(x>=grid.length || y >= grid[0].length || x<0 || y<0 || grid[x][y]==-1) return 0;\\n        if(grid[x][y]==2){\\n            return (zero==-1) ? 1 : 0;\\n        }\\n        grid[x][y]=-1;\\n        zero--;\\n        int totpath = dfs(grid, x+1, y, zero) + dfs(grid, x, y+1, zero) + dfs(grid, x-1, y, zero) + dfs(grid, x, y-1, zero);\\n        grid[x][y]=0;\\n        zero++;\\n        return totpath;\\n\\n    }\\n    public int uniquePathsIII(int[][] grid) {\\n        int zero=0, sx=0, sy=0;\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j]==0)zero++;\\n                if(grid[i][j]==1){\\n                    sx=i;\\n                    sy=j;\\n                }\\n            }\\n        }\\n        return dfs(grid, sx, sy, zero);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& grid, int x, int y, int zero){\\n        if(x>=grid.size() || y >= grid[0].size() || x<0 || y<0 || grid[x][y]==-1) return 0;\\n        if(grid[x][y]==2){\\n            return (zero==-1) ? 1 : 0;\\n        }\\n        grid[x][y]=-1;\\n        zero--;\\n        int totpath = dfs(grid, x+1, y, zero) + dfs(grid, x, y+1, zero) + dfs(grid, x-1, y, zero) + dfs(grid, x, y-1, zero);\\n        grid[x][y]=0;\\n        zero++;\\n        return totpath;\\n\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int zero=0, sx, sy;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j]==0)zero++;\\n                if(grid[i][j]==1){\\n                    sx=i;\\n                    sy=j;\\n                }\\n            }\\n        }\\n        return dfs(grid, sx, sy, zero);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974419,
                "title": "100-faster-approach-backtrack-recursion-c",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(4^n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<vector<int>>& grid,int zeroCount){\\n             int m=grid.size(),n=grid[0].size();\\n             if(i>=m || j>=n ||i<0 || j<0 || grid[i][j]==-1 )return 0;\\n             if(grid[i][j]==2){\\n                 return (zeroCount==-1)?1:0;\\n             }\\n            \\n            grid[i][j]=-1;\\n            zeroCount--;\\n            int totalPaths=solve(i,j+1,grid,zeroCount)+\\n            solve(i,j-1,grid,zeroCount)+\\n            solve(i+1,j,grid,zeroCount)+\\n            solve(i-1,j,grid,zeroCount);\\n            grid[i][j]=0;\\n            return totalPaths;\\n           \\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int ans=0,i,j,m=grid.size(),n=grid[0].size(),zeroCount=0;\\n        int i_st,j_st;\\n        for(i=0;i<m;i++){\\n            for(j=0;j<n;j++){\\n                if(grid[i][j]==0)zeroCount++;\\n                if(grid[i][j]==1){i_st=i;j_st=j;}\\n            }\\n        }\\n        return solve(i_st,j_st,grid,zeroCount);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<vector<int>>& grid,int zeroCount){\\n             int m=grid.size(),n=grid[0].size();\\n             if(i>=m || j>=n ||i<0 || j<0 || grid[i][j]==-1 )return 0;\\n             if(grid[i][j]==2){\\n                 return (zeroCount==-1)?1:0;\\n             }\\n            \\n            grid[i][j]=-1;\\n            zeroCount--;\\n            int totalPaths=solve(i,j+1,grid,zeroCount)+\\n            solve(i,j-1,grid,zeroCount)+\\n            solve(i+1,j,grid,zeroCount)+\\n            solve(i-1,j,grid,zeroCount);\\n            grid[i][j]=0;\\n            return totalPaths;\\n           \\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int ans=0,i,j,m=grid.size(),n=grid[0].size(),zeroCount=0;\\n        int i_st,j_st;\\n        for(i=0;i<m;i++){\\n            for(j=0;j<n;j++){\\n                if(grid[i][j]==0)zeroCount++;\\n                if(grid[i][j]==1){i_st=i;j_st=j;}\\n            }\\n        }\\n        return solve(i_st,j_st,grid,zeroCount);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974129,
                "title": "100-0ms-pruning-consice-explain-proof",
                "content": "# UPVOTE PLS\\n\\n![image.png](https://assets.leetcode.com/users/images/fc731627-2269-435b-9061-204a5e14cbc5_1672467688.743408.png)\\n\\n# EXPLAINATION \\nFirst find out where the start and the end is.\\nAlso We need to know the number of empty cells.\\n\\nWe we try to explore a cell,\\nit will change 0 to -1 and do a dfs in 4 direction.\\n\\nIf we hit the target and pass all empty cells, increment the result.\\n\\n# Code\\n```\\n    int res=0,em=1,sx,sy,ex,ey,m=0,n=0;\\n    public int uniquePathsIII(int[][] G) {\\n        m=G.length;n=G[0].length;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++){\\n                if(G[i][j]==0) em++;\\n                else if(G[i][j]==1){\\n                    sx=i; sy=j;\\n                }\\n            }\\n        dfs(G,sx,sy);\\n        return res;\\n    }\\n    private void dfs(int G[][],int x,int y){\\n        if(x<0||x>=m || y<0 || y>=n || G[x][y]<0) return;\\n        if(G[x][y]==2){\\n            if(em==0) res++;\\n            return;\\n        }\\n        G[x][y]=-1;\\n        em--;\\n        dfs(G,x+1,y); dfs(G,x-1,y); dfs(G,x,y+1); dfs(G,x,y-1); \\n        G[x][y]=0;\\n        em++;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    int res=0,em=1,sx,sy,ex,ey,m=0,n=0;\\n    public int uniquePathsIII(int[][] G) {\\n        m=G.length;n=G[0].length;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++){\\n                if(G[i][j]==0) em++;\\n                else if(G[i][j]==1){\\n                    sx=i; sy=j;\\n                }\\n            }\\n        dfs(G,sx,sy);\\n        return res;\\n    }\\n    private void dfs(int G[][],int x,int y){\\n        if(x<0||x>=m || y<0 || y>=n || G[x][y]<0) return;\\n        if(G[x][y]==2){\\n            if(em==0) res++;\\n            return;\\n        }\\n        G[x][y]=-1;\\n        em--;\\n        dfs(G,x+1,y); dfs(G,x-1,y); dfs(G,x,y+1); dfs(G,x,y-1); \\n        G[x][y]=0;\\n        em++;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2974067,
                "title": "beats-92-codedominar-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        rows,cols = len(grid),len(grid[0])\\n        sr, sc, zeros = [(r, c, sum(1 for row in grid for element in row if element == 0)) for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c] == 1][0]\\n        def dfs(r,c,zeros):\\n            if r not in range(rows) or c not in range(cols) or grid[r][c] == -1:\\n                return 0\\n            if grid[r][c] == 2:\\n                return 1 if zeros == -1 else 0\\n            grid[r][c] = -1\\n            zeros-=1\\n            ans = (dfs(r+1,c,zeros) + dfs(r,c+1,zeros) + dfs(r-1,c,zeros) + dfs(r,c-1,zeros))\\n            grid[r][c] = 0\\n            zeros+=1\\n            return ans\\n        return dfs(sr,sc,zeros)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        rows,cols = len(grid),len(grid[0])\\n        sr, sc, zeros = [(r, c, sum(1 for row in grid for element in row if element == 0)) for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c] == 1][0]\\n        def dfs(r,c,zeros):\\n            if r not in range(rows) or c not in range(cols) or grid[r][c] == -1:\\n                return 0\\n            if grid[r][c] == 2:\\n                return 1 if zeros == -1 else 0\\n            grid[r][c] = -1\\n            zeros-=1\\n            ans = (dfs(r+1,c,zeros) + dfs(r,c+1,zeros) + dfs(r-1,c,zeros) + dfs(r,c-1,zeros))\\n            grid[r][c] = 0\\n            zeros+=1\\n            return ans\\n        return dfs(sr,sc,zeros)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974016,
                "title": "easy-standard-c-backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int f(int row,int col,int steps,vector<vector<int>>&grid,int totStepsCnt)\\n    {\\n        \\n        if(grid[row][col]==2 ) \\n        {\\n            return steps==totStepsCnt;\\n        }\\n        \\n        int orig=grid[row][col];\\n        grid[row][col]=-1;\\n        \\n        int dr[]={-1,0,+1,0};\\n        int dc[]={0,+1,0,-1};\\n        int paths=0;\\n        for(int i=0;i<4;i++)\\n        {\\n                int nrow=row+dr[i];\\n                int ncol=col+dc[i];\\n                \\n                if(nrow<grid.size() && ncol<grid[0].size() && grid[nrow][ncol]!=-1)\\n                {\\n                    paths+=f(nrow,ncol,steps+1,grid,totStepsCnt);    \\n                }\\n        }\\n        \\n        grid[row][col]=orig;\\n            \\n        return paths;\\n        \\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n        int i,j;//start point\\n        int stepCnt=0;\\n        for(int row=0;row<grid.size();row++)\\n        {\\n            for(int col=0;col<grid[0].size();col++)\\n            {\\n                if(grid[row][col]==1)\\n                {\\n                    i=row;\\n                    j=col;\\n                }\\n                if(grid[row][col]!=-1) stepCnt++;\\n            }\\n        }\\n        \\n        \\n        return f(i,j,1,grid,stepCnt);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int f(int row,int col,int steps,vector<vector<int>>&grid,int totStepsCnt)\\n    {\\n        \\n        if(grid[row][col]==2 ) \\n        {\\n            return steps==totStepsCnt;\\n        }\\n        \\n        int orig=grid[row][col];\\n        grid[row][col]=-1;\\n        \\n        int dr[]={-1,0,+1,0};\\n        int dc[]={0,+1,0,-1};\\n        int paths=0;\\n        for(int i=0;i<4;i++)\\n        {\\n                int nrow=row+dr[i];\\n                int ncol=col+dc[i];\\n                \\n                if(nrow<grid.size() && ncol<grid[0].size() && grid[nrow][ncol]!=-1)\\n                {\\n                    paths+=f(nrow,ncol,steps+1,grid,totStepsCnt);    \\n                }\\n        }\\n        \\n        grid[row][col]=orig;\\n            \\n        return paths;\\n        \\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n        int i,j;//start point\\n        int stepCnt=0;\\n        for(int row=0;row<grid.size();row++)\\n        {\\n            for(int col=0;col<grid[0].size();col++)\\n            {\\n                if(grid[row][col]==1)\\n                {\\n                    i=row;\\n                    j=col;\\n                }\\n                if(grid[row][col]!=-1) stepCnt++;\\n            }\\n        }\\n        \\n        \\n        return f(i,j,1,grid,stepCnt);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973564,
                "title": "easy-to-understand-backtracking-dfs",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/hard/backtracking/UniquePathsIII.java",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2973353,
                "title": "c-simple-dfs-easy-to-understand-100-accepted",
                "content": "# Complexity\\n- ***Time Complexity*** : **O(3^m * n)** At every cell (except the start cell), we can continue the path exploration in 3 direction (after excuding previous visited cell) and there can be O(m*n) cells in total to be visited.\\n\\n- ***Space Complexity*** : **O(m*n)** required for implicit recursive stack in dfs.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m, n, startx, starty, endx, endy, viscount = 0, ans = 0;\\n    vector<int> dirx = {1, 0, -1, 0}, diry = {0, 1, 0, -1};\\n    vector<vector<bool>> visited;\\n\\n    void dfs(int x, int y) {\\n        if (x == endx and y == endy) {\\n            if (viscount == m * n - 1) ans++;\\n            return;\\n        }\\n        viscount++;\\n        visited[y][x] = true;\\n        for (int i = 0; i < 4; i++) {\\n            int newx = x + dirx[i], newy = y + diry[i];\\n            if ((newx < 0 or newx >= n) or (newy < 0 or newy >= m)) \\n            continue;\\n            if (not visited[newy][newx]) \\n            dfs(newx, newy);\\n        }\\n        viscount--;\\n        visited[y][x] = false;\\n        return;\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        visited.resize(m, vector<bool>(n));\\n        for (int y = 0; y < m; y++) {\\n            for (int x = 0; x < n; x++) {\\n                if (grid[y][x] == -1) {\\n                    viscount++;\\n                    visited[y][x] = true;\\n                }\\n                else if (grid[y][x] == 1) {\\n                    startx = x;\\n                    starty = y;\\n                }\\n                else if (grid[y][x] == 2) {\\n                    endx = x;\\n                    endy = y;\\n                }\\n            }\\n        }\\n        dfs(startx, starty);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n, startx, starty, endx, endy, viscount = 0, ans = 0;\\n    vector<int> dirx = {1, 0, -1, 0}, diry = {0, 1, 0, -1};\\n    vector<vector<bool>> visited;\\n\\n    void dfs(int x, int y) {\\n        if (x == endx and y == endy) {\\n            if (viscount == m * n - 1) ans++;\\n            return;\\n        }\\n        viscount++;\\n        visited[y][x] = true;\\n        for (int i = 0; i < 4; i++) {\\n            int newx = x + dirx[i], newy = y + diry[i];\\n            if ((newx < 0 or newx >= n) or (newy < 0 or newy >= m)) \\n            continue;\\n            if (not visited[newy][newx]) \\n            dfs(newx, newy);\\n        }\\n        viscount--;\\n        visited[y][x] = false;\\n        return;\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        visited.resize(m, vector<bool>(n));\\n        for (int y = 0; y < m; y++) {\\n            for (int x = 0; x < n; x++) {\\n                if (grid[y][x] == -1) {\\n                    viscount++;\\n                    visited[y][x] = true;\\n                }\\n                else if (grid[y][x] == 1) {\\n                    startx = x;\\n                    starty = y;\\n                }\\n                else if (grid[y][x] == 2) {\\n                    endx = x;\\n                    endy = y;\\n                }\\n            }\\n        }\\n        dfs(startx, starty);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940184,
                "title": "easy-backtracking-recursive-solution-0ms-100-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int zeroes = 1;\\n    int totalPath = 0;\\n\\n    void dfs(int[][] grid, int x, int y){\\n\\n        if(x<0 || x>=grid.length || y<0 || y>= grid[0].length || grid[x][y] <0)\\n            return;\\n        \\n        if(grid[x][y] == 2){\\n            if(zeroes == 0) totalPath++;\\n            return;\\n        }\\n        grid[x][y] = -2;\\n        zeroes--;\\n\\n        dfs(grid, x+1, y);\\n        dfs(grid, x-1, y);\\n        dfs(grid, x, y+1);\\n        dfs(grid, x, y-1);\\n        grid[x][y] = 0;\\n        zeroes++;\\n    }\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        int sr = 0, sc = 0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] == 0)\\n                    zeroes++;\\n                else if(grid[i][j] == 1){\\n                    sr = i;\\n                    sc = j;\\n                }\\n            }\\n        }\\n        dfs(grid, sr, sc);\\n        return totalPath;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    int zeroes = 1;\\n    int totalPath = 0;\\n\\n    void dfs(int[][] grid, int x, int y){\\n\\n        if(x<0 || x>=grid.length || y<0 || y>= grid[0].length || grid[x][y] <0)\\n            return;\\n        \\n        if(grid[x][y] == 2){\\n            if(zeroes == 0) totalPath++;\\n            return;\\n        }\\n        grid[x][y] = -2;\\n        zeroes--;\\n\\n        dfs(grid, x+1, y);\\n        dfs(grid, x-1, y);\\n        dfs(grid, x, y+1);\\n        dfs(grid, x, y-1);\\n        grid[x][y] = 0;\\n        zeroes++;\\n    }\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        int sr = 0, sc = 0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] == 0)\\n                    zeroes++;\\n                else if(grid[i][j] == 1){\\n                    sr = i;\\n                    sc = j;\\n                }\\n            }\\n        }\\n        dfs(grid, sr, sc);\\n        return totalPath;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2865796,
                "title": "9ms-easy-understand-dfs-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int dfs(vector<vector<int>> &g, int i, int j, int s, int t_s)\\n    {\\n        if (i < 0 || j < 0 || i >= g.size() || j >= g[0].size() || g[i][j] == -1)\\n            return 0;\\n        if (g[i][j] == 2)\\n            return s == t_s ? 1 : 0;\\n        g[i][j] = -1;\\n        int paths = dfs(g, i + 1, j, s + 1, t_s) + dfs(g, i - 1, j, s + 1, t_s) +\\n                    dfs(g, i, j + 1, s + 1, t_s) + dfs(g, i, j - 1, s + 1, t_s);\\n        g[i][j] = 0;\\n        return paths;\\n    }\\n    int uniquePathsIII(vector<vector<int>> &g)\\n    {\\n        auto i1 = 0, j1 = 0, t_steps = 0;\\n        for (auto i = 0; i < g.size(); ++i)\\n            for (auto j = 0; j < g[0].size(); ++j)\\n            {\\n                if (g[i][j] == 1)\\n                    i1 = i, j1 = j;\\n                if (g[i][j] != -1)\\n                    ++t_steps;\\n            }\\n        return dfs(g, i1, j1, 1, t_steps);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int dfs(vector<vector<int>> &g, int i, int j, int s, int t_s)\\n    {\\n        if (i < 0 || j < 0 || i >= g.size() || j >= g[0].size() || g[i][j] == -1)\\n            return 0;\\n        if (g[i][j] == 2)\\n            return s == t_s ? 1 : 0;\\n        g[i][j] = -1;\\n        int paths = dfs(g, i + 1, j, s + 1, t_s) + dfs(g, i - 1, j, s + 1, t_s) +\\n                    dfs(g, i, j + 1, s + 1, t_s) + dfs(g, i, j - 1, s + 1, t_s);\\n        g[i][j] = 0;\\n        return paths;\\n    }\\n    int uniquePathsIII(vector<vector<int>> &g)\\n    {\\n        auto i1 = 0, j1 = 0, t_steps = 0;\\n        for (auto i = 0; i < g.size(); ++i)\\n            for (auto j = 0; j < g[0].size(); ++j)\\n            {\\n                if (g[i][j] == 1)\\n                    i1 = i, j1 = j;\\n                if (g[i][j] != -1)\\n                    ++t_steps;\\n            }\\n        return dfs(g, i1, j1, 1, t_steps);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775551,
                "title": "python-easy-solution-dfs-backtracking",
                "content": "# Intuition\\nThis is a Game !! \\uD83E\\uDD16\\nIn simpler words, we need to find the count of possible paths for a robot to reach from starting to ending point without encountering a obstacle.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst of all, lets calculate the starting position, ending position and total number of empty cells present in the grid. And using Depth First Search (DFS) algorithm and Backtracking, we can check the possible paths having no obstacles and add find the valid path using visited set. If a valid path is found, then increment the output.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N\\xB2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n\\n        start_row,start_col,end_row,end_col = 0,0,0,0\\n        empty_cells = 0\\n\\n        # Traversing the grid to find the start and end index\\n        for i in range(0,rows):\\n            for j in range(0,cols):\\n                if (grid[i][j] == 1):\\n                    start_row,start_col = i,j\\n                elif (grid[i][j] == 2):\\n                    end_row,end_col = i,j\\n                elif (grid[i][j] == 0):\\n                    empty_cells += 1\\n        \\n        self.output = 0\\n        visited = set()\\n\\n        def dfs(r,c,visited,walk):\\n            if (r == end_row and c == end_col):\\n                if (walk == empty_cells+1):\\n                    self.output += 1  # Path found\\n                return\\n\\n            if (0<= r < rows and 0<= c < cols and grid[r][c] != -1 and (r,c) not in visited):\\n                visited.add((r,c))\\n                for i,j in [(0,-1),(0,1),(1,0),(-1,0)]:\\n                    dfs(r+i,c+j,visited,walk+1)\\n                visited.remove((r,c))\\n            \\n        dfs(start_row,start_col,visited,0)\\n\\n        return self.output\\n```\\n# Result\\n- Runtime: 150 ms beats 35%\\n- Memory: 14 MB beats 58%\\n\\n![image.png](https://assets.leetcode.com/users/images/6016c7e7-9769-45f0-9bb5-c98493be8fec_1667526533.989835.png)\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n\\n        start_row,start_col,end_row,end_col = 0,0,0,0\\n        empty_cells = 0\\n\\n        # Traversing the grid to find the start and end index\\n        for i in range(0,rows):\\n            for j in range(0,cols):\\n                if (grid[i][j] == 1):\\n                    start_row,start_col = i,j\\n                elif (grid[i][j] == 2):\\n                    end_row,end_col = i,j\\n                elif (grid[i][j] == 0):\\n                    empty_cells += 1\\n        \\n        self.output = 0\\n        visited = set()\\n\\n        def dfs(r,c,visited,walk):\\n            if (r == end_row and c == end_col):\\n                if (walk == empty_cells+1):\\n                    self.output += 1  # Path found\\n                return\\n\\n            if (0<= r < rows and 0<= c < cols and grid[r][c] != -1 and (r,c) not in visited):\\n                visited.add((r,c))\\n                for i,j in [(0,-1),(0,1),(1,0),(-1,0)]:\\n                    dfs(r+i,c+j,visited,walk+1)\\n                visited.remove((r,c))\\n            \\n        dfs(start_row,start_col,visited,0)\\n\\n        return self.output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2638005,
                "title": "c-python-backtracking-dfs",
                "content": "# C++\\n```\\nclass Solution {\\n    void dfs(int i, int j, vector<vector<int>>& grid, int e, int &ans) {\\n        if(i < 0 || i == grid.size() || j < 0 || j == grid[0].size() || grid[i][j] == -1) return;\\n        if(grid[i][j] == 2) {\\n            if(!e) ans++;\\n            return;\\n        }\\n        \\n        grid[i][j] = -1;\\n        dfs(i + 1, j, grid, e - 1, ans);\\n        dfs(i - 1, j, grid, e - 1, ans);\\n        dfs(i, j + 1, grid, e - 1, ans);\\n        dfs(i, j - 1, grid, e - 1, ans);\\n        grid[i][j] = 0;\\n    }\\n    \\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int e = 0, x, y, ans = 0;\\n        for(int i=0; i<grid.size(); i++) {\\n            for(int j=0; j<grid[0].size(); j++) {\\n                if(grid[i][j] == 1) x = i, y = j;\\n                else if(grid[i][j] == 0) e++;\\n            }\\n        }\\n        \\n        dfs(x, y, grid, e + 1, ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def uniquePathsIII(self, grid):\\n        e, x, y = 0, 0, 0\\n        self.ans = 0\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1: x, y = i, j\\n                elif not grid[i][j]: e += 1\\n        \\n        def dfs(i, j, e):\\n            if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]) or grid[i][j] == -1: return\\n            if grid[i][j] == 2:\\n                if not e: self.ans += 1\\n                return\\n            \\n            grid[i][j] = -1\\n            dfs(i + 1, j, e - 1)\\n            dfs(i - 1, j, e - 1)\\n            dfs(i, j + 1, e - 1)\\n            dfs(i, j - 1, e - 1)\\n            grid[i][j] = 0\\n        \\n        dfs(x, y, e + 1)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int i, int j, vector<vector<int>>& grid, int e, int &ans) {\\n        if(i < 0 || i == grid.size() || j < 0 || j == grid[0].size() || grid[i][j] == -1) return;\\n        if(grid[i][j] == 2) {\\n            if(!e) ans++;\\n            return;\\n        }\\n        \\n        grid[i][j] = -1;\\n        dfs(i + 1, j, grid, e - 1, ans);\\n        dfs(i - 1, j, grid, e - 1, ans);\\n        dfs(i, j + 1, grid, e - 1, ans);\\n        dfs(i, j - 1, grid, e - 1, ans);\\n        grid[i][j] = 0;\\n    }\\n    \\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int e = 0, x, y, ans = 0;\\n        for(int i=0; i<grid.size(); i++) {\\n            for(int j=0; j<grid[0].size(); j++) {\\n                if(grid[i][j] == 1) x = i, y = j;\\n                else if(grid[i][j] == 0) e++;\\n            }\\n        }\\n        \\n        dfs(x, y, grid, e + 1, ans);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def uniquePathsIII(self, grid):\\n        e, x, y = 0, 0, 0\\n        self.ans = 0\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1: x, y = i, j\\n                elif not grid[i][j]: e += 1\\n        \\n        def dfs(i, j, e):\\n            if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]) or grid[i][j] == -1: return\\n            if grid[i][j] == 2:\\n                if not e: self.ans += 1\\n                return\\n            \\n            grid[i][j] = -1\\n            dfs(i + 1, j, e - 1)\\n            dfs(i - 1, j, e - 1)\\n            dfs(i, j + 1, e - 1)\\n            dfs(i, j - 1, e - 1)\\n            grid[i][j] = 0\\n        \\n        dfs(x, y, e + 1)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522134,
                "title": "java-backtracking-recursion-1ms",
                "content": "class Solution {\\n    \\n    \\n    \\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int count  = 0,xpos = 0, ypos = 0 ;\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        \\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(grid[i][j] == 0){\\n                    count++;\\n                }\\n                else if(grid[i][j] == 1){\\n                    xpos = i;\\n                    ypos = j;\\n                }\\n            }\\n        }\\n        \\n        return helper(grid , xpos , ypos ,n , m, count);\\n    }\\n    \\n    public int helper(int[][]grid , int i , int j ,int n , int m, int count){\\n        \\n        if(i < 0 || i>=n || j<0 || j>=m || grid[i][j] == -1){\\n            return 0;\\n        }\\n        \\n        if(grid[i][j] == 2)return count == -1? 1 : 0;\\n        \\n        grid[i][j] = -1;\\n        count--;\\n        \\n        int top = helper(grid , i-1, j ,n , m , count);\\n        int down = helper(grid , i+1, j ,n , m , count);\\n        int left = helper(grid , i, j-1 ,n , m , count);\\n        int right = helper(grid , i, j+1 ,n , m , count);\\n        \\n        grid[i][j] = 0;\\n        \\n        return top+down+left+right;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\n    \\n    \\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int count  = 0,xpos = 0, ypos = 0 ;\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        \\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(grid[i][j] == 0){\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2476820,
                "title": "easy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int ie,je,m,n;\\n    \\n    int func(int i,int j,vector<vector<int>>&grid, vector<vector<int>>&vis,int t){\\n        if(i<0 || j<0 || i>=m || j>=n || grid[i][j]==-1 || vis[i][j])return 0;\\n        \\n        if(i==ie && j==je){\\n            return t==0;\\n        }\\n        \\n        vis[i][j]=1;\\n        \\n        int a=0;\\n        a=func(i+1,j,grid,vis,t-1)+func(i-1,j,grid,vis,t-1)+func(i,j+1,grid,vis,t-1)+func(i,j-1,grid,vis,t-1);\\n        \\n        vis[i][j]=0;\\n        return a;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n        m=grid.size(),n=grid[0].size();\\n        \\n        int is,js,t=0;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==2){\\n                    ie=i;\\n                    je=j;\\n                }\\n                \\n                if(grid[i][j]==1){\\n                    is=i;\\n                    js=j;\\n                }\\n                \\n                if(grid[i][j]==0)t++;\\n            }\\n        }\\n        \\n        vector<vector<int>>vis(m,vector<int>(n));\\n        return func(is,js,grid,vis,t+1);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int ie,je,m,n;\\n    \\n    int func(int i,int j,vector<vector<int>>&grid, vector<vector<int>>&vis,int t){\\n        if(i<0 || j<0 || i>=m || j>=n || grid[i][j]==-1 || vis[i][j])return 0;\\n        \\n        if(i==ie && j==je){\\n            return t==0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2425851,
                "title": "c-easiest-solution-faster-than-100-dfs-and-backtracking-0ms-with-comments",
                "content": "```\\nclass Solution {\\n    \\n      int startrow = 0, startcol = 0, count = 0, ans  = 0;\\n    \\n    \\n    void dfs(vector<vector<int>>& grid, int i , int j , int cellvisited)\\n    {\\n        if(i<0 || j<0 || i>= grid.size() || j>= grid[0].size() || grid[i][j] == -1 )\\n            return ;\\n        \\n        // If You Have come to ending Position \\n        if(grid[i][j] == 2 )\\n        {\\n            if(cellvisited == count)\\n                ans++;\\n            return ;\\n        }\\n        // Marking The Cell as Visited\\n        grid[i][j] = -1;\\n        \\n        // DFS Traversal in all possible direction\\n        dfs(grid, i+1 , j , cellvisited+1);\\n        dfs(grid, i-1 , j , cellvisited+1);\\n        dfs(grid, i , j+1 , cellvisited+1);\\n        dfs(grid, i , j-1 , cellvisited+1);\\n        \\n        // Backtracking\\n        grid[i][j] = 0;\\n    }\\n  \\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n      // Storing Starting Position, Ending Position and count of empty cell \\n        for(int i = 0 ; i<grid.size() ; i++)\\n        {\\n            for(int j = 0 ; j<grid[0].size() ; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                    startrow = i, startcol = j;\\n                else if(grid[i][j] == 0)\\n                    count++;\\n            }\\n        }\\n        \\n        //This is for starting cell\\n        count++;\\n        \\n        // Making Variable to store the count of visited cell in dfs traversal\\n        int cellvisited = 0;\\n        //Start\\n        dfs(grid, startrow, startcol, cellvisited);\\n        return ans;\\n    }\\n};\\n\\n//Pls upvote If you Like It\\n```\\n\\n![image](https://assets.leetcode.com/users/images/b7a72cac-101f-4bc1-b31c-7f99eb9fb33b_1660502121.285097.png)\\n\\n",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n      int startrow = 0, startcol = 0, count = 0, ans  = 0;\\n    \\n    \\n    void dfs(vector<vector<int>>& grid, int i , int j , int cellvisited)\\n    {\\n        if(i<0 || j<0 || i>= grid.size() || j>= grid[0].size() || grid[i][j] == -1 )\\n            return ;\\n        \\n        // If You Have come to ending Position \\n        if(grid[i][j] == 2 )\\n        {\\n            if(cellvisited == count)\\n                ans++;\\n            return ;\\n        }\\n        // Marking The Cell as Visited\\n        grid[i][j] = -1;\\n        \\n        // DFS Traversal in all possible direction\\n        dfs(grid, i+1 , j , cellvisited+1);\\n        dfs(grid, i-1 , j , cellvisited+1);\\n        dfs(grid, i , j+1 , cellvisited+1);\\n        dfs(grid, i , j-1 , cellvisited+1);\\n        \\n        // Backtracking\\n        grid[i][j] = 0;\\n    }\\n  \\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n      // Storing Starting Position, Ending Position and count of empty cell \\n        for(int i = 0 ; i<grid.size() ; i++)\\n        {\\n            for(int j = 0 ; j<grid[0].size() ; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                    startrow = i, startcol = j;\\n                else if(grid[i][j] == 0)\\n                    count++;\\n            }\\n        }\\n        \\n        //This is for starting cell\\n        count++;\\n        \\n        // Making Variable to store the count of visited cell in dfs traversal\\n        int cellvisited = 0;\\n        //Start\\n        dfs(grid, startrow, startcol, cellvisited);\\n        return ans;\\n    }\\n};\\n\\n//Pls upvote If you Like It\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420674,
                "title": "easy-and-naive-approach-c",
                "content": "Here, we have checked the all paths which lead us to result.\\n\\n\\n//THIS IS MY FIRST POST\\n\\nExplaination is given below with code \\n///\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    void helper(vector<vector<int>>&grid,int ri,int ci,int rd,int cd,string asf,int count,vector<vector<bool>> &check)\\n    {\\n        if(ri < 0 || ci < 0 || ri >= rd || ci >= cd || grid[ri][ci] == -1 || check[ri][ci] == true)  // boundary condition\\n            return;\\n        if(grid[ri][ci] == 2)\\n        {\\n            if(asf.size() == count) // if count is equal to path size the increment ans\\n            {\\n                ans++;\\n            }  \\n            return;\\n        }\\n        check[ri][ci] = true;\\n        helper(grid,ri+1,ci,rd,cd,asf + \"D\",count,check);\\n        helper(grid,ri-1,ci,rd,cd,asf + \"U\",count,check);\\n        helper(grid,ri,ci+1,rd,cd,asf + \"R\",count,check);\\n        helper(grid,ri,ci-1,rd,cd,asf + \"L\",count,check);\\n        check[ri][ci] = false;\\n        \\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        \\n        int count = 0;    //To count the number of blocks to be covered\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int ri=0,ci=0;       // To get the starting index of the block \\n        \\n        vector<vector<bool>> check(m,vector<bool>(n,false));   // To check if we have visited that block on the grid  \\n        for(auto i = 0 ; i< m ; i++)\\n        {\\n            for(auto j = 0 ; j<n;j++)\\n            {\\n                if(grid[i][j] == 0)\\n                    count++;\\n                if(grid[i][j] == 1)\\n                {\\n                    ri = i;\\n                    ci = j;\\n                }\\n            }\\n        }\\n         helper(grid,ri,ci,m,n,\"\",count+1,check);     // Giving call with count +1 , where +1 is done because\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t //we have to consider the destination block too\\n         return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int ans = 0;\\n    \\n    void helper(vector<vector<int>>&grid,int ri,int ci,int rd,int cd,string asf,int count,vector<vector<bool>> &check)\\n    {\\n        if(ri < 0 || ci < 0 || ri >= rd || ci >= cd || grid[ri][ci] == -1 || check[ri][ci] == true)  // boundary condition\\n            return;\\n        if(grid[ri][ci] == 2)\\n        {\\n            if(asf.size() == count) // if count is equal to path size the increment ans\\n            {\\n                ans++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2409680,
                "title": "faster-than-100-00-of-c-online-submissions",
                "content": "int solve(vector<vector<int>>& arr,int i,int j,int &n,int &m,int k){\\n    if (i<0 || j<0 || i==n || j==m || arr[i][j]==-1)\\n    {\\n       return 0;\\n    }\\n    if (arr[i][j]==2)\\n    {\\n        if (k==0)\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n       int x=arr[i][j];\\n    arr[i][j]=-1;\\n    int ans=solve(arr,i-1,j,n,m,k-1);\\n        ans+=solve(arr,i,j+1,n,m,k-1);\\n       ans+=solve(arr,i,j-1,n,m,k-1);\\n    ans+=solve(arr,i+1,j,n,m,k-1);\\n    arr[i][j]=x;\\n   \\n    return ans;\\n    \\n    \\n    \\n}\\n int uniquePathsIII(vector<vector<int>>& arr) {\\n        int k=0,x=-1,y=-1;\\n        int n=arr.size();\\n        int m=arr[0].size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (arr[i][j]==0)\\n                {\\n                    k++;\\n                }\\n                if (arr[i][j]==1)\\n                {\\n                    x=i,y=j;\\n                }\\n                \\n                \\n            }\\n            \\n        }\\n        return solve(arr,x,y,n,m,k+1);\\n\\n        \\n    }",
                "solutionTags": [],
                "code": "int solve(vector<vector<int>>& arr,int i,int j,int &n,int &m,int k){\\n    if (i<0 || j<0 || i==n || j==m || arr[i][j]==-1)\\n    {\\n       return 0;\\n    }\\n    if (arr[i][j]==2)\\n    {\\n        if (k==0)\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n       int x=arr[i][j];\\n    arr[i][j]=-1;\\n    int ans=solve(arr,i-1,j,n,m,k-1);\\n        ans+=solve(arr,i,j+1,n,m,k-1);\\n       ans+=solve(arr,i,j-1,n,m,k-1);\\n    ans+=solve(arr,i+1,j,n,m,k-1);\\n    arr[i][j]=x;\\n   \\n    return ans;\\n    \\n    \\n    \\n}\\n int uniquePathsIII(vector<vector<int>>& arr) {\\n        int k=0,x=-1,y=-1;\\n        int n=arr.size();\\n        int m=arr[0].size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (arr[i][j]==0)\\n                {\\n                    k++;\\n                }\\n                if (arr[i][j]==1)\\n                {\\n                    x=i,y=j;\\n                }\\n                \\n                \\n            }\\n            \\n        }\\n        return solve(arr,x,y,n,m,k+1);\\n\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2159888,
                "title": "java-solution-using-backtracking",
                "content": "First find starting position and no of 0 positions . Now backtrack through every position and if you find 2 and count also becomes equal then increment answer.\\n```\\nclass Solution {\\n    int ans=0;\\n    public int uniquePathsIII(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int r=-1;\\n        int c=-1;\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    grid[i][j]=0;\\n                    r=i;\\n                    c=j;\\n                }\\n                if(grid[i][j]==0)count++;\\n            }\\n        }\\n        findPath(grid,r,c,n,m,count,0);\\n        return ans;\\n        \\n    }\\n    void findPath(int[][]grid,int row,int col,int n,int m,int count,int k){\\n        if(row<0||row>=n||col<0||col>=m||grid[row][col]==-1)return;\\n        if(grid[row][col]==2){\\n            if(count==k)\\n            ans++;\\n            return;\\n        }\\n        grid[row][col]=-1;\\n        findPath(grid,row+1,col,n,m,count,k+1);\\n        findPath(grid,row-1,col,n,m,count,k+1);\\n        findPath(grid,row,col+1,n,m,count,k+1);\\n        findPath(grid,row,col-1,n,m,count,k+1);\\n        grid[row][col]=0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int ans=0;\\n    public int uniquePathsIII(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int r=-1;\\n        int c=-1;\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    grid[i][j]=0;\\n                    r=i;\\n                    c=j;\\n                }\\n                if(grid[i][j]==0)count++;\\n            }\\n        }\\n        findPath(grid,r,c,n,m,count,0);\\n        return ans;\\n        \\n    }\\n    void findPath(int[][]grid,int row,int col,int n,int m,int count,int k){\\n        if(row<0||row>=n||col<0||col>=m||grid[row][col]==-1)return;\\n        if(grid[row][col]==2){\\n            if(count==k)\\n            ans++;\\n            return;\\n        }\\n        grid[row][col]=-1;\\n        findPath(grid,row+1,col,n,m,count,k+1);\\n        findPath(grid,row-1,col,n,m,count,k+1);\\n        findPath(grid,row,col+1,n,m,count,k+1);\\n        findPath(grid,row,col-1,n,m,count,k+1);\\n        grid[row][col]=0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2157068,
                "title": "java-detailed-explanation-of-backtracking-approach",
                "content": "## Problem\\n\\nGiven a grid containing a starting point, and ending point, and obstacles, return the number of ways to get from the starting point to the ending point visiting all squares in the grid once, and avoiding all obstacles. \\n\\n## Backtracking Approach\\n\\nThe best way to approach this problem is by using a DFS with backtracking. In order to perform the DFS, we need to know where to start, and how many empty cells there are in the board. The reason we need this is because when our DFS reaches the ending point, the path we have found is only valid if we have visited all open cells before we reached the end cell, so if we know how many open cells there are, we can tell if a path is valid. So before we call the recursive method, we go through `grid`, find the starting position, and count the number of open cells. After we have done so, we make the initial recursive call.\\n\\nOur DFS takes in 4 parameters: `row` and `col` being the row and column respectively of our current cell in `grid`, the grid `grid`, and an integer `count` being the number of cells that we have found in our path. \\n\\nIn this DFS, to avoid having to use an external array to mark visited cells, we can use `grid` itself. Plus, since we are backtracking and we have to unmark visited cells, after all the recursive calls are done, `grid` will be left unchanged. How we can use `grid` to mark visited cells is if we run into an open cell (i.e. a `0`), we change its value to `-1`. This essentially puts an obstacle at this cell so in later recursive calls, we can not revisit this cell. \\n\\nThe base case of our DFS occurs when either `[row][col]` is outside the grid, or `grid[row][col]` is an obstacle (i.e. `-1`). Since we used `-1` to mark visited cells, seeing if the cell has been visited is the same thing as checking if there is an obstacle there. In any of these cases, we can not continue our DFS, so we return to the previous recursive call. The other of bases case we need to check is if we have reached the ending point (`grid[row][col] = 2`). At this point, we check if `count` is equal to the number of open cells, if so, then we have found a valid path, so we increment a counter variable (say `numPaths`), if not, we do nothing.\\n\\n If none of these base cases are met, we mark `[row][col]` as visited by setting its value to `-1`, then call DFS on all 4 directions, passing in `count + 1` since we have found a new cell. Once these recursive calls come back, we unmark cell `[row][col]` by setting its value to `0` (i.e. removing the obstacle we put there), then return to the previous recursive call. In the end, `numPaths` will have the total number of valid paths from our starting point to the end point. \\n\\n## Code\\n\\n**Java**\\n\\n```java\\nclass Solution {\\n    int m; //number of rows in grid\\n    int n; //number of columns in grid\\n    int openSquares; //number of open cells in grid\\n    int numPaths; //number of valid paths from the starting point to the ending point\\n    public int uniquePathsIII(int[][] grid) {\\n        int startRow = 0;\\n        int startCol = 0;\\n        int count = 0;\\n        \\n        m = grid.length;\\n        n = grid[0].length;\\n        \\n        //find the starting point and count the number of open cells\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 1){ //found the starting point, which is also an open cell\\n                    startRow = i;\\n                    startCol = j;\\n                    openSquares++;\\n                }else if(grid[i][j] == 0){ //found an open cell\\n                    openSquares++;\\n                }        \\n            }\\n        }\\n        //note: the reason we do not consider the end point as an open cell is because we terminate our \\n        //      search at that point and don\\'t increase our counter\\n        \\n        dfs(startRow, startCol, grid, 0);\\n        return numPaths;\\n    }\\n    \\n    private void dfs(int row, int col, int[][] grid, int count){\\n        //base case --> if [row][col] is outside of grid, is an obstacle cell or has been visited\\n        //              (means the same as an obstacle), we stop our DFS and return to the previous recursive call\\n        if(row < 0 || row > m-1 || col < 0 || col > n-1 || grid[row][col] == -1){\\n            return;\\n        }\\n        \\n        //base case --> if we reached our endpoint, and we have visited all open cells, we increment numPaths before\\n        //              returning, otherwise, we just return since the path was invalid\\n        if(grid[row][col] == 2){\\n            if(count == openSquares){\\n                numPaths++;\\n            }\\n            return;\\n        }\\n        \\n        //mark the current cell as visited by essentially placing an obstacle there\\n        grid[row][col] = -1;\\n        \\n        //call the dfs on all 4 adjacent cells, passing in count + 1 since we visited a new cell\\n        dfs(row-1, col, grid, count + 1);\\n        dfs(row+1, col, grid, count + 1);\\n        dfs(row, col-1, grid, count + 1);\\n        dfs(row, col+1, grid, count + 1);\\n        \\n        //unmark the current cell by essentially removing the obstacle\\n        grid[row][col] = 0;\\n    }\\n}\\n```\\n\\n## Time and Space Complexity\\n\\nTime Complexity: `O(3^(mn))`\\n\\nWe will be making 3 recursive calls at each cell (recursive call for the direction we came from will lead to a base case), of which there are `mn` of them\\n\\nSpace Complexity: `O(mn)`\\n\\nSince we are not using any external data structures, our space complexity is the max depth of the recursion tree (i.e. `mn`)\\n  \\n    \\n\\t\\n**Please Upvote** if you find this helpful!!",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```java\\nclass Solution {\\n    int m; //number of rows in grid\\n    int n; //number of columns in grid\\n    int openSquares; //number of open cells in grid\\n    int numPaths; //number of valid paths from the starting point to the ending point\\n    public int uniquePathsIII(int[][] grid) {\\n        int startRow = 0;\\n        int startCol = 0;\\n        int count = 0;\\n        \\n        m = grid.length;\\n        n = grid[0].length;\\n        \\n        //find the starting point and count the number of open cells\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 1){ //found the starting point, which is also an open cell\\n                    startRow = i;\\n                    startCol = j;\\n                    openSquares++;\\n                }else if(grid[i][j] == 0){ //found an open cell\\n                    openSquares++;\\n                }        \\n            }\\n        }\\n        //note: the reason we do not consider the end point as an open cell is because we terminate our \\n        //      search at that point and don\\'t increase our counter\\n        \\n        dfs(startRow, startCol, grid, 0);\\n        return numPaths;\\n    }\\n    \\n    private void dfs(int row, int col, int[][] grid, int count){\\n        //base case --> if [row][col] is outside of grid, is an obstacle cell or has been visited\\n        //              (means the same as an obstacle), we stop our DFS and return to the previous recursive call\\n        if(row < 0 || row > m-1 || col < 0 || col > n-1 || grid[row][col] == -1){\\n            return;\\n        }\\n        \\n        //base case --> if we reached our endpoint, and we have visited all open cells, we increment numPaths before\\n        //              returning, otherwise, we just return since the path was invalid\\n        if(grid[row][col] == 2){\\n            if(count == openSquares){\\n                numPaths++;\\n            }\\n            return;\\n        }\\n        \\n        //mark the current cell as visited by essentially placing an obstacle there\\n        grid[row][col] = -1;\\n        \\n        //call the dfs on all 4 adjacent cells, passing in count + 1 since we visited a new cell\\n        dfs(row-1, col, grid, count + 1);\\n        dfs(row+1, col, grid, count + 1);\\n        dfs(row, col-1, grid, count + 1);\\n        dfs(row, col+1, grid, count + 1);\\n        \\n        //unmark the current cell by essentially removing the obstacle\\n        grid[row][col] = 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2150439,
                "title": "simple-golang-solution-with-backtracking-beats-100",
                "content": "```\\nfunc uniquePathsIII(grid [][]int) int {\\n    \\n    remaining := 0\\n    startX := 0 \\n    startY := 0 \\n    \\n    for i:=0 ; i<len(grid); i++ {\\n        for j:=0 ; j<len(grid[i]); j++ {\\n            if grid[i][j] == 0 {\\n                remaining += 1\\n            } else if grid[i][j] == 1 {\\n                startX = i\\n                startY = j\\n            }\\n        }\\n    }\\n    \\n\\n    \\n    return uniquePathHelper(grid, remaining, startX, startY)\\n    \\n}\\n\\nfunc uniquePathHelper(grid [][]int, remaining, i, j int) int {\\n    result := 0\\n    \\n    // value being -1 is obstacle or visited and 1 being the starting square\\n    if i<0 || i == len(grid) || j <0 || j == len(grid[i]) || grid[i][j] == -1 {\\n                \\n        return 0\\n                \\n        } else if grid[i][j] == 0 || grid[i][j] == 1 {\\n                \\n            grid[i][j] = -1\\n\\n                result = uniquePathHelper(grid, remaining-1, i-1, j) + \\n                        uniquePathHelper(grid, remaining-1, i+1, j) +\\n                        uniquePathHelper(grid, remaining-1, i, j+1) +\\n                        uniquePathHelper(grid, remaining-1, i, j-1)\\n\\n            grid[i][j] = 0\\n                \\n            // the remaining is less than 0 because all the 0 cells are covered\\n            } else if grid[i][j] == 2 && remaining < 0 {\\n                \\n                return 1\\n            } \\n    \\n    return result\\n}",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```\\nfunc uniquePathsIII(grid [][]int) int {\\n    \\n    remaining := 0\\n    startX := 0 \\n    startY := 0 \\n    \\n    for i:=0 ; i<len(grid); i++ {\\n        for j:=0 ; j<len(grid[i]); j++ {\\n            if grid[i][j] == 0 {\\n                remaining += 1\\n            } else if grid[i][j] == 1 {\\n                startX = i\\n                startY = j\\n            }\\n        }\\n    }\\n    \\n\\n    \\n    return uniquePathHelper(grid, remaining, startX, startY)\\n    \\n}\\n\\nfunc uniquePathHelper(grid [][]int, remaining, i, j int) int {\\n    result := 0\\n    \\n    // value being -1 is obstacle or visited and 1 being the starting square\\n    if i<0 || i == len(grid) || j <0 || j == len(grid[i]) || grid[i][j] == -1 {\\n                \\n        return 0\\n                \\n        } else if grid[i][j] == 0 || grid[i][j] == 1 {\\n                \\n            grid[i][j] = -1\\n\\n                result = uniquePathHelper(grid, remaining-1, i-1, j) + \\n                        uniquePathHelper(grid, remaining-1, i+1, j) +\\n                        uniquePathHelper(grid, remaining-1, i, j+1) +\\n                        uniquePathHelper(grid, remaining-1, i, j-1)\\n\\n            grid[i][j] = 0\\n                \\n            // the remaining is less than 0 because all the 0 cells are covered\\n            } else if grid[i][j] == 2 && remaining < 0 {\\n                \\n                return 1\\n            } \\n    \\n    return result\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2132372,
                "title": "c-simple-and-clean-bfs-solution-code",
                "content": "```\\nclass Solution\\n{\\npublic:\\n\\tint ans;\\n\\tvoid pass(vector<vector<int>> &grid, int i, int j, int n, int m, int step)\\n\\t{\\n\\t\\t//Base Condition\\n\\t\\tif (i < 0 || j < 0 || i >= n || j >= m || grid[i][j] == -1)\\n\\t\\t\\treturn;\\n        //Main Condition\\n\\t\\tif (grid[i][j] == 2)\\n\\t\\t{\\n\\t\\t\\tif (step == 1)\\n\\t\\t\\t\\tans++;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tgrid[i][j] = -1;\\n\\t\\t\\tpass(grid, i - 1, j, n, m, step - 1);\\n\\t\\t\\tpass(grid, i + 1, j, n, m, step - 1);\\n\\t\\t\\tpass(grid, i, j + 1, n, m, step - 1);\\n\\t\\t\\tpass(grid, i, j - 1, n, m, step - 1);\\n\\t\\t\\tgrid[i][j] = 0;\\n\\t\\t}\\n\\t}\\n\\tint uniquePathsIII(vector<vector<int>> &grid)\\n\\t{\\n\\t\\tans = 0;\\n\\t\\tint i = 0, j = 0;\\n\\t\\tint n = grid.size();\\n\\t\\tint m = grid[0].size();\\n\\t\\tbool bat = 0;\\n\\t\\tfor (i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tfor (j = 0; j < m; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (grid[i][j] == 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbat = 1;\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (bat)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint brick = 0;\\n\\t\\tfor (int ii = 0; ii < n; ii++)\\n\\t\\t{\\n\\t\\t\\tfor (int jj = 0; jj < m; jj++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (grid[ii][jj] == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbrick++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpass(grid, i, j, n, m, (n * m) - brick);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tint ans;\\n\\tvoid pass(vector<vector<int>> &grid, int i, int j, int n, int m, int step)\\n\\t{\\n\\t\\t//Base Condition\\n\\t\\tif (i < 0 || j < 0 || i >= n || j >= m || grid[i][j] == -1)\\n\\t\\t\\treturn;\\n        //Main Condition\\n\\t\\tif (grid[i][j] == 2)\\n\\t\\t{\\n\\t\\t\\tif (step == 1)\\n\\t\\t\\t\\tans++;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tgrid[i][j] = -1;\\n\\t\\t\\tpass(grid, i - 1, j, n, m, step - 1);\\n\\t\\t\\tpass(grid, i + 1, j, n, m, step - 1);\\n\\t\\t\\tpass(grid, i, j + 1, n, m, step - 1);\\n\\t\\t\\tpass(grid, i, j - 1, n, m, step - 1);\\n\\t\\t\\tgrid[i][j] = 0;\\n\\t\\t}\\n\\t}\\n\\tint uniquePathsIII(vector<vector<int>> &grid)\\n\\t{\\n\\t\\tans = 0;\\n\\t\\tint i = 0, j = 0;\\n\\t\\tint n = grid.size();\\n\\t\\tint m = grid[0].size();\\n\\t\\tbool bat = 0;\\n\\t\\tfor (i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tfor (j = 0; j < m; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (grid[i][j] == 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbat = 1;\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (bat)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint brick = 0;\\n\\t\\tfor (int ii = 0; ii < n; ii++)\\n\\t\\t{\\n\\t\\t\\tfor (int jj = 0; jj < m; jj++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (grid[ii][jj] == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbrick++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpass(grid, i, j, n, m, (n * m) - brick);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2124366,
                "title": "python3-simple-backtracking-based-solution",
                "content": "```\\n\"\"\"https://leetcode.com/problems/unique-paths-iii/\"\"\"\\n\\n\\nclass Solution:\\n    def __init__(self):\\n        self.res = 0\\n\\n    def uniquePathsIII(self, A):\\n        def dfs(x, y, empty):\\n            if 0 <= x < m and 0 <= y < n and A[x][y] >= 0:\\n                if A[x][y] == 2:\\n                    # destination reached, update count only if empty count is also zero, which implies that\\n                    # each empty cell has been explored\\n                    self.res += empty == 0\\n                    return\\n                A[x][y] = -2\\n                for (dx, dy) in directions:\\n                    dfs(x + dx, y + dy, empty - 1)\\n                A[x][y] = 0\\n\\n        m, n, empty_counts = len(A), len(A[0]), 1\\n        start_x, start_y = None, None\\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        for i in range(m):\\n            for j in range(n):\\n                if A[i][j] == 1:\\n                    # start_node\\n                    start_x, start_y = (i, j)\\n                elif A[i][j] == 0:\\n                    empty_counts += 1\\n\\n        dfs(start_x, start_y, empty_counts)\\n        return self.res\\n",
                "solutionTags": [],
                "code": "```\\n\"\"\"https://leetcode.com/problems/unique-paths-iii/\"\"\"\\n\\n\\nclass Solution:\\n    def __init__(self):\\n        self.res = 0\\n\\n    def uniquePathsIII(self, A):\\n        def dfs(x, y, empty):\\n            if 0 <= x < m and 0 <= y < n and A[x][y] >= 0:\\n                if A[x][y] == 2:\\n                    # destination reached, update count only if empty count is also zero, which implies that\\n                    # each empty cell has been explored\\n                    self.res += empty == 0\\n                    return\\n                A[x][y] = -2\\n                for (dx, dy) in directions:\\n                    dfs(x + dx, y + dy, empty - 1)\\n                A[x][y] = 0\\n\\n        m, n, empty_counts = len(A), len(A[0]), 1\\n        start_x, start_y = None, None\\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        for i in range(m):\\n            for j in range(n):\\n                if A[i][j] == 1:\\n                    # start_node\\n                    start_x, start_y = (i, j)\\n                elif A[i][j] == 0:\\n                    empty_counts += 1\\n\\n        dfs(start_x, start_y, empty_counts)\\n        return self.res\\n",
                "codeTag": "Java"
            },
            {
                "id": 1977130,
                "title": "c-0ms-simple-backtracking-code",
                "content": "**Please do upvote if you liked my efforts ;)**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int ans=0;\\n    \\n    void helper(vector<vector<int>>& grid, int i, int j, int empty, int currEmpty)\\n    {\\n        if(i<0 or j<0 or i >= grid.size() or j >= grid[0].size() or grid[i][j] == -1 or grid[i][j] == 10) return;\\n        \\n        if(grid[i][j] == 2 and currEmpty == empty) ++ans;\\n        if(grid[i][j] == 0) ++currEmpty;\\n        \\n        int temp = grid[i][j];\\n        grid[i][j] = 10;\\n        \\n        helper(grid, i+1, j, empty, currEmpty);\\n        helper(grid, i-1, j, empty, currEmpty);\\n        helper(grid, i, j+1, empty, currEmpty);\\n        helper(grid, i, j-1, empty, currEmpty);\\n        \\n        grid[i][j] = temp;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) \\n    {\\n        int start_x, start_y, empty=0;\\n        \\n        for(int i=0; i<grid.size(); i++)\\n            for(int j=0; j<grid[0].size(); j++)\\n            {\\n                if(grid[i][j] == 1)\\n                    start_x = i, start_y = j;\\n                else if(grid[i][j] == 0) ++empty;\\n            }\\n        \\n        helper(grid, start_x, start_y, empty, 0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int ans=0;\\n    \\n    void helper(vector<vector<int>>& grid, int i, int j, int empty, int currEmpty)\\n    {\\n        if(i<0 or j<0 or i >= grid.size() or j >= grid[0].size() or grid[i][j] == -1 or grid[i][j] == 10) return;\\n        \\n        if(grid[i][j] == 2 and currEmpty == empty) ++ans;\\n        if(grid[i][j] == 0) ++currEmpty;\\n        \\n        int temp = grid[i][j];\\n        grid[i][j] = 10;\\n        \\n        helper(grid, i+1, j, empty, currEmpty);\\n        helper(grid, i-1, j, empty, currEmpty);\\n        helper(grid, i, j+1, empty, currEmpty);\\n        helper(grid, i, j-1, empty, currEmpty);\\n        \\n        grid[i][j] = temp;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) \\n    {\\n        int start_x, start_y, empty=0;\\n        \\n        for(int i=0; i<grid.size(); i++)\\n            for(int j=0; j<grid[0].size(); j++)\\n            {\\n                if(grid[i][j] == 1)\\n                    start_x = i, start_y = j;\\n                else if(grid[i][j] == 0) ++empty;\\n            }\\n        \\n        helper(grid, start_x, start_y, empty, 0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891952,
                "title": "c-bitmasking-dfs-simple-method",
                "content": "```\\nclass Solution {\\npublic:\\n    pair<int,int> p[4] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}; //path from each index\\n    int target_mask = 0; // each bit represent a cell \\n    int ans= 0;\\n    void dfs(vector<vector<int>>& grid, int i, int j, int mask, int& n, int& m){\\n        if(grid[i][j] == 2) {\\n            if( (mask | (1<<(i*m + j))) == target_mask) //checking if we have visited all cells before target\\n            ans++;\\n            return;\\n        }\\n        for(auto a: p){\\n            int x = a.first + i, y = a.second + j;\\n            if(x < 0 or y < 0 or x >= n or y >= m or grid[x][y] == -1 or mask&(1<<(x*m + y))) continue;\\n            dfs(grid, x, y, mask | (1<<(x*m + y)), n, m); //masking the cell bit as visited while making dfs call\\n        }\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        target_mask = (1 << n*m) -1; //making every bit as visited for target mask \\n        int row, col;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == 1){  // getting the starting index address\\n                    row = i;\\n                    col = j;\\n                }\\n                if(grid[i][j] == -1){\\n                    target_mask = target_mask^(1<<(i*m + j)); // changing the -1 cell\\'s bit to 0\\n                }\\n            }\\n        }\\n        dfs(grid, row, col, (0 | (1<<(row*m + col))), n, m); //making the beginning node visited and making dfs call \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int> p[4] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}; //path from each index\\n    int target_mask = 0; // each bit represent a cell \\n    int ans= 0;\\n    void dfs(vector<vector<int>>& grid, int i, int j, int mask, int& n, int& m){\\n        if(grid[i][j] == 2) {\\n            if( (mask | (1<<(i*m + j))) == target_mask) //checking if we have visited all cells before target\\n            ans++;\\n            return;\\n        }\\n        for(auto a: p){\\n            int x = a.first + i, y = a.second + j;\\n            if(x < 0 or y < 0 or x >= n or y >= m or grid[x][y] == -1 or mask&(1<<(x*m + y))) continue;\\n            dfs(grid, x, y, mask | (1<<(x*m + y)), n, m); //masking the cell bit as visited while making dfs call\\n        }\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        target_mask = (1 << n*m) -1; //making every bit as visited for target mask \\n        int row, col;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == 1){  // getting the starting index address\\n                    row = i;\\n                    col = j;\\n                }\\n                if(grid[i][j] == -1){\\n                    target_mask = target_mask^(1<<(i*m + j)); // changing the -1 cell\\'s bit to 0\\n                }\\n            }\\n        }\\n        dfs(grid, row, col, (0 | (1<<(row*m + col))), n, m); //making the beginning node visited and making dfs call \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691482,
                "title": "simple-c-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    \\n    void dfs(vector<vector<int>>& grid, vector<vector<int>>& dp, \\n             int i, int j, int m, int n, int val, int& count, int space) {\\n        \\n        //cout << i << \":\" << j << \":\" << \":\" << val << endl;\\n        if (i < 0 || i == m || j < 0 || j == n)  return;\\n        if (grid[i][j] == -1 || dp[i][j] == 1)   return;\\n        if (grid[i][j] == 2) {\\n            if (space == val)   count++;\\n            return;\\n        }\\n        dp[i][j] = 1;\\n        for (int k = 0; k < dir.size(); k++) {\\n            int x = i + dir[k][0], y = j + dir[k][1];\\n            dfs(grid, dp, x, y, m, n, val + 1, count, space);\\n        }\\n        dp[i][j] = 0;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int space = 0, m = grid.size(), n = grid[0].size(), x, y;\\n        \\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0)    space++;\\n                else if (grid[i][j] == 1)  {\\n                    x = i; y = j;\\n                }\\n            }\\n        }\\n        int val = -1, count = 0;\\n        grid[x][y] = 0;\\n        dfs(grid, dp, x, y, m, n, val, count, space);\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    \\n    void dfs(vector<vector<int>>& grid, vector<vector<int>>& dp, \\n             int i, int j, int m, int n, int val, int& count, int space) {\\n        \\n        //cout << i << \":\" << j << \":\" << \":\" << val << endl;\\n        if (i < 0 || i == m || j < 0 || j == n)  return;\\n        if (grid[i][j] == -1 || dp[i][j] == 1)   return;\\n        if (grid[i][j] == 2) {\\n            if (space == val)   count++;\\n            return;\\n        }\\n        dp[i][j] = 1;\\n        for (int k = 0; k < dir.size(); k++) {\\n            int x = i + dir[k][0], y = j + dir[k][1];\\n            dfs(grid, dp, x, y, m, n, val + 1, count, space);\\n        }\\n        dp[i][j] = 0;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int space = 0, m = grid.size(), n = grid[0].size(), x, y;\\n        \\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0)    space++;\\n                else if (grid[i][j] == 1)  {\\n                    x = i; y = j;\\n                }\\n            }\\n        }\\n        int val = -1, count = 0;\\n        grid[x][y] = 0;\\n        dfs(grid, dp, x, y, m, n, val, count, space);\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1652022,
                "title": "c-dfs-backtracking-solution",
                "content": "Please upvote if you like :)\\n\\n```\\nclass Solution {\\nprivate:\\n    int dfs(vector<vector<int>> &grid, int x, int y, int zeros){\\n        if(x<0 || y<0 || x>=grid.size() || y>=grid[0].size() || grid[x][y] == -1){  // base cases\\n            return 0;\\n        }\\n        \\n        if(grid[x][y] == 2){\\n            // reaching required end\\n            return zeros == -1 ? 1 : 0;   //check if all zeros covered, then it\\'s a possible path \\n        }\\n        \\n        grid[x][y] = -1;        // marking as visisted \\n        zeros--;\\n        \\n        int totalPath = dfs(grid, x + 1, y, zeros) +        // right \\n                        dfs(grid, x, y + 1, zeros) +        // down  \\n                        dfs(grid, x - 1, y, zeros) +        // left \\n                        dfs(grid, x, y - 1, zeros);         // top \\n        \\n        grid[x][y] = 0;     // these steps are added \\n        zeros++;            // to backtrack \\n        \\n        return totalPath;\\n    }\\n    \\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int zeros = 0, sx = 0, sy = 0;      // sx & sy are starting positions\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j] == 0) zeros++;\\n                else if (grid[i][j] == 1){\\n                    sx = i;\\n                    sy = j;\\n                } \\n            }\\n        }\\n        \\n        return dfs(grid, sx, sy, zeros);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dfs(vector<vector<int>> &grid, int x, int y, int zeros){\\n        if(x<0 || y<0 || x>=grid.size() || y>=grid[0].size() || grid[x][y] == -1){  // base cases\\n            return 0;\\n        }\\n        \\n        if(grid[x][y] == 2){\\n            // reaching required end\\n            return zeros == -1 ? 1 : 0;   //check if all zeros covered, then it\\'s a possible path \\n        }\\n        \\n        grid[x][y] = -1;        // marking as visisted \\n        zeros--;\\n        \\n        int totalPath = dfs(grid, x + 1, y, zeros) +        // right \\n                        dfs(grid, x, y + 1, zeros) +        // down  \\n                        dfs(grid, x - 1, y, zeros) +        // left \\n                        dfs(grid, x, y - 1, zeros);         // top \\n        \\n        grid[x][y] = 0;     // these steps are added \\n        zeros++;            // to backtrack \\n        \\n        return totalPath;\\n    }\\n    \\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int zeros = 0, sx = 0, sy = 0;      // sx & sy are starting positions\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j] == 0) zeros++;\\n                else if (grid[i][j] == 1){\\n                    sx = i;\\n                    sy = j;\\n                } \\n            }\\n        }\\n        \\n        return dfs(grid, sx, sy, zeros);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645101,
                "title": "space-and-time-complexity-explained-simple-code-c",
                "content": "//time complexity->3^(m*n) because first box hai 4 choices and rest have 3\\n// space->m*n coz space is equal to the height of stack and in worst case stack can have all elements\\n\\nclass Solution {\\npublic:\\n   typedef pair<int,int> Pair;\\n\\n  int solution(int starti,int startj,vector<vector<int>>& grid,int initialcount){\\n   \\n      \\n         if(starti<0 || startj<0 || starti>=grid.size() || startj>=grid[0].size() || grid[starti][startj]==-1){\\n            return 0;\\n        }\\n      \\n        if(grid[starti][startj]==2){\\n            if( initialcount==-1)//because for last box when we reach destination the count be also decrease by 1 extra time\\n          return 1;\\n            else\\n                return 0;\\n        }\\n        \\n     \\n        \\n      \\n        grid[starti][startj]=-1;\\n        initialcount--;\\n             int path1=solution(starti,startj+1,grid,initialcount);\\n             int path2=solution(starti+1,startj,grid,initialcount);\\n             int path3=solution(starti,startj-1,grid,initialcount);\\n             int path4=solution(starti-1,startj,grid,initialcount);\\n\\n        initialcount++;\\n        grid[starti][startj]=0;\\n      \\n     int ans= path1+path2+path3+path4;\\n   return ans;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n     \\n        \\n        \\n             int count=0;\\n        int starti=0;\\n            int startj=0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==0){\\n                    count++;\\n                }\\n               else if(grid[i][j]==1){\\n                    starti=i;\\n                    startj=j;\\n                }\\n               \\n           \\n            }  \\n        }\\n      return  solution(starti,startj,grid,count);\\n    }\\n};\\n//pls upvote if you like my solution : )",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n   typedef pair<int,int> Pair;\\n\\n  int solution(int starti,int startj,vector<vector<int>>& grid,int initialcount){\\n   \\n      \\n         if(starti<0 || startj<0 || starti>=grid.size() || startj>=grid[0].size() || grid[starti][startj]==-1){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1628825,
                "title": "java-dfs-solution-backtracking-easy-clean-code",
                "content": "```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        if(grid==null || grid.length==0) return 0;\\n        \\n        int zero=0;\\n        int x=-1;\\n        int y=-1;\\n        \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==0) zero++;\\n                else if(grid[i][j]==1){\\n                    x=i;\\n                    y=j;\\n                }\\n            }\\n        }\\n        return helper(grid,x,y,zero);\\n    }\\n    \\n    public int helper(int[][] grid, int x, int y, int zero){\\n        if(x<0 || y<0 || x>=grid.length || y>=grid[0].length || grid[x][y]==-1) return 0;\\n        \\n        if(grid[x][y]==2) return zero == -1 ? 1 : 0;\\n        \\n        grid[x][y]=-1;\\n        zero--;\\n        \\n        int ans = helper(grid,x+1,y,zero)\\n                + helper(grid,x-1,y,zero)\\n                + helper(grid,x,y+1,zero)\\n                + helper(grid,x,y-1,zero);\\n        \\n        zero++;\\n        grid[x][y]=0;\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        if(grid==null || grid.length==0) return 0;\\n        \\n        int zero=0;\\n        int x=-1;\\n        int y=-1;\\n        \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==0) zero++;\\n                else if(grid[i][j]==1){\\n                    x=i;\\n                    y=j;\\n                }\\n            }\\n        }\\n        return helper(grid,x,y,zero);\\n    }\\n    \\n    public int helper(int[][] grid, int x, int y, int zero){\\n        if(x<0 || y<0 || x>=grid.length || y>=grid[0].length || grid[x][y]==-1) return 0;\\n        \\n        if(grid[x][y]==2) return zero == -1 ? 1 : 0;\\n        \\n        grid[x][y]=-1;\\n        zero--;\\n        \\n        int ans = helper(grid,x+1,y,zero)\\n                + helper(grid,x-1,y,zero)\\n                + helper(grid,x,y+1,zero)\\n                + helper(grid,x,y-1,zero);\\n        \\n        zero++;\\n        grid[x][y]=0;\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555480,
                "title": "november-challenge-day-2-unique-paths-3-c-code-with-comments",
                "content": "```\\n// we need to count total no. of 0s and also find out which cell is start point\\n    int zeroCells = 1, res = 0; // zeroCells starts w 1 to account for start point\\n    // which is 1 and not 0 \\n    \\n    void dfs(vector<vector<int>>& grid, int x, int y, int countZeros){\\n        // base cases\\n        if(x < 0 || y < 0 || x >=grid.size() || y>=grid[0].size() || grid[x][y] == -1)\\n            return;\\n        \\n        if(grid[x][y] == 2) {\\n            if (countZeros == zeroCells)  res += 1;\\n            return; // we reached destination and all cells w 0 have been visited -> inc. unique path count (res) by 1. Else just return\\n        }\\n        \\n        grid[x][y] = -1; // mark curr cell visited\\n        \\n        // dfs\\n        dfs(grid, x+1, y, countZeros+1);\\n        dfs(grid, x-1, y, countZeros+1);\\n        dfs(grid, x, y+1, countZeros+1);\\n        dfs(grid, x, y-1, countZeros+1);\\n        \\n        // backtrack before trying to find new path\\n        grid[x][y] = 0;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        // fast\\n        ios_base::sync_with_stdio(false);\\n        int start_x, start_y;\\n        int rows = grid.size(), cols = grid[0].size();\\n        \\n        for(int i = 0; i<rows; i++){\\n            for(int j = 0; j<cols; j++){\\n                if(grid[i][j] == 1) start_x = i, start_y = j;\\n                else if(grid[i][j] == 0) zeroCells += 1;\\n            }\\n        }\\n        \\n        // now do dfs from start\\n        dfs(grid, start_x, start_y, 0);\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n// we need to count total no. of 0s and also find out which cell is start point\\n    int zeroCells = 1, res = 0; // zeroCells starts w 1 to account for start point\\n    // which is 1 and not 0 \\n    \\n    void dfs(vector<vector<int>>& grid, int x, int y, int countZeros){\\n        // base cases\\n        if(x < 0 || y < 0 || x >=grid.size() || y>=grid[0].size() || grid[x][y] == -1)\\n            return;\\n        \\n        if(grid[x][y] == 2) {\\n            if (countZeros == zeroCells)  res += 1;\\n            return; // we reached destination and all cells w 0 have been visited -> inc. unique path count (res) by 1. Else just return\\n        }\\n        \\n        grid[x][y] = -1; // mark curr cell visited\\n        \\n        // dfs\\n        dfs(grid, x+1, y, countZeros+1);\\n        dfs(grid, x-1, y, countZeros+1);\\n        dfs(grid, x, y+1, countZeros+1);\\n        dfs(grid, x, y-1, countZeros+1);\\n        \\n        // backtrack before trying to find new path\\n        grid[x][y] = 0;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        // fast\\n        ios_base::sync_with_stdio(false);\\n        int start_x, start_y;\\n        int rows = grid.size(), cols = grid[0].size();\\n        \\n        for(int i = 0; i<rows; i++){\\n            for(int j = 0; j<cols; j++){\\n                if(grid[i][j] == 1) start_x = i, start_y = j;\\n                else if(grid[i][j] == 0) zeroCells += 1;\\n            }\\n        }\\n        \\n        // now do dfs from start\\n        dfs(grid, start_x, start_y, 0);\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1554465,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar uniquePathsIII = function(obstacleGrid) {\\n    let rows = obstacleGrid.length;\\n    let columns = obstacleGrid[0].length;\\n    \\n    let directions = [ [1, 0], [0, 1], [-1, 0], [0, -1] ];\\n    let nonObstacles = 0;\\n    let startX, startY;\\n    \\n    for(let g=0; g<rows; g++){\\n        for(let k=0; k<columns; k++){\\n            if(obstacleGrid[g][k] == 1){\\n                startX = g;\\n                startY = k;\\n                \\n            }\\n            else if (obstacleGrid[g][k] == 0){\\n                     nonObstacles++;\\n            }\\n        }\\n    }\\n    \\n    \\n    \\n    const compute = (x, y, count) => {\\n        if(x >= rows || y>= columns || x<0 || y<0) return 0;\\n        if( obstacleGrid[x][y] == -1 || obstacleGrid[x][y] == \\'V\\') return 0;\\n        if( obstacleGrid[x][y] == 2 && count == nonObstacles+1  ) {\\n            return 1;\\n        }\\n        let res = 0;\\n        let oldValue =  obstacleGrid[x][y] ;\\n        obstacleGrid[x][y] = \\'V\\';\\n        for(let [dx, dy] of directions) {\\n             let curRes   = compute(x+dx, y+dy, count+1);\\n             res = curRes + res;\\n        }\\n        obstacleGrid[x][y] = oldValue;\\n        return res;\\n    }\\n    return compute(startX, startY, 0);\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar uniquePathsIII = function(obstacleGrid) {\\n    let rows = obstacleGrid.length;\\n    let columns = obstacleGrid[0].length;\\n    \\n    let directions = [ [1, 0], [0, 1], [-1, 0], [0, -1] ];\\n    let nonObstacles = 0;\\n    let startX, startY;\\n    \\n    for(let g=0; g<rows; g++){\\n        for(let k=0; k<columns; k++){\\n            if(obstacleGrid[g][k] == 1){\\n                startX = g;\\n                startY = k;\\n                \\n            }\\n            else if (obstacleGrid[g][k] == 0){\\n                     nonObstacles++;\\n            }\\n        }\\n    }\\n    \\n    \\n    \\n    const compute = (x, y, count) => {\\n        if(x >= rows || y>= columns || x<0 || y<0) return 0;\\n        if( obstacleGrid[x][y] == -1 || obstacleGrid[x][y] == \\'V\\') return 0;\\n        if( obstacleGrid[x][y] == 2 && count == nonObstacles+1  ) {\\n            return 1;\\n        }\\n        let res = 0;\\n        let oldValue =  obstacleGrid[x][y] ;\\n        obstacleGrid[x][y] = \\'V\\';\\n        for(let [dx, dy] of directions) {\\n             let curRes   = compute(x+dx, y+dy, count+1);\\n             res = curRes + res;\\n        }\\n        obstacleGrid[x][y] = oldValue;\\n        return res;\\n    }\\n    return compute(startX, startY, 0);\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1554325,
                "title": "c-backtracking-optimized-solution-with-comments-beats-100",
                "content": "```\\n#define vvi vector<vector<int>>\\n\\n//for 4 directions\\nint rowArr[] = {1,-1,0,0};\\nint colArr[] = {0,0,1,-1};\\n\\n//variable to keep track of no. of paths\\nint cnt = 0;\\n    \\n\\t//function to check if current cell is inside grid\\n\\t//and is not obstacle/starting point/already visited cell\\n    bool isValid(vvi &grid,int row,int col)\\n    {\\n        if(row<0 || col<0 || \\n           row>=grid.size() || col>=grid[0].size()\\n           || grid[row][col] == -1 || grid[row][col] == 1)\\n            return false;\\n        return true;\\n    }\\n    \\n\\t//function to look for valid paths\\n    void dfs(vvi &grid,int row,int col,int sq,int total)\\n    {\\n\\t//if current cell is invalid , just return\\n        if(!isValid(grid,row,col)) return;\\n\\t\\t\\n\\t\\t//if the current cell is ending point, do cnt++ if \\n\\t\\t//no. of empty cells visited is equal to total \\n\\t\\t//empty cells is the grid and return\\n        if(grid[row][col] == 2)\\n        {\\n            cnt+= (sq == total);\\n            return;\\n        }\\n        \\n\\t\\t//change value of current cell to -1 to mark it as visited\\n        grid[row][col] = -1;\\n\\t\\t\\n\\t\\t//move in all 4 directions from this current cell\\n        for(int i=0;i<4;i++) \\n            dfs(grid,row+rowArr[i],col+colArr[i],sq+1,total);\\n\\t\\t\\n\\t\\t//after coming back from all 4 directions\\n\\t\\t//mark current cell as unvisited(0) again\\n        grid[row][col] = 0;\\n    }\\n\\t\\n\\t int uniquePathsIII(vector<vector<int>>& grid) {\\n        cnt=0;\\n        int total = 0;\\n        int x,y;\\n\\t\\t//iterate over grid to find the starting point and\\n\\t\\t//count no. of empty cells\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j] == 0) total++;\\n                else if(grid[i][j] == 1) x=i,y=j;\\n            }\\n        }\\n        // from the starting point move in all 4 directions to count \\n\\t\\t//no. of valid paths\\n        for(int i=0;i<4;i++) dfs(grid,x+rowArr[i],y+colArr[i],0,total);\\n        \\n\\t\\t\\n\\t\\t//return the count of valid paths\\n        return cnt;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n#define vvi vector<vector<int>>\\n\\n//for 4 directions\\nint rowArr[] = {1,-1,0,0};\\nint colArr[] = {0,0,1,-1};\\n\\n//variable to keep track of no. of paths\\nint cnt = 0;\\n    \\n\\t//function to check if current cell is inside grid\\n\\t//and is not obstacle/starting point/already visited cell\\n    bool isValid(vvi &grid,int row,int col)\\n    {\\n        if(row<0 || col<0 || \\n           row>=grid.size() || col>=grid[0].size()\\n           || grid[row][col] == -1 || grid[row][col] == 1)\\n            return false;\\n        return true;\\n    }\\n    \\n\\t//function to look for valid paths\\n    void dfs(vvi &grid,int row,int col,int sq,int total)\\n    {\\n\\t//if current cell is invalid , just return\\n        if(!isValid(grid,row,col)) return;\\n\\t\\t\\n\\t\\t//if the current cell is ending point, do cnt++ if \\n\\t\\t//no. of empty cells visited is equal to total \\n\\t\\t//empty cells is the grid and return\\n        if(grid[row][col] == 2)\\n        {\\n            cnt+= (sq == total);\\n            return;\\n        }\\n        \\n\\t\\t//change value of current cell to -1 to mark it as visited\\n        grid[row][col] = -1;\\n\\t\\t\\n\\t\\t//move in all 4 directions from this current cell\\n        for(int i=0;i<4;i++) \\n            dfs(grid,row+rowArr[i],col+colArr[i],sq+1,total);\\n\\t\\t\\n\\t\\t//after coming back from all 4 directions\\n\\t\\t//mark current cell as unvisited(0) again\\n        grid[row][col] = 0;\\n    }\\n\\t\\n\\t int uniquePathsIII(vector<vector<int>>& grid) {\\n        cnt=0;\\n        int total = 0;\\n        int x,y;\\n\\t\\t//iterate over grid to find the starting point and\\n\\t\\t//count no. of empty cells\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j] == 0) total++;\\n                else if(grid[i][j] == 1) x=i,y=j;\\n            }\\n        }\\n        // from the starting point move in all 4 directions to count \\n\\t\\t//no. of valid paths\\n        for(int i=0;i<4;i++) dfs(grid,x+rowArr[i],y+colArr[i],0,total);\\n        \\n\\t\\t\\n\\t\\t//return the count of valid paths\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1554140,
                "title": "c-dfs-approach",
                "content": "1. DFS\\n```\\n\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>> &grid, vector<vector<bool>> &visited, int i, int j, int ei, int ej, int count0) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        int ans = 0;\\n\\n        // cout<<i<<\" \"<<j<<\" \"<<\" \"<<count0<<endl;\\n        if (i == ei && j == ej) {\\n            if (count0 == -1)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n\\n        visited[i][j] = true;\\n\\n        //up\\n        if (i - 1 >= 0 && !visited[i - 1][j] && grid[i - 1][j] != -1)\\n            ans += dfs(grid, visited, i - 1, j, ei, ej, count0 - 1);\\n        //down\\n        if (i + 1 < m && !visited[i + 1][j] && grid[i + 1][j] != -1)\\n            ans += dfs(grid, visited, i + 1, j, ei, ej, count0 - 1);\\n        //left\\n        if (j - 1 >= 0 && !visited[i][j - 1] && grid[i][j - 1] != -1)\\n            ans += dfs(grid, visited, i, j - 1, ei, ej, count0 - 1);\\n        //right\\n        if (j + 1 < n && !visited[i][j + 1] && grid[i][j + 1] != -1)\\n            ans += dfs(grid, visited, i, j + 1, ei, ej, count0 - 1);\\n\\n        visited[i][j] = false;\\n\\n        return ans;\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>> &grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        int si,sj,ei,ej,count0=0;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    si = i;\\n                    sj = j;\\n                }\\n\\n                if (grid[i][j] == 2) {\\n                    ei = i;\\n                    ej = j;\\n                }\\n\\n                if (grid[i][j] == 0) {\\n                    count0++;\\n                }\\n\\n            }\\n        }\\n\\n        return dfs(grid, visited, si, sj, ei, ej, count0);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>> &grid, vector<vector<bool>> &visited, int i, int j, int ei, int ej, int count0) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        int ans = 0;\\n\\n        // cout<<i<<\" \"<<j<<\" \"<<\" \"<<count0<<endl;\\n        if (i == ei && j == ej) {\\n            if (count0 == -1)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n\\n        visited[i][j] = true;\\n\\n        //up\\n        if (i - 1 >= 0 && !visited[i - 1][j] && grid[i - 1][j] != -1)\\n            ans += dfs(grid, visited, i - 1, j, ei, ej, count0 - 1);\\n        //down\\n        if (i + 1 < m && !visited[i + 1][j] && grid[i + 1][j] != -1)\\n            ans += dfs(grid, visited, i + 1, j, ei, ej, count0 - 1);\\n        //left\\n        if (j - 1 >= 0 && !visited[i][j - 1] && grid[i][j - 1] != -1)\\n            ans += dfs(grid, visited, i, j - 1, ei, ej, count0 - 1);\\n        //right\\n        if (j + 1 < n && !visited[i][j + 1] && grid[i][j + 1] != -1)\\n            ans += dfs(grid, visited, i, j + 1, ei, ej, count0 - 1);\\n\\n        visited[i][j] = false;\\n\\n        return ans;\\n    }\\n\\n    int uniquePathsIII(vector<vector<int>> &grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        int si,sj,ei,ej,count0=0;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    si = i;\\n                    sj = j;\\n                }\\n\\n                if (grid[i][j] == 2) {\\n                    ei = i;\\n                    ej = j;\\n                }\\n\\n                if (grid[i][j] == 0) {\\n                    count0++;\\n                }\\n\\n            }\\n        }\\n\\n        return dfs(grid, visited, si, sj, ei, ej, count0);\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1553995,
                "title": "c-with-explanation-clean-code",
                "content": "**Idea:-**\\n1. Iterate over ```grid``` and find the start position and count the umber of empty cells(including start position,that\\'s why i initilized empty with 1).\\n2. Now start backtrackin  from start posiiton and mark visited to every empty cells(by assigning it ```-2``` or other different value) and also decrease ```empty```.\\n3. When we complete backtracking from current cell then restore the previous values(empty++,grid[row][col]=0). \\n4. When we reach ```end``` position our ```empty``` variable should be ```0``` because we have to count number of paths that include every ```empty cell.```.\\n\\n**Time Complexity:-** ```O(3^(m*n))```,where m,n are row,columns of grid.\\n4th one is not included because we can\\'t go back to same posiiton.\\n**Space Complexity:-** ```O(1)```, I am not using stack space as i am passing by ```reference```.\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n       int m=grid.size(),n=grid[0].size(),ans=0,startRow,startCol,empty=1;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    startRow=i; startCol=j;\\n                }\\n                else if(grid[i][j]==0)\\n                    empty++;\\n            }\\n        helper(grid,startRow,startCol,ans,m,n,empty);\\n          return ans;          \\n    }\\n    void helper(vector<vector<int>>& grid,int &row,int&col,int &ans,int &m,int &n,int &empty){\\n        if(row<0 || row>=m || col<0 || col>=n || grid[row][col]==-1 || grid[row][col]==-2)\\n            return;\\n        if(grid[row][col]==2){\\n            if(empty==0)\\n              ans++;\\n            return;\\n        }\\n        grid[row][col]=-2;  empty--;\\n        vector<vector<int>>dirs={{1,0},{0,1},{-1,0},{0,-1}};\\n        for(auto & i:dirs){\\n            row+=i[0];   col+=i[1];\\n            helper(grid,row,col,ans,m,n,empty);\\n            row-=i[0];  col-=i[1];\\n        }\\n        grid[row][col]=0; empty++;\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps:)\\nIf you have any doubt or suggestion then please ask in comment section.",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```grid```\n```-2```\n```empty```\n```end```\n```empty```\n```0```\n```empty cell.```\n```O(3^(m*n))```\n```O(1)```\n```reference```\n```\\nclass Solution {\\npublic:\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n       int m=grid.size(),n=grid[0].size(),ans=0,startRow,startCol,empty=1;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    startRow=i; startCol=j;\\n                }\\n                else if(grid[i][j]==0)\\n                    empty++;\\n            }\\n        helper(grid,startRow,startCol,ans,m,n,empty);\\n          return ans;          \\n    }\\n    void helper(vector<vector<int>>& grid,int &row,int&col,int &ans,int &m,int &n,int &empty){\\n        if(row<0 || row>=m || col<0 || col>=n || grid[row][col]==-1 || grid[row][col]==-2)\\n            return;\\n        if(grid[row][col]==2){\\n            if(empty==0)\\n              ans++;\\n            return;\\n        }\\n        grid[row][col]=-2;  empty--;\\n        vector<vector<int>>dirs={{1,0},{0,1},{-1,0},{0,-1}};\\n        for(auto & i:dirs){\\n            row+=i[0];   col+=i[1];\\n            helper(grid,row,col,ans,m,n,empty);\\n            row-=i[0];  col-=i[1];\\n        }\\n        grid[row][col]=0; empty++;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1553968,
                "title": "python-dfs-and-backtracking-a-few-lines-of-code",
                "content": "\\n```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        visit=set() # need to be visted\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==0:\\n                    visit.add((i,j))\\n                elif grid[i][j]==1:\\n                    start = (i,j)\\n                elif grid[i][j]==2:\\n                    end= (i,j)\\n                    visit.add((i,j))\\n        \\n        def back(i,j):\\n            if grid[i][j]==2 and len(visit)==0:\\n                return 1\\n            rst = 0\\n            \\n            for v in [(i-1,j), (i+1,j), (i,j-1),(i,j+1)]: # DFS 4 direct\\n                if v in visit:\\n                    visit.remove(v)\\n                    rst += back(v[0], v[1])\\n                    visit.add(v) # must added back for the other path\\n            return rst\\n\\n        return back(start[0], start[1])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        visit=set() # need to be visted\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==0:\\n                    visit.add((i,j))\\n                elif grid[i][j]==1:\\n                    start = (i,j)\\n                elif grid[i][j]==2:\\n                    end= (i,j)\\n                    visit.add((i,j))\\n        \\n        def back(i,j):\\n            if grid[i][j]==2 and len(visit)==0:\\n                return 1\\n            rst = 0\\n            \\n            for v in [(i-1,j), (i+1,j), (i,j-1),(i,j+1)]: # DFS 4 direct\\n                if v in visit:\\n                    visit.remove(v)\\n                    rst += back(v[0], v[1])\\n                    visit.add(v) # must added back for the other path\\n            return rst\\n\\n        return back(start[0], start[1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1553933,
                "title": "simple-easy-code-c",
                "content": "class Solution {\\npublic:\\n    int ans = 0;\\n    \\n    void check(vector<vector<int>>&v ,int i , int j , int c){\\n        if(i<0 || i>=v.size() || j<0 || j>=v[0].size() || v[i][j]==INT_MIN || v[i][j]==-1 ) return ;\\n        \\n        if(v[i][j]==2){\\n            if(c==-1){\\n                ans+=1;\\n            }\\n            return ;\\n        }\\n        \\n         \\n        v[i][j] = INT_MIN;  // MARK AS VISITED\\n        check(v , i+1 , j , c-1);\\n        check(v ,i-1 , j, c-1);\\n        check(v, i , j+1 ,c-1);\\n        check(v , i, j-1 , c-1);\\n        v[i][j] = 0;  // UNMARK\\n    } \\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int c =0;\\n        int s=0,e=0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]==0){\\n                    c++;  // COUNT TOTAL ZEROES\\n                }\\n                else if(grid[i][j]==1){\\n                    s = i;  // START POINT ROW\\n                    e = j; // START POINT COLOUMN\\n                }\\n            }\\n        }\\n        \\n        check(grid , s , e , c);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int ans = 0;\\n    \\n    void check(vector<vector<int>>&v ,int i , int j , int c){\\n        if(i<0 || i>=v.size() || j<0 || j>=v[0].size() || v[i][j]==INT_MIN || v[i][j]==-1 ) return ;\\n        \\n        if(v[i][j]==2){\\n            if(c==-1){\\n                ans+=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1553895,
                "title": "simple-ruby-3-liner",
                "content": "```\\ndef unique_paths_iii(g, h={}) [*0...g.size].product([*0...g[0].size]){|i,j| h[[i,j]]=g[i][j]}\\n  (dfs = -> i,j,h{[[i+1,j], [i-1,j], [i,j+1], [i,j-1]].sum{|n| h[n]==0 ?\\n    dfs[*n, h.merge(n=>1)] : h[n]!=2 ? 0 : h.key(0) ? 0 : 1}})[*h.key(1), h] end\\n```",
                "solutionTags": [],
                "code": "```\\ndef unique_paths_iii(g, h={}) [*0...g.size].product([*0...g[0].size]){|i,j| h[[i,j]]=g[i][j]}\\n  (dfs = -> i,j,h{[[i+1,j], [i-1,j], [i,j+1], [i,j-1]].sum{|n| h[n]==0 ?\\n    dfs[*n, h.merge(n=>1)] : h[n]!=2 ? 0 : h.key(0) ? 0 : 1}})[*h.key(1), h] end\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1547183,
                "title": "python-solution-with-complex-numbers-faster-than-99-5",
                "content": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\n        self.maze = set()\\n        for y, row in enumerate(grid):\\n            for x, sq in enumerate(row):\\n                pos = x + 1j * y\\n                if sq == 1:\\n                    start = pos\\n                elif sq == 2:\\n                    end = pos\\n                if sq != -1:\\n                    self.maze.add(pos)\\n        self.maze.remove(start)\\n\\n        self.solutions = 0\\n\\n        self.solve(start, end)\\n        return self.solutions\\n\\n    def solve(self, pos, end):\\n        if pos == end:\\n            if not self.maze:\\n                self.solutions += 1\\n            return\\n\\n        for dv in 1, -1, 1j, -1j:\\n            np = pos + dv\\n            if np not in self.maze:\\n                continue\\n\\n            self.maze.remove(np)\\n            self.solve(np, end)\\n            self.maze.add(np)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n\\n        self.maze = set()\\n        for y, row in enumerate(grid):\\n            for x, sq in enumerate(row):\\n                pos = x + 1j * y\\n                if sq == 1:\\n                    start = pos\\n                elif sq == 2:\\n                    end = pos\\n                if sq != -1:\\n                    self.maze.add(pos)\\n        self.maze.remove(start)\\n\\n        self.solutions = 0\\n\\n        self.solve(start, end)\\n        return self.solutions\\n\\n    def solve(self, pos, end):\\n        if pos == end:\\n            if not self.maze:\\n                self.solutions += 1\\n            return\\n\\n        for dv in 1, -1, 1j, -1j:\\n            np = pos + dv\\n            if np not in self.maze:\\n                continue\\n\\n            self.maze.remove(np)\\n            self.solve(np, end)\\n            self.maze.add(np)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408339,
                "title": "java-dfs-and-backtracking-templates-time-beats-100",
                "content": "**Idea:** Use backtracking and grid DFS templates\\n>**T/S:** O(3\\u207F)/O(n), where n = total number of cells in the grid\\n```\\nprivate static final int[][] DIRS = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n\\t\\npublic int uniquePathsIII(int[][] grid) {\\n\\t// 0 and 1 will both be treated as empty even though their values are different.\\n\\t// This initialization is for counting the starting square as there will always be one.\\n\\tvar empty = 1;\\n\\tvar startX = -1;\\n\\tvar startY = -1;\\n\\n\\tfor (var i = 0; i < grid.length; i++)\\n\\t\\tfor (var j = 0; j < grid[0].length; j++)\\n\\t\\t\\tif (grid[i][j] == 1) {\\n\\t\\t\\t\\tstartX = i;\\n\\t\\t\\t\\tstartY = j;\\n\\t\\t\\t} else if (grid[i][j] == 0) {\\n\\t\\t\\t\\tempty++;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\treturn dfs(grid, startX, startY, new int[]{empty});\\n}\\n\\n// most of the grid DFS questions have this template. Number of Islands is the most popular one\\nprivate int dfs(int[][] grid, int i, int j, int[] empty) {\\n\\tif (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == -1)\\n\\t\\treturn 0; // invalid cell\\n\\tif (grid[i][j] == 2)\\n\\t\\treturn (empty[0] == 0) ? 1 : 0; // terminate early if empty cells haven\\'t exhausted when ending square is reached\\n\\n\\t// use backtracking template: choose-explore-unchoose\\n\\t// choose (change)\\n\\tempty[0]--;\\n\\tvar temp = grid[i][j]; // here temp is used to account for 0 and 1 valid traversable values\\n\\tgrid[i][j] = -1;\\n\\n\\t// explore\\n\\tvar paths = 0;\\n\\tfor (var dir : DIRS)\\n\\t\\tpaths += dfs(grid, i + dir[0], j + dir[1], empty);\\n\\n\\t// unchoose (restore)\\n\\tgrid[i][j] = temp;\\n\\tempty[0]++;\\n\\treturn paths;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nprivate static final int[][] DIRS = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n\\t\\npublic int uniquePathsIII(int[][] grid) {\\n\\t// 0 and 1 will both be treated as empty even though their values are different.\\n\\t// This initialization is for counting the starting square as there will always be one.\\n\\tvar empty = 1;\\n\\tvar startX = -1;\\n\\tvar startY = -1;\\n\\n\\tfor (var i = 0; i < grid.length; i++)\\n\\t\\tfor (var j = 0; j < grid[0].length; j++)\\n\\t\\t\\tif (grid[i][j] == 1) {\\n\\t\\t\\t\\tstartX = i;\\n\\t\\t\\t\\tstartY = j;\\n\\t\\t\\t} else if (grid[i][j] == 0) {\\n\\t\\t\\t\\tempty++;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\treturn dfs(grid, startX, startY, new int[]{empty});\\n}\\n\\n// most of the grid DFS questions have this template. Number of Islands is the most popular one\\nprivate int dfs(int[][] grid, int i, int j, int[] empty) {\\n\\tif (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == -1)\\n\\t\\treturn 0; // invalid cell\\n\\tif (grid[i][j] == 2)\\n\\t\\treturn (empty[0] == 0) ? 1 : 0; // terminate early if empty cells haven\\'t exhausted when ending square is reached\\n\\n\\t// use backtracking template: choose-explore-unchoose\\n\\t// choose (change)\\n\\tempty[0]--;\\n\\tvar temp = grid[i][j]; // here temp is used to account for 0 and 1 valid traversable values\\n\\tgrid[i][j] = -1;\\n\\n\\t// explore\\n\\tvar paths = 0;\\n\\tfor (var dir : DIRS)\\n\\t\\tpaths += dfs(grid, i + dir[0], j + dir[1], empty);\\n\\n\\t// unchoose (restore)\\n\\tgrid[i][j] = temp;\\n\\tempty[0]++;\\n\\treturn paths;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390740,
                "title": "java-100-faster-backtracking-solution",
                "content": "```\\nclass Solution {\\n    int[][] directions = {{1,0}, {-1,0}, {0,1}, {0,-1}};\\n    \\n    public int uniquePathsIII(int[][] grid) {\\n        int rows = grid.length, cols = grid[0].length;\\n        int[] start = new int[2];\\n        int emptySquares = 0;\\n        \\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++){\\n                if(grid[i][j] == 1){\\n                    start[0] = i;\\n                    start[1] = j;\\n                }else if(grid[i][j] == 0){\\n                    emptySquares++;\\n                }\\n            }\\n        }\\n        \\n        return countPaths(start[0], start[1], grid, emptySquares);\\n    }\\n    \\n    private int countPaths(int row, int col, int[][] grid, int emptySquares){\\n        if(row<0 || col<0 || row>=grid.length || col>=grid[0].length){\\n            return 0;\\n        }else if(grid[row][col] == -1 || grid[row][col] == 3){\\n            return 0;\\n        }else if(grid[row][col] == 2){\\n            return emptySquares == -1 ? 1 : 0;\\n        }\\n        \\n        grid[row][col] = 3;\\n        \\n        int countPaths = 0;\\n        \\n        for(int[] d : directions){\\n            countPaths += countPaths(row+d[0], col+d[1], grid, emptySquares-1);\\n        }\\n        \\n        grid[row][col] = 0;\\n        return countPaths;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int[][] directions = {{1,0}, {-1,0}, {0,1}, {0,-1}};\\n    \\n    public int uniquePathsIII(int[][] grid) {\\n        int rows = grid.length, cols = grid[0].length;\\n        int[] start = new int[2];\\n        int emptySquares = 0;\\n        \\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++){\\n                if(grid[i][j] == 1){\\n                    start[0] = i;\\n                    start[1] = j;\\n                }else if(grid[i][j] == 0){\\n                    emptySquares++;\\n                }\\n            }\\n        }\\n        \\n        return countPaths(start[0], start[1], grid, emptySquares);\\n    }\\n    \\n    private int countPaths(int row, int col, int[][] grid, int emptySquares){\\n        if(row<0 || col<0 || row>=grid.length || col>=grid[0].length){\\n            return 0;\\n        }else if(grid[row][col] == -1 || grid[row][col] == 3){\\n            return 0;\\n        }else if(grid[row][col] == 2){\\n            return emptySquares == -1 ? 1 : 0;\\n        }\\n        \\n        grid[row][col] = 3;\\n        \\n        int countPaths = 0;\\n        \\n        for(int[] d : directions){\\n            countPaths += countPaths(row+d[0], col+d[1], grid, emptySquares-1);\\n        }\\n        \\n        grid[row][col] = 0;\\n        return countPaths;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390421,
                "title": "c-backtracking-solution-commented",
                "content": "This problem is a slight modification of the `rat in a maze` problem, the only difference being: we have to find only those paths that cover every block (except the hurdles of course). So, a simple modification in the base case is, we have to return only that path for which all the blocks have been visited. (Now try again without looking at the code below.)\\n``` \\nint getPaths(int i, int j, vector<vector<int>> &mat, int m, int n, vector<vector<int>> &visited, int* di, int* dj){\\n        if (i<0 || j<0 || i==m || j==n || visited[i][j]==1 || mat[i][j]==-1)\\n            return 0;\\n        \\n        if (mat[i][j]==2){  // base case (hit the target)\\n            for (int a=0;a<m;a++)  // checking if any block in the visited array is unvisited\\n                for (int b=0;b<n;b++)\\n                    if (mat[a][b]!=-1 && mat[a][b]!=2 && visited[a][b]==0)\\n                        return 0;\\n            return 1;\\n        }\\n\\n        visited[i][j] = 1;\\n        int counter = 0;\\n        for (int k=0;k<4;k++)\\n            counter += getPaths(i+di[k], j+dj[k], mat, m, n, visited, di, dj);\\n        visited[i][j] = 0;\\n        return counter;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> visited(m, vector<int>(n, 0));\\n        int di[4] = {1, 0, -1, 0};\\n        int dj[4] = {0, 1, 0, -1};\\n        int i, j;\\n        bool flag = false;\\n        for (i=0; i<m && flag==false; i++)  // searching for the starting point (grid[i][j]=1)\\n            for (j=0;j<n;j++)\\n                if (grid[i][j]==1){\\n                    flag = true;\\n                    break;\\n                }\\n        return getPaths(--i, j, grid, m, n, visited, di, dj);  // --i to get the correct position of the starting point (due to the method used to break out of 2 for loops)\\n    }\\n```",
                "solutionTags": [],
                "code": "``` \\nint getPaths(int i, int j, vector<vector<int>> &mat, int m, int n, vector<vector<int>> &visited, int* di, int* dj){\\n        if (i<0 || j<0 || i==m || j==n || visited[i][j]==1 || mat[i][j]==-1)\\n            return 0;\\n        \\n        if (mat[i][j]==2){  // base case (hit the target)\\n            for (int a=0;a<m;a++)  // checking if any block in the visited array is unvisited\\n                for (int b=0;b<n;b++)\\n                    if (mat[a][b]!=-1 && mat[a][b]!=2 && visited[a][b]==0)\\n                        return 0;\\n            return 1;\\n        }\\n\\n        visited[i][j] = 1;\\n        int counter = 0;\\n        for (int k=0;k<4;k++)\\n            counter += getPaths(i+di[k], j+dj[k], mat, m, n, visited, di, dj);\\n        visited[i][j] = 0;\\n        return counter;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> visited(m, vector<int>(n, 0));\\n        int di[4] = {1, 0, -1, 0};\\n        int dj[4] = {0, 1, 0, -1};\\n        int i, j;\\n        bool flag = false;\\n        for (i=0; i<m && flag==false; i++)  // searching for the starting point (grid[i][j]=1)\\n            for (j=0;j<n;j++)\\n                if (grid[i][j]==1){\\n                    flag = true;\\n                    break;\\n                }\\n        return getPaths(--i, j, grid, m, n, visited, di, dj);  // --i to get the correct position of the starting point (due to the method used to break out of 2 for loops)\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1373845,
                "title": "c-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int answer , countZeros , n , m;\\n    bool vis[30][30];\\n    \\n    bool valid(int i,int j){\\n        return (i>=0 and j>=0 and i<n and j<m);\\n    }\\n    \\n    void dfs(int i,int j,int ct0,vector<vector<int>>& grid){\\n        if(valid(i,j) == 0 or vis[i][j] or grid[i][j] == -1)\\n            return;\\n        vis[i][j] = 1;\\n        if(grid[i][j] == 0)\\n            ++ct0;\\n        if(ct0 == countZeros and grid[i][j] == 2)\\n            ++answer;\\n        \\n        dfs(i+1,j,ct0,grid);\\n        dfs(i,j+1,ct0,grid);\\n        dfs(i-1,j,ct0,grid);\\n        dfs(i,j-1,ct0,grid);\\n        \\n        if(grid[i][j] == 0)\\n            --ct0;\\n        vis[i][j] = 0;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        answer = 0 , countZeros = 0;\\n        memset(vis,0,sizeof vis);\\n        for(auto it : grid){\\n            for(auto it2 : it)\\n                countZeros += (it2 == 0);\\n        }\\n        n = grid.size() , m = grid[0].size();\\n        \\n        int startx, starty , flag = 1;\\n        for(int i=0;i<n and flag;++i){\\n            for(int j=0;j<m and flag;++j){\\n                if(grid[i][j] == 1){\\n                    startx = i, starty = j;\\n                    flag = 0;\\n                    break;\\n                }\\n            }\\n        }\\n        dfs(startx,starty,0,grid);\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int answer , countZeros , n , m;\\n    bool vis[30][30];\\n    \\n    bool valid(int i,int j){\\n        return (i>=0 and j>=0 and i<n and j<m);\\n    }\\n    \\n    void dfs(int i,int j,int ct0,vector<vector<int>>& grid){\\n        if(valid(i,j) == 0 or vis[i][j] or grid[i][j] == -1)\\n            return;\\n        vis[i][j] = 1;\\n        if(grid[i][j] == 0)\\n            ++ct0;\\n        if(ct0 == countZeros and grid[i][j] == 2)\\n            ++answer;\\n        \\n        dfs(i+1,j,ct0,grid);\\n        dfs(i,j+1,ct0,grid);\\n        dfs(i-1,j,ct0,grid);\\n        dfs(i,j-1,ct0,grid);\\n        \\n        if(grid[i][j] == 0)\\n            --ct0;\\n        vis[i][j] = 0;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        answer = 0 , countZeros = 0;\\n        memset(vis,0,sizeof vis);\\n        for(auto it : grid){\\n            for(auto it2 : it)\\n                countZeros += (it2 == 0);\\n        }\\n        n = grid.size() , m = grid[0].size();\\n        \\n        int startx, starty , flag = 1;\\n        for(int i=0;i<n and flag;++i){\\n            for(int j=0;j<m and flag;++j){\\n                if(grid[i][j] == 1){\\n                    startx = i, starty = j;\\n                    flag = 0;\\n                    break;\\n                }\\n            }\\n        }\\n        dfs(startx,starty,0,grid);\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333542,
                "title": "c-solution-with-explanation",
                "content": "**This problem is similar to basic backtracking problems like find the shortest path from start to bottom if you don\\'t know that one then try them first and then come to this problem **\\n\\n**So lets begin, in this problem it is given that we have to find no. of ways to reach end from start so 1st thing in our mind is to where is start so we first find it by finding it index and we have to cover all routes that have values zero so 2nd thing in our mind is how many zero we have to covered to reach end so for this we calculate no. of zeroes **\\n**Now the problem is simplified to basic backtracking problem where we have to go in all directions and if we covered all zeroes then we have to return it as valid path or otherwise not valid and sum up all the valid paths  **\\n```\\nclass Solution {\\npublic:\\n       int rec(vector<vector<int>>& grid , int x , int y , int zero){ \\n         if(x < 0 ||y < 0 || x >= grid.size() || y >= grid[0].size() || grid[x][y] == -1 ) return 0; \\n      if(grid[x][y] == 2){     \\n      if(zero == -1){\\n          return 1; \\n      } return 0; \\n          }\\n           grid[x][y] = -1;\\n          int paths =  rec(grid , x-1 , y , zero-1) + rec(grid ,  x+1 , y  , zero-1) + rec(grid ,  x , y-1  , zero-1) + rec(grid ,  x , y+1  , zero-1);  \\n           grid[x][y] = 0; \\n           zero++; \\n       return paths;\\n       }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int start  = 0 ; \\n        int end = 0; \\n        int zero  = 0; \\n          for( int i = 0; i < grid.size() ; i++){ \\n              for(int j = 0; j<grid[0].size() ; j++){ \\n                  if(grid[i][j] ==  1 ) { \\n                    start = i; \\n                      end = j; \\n                  }\\n                  if(grid[i][j] == 0) zero++; \\n              }\\n          }  \\n      return rec(grid , start , end , zero);   \\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n       int rec(vector<vector<int>>& grid , int x , int y , int zero){ \\n         if(x < 0 ||y < 0 || x >= grid.size() || y >= grid[0].size() || grid[x][y] == -1 ) return 0; \\n      if(grid[x][y] == 2){     \\n      if(zero == -1){\\n          return 1; \\n      } return 0; \\n          }\\n           grid[x][y] = -1;\\n          int paths =  rec(grid , x-1 , y , zero-1) + rec(grid ,  x+1 , y  , zero-1) + rec(grid ,  x , y-1  , zero-1) + rec(grid ,  x , y+1  , zero-1);  \\n           grid[x][y] = 0; \\n           zero++; \\n       return paths;\\n       }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int start  = 0 ; \\n        int end = 0; \\n        int zero  = 0; \\n          for( int i = 0; i < grid.size() ; i++){ \\n              for(int j = 0; j<grid[0].size() ; j++){ \\n                  if(grid[i][j] ==  1 ) { \\n                    start = i; \\n                      end = j; \\n                  }\\n                  if(grid[i][j] == 0) zero++; \\n              }\\n          }  \\n      return rec(grid , start , end , zero);   \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252027,
                "title": "simple-java-solution-commented",
                "content": "```\\nclass Solution {\\n    public int uniquePathsIII(int[][] A) {\\n\\t\\tint i = 0, j = 0, n = A.length, m = A[0].length;\\n\\t\\tint p = 0, q = 0, zero = 0;\\n\\t\\tfor (i = 0; i < n; i++) {\\n\\t\\t\\tfor (j = 0; j < m; j++) {\\n\\t\\t\\t\\tif (A[i][j] == 1) {\\n\\t\\t\\t\\t\\tp = i;\\n\\t\\t\\t\\t\\tq = j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (A[i][j] == 0)\\n\\t\\t\\t\\t\\tzero += 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//p and q are starting position\\n\\t\\tint totalPath = getPathCount(p, q, A, zero, 0);\\n\\t\\treturn totalPath;\\n\\t}\\n\\n\\tprivate int getPathCount(int x, int y, int[][] path, int zero, int cnt) {\\n\\t   // If any of this condition is true we will not be having any path. (checking for out of bound and          obstacle)\\n\\t\\tif (x < 0 || y < 0 || x == path.length || y == path[0].length || path[x][y] == -1) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (path[x][y] == 2) {\\n\\t\\t    // Found path, then check for total non-obstacle .\\n\\t\\t\\tif (cnt == zero + 1) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tpath[x][y] = -1;  // making this grid as obstacle to avoid looping in same path \\n\\t\\tcnt += 1;  \\n\\t\\tint d1 = getPathCount(x + 1, y, path, zero, cnt);\\n\\t\\tint d2 = getPathCount(x - 1, y, path, zero, cnt);\\n\\t\\tint d3 = getPathCount(x, y + 1, path, zero, cnt);\\n\\t\\tint d4 = getPathCount(x, y - 1, path, zero, cnt);\\n\\t\\tpath[x][y] = 0;  // re-setting path as non-obstacle.\\n\\t\\treturn d1 + d2 + d3 + d4;\\n\\n\\t}\\n}\\n```\\n**Time Complexity:**\\nSince for every sqaure we are traversing in 4 direction and we can have (N*M)-2  sqaure with 0 (in worst case).\\nTC: O(4^NM) \\n\\n**Space Complexity:**\\nSC: O(NM)",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsIII(int[][] A) {\\n\\t\\tint i = 0, j = 0, n = A.length, m = A[0].length;\\n\\t\\tint p = 0, q = 0, zero = 0;\\n\\t\\tfor (i = 0; i < n; i++) {\\n\\t\\t\\tfor (j = 0; j < m; j++) {\\n\\t\\t\\t\\tif (A[i][j] == 1) {\\n\\t\\t\\t\\t\\tp = i;\\n\\t\\t\\t\\t\\tq = j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (A[i][j] == 0)\\n\\t\\t\\t\\t\\tzero += 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//p and q are starting position\\n\\t\\tint totalPath = getPathCount(p, q, A, zero, 0);\\n\\t\\treturn totalPath;\\n\\t}\\n\\n\\tprivate int getPathCount(int x, int y, int[][] path, int zero, int cnt) {\\n\\t   // If any of this condition is true we will not be having any path. (checking for out of bound and          obstacle)\\n\\t\\tif (x < 0 || y < 0 || x == path.length || y == path[0].length || path[x][y] == -1) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (path[x][y] == 2) {\\n\\t\\t    // Found path, then check for total non-obstacle .\\n\\t\\t\\tif (cnt == zero + 1) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tpath[x][y] = -1;  // making this grid as obstacle to avoid looping in same path \\n\\t\\tcnt += 1;  \\n\\t\\tint d1 = getPathCount(x + 1, y, path, zero, cnt);\\n\\t\\tint d2 = getPathCount(x - 1, y, path, zero, cnt);\\n\\t\\tint d3 = getPathCount(x, y + 1, path, zero, cnt);\\n\\t\\tint d4 = getPathCount(x, y - 1, path, zero, cnt);\\n\\t\\tpath[x][y] = 0;  // re-setting path as non-obstacle.\\n\\t\\treturn d1 + d2 + d3 + d4;\\n\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219366,
                "title": "dfs-and-backtracking",
                "content": "This question uses DFS or flood fill algorithm to traverse the grid.\\nStep 1: Find the starting point in the given grid\\nStep 2: Make a **visited matrix** and **initialize it to 0** also make an **answer variable** and **initialize it to 0** as well\\nStep 3: Make a call to the DFS function \\n____________DFS function accepts  following parameters:-\\n__________GRID , ROW INDEX(starting) , COLUMN INDEX(starting), ans, visited \\n\\n\\n\\n**Inside DFS function:**\\n\\nStep 1: Check the **validity of row and column** also **check if it is non movable block** and **check for visited**. If any of the conditions are met we just return\\nStep 2: Check if the position we are current on is the ending position or not\\n--->**if yes,**  then traverse the **entire visited matrix** , if any block is not visited just return.\\n--->**else**, if every block is visited** increment the ans by  1 and return**\\n Step 3: If it is **not the final position** then **mark the visited as 1**  and perform DFS on the neighbouring cells \\n -->i,e.** row+1, col  || row-1, col || row, col+1 || row, col-1**\\n \\n After  all the DFS calls are completed just return the ans from the main function\\n \\n```\\n\\nclass Solution {\\npublic:\\nvoid solve(vector<vector<int>>&grid,int row,int col,int &ans,vector<vector<int>>vis){\\n//// CHECK FOR ALL THE INVALID CASES\\nif(row<0 || row>=grid.size() || col<0 || col>=grid[0].size() || vis[row][col]==1 || grid[row][col]==-1){\\nreturn;\\n}\\n\\n/// CHECK FOR ENDING POSITION\\nif(grid[row][col]==2){\\nvis[row][col]=1;\\nfor(int i=0;i<grid.size();i++){\\nfor(int j=0;j<grid[0].size();j++){\\nif(vis[i][j]==0 and grid[i][j]!=-1){\\nreturn;\\n}\\n\\n}\\n}\\nans+=1;\\nreturn;\\n}\\n\\n//// MARKING THE VISITED AS TRUE \\nvis[row][col]=1;\\n\\n//// DFS CALL FOR THE NEIGHBOURS\\nsolve(grid,row+1,col,ans,vis);\\nsolve(grid,row-1,col,ans,vis);\\nsolve(grid,row,col+1,ans,vis);\\nsolve(grid,row,col-1,ans,vis);\\n\\n}\\nint uniquePathsIII(vector<vector<int>>& grid) {\\nint ans=0;\\nint n=grid.size();\\nint m=grid[0].size();\\nint i=0;\\nint j=0;\\n\\n////  VISITED ARRAY \\nvector<vector<int>>vis(n,vector<int>(m,0));\\n\\n///// FINDING THE STARTING ROW  AND COLUMN \\nfor(;i<n;i++){\\nfor(j=0;j<m;j++){\\nif(grid[i][j]==1)break;\\n}\\nif(j!=m)break;\\n}\\n\\n/// CALLING THE DFS FUNCTION \\nsolve(grid,i,j,ans,vis);\\n\\n\\nreturn ans;\\n}\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\nvoid solve(vector<vector<int>>&grid,int row,int col,int &ans,vector<vector<int>>vis){\\n//// CHECK FOR ALL THE INVALID CASES\\nif(row<0 || row>=grid.size() || col<0 || col>=grid[0].size() || vis[row][col]==1 || grid[row][col]==-1){\\nreturn;\\n}\\n\\n/// CHECK FOR ENDING POSITION\\nif(grid[row][col]==2){\\nvis[row][col]=1;\\nfor(int i=0;i<grid.size();i++){\\nfor(int j=0;j<grid[0].size();j++){\\nif(vis[i][j]==0 and grid[i][j]!=-1){\\nreturn;\\n}\\n\\n}\\n}\\nans+=1;\\nreturn;\\n}\\n\\n//// MARKING THE VISITED AS TRUE \\nvis[row][col]=1;\\n\\n//// DFS CALL FOR THE NEIGHBOURS\\nsolve(grid,row+1,col,ans,vis);\\nsolve(grid,row-1,col,ans,vis);\\nsolve(grid,row,col+1,ans,vis);\\nsolve(grid,row,col-1,ans,vis);\\n\\n}\\nint uniquePathsIII(vector<vector<int>>& grid) {\\nint ans=0;\\nint n=grid.size();\\nint m=grid[0].size();\\nint i=0;\\nint j=0;\\n\\n////  VISITED ARRAY \\nvector<vector<int>>vis(n,vector<int>(m,0));\\n\\n///// FINDING THE STARTING ROW  AND COLUMN \\nfor(;i<n;i++){\\nfor(j=0;j<m;j++){\\nif(grid[i][j]==1)break;\\n}\\nif(j!=m)break;\\n}\\n\\n/// CALLING THE DFS FUNCTION \\nsolve(grid,i,j,ans,vis);\\n\\n\\nreturn ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113808,
                "title": "java-better-than-100-of-submissions-backtracking",
                "content": "```\\nclass Solution {\\n    int res=0;\\n    public int uniquePathsIII(int[][] grid) {\\n        int zero=0,is=0,js=0,ie=0,je=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==0)   zero++;\\n                else if(grid[i][j]==1){\\n                    is=i;\\n                    js=j;\\n                }\\n                else if(grid[i][j]==2){\\n                    ie=i;\\n                    je=j;\\n                }\\n            }\\n        }\\n        func(grid,is+1,js,zero);\\n        func(grid,is-1,js,zero);\\n        func(grid,is,js+1,zero);\\n        func(grid,is,js-1,zero);\\n        return res;\\n    }\\n    private void func(int[][] g, int i, int j, int zero){\\n        if(i<0 || i==g.length || j<0 || j==g[0].length) return;\\n        else if(g[i][j]==2){\\n            if(zero==0)  res++;\\n            return;\\n        }\\n        else if(g[i][j]==-1)    return;\\n        else if(g[i][j]==1) return;\\n        g[i][j]=-1;\\n        zero--;\\n        func(g,i+1,j,zero);\\n        func(g,i-1,j,zero);\\n        func(g,i,j+1,zero);\\n        func(g,i,j-1,zero);\\n        zero++;\\n        g[i][j]=0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int res=0;\\n    public int uniquePathsIII(int[][] grid) {\\n        int zero=0,is=0,js=0,ie=0,je=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==0)   zero++;\\n                else if(grid[i][j]==1){\\n                    is=i;\\n                    js=j;\\n                }\\n                else if(grid[i][j]==2){\\n                    ie=i;\\n                    je=j;\\n                }\\n            }\\n        }\\n        func(grid,is+1,js,zero);\\n        func(grid,is-1,js,zero);\\n        func(grid,is,js+1,zero);\\n        func(grid,is,js-1,zero);\\n        return res;\\n    }\\n    private void func(int[][] g, int i, int j, int zero){\\n        if(i<0 || i==g.length || j<0 || j==g[0].length) return;\\n        else if(g[i][j]==2){\\n            if(zero==0)  res++;\\n            return;\\n        }\\n        else if(g[i][j]==-1)    return;\\n        else if(g[i][j]==1) return;\\n        g[i][j]=-1;\\n        zero--;\\n        func(g,i+1,j,zero);\\n        func(g,i-1,j,zero);\\n        func(g,i,j+1,zero);\\n        func(g,i,j-1,zero);\\n        zero++;\\n        g[i][j]=0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096139,
                "title": "c-bitmask-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    using pii = pair<int, int>;\\n    using vi = vector<int>;\\n    using vii = vector<vi>;\\n    using viii = vector<vii>;\\n\\n    int rows;\\n    int cols;\\n    int validCells;\\n    viii dp;\\n\\n    int piiToNum(pii point) {\\n        return point.first * cols + point.second;\\n    }\\n    \\n    vector<int> dx = {-1, 1, 0, 0};\\n    vector<int> dy = {0, 0, -1, 1};\\n    \\n    int solve(pii now, pii target, int mask, vector<vector<int>>& grid) {\\n        if (now == target) {\\n            return validCells == __builtin_popcount(mask);\\n        }\\n        int& ret = dp[now.first][now.second][mask];\\n        if (ret != -1) {\\n            return ret;\\n        }\\n        \\n        ret = 0;\\n        for (int k = 0; k < 4; k++) {\\n            pii nxt = {now.first + dx[k], now.second + dy[k]};\\n            if (nxt.first >= 0 && nxt.first < rows && nxt.second >= 0 && nxt.second < cols && grid[nxt.first][nxt.second] != -1) {\\n                int bit = piiToNum(nxt);\\n                if (!(mask & (1 << bit)) && grid[nxt.first][nxt.second] != -1) {\\n                    ret += solve(nxt, target, mask | (1 << bit), grid);\\n                }   \\n            }\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        rows = grid.size();\\n        cols = grid[0].size();\\n        \\n        int obstacles = 0;\\n        pii start, target;\\n\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == -1) {\\n                    obstacles++;\\n                } else if (grid[i][j] == 1) {\\n                    start = {i, j};\\n                } else if (grid[i][j] == 2) {\\n                    target = {i, j};\\n                }\\n            }\\n        }\\n        \\n        validCells = rows * cols - obstacles;\\n        dp = viii(rows, vii(cols, vi(1 << (rows * cols), -1)));\\n        \\n        return solve(start, target, 1 << piiToNum(start), grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using pii = pair<int, int>;\\n    using vi = vector<int>;\\n    using vii = vector<vi>;\\n    using viii = vector<vii>;\\n\\n    int rows;\\n    int cols;\\n    int validCells;\\n    viii dp;\\n\\n    int piiToNum(pii point) {\\n        return point.first * cols + point.second;\\n    }\\n    \\n    vector<int> dx = {-1, 1, 0, 0};\\n    vector<int> dy = {0, 0, -1, 1};\\n    \\n    int solve(pii now, pii target, int mask, vector<vector<int>>& grid) {\\n        if (now == target) {\\n            return validCells == __builtin_popcount(mask);\\n        }\\n        int& ret = dp[now.first][now.second][mask];\\n        if (ret != -1) {\\n            return ret;\\n        }\\n        \\n        ret = 0;\\n        for (int k = 0; k < 4; k++) {\\n            pii nxt = {now.first + dx[k], now.second + dy[k]};\\n            if (nxt.first >= 0 && nxt.first < rows && nxt.second >= 0 && nxt.second < cols && grid[nxt.first][nxt.second] != -1) {\\n                int bit = piiToNum(nxt);\\n                if (!(mask & (1 << bit)) && grid[nxt.first][nxt.second] != -1) {\\n                    ret += solve(nxt, target, mask | (1 << bit), grid);\\n                }   \\n            }\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        rows = grid.size();\\n        cols = grid[0].size();\\n        \\n        int obstacles = 0;\\n        pii start, target;\\n\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == -1) {\\n                    obstacles++;\\n                } else if (grid[i][j] == 1) {\\n                    start = {i, j};\\n                } else if (grid[i][j] == 2) {\\n                    target = {i, j};\\n                }\\n            }\\n        }\\n        \\n        validCells = rows * cols - obstacles;\\n        dp = viii(rows, vii(cols, vi(1 << (rows * cols), -1)));\\n        \\n        return solve(start, target, 1 << piiToNum(start), grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1061049,
                "title": "python-backtracking-with-comments",
                "content": "The most important thing to keep in mind is the conditions:\\n- walk over every \"0\"?\\n\\t- For this, we need to count how many zeros we have first, no?\\n- do not walk over any -1\\n\\t- This can be a termination condition\\n- start at 1\\n\\t- Only start the backtracking if we reach a 1\\n- end at 2\\n\\t- If we reach a two and have touched all of the zeros, we can return/count this as one path!\\n\\n```python\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        \\n        global result\\n        result = 0\\n                    \\n        def backtrack(i, j, squares):\\n            global result\\n            \\n\\t\\t\\t# all the code below here is pretty much termination conditions from above bullet points...\\n\\t\\t\\t\\n            if not (0 <= i < len(grid)): return\\n            if not (0 <= j < len(grid[0])): return\\n            \\n            if grid[i][j] == -1: return # ignore obstacles\\n            \\n            if grid[i][j] == 2: # return\\n                if squares == 0:\\n                    result += 1 # only add result if we\\'ve reached all squares\\n                return             \\n            \\n            if grid[i][j] == 0:\\n                squares -= 1 # one less square to touch\\n\\t\\t\\t\\t\\n\\t\\t\\t# backtracking code to avoid walking in circles\\n\\t\\t\\t# ....\\n                \\n            grid[i][j] = -1\\n                \\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\\n                backtrack(x, y, squares)\\n                \\n            grid[i][j] = 0\\n                \\n                                \\n        # Figure out how many zeros we need?\\n        num_zeros = 0\\n        for i in grid:\\n            num_zeros += collections.Counter(i)[0]\\n               \\t\\t\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    backtrack(i, j, num_zeros)\\n        \\n        return result\\n```\\n\\n---\\n\\nCode without comments:\\n\\n```python\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        \\n\\t\\t\\n        global result\\n        result = 0\\n\\t\\t\\n                    \\n        def backtrack(i, j, squares):\\n            global result\\n            \\n            if not (0 <= i < len(grid)): return\\n            if not (0 <= j < len(grid[0])): return\\n            if grid[i][j] == -1: return\\n\\t\\t\\tif grid[i][j] == 0: squares -= 1\\n            if grid[i][j] == 2:\\n                if squares == 0: result += 1\\n                return\\n\\t\\t\\t\\t\\n            grid[i][j] = -1\\n\\t\\t\\t\\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\\n                backtrack(x, y, squares)\\n\\t\\t\\t\\t\\n            grid[i][j] = 0\\n\\t\\t\\n                \\n        num_zeros = 0\\n        for i in grid:\\n            num_zeros += collections.Counter(i)[0]\\n\\t\\t\\n               \\t\\t\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    backtrack(i, j, num_zeros)\\n        \\n\\t\\t\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```python\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        \\n        global result\\n        result = 0\\n                    \\n        def backtrack(i, j, squares):\\n            global result\\n            \\n\\t\\t\\t# all the code below here is pretty much termination conditions from above bullet points...\\n\\t\\t\\t\\n            if not (0 <= i < len(grid)): return\\n            if not (0 <= j < len(grid[0])): return\\n            \\n            if grid[i][j] == -1: return # ignore obstacles\\n            \\n            if grid[i][j] == 2: # return\\n                if squares == 0:\\n                    result += 1 # only add result if we\\'ve reached all squares\\n                return             \\n            \\n            if grid[i][j] == 0:\\n                squares -= 1 # one less square to touch\\n\\t\\t\\t\\t\\n\\t\\t\\t# backtracking code to avoid walking in circles\\n\\t\\t\\t# ....\\n                \\n            grid[i][j] = -1\\n                \\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\\n                backtrack(x, y, squares)\\n                \\n            grid[i][j] = 0\\n                \\n                                \\n        # Figure out how many zeros we need?\\n        num_zeros = 0\\n        for i in grid:\\n            num_zeros += collections.Counter(i)[0]\\n               \\t\\t\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    backtrack(i, j, num_zeros)\\n        \\n        return result\\n```\n```python\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        \\n\\t\\t\\n        global result\\n        result = 0\\n\\t\\t\\n                    \\n        def backtrack(i, j, squares):\\n            global result\\n            \\n            if not (0 <= i < len(grid)): return\\n            if not (0 <= j < len(grid[0])): return\\n            if grid[i][j] == -1: return\\n\\t\\t\\tif grid[i][j] == 0: squares -= 1\\n            if grid[i][j] == 2:\\n                if squares == 0: result += 1\\n                return\\n\\t\\t\\t\\t\\n            grid[i][j] = -1\\n\\t\\t\\t\\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\\n                backtrack(x, y, squares)\\n\\t\\t\\t\\t\\n            grid[i][j] = 0\\n\\t\\t\\n                \\n        num_zeros = 0\\n        for i in grid:\\n            num_zeros += collections.Counter(i)[0]\\n\\t\\t\\n               \\t\\t\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    backtrack(i, j, num_zeros)\\n        \\n\\t\\t\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936811,
                "title": "java-dfs-solution",
                "content": "credits to : @lee215\\n```\\nclass Solution {\\n    int ans = 0;\\n    int totalEmpty = 1;\\n    \\n    public int uniquePathsIII(int[][] grid) {\\n        int row = -1;\\n        int col = -1;\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j =0; j < grid[0].length; j++){\\n                if(grid[i][j] == 1){\\n                    row = i;\\n                    col = j;\\n                }else if(grid[i][j] == 0){\\n                    totalEmpty++;\\n                }\\n            }\\n        }\\n        \\n        dfs(grid, row, col);\\n        return ans;\\n    }\\n    \\n    public void dfs(int [][]grid, int r, int c){\\n        \\n        if(r < 0 || c <0 || r >= grid.length || c >= grid[0].length || grid[r][c] < 0)\\n            return;\\n        \\n        if(grid[r][c] == 2){\\n            if(totalEmpty == 0)\\n            ans += 1;\\n            return;\\n        }\\n        \\n        grid[r][c] = -2;\\n        totalEmpty--;\\n        dfs(grid, r+1,c);\\n        dfs(grid, r-1,c);\\n        dfs(grid, r,c+1);\\n        dfs(grid, r,c-1);\\n        grid[r][c] = 0;\\n        totalEmpty++;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    int totalEmpty = 1;\\n    \\n    public int uniquePathsIII(int[][] grid) {\\n        int row = -1;\\n        int col = -1;\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j =0; j < grid[0].length; j++){\\n                if(grid[i][j] == 1){\\n                    row = i;\\n                    col = j;\\n                }else if(grid[i][j] == 0){\\n                    totalEmpty++;\\n                }\\n            }\\n        }\\n        \\n        dfs(grid, row, col);\\n        return ans;\\n    }\\n    \\n    public void dfs(int [][]grid, int r, int c){\\n        \\n        if(r < 0 || c <0 || r >= grid.length || c >= grid[0].length || grid[r][c] < 0)\\n            return;\\n        \\n        if(grid[r][c] == 2){\\n            if(totalEmpty == 0)\\n            ans += 1;\\n            return;\\n        }\\n        \\n        grid[r][c] = -2;\\n        totalEmpty--;\\n        dfs(grid, r+1,c);\\n        dfs(grid, r-1,c);\\n        dfs(grid, r,c+1);\\n        dfs(grid, r,c-1);\\n        grid[r][c] = 0;\\n        totalEmpty++;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899021,
                "title": "java-100-fast-explained-dfs",
                "content": "If you found the solution helpful, kindly upvote. :)\\n       \\n\\t   **METHOD**\\n\\t   \\n        1. Count the total number of zeroes in the grid\\n        2. Find the coordinates of the starting index and store it.\\n        3. Call dfs in all 4 directions, and if the path has all zeroes covered, increment result.\\n \\n\\n```\\nclass Solution {\\n        public int uniquePathsIII(int[][] grid) {\\n        /*\\n        \\n        */\\n        \\n        int rows= grid.length;\\n        int cols= grid[0].length;\\n        int numZero=0, sx=0, sy=0;\\n\\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++){\\n                if(grid[i][j]==1){\\n                    sx=i; sy=j;\\n                }\\n                else if(grid[i][j]==0)\\n                    numZero++;\\n            }\\n        }\\n        \\n        return dfs(grid, sx, sy, numZero);\\n    }\\n\\n    private int dfs(int[][] grid, int sx, int sy, int numZero) {\\n        //Boundary checks\\n        if(sx<0 || sy<0 ||sx>=grid.length || sy>=grid[0].length || grid[sx][sy]==-1)\\n            return 0;\\n        //If the destination is reached\\n        if(grid[sx][sy]==2)\\n            return numZero==-1? 1:0;\\n\\n        //Marking the cell\\n        grid[sx][sy]=-1;\\n        numZero--;\\n        int totalPath= dfs(grid, sx+1, sy, numZero)+\\n                        dfs(grid, sx-1, sy, numZero)+\\n                        dfs(grid, sx, sy+1, numZero)+\\n                        dfs(grid, sx, sy-1, numZero);\\n        //Backtracking\\n        grid[sx][sy]=0;\\n        numZero++;\\n        return totalPath;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        public int uniquePathsIII(int[][] grid) {\\n        /*\\n        \\n        */\\n        \\n        int rows= grid.length;\\n        int cols= grid[0].length;\\n        int numZero=0, sx=0, sy=0;\\n\\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++){\\n                if(grid[i][j]==1){\\n                    sx=i; sy=j;\\n                }\\n                else if(grid[i][j]==0)\\n                    numZero++;\\n            }\\n        }\\n        \\n        return dfs(grid, sx, sy, numZero);\\n    }\\n\\n    private int dfs(int[][] grid, int sx, int sy, int numZero) {\\n        //Boundary checks\\n        if(sx<0 || sy<0 ||sx>=grid.length || sy>=grid[0].length || grid[sx][sy]==-1)\\n            return 0;\\n        //If the destination is reached\\n        if(grid[sx][sy]==2)\\n            return numZero==-1? 1:0;\\n\\n        //Marking the cell\\n        grid[sx][sy]=-1;\\n        numZero--;\\n        int totalPath= dfs(grid, sx+1, sy, numZero)+\\n                        dfs(grid, sx-1, sy, numZero)+\\n                        dfs(grid, sx, sy+1, numZero)+\\n                        dfs(grid, sx, sy-1, numZero);\\n        //Backtracking\\n        grid[sx][sy]=0;\\n        numZero++;\\n        return totalPath;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878600,
                "title": "java-backtracking-clean-code-with-full-comments-100-speed-95-29-space",
                "content": "```\\n    int count = 0;  // Set counter.\\n    int startPointX = 0; // Set index for the starting point.\\n    int startPointY = 0;\\n    \\n    public int uniquePathsIII(int[][] grid) // Main method.\\n    {\\n       for(int i = 0; i < grid.length; i++) // The nested for loops are responsible for locating the starting point.\\n       {\\n           for(int j = 0; j < grid[0].length; j++)\\n           {\\n               if(grid[i][j] == 1) // When the starting point has been found, assigned the starting index x & y.\\n               {\\n                   startPointX = i;\\n                   startPointY = j;\\n               }\\n               if(grid[i][j] == 0) // When the value in a given spot are zero, count it.\\n               {\\n                   count++;\\n               }\\n           }\\n       }\\n          return helper(grid, startPointX, startPointY, count); \\n    }\\n    \\n    private int helper(int[][] grid, int x, int y, int count) // Helper method.\\n    {\\n        \\n        if(x < 0 || grid.length-1 < x || y < 0 || grid[0].length-1 < y || grid[x][y] == -1) // Boundaries, visited spots and forbidden spots check.\\n        {\\n            return 0;\\n        }\\n        \\n        if(grid[x][y] == 2) // If we stumbled upon a spot with value of two, thats mean that we have finish the current iteration.\\n        {\\n            if(count == -1) // Check for valid count.\\n            {\\n                return 1;\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n            int temp = grid[x][y]; // Copy a current spots value in order to not repeat it in the current iteration.\\n            grid[x][y] = -1; // Overwrite the current value white zero so that we will know that we have been here before.\\n            count--;\\n\\t\\t\\t\\n            int up = helper(grid, x-1, y,count);   // valid movements for traversing the matrix.\\n            int down = helper(grid, x+1, y, count);\\n            int left = helper(grid, x, y-1, count);\\n            int right = helper(grid, x, y+1,count);\\n            \\n            grid[x][y] = temp; // After traversing return the original value of a spot for the next iteration.\\n            count++; // count the iteration.\\n            return up + down + left + right; // return a valid movement. (backtracking keeps all movements of a current iteration untill the end of it).\\n\\t\\t\\t\\n     }  // Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths III.\\n\\t    // Memory Usage: 36.4 MB, less than 95.29% of Java online submissions for Unique Paths III.",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n    int count = 0;  // Set counter.\\n    int startPointX = 0; // Set index for the starting point.\\n    int startPointY = 0;\\n    \\n    public int uniquePathsIII(int[][] grid) // Main method.\\n    {\\n       for(int i = 0; i < grid.length; i++) // The nested for loops are responsible for locating the starting point.\\n       {\\n           for(int j = 0; j < grid[0].length; j++)\\n           {\\n               if(grid[i][j] == 1) // When the starting point has been found, assigned the starting index x & y.\\n               {\\n                   startPointX = i;\\n                   startPointY = j;\\n               }\\n               if(grid[i][j] == 0) // When the value in a given spot are zero, count it.\\n               {\\n                   count++;\\n               }\\n           }\\n       }\\n          return helper(grid, startPointX, startPointY, count); \\n    }\\n    \\n    private int helper(int[][] grid, int x, int y, int count) // Helper method.\\n    {\\n        \\n        if(x < 0 || grid.length-1 < x || y < 0 || grid[0].length-1 < y || grid[x][y] == -1) // Boundaries, visited spots and forbidden spots check.\\n        {\\n            return 0;\\n        }\\n        \\n        if(grid[x][y] == 2) // If we stumbled upon a spot with value of two, thats mean that we have finish the current iteration.\\n        {\\n            if(count == -1) // Check for valid count.\\n            {\\n                return 1;\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n            int temp = grid[x][y]; // Copy a current spots value in order to not repeat it in the current iteration.\\n            grid[x][y] = -1; // Overwrite the current value white zero so that we will know that we have been here before.\\n            count--;\\n\\t\\t\\t\\n            int up = helper(grid, x-1, y,count);   // valid movements for traversing the matrix.\\n            int down = helper(grid, x+1, y, count);\\n            int left = helper(grid, x, y-1, count);\\n            int right = helper(grid, x, y+1,count);\\n            \\n            grid[x][y] = temp; // After traversing return the original value of a spot for the next iteration.\\n            count++; // count the iteration.\\n            return up + down + left + right; // return a valid movement. (backtracking keeps all movements of a current iteration untill the end of it).\\n\\t\\t\\t\\n     }  // Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths III.\\n\\t    // Memory Usage: 36.4 MB, less than 95.29% of Java online submissions for Unique Paths III.",
                "codeTag": "Unknown"
            },
            {
                "id": 857674,
                "title": "simple-dfs-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int f=0;\\n    void func(vector<vector<int>> grid,int i,int j,int c)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size())\\n        {\\n            return;\\n        }\\n        if(grid[i][j]==-1 || grid[i][j]==3)\\n        {\\n            return;\\n        }\\n        if(grid[i][j]==2 && c==0)\\n        {\\n            f++;\\n            return;\\n        }\\n        if(grid[i][j]==2)\\n        {\\n            return;\\n        }\\n        grid[i][j]=3; /// mark the point as visited\\n        func(grid,i,j+1,c-1);\\n        func(grid,i+1,j,c-1);\\n        func(grid,i-1,j,c-1);\\n        func(grid,i,j-1,c-1);\\n        \\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int x,y,c=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    x=i;\\n                    y=j;\\n                }\\n                if(grid[i][j]==0)\\n                {\\n                    c++;\\n                }\\n            }\\n        }\\n        func(grid,x,y,c+1);\\n        return f;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int f=0;\\n    void func(vector<vector<int>> grid,int i,int j,int c)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size())\\n        {\\n            return;\\n        }\\n        if(grid[i][j]==-1 || grid[i][j]==3)\\n        {\\n            return;\\n        }\\n        if(grid[i][j]==2 && c==0)\\n        {\\n            f++;\\n            return;\\n        }\\n        if(grid[i][j]==2)\\n        {\\n            return;\\n        }\\n        grid[i][j]=3; /// mark the point as visited\\n        func(grid,i,j+1,c-1);\\n        func(grid,i+1,j,c-1);\\n        func(grid,i-1,j,c-1);\\n        func(grid,i,j-1,c-1);\\n        \\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int x,y,c=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    x=i;\\n                    y=j;\\n                }\\n                if(grid[i][j]==0)\\n                {\\n                    c++;\\n                }\\n            }\\n        }\\n        func(grid,x,y,c+1);\\n        return f;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856749,
                "title": "why-doesn-t-memoization-work",
                "content": "Could anyone explain why the following memoization strategy to reduce the time complexity gives a wrong answer?\\n\\nThe idea is the same as that of the official solution. We simply do the DFS with backtracking to count the number of answers. In addition, the following solution caches the solutions to subproblems in a 2D matrix `memo`.\\n\\n```java\\nclass Solution {\\n    int targetPathLen = 1;\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int startRow = -1;\\n        int startCol= -1;\\n\\n        for (int row = 0; row < n; row++) {\\n            for (int col = 0; col < m; col++) {\\n                if (grid[row][col] == 1) {\\n                    startRow = row;\\n                    startCol = col;\\n                } else if (grid[row][col] == 0) {\\n                    targetPathLen++;\\n                }\\n            }\\n        }\\n        \\n        boolean[][] onStack = new boolean[n][m];\\n        int[][] memo = new int[n][m];\\n        for (int row = 0; row < n; row++) {\\n            for(int col = 0; col < m; col++) {\\n                memo[row][col] = -1;\\n            }\\n        }\\n        \\n        return dfs(grid, startRow, startCol, onStack, memo, 0);\\n    }\\n    \\n    private int dfs(int[][] grid, int row, int col, boolean[][] onStack, int[][] memo, int coveredLen) {\\n        if (row < 0 || row > grid.length - 1 || col < 0 || col > grid[0].length - 1) {\\n            return 0;\\n        }\\n        \\n        int val = grid[row][col];\\n        if (val == -1 || onStack[row][col]) {\\n            return 0;\\n        }\\n        \\n        if (memo[row][col] != -1) {\\n            return memo[row][col];\\n        }\\n        \\n        if (val == 2) {\\n            if (targetPathLen == coveredLen) {\\n                return 1;\\n            }\\n            \\n            return 0;\\n        }\\n    \\n        onStack[row][col] = true;\\n\\n        int ans = dfs(grid, row-1, col, onStack, memo, coveredLen + 1) +\\n            dfs(grid, row+1, col, onStack, memo, coveredLen + 1) +\\n            dfs(grid, row, col-1, onStack, memo, coveredLen + 1) +\\n            dfs(grid, row, col+1, onStack, memo, coveredLen + 1);\\n\\n        onStack[row][col] = false;\\n\\n        memo[row][col] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    int targetPathLen = 1;\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int startRow = -1;\\n        int startCol= -1;\\n\\n        for (int row = 0; row < n; row++) {\\n            for (int col = 0; col < m; col++) {\\n                if (grid[row][col] == 1) {\\n                    startRow = row;\\n                    startCol = col;\\n                } else if (grid[row][col] == 0) {\\n                    targetPathLen++;\\n                }\\n            }\\n        }\\n        \\n        boolean[][] onStack = new boolean[n][m];\\n        int[][] memo = new int[n][m];\\n        for (int row = 0; row < n; row++) {\\n            for(int col = 0; col < m; col++) {\\n                memo[row][col] = -1;\\n            }\\n        }\\n        \\n        return dfs(grid, startRow, startCol, onStack, memo, 0);\\n    }\\n    \\n    private int dfs(int[][] grid, int row, int col, boolean[][] onStack, int[][] memo, int coveredLen) {\\n        if (row < 0 || row > grid.length - 1 || col < 0 || col > grid[0].length - 1) {\\n            return 0;\\n        }\\n        \\n        int val = grid[row][col];\\n        if (val == -1 || onStack[row][col]) {\\n            return 0;\\n        }\\n        \\n        if (memo[row][col] != -1) {\\n            return memo[row][col];\\n        }\\n        \\n        if (val == 2) {\\n            if (targetPathLen == coveredLen) {\\n                return 1;\\n            }\\n            \\n            return 0;\\n        }\\n    \\n        onStack[row][col] = true;\\n\\n        int ans = dfs(grid, row-1, col, onStack, memo, coveredLen + 1) +\\n            dfs(grid, row+1, col, onStack, memo, coveredLen + 1) +\\n            dfs(grid, row, col-1, onStack, memo, coveredLen + 1) +\\n            dfs(grid, row, col+1, onStack, memo, coveredLen + 1);\\n\\n        onStack[row][col] = false;\\n\\n        memo[row][col] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856578,
                "title": "python-simple-concise-backtrack",
                "content": "```python\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        def isvalid(x, y): return 0 <= x < m and 0 <= y < n            \\n        def dfs(x, y, zeros_remaining):\\n            if zeros_remaining == 0:\\n                # find if there is end box\\n                for xx, yy in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\\n                    if isvalid(x + xx, y + yy) and grid[x + xx][y + yy] == 2: self.path += 1\\n            else:\\n                # go to neighboring empty grid\\n                temp, grid[x][y] = grid[x][y], VISITED\\n                for xx, yy in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\\n                    if isvalid(x + xx, y + yy) and grid[x + xx][y + yy] == 0: dfs(x + xx, y + yy, zeros_remaining - 1)\\n                grid[x][y] = temp\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        # find start index, and count zeros\\n        zeros, startx, starty = 0, 0, 0\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 1: startx, starty = r, c\\n                if grid[r][c] == 0: zeros += 1\\n\\t\\t\\t\\t\\n        self.path, VISITED = 0, \\'#\\'\\n        dfs(startx, starty, zeros)\\n        return self.path\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        def isvalid(x, y): return 0 <= x < m and 0 <= y < n            \\n        def dfs(x, y, zeros_remaining):\\n            if zeros_remaining == 0:\\n                # find if there is end box\\n                for xx, yy in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\\n                    if isvalid(x + xx, y + yy) and grid[x + xx][y + yy] == 2: self.path += 1\\n            else:\\n                # go to neighboring empty grid\\n                temp, grid[x][y] = grid[x][y], VISITED\\n                for xx, yy in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\\n                    if isvalid(x + xx, y + yy) and grid[x + xx][y + yy] == 0: dfs(x + xx, y + yy, zeros_remaining - 1)\\n                grid[x][y] = temp\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        # find start index, and count zeros\\n        zeros, startx, starty = 0, 0, 0\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 1: startx, starty = r, c\\n                if grid[r][c] == 0: zeros += 1\\n\\t\\t\\t\\t\\n        self.path, VISITED = 0, \\'#\\'\\n        dfs(startx, starty, zeros)\\n        return self.path\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856354,
                "title": "alternative-solution-using-dp-and-bitmask-o-2-n-n",
                "content": "Most solutions with dfs / backtracking have runtime complexity O(3^N), where N is the number of cells. Alternative solution is to do this with dp and bitmask, which achieves a better runtime complexity of O(2^N * N).\\n\\nLet `bits` be a bitmap of current visited cells, `r` and `c` be current location. Traversing the four possible directions take O(1) time with memoization. If we ever reach 2 and all valid zeros in the bitmap has been set, we get a valid path. `dp` sums number of valid paths for all four directions.\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        R, C = len(grid), len(grid[0])\\n        count0 = sum([row.count(0) for row in grid])\\n        @lru_cache(None)\\n        def dp(bits, r, c):\\n            res = 0\\n            count1 = bin(bits).count(\\'1\\')\\n            nbits = bits | (1 << (r * C + c))\\n            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):\\n                nr = r + dr\\n                nc = c + dc\\n                if 0 <= nr < R and 0 <= nc < C:\\n                    if grid[nr][nc] == 0 and not ((bits >> (nr * C + nc)) & 1):\\n                        res += dp(nbits, nr, nc)\\n                    elif grid[nr][nc] == 2 and count1 == count0:\\n                        res += 1\\n            return res\\n        for r in range(R):\\n            for c in range(C):\\n                if grid[r][c] == 1:    \\n                    return dp(0, r, c)\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n        R, C = len(grid), len(grid[0])\\n        count0 = sum([row.count(0) for row in grid])\\n        @lru_cache(None)\\n        def dp(bits, r, c):\\n            res = 0\\n            count1 = bin(bits).count(\\'1\\')\\n            nbits = bits | (1 << (r * C + c))\\n            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):\\n                nr = r + dr\\n                nc = c + dc\\n                if 0 <= nr < R and 0 <= nc < C:\\n                    if grid[nr][nc] == 0 and not ((bits >> (nr * C + nc)) & 1):\\n                        res += dp(nbits, nr, nc)\\n                    elif grid[nr][nc] == 2 and count1 == count0:\\n                        res += 1\\n            return res\\n        for r in range(R):\\n            for c in range(C):\\n                if grid[r][c] == 1:    \\n                    return dp(0, r, c)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855687,
                "title": "simple-java-dfs-backtracking-solution-with-explanation-0-ms-100",
                "content": "**EXPLANATION**\\n\\n**Let me explain the problem statement first.**  *You need to find the count of all the paths from the source cell to target cell.  The only contraint here is that your path must traverse over all the 0s present in the grid.*\\n\\n**Brute force** idea is simple.  Whenever you find a *1, i.e. the starting cell*, start performing DFS from that cell.  Whene you reach a *2, i.e. the target cell*, check if there is any *0* remaining in the grid.  If there is a *0* remaining it means that all *0* have not been covered in the current path so return without incrementing the count.  If there is no remaining *0*, then increment the count and return.  Finally return the count.\\n\\n**Optimized solution** is even simpler.  Before starting the DFS traversal, count all the *0s* present in the grid and store it in a variable *totalZeros*.  Now, start the DFS from the starting cell, i.e. *1* and keep incrementing the current count of visited *0s* in the recursive function itself through the variable *currentZeros*.  In the base condition check the following:\\n\\n**if (current cell is the target cell) -> if *\"currentZeros\"* is equal to *\"totalZeros\"*, then return 1 else return 0.**\\n\\n*------This is the only modification required to optimize the normal DFS.------*\\n\\n**Note:**\\n\\n***We are initializing \"currentZeros\" with -1 because we are starting with the cell having value \"1\", i.e the starting cell. If we would have started \"currentZeros\" with 0, then the actual count when the recursion hits the target cell would have been (total number of zeros + 1) because it would have counted the cell having value \"1\" also.  Hence, for simplicity, we are initializing it with -1.***\\n\\nPlease upvote if you like the solution. Comment if you have any queries/doubts.\\n\\n\\n```\\nclass Solution {\\n    public int uniquePathsIII (int[][] grid) {\\n        if (grid == null || grid.length == 0)\\n            return 0;\\n        int totalZeros = 0, x = 0, y = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid [i][j] == 0)\\n                    totalZeros++;\\n                if (grid [i][j] == 1) {\\n                    x = i;\\n                    y = j;\\n                }\\n            }\\n        }\\n        return DFS (grid, totalZeros, -1, x, y);\\n    }\\n    \\n    public int DFS (int grid [][], int totalZeros, int currentZeros, int i, int j) {\\n        if (!isValid (grid, i, j))\\n            return 0;\\n        if (grid [i][j] == 2) {\\n            if (currentZeros == totalZeros)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        grid [i][j] = -1;\\n        int v1 = DFS (grid, totalZeros, currentZeros+1, i+1, j);\\n        int v2 = DFS (grid, totalZeros, currentZeros+1, i-1, j);\\n        int v3 = DFS (grid, totalZeros, currentZeros+1, i, j+1);\\n        int v4 = DFS (grid, totalZeros, currentZeros+1, i, j-1);\\n        grid [i][j] = 0;\\n        return (v1 + v2 + v3 + v4);\\n    }\\n    \\n    public boolean isValid (int grid [][], int i, int j) {\\n        if (i >= 0 && i < grid.length && j >= 0 && j < grid[0].length && grid [i][j] != -1)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int uniquePathsIII (int[][] grid) {\\n        if (grid == null || grid.length == 0)\\n            return 0;\\n        int totalZeros = 0, x = 0, y = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid [i][j] == 0)\\n                    totalZeros++;\\n                if (grid [i][j] == 1) {\\n                    x = i;\\n                    y = j;\\n                }\\n            }\\n        }\\n        return DFS (grid, totalZeros, -1, x, y);\\n    }\\n    \\n    public int DFS (int grid [][], int totalZeros, int currentZeros, int i, int j) {\\n        if (!isValid (grid, i, j))\\n            return 0;\\n        if (grid [i][j] == 2) {\\n            if (currentZeros == totalZeros)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        grid [i][j] = -1;\\n        int v1 = DFS (grid, totalZeros, currentZeros+1, i+1, j);\\n        int v2 = DFS (grid, totalZeros, currentZeros+1, i-1, j);\\n        int v3 = DFS (grid, totalZeros, currentZeros+1, i, j+1);\\n        int v4 = DFS (grid, totalZeros, currentZeros+1, i, j-1);\\n        grid [i][j] = 0;\\n        return (v1 + v2 + v3 + v4);\\n    }\\n    \\n    public boolean isValid (int grid [][], int i, int j) {\\n        if (i >= 0 && i < grid.length && j >= 0 && j < grid[0].length && grid [i][j] != -1)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825590,
                "title": "java-dfs-backtracking-with-explanation-easy-to-understand",
                "content": "* Iterate through the grid once, record the start coordinate and count the number of total \"non-obstacle\" cells.\\n*  Using a boolean visited array, we could simply mark the obstacles as \"visited\" so that in helper method, if we meet the obstacle, return directly.\\n\\nHelper Method:\\n* In helper method, the two base cases are: \\n\\t* first check if the index i,j is still within boundary or if the cell has been visited. If not, return directly. \\n\\t* Otherwise, check when reach the end `2` if `remain` equals 1, if so, we\\'ve found a new path. `count += 1` and return. \\n* Recursive case is:\\n\\t* mark current cell as visited, visit all four directions.\\n\\t* after recursion, put the cell back to unvisited.\\n\\n```\\nclass Solution {\\n    int count = 0;\\n    public int uniquePathsIII(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        int r = 0, c = 0; // start point\\n        int remain = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] >= 0) {\\n                    remain++;\\n                    if (grid[i][j] == 1){\\n                        r = i;\\n                        c = j;\\n                    } \\n                } else {\\n                    visited[i][j] = true;\\n                }\\n            }\\n        }\\n        helper(grid, r, c, remain, visited);\\n        return count;\\n    }\\n    \\n    private void helper(int[][]grid, int i, int j, int remain, boolean[][] visited) {\\n        if (i < 0 || j < 0 || i >= visited.length || j >= visited[0].length || visited[i][j] == true) {\\n            return;\\n        }\\n        if (grid[i][j] == 2 && remain == 1) {\\n            this.count+=1;\\n            return;\\n        }\\n        visited[i][j] = true;\\n        \\n        helper(grid, i+1, j, remain - 1, visited);\\n        helper(grid, i-1, j, remain - 1, visited);\\n        helper(grid, i, j+1, remain - 1, visited);\\n        helper(grid, i, j-1, remain - 1, visited);\\n        \\n        visited[i][j] = false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public int uniquePathsIII(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        int r = 0, c = 0; // start point\\n        int remain = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] >= 0) {\\n                    remain++;\\n                    if (grid[i][j] == 1){\\n                        r = i;\\n                        c = j;\\n                    } \\n                } else {\\n                    visited[i][j] = true;\\n                }\\n            }\\n        }\\n        helper(grid, r, c, remain, visited);\\n        return count;\\n    }\\n    \\n    private void helper(int[][]grid, int i, int j, int remain, boolean[][] visited) {\\n        if (i < 0 || j < 0 || i >= visited.length || j >= visited[0].length || visited[i][j] == true) {\\n            return;\\n        }\\n        if (grid[i][j] == 2 && remain == 1) {\\n            this.count+=1;\\n            return;\\n        }\\n        visited[i][j] = true;\\n        \\n        helper(grid, i+1, j, remain - 1, visited);\\n        helper(grid, i-1, j, remain - 1, visited);\\n        helper(grid, i, j+1, remain - 1, visited);\\n        helper(grid, i, j-1, remain - 1, visited);\\n        \\n        visited[i][j] = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824910,
                "title": "java-backtracking-without-global-variable-100",
                "content": "```\\nclass Solution {\\n   \\n    int solve(int[][]grid,int x, int y, int m, int n, int nonObstacles){\\n        if(x<0 || x>=m || y<0 || y>=n || grid[x][y]==-1 || grid[x][y]==1) return 0; //sanity check\\n        if(grid[x][y]==2){ //destination\\n            if(nonObstacles==0) return 1; // every non-obstacle square is visited (the only valid condition)\\n            return 0; //every non-obstacle square is not visited\\n        }\\n        if(nonObstacles==0) return 0; //without reaching the target all non-obstacle squares are visited  \\n        grid[x][y] = -1; //mark visited\\n        int way1 = solve(grid,x+1,y,m,n,nonObstacles-1);\\n        int way2 = solve(grid,x-1,y,m,n,nonObstacles-1);\\n        int way3 = solve(grid,x,y+1,m,n,nonObstacles-1);\\n        int way4 = solve(grid,x,y-1,m,n,nonObstacles-1);\\n        grid[x][y] = 0; //backtrack\\n        return way1+way2+way3+way4;\\n    }\\n    \\n    public int uniquePathsIII(int[][] grid){\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int nonObstacles = 0;\\n        \\n        for(int[] row : grid){ //count the number of obstacles that are needed to be visited before reaching the destination\\n            for(int i=0;i<row.length;i++) if(row[i]==0) nonObstacles++;\\n        }\\n      \\n        for(int x=0;x<m;x++){ //find the starting point \\n            for(int y=0;y<n;y++){\\n                if(grid[x][y]==1){\\n                    return solve(grid,x+1,y,m,n,nonObstacles)+\\n                    solve(grid,x-1,y,m,n,nonObstacles)+\\n                    solve(grid,x,y+1,m,n,nonObstacles)+\\n                    solve(grid,x,y-1,m,n,nonObstacles);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   \\n    int solve(int[][]grid,int x, int y, int m, int n, int nonObstacles){\\n        if(x<0 || x>=m || y<0 || y>=n || grid[x][y]==-1 || grid[x][y]==1) return 0; //sanity check\\n        if(grid[x][y]==2){ //destination\\n            if(nonObstacles==0) return 1; // every non-obstacle square is visited (the only valid condition)\\n            return 0; //every non-obstacle square is not visited\\n        }\\n        if(nonObstacles==0) return 0; //without reaching the target all non-obstacle squares are visited  \\n        grid[x][y] = -1; //mark visited\\n        int way1 = solve(grid,x+1,y,m,n,nonObstacles-1);\\n        int way2 = solve(grid,x-1,y,m,n,nonObstacles-1);\\n        int way3 = solve(grid,x,y+1,m,n,nonObstacles-1);\\n        int way4 = solve(grid,x,y-1,m,n,nonObstacles-1);\\n        grid[x][y] = 0; //backtrack\\n        return way1+way2+way3+way4;\\n    }\\n    \\n    public int uniquePathsIII(int[][] grid){\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int nonObstacles = 0;\\n        \\n        for(int[] row : grid){ //count the number of obstacles that are needed to be visited before reaching the destination\\n            for(int i=0;i<row.length;i++) if(row[i]==0) nonObstacles++;\\n        }\\n      \\n        for(int x=0;x<m;x++){ //find the starting point \\n            for(int y=0;y<n;y++){\\n                if(grid[x][y]==1){\\n                    return solve(grid,x+1,y,m,n,nonObstacles)+\\n                    solve(grid,x-1,y,m,n,nonObstacles)+\\n                    solve(grid,x,y+1,m,n,nonObstacles)+\\n                    solve(grid,x,y-1,m,n,nonObstacles);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1734811,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1734812,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1564874,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1566997,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1734859,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1734998,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1734932,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1734819,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1575921,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1568772,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1734811,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1734812,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1564874,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1566997,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1734859,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1734998,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1734932,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1734819,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1575921,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1568772,
                "content": [
                    {
                        "username": "theaksaa",
                        "content": "the best way to end 2022"
                    },
                    {
                        "username": "Msey",
                        "content": "[@ssy55ssy](/ssy55ssy) good start for new journey :D"
                    },
                    {
                        "username": "JustBored",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "ssy55ssy",
                        "content": "the first hard problem I finish by myself!"
                    },
                    {
                        "username": "72engineers",
                        "content": "Happy new year Everyone, Hope all of you have a safe, healthy, wonderful 2023! "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manasbaroi6699",
                        "content": "The best way to end 2022"
                    },
                    {
                        "username": "nadabao",
                        "content": "If it\\'s only brute force backtracking, see no point why it\\'s hard"
                    },
                    {
                        "username": "MeganusWesker",
                        "content": "exactly just take count and check wheter it\\' two with count==0 or not and that\\'s it do backtrack and done it should be consider as medium or easy\\n"
                    },
                    {
                        "username": "cortexauth",
                        "content": "I spent quite some time thinking that I can maybe find some pattern too but I just could not think of any either, tags are just confusing "
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "this was easiest hard ques\\\\n felt this ques was a new year gift from leetcode"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Indeed. I thought this question need to use pruning before checking the input range."
                    },
                    {
                        "username": "trpaslik",
                        "content": "[@nishant7372](/nishant7372) This is the secret way to keep discussions so alive ;-)\\nHappy New Year to all of you!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Most of hard problems on Leetcode are tagged medium and many medium problems are tagged hard.\nDon't know how leetcode decide problem level."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "good for you"
                    },
                    {
                        "username": "JerryPorter",
                        "content": "I think it\\'s the first hard I solved on my own. Best way to end 2022!\\nHave a good year and keep on keeping on, everyone!"
                    },
                    {
                        "username": "dkashi",
                        "content": "Happy New Year, fellow leetcoders! If you are here solving questions on New Year\\u2019s Eve, your commitment is commendable and I hope you achieve all your goals in 2023!! "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I brute forced through 22 like this problem resulting in a terrible year, I hope 23 will be better. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is a tricky problem - the key is the path has to cover ALL non-blocked squares. I initially thought it just wanted to list all the possible paths, and got 17 paths for test case 1 which was wrong"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Ha-ha, exactly what I had initially too :) \\n\"Consistency is a key\", and \"attentiveness is a must to choose a proper key from a keychain\" ;)\\nHappy coming New Year everyone!"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video.\\n\\nhttps://vimeo.com/641360931\\n\\nEmail: l.bayarkhuu@gmail.com\\nMy discord server for leetcode: https://discord.gg/RcGu3wbD\\n\\n"
                    },
                    {
                        "username": "sarveshkumararora",
                        "content": "I just want to ask why this question cannot have a dp solution(without bitmasking) i am struggling to find where DP works(it works for grid question but why not here) and where it doesnt.  Also it would be great if someone could generalize this for all the question. I need to know how can i think why DP in this question will get me wrong answer and then generalize this reasoning to all such problems.\\n\\nThanks in advance . Any help/resources would be appreciated.\\n\\n\\nattaching wrong ans link : - https://leetcode.com/submissions/detail/703636410/"
                    },
                    {
                        "username": "Drucoder",
                        "content": "As per my intuition, the dp will only work when you are able to traverse from smaller problems to larger problems in a particular way. In grids this translates to being able to traverse the grid row-wise, column-wise or in some other fixed way such that when you reach a particular cell in the grid you will already have the final solutions for all the cells that you visit before it, thus ensuring that you can calculate the final result for current cell using the earlier cells. You can think of the different sub-problems forming a DAG. For solving a particular sub-problem, you need all final answers for all sub-problems it is dependent on. You can ensure this by doing a topological sort and traversing the subproblem graph in that manner.\\nNow in the current problem since we can head in any of the 4 directions such kind of traversal cannot be formed since dependencies among the subproblems form cycles. So, you cannot meet all dependencies of a subproblem and get a final solution to it. "
                    },
                    {
                        "username": "Triquetra",
                        "content": "This problem is an instance of Hamiltonian Path, which is NP-hard. The low limit on problem parameters can be a hint. It obviously still requires some kind of pruning, since simply brute-forcing $$18!$$ possible paths is not possible."
                    },
                    {
                        "username": "nishant-nimbare",
                        "content": "what i have observed in grid questions is that \\nDP only works if the movement if restricted to 1 or 2 directions. e.g from cell i, j we can move (i+1, j )  or (i, j+ 1).\\nThat works with DP because we iterate from top left to bottom right. and once a cell is visited we are sure that the ans in that cell is fixed for the rest of problem because we cant go back to that particular cell again.\\n\\nIn problems where movement is allowed in all four directions, you cannot guarantee whether the you\\'ll visited the cell again or not, (try imagining going down around the cell and moving back up to the cell vs directly moving into the cell ). Here the value we compute can\\'t be said to be final hence no point in storing it for future use.\\n\\nHope it helps. "
                    }
                ]
            },
            {
                "id": 1735428,
                "content": [
                    {
                        "username": "alecn2002",
                        "content": "These 2 constrains contradict to each other:\\n\\n- $$1 <= m * n <= 20$$\\n- There is exactly one starting cell and one ending cell.\\n\\nThe same cell can not be starting and ending at the same time, so $$m*n$$ could not be equal to 1, it should be at least 2."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Well, $$1 \\leqslant 2$$, so…"
                    },
                    {
                        "username": "sudip_0492",
                        "content": "First hard problem that got submitted with 100% that too on 31.12.22 .. so happy.  Happy New Year 2023 to everyone.."
                    },
                    {
                        "username": "ravishk17",
                        "content": "Hey folks, I\\'d just like to thanks leetcode for providing a set of variety and challenging questions. It really helped me in getting confidence in coding. This year I\\'ve solved the daily problem for more than 200 days continuously.\\nCheers to LeetCode!!!\\nHappy new year!!"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Happy new year everyone. For whatever reason you are grinding out leecode, be it for the upcoming placements season or improving your dsa skills or the fact that you simply enjoy it, I hope you accomplish everything you had hoped for next year."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "A hard question with 80%+ acceptance rate and brute force solution. xD"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "I\\'m getting this error for [[0],[0],[2],[1]] testcase\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000002c8 at pc 0x000000347a28 bp 0x7ffea72c7e40 sp 0x7ffea72c7e38\\nREAD of size 8 at 0x6040000002c8 thread T0\\n    #3 0x7f0b0c76e0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x6040000002c8 is a wild pointer.\\nShadow bytes around the buggy address:\\n  0x0c087fff8000: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 06\\n  0x0c087fff8010: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8020: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8030: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8040: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 fa\\n=>0x0c087fff8050: fa fa fa fa fa fa fa fa fa[fa]fa fa fa fa fa fa\\n  0x0c087fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n\\n\\nMy code :\\nclass Solution {\\npublic:\\n    void bf(vector<vector<int>>& grid,int &ans,vector<vector<bool>>& visited,int i,     int j,int tar_c,int visit_c,int m,int n)\\n    {\\n        if( i>=m || j>=n || i<0 || j<0 ||grid[i][j]==-1 || (visited[i][j]==true ))\\n        return ;\\n        if(grid[i][j]==2 and tar_c>visit_c)\\n        return;\\n        visited[i][j]=true;\\n         //cout<<grid[i][j]<<\" \"<<i<<\",\"<<j<<tar_c<<\" \"<<visit_c<<\" \"<<endl;\\n        if(grid[i][j]==2 and tar_c==visit_c-1)\\n        {\\n            \\n            ans++;\\n         \\n        }\\n        bf(grid,ans,visited,i+1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j+1,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i-1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j-1,tar_c,visit_c+1,m,n);\\n\\n\\n       visited[i][j]=false;\\n        \\n        return ;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<bool>> visited;\\n        for(int i=0;i<n;i++)\\n        {vector<bool> temp;\\n            for(int j=0;j<n;j++)\\n            temp.push_back(false);\\n\\n        visited.push_back(temp);\\n        }\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {if(grid[i][j]==0)\\n                c++;\\n            if(grid[i][j]==1)\\n            {a=i;\\n            b=j;}}\\n        }\\n        int ans=0;\\n    \\n        \\n        bf(grid,ans,visited,a,b,c,0,m,n);\\n\\n        return ans;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@ajaykumar540official](/ajaykumar540official) see https://www.markdownguide.org/extended-syntax/#fenced-code-blocks"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) How ``` can be used to format code ?\\n"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the dimensions of `visited`. It should be have the same dimensions as `grid`, that is `m x n`.  \\nCan you spot the one character that needs to be changed?\\n\\nBTW: To format your code properly put a line with three backticks (<code>```</code>) before and after the code, or indent each line with four *additional* spaces."
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "Happy New Year! \\n           2o23\\nStay Safe and Motivated\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really want to know about more hard problems which are like this : ) \\n`Happy New Year Guys !! \\uD83E\\uDD73\\uD83C\\uDF89` "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Today I got my first badge and tomorrow would be the contest in the morning on  first day of New Year!\\nI hope everyone did well and enjoyed this year and will do more better in the upcoming year with lots of energy and courage.."
                    }
                ]
            },
            {
                "id": 1735382,
                "content": [
                    {
                        "username": "alecn2002",
                        "content": "These 2 constrains contradict to each other:\\n\\n- $$1 <= m * n <= 20$$\\n- There is exactly one starting cell and one ending cell.\\n\\nThe same cell can not be starting and ending at the same time, so $$m*n$$ could not be equal to 1, it should be at least 2."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Well, $$1 \\leqslant 2$$, so…"
                    },
                    {
                        "username": "sudip_0492",
                        "content": "First hard problem that got submitted with 100% that too on 31.12.22 .. so happy.  Happy New Year 2023 to everyone.."
                    },
                    {
                        "username": "ravishk17",
                        "content": "Hey folks, I\\'d just like to thanks leetcode for providing a set of variety and challenging questions. It really helped me in getting confidence in coding. This year I\\'ve solved the daily problem for more than 200 days continuously.\\nCheers to LeetCode!!!\\nHappy new year!!"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Happy new year everyone. For whatever reason you are grinding out leecode, be it for the upcoming placements season or improving your dsa skills or the fact that you simply enjoy it, I hope you accomplish everything you had hoped for next year."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "A hard question with 80%+ acceptance rate and brute force solution. xD"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "I\\'m getting this error for [[0],[0],[2],[1]] testcase\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000002c8 at pc 0x000000347a28 bp 0x7ffea72c7e40 sp 0x7ffea72c7e38\\nREAD of size 8 at 0x6040000002c8 thread T0\\n    #3 0x7f0b0c76e0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x6040000002c8 is a wild pointer.\\nShadow bytes around the buggy address:\\n  0x0c087fff8000: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 06\\n  0x0c087fff8010: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8020: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8030: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8040: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 fa\\n=>0x0c087fff8050: fa fa fa fa fa fa fa fa fa[fa]fa fa fa fa fa fa\\n  0x0c087fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n\\n\\nMy code :\\nclass Solution {\\npublic:\\n    void bf(vector<vector<int>>& grid,int &ans,vector<vector<bool>>& visited,int i,     int j,int tar_c,int visit_c,int m,int n)\\n    {\\n        if( i>=m || j>=n || i<0 || j<0 ||grid[i][j]==-1 || (visited[i][j]==true ))\\n        return ;\\n        if(grid[i][j]==2 and tar_c>visit_c)\\n        return;\\n        visited[i][j]=true;\\n         //cout<<grid[i][j]<<\" \"<<i<<\",\"<<j<<tar_c<<\" \"<<visit_c<<\" \"<<endl;\\n        if(grid[i][j]==2 and tar_c==visit_c-1)\\n        {\\n            \\n            ans++;\\n         \\n        }\\n        bf(grid,ans,visited,i+1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j+1,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i-1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j-1,tar_c,visit_c+1,m,n);\\n\\n\\n       visited[i][j]=false;\\n        \\n        return ;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<bool>> visited;\\n        for(int i=0;i<n;i++)\\n        {vector<bool> temp;\\n            for(int j=0;j<n;j++)\\n            temp.push_back(false);\\n\\n        visited.push_back(temp);\\n        }\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {if(grid[i][j]==0)\\n                c++;\\n            if(grid[i][j]==1)\\n            {a=i;\\n            b=j;}}\\n        }\\n        int ans=0;\\n    \\n        \\n        bf(grid,ans,visited,a,b,c,0,m,n);\\n\\n        return ans;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@ajaykumar540official](/ajaykumar540official) see https://www.markdownguide.org/extended-syntax/#fenced-code-blocks"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) How ``` can be used to format code ?\\n"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the dimensions of `visited`. It should be have the same dimensions as `grid`, that is `m x n`.  \\nCan you spot the one character that needs to be changed?\\n\\nBTW: To format your code properly put a line with three backticks (<code>```</code>) before and after the code, or indent each line with four *additional* spaces."
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "Happy New Year! \\n           2o23\\nStay Safe and Motivated\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really want to know about more hard problems which are like this : ) \\n`Happy New Year Guys !! \\uD83E\\uDD73\\uD83C\\uDF89` "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Today I got my first badge and tomorrow would be the contest in the morning on  first day of New Year!\\nI hope everyone did well and enjoyed this year and will do more better in the upcoming year with lots of energy and courage.."
                    }
                ]
            },
            {
                "id": 1735317,
                "content": [
                    {
                        "username": "alecn2002",
                        "content": "These 2 constrains contradict to each other:\\n\\n- $$1 <= m * n <= 20$$\\n- There is exactly one starting cell and one ending cell.\\n\\nThe same cell can not be starting and ending at the same time, so $$m*n$$ could not be equal to 1, it should be at least 2."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Well, $$1 \\leqslant 2$$, so…"
                    },
                    {
                        "username": "sudip_0492",
                        "content": "First hard problem that got submitted with 100% that too on 31.12.22 .. so happy.  Happy New Year 2023 to everyone.."
                    },
                    {
                        "username": "ravishk17",
                        "content": "Hey folks, I\\'d just like to thanks leetcode for providing a set of variety and challenging questions. It really helped me in getting confidence in coding. This year I\\'ve solved the daily problem for more than 200 days continuously.\\nCheers to LeetCode!!!\\nHappy new year!!"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Happy new year everyone. For whatever reason you are grinding out leecode, be it for the upcoming placements season or improving your dsa skills or the fact that you simply enjoy it, I hope you accomplish everything you had hoped for next year."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "A hard question with 80%+ acceptance rate and brute force solution. xD"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "I\\'m getting this error for [[0],[0],[2],[1]] testcase\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000002c8 at pc 0x000000347a28 bp 0x7ffea72c7e40 sp 0x7ffea72c7e38\\nREAD of size 8 at 0x6040000002c8 thread T0\\n    #3 0x7f0b0c76e0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x6040000002c8 is a wild pointer.\\nShadow bytes around the buggy address:\\n  0x0c087fff8000: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 06\\n  0x0c087fff8010: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8020: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8030: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8040: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 fa\\n=>0x0c087fff8050: fa fa fa fa fa fa fa fa fa[fa]fa fa fa fa fa fa\\n  0x0c087fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n\\n\\nMy code :\\nclass Solution {\\npublic:\\n    void bf(vector<vector<int>>& grid,int &ans,vector<vector<bool>>& visited,int i,     int j,int tar_c,int visit_c,int m,int n)\\n    {\\n        if( i>=m || j>=n || i<0 || j<0 ||grid[i][j]==-1 || (visited[i][j]==true ))\\n        return ;\\n        if(grid[i][j]==2 and tar_c>visit_c)\\n        return;\\n        visited[i][j]=true;\\n         //cout<<grid[i][j]<<\" \"<<i<<\",\"<<j<<tar_c<<\" \"<<visit_c<<\" \"<<endl;\\n        if(grid[i][j]==2 and tar_c==visit_c-1)\\n        {\\n            \\n            ans++;\\n         \\n        }\\n        bf(grid,ans,visited,i+1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j+1,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i-1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j-1,tar_c,visit_c+1,m,n);\\n\\n\\n       visited[i][j]=false;\\n        \\n        return ;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<bool>> visited;\\n        for(int i=0;i<n;i++)\\n        {vector<bool> temp;\\n            for(int j=0;j<n;j++)\\n            temp.push_back(false);\\n\\n        visited.push_back(temp);\\n        }\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {if(grid[i][j]==0)\\n                c++;\\n            if(grid[i][j]==1)\\n            {a=i;\\n            b=j;}}\\n        }\\n        int ans=0;\\n    \\n        \\n        bf(grid,ans,visited,a,b,c,0,m,n);\\n\\n        return ans;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@ajaykumar540official](/ajaykumar540official) see https://www.markdownguide.org/extended-syntax/#fenced-code-blocks"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) How ``` can be used to format code ?\\n"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the dimensions of `visited`. It should be have the same dimensions as `grid`, that is `m x n`.  \\nCan you spot the one character that needs to be changed?\\n\\nBTW: To format your code properly put a line with three backticks (<code>```</code>) before and after the code, or indent each line with four *additional* spaces."
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "Happy New Year! \\n           2o23\\nStay Safe and Motivated\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really want to know about more hard problems which are like this : ) \\n`Happy New Year Guys !! \\uD83E\\uDD73\\uD83C\\uDF89` "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Today I got my first badge and tomorrow would be the contest in the morning on  first day of New Year!\\nI hope everyone did well and enjoyed this year and will do more better in the upcoming year with lots of energy and courage.."
                    }
                ]
            },
            {
                "id": 1735188,
                "content": [
                    {
                        "username": "alecn2002",
                        "content": "These 2 constrains contradict to each other:\\n\\n- $$1 <= m * n <= 20$$\\n- There is exactly one starting cell and one ending cell.\\n\\nThe same cell can not be starting and ending at the same time, so $$m*n$$ could not be equal to 1, it should be at least 2."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Well, $$1 \\leqslant 2$$, so…"
                    },
                    {
                        "username": "sudip_0492",
                        "content": "First hard problem that got submitted with 100% that too on 31.12.22 .. so happy.  Happy New Year 2023 to everyone.."
                    },
                    {
                        "username": "ravishk17",
                        "content": "Hey folks, I\\'d just like to thanks leetcode for providing a set of variety and challenging questions. It really helped me in getting confidence in coding. This year I\\'ve solved the daily problem for more than 200 days continuously.\\nCheers to LeetCode!!!\\nHappy new year!!"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Happy new year everyone. For whatever reason you are grinding out leecode, be it for the upcoming placements season or improving your dsa skills or the fact that you simply enjoy it, I hope you accomplish everything you had hoped for next year."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "A hard question with 80%+ acceptance rate and brute force solution. xD"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "I\\'m getting this error for [[0],[0],[2],[1]] testcase\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000002c8 at pc 0x000000347a28 bp 0x7ffea72c7e40 sp 0x7ffea72c7e38\\nREAD of size 8 at 0x6040000002c8 thread T0\\n    #3 0x7f0b0c76e0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x6040000002c8 is a wild pointer.\\nShadow bytes around the buggy address:\\n  0x0c087fff8000: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 06\\n  0x0c087fff8010: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8020: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8030: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8040: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 fa\\n=>0x0c087fff8050: fa fa fa fa fa fa fa fa fa[fa]fa fa fa fa fa fa\\n  0x0c087fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n\\n\\nMy code :\\nclass Solution {\\npublic:\\n    void bf(vector<vector<int>>& grid,int &ans,vector<vector<bool>>& visited,int i,     int j,int tar_c,int visit_c,int m,int n)\\n    {\\n        if( i>=m || j>=n || i<0 || j<0 ||grid[i][j]==-1 || (visited[i][j]==true ))\\n        return ;\\n        if(grid[i][j]==2 and tar_c>visit_c)\\n        return;\\n        visited[i][j]=true;\\n         //cout<<grid[i][j]<<\" \"<<i<<\",\"<<j<<tar_c<<\" \"<<visit_c<<\" \"<<endl;\\n        if(grid[i][j]==2 and tar_c==visit_c-1)\\n        {\\n            \\n            ans++;\\n         \\n        }\\n        bf(grid,ans,visited,i+1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j+1,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i-1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j-1,tar_c,visit_c+1,m,n);\\n\\n\\n       visited[i][j]=false;\\n        \\n        return ;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<bool>> visited;\\n        for(int i=0;i<n;i++)\\n        {vector<bool> temp;\\n            for(int j=0;j<n;j++)\\n            temp.push_back(false);\\n\\n        visited.push_back(temp);\\n        }\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {if(grid[i][j]==0)\\n                c++;\\n            if(grid[i][j]==1)\\n            {a=i;\\n            b=j;}}\\n        }\\n        int ans=0;\\n    \\n        \\n        bf(grid,ans,visited,a,b,c,0,m,n);\\n\\n        return ans;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@ajaykumar540official](/ajaykumar540official) see https://www.markdownguide.org/extended-syntax/#fenced-code-blocks"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) How ``` can be used to format code ?\\n"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the dimensions of `visited`. It should be have the same dimensions as `grid`, that is `m x n`.  \\nCan you spot the one character that needs to be changed?\\n\\nBTW: To format your code properly put a line with three backticks (<code>```</code>) before and after the code, or indent each line with four *additional* spaces."
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "Happy New Year! \\n           2o23\\nStay Safe and Motivated\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really want to know about more hard problems which are like this : ) \\n`Happy New Year Guys !! \\uD83E\\uDD73\\uD83C\\uDF89` "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Today I got my first badge and tomorrow would be the contest in the morning on  first day of New Year!\\nI hope everyone did well and enjoyed this year and will do more better in the upcoming year with lots of energy and courage.."
                    }
                ]
            },
            {
                "id": 1735080,
                "content": [
                    {
                        "username": "alecn2002",
                        "content": "These 2 constrains contradict to each other:\\n\\n- $$1 <= m * n <= 20$$\\n- There is exactly one starting cell and one ending cell.\\n\\nThe same cell can not be starting and ending at the same time, so $$m*n$$ could not be equal to 1, it should be at least 2."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Well, $$1 \\leqslant 2$$, so…"
                    },
                    {
                        "username": "sudip_0492",
                        "content": "First hard problem that got submitted with 100% that too on 31.12.22 .. so happy.  Happy New Year 2023 to everyone.."
                    },
                    {
                        "username": "ravishk17",
                        "content": "Hey folks, I\\'d just like to thanks leetcode for providing a set of variety and challenging questions. It really helped me in getting confidence in coding. This year I\\'ve solved the daily problem for more than 200 days continuously.\\nCheers to LeetCode!!!\\nHappy new year!!"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Happy new year everyone. For whatever reason you are grinding out leecode, be it for the upcoming placements season or improving your dsa skills or the fact that you simply enjoy it, I hope you accomplish everything you had hoped for next year."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "A hard question with 80%+ acceptance rate and brute force solution. xD"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "I\\'m getting this error for [[0],[0],[2],[1]] testcase\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000002c8 at pc 0x000000347a28 bp 0x7ffea72c7e40 sp 0x7ffea72c7e38\\nREAD of size 8 at 0x6040000002c8 thread T0\\n    #3 0x7f0b0c76e0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x6040000002c8 is a wild pointer.\\nShadow bytes around the buggy address:\\n  0x0c087fff8000: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 06\\n  0x0c087fff8010: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8020: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8030: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8040: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 fa\\n=>0x0c087fff8050: fa fa fa fa fa fa fa fa fa[fa]fa fa fa fa fa fa\\n  0x0c087fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n\\n\\nMy code :\\nclass Solution {\\npublic:\\n    void bf(vector<vector<int>>& grid,int &ans,vector<vector<bool>>& visited,int i,     int j,int tar_c,int visit_c,int m,int n)\\n    {\\n        if( i>=m || j>=n || i<0 || j<0 ||grid[i][j]==-1 || (visited[i][j]==true ))\\n        return ;\\n        if(grid[i][j]==2 and tar_c>visit_c)\\n        return;\\n        visited[i][j]=true;\\n         //cout<<grid[i][j]<<\" \"<<i<<\",\"<<j<<tar_c<<\" \"<<visit_c<<\" \"<<endl;\\n        if(grid[i][j]==2 and tar_c==visit_c-1)\\n        {\\n            \\n            ans++;\\n         \\n        }\\n        bf(grid,ans,visited,i+1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j+1,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i-1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j-1,tar_c,visit_c+1,m,n);\\n\\n\\n       visited[i][j]=false;\\n        \\n        return ;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<bool>> visited;\\n        for(int i=0;i<n;i++)\\n        {vector<bool> temp;\\n            for(int j=0;j<n;j++)\\n            temp.push_back(false);\\n\\n        visited.push_back(temp);\\n        }\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {if(grid[i][j]==0)\\n                c++;\\n            if(grid[i][j]==1)\\n            {a=i;\\n            b=j;}}\\n        }\\n        int ans=0;\\n    \\n        \\n        bf(grid,ans,visited,a,b,c,0,m,n);\\n\\n        return ans;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@ajaykumar540official](/ajaykumar540official) see https://www.markdownguide.org/extended-syntax/#fenced-code-blocks"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) How ``` can be used to format code ?\\n"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the dimensions of `visited`. It should be have the same dimensions as `grid`, that is `m x n`.  \\nCan you spot the one character that needs to be changed?\\n\\nBTW: To format your code properly put a line with three backticks (<code>```</code>) before and after the code, or indent each line with four *additional* spaces."
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "Happy New Year! \\n           2o23\\nStay Safe and Motivated\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really want to know about more hard problems which are like this : ) \\n`Happy New Year Guys !! \\uD83E\\uDD73\\uD83C\\uDF89` "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Today I got my first badge and tomorrow would be the contest in the morning on  first day of New Year!\\nI hope everyone did well and enjoyed this year and will do more better in the upcoming year with lots of energy and courage.."
                    }
                ]
            },
            {
                "id": 1735845,
                "content": [
                    {
                        "username": "alecn2002",
                        "content": "These 2 constrains contradict to each other:\\n\\n- $$1 <= m * n <= 20$$\\n- There is exactly one starting cell and one ending cell.\\n\\nThe same cell can not be starting and ending at the same time, so $$m*n$$ could not be equal to 1, it should be at least 2."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Well, $$1 \\leqslant 2$$, so…"
                    },
                    {
                        "username": "sudip_0492",
                        "content": "First hard problem that got submitted with 100% that too on 31.12.22 .. so happy.  Happy New Year 2023 to everyone.."
                    },
                    {
                        "username": "ravishk17",
                        "content": "Hey folks, I\\'d just like to thanks leetcode for providing a set of variety and challenging questions. It really helped me in getting confidence in coding. This year I\\'ve solved the daily problem for more than 200 days continuously.\\nCheers to LeetCode!!!\\nHappy new year!!"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Happy new year everyone. For whatever reason you are grinding out leecode, be it for the upcoming placements season or improving your dsa skills or the fact that you simply enjoy it, I hope you accomplish everything you had hoped for next year."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "A hard question with 80%+ acceptance rate and brute force solution. xD"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "I\\'m getting this error for [[0],[0],[2],[1]] testcase\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000002c8 at pc 0x000000347a28 bp 0x7ffea72c7e40 sp 0x7ffea72c7e38\\nREAD of size 8 at 0x6040000002c8 thread T0\\n    #3 0x7f0b0c76e0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x6040000002c8 is a wild pointer.\\nShadow bytes around the buggy address:\\n  0x0c087fff8000: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 06\\n  0x0c087fff8010: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8020: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8030: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8040: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 fa\\n=>0x0c087fff8050: fa fa fa fa fa fa fa fa fa[fa]fa fa fa fa fa fa\\n  0x0c087fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n\\n\\nMy code :\\nclass Solution {\\npublic:\\n    void bf(vector<vector<int>>& grid,int &ans,vector<vector<bool>>& visited,int i,     int j,int tar_c,int visit_c,int m,int n)\\n    {\\n        if( i>=m || j>=n || i<0 || j<0 ||grid[i][j]==-1 || (visited[i][j]==true ))\\n        return ;\\n        if(grid[i][j]==2 and tar_c>visit_c)\\n        return;\\n        visited[i][j]=true;\\n         //cout<<grid[i][j]<<\" \"<<i<<\",\"<<j<<tar_c<<\" \"<<visit_c<<\" \"<<endl;\\n        if(grid[i][j]==2 and tar_c==visit_c-1)\\n        {\\n            \\n            ans++;\\n         \\n        }\\n        bf(grid,ans,visited,i+1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j+1,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i-1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j-1,tar_c,visit_c+1,m,n);\\n\\n\\n       visited[i][j]=false;\\n        \\n        return ;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<bool>> visited;\\n        for(int i=0;i<n;i++)\\n        {vector<bool> temp;\\n            for(int j=0;j<n;j++)\\n            temp.push_back(false);\\n\\n        visited.push_back(temp);\\n        }\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {if(grid[i][j]==0)\\n                c++;\\n            if(grid[i][j]==1)\\n            {a=i;\\n            b=j;}}\\n        }\\n        int ans=0;\\n    \\n        \\n        bf(grid,ans,visited,a,b,c,0,m,n);\\n\\n        return ans;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@ajaykumar540official](/ajaykumar540official) see https://www.markdownguide.org/extended-syntax/#fenced-code-blocks"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) How ``` can be used to format code ?\\n"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the dimensions of `visited`. It should be have the same dimensions as `grid`, that is `m x n`.  \\nCan you spot the one character that needs to be changed?\\n\\nBTW: To format your code properly put a line with three backticks (<code>```</code>) before and after the code, or indent each line with four *additional* spaces."
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "Happy New Year! \\n           2o23\\nStay Safe and Motivated\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really want to know about more hard problems which are like this : ) \\n`Happy New Year Guys !! \\uD83E\\uDD73\\uD83C\\uDF89` "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Today I got my first badge and tomorrow would be the contest in the morning on  first day of New Year!\\nI hope everyone did well and enjoyed this year and will do more better in the upcoming year with lots of energy and courage.."
                    }
                ]
            },
            {
                "id": 1735372,
                "content": [
                    {
                        "username": "alecn2002",
                        "content": "These 2 constrains contradict to each other:\\n\\n- $$1 <= m * n <= 20$$\\n- There is exactly one starting cell and one ending cell.\\n\\nThe same cell can not be starting and ending at the same time, so $$m*n$$ could not be equal to 1, it should be at least 2."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Well, $$1 \\leqslant 2$$, so…"
                    },
                    {
                        "username": "sudip_0492",
                        "content": "First hard problem that got submitted with 100% that too on 31.12.22 .. so happy.  Happy New Year 2023 to everyone.."
                    },
                    {
                        "username": "ravishk17",
                        "content": "Hey folks, I\\'d just like to thanks leetcode for providing a set of variety and challenging questions. It really helped me in getting confidence in coding. This year I\\'ve solved the daily problem for more than 200 days continuously.\\nCheers to LeetCode!!!\\nHappy new year!!"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Happy new year everyone. For whatever reason you are grinding out leecode, be it for the upcoming placements season or improving your dsa skills or the fact that you simply enjoy it, I hope you accomplish everything you had hoped for next year."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "A hard question with 80%+ acceptance rate and brute force solution. xD"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "I\\'m getting this error for [[0],[0],[2],[1]] testcase\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000002c8 at pc 0x000000347a28 bp 0x7ffea72c7e40 sp 0x7ffea72c7e38\\nREAD of size 8 at 0x6040000002c8 thread T0\\n    #3 0x7f0b0c76e0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x6040000002c8 is a wild pointer.\\nShadow bytes around the buggy address:\\n  0x0c087fff8000: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 06\\n  0x0c087fff8010: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8020: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8030: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8040: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 fa\\n=>0x0c087fff8050: fa fa fa fa fa fa fa fa fa[fa]fa fa fa fa fa fa\\n  0x0c087fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n\\n\\nMy code :\\nclass Solution {\\npublic:\\n    void bf(vector<vector<int>>& grid,int &ans,vector<vector<bool>>& visited,int i,     int j,int tar_c,int visit_c,int m,int n)\\n    {\\n        if( i>=m || j>=n || i<0 || j<0 ||grid[i][j]==-1 || (visited[i][j]==true ))\\n        return ;\\n        if(grid[i][j]==2 and tar_c>visit_c)\\n        return;\\n        visited[i][j]=true;\\n         //cout<<grid[i][j]<<\" \"<<i<<\",\"<<j<<tar_c<<\" \"<<visit_c<<\" \"<<endl;\\n        if(grid[i][j]==2 and tar_c==visit_c-1)\\n        {\\n            \\n            ans++;\\n         \\n        }\\n        bf(grid,ans,visited,i+1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j+1,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i-1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j-1,tar_c,visit_c+1,m,n);\\n\\n\\n       visited[i][j]=false;\\n        \\n        return ;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<bool>> visited;\\n        for(int i=0;i<n;i++)\\n        {vector<bool> temp;\\n            for(int j=0;j<n;j++)\\n            temp.push_back(false);\\n\\n        visited.push_back(temp);\\n        }\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {if(grid[i][j]==0)\\n                c++;\\n            if(grid[i][j]==1)\\n            {a=i;\\n            b=j;}}\\n        }\\n        int ans=0;\\n    \\n        \\n        bf(grid,ans,visited,a,b,c,0,m,n);\\n\\n        return ans;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@ajaykumar540official](/ajaykumar540official) see https://www.markdownguide.org/extended-syntax/#fenced-code-blocks"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) How ``` can be used to format code ?\\n"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the dimensions of `visited`. It should be have the same dimensions as `grid`, that is `m x n`.  \\nCan you spot the one character that needs to be changed?\\n\\nBTW: To format your code properly put a line with three backticks (<code>```</code>) before and after the code, or indent each line with four *additional* spaces."
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "Happy New Year! \\n           2o23\\nStay Safe and Motivated\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really want to know about more hard problems which are like this : ) \\n`Happy New Year Guys !! \\uD83E\\uDD73\\uD83C\\uDF89` "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Today I got my first badge and tomorrow would be the contest in the morning on  first day of New Year!\\nI hope everyone did well and enjoyed this year and will do more better in the upcoming year with lots of energy and courage.."
                    }
                ]
            },
            {
                "id": 1734990,
                "content": [
                    {
                        "username": "alecn2002",
                        "content": "These 2 constrains contradict to each other:\\n\\n- $$1 <= m * n <= 20$$\\n- There is exactly one starting cell and one ending cell.\\n\\nThe same cell can not be starting and ending at the same time, so $$m*n$$ could not be equal to 1, it should be at least 2."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Well, $$1 \\leqslant 2$$, so…"
                    },
                    {
                        "username": "sudip_0492",
                        "content": "First hard problem that got submitted with 100% that too on 31.12.22 .. so happy.  Happy New Year 2023 to everyone.."
                    },
                    {
                        "username": "ravishk17",
                        "content": "Hey folks, I\\'d just like to thanks leetcode for providing a set of variety and challenging questions. It really helped me in getting confidence in coding. This year I\\'ve solved the daily problem for more than 200 days continuously.\\nCheers to LeetCode!!!\\nHappy new year!!"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Happy new year everyone. For whatever reason you are grinding out leecode, be it for the upcoming placements season or improving your dsa skills or the fact that you simply enjoy it, I hope you accomplish everything you had hoped for next year."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "A hard question with 80%+ acceptance rate and brute force solution. xD"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "I\\'m getting this error for [[0],[0],[2],[1]] testcase\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000002c8 at pc 0x000000347a28 bp 0x7ffea72c7e40 sp 0x7ffea72c7e38\\nREAD of size 8 at 0x6040000002c8 thread T0\\n    #3 0x7f0b0c76e0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x6040000002c8 is a wild pointer.\\nShadow bytes around the buggy address:\\n  0x0c087fff8000: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 06\\n  0x0c087fff8010: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8020: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8030: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8040: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 fa\\n=>0x0c087fff8050: fa fa fa fa fa fa fa fa fa[fa]fa fa fa fa fa fa\\n  0x0c087fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n\\n\\nMy code :\\nclass Solution {\\npublic:\\n    void bf(vector<vector<int>>& grid,int &ans,vector<vector<bool>>& visited,int i,     int j,int tar_c,int visit_c,int m,int n)\\n    {\\n        if( i>=m || j>=n || i<0 || j<0 ||grid[i][j]==-1 || (visited[i][j]==true ))\\n        return ;\\n        if(grid[i][j]==2 and tar_c>visit_c)\\n        return;\\n        visited[i][j]=true;\\n         //cout<<grid[i][j]<<\" \"<<i<<\",\"<<j<<tar_c<<\" \"<<visit_c<<\" \"<<endl;\\n        if(grid[i][j]==2 and tar_c==visit_c-1)\\n        {\\n            \\n            ans++;\\n         \\n        }\\n        bf(grid,ans,visited,i+1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j+1,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i-1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j-1,tar_c,visit_c+1,m,n);\\n\\n\\n       visited[i][j]=false;\\n        \\n        return ;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<bool>> visited;\\n        for(int i=0;i<n;i++)\\n        {vector<bool> temp;\\n            for(int j=0;j<n;j++)\\n            temp.push_back(false);\\n\\n        visited.push_back(temp);\\n        }\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {if(grid[i][j]==0)\\n                c++;\\n            if(grid[i][j]==1)\\n            {a=i;\\n            b=j;}}\\n        }\\n        int ans=0;\\n    \\n        \\n        bf(grid,ans,visited,a,b,c,0,m,n);\\n\\n        return ans;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@ajaykumar540official](/ajaykumar540official) see https://www.markdownguide.org/extended-syntax/#fenced-code-blocks"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) How ``` can be used to format code ?\\n"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the dimensions of `visited`. It should be have the same dimensions as `grid`, that is `m x n`.  \\nCan you spot the one character that needs to be changed?\\n\\nBTW: To format your code properly put a line with three backticks (<code>```</code>) before and after the code, or indent each line with four *additional* spaces."
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "Happy New Year! \\n           2o23\\nStay Safe and Motivated\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really want to know about more hard problems which are like this : ) \\n`Happy New Year Guys !! \\uD83E\\uDD73\\uD83C\\uDF89` "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Today I got my first badge and tomorrow would be the contest in the morning on  first day of New Year!\\nI hope everyone did well and enjoyed this year and will do more better in the upcoming year with lots of energy and courage.."
                    }
                ]
            },
            {
                "id": 1734985,
                "content": [
                    {
                        "username": "alecn2002",
                        "content": "These 2 constrains contradict to each other:\\n\\n- $$1 <= m * n <= 20$$\\n- There is exactly one starting cell and one ending cell.\\n\\nThe same cell can not be starting and ending at the same time, so $$m*n$$ could not be equal to 1, it should be at least 2."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Well, $$1 \\leqslant 2$$, so…"
                    },
                    {
                        "username": "sudip_0492",
                        "content": "First hard problem that got submitted with 100% that too on 31.12.22 .. so happy.  Happy New Year 2023 to everyone.."
                    },
                    {
                        "username": "ravishk17",
                        "content": "Hey folks, I\\'d just like to thanks leetcode for providing a set of variety and challenging questions. It really helped me in getting confidence in coding. This year I\\'ve solved the daily problem for more than 200 days continuously.\\nCheers to LeetCode!!!\\nHappy new year!!"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Happy new year everyone. For whatever reason you are grinding out leecode, be it for the upcoming placements season or improving your dsa skills or the fact that you simply enjoy it, I hope you accomplish everything you had hoped for next year."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "A hard question with 80%+ acceptance rate and brute force solution. xD"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "I\\'m getting this error for [[0],[0],[2],[1]] testcase\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000002c8 at pc 0x000000347a28 bp 0x7ffea72c7e40 sp 0x7ffea72c7e38\\nREAD of size 8 at 0x6040000002c8 thread T0\\n    #3 0x7f0b0c76e0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x6040000002c8 is a wild pointer.\\nShadow bytes around the buggy address:\\n  0x0c087fff8000: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 06\\n  0x0c087fff8010: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8020: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8030: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8040: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 fa\\n=>0x0c087fff8050: fa fa fa fa fa fa fa fa fa[fa]fa fa fa fa fa fa\\n  0x0c087fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n\\n\\nMy code :\\nclass Solution {\\npublic:\\n    void bf(vector<vector<int>>& grid,int &ans,vector<vector<bool>>& visited,int i,     int j,int tar_c,int visit_c,int m,int n)\\n    {\\n        if( i>=m || j>=n || i<0 || j<0 ||grid[i][j]==-1 || (visited[i][j]==true ))\\n        return ;\\n        if(grid[i][j]==2 and tar_c>visit_c)\\n        return;\\n        visited[i][j]=true;\\n         //cout<<grid[i][j]<<\" \"<<i<<\",\"<<j<<tar_c<<\" \"<<visit_c<<\" \"<<endl;\\n        if(grid[i][j]==2 and tar_c==visit_c-1)\\n        {\\n            \\n            ans++;\\n         \\n        }\\n        bf(grid,ans,visited,i+1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j+1,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i-1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j-1,tar_c,visit_c+1,m,n);\\n\\n\\n       visited[i][j]=false;\\n        \\n        return ;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<bool>> visited;\\n        for(int i=0;i<n;i++)\\n        {vector<bool> temp;\\n            for(int j=0;j<n;j++)\\n            temp.push_back(false);\\n\\n        visited.push_back(temp);\\n        }\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {if(grid[i][j]==0)\\n                c++;\\n            if(grid[i][j]==1)\\n            {a=i;\\n            b=j;}}\\n        }\\n        int ans=0;\\n    \\n        \\n        bf(grid,ans,visited,a,b,c,0,m,n);\\n\\n        return ans;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@ajaykumar540official](/ajaykumar540official) see https://www.markdownguide.org/extended-syntax/#fenced-code-blocks"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) How ``` can be used to format code ?\\n"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the dimensions of `visited`. It should be have the same dimensions as `grid`, that is `m x n`.  \\nCan you spot the one character that needs to be changed?\\n\\nBTW: To format your code properly put a line with three backticks (<code>```</code>) before and after the code, or indent each line with four *additional* spaces."
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "Happy New Year! \\n           2o23\\nStay Safe and Motivated\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really want to know about more hard problems which are like this : ) \\n`Happy New Year Guys !! \\uD83E\\uDD73\\uD83C\\uDF89` "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Today I got my first badge and tomorrow would be the contest in the morning on  first day of New Year!\\nI hope everyone did well and enjoyed this year and will do more better in the upcoming year with lots of energy and courage.."
                    }
                ]
            },
            {
                "id": 1734915,
                "content": [
                    {
                        "username": "alecn2002",
                        "content": "These 2 constrains contradict to each other:\\n\\n- $$1 <= m * n <= 20$$\\n- There is exactly one starting cell and one ending cell.\\n\\nThe same cell can not be starting and ending at the same time, so $$m*n$$ could not be equal to 1, it should be at least 2."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Well, $$1 \\leqslant 2$$, so…"
                    },
                    {
                        "username": "sudip_0492",
                        "content": "First hard problem that got submitted with 100% that too on 31.12.22 .. so happy.  Happy New Year 2023 to everyone.."
                    },
                    {
                        "username": "ravishk17",
                        "content": "Hey folks, I\\'d just like to thanks leetcode for providing a set of variety and challenging questions. It really helped me in getting confidence in coding. This year I\\'ve solved the daily problem for more than 200 days continuously.\\nCheers to LeetCode!!!\\nHappy new year!!"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Happy new year everyone. For whatever reason you are grinding out leecode, be it for the upcoming placements season or improving your dsa skills or the fact that you simply enjoy it, I hope you accomplish everything you had hoped for next year."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "A hard question with 80%+ acceptance rate and brute force solution. xD"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "I\\'m getting this error for [[0],[0],[2],[1]] testcase\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000002c8 at pc 0x000000347a28 bp 0x7ffea72c7e40 sp 0x7ffea72c7e38\\nREAD of size 8 at 0x6040000002c8 thread T0\\n    #3 0x7f0b0c76e0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddress 0x6040000002c8 is a wild pointer.\\nShadow bytes around the buggy address:\\n  0x0c087fff8000: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 06\\n  0x0c087fff8010: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8020: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8030: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\\n  0x0c087fff8040: fa fa fd fd fd fd fd fd fa fa 00 00 00 00 00 fa\\n=>0x0c087fff8050: fa fa fa fa fa fa fa fa fa[fa]fa fa fa fa fa fa\\n  0x0c087fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c087fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n\\n\\nMy code :\\nclass Solution {\\npublic:\\n    void bf(vector<vector<int>>& grid,int &ans,vector<vector<bool>>& visited,int i,     int j,int tar_c,int visit_c,int m,int n)\\n    {\\n        if( i>=m || j>=n || i<0 || j<0 ||grid[i][j]==-1 || (visited[i][j]==true ))\\n        return ;\\n        if(grid[i][j]==2 and tar_c>visit_c)\\n        return;\\n        visited[i][j]=true;\\n         //cout<<grid[i][j]<<\" \"<<i<<\",\"<<j<<tar_c<<\" \"<<visit_c<<\" \"<<endl;\\n        if(grid[i][j]==2 and tar_c==visit_c-1)\\n        {\\n            \\n            ans++;\\n         \\n        }\\n        bf(grid,ans,visited,i+1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j+1,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i-1,j,tar_c,visit_c+1,m,n);\\n        bf(grid,ans,visited,i,j-1,tar_c,visit_c+1,m,n);\\n\\n\\n       visited[i][j]=false;\\n        \\n        return ;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<bool>> visited;\\n        for(int i=0;i<n;i++)\\n        {vector<bool> temp;\\n            for(int j=0;j<n;j++)\\n            temp.push_back(false);\\n\\n        visited.push_back(temp);\\n        }\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {if(grid[i][j]==0)\\n                c++;\\n            if(grid[i][j]==1)\\n            {a=i;\\n            b=j;}}\\n        }\\n        int ans=0;\\n    \\n        \\n        bf(grid,ans,visited,a,b,c,0,m,n);\\n\\n        return ans;\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@ajaykumar540official](/ajaykumar540official) see https://www.markdownguide.org/extended-syntax/#fenced-code-blocks"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) How ``` can be used to format code ?\\n"
                    },
                    {
                        "username": "ajaykumar540official",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thanks\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the dimensions of `visited`. It should be have the same dimensions as `grid`, that is `m x n`.  \\nCan you spot the one character that needs to be changed?\\n\\nBTW: To format your code properly put a line with three backticks (<code>```</code>) before and after the code, or indent each line with four *additional* spaces."
                    },
                    {
                        "username": "JakhongirMurodov",
                        "content": "Happy New Year! \\n           2o23\\nStay Safe and Motivated\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really want to know about more hard problems which are like this : ) \\n`Happy New Year Guys !! \\uD83E\\uDD73\\uD83C\\uDF89` "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Today I got my first badge and tomorrow would be the contest in the morning on  first day of New Year!\\nI hope everyone did well and enjoyed this year and will do more better in the upcoming year with lots of energy and courage.."
                    }
                ]
            },
            {
                "id": 1735402,
                "content": [
                    {
                        "username": "Lightning-Coder",
                        "content": " `class Solution {\\npublic:\\n    int totAvailable;\\n    int dfs(int si,int sj,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& dp,int cnt){\\n        if(si >= grid.size() || si < 0 || sj >= grid[0].size() || sj < 0 ){\\n            return 0;\\n        }\\n        if(grid[si][sj] == -1 || vis[si][sj] != -1) return 0;\\n\\n        if(grid[si][sj] == 2){\\n            if(totAvailable != cnt) return 0;\\n            return 1;\\n        }\\n        int ans = 0;\\n        vis[si][sj] = 1;\\n        ans += dfs(si+1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si-1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj+1,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj-1,grid,vis,dp,cnt+1);\\n        vis[si][sj] = -1;\\n        return ans;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int si,sj;\\n        totAvailable = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i = 0 ; i < row;i++){\\n            for(int j= 0;j < col;j++){\\n                if(grid[i][j] == 1) {\\n                    si = i;\\n                    sj = j;\\n                }\\n                if(grid[i][j] == 0 || grid[i][j] == 2) totAvailable++;\\n            }\\n        }\\n        vector<vector<int>> vis(row,vector<int> (col,-1));\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return dfs(si,sj,grid,vis,dp,0);\\n    }\\n};`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "This is a wrong place to post solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "nothing but brute force"
                    },
                    {
                        "username": "unordered_set",
                        "content": "The solution given in the editorial has a time complexity of 3^N where N is the number of cells.  Given the constraints 1 <= m * n <= 20. Don\\'t you guys 3^20 should give TLE?? 3^20 = 9^10"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Struggled to implement a DP solution only to realize that any squares result is dependent on the number of squares that lead up to that point. With a variable path beforehand, you will get variable results for any given square. Basically, just brute force it. Maybe leave a memo on each square that you cross so that you know if you\\'ve gone back to a square that\\'s been crossed already."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "Solved this question on my own in last 10 mins !!!!! Yay.\\n\\nFantastic end to the year 2022."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Can\\'t believe I\\'m able to solve this question without looking at any hints! \\n\\nHappy new year everyone and happy leetcoding!"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "Ahmed-Shukri02",
                        "content": "Great way to end the year."
                    },
                    {
                        "username": "Hailey-moon",
                        "content": "Happy new year to fellow nerds ;)) "
                    },
                    {
                        "username": "Diamantis",
                        "content": "A medium problem labeled as hard is a very good way to anticipate 2023!"
                    }
                ]
            },
            {
                "id": 2048976,
                "content": [
                    {
                        "username": "Lightning-Coder",
                        "content": " `class Solution {\\npublic:\\n    int totAvailable;\\n    int dfs(int si,int sj,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& dp,int cnt){\\n        if(si >= grid.size() || si < 0 || sj >= grid[0].size() || sj < 0 ){\\n            return 0;\\n        }\\n        if(grid[si][sj] == -1 || vis[si][sj] != -1) return 0;\\n\\n        if(grid[si][sj] == 2){\\n            if(totAvailable != cnt) return 0;\\n            return 1;\\n        }\\n        int ans = 0;\\n        vis[si][sj] = 1;\\n        ans += dfs(si+1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si-1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj+1,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj-1,grid,vis,dp,cnt+1);\\n        vis[si][sj] = -1;\\n        return ans;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int si,sj;\\n        totAvailable = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i = 0 ; i < row;i++){\\n            for(int j= 0;j < col;j++){\\n                if(grid[i][j] == 1) {\\n                    si = i;\\n                    sj = j;\\n                }\\n                if(grid[i][j] == 0 || grid[i][j] == 2) totAvailable++;\\n            }\\n        }\\n        vector<vector<int>> vis(row,vector<int> (col,-1));\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return dfs(si,sj,grid,vis,dp,0);\\n    }\\n};`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "This is a wrong place to post solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "nothing but brute force"
                    },
                    {
                        "username": "unordered_set",
                        "content": "The solution given in the editorial has a time complexity of 3^N where N is the number of cells.  Given the constraints 1 <= m * n <= 20. Don\\'t you guys 3^20 should give TLE?? 3^20 = 9^10"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Struggled to implement a DP solution only to realize that any squares result is dependent on the number of squares that lead up to that point. With a variable path beforehand, you will get variable results for any given square. Basically, just brute force it. Maybe leave a memo on each square that you cross so that you know if you\\'ve gone back to a square that\\'s been crossed already."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "Solved this question on my own in last 10 mins !!!!! Yay.\\n\\nFantastic end to the year 2022."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Can\\'t believe I\\'m able to solve this question without looking at any hints! \\n\\nHappy new year everyone and happy leetcoding!"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "Ahmed-Shukri02",
                        "content": "Great way to end the year."
                    },
                    {
                        "username": "Hailey-moon",
                        "content": "Happy new year to fellow nerds ;)) "
                    },
                    {
                        "username": "Diamantis",
                        "content": "A medium problem labeled as hard is a very good way to anticipate 2023!"
                    }
                ]
            },
            {
                "id": 2030605,
                "content": [
                    {
                        "username": "Lightning-Coder",
                        "content": " `class Solution {\\npublic:\\n    int totAvailable;\\n    int dfs(int si,int sj,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& dp,int cnt){\\n        if(si >= grid.size() || si < 0 || sj >= grid[0].size() || sj < 0 ){\\n            return 0;\\n        }\\n        if(grid[si][sj] == -1 || vis[si][sj] != -1) return 0;\\n\\n        if(grid[si][sj] == 2){\\n            if(totAvailable != cnt) return 0;\\n            return 1;\\n        }\\n        int ans = 0;\\n        vis[si][sj] = 1;\\n        ans += dfs(si+1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si-1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj+1,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj-1,grid,vis,dp,cnt+1);\\n        vis[si][sj] = -1;\\n        return ans;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int si,sj;\\n        totAvailable = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i = 0 ; i < row;i++){\\n            for(int j= 0;j < col;j++){\\n                if(grid[i][j] == 1) {\\n                    si = i;\\n                    sj = j;\\n                }\\n                if(grid[i][j] == 0 || grid[i][j] == 2) totAvailable++;\\n            }\\n        }\\n        vector<vector<int>> vis(row,vector<int> (col,-1));\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return dfs(si,sj,grid,vis,dp,0);\\n    }\\n};`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "This is a wrong place to post solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "nothing but brute force"
                    },
                    {
                        "username": "unordered_set",
                        "content": "The solution given in the editorial has a time complexity of 3^N where N is the number of cells.  Given the constraints 1 <= m * n <= 20. Don\\'t you guys 3^20 should give TLE?? 3^20 = 9^10"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Struggled to implement a DP solution only to realize that any squares result is dependent on the number of squares that lead up to that point. With a variable path beforehand, you will get variable results for any given square. Basically, just brute force it. Maybe leave a memo on each square that you cross so that you know if you\\'ve gone back to a square that\\'s been crossed already."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "Solved this question on my own in last 10 mins !!!!! Yay.\\n\\nFantastic end to the year 2022."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Can\\'t believe I\\'m able to solve this question without looking at any hints! \\n\\nHappy new year everyone and happy leetcoding!"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "Ahmed-Shukri02",
                        "content": "Great way to end the year."
                    },
                    {
                        "username": "Hailey-moon",
                        "content": "Happy new year to fellow nerds ;)) "
                    },
                    {
                        "username": "Diamantis",
                        "content": "A medium problem labeled as hard is a very good way to anticipate 2023!"
                    }
                ]
            },
            {
                "id": 2010201,
                "content": [
                    {
                        "username": "Lightning-Coder",
                        "content": " `class Solution {\\npublic:\\n    int totAvailable;\\n    int dfs(int si,int sj,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& dp,int cnt){\\n        if(si >= grid.size() || si < 0 || sj >= grid[0].size() || sj < 0 ){\\n            return 0;\\n        }\\n        if(grid[si][sj] == -1 || vis[si][sj] != -1) return 0;\\n\\n        if(grid[si][sj] == 2){\\n            if(totAvailable != cnt) return 0;\\n            return 1;\\n        }\\n        int ans = 0;\\n        vis[si][sj] = 1;\\n        ans += dfs(si+1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si-1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj+1,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj-1,grid,vis,dp,cnt+1);\\n        vis[si][sj] = -1;\\n        return ans;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int si,sj;\\n        totAvailable = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i = 0 ; i < row;i++){\\n            for(int j= 0;j < col;j++){\\n                if(grid[i][j] == 1) {\\n                    si = i;\\n                    sj = j;\\n                }\\n                if(grid[i][j] == 0 || grid[i][j] == 2) totAvailable++;\\n            }\\n        }\\n        vector<vector<int>> vis(row,vector<int> (col,-1));\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return dfs(si,sj,grid,vis,dp,0);\\n    }\\n};`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "This is a wrong place to post solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "nothing but brute force"
                    },
                    {
                        "username": "unordered_set",
                        "content": "The solution given in the editorial has a time complexity of 3^N where N is the number of cells.  Given the constraints 1 <= m * n <= 20. Don\\'t you guys 3^20 should give TLE?? 3^20 = 9^10"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Struggled to implement a DP solution only to realize that any squares result is dependent on the number of squares that lead up to that point. With a variable path beforehand, you will get variable results for any given square. Basically, just brute force it. Maybe leave a memo on each square that you cross so that you know if you\\'ve gone back to a square that\\'s been crossed already."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "Solved this question on my own in last 10 mins !!!!! Yay.\\n\\nFantastic end to the year 2022."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Can\\'t believe I\\'m able to solve this question without looking at any hints! \\n\\nHappy new year everyone and happy leetcoding!"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "Ahmed-Shukri02",
                        "content": "Great way to end the year."
                    },
                    {
                        "username": "Hailey-moon",
                        "content": "Happy new year to fellow nerds ;)) "
                    },
                    {
                        "username": "Diamantis",
                        "content": "A medium problem labeled as hard is a very good way to anticipate 2023!"
                    }
                ]
            },
            {
                "id": 1735908,
                "content": [
                    {
                        "username": "Lightning-Coder",
                        "content": " `class Solution {\\npublic:\\n    int totAvailable;\\n    int dfs(int si,int sj,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& dp,int cnt){\\n        if(si >= grid.size() || si < 0 || sj >= grid[0].size() || sj < 0 ){\\n            return 0;\\n        }\\n        if(grid[si][sj] == -1 || vis[si][sj] != -1) return 0;\\n\\n        if(grid[si][sj] == 2){\\n            if(totAvailable != cnt) return 0;\\n            return 1;\\n        }\\n        int ans = 0;\\n        vis[si][sj] = 1;\\n        ans += dfs(si+1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si-1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj+1,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj-1,grid,vis,dp,cnt+1);\\n        vis[si][sj] = -1;\\n        return ans;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int si,sj;\\n        totAvailable = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i = 0 ; i < row;i++){\\n            for(int j= 0;j < col;j++){\\n                if(grid[i][j] == 1) {\\n                    si = i;\\n                    sj = j;\\n                }\\n                if(grid[i][j] == 0 || grid[i][j] == 2) totAvailable++;\\n            }\\n        }\\n        vector<vector<int>> vis(row,vector<int> (col,-1));\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return dfs(si,sj,grid,vis,dp,0);\\n    }\\n};`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "This is a wrong place to post solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "nothing but brute force"
                    },
                    {
                        "username": "unordered_set",
                        "content": "The solution given in the editorial has a time complexity of 3^N where N is the number of cells.  Given the constraints 1 <= m * n <= 20. Don\\'t you guys 3^20 should give TLE?? 3^20 = 9^10"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Struggled to implement a DP solution only to realize that any squares result is dependent on the number of squares that lead up to that point. With a variable path beforehand, you will get variable results for any given square. Basically, just brute force it. Maybe leave a memo on each square that you cross so that you know if you\\'ve gone back to a square that\\'s been crossed already."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "Solved this question on my own in last 10 mins !!!!! Yay.\\n\\nFantastic end to the year 2022."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Can\\'t believe I\\'m able to solve this question without looking at any hints! \\n\\nHappy new year everyone and happy leetcoding!"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "Ahmed-Shukri02",
                        "content": "Great way to end the year."
                    },
                    {
                        "username": "Hailey-moon",
                        "content": "Happy new year to fellow nerds ;)) "
                    },
                    {
                        "username": "Diamantis",
                        "content": "A medium problem labeled as hard is a very good way to anticipate 2023!"
                    }
                ]
            },
            {
                "id": 1735891,
                "content": [
                    {
                        "username": "Lightning-Coder",
                        "content": " `class Solution {\\npublic:\\n    int totAvailable;\\n    int dfs(int si,int sj,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& dp,int cnt){\\n        if(si >= grid.size() || si < 0 || sj >= grid[0].size() || sj < 0 ){\\n            return 0;\\n        }\\n        if(grid[si][sj] == -1 || vis[si][sj] != -1) return 0;\\n\\n        if(grid[si][sj] == 2){\\n            if(totAvailable != cnt) return 0;\\n            return 1;\\n        }\\n        int ans = 0;\\n        vis[si][sj] = 1;\\n        ans += dfs(si+1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si-1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj+1,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj-1,grid,vis,dp,cnt+1);\\n        vis[si][sj] = -1;\\n        return ans;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int si,sj;\\n        totAvailable = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i = 0 ; i < row;i++){\\n            for(int j= 0;j < col;j++){\\n                if(grid[i][j] == 1) {\\n                    si = i;\\n                    sj = j;\\n                }\\n                if(grid[i][j] == 0 || grid[i][j] == 2) totAvailable++;\\n            }\\n        }\\n        vector<vector<int>> vis(row,vector<int> (col,-1));\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return dfs(si,sj,grid,vis,dp,0);\\n    }\\n};`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "This is a wrong place to post solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "nothing but brute force"
                    },
                    {
                        "username": "unordered_set",
                        "content": "The solution given in the editorial has a time complexity of 3^N where N is the number of cells.  Given the constraints 1 <= m * n <= 20. Don\\'t you guys 3^20 should give TLE?? 3^20 = 9^10"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Struggled to implement a DP solution only to realize that any squares result is dependent on the number of squares that lead up to that point. With a variable path beforehand, you will get variable results for any given square. Basically, just brute force it. Maybe leave a memo on each square that you cross so that you know if you\\'ve gone back to a square that\\'s been crossed already."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "Solved this question on my own in last 10 mins !!!!! Yay.\\n\\nFantastic end to the year 2022."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Can\\'t believe I\\'m able to solve this question without looking at any hints! \\n\\nHappy new year everyone and happy leetcoding!"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "Ahmed-Shukri02",
                        "content": "Great way to end the year."
                    },
                    {
                        "username": "Hailey-moon",
                        "content": "Happy new year to fellow nerds ;)) "
                    },
                    {
                        "username": "Diamantis",
                        "content": "A medium problem labeled as hard is a very good way to anticipate 2023!"
                    }
                ]
            },
            {
                "id": 1735867,
                "content": [
                    {
                        "username": "Lightning-Coder",
                        "content": " `class Solution {\\npublic:\\n    int totAvailable;\\n    int dfs(int si,int sj,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& dp,int cnt){\\n        if(si >= grid.size() || si < 0 || sj >= grid[0].size() || sj < 0 ){\\n            return 0;\\n        }\\n        if(grid[si][sj] == -1 || vis[si][sj] != -1) return 0;\\n\\n        if(grid[si][sj] == 2){\\n            if(totAvailable != cnt) return 0;\\n            return 1;\\n        }\\n        int ans = 0;\\n        vis[si][sj] = 1;\\n        ans += dfs(si+1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si-1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj+1,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj-1,grid,vis,dp,cnt+1);\\n        vis[si][sj] = -1;\\n        return ans;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int si,sj;\\n        totAvailable = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i = 0 ; i < row;i++){\\n            for(int j= 0;j < col;j++){\\n                if(grid[i][j] == 1) {\\n                    si = i;\\n                    sj = j;\\n                }\\n                if(grid[i][j] == 0 || grid[i][j] == 2) totAvailable++;\\n            }\\n        }\\n        vector<vector<int>> vis(row,vector<int> (col,-1));\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return dfs(si,sj,grid,vis,dp,0);\\n    }\\n};`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "This is a wrong place to post solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "nothing but brute force"
                    },
                    {
                        "username": "unordered_set",
                        "content": "The solution given in the editorial has a time complexity of 3^N where N is the number of cells.  Given the constraints 1 <= m * n <= 20. Don\\'t you guys 3^20 should give TLE?? 3^20 = 9^10"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Struggled to implement a DP solution only to realize that any squares result is dependent on the number of squares that lead up to that point. With a variable path beforehand, you will get variable results for any given square. Basically, just brute force it. Maybe leave a memo on each square that you cross so that you know if you\\'ve gone back to a square that\\'s been crossed already."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "Solved this question on my own in last 10 mins !!!!! Yay.\\n\\nFantastic end to the year 2022."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Can\\'t believe I\\'m able to solve this question without looking at any hints! \\n\\nHappy new year everyone and happy leetcoding!"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "Ahmed-Shukri02",
                        "content": "Great way to end the year."
                    },
                    {
                        "username": "Hailey-moon",
                        "content": "Happy new year to fellow nerds ;)) "
                    },
                    {
                        "username": "Diamantis",
                        "content": "A medium problem labeled as hard is a very good way to anticipate 2023!"
                    }
                ]
            },
            {
                "id": 1735849,
                "content": [
                    {
                        "username": "Lightning-Coder",
                        "content": " `class Solution {\\npublic:\\n    int totAvailable;\\n    int dfs(int si,int sj,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& dp,int cnt){\\n        if(si >= grid.size() || si < 0 || sj >= grid[0].size() || sj < 0 ){\\n            return 0;\\n        }\\n        if(grid[si][sj] == -1 || vis[si][sj] != -1) return 0;\\n\\n        if(grid[si][sj] == 2){\\n            if(totAvailable != cnt) return 0;\\n            return 1;\\n        }\\n        int ans = 0;\\n        vis[si][sj] = 1;\\n        ans += dfs(si+1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si-1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj+1,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj-1,grid,vis,dp,cnt+1);\\n        vis[si][sj] = -1;\\n        return ans;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int si,sj;\\n        totAvailable = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i = 0 ; i < row;i++){\\n            for(int j= 0;j < col;j++){\\n                if(grid[i][j] == 1) {\\n                    si = i;\\n                    sj = j;\\n                }\\n                if(grid[i][j] == 0 || grid[i][j] == 2) totAvailable++;\\n            }\\n        }\\n        vector<vector<int>> vis(row,vector<int> (col,-1));\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return dfs(si,sj,grid,vis,dp,0);\\n    }\\n};`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "This is a wrong place to post solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "nothing but brute force"
                    },
                    {
                        "username": "unordered_set",
                        "content": "The solution given in the editorial has a time complexity of 3^N where N is the number of cells.  Given the constraints 1 <= m * n <= 20. Don\\'t you guys 3^20 should give TLE?? 3^20 = 9^10"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Struggled to implement a DP solution only to realize that any squares result is dependent on the number of squares that lead up to that point. With a variable path beforehand, you will get variable results for any given square. Basically, just brute force it. Maybe leave a memo on each square that you cross so that you know if you\\'ve gone back to a square that\\'s been crossed already."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "Solved this question on my own in last 10 mins !!!!! Yay.\\n\\nFantastic end to the year 2022."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Can\\'t believe I\\'m able to solve this question without looking at any hints! \\n\\nHappy new year everyone and happy leetcoding!"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "Ahmed-Shukri02",
                        "content": "Great way to end the year."
                    },
                    {
                        "username": "Hailey-moon",
                        "content": "Happy new year to fellow nerds ;)) "
                    },
                    {
                        "username": "Diamantis",
                        "content": "A medium problem labeled as hard is a very good way to anticipate 2023!"
                    }
                ]
            },
            {
                "id": 1735789,
                "content": [
                    {
                        "username": "Lightning-Coder",
                        "content": " `class Solution {\\npublic:\\n    int totAvailable;\\n    int dfs(int si,int sj,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& dp,int cnt){\\n        if(si >= grid.size() || si < 0 || sj >= grid[0].size() || sj < 0 ){\\n            return 0;\\n        }\\n        if(grid[si][sj] == -1 || vis[si][sj] != -1) return 0;\\n\\n        if(grid[si][sj] == 2){\\n            if(totAvailable != cnt) return 0;\\n            return 1;\\n        }\\n        int ans = 0;\\n        vis[si][sj] = 1;\\n        ans += dfs(si+1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si-1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj+1,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj-1,grid,vis,dp,cnt+1);\\n        vis[si][sj] = -1;\\n        return ans;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int si,sj;\\n        totAvailable = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i = 0 ; i < row;i++){\\n            for(int j= 0;j < col;j++){\\n                if(grid[i][j] == 1) {\\n                    si = i;\\n                    sj = j;\\n                }\\n                if(grid[i][j] == 0 || grid[i][j] == 2) totAvailable++;\\n            }\\n        }\\n        vector<vector<int>> vis(row,vector<int> (col,-1));\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return dfs(si,sj,grid,vis,dp,0);\\n    }\\n};`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "This is a wrong place to post solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "nothing but brute force"
                    },
                    {
                        "username": "unordered_set",
                        "content": "The solution given in the editorial has a time complexity of 3^N where N is the number of cells.  Given the constraints 1 <= m * n <= 20. Don\\'t you guys 3^20 should give TLE?? 3^20 = 9^10"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Struggled to implement a DP solution only to realize that any squares result is dependent on the number of squares that lead up to that point. With a variable path beforehand, you will get variable results for any given square. Basically, just brute force it. Maybe leave a memo on each square that you cross so that you know if you\\'ve gone back to a square that\\'s been crossed already."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "Solved this question on my own in last 10 mins !!!!! Yay.\\n\\nFantastic end to the year 2022."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Can\\'t believe I\\'m able to solve this question without looking at any hints! \\n\\nHappy new year everyone and happy leetcoding!"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "Ahmed-Shukri02",
                        "content": "Great way to end the year."
                    },
                    {
                        "username": "Hailey-moon",
                        "content": "Happy new year to fellow nerds ;)) "
                    },
                    {
                        "username": "Diamantis",
                        "content": "A medium problem labeled as hard is a very good way to anticipate 2023!"
                    }
                ]
            },
            {
                "id": 1735779,
                "content": [
                    {
                        "username": "Lightning-Coder",
                        "content": " `class Solution {\\npublic:\\n    int totAvailable;\\n    int dfs(int si,int sj,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& dp,int cnt){\\n        if(si >= grid.size() || si < 0 || sj >= grid[0].size() || sj < 0 ){\\n            return 0;\\n        }\\n        if(grid[si][sj] == -1 || vis[si][sj] != -1) return 0;\\n\\n        if(grid[si][sj] == 2){\\n            if(totAvailable != cnt) return 0;\\n            return 1;\\n        }\\n        int ans = 0;\\n        vis[si][sj] = 1;\\n        ans += dfs(si+1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si-1,sj,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj+1,grid,vis,dp,cnt+1);\\n        ans += dfs(si,sj-1,grid,vis,dp,cnt+1);\\n        vis[si][sj] = -1;\\n        return ans;\\n    }\\n    int uniquePathsIII(vector<vector<int>>& grid) {\\n        int si,sj;\\n        totAvailable = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i = 0 ; i < row;i++){\\n            for(int j= 0;j < col;j++){\\n                if(grid[i][j] == 1) {\\n                    si = i;\\n                    sj = j;\\n                }\\n                if(grid[i][j] == 0 || grid[i][j] == 2) totAvailable++;\\n            }\\n        }\\n        vector<vector<int>> vis(row,vector<int> (col,-1));\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return dfs(si,sj,grid,vis,dp,0);\\n    }\\n};`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "This is a wrong place to post solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "nothing but brute force"
                    },
                    {
                        "username": "unordered_set",
                        "content": "The solution given in the editorial has a time complexity of 3^N where N is the number of cells.  Given the constraints 1 <= m * n <= 20. Don\\'t you guys 3^20 should give TLE?? 3^20 = 9^10"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Struggled to implement a DP solution only to realize that any squares result is dependent on the number of squares that lead up to that point. With a variable path beforehand, you will get variable results for any given square. Basically, just brute force it. Maybe leave a memo on each square that you cross so that you know if you\\'ve gone back to a square that\\'s been crossed already."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "Solved this question on my own in last 10 mins !!!!! Yay.\\n\\nFantastic end to the year 2022."
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Can\\'t believe I\\'m able to solve this question without looking at any hints! \\n\\nHappy new year everyone and happy leetcoding!"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Happy new year!"
                    },
                    {
                        "username": "Ahmed-Shukri02",
                        "content": "Great way to end the year."
                    },
                    {
                        "username": "Hailey-moon",
                        "content": "Happy new year to fellow nerds ;)) "
                    },
                    {
                        "username": "Diamantis",
                        "content": "A medium problem labeled as hard is a very good way to anticipate 2023!"
                    }
                ]
            },
            {
                "id": 1735765,
                "content": [
                    {
                        "username": "hyperbole",
                        "content": "should be medium"
                    },
                    {
                        "username": "santanusen",
                        "content": "Wish the New Year brings you your dream offer from your dream company.\\nHappy New Year!!!"
                    },
                    {
                        "username": "Vishaljenny",
                        "content": "coming 22 to 23. :) \\n\\u2581 \\u2582 \\u2584 \\u2585 \\u2586 \\u2587 \\u2588   \\uD83C\\uDF80  \\uD835\\uDFE4\\u2661\\uD835\\uDFE4\\uD835\\uDFE5  \\uD83C\\uDF80   \\u2588 \\u2587 \\u2586 \\u2585 \\u2584 \\u2582 \\u2581"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Happy new year everyone :) ! hope we all find mutiple paths to reach our destination covering all the happiness and escaping all the obstacles  (new year wishes inspired from this problem!!! ) "
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone may all of you accomplish your dream this year. Happy leetcoding and happy new year\\uD83D\\uDE09\\uD83D\\uDE09 "
                    },
                    {
                        "username": "_metaverse_",
                        "content": "## Repeat after me...\\n ~I\\'m about to walk into the greatest year of my life.... ~"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Happy New Year all.\nSolved this without help. And ended 2022 with this.\nI wish all aspirants good luck so that their dreams come true."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "Harsh_Anand19",
                        "content": "\ncan anyone suggest why it is giving runtime error saying: stack-overflow?\n```\nclass Solution {\n    int cnt = 0;\n    int n,m;\n    int func(int i, int j, vector<vector<int>>& grid) {\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j] == -1) return 0;\n        if(grid[i][j] == 2) return (cnt == -1 ? 1 : 0);\n        \n        grid[i][j] = 3;\n        cnt--;\n        int op1 = func(i+1,j,grid);\n        int op2 = func(i-1,j,grid);\n        int op3 = func(i,j+1,grid);\n        int op4 = func(i,j-1,grid);\n        grid[i][j] = 0;\n        return op1 + op2 + op3 + op4;\n    }\n\npublic:\n    int uniquePathsIII(vector<vector<int>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n\n        int sti=-1,stj=-1;\n        for(int i=0 ; i<n ; i++) {\n            for(int j=0 ; j<m ; j++) {\n                if(grid[i][j] == 1) {\n                    sti=i;\n                    stj=j;\n                }\n                else if(grid[i][j] == 0) cnt++;\n            }\n        }\n\n        return func(sti,stj,grid);\n    }\n};\n```"
                    },
                    {
                        "username": "kcharris77",
                        "content": "Not a very hard problem. Mainly a bit to keep track of."
                    }
                ]
            },
            {
                "id": 1735756,
                "content": [
                    {
                        "username": "hyperbole",
                        "content": "should be medium"
                    },
                    {
                        "username": "santanusen",
                        "content": "Wish the New Year brings you your dream offer from your dream company.\\nHappy New Year!!!"
                    },
                    {
                        "username": "Vishaljenny",
                        "content": "coming 22 to 23. :) \\n\\u2581 \\u2582 \\u2584 \\u2585 \\u2586 \\u2587 \\u2588   \\uD83C\\uDF80  \\uD835\\uDFE4\\u2661\\uD835\\uDFE4\\uD835\\uDFE5  \\uD83C\\uDF80   \\u2588 \\u2587 \\u2586 \\u2585 \\u2584 \\u2582 \\u2581"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Happy new year everyone :) ! hope we all find mutiple paths to reach our destination covering all the happiness and escaping all the obstacles  (new year wishes inspired from this problem!!! ) "
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone may all of you accomplish your dream this year. Happy leetcoding and happy new year\\uD83D\\uDE09\\uD83D\\uDE09 "
                    },
                    {
                        "username": "_metaverse_",
                        "content": "## Repeat after me...\\n ~I\\'m about to walk into the greatest year of my life.... ~"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Happy New Year all.\nSolved this without help. And ended 2022 with this.\nI wish all aspirants good luck so that their dreams come true."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "Harsh_Anand19",
                        "content": "\ncan anyone suggest why it is giving runtime error saying: stack-overflow?\n```\nclass Solution {\n    int cnt = 0;\n    int n,m;\n    int func(int i, int j, vector<vector<int>>& grid) {\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j] == -1) return 0;\n        if(grid[i][j] == 2) return (cnt == -1 ? 1 : 0);\n        \n        grid[i][j] = 3;\n        cnt--;\n        int op1 = func(i+1,j,grid);\n        int op2 = func(i-1,j,grid);\n        int op3 = func(i,j+1,grid);\n        int op4 = func(i,j-1,grid);\n        grid[i][j] = 0;\n        return op1 + op2 + op3 + op4;\n    }\n\npublic:\n    int uniquePathsIII(vector<vector<int>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n\n        int sti=-1,stj=-1;\n        for(int i=0 ; i<n ; i++) {\n            for(int j=0 ; j<m ; j++) {\n                if(grid[i][j] == 1) {\n                    sti=i;\n                    stj=j;\n                }\n                else if(grid[i][j] == 0) cnt++;\n            }\n        }\n\n        return func(sti,stj,grid);\n    }\n};\n```"
                    },
                    {
                        "username": "kcharris77",
                        "content": "Not a very hard problem. Mainly a bit to keep track of."
                    }
                ]
            },
            {
                "id": 1735678,
                "content": [
                    {
                        "username": "hyperbole",
                        "content": "should be medium"
                    },
                    {
                        "username": "santanusen",
                        "content": "Wish the New Year brings you your dream offer from your dream company.\\nHappy New Year!!!"
                    },
                    {
                        "username": "Vishaljenny",
                        "content": "coming 22 to 23. :) \\n\\u2581 \\u2582 \\u2584 \\u2585 \\u2586 \\u2587 \\u2588   \\uD83C\\uDF80  \\uD835\\uDFE4\\u2661\\uD835\\uDFE4\\uD835\\uDFE5  \\uD83C\\uDF80   \\u2588 \\u2587 \\u2586 \\u2585 \\u2584 \\u2582 \\u2581"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Happy new year everyone :) ! hope we all find mutiple paths to reach our destination covering all the happiness and escaping all the obstacles  (new year wishes inspired from this problem!!! ) "
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone may all of you accomplish your dream this year. Happy leetcoding and happy new year\\uD83D\\uDE09\\uD83D\\uDE09 "
                    },
                    {
                        "username": "_metaverse_",
                        "content": "## Repeat after me...\\n ~I\\'m about to walk into the greatest year of my life.... ~"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Happy New Year all.\nSolved this without help. And ended 2022 with this.\nI wish all aspirants good luck so that their dreams come true."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "Harsh_Anand19",
                        "content": "\ncan anyone suggest why it is giving runtime error saying: stack-overflow?\n```\nclass Solution {\n    int cnt = 0;\n    int n,m;\n    int func(int i, int j, vector<vector<int>>& grid) {\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j] == -1) return 0;\n        if(grid[i][j] == 2) return (cnt == -1 ? 1 : 0);\n        \n        grid[i][j] = 3;\n        cnt--;\n        int op1 = func(i+1,j,grid);\n        int op2 = func(i-1,j,grid);\n        int op3 = func(i,j+1,grid);\n        int op4 = func(i,j-1,grid);\n        grid[i][j] = 0;\n        return op1 + op2 + op3 + op4;\n    }\n\npublic:\n    int uniquePathsIII(vector<vector<int>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n\n        int sti=-1,stj=-1;\n        for(int i=0 ; i<n ; i++) {\n            for(int j=0 ; j<m ; j++) {\n                if(grid[i][j] == 1) {\n                    sti=i;\n                    stj=j;\n                }\n                else if(grid[i][j] == 0) cnt++;\n            }\n        }\n\n        return func(sti,stj,grid);\n    }\n};\n```"
                    },
                    {
                        "username": "kcharris77",
                        "content": "Not a very hard problem. Mainly a bit to keep track of."
                    }
                ]
            },
            {
                "id": 1735666,
                "content": [
                    {
                        "username": "hyperbole",
                        "content": "should be medium"
                    },
                    {
                        "username": "santanusen",
                        "content": "Wish the New Year brings you your dream offer from your dream company.\\nHappy New Year!!!"
                    },
                    {
                        "username": "Vishaljenny",
                        "content": "coming 22 to 23. :) \\n\\u2581 \\u2582 \\u2584 \\u2585 \\u2586 \\u2587 \\u2588   \\uD83C\\uDF80  \\uD835\\uDFE4\\u2661\\uD835\\uDFE4\\uD835\\uDFE5  \\uD83C\\uDF80   \\u2588 \\u2587 \\u2586 \\u2585 \\u2584 \\u2582 \\u2581"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Happy new year everyone :) ! hope we all find mutiple paths to reach our destination covering all the happiness and escaping all the obstacles  (new year wishes inspired from this problem!!! ) "
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone may all of you accomplish your dream this year. Happy leetcoding and happy new year\\uD83D\\uDE09\\uD83D\\uDE09 "
                    },
                    {
                        "username": "_metaverse_",
                        "content": "## Repeat after me...\\n ~I\\'m about to walk into the greatest year of my life.... ~"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Happy New Year all.\nSolved this without help. And ended 2022 with this.\nI wish all aspirants good luck so that their dreams come true."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "Harsh_Anand19",
                        "content": "\ncan anyone suggest why it is giving runtime error saying: stack-overflow?\n```\nclass Solution {\n    int cnt = 0;\n    int n,m;\n    int func(int i, int j, vector<vector<int>>& grid) {\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j] == -1) return 0;\n        if(grid[i][j] == 2) return (cnt == -1 ? 1 : 0);\n        \n        grid[i][j] = 3;\n        cnt--;\n        int op1 = func(i+1,j,grid);\n        int op2 = func(i-1,j,grid);\n        int op3 = func(i,j+1,grid);\n        int op4 = func(i,j-1,grid);\n        grid[i][j] = 0;\n        return op1 + op2 + op3 + op4;\n    }\n\npublic:\n    int uniquePathsIII(vector<vector<int>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n\n        int sti=-1,stj=-1;\n        for(int i=0 ; i<n ; i++) {\n            for(int j=0 ; j<m ; j++) {\n                if(grid[i][j] == 1) {\n                    sti=i;\n                    stj=j;\n                }\n                else if(grid[i][j] == 0) cnt++;\n            }\n        }\n\n        return func(sti,stj,grid);\n    }\n};\n```"
                    },
                    {
                        "username": "kcharris77",
                        "content": "Not a very hard problem. Mainly a bit to keep track of."
                    }
                ]
            },
            {
                "id": 1735665,
                "content": [
                    {
                        "username": "hyperbole",
                        "content": "should be medium"
                    },
                    {
                        "username": "santanusen",
                        "content": "Wish the New Year brings you your dream offer from your dream company.\\nHappy New Year!!!"
                    },
                    {
                        "username": "Vishaljenny",
                        "content": "coming 22 to 23. :) \\n\\u2581 \\u2582 \\u2584 \\u2585 \\u2586 \\u2587 \\u2588   \\uD83C\\uDF80  \\uD835\\uDFE4\\u2661\\uD835\\uDFE4\\uD835\\uDFE5  \\uD83C\\uDF80   \\u2588 \\u2587 \\u2586 \\u2585 \\u2584 \\u2582 \\u2581"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Happy new year everyone :) ! hope we all find mutiple paths to reach our destination covering all the happiness and escaping all the obstacles  (new year wishes inspired from this problem!!! ) "
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone may all of you accomplish your dream this year. Happy leetcoding and happy new year\\uD83D\\uDE09\\uD83D\\uDE09 "
                    },
                    {
                        "username": "_metaverse_",
                        "content": "## Repeat after me...\\n ~I\\'m about to walk into the greatest year of my life.... ~"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Happy New Year all.\nSolved this without help. And ended 2022 with this.\nI wish all aspirants good luck so that their dreams come true."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "Harsh_Anand19",
                        "content": "\ncan anyone suggest why it is giving runtime error saying: stack-overflow?\n```\nclass Solution {\n    int cnt = 0;\n    int n,m;\n    int func(int i, int j, vector<vector<int>>& grid) {\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j] == -1) return 0;\n        if(grid[i][j] == 2) return (cnt == -1 ? 1 : 0);\n        \n        grid[i][j] = 3;\n        cnt--;\n        int op1 = func(i+1,j,grid);\n        int op2 = func(i-1,j,grid);\n        int op3 = func(i,j+1,grid);\n        int op4 = func(i,j-1,grid);\n        grid[i][j] = 0;\n        return op1 + op2 + op3 + op4;\n    }\n\npublic:\n    int uniquePathsIII(vector<vector<int>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n\n        int sti=-1,stj=-1;\n        for(int i=0 ; i<n ; i++) {\n            for(int j=0 ; j<m ; j++) {\n                if(grid[i][j] == 1) {\n                    sti=i;\n                    stj=j;\n                }\n                else if(grid[i][j] == 0) cnt++;\n            }\n        }\n\n        return func(sti,stj,grid);\n    }\n};\n```"
                    },
                    {
                        "username": "kcharris77",
                        "content": "Not a very hard problem. Mainly a bit to keep track of."
                    }
                ]
            },
            {
                "id": 1735663,
                "content": [
                    {
                        "username": "hyperbole",
                        "content": "should be medium"
                    },
                    {
                        "username": "santanusen",
                        "content": "Wish the New Year brings you your dream offer from your dream company.\\nHappy New Year!!!"
                    },
                    {
                        "username": "Vishaljenny",
                        "content": "coming 22 to 23. :) \\n\\u2581 \\u2582 \\u2584 \\u2585 \\u2586 \\u2587 \\u2588   \\uD83C\\uDF80  \\uD835\\uDFE4\\u2661\\uD835\\uDFE4\\uD835\\uDFE5  \\uD83C\\uDF80   \\u2588 \\u2587 \\u2586 \\u2585 \\u2584 \\u2582 \\u2581"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Happy new year everyone :) ! hope we all find mutiple paths to reach our destination covering all the happiness and escaping all the obstacles  (new year wishes inspired from this problem!!! ) "
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone may all of you accomplish your dream this year. Happy leetcoding and happy new year\\uD83D\\uDE09\\uD83D\\uDE09 "
                    },
                    {
                        "username": "_metaverse_",
                        "content": "## Repeat after me...\\n ~I\\'m about to walk into the greatest year of my life.... ~"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Happy New Year all.\nSolved this without help. And ended 2022 with this.\nI wish all aspirants good luck so that their dreams come true."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "Harsh_Anand19",
                        "content": "\ncan anyone suggest why it is giving runtime error saying: stack-overflow?\n```\nclass Solution {\n    int cnt = 0;\n    int n,m;\n    int func(int i, int j, vector<vector<int>>& grid) {\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j] == -1) return 0;\n        if(grid[i][j] == 2) return (cnt == -1 ? 1 : 0);\n        \n        grid[i][j] = 3;\n        cnt--;\n        int op1 = func(i+1,j,grid);\n        int op2 = func(i-1,j,grid);\n        int op3 = func(i,j+1,grid);\n        int op4 = func(i,j-1,grid);\n        grid[i][j] = 0;\n        return op1 + op2 + op3 + op4;\n    }\n\npublic:\n    int uniquePathsIII(vector<vector<int>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n\n        int sti=-1,stj=-1;\n        for(int i=0 ; i<n ; i++) {\n            for(int j=0 ; j<m ; j++) {\n                if(grid[i][j] == 1) {\n                    sti=i;\n                    stj=j;\n                }\n                else if(grid[i][j] == 0) cnt++;\n            }\n        }\n\n        return func(sti,stj,grid);\n    }\n};\n```"
                    },
                    {
                        "username": "kcharris77",
                        "content": "Not a very hard problem. Mainly a bit to keep track of."
                    }
                ]
            },
            {
                "id": 1735424,
                "content": [
                    {
                        "username": "hyperbole",
                        "content": "should be medium"
                    },
                    {
                        "username": "santanusen",
                        "content": "Wish the New Year brings you your dream offer from your dream company.\\nHappy New Year!!!"
                    },
                    {
                        "username": "Vishaljenny",
                        "content": "coming 22 to 23. :) \\n\\u2581 \\u2582 \\u2584 \\u2585 \\u2586 \\u2587 \\u2588   \\uD83C\\uDF80  \\uD835\\uDFE4\\u2661\\uD835\\uDFE4\\uD835\\uDFE5  \\uD83C\\uDF80   \\u2588 \\u2587 \\u2586 \\u2585 \\u2584 \\u2582 \\u2581"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Happy new year everyone :) ! hope we all find mutiple paths to reach our destination covering all the happiness and escaping all the obstacles  (new year wishes inspired from this problem!!! ) "
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone may all of you accomplish your dream this year. Happy leetcoding and happy new year\\uD83D\\uDE09\\uD83D\\uDE09 "
                    },
                    {
                        "username": "_metaverse_",
                        "content": "## Repeat after me...\\n ~I\\'m about to walk into the greatest year of my life.... ~"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Happy New Year all.\nSolved this without help. And ended 2022 with this.\nI wish all aspirants good luck so that their dreams come true."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "Harsh_Anand19",
                        "content": "\ncan anyone suggest why it is giving runtime error saying: stack-overflow?\n```\nclass Solution {\n    int cnt = 0;\n    int n,m;\n    int func(int i, int j, vector<vector<int>>& grid) {\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j] == -1) return 0;\n        if(grid[i][j] == 2) return (cnt == -1 ? 1 : 0);\n        \n        grid[i][j] = 3;\n        cnt--;\n        int op1 = func(i+1,j,grid);\n        int op2 = func(i-1,j,grid);\n        int op3 = func(i,j+1,grid);\n        int op4 = func(i,j-1,grid);\n        grid[i][j] = 0;\n        return op1 + op2 + op3 + op4;\n    }\n\npublic:\n    int uniquePathsIII(vector<vector<int>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n\n        int sti=-1,stj=-1;\n        for(int i=0 ; i<n ; i++) {\n            for(int j=0 ; j<m ; j++) {\n                if(grid[i][j] == 1) {\n                    sti=i;\n                    stj=j;\n                }\n                else if(grid[i][j] == 0) cnt++;\n            }\n        }\n\n        return func(sti,stj,grid);\n    }\n};\n```"
                    },
                    {
                        "username": "kcharris77",
                        "content": "Not a very hard problem. Mainly a bit to keep track of."
                    }
                ]
            },
            {
                "id": 1735386,
                "content": [
                    {
                        "username": "hyperbole",
                        "content": "should be medium"
                    },
                    {
                        "username": "santanusen",
                        "content": "Wish the New Year brings you your dream offer from your dream company.\\nHappy New Year!!!"
                    },
                    {
                        "username": "Vishaljenny",
                        "content": "coming 22 to 23. :) \\n\\u2581 \\u2582 \\u2584 \\u2585 \\u2586 \\u2587 \\u2588   \\uD83C\\uDF80  \\uD835\\uDFE4\\u2661\\uD835\\uDFE4\\uD835\\uDFE5  \\uD83C\\uDF80   \\u2588 \\u2587 \\u2586 \\u2585 \\u2584 \\u2582 \\u2581"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Happy new year everyone :) ! hope we all find mutiple paths to reach our destination covering all the happiness and escaping all the obstacles  (new year wishes inspired from this problem!!! ) "
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone may all of you accomplish your dream this year. Happy leetcoding and happy new year\\uD83D\\uDE09\\uD83D\\uDE09 "
                    },
                    {
                        "username": "_metaverse_",
                        "content": "## Repeat after me...\\n ~I\\'m about to walk into the greatest year of my life.... ~"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Happy New Year all.\nSolved this without help. And ended 2022 with this.\nI wish all aspirants good luck so that their dreams come true."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "Harsh_Anand19",
                        "content": "\ncan anyone suggest why it is giving runtime error saying: stack-overflow?\n```\nclass Solution {\n    int cnt = 0;\n    int n,m;\n    int func(int i, int j, vector<vector<int>>& grid) {\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j] == -1) return 0;\n        if(grid[i][j] == 2) return (cnt == -1 ? 1 : 0);\n        \n        grid[i][j] = 3;\n        cnt--;\n        int op1 = func(i+1,j,grid);\n        int op2 = func(i-1,j,grid);\n        int op3 = func(i,j+1,grid);\n        int op4 = func(i,j-1,grid);\n        grid[i][j] = 0;\n        return op1 + op2 + op3 + op4;\n    }\n\npublic:\n    int uniquePathsIII(vector<vector<int>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n\n        int sti=-1,stj=-1;\n        for(int i=0 ; i<n ; i++) {\n            for(int j=0 ; j<m ; j++) {\n                if(grid[i][j] == 1) {\n                    sti=i;\n                    stj=j;\n                }\n                else if(grid[i][j] == 0) cnt++;\n            }\n        }\n\n        return func(sti,stj,grid);\n    }\n};\n```"
                    },
                    {
                        "username": "kcharris77",
                        "content": "Not a very hard problem. Mainly a bit to keep track of."
                    }
                ]
            },
            {
                "id": 1735363,
                "content": [
                    {
                        "username": "hyperbole",
                        "content": "should be medium"
                    },
                    {
                        "username": "santanusen",
                        "content": "Wish the New Year brings you your dream offer from your dream company.\\nHappy New Year!!!"
                    },
                    {
                        "username": "Vishaljenny",
                        "content": "coming 22 to 23. :) \\n\\u2581 \\u2582 \\u2584 \\u2585 \\u2586 \\u2587 \\u2588   \\uD83C\\uDF80  \\uD835\\uDFE4\\u2661\\uD835\\uDFE4\\uD835\\uDFE5  \\uD83C\\uDF80   \\u2588 \\u2587 \\u2586 \\u2585 \\u2584 \\u2582 \\u2581"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Happy new year everyone :) ! hope we all find mutiple paths to reach our destination covering all the happiness and escaping all the obstacles  (new year wishes inspired from this problem!!! ) "
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone may all of you accomplish your dream this year. Happy leetcoding and happy new year\\uD83D\\uDE09\\uD83D\\uDE09 "
                    },
                    {
                        "username": "_metaverse_",
                        "content": "## Repeat after me...\\n ~I\\'m about to walk into the greatest year of my life.... ~"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Happy New Year all.\nSolved this without help. And ended 2022 with this.\nI wish all aspirants good luck so that their dreams come true."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "Harsh_Anand19",
                        "content": "\ncan anyone suggest why it is giving runtime error saying: stack-overflow?\n```\nclass Solution {\n    int cnt = 0;\n    int n,m;\n    int func(int i, int j, vector<vector<int>>& grid) {\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j] == -1) return 0;\n        if(grid[i][j] == 2) return (cnt == -1 ? 1 : 0);\n        \n        grid[i][j] = 3;\n        cnt--;\n        int op1 = func(i+1,j,grid);\n        int op2 = func(i-1,j,grid);\n        int op3 = func(i,j+1,grid);\n        int op4 = func(i,j-1,grid);\n        grid[i][j] = 0;\n        return op1 + op2 + op3 + op4;\n    }\n\npublic:\n    int uniquePathsIII(vector<vector<int>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n\n        int sti=-1,stj=-1;\n        for(int i=0 ; i<n ; i++) {\n            for(int j=0 ; j<m ; j++) {\n                if(grid[i][j] == 1) {\n                    sti=i;\n                    stj=j;\n                }\n                else if(grid[i][j] == 0) cnt++;\n            }\n        }\n\n        return func(sti,stj,grid);\n    }\n};\n```"
                    },
                    {
                        "username": "kcharris77",
                        "content": "Not a very hard problem. Mainly a bit to keep track of."
                    }
                ]
            },
            {
                "id": 1735300,
                "content": [
                    {
                        "username": "hyperbole",
                        "content": "should be medium"
                    },
                    {
                        "username": "santanusen",
                        "content": "Wish the New Year brings you your dream offer from your dream company.\\nHappy New Year!!!"
                    },
                    {
                        "username": "Vishaljenny",
                        "content": "coming 22 to 23. :) \\n\\u2581 \\u2582 \\u2584 \\u2585 \\u2586 \\u2587 \\u2588   \\uD83C\\uDF80  \\uD835\\uDFE4\\u2661\\uD835\\uDFE4\\uD835\\uDFE5  \\uD83C\\uDF80   \\u2588 \\u2587 \\u2586 \\u2585 \\u2584 \\u2582 \\u2581"
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Happy new year everyone :) ! hope we all find mutiple paths to reach our destination covering all the happiness and escaping all the obstacles  (new year wishes inspired from this problem!!! ) "
                    },
                    {
                        "username": "surajku2022",
                        "content": "Happy new year everyone may all of you accomplish your dream this year. Happy leetcoding and happy new year\\uD83D\\uDE09\\uD83D\\uDE09 "
                    },
                    {
                        "username": "_metaverse_",
                        "content": "## Repeat after me...\\n ~I\\'m about to walk into the greatest year of my life.... ~"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Happy New Year all.\nSolved this without help. And ended 2022 with this.\nI wish all aspirants good luck so that their dreams come true."
                    },
                    {
                        "username": "JoshuaMorris95",
                        "content": "Happy new year everyone!"
                    },
                    {
                        "username": "Harsh_Anand19",
                        "content": "\ncan anyone suggest why it is giving runtime error saying: stack-overflow?\n```\nclass Solution {\n    int cnt = 0;\n    int n,m;\n    int func(int i, int j, vector<vector<int>>& grid) {\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j] == -1) return 0;\n        if(grid[i][j] == 2) return (cnt == -1 ? 1 : 0);\n        \n        grid[i][j] = 3;\n        cnt--;\n        int op1 = func(i+1,j,grid);\n        int op2 = func(i-1,j,grid);\n        int op3 = func(i,j+1,grid);\n        int op4 = func(i,j-1,grid);\n        grid[i][j] = 0;\n        return op1 + op2 + op3 + op4;\n    }\n\npublic:\n    int uniquePathsIII(vector<vector<int>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n\n        int sti=-1,stj=-1;\n        for(int i=0 ; i<n ; i++) {\n            for(int j=0 ; j<m ; j++) {\n                if(grid[i][j] == 1) {\n                    sti=i;\n                    stj=j;\n                }\n                else if(grid[i][j] == 0) cnt++;\n            }\n        }\n\n        return func(sti,stj,grid);\n    }\n};\n```"
                    },
                    {
                        "username": "kcharris77",
                        "content": "Not a very hard problem. Mainly a bit to keep track of."
                    }
                ]
            },
            {
                "id": 1735232,
                "content": [
                    {
                        "username": "maxfadeev",
                        "content": "Happy New Year! Wish everyone peace, happiness and prosperity in the coming year!"
                    },
                    {
                        "username": "Tipra",
                        "content": "Dunno why a straightforward implementation of backtracking would be categorized as hard. Usually I\\'m unable to solve hard questions so kinda weird."
                    },
                    {
                        "username": "dsyz17d2",
                        "content": "I wish everyone happy nd peaceful upcoming year!"
                    },
                    {
                        "username": "Jaiff",
                        "content": "LONG LIVE LEETCODE! and Happy New Year to you, the reader."
                    },
                    {
                        "username": "space_invader",
                        "content": "The last day of 2023. Expectation: easy. Actual: hard.\\n\\nalright... "
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Ending off the year with a hard problem I see!\\nGreat way to brace ourselves for what us gonna be a nightmare of an year. Thanks leetcode.\\n"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Important line is walk over EVERY non-obstacle square exactly ONCE."
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Why this solution giving me Stackoverflow error please help me\\n\\n ```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int m=grid.length, n=grid[0].length, count=0, res=0, starti=0, startj=0;\\n        boolean[][] vis = new boolean[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1|| grid[i][j] == 0 || grid[i][j] == 2)\\n                    count++;\\n                if(grid[i][j] == 1){\\n                    starti = i;\\n                    startj = j;\\n                }\\n            }\\n        }\\n\\n        return dfs(starti, startj, count,grid,0, res, vis);\\n        \\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int dfs(int i, int j, int count, int[][] grid, int curCount, int res, boolean[][] vis){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1) return 0;\\n        \\n        \\n        vis[i][j] = true;\\n        curCount++;\\n\\n        if(grid[i][j] == 2){\\n            if(curCount == count) return 1;\\n            return 0;\\n        }\\n\\n        int totalPaths = 0;\\n        for(int k=0; k<4; k++){\\n            totalPaths += dfs(i+dir[k][0] , j+dir[k][1], count, grid, curCount, res,vis);\\n        }\\n\\n        curCount--;\\n        vis[i][j] = false;\\n\\n        return totalPaths;\\n        \\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Also return 0 if you have already visited the same cell in the first if condition\\nif(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1 || vis[i][j]) return 0;\\n\\nHope it helps"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Happy to end the year by solving a hard problem :)"
                    },
                    {
                        "username": "arajshow",
                        "content": "Using DFS is optimized solution or we need to think more."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "na that\\'s brute force there\\'s apparently a bitmask dp solution too"
                    }
                ]
            },
            {
                "id": 1735216,
                "content": [
                    {
                        "username": "maxfadeev",
                        "content": "Happy New Year! Wish everyone peace, happiness and prosperity in the coming year!"
                    },
                    {
                        "username": "Tipra",
                        "content": "Dunno why a straightforward implementation of backtracking would be categorized as hard. Usually I\\'m unable to solve hard questions so kinda weird."
                    },
                    {
                        "username": "dsyz17d2",
                        "content": "I wish everyone happy nd peaceful upcoming year!"
                    },
                    {
                        "username": "Jaiff",
                        "content": "LONG LIVE LEETCODE! and Happy New Year to you, the reader."
                    },
                    {
                        "username": "space_invader",
                        "content": "The last day of 2023. Expectation: easy. Actual: hard.\\n\\nalright... "
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Ending off the year with a hard problem I see!\\nGreat way to brace ourselves for what us gonna be a nightmare of an year. Thanks leetcode.\\n"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Important line is walk over EVERY non-obstacle square exactly ONCE."
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Why this solution giving me Stackoverflow error please help me\\n\\n ```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int m=grid.length, n=grid[0].length, count=0, res=0, starti=0, startj=0;\\n        boolean[][] vis = new boolean[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1|| grid[i][j] == 0 || grid[i][j] == 2)\\n                    count++;\\n                if(grid[i][j] == 1){\\n                    starti = i;\\n                    startj = j;\\n                }\\n            }\\n        }\\n\\n        return dfs(starti, startj, count,grid,0, res, vis);\\n        \\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int dfs(int i, int j, int count, int[][] grid, int curCount, int res, boolean[][] vis){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1) return 0;\\n        \\n        \\n        vis[i][j] = true;\\n        curCount++;\\n\\n        if(grid[i][j] == 2){\\n            if(curCount == count) return 1;\\n            return 0;\\n        }\\n\\n        int totalPaths = 0;\\n        for(int k=0; k<4; k++){\\n            totalPaths += dfs(i+dir[k][0] , j+dir[k][1], count, grid, curCount, res,vis);\\n        }\\n\\n        curCount--;\\n        vis[i][j] = false;\\n\\n        return totalPaths;\\n        \\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Also return 0 if you have already visited the same cell in the first if condition\\nif(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1 || vis[i][j]) return 0;\\n\\nHope it helps"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Happy to end the year by solving a hard problem :)"
                    },
                    {
                        "username": "arajshow",
                        "content": "Using DFS is optimized solution or we need to think more."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "na that\\'s brute force there\\'s apparently a bitmask dp solution too"
                    }
                ]
            },
            {
                "id": 1735206,
                "content": [
                    {
                        "username": "maxfadeev",
                        "content": "Happy New Year! Wish everyone peace, happiness and prosperity in the coming year!"
                    },
                    {
                        "username": "Tipra",
                        "content": "Dunno why a straightforward implementation of backtracking would be categorized as hard. Usually I\\'m unable to solve hard questions so kinda weird."
                    },
                    {
                        "username": "dsyz17d2",
                        "content": "I wish everyone happy nd peaceful upcoming year!"
                    },
                    {
                        "username": "Jaiff",
                        "content": "LONG LIVE LEETCODE! and Happy New Year to you, the reader."
                    },
                    {
                        "username": "space_invader",
                        "content": "The last day of 2023. Expectation: easy. Actual: hard.\\n\\nalright... "
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Ending off the year with a hard problem I see!\\nGreat way to brace ourselves for what us gonna be a nightmare of an year. Thanks leetcode.\\n"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Important line is walk over EVERY non-obstacle square exactly ONCE."
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Why this solution giving me Stackoverflow error please help me\\n\\n ```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int m=grid.length, n=grid[0].length, count=0, res=0, starti=0, startj=0;\\n        boolean[][] vis = new boolean[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1|| grid[i][j] == 0 || grid[i][j] == 2)\\n                    count++;\\n                if(grid[i][j] == 1){\\n                    starti = i;\\n                    startj = j;\\n                }\\n            }\\n        }\\n\\n        return dfs(starti, startj, count,grid,0, res, vis);\\n        \\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int dfs(int i, int j, int count, int[][] grid, int curCount, int res, boolean[][] vis){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1) return 0;\\n        \\n        \\n        vis[i][j] = true;\\n        curCount++;\\n\\n        if(grid[i][j] == 2){\\n            if(curCount == count) return 1;\\n            return 0;\\n        }\\n\\n        int totalPaths = 0;\\n        for(int k=0; k<4; k++){\\n            totalPaths += dfs(i+dir[k][0] , j+dir[k][1], count, grid, curCount, res,vis);\\n        }\\n\\n        curCount--;\\n        vis[i][j] = false;\\n\\n        return totalPaths;\\n        \\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Also return 0 if you have already visited the same cell in the first if condition\\nif(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1 || vis[i][j]) return 0;\\n\\nHope it helps"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Happy to end the year by solving a hard problem :)"
                    },
                    {
                        "username": "arajshow",
                        "content": "Using DFS is optimized solution or we need to think more."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "na that\\'s brute force there\\'s apparently a bitmask dp solution too"
                    }
                ]
            },
            {
                "id": 1735149,
                "content": [
                    {
                        "username": "maxfadeev",
                        "content": "Happy New Year! Wish everyone peace, happiness and prosperity in the coming year!"
                    },
                    {
                        "username": "Tipra",
                        "content": "Dunno why a straightforward implementation of backtracking would be categorized as hard. Usually I\\'m unable to solve hard questions so kinda weird."
                    },
                    {
                        "username": "dsyz17d2",
                        "content": "I wish everyone happy nd peaceful upcoming year!"
                    },
                    {
                        "username": "Jaiff",
                        "content": "LONG LIVE LEETCODE! and Happy New Year to you, the reader."
                    },
                    {
                        "username": "space_invader",
                        "content": "The last day of 2023. Expectation: easy. Actual: hard.\\n\\nalright... "
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Ending off the year with a hard problem I see!\\nGreat way to brace ourselves for what us gonna be a nightmare of an year. Thanks leetcode.\\n"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Important line is walk over EVERY non-obstacle square exactly ONCE."
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Why this solution giving me Stackoverflow error please help me\\n\\n ```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int m=grid.length, n=grid[0].length, count=0, res=0, starti=0, startj=0;\\n        boolean[][] vis = new boolean[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1|| grid[i][j] == 0 || grid[i][j] == 2)\\n                    count++;\\n                if(grid[i][j] == 1){\\n                    starti = i;\\n                    startj = j;\\n                }\\n            }\\n        }\\n\\n        return dfs(starti, startj, count,grid,0, res, vis);\\n        \\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int dfs(int i, int j, int count, int[][] grid, int curCount, int res, boolean[][] vis){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1) return 0;\\n        \\n        \\n        vis[i][j] = true;\\n        curCount++;\\n\\n        if(grid[i][j] == 2){\\n            if(curCount == count) return 1;\\n            return 0;\\n        }\\n\\n        int totalPaths = 0;\\n        for(int k=0; k<4; k++){\\n            totalPaths += dfs(i+dir[k][0] , j+dir[k][1], count, grid, curCount, res,vis);\\n        }\\n\\n        curCount--;\\n        vis[i][j] = false;\\n\\n        return totalPaths;\\n        \\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Also return 0 if you have already visited the same cell in the first if condition\\nif(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1 || vis[i][j]) return 0;\\n\\nHope it helps"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Happy to end the year by solving a hard problem :)"
                    },
                    {
                        "username": "arajshow",
                        "content": "Using DFS is optimized solution or we need to think more."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "na that\\'s brute force there\\'s apparently a bitmask dp solution too"
                    }
                ]
            },
            {
                "id": 1735135,
                "content": [
                    {
                        "username": "maxfadeev",
                        "content": "Happy New Year! Wish everyone peace, happiness and prosperity in the coming year!"
                    },
                    {
                        "username": "Tipra",
                        "content": "Dunno why a straightforward implementation of backtracking would be categorized as hard. Usually I\\'m unable to solve hard questions so kinda weird."
                    },
                    {
                        "username": "dsyz17d2",
                        "content": "I wish everyone happy nd peaceful upcoming year!"
                    },
                    {
                        "username": "Jaiff",
                        "content": "LONG LIVE LEETCODE! and Happy New Year to you, the reader."
                    },
                    {
                        "username": "space_invader",
                        "content": "The last day of 2023. Expectation: easy. Actual: hard.\\n\\nalright... "
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Ending off the year with a hard problem I see!\\nGreat way to brace ourselves for what us gonna be a nightmare of an year. Thanks leetcode.\\n"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Important line is walk over EVERY non-obstacle square exactly ONCE."
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Why this solution giving me Stackoverflow error please help me\\n\\n ```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int m=grid.length, n=grid[0].length, count=0, res=0, starti=0, startj=0;\\n        boolean[][] vis = new boolean[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1|| grid[i][j] == 0 || grid[i][j] == 2)\\n                    count++;\\n                if(grid[i][j] == 1){\\n                    starti = i;\\n                    startj = j;\\n                }\\n            }\\n        }\\n\\n        return dfs(starti, startj, count,grid,0, res, vis);\\n        \\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int dfs(int i, int j, int count, int[][] grid, int curCount, int res, boolean[][] vis){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1) return 0;\\n        \\n        \\n        vis[i][j] = true;\\n        curCount++;\\n\\n        if(grid[i][j] == 2){\\n            if(curCount == count) return 1;\\n            return 0;\\n        }\\n\\n        int totalPaths = 0;\\n        for(int k=0; k<4; k++){\\n            totalPaths += dfs(i+dir[k][0] , j+dir[k][1], count, grid, curCount, res,vis);\\n        }\\n\\n        curCount--;\\n        vis[i][j] = false;\\n\\n        return totalPaths;\\n        \\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Also return 0 if you have already visited the same cell in the first if condition\\nif(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1 || vis[i][j]) return 0;\\n\\nHope it helps"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Happy to end the year by solving a hard problem :)"
                    },
                    {
                        "username": "arajshow",
                        "content": "Using DFS is optimized solution or we need to think more."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "na that\\'s brute force there\\'s apparently a bitmask dp solution too"
                    }
                ]
            },
            {
                "id": 1735108,
                "content": [
                    {
                        "username": "maxfadeev",
                        "content": "Happy New Year! Wish everyone peace, happiness and prosperity in the coming year!"
                    },
                    {
                        "username": "Tipra",
                        "content": "Dunno why a straightforward implementation of backtracking would be categorized as hard. Usually I\\'m unable to solve hard questions so kinda weird."
                    },
                    {
                        "username": "dsyz17d2",
                        "content": "I wish everyone happy nd peaceful upcoming year!"
                    },
                    {
                        "username": "Jaiff",
                        "content": "LONG LIVE LEETCODE! and Happy New Year to you, the reader."
                    },
                    {
                        "username": "space_invader",
                        "content": "The last day of 2023. Expectation: easy. Actual: hard.\\n\\nalright... "
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Ending off the year with a hard problem I see!\\nGreat way to brace ourselves for what us gonna be a nightmare of an year. Thanks leetcode.\\n"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Important line is walk over EVERY non-obstacle square exactly ONCE."
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Why this solution giving me Stackoverflow error please help me\\n\\n ```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int m=grid.length, n=grid[0].length, count=0, res=0, starti=0, startj=0;\\n        boolean[][] vis = new boolean[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1|| grid[i][j] == 0 || grid[i][j] == 2)\\n                    count++;\\n                if(grid[i][j] == 1){\\n                    starti = i;\\n                    startj = j;\\n                }\\n            }\\n        }\\n\\n        return dfs(starti, startj, count,grid,0, res, vis);\\n        \\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int dfs(int i, int j, int count, int[][] grid, int curCount, int res, boolean[][] vis){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1) return 0;\\n        \\n        \\n        vis[i][j] = true;\\n        curCount++;\\n\\n        if(grid[i][j] == 2){\\n            if(curCount == count) return 1;\\n            return 0;\\n        }\\n\\n        int totalPaths = 0;\\n        for(int k=0; k<4; k++){\\n            totalPaths += dfs(i+dir[k][0] , j+dir[k][1], count, grid, curCount, res,vis);\\n        }\\n\\n        curCount--;\\n        vis[i][j] = false;\\n\\n        return totalPaths;\\n        \\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Also return 0 if you have already visited the same cell in the first if condition\\nif(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1 || vis[i][j]) return 0;\\n\\nHope it helps"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Happy to end the year by solving a hard problem :)"
                    },
                    {
                        "username": "arajshow",
                        "content": "Using DFS is optimized solution or we need to think more."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "na that\\'s brute force there\\'s apparently a bitmask dp solution too"
                    }
                ]
            },
            {
                "id": 1735089,
                "content": [
                    {
                        "username": "maxfadeev",
                        "content": "Happy New Year! Wish everyone peace, happiness and prosperity in the coming year!"
                    },
                    {
                        "username": "Tipra",
                        "content": "Dunno why a straightforward implementation of backtracking would be categorized as hard. Usually I\\'m unable to solve hard questions so kinda weird."
                    },
                    {
                        "username": "dsyz17d2",
                        "content": "I wish everyone happy nd peaceful upcoming year!"
                    },
                    {
                        "username": "Jaiff",
                        "content": "LONG LIVE LEETCODE! and Happy New Year to you, the reader."
                    },
                    {
                        "username": "space_invader",
                        "content": "The last day of 2023. Expectation: easy. Actual: hard.\\n\\nalright... "
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Ending off the year with a hard problem I see!\\nGreat way to brace ourselves for what us gonna be a nightmare of an year. Thanks leetcode.\\n"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Important line is walk over EVERY non-obstacle square exactly ONCE."
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Why this solution giving me Stackoverflow error please help me\\n\\n ```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int m=grid.length, n=grid[0].length, count=0, res=0, starti=0, startj=0;\\n        boolean[][] vis = new boolean[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1|| grid[i][j] == 0 || grid[i][j] == 2)\\n                    count++;\\n                if(grid[i][j] == 1){\\n                    starti = i;\\n                    startj = j;\\n                }\\n            }\\n        }\\n\\n        return dfs(starti, startj, count,grid,0, res, vis);\\n        \\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int dfs(int i, int j, int count, int[][] grid, int curCount, int res, boolean[][] vis){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1) return 0;\\n        \\n        \\n        vis[i][j] = true;\\n        curCount++;\\n\\n        if(grid[i][j] == 2){\\n            if(curCount == count) return 1;\\n            return 0;\\n        }\\n\\n        int totalPaths = 0;\\n        for(int k=0; k<4; k++){\\n            totalPaths += dfs(i+dir[k][0] , j+dir[k][1], count, grid, curCount, res,vis);\\n        }\\n\\n        curCount--;\\n        vis[i][j] = false;\\n\\n        return totalPaths;\\n        \\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Also return 0 if you have already visited the same cell in the first if condition\\nif(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1 || vis[i][j]) return 0;\\n\\nHope it helps"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Happy to end the year by solving a hard problem :)"
                    },
                    {
                        "username": "arajshow",
                        "content": "Using DFS is optimized solution or we need to think more."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "na that\\'s brute force there\\'s apparently a bitmask dp solution too"
                    }
                ]
            },
            {
                "id": 1735082,
                "content": [
                    {
                        "username": "maxfadeev",
                        "content": "Happy New Year! Wish everyone peace, happiness and prosperity in the coming year!"
                    },
                    {
                        "username": "Tipra",
                        "content": "Dunno why a straightforward implementation of backtracking would be categorized as hard. Usually I\\'m unable to solve hard questions so kinda weird."
                    },
                    {
                        "username": "dsyz17d2",
                        "content": "I wish everyone happy nd peaceful upcoming year!"
                    },
                    {
                        "username": "Jaiff",
                        "content": "LONG LIVE LEETCODE! and Happy New Year to you, the reader."
                    },
                    {
                        "username": "space_invader",
                        "content": "The last day of 2023. Expectation: easy. Actual: hard.\\n\\nalright... "
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Ending off the year with a hard problem I see!\\nGreat way to brace ourselves for what us gonna be a nightmare of an year. Thanks leetcode.\\n"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Important line is walk over EVERY non-obstacle square exactly ONCE."
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Why this solution giving me Stackoverflow error please help me\\n\\n ```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int m=grid.length, n=grid[0].length, count=0, res=0, starti=0, startj=0;\\n        boolean[][] vis = new boolean[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1|| grid[i][j] == 0 || grid[i][j] == 2)\\n                    count++;\\n                if(grid[i][j] == 1){\\n                    starti = i;\\n                    startj = j;\\n                }\\n            }\\n        }\\n\\n        return dfs(starti, startj, count,grid,0, res, vis);\\n        \\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int dfs(int i, int j, int count, int[][] grid, int curCount, int res, boolean[][] vis){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1) return 0;\\n        \\n        \\n        vis[i][j] = true;\\n        curCount++;\\n\\n        if(grid[i][j] == 2){\\n            if(curCount == count) return 1;\\n            return 0;\\n        }\\n\\n        int totalPaths = 0;\\n        for(int k=0; k<4; k++){\\n            totalPaths += dfs(i+dir[k][0] , j+dir[k][1], count, grid, curCount, res,vis);\\n        }\\n\\n        curCount--;\\n        vis[i][j] = false;\\n\\n        return totalPaths;\\n        \\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Also return 0 if you have already visited the same cell in the first if condition\\nif(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1 || vis[i][j]) return 0;\\n\\nHope it helps"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Happy to end the year by solving a hard problem :)"
                    },
                    {
                        "username": "arajshow",
                        "content": "Using DFS is optimized solution or we need to think more."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "na that\\'s brute force there\\'s apparently a bitmask dp solution too"
                    }
                ]
            },
            {
                "id": 1735040,
                "content": [
                    {
                        "username": "maxfadeev",
                        "content": "Happy New Year! Wish everyone peace, happiness and prosperity in the coming year!"
                    },
                    {
                        "username": "Tipra",
                        "content": "Dunno why a straightforward implementation of backtracking would be categorized as hard. Usually I\\'m unable to solve hard questions so kinda weird."
                    },
                    {
                        "username": "dsyz17d2",
                        "content": "I wish everyone happy nd peaceful upcoming year!"
                    },
                    {
                        "username": "Jaiff",
                        "content": "LONG LIVE LEETCODE! and Happy New Year to you, the reader."
                    },
                    {
                        "username": "space_invader",
                        "content": "The last day of 2023. Expectation: easy. Actual: hard.\\n\\nalright... "
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Ending off the year with a hard problem I see!\\nGreat way to brace ourselves for what us gonna be a nightmare of an year. Thanks leetcode.\\n"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Important line is walk over EVERY non-obstacle square exactly ONCE."
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Why this solution giving me Stackoverflow error please help me\\n\\n ```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int m=grid.length, n=grid[0].length, count=0, res=0, starti=0, startj=0;\\n        boolean[][] vis = new boolean[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1|| grid[i][j] == 0 || grid[i][j] == 2)\\n                    count++;\\n                if(grid[i][j] == 1){\\n                    starti = i;\\n                    startj = j;\\n                }\\n            }\\n        }\\n\\n        return dfs(starti, startj, count,grid,0, res, vis);\\n        \\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int dfs(int i, int j, int count, int[][] grid, int curCount, int res, boolean[][] vis){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1) return 0;\\n        \\n        \\n        vis[i][j] = true;\\n        curCount++;\\n\\n        if(grid[i][j] == 2){\\n            if(curCount == count) return 1;\\n            return 0;\\n        }\\n\\n        int totalPaths = 0;\\n        for(int k=0; k<4; k++){\\n            totalPaths += dfs(i+dir[k][0] , j+dir[k][1], count, grid, curCount, res,vis);\\n        }\\n\\n        curCount--;\\n        vis[i][j] = false;\\n\\n        return totalPaths;\\n        \\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Also return 0 if you have already visited the same cell in the first if condition\\nif(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1 || vis[i][j]) return 0;\\n\\nHope it helps"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Happy to end the year by solving a hard problem :)"
                    },
                    {
                        "username": "arajshow",
                        "content": "Using DFS is optimized solution or we need to think more."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "na that\\'s brute force there\\'s apparently a bitmask dp solution too"
                    }
                ]
            },
            {
                "id": 1735016,
                "content": [
                    {
                        "username": "maxfadeev",
                        "content": "Happy New Year! Wish everyone peace, happiness and prosperity in the coming year!"
                    },
                    {
                        "username": "Tipra",
                        "content": "Dunno why a straightforward implementation of backtracking would be categorized as hard. Usually I\\'m unable to solve hard questions so kinda weird."
                    },
                    {
                        "username": "dsyz17d2",
                        "content": "I wish everyone happy nd peaceful upcoming year!"
                    },
                    {
                        "username": "Jaiff",
                        "content": "LONG LIVE LEETCODE! and Happy New Year to you, the reader."
                    },
                    {
                        "username": "space_invader",
                        "content": "The last day of 2023. Expectation: easy. Actual: hard.\\n\\nalright... "
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Ending off the year with a hard problem I see!\\nGreat way to brace ourselves for what us gonna be a nightmare of an year. Thanks leetcode.\\n"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Important line is walk over EVERY non-obstacle square exactly ONCE."
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Why this solution giving me Stackoverflow error please help me\\n\\n ```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        int m=grid.length, n=grid[0].length, count=0, res=0, starti=0, startj=0;\\n        boolean[][] vis = new boolean[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1|| grid[i][j] == 0 || grid[i][j] == 2)\\n                    count++;\\n                if(grid[i][j] == 1){\\n                    starti = i;\\n                    startj = j;\\n                }\\n            }\\n        }\\n\\n        return dfs(starti, startj, count,grid,0, res, vis);\\n        \\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int dfs(int i, int j, int count, int[][] grid, int curCount, int res, boolean[][] vis){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1) return 0;\\n        \\n        \\n        vis[i][j] = true;\\n        curCount++;\\n\\n        if(grid[i][j] == 2){\\n            if(curCount == count) return 1;\\n            return 0;\\n        }\\n\\n        int totalPaths = 0;\\n        for(int k=0; k<4; k++){\\n            totalPaths += dfs(i+dir[k][0] , j+dir[k][1], count, grid, curCount, res,vis);\\n        }\\n\\n        curCount--;\\n        vis[i][j] = false;\\n\\n        return totalPaths;\\n        \\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Also return 0 if you have already visited the same cell in the first if condition\\nif(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] == -1 || vis[i][j]) return 0;\\n\\nHope it helps"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "Happy to end the year by solving a hard problem :)"
                    },
                    {
                        "username": "arajshow",
                        "content": "Using DFS is optimized solution or we need to think more."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "na that\\'s brute force there\\'s apparently a bitmask dp solution too"
                    }
                ]
            },
            {
                "id": 1734968,
                "content": [
                    {
                        "username": "CyberRedPanda",
                        "content": "Why is this tagged as a shell problem?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Happy New Year Everyone \\uD83D\\uDE4C\\uD83D\\uDE4C"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Is there any other way other than brutforce dfs ?\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Happy new year :D \\nHint: \\n- We have to visit all tile before return 1 ( i spent 1 hour to figure it out) \\n- Use dfs backtracking \\n"
                    },
                    {
                        "username": "shakticse",
                        "content": "Can someone explain if a BFS solution exists for this problem .. if yes , then how to implement it , if no , then why ?\\nThanks in advance !"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Hello [@shakti s](/shakticse) Yes ofc bfs will also works, there is several solution that use BFS here,\n\nhere is one example: \nhttps://leetcode.com/problems/unique-paths-iii/solutions/1556623/python-localized-bfs-solution/?q=bfs&orderBy=most_relevant"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "By looking at the Acceptance Rate, can\\'t imagine how I feel if I don\\'t get it at the first time."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Looks like the problem could be solved using recursion, but in case of a big grid it will take too much time and memory."
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "So leetcode wants us to play some game on last day of year \\uD83D\\uDE80\\uD83D\\uDE80"
                    },
                    {
                        "username": "agrinzewich",
                        "content": "```\\nclass Solution {\\n\\n    private int w, h, totalCells;\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        this.w = grid.length;\\n        this.h = grid[0].length;\\n\\n        int[] startCell = new int[2];\\n        int cellsToVisit = 0;\\n\\n        for (int i = 0; i < w; i++) {\\n            for (int j = 0; j < h; j++) {\\n                if (grid[i][j] == 1) {\\n                    startCell[0] = i;\\n                    startCell[1] = j;\\n                } else if (grid[i][j] == 0) {\\n                    cellsToVisit++;\\n                }\\n            }\\n        }\\n\\n        return dfs(grid, startCell[0], startCell[1], cellsToVisit+1, new HashSet<>());\\n\\n    }\\n\\n    public int dfs(int[][] grid, int i, int j, int cellsToVisit, Set<String> visited) {\\n        if ( i < 0||j < 0||i >= grid.length || j >= grid[i].length) {\\n            return 0;\\n        }\\n        \\n        if (grid[i][j] == -1 || visited.contains(i+\" \"+j)) {\\n            return 0;\\n        }\\n\\n\\n        if (grid[i][j] == 2) {// finishing cell \\n            if(visited.size() == cellsToVisit) { // traversed all the cells without obstacles\\n                return 1;\\n            }\\n\\n            return 0;\\n        }\\n\\n        visited.add(i+\" \"+j);\\n\\n        int pathsCount = 0;\\n        pathsCount += dfs(grid, i+1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i-1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j+1, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j-1, cellsToVisit, new HashSet<>(visited));\\n        return pathsCount;\\n    }\\n\\n   \\n      \\n}\\n```"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "Msey",
                        "content": "Can anyone explain the time complexity? I set a \"counter\" variable in my brute-force solution and it seems like O(4 ^ n), but some people say that it\\'s O(3 ^ N) in the same approaches"
                    },
                    {
                        "username": "Msey",
                        "content": "[@charonme](/charonme) thanks"
                    },
                    {
                        "username": "charonme",
                        "content": "you can move in 4 directions only at the first move (if you are positioned with 4 free spaces around you), but after that you can only move to at most 3 new positions, not backwards because you can only visit each free tile once."
                    }
                ]
            },
            {
                "id": 1734952,
                "content": [
                    {
                        "username": "CyberRedPanda",
                        "content": "Why is this tagged as a shell problem?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Happy New Year Everyone \\uD83D\\uDE4C\\uD83D\\uDE4C"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Is there any other way other than brutforce dfs ?\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Happy new year :D \\nHint: \\n- We have to visit all tile before return 1 ( i spent 1 hour to figure it out) \\n- Use dfs backtracking \\n"
                    },
                    {
                        "username": "shakticse",
                        "content": "Can someone explain if a BFS solution exists for this problem .. if yes , then how to implement it , if no , then why ?\\nThanks in advance !"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Hello [@shakti s](/shakticse) Yes ofc bfs will also works, there is several solution that use BFS here,\n\nhere is one example: \nhttps://leetcode.com/problems/unique-paths-iii/solutions/1556623/python-localized-bfs-solution/?q=bfs&orderBy=most_relevant"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "By looking at the Acceptance Rate, can\\'t imagine how I feel if I don\\'t get it at the first time."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Looks like the problem could be solved using recursion, but in case of a big grid it will take too much time and memory."
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "So leetcode wants us to play some game on last day of year \\uD83D\\uDE80\\uD83D\\uDE80"
                    },
                    {
                        "username": "agrinzewich",
                        "content": "```\\nclass Solution {\\n\\n    private int w, h, totalCells;\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        this.w = grid.length;\\n        this.h = grid[0].length;\\n\\n        int[] startCell = new int[2];\\n        int cellsToVisit = 0;\\n\\n        for (int i = 0; i < w; i++) {\\n            for (int j = 0; j < h; j++) {\\n                if (grid[i][j] == 1) {\\n                    startCell[0] = i;\\n                    startCell[1] = j;\\n                } else if (grid[i][j] == 0) {\\n                    cellsToVisit++;\\n                }\\n            }\\n        }\\n\\n        return dfs(grid, startCell[0], startCell[1], cellsToVisit+1, new HashSet<>());\\n\\n    }\\n\\n    public int dfs(int[][] grid, int i, int j, int cellsToVisit, Set<String> visited) {\\n        if ( i < 0||j < 0||i >= grid.length || j >= grid[i].length) {\\n            return 0;\\n        }\\n        \\n        if (grid[i][j] == -1 || visited.contains(i+\" \"+j)) {\\n            return 0;\\n        }\\n\\n\\n        if (grid[i][j] == 2) {// finishing cell \\n            if(visited.size() == cellsToVisit) { // traversed all the cells without obstacles\\n                return 1;\\n            }\\n\\n            return 0;\\n        }\\n\\n        visited.add(i+\" \"+j);\\n\\n        int pathsCount = 0;\\n        pathsCount += dfs(grid, i+1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i-1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j+1, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j-1, cellsToVisit, new HashSet<>(visited));\\n        return pathsCount;\\n    }\\n\\n   \\n      \\n}\\n```"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "Msey",
                        "content": "Can anyone explain the time complexity? I set a \"counter\" variable in my brute-force solution and it seems like O(4 ^ n), but some people say that it\\'s O(3 ^ N) in the same approaches"
                    },
                    {
                        "username": "Msey",
                        "content": "[@charonme](/charonme) thanks"
                    },
                    {
                        "username": "charonme",
                        "content": "you can move in 4 directions only at the first move (if you are positioned with 4 free spaces around you), but after that you can only move to at most 3 new positions, not backwards because you can only visit each free tile once."
                    }
                ]
            },
            {
                "id": 1734943,
                "content": [
                    {
                        "username": "CyberRedPanda",
                        "content": "Why is this tagged as a shell problem?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Happy New Year Everyone \\uD83D\\uDE4C\\uD83D\\uDE4C"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Is there any other way other than brutforce dfs ?\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Happy new year :D \\nHint: \\n- We have to visit all tile before return 1 ( i spent 1 hour to figure it out) \\n- Use dfs backtracking \\n"
                    },
                    {
                        "username": "shakticse",
                        "content": "Can someone explain if a BFS solution exists for this problem .. if yes , then how to implement it , if no , then why ?\\nThanks in advance !"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Hello [@shakti s](/shakticse) Yes ofc bfs will also works, there is several solution that use BFS here,\n\nhere is one example: \nhttps://leetcode.com/problems/unique-paths-iii/solutions/1556623/python-localized-bfs-solution/?q=bfs&orderBy=most_relevant"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "By looking at the Acceptance Rate, can\\'t imagine how I feel if I don\\'t get it at the first time."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Looks like the problem could be solved using recursion, but in case of a big grid it will take too much time and memory."
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "So leetcode wants us to play some game on last day of year \\uD83D\\uDE80\\uD83D\\uDE80"
                    },
                    {
                        "username": "agrinzewich",
                        "content": "```\\nclass Solution {\\n\\n    private int w, h, totalCells;\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        this.w = grid.length;\\n        this.h = grid[0].length;\\n\\n        int[] startCell = new int[2];\\n        int cellsToVisit = 0;\\n\\n        for (int i = 0; i < w; i++) {\\n            for (int j = 0; j < h; j++) {\\n                if (grid[i][j] == 1) {\\n                    startCell[0] = i;\\n                    startCell[1] = j;\\n                } else if (grid[i][j] == 0) {\\n                    cellsToVisit++;\\n                }\\n            }\\n        }\\n\\n        return dfs(grid, startCell[0], startCell[1], cellsToVisit+1, new HashSet<>());\\n\\n    }\\n\\n    public int dfs(int[][] grid, int i, int j, int cellsToVisit, Set<String> visited) {\\n        if ( i < 0||j < 0||i >= grid.length || j >= grid[i].length) {\\n            return 0;\\n        }\\n        \\n        if (grid[i][j] == -1 || visited.contains(i+\" \"+j)) {\\n            return 0;\\n        }\\n\\n\\n        if (grid[i][j] == 2) {// finishing cell \\n            if(visited.size() == cellsToVisit) { // traversed all the cells without obstacles\\n                return 1;\\n            }\\n\\n            return 0;\\n        }\\n\\n        visited.add(i+\" \"+j);\\n\\n        int pathsCount = 0;\\n        pathsCount += dfs(grid, i+1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i-1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j+1, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j-1, cellsToVisit, new HashSet<>(visited));\\n        return pathsCount;\\n    }\\n\\n   \\n      \\n}\\n```"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "Msey",
                        "content": "Can anyone explain the time complexity? I set a \"counter\" variable in my brute-force solution and it seems like O(4 ^ n), but some people say that it\\'s O(3 ^ N) in the same approaches"
                    },
                    {
                        "username": "Msey",
                        "content": "[@charonme](/charonme) thanks"
                    },
                    {
                        "username": "charonme",
                        "content": "you can move in 4 directions only at the first move (if you are positioned with 4 free spaces around you), but after that you can only move to at most 3 new positions, not backwards because you can only visit each free tile once."
                    }
                ]
            },
            {
                "id": 1734936,
                "content": [
                    {
                        "username": "CyberRedPanda",
                        "content": "Why is this tagged as a shell problem?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Happy New Year Everyone \\uD83D\\uDE4C\\uD83D\\uDE4C"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Is there any other way other than brutforce dfs ?\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Happy new year :D \\nHint: \\n- We have to visit all tile before return 1 ( i spent 1 hour to figure it out) \\n- Use dfs backtracking \\n"
                    },
                    {
                        "username": "shakticse",
                        "content": "Can someone explain if a BFS solution exists for this problem .. if yes , then how to implement it , if no , then why ?\\nThanks in advance !"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Hello [@shakti s](/shakticse) Yes ofc bfs will also works, there is several solution that use BFS here,\n\nhere is one example: \nhttps://leetcode.com/problems/unique-paths-iii/solutions/1556623/python-localized-bfs-solution/?q=bfs&orderBy=most_relevant"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "By looking at the Acceptance Rate, can\\'t imagine how I feel if I don\\'t get it at the first time."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Looks like the problem could be solved using recursion, but in case of a big grid it will take too much time and memory."
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "So leetcode wants us to play some game on last day of year \\uD83D\\uDE80\\uD83D\\uDE80"
                    },
                    {
                        "username": "agrinzewich",
                        "content": "```\\nclass Solution {\\n\\n    private int w, h, totalCells;\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        this.w = grid.length;\\n        this.h = grid[0].length;\\n\\n        int[] startCell = new int[2];\\n        int cellsToVisit = 0;\\n\\n        for (int i = 0; i < w; i++) {\\n            for (int j = 0; j < h; j++) {\\n                if (grid[i][j] == 1) {\\n                    startCell[0] = i;\\n                    startCell[1] = j;\\n                } else if (grid[i][j] == 0) {\\n                    cellsToVisit++;\\n                }\\n            }\\n        }\\n\\n        return dfs(grid, startCell[0], startCell[1], cellsToVisit+1, new HashSet<>());\\n\\n    }\\n\\n    public int dfs(int[][] grid, int i, int j, int cellsToVisit, Set<String> visited) {\\n        if ( i < 0||j < 0||i >= grid.length || j >= grid[i].length) {\\n            return 0;\\n        }\\n        \\n        if (grid[i][j] == -1 || visited.contains(i+\" \"+j)) {\\n            return 0;\\n        }\\n\\n\\n        if (grid[i][j] == 2) {// finishing cell \\n            if(visited.size() == cellsToVisit) { // traversed all the cells without obstacles\\n                return 1;\\n            }\\n\\n            return 0;\\n        }\\n\\n        visited.add(i+\" \"+j);\\n\\n        int pathsCount = 0;\\n        pathsCount += dfs(grid, i+1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i-1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j+1, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j-1, cellsToVisit, new HashSet<>(visited));\\n        return pathsCount;\\n    }\\n\\n   \\n      \\n}\\n```"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "Msey",
                        "content": "Can anyone explain the time complexity? I set a \"counter\" variable in my brute-force solution and it seems like O(4 ^ n), but some people say that it\\'s O(3 ^ N) in the same approaches"
                    },
                    {
                        "username": "Msey",
                        "content": "[@charonme](/charonme) thanks"
                    },
                    {
                        "username": "charonme",
                        "content": "you can move in 4 directions only at the first move (if you are positioned with 4 free spaces around you), but after that you can only move to at most 3 new positions, not backwards because you can only visit each free tile once."
                    }
                ]
            },
            {
                "id": 1734930,
                "content": [
                    {
                        "username": "CyberRedPanda",
                        "content": "Why is this tagged as a shell problem?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Happy New Year Everyone \\uD83D\\uDE4C\\uD83D\\uDE4C"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Is there any other way other than brutforce dfs ?\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Happy new year :D \\nHint: \\n- We have to visit all tile before return 1 ( i spent 1 hour to figure it out) \\n- Use dfs backtracking \\n"
                    },
                    {
                        "username": "shakticse",
                        "content": "Can someone explain if a BFS solution exists for this problem .. if yes , then how to implement it , if no , then why ?\\nThanks in advance !"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Hello [@shakti s](/shakticse) Yes ofc bfs will also works, there is several solution that use BFS here,\n\nhere is one example: \nhttps://leetcode.com/problems/unique-paths-iii/solutions/1556623/python-localized-bfs-solution/?q=bfs&orderBy=most_relevant"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "By looking at the Acceptance Rate, can\\'t imagine how I feel if I don\\'t get it at the first time."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Looks like the problem could be solved using recursion, but in case of a big grid it will take too much time and memory."
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "So leetcode wants us to play some game on last day of year \\uD83D\\uDE80\\uD83D\\uDE80"
                    },
                    {
                        "username": "agrinzewich",
                        "content": "```\\nclass Solution {\\n\\n    private int w, h, totalCells;\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        this.w = grid.length;\\n        this.h = grid[0].length;\\n\\n        int[] startCell = new int[2];\\n        int cellsToVisit = 0;\\n\\n        for (int i = 0; i < w; i++) {\\n            for (int j = 0; j < h; j++) {\\n                if (grid[i][j] == 1) {\\n                    startCell[0] = i;\\n                    startCell[1] = j;\\n                } else if (grid[i][j] == 0) {\\n                    cellsToVisit++;\\n                }\\n            }\\n        }\\n\\n        return dfs(grid, startCell[0], startCell[1], cellsToVisit+1, new HashSet<>());\\n\\n    }\\n\\n    public int dfs(int[][] grid, int i, int j, int cellsToVisit, Set<String> visited) {\\n        if ( i < 0||j < 0||i >= grid.length || j >= grid[i].length) {\\n            return 0;\\n        }\\n        \\n        if (grid[i][j] == -1 || visited.contains(i+\" \"+j)) {\\n            return 0;\\n        }\\n\\n\\n        if (grid[i][j] == 2) {// finishing cell \\n            if(visited.size() == cellsToVisit) { // traversed all the cells without obstacles\\n                return 1;\\n            }\\n\\n            return 0;\\n        }\\n\\n        visited.add(i+\" \"+j);\\n\\n        int pathsCount = 0;\\n        pathsCount += dfs(grid, i+1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i-1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j+1, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j-1, cellsToVisit, new HashSet<>(visited));\\n        return pathsCount;\\n    }\\n\\n   \\n      \\n}\\n```"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "Msey",
                        "content": "Can anyone explain the time complexity? I set a \"counter\" variable in my brute-force solution and it seems like O(4 ^ n), but some people say that it\\'s O(3 ^ N) in the same approaches"
                    },
                    {
                        "username": "Msey",
                        "content": "[@charonme](/charonme) thanks"
                    },
                    {
                        "username": "charonme",
                        "content": "you can move in 4 directions only at the first move (if you are positioned with 4 free spaces around you), but after that you can only move to at most 3 new positions, not backwards because you can only visit each free tile once."
                    }
                ]
            },
            {
                "id": 1734923,
                "content": [
                    {
                        "username": "CyberRedPanda",
                        "content": "Why is this tagged as a shell problem?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Happy New Year Everyone \\uD83D\\uDE4C\\uD83D\\uDE4C"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Is there any other way other than brutforce dfs ?\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Happy new year :D \\nHint: \\n- We have to visit all tile before return 1 ( i spent 1 hour to figure it out) \\n- Use dfs backtracking \\n"
                    },
                    {
                        "username": "shakticse",
                        "content": "Can someone explain if a BFS solution exists for this problem .. if yes , then how to implement it , if no , then why ?\\nThanks in advance !"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Hello [@shakti s](/shakticse) Yes ofc bfs will also works, there is several solution that use BFS here,\n\nhere is one example: \nhttps://leetcode.com/problems/unique-paths-iii/solutions/1556623/python-localized-bfs-solution/?q=bfs&orderBy=most_relevant"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "By looking at the Acceptance Rate, can\\'t imagine how I feel if I don\\'t get it at the first time."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Looks like the problem could be solved using recursion, but in case of a big grid it will take too much time and memory."
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "So leetcode wants us to play some game on last day of year \\uD83D\\uDE80\\uD83D\\uDE80"
                    },
                    {
                        "username": "agrinzewich",
                        "content": "```\\nclass Solution {\\n\\n    private int w, h, totalCells;\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        this.w = grid.length;\\n        this.h = grid[0].length;\\n\\n        int[] startCell = new int[2];\\n        int cellsToVisit = 0;\\n\\n        for (int i = 0; i < w; i++) {\\n            for (int j = 0; j < h; j++) {\\n                if (grid[i][j] == 1) {\\n                    startCell[0] = i;\\n                    startCell[1] = j;\\n                } else if (grid[i][j] == 0) {\\n                    cellsToVisit++;\\n                }\\n            }\\n        }\\n\\n        return dfs(grid, startCell[0], startCell[1], cellsToVisit+1, new HashSet<>());\\n\\n    }\\n\\n    public int dfs(int[][] grid, int i, int j, int cellsToVisit, Set<String> visited) {\\n        if ( i < 0||j < 0||i >= grid.length || j >= grid[i].length) {\\n            return 0;\\n        }\\n        \\n        if (grid[i][j] == -1 || visited.contains(i+\" \"+j)) {\\n            return 0;\\n        }\\n\\n\\n        if (grid[i][j] == 2) {// finishing cell \\n            if(visited.size() == cellsToVisit) { // traversed all the cells without obstacles\\n                return 1;\\n            }\\n\\n            return 0;\\n        }\\n\\n        visited.add(i+\" \"+j);\\n\\n        int pathsCount = 0;\\n        pathsCount += dfs(grid, i+1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i-1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j+1, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j-1, cellsToVisit, new HashSet<>(visited));\\n        return pathsCount;\\n    }\\n\\n   \\n      \\n}\\n```"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "Msey",
                        "content": "Can anyone explain the time complexity? I set a \"counter\" variable in my brute-force solution and it seems like O(4 ^ n), but some people say that it\\'s O(3 ^ N) in the same approaches"
                    },
                    {
                        "username": "Msey",
                        "content": "[@charonme](/charonme) thanks"
                    },
                    {
                        "username": "charonme",
                        "content": "you can move in 4 directions only at the first move (if you are positioned with 4 free spaces around you), but after that you can only move to at most 3 new positions, not backwards because you can only visit each free tile once."
                    }
                ]
            },
            {
                "id": 1734830,
                "content": [
                    {
                        "username": "CyberRedPanda",
                        "content": "Why is this tagged as a shell problem?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Happy New Year Everyone \\uD83D\\uDE4C\\uD83D\\uDE4C"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Is there any other way other than brutforce dfs ?\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Happy new year :D \\nHint: \\n- We have to visit all tile before return 1 ( i spent 1 hour to figure it out) \\n- Use dfs backtracking \\n"
                    },
                    {
                        "username": "shakticse",
                        "content": "Can someone explain if a BFS solution exists for this problem .. if yes , then how to implement it , if no , then why ?\\nThanks in advance !"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Hello [@shakti s](/shakticse) Yes ofc bfs will also works, there is several solution that use BFS here,\n\nhere is one example: \nhttps://leetcode.com/problems/unique-paths-iii/solutions/1556623/python-localized-bfs-solution/?q=bfs&orderBy=most_relevant"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "By looking at the Acceptance Rate, can\\'t imagine how I feel if I don\\'t get it at the first time."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Looks like the problem could be solved using recursion, but in case of a big grid it will take too much time and memory."
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "So leetcode wants us to play some game on last day of year \\uD83D\\uDE80\\uD83D\\uDE80"
                    },
                    {
                        "username": "agrinzewich",
                        "content": "```\\nclass Solution {\\n\\n    private int w, h, totalCells;\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        this.w = grid.length;\\n        this.h = grid[0].length;\\n\\n        int[] startCell = new int[2];\\n        int cellsToVisit = 0;\\n\\n        for (int i = 0; i < w; i++) {\\n            for (int j = 0; j < h; j++) {\\n                if (grid[i][j] == 1) {\\n                    startCell[0] = i;\\n                    startCell[1] = j;\\n                } else if (grid[i][j] == 0) {\\n                    cellsToVisit++;\\n                }\\n            }\\n        }\\n\\n        return dfs(grid, startCell[0], startCell[1], cellsToVisit+1, new HashSet<>());\\n\\n    }\\n\\n    public int dfs(int[][] grid, int i, int j, int cellsToVisit, Set<String> visited) {\\n        if ( i < 0||j < 0||i >= grid.length || j >= grid[i].length) {\\n            return 0;\\n        }\\n        \\n        if (grid[i][j] == -1 || visited.contains(i+\" \"+j)) {\\n            return 0;\\n        }\\n\\n\\n        if (grid[i][j] == 2) {// finishing cell \\n            if(visited.size() == cellsToVisit) { // traversed all the cells without obstacles\\n                return 1;\\n            }\\n\\n            return 0;\\n        }\\n\\n        visited.add(i+\" \"+j);\\n\\n        int pathsCount = 0;\\n        pathsCount += dfs(grid, i+1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i-1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j+1, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j-1, cellsToVisit, new HashSet<>(visited));\\n        return pathsCount;\\n    }\\n\\n   \\n      \\n}\\n```"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "Msey",
                        "content": "Can anyone explain the time complexity? I set a \"counter\" variable in my brute-force solution and it seems like O(4 ^ n), but some people say that it\\'s O(3 ^ N) in the same approaches"
                    },
                    {
                        "username": "Msey",
                        "content": "[@charonme](/charonme) thanks"
                    },
                    {
                        "username": "charonme",
                        "content": "you can move in 4 directions only at the first move (if you are positioned with 4 free spaces around you), but after that you can only move to at most 3 new positions, not backwards because you can only visit each free tile once."
                    }
                ]
            },
            {
                "id": 1734818,
                "content": [
                    {
                        "username": "CyberRedPanda",
                        "content": "Why is this tagged as a shell problem?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Happy New Year Everyone \\uD83D\\uDE4C\\uD83D\\uDE4C"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Is there any other way other than brutforce dfs ?\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Happy new year :D \\nHint: \\n- We have to visit all tile before return 1 ( i spent 1 hour to figure it out) \\n- Use dfs backtracking \\n"
                    },
                    {
                        "username": "shakticse",
                        "content": "Can someone explain if a BFS solution exists for this problem .. if yes , then how to implement it , if no , then why ?\\nThanks in advance !"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Hello [@shakti s](/shakticse) Yes ofc bfs will also works, there is several solution that use BFS here,\n\nhere is one example: \nhttps://leetcode.com/problems/unique-paths-iii/solutions/1556623/python-localized-bfs-solution/?q=bfs&orderBy=most_relevant"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "By looking at the Acceptance Rate, can\\'t imagine how I feel if I don\\'t get it at the first time."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Looks like the problem could be solved using recursion, but in case of a big grid it will take too much time and memory."
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "So leetcode wants us to play some game on last day of year \\uD83D\\uDE80\\uD83D\\uDE80"
                    },
                    {
                        "username": "agrinzewich",
                        "content": "```\\nclass Solution {\\n\\n    private int w, h, totalCells;\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        this.w = grid.length;\\n        this.h = grid[0].length;\\n\\n        int[] startCell = new int[2];\\n        int cellsToVisit = 0;\\n\\n        for (int i = 0; i < w; i++) {\\n            for (int j = 0; j < h; j++) {\\n                if (grid[i][j] == 1) {\\n                    startCell[0] = i;\\n                    startCell[1] = j;\\n                } else if (grid[i][j] == 0) {\\n                    cellsToVisit++;\\n                }\\n            }\\n        }\\n\\n        return dfs(grid, startCell[0], startCell[1], cellsToVisit+1, new HashSet<>());\\n\\n    }\\n\\n    public int dfs(int[][] grid, int i, int j, int cellsToVisit, Set<String> visited) {\\n        if ( i < 0||j < 0||i >= grid.length || j >= grid[i].length) {\\n            return 0;\\n        }\\n        \\n        if (grid[i][j] == -1 || visited.contains(i+\" \"+j)) {\\n            return 0;\\n        }\\n\\n\\n        if (grid[i][j] == 2) {// finishing cell \\n            if(visited.size() == cellsToVisit) { // traversed all the cells without obstacles\\n                return 1;\\n            }\\n\\n            return 0;\\n        }\\n\\n        visited.add(i+\" \"+j);\\n\\n        int pathsCount = 0;\\n        pathsCount += dfs(grid, i+1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i-1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j+1, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j-1, cellsToVisit, new HashSet<>(visited));\\n        return pathsCount;\\n    }\\n\\n   \\n      \\n}\\n```"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "Msey",
                        "content": "Can anyone explain the time complexity? I set a \"counter\" variable in my brute-force solution and it seems like O(4 ^ n), but some people say that it\\'s O(3 ^ N) in the same approaches"
                    },
                    {
                        "username": "Msey",
                        "content": "[@charonme](/charonme) thanks"
                    },
                    {
                        "username": "charonme",
                        "content": "you can move in 4 directions only at the first move (if you are positioned with 4 free spaces around you), but after that you can only move to at most 3 new positions, not backwards because you can only visit each free tile once."
                    }
                ]
            },
            {
                "id": 1725311,
                "content": [
                    {
                        "username": "CyberRedPanda",
                        "content": "Why is this tagged as a shell problem?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Happy New Year Everyone \\uD83D\\uDE4C\\uD83D\\uDE4C"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Is there any other way other than brutforce dfs ?\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Happy new year :D \\nHint: \\n- We have to visit all tile before return 1 ( i spent 1 hour to figure it out) \\n- Use dfs backtracking \\n"
                    },
                    {
                        "username": "shakticse",
                        "content": "Can someone explain if a BFS solution exists for this problem .. if yes , then how to implement it , if no , then why ?\\nThanks in advance !"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Hello [@shakti s](/shakticse) Yes ofc bfs will also works, there is several solution that use BFS here,\n\nhere is one example: \nhttps://leetcode.com/problems/unique-paths-iii/solutions/1556623/python-localized-bfs-solution/?q=bfs&orderBy=most_relevant"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "By looking at the Acceptance Rate, can\\'t imagine how I feel if I don\\'t get it at the first time."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Looks like the problem could be solved using recursion, but in case of a big grid it will take too much time and memory."
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "So leetcode wants us to play some game on last day of year \\uD83D\\uDE80\\uD83D\\uDE80"
                    },
                    {
                        "username": "agrinzewich",
                        "content": "```\\nclass Solution {\\n\\n    private int w, h, totalCells;\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        this.w = grid.length;\\n        this.h = grid[0].length;\\n\\n        int[] startCell = new int[2];\\n        int cellsToVisit = 0;\\n\\n        for (int i = 0; i < w; i++) {\\n            for (int j = 0; j < h; j++) {\\n                if (grid[i][j] == 1) {\\n                    startCell[0] = i;\\n                    startCell[1] = j;\\n                } else if (grid[i][j] == 0) {\\n                    cellsToVisit++;\\n                }\\n            }\\n        }\\n\\n        return dfs(grid, startCell[0], startCell[1], cellsToVisit+1, new HashSet<>());\\n\\n    }\\n\\n    public int dfs(int[][] grid, int i, int j, int cellsToVisit, Set<String> visited) {\\n        if ( i < 0||j < 0||i >= grid.length || j >= grid[i].length) {\\n            return 0;\\n        }\\n        \\n        if (grid[i][j] == -1 || visited.contains(i+\" \"+j)) {\\n            return 0;\\n        }\\n\\n\\n        if (grid[i][j] == 2) {// finishing cell \\n            if(visited.size() == cellsToVisit) { // traversed all the cells without obstacles\\n                return 1;\\n            }\\n\\n            return 0;\\n        }\\n\\n        visited.add(i+\" \"+j);\\n\\n        int pathsCount = 0;\\n        pathsCount += dfs(grid, i+1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i-1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j+1, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j-1, cellsToVisit, new HashSet<>(visited));\\n        return pathsCount;\\n    }\\n\\n   \\n      \\n}\\n```"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "Msey",
                        "content": "Can anyone explain the time complexity? I set a \"counter\" variable in my brute-force solution and it seems like O(4 ^ n), but some people say that it\\'s O(3 ^ N) in the same approaches"
                    },
                    {
                        "username": "Msey",
                        "content": "[@charonme](/charonme) thanks"
                    },
                    {
                        "username": "charonme",
                        "content": "you can move in 4 directions only at the first move (if you are positioned with 4 free spaces around you), but after that you can only move to at most 3 new positions, not backwards because you can only visit each free tile once."
                    }
                ]
            },
            {
                "id": 1711056,
                "content": [
                    {
                        "username": "CyberRedPanda",
                        "content": "Why is this tagged as a shell problem?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Happy New Year Everyone \\uD83D\\uDE4C\\uD83D\\uDE4C"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Is there any other way other than brutforce dfs ?\\n"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Happy new year :D \\nHint: \\n- We have to visit all tile before return 1 ( i spent 1 hour to figure it out) \\n- Use dfs backtracking \\n"
                    },
                    {
                        "username": "shakticse",
                        "content": "Can someone explain if a BFS solution exists for this problem .. if yes , then how to implement it , if no , then why ?\\nThanks in advance !"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Hello [@shakti s](/shakticse) Yes ofc bfs will also works, there is several solution that use BFS here,\n\nhere is one example: \nhttps://leetcode.com/problems/unique-paths-iii/solutions/1556623/python-localized-bfs-solution/?q=bfs&orderBy=most_relevant"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "By looking at the Acceptance Rate, can\\'t imagine how I feel if I don\\'t get it at the first time."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Looks like the problem could be solved using recursion, but in case of a big grid it will take too much time and memory."
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "So leetcode wants us to play some game on last day of year \\uD83D\\uDE80\\uD83D\\uDE80"
                    },
                    {
                        "username": "agrinzewich",
                        "content": "```\\nclass Solution {\\n\\n    private int w, h, totalCells;\\n\\n    public int uniquePathsIII(int[][] grid) {\\n        this.w = grid.length;\\n        this.h = grid[0].length;\\n\\n        int[] startCell = new int[2];\\n        int cellsToVisit = 0;\\n\\n        for (int i = 0; i < w; i++) {\\n            for (int j = 0; j < h; j++) {\\n                if (grid[i][j] == 1) {\\n                    startCell[0] = i;\\n                    startCell[1] = j;\\n                } else if (grid[i][j] == 0) {\\n                    cellsToVisit++;\\n                }\\n            }\\n        }\\n\\n        return dfs(grid, startCell[0], startCell[1], cellsToVisit+1, new HashSet<>());\\n\\n    }\\n\\n    public int dfs(int[][] grid, int i, int j, int cellsToVisit, Set<String> visited) {\\n        if ( i < 0||j < 0||i >= grid.length || j >= grid[i].length) {\\n            return 0;\\n        }\\n        \\n        if (grid[i][j] == -1 || visited.contains(i+\" \"+j)) {\\n            return 0;\\n        }\\n\\n\\n        if (grid[i][j] == 2) {// finishing cell \\n            if(visited.size() == cellsToVisit) { // traversed all the cells without obstacles\\n                return 1;\\n            }\\n\\n            return 0;\\n        }\\n\\n        visited.add(i+\" \"+j);\\n\\n        int pathsCount = 0;\\n        pathsCount += dfs(grid, i+1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i-1, j, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j+1, cellsToVisit, new HashSet<>(visited));\\n        pathsCount += dfs(grid, i, j-1, cellsToVisit, new HashSet<>(visited));\\n        return pathsCount;\\n    }\\n\\n   \\n      \\n}\\n```"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "Msey",
                        "content": "Can anyone explain the time complexity? I set a \"counter\" variable in my brute-force solution and it seems like O(4 ^ n), but some people say that it\\'s O(3 ^ N) in the same approaches"
                    },
                    {
                        "username": "Msey",
                        "content": "[@charonme](/charonme) thanks"
                    },
                    {
                        "username": "charonme",
                        "content": "you can move in 4 directions only at the first move (if you are positioned with 4 free spaces around you), but after that you can only move to at most 3 new positions, not backwards because you can only visit each free tile once."
                    }
                ]
            }
        ]
    }
]