[
    {
        "title": "Subarray With Elements Greater Than Varying Threshold",
        "question_content": "You are given an integer array nums and an integer threshold.\nFind any subarray of nums of length k such that every element in the subarray is greater than threshold / k.\nReturn the size of any such subarray. If there is no such subarray, return -1.\nA subarray is a contiguous non-empty sequence of elements within an array.\n&nbsp;\nExample 1:\n\nInput: nums = [1,3,4,3,1], threshold = 6\nOutput: 3\nExplanation: The subarray [3,4,3] has a size of 3, and every element is greater than 6 / 3 = 2.\nNote that this is the only valid subarray.\n\nExample 2:\n\nInput: nums = [6,5,6,5,8], threshold = 7\nOutput: 1\nExplanation: The subarray [8] has a size of 1, and 8 > 7 / 1 = 7. So 1 is returned.\nNote that the subarray [6,5] has a size of 2, and every element is greater than 7 / 2 = 3.5. \nSimilarly, the subarrays [6,5,6], [6,5,6,5], [6,5,6,5,8] also satisfy the given conditions.\nTherefore, 2, 3, 4, or 5 may also be returned.\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i], threshold <= 109",
        "solutions": [
            {
                "id": 2259285,
                "title": "c-o-n-solution-using-monotonic-stacks",
                "content": "The question says that we need to find any such subarray which has the property that all the elements in that subarray are `> threshold / k`.  \\n\\nThe gist of the above statement is that we need to find the subarray minimum and we need to expand that subarray as max as possible so as to have as less `threshold / k` as possible.\\n\\n### Solution Idea\\nWe consider the current element as the minimum element and try to find out the prev smaller and next smaller elements. Once we know that, we can calculate the max. subarray length K which will allow us to get least `threshold / k`. \\n\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& a, int threshold) {\\n        int n = a.size();\\n        \\n        vector<int> stk;                            // used as a stack\\n        vector<int> nextS(n, -1), prevS(n, -1);     // used for storing next and previous smaller elements\\n                \\n        // firstly, let\\'s find out the next smaller elements\\n        for(int i = 0; i < n; i++) {\\n            while (!stk.empty() && a[i] < a[stk.back()]) {\\n                nextS[stk.back()] = i;\\n                stk.pop_back();\\n            }\\n            stk.push_back(i);\\n        }\\n\\n        // clear up our stack\\n        stk.clear();\\n        \\n        // now, let\\'s find out the previous smaller elements for each index\\n        for(int i = n-1; i >= 0; i--) {\\n            while (!stk.empty() && a[i] < a[stk.back()]) {\\n                prevS[stk.back()] = i;\\n                stk.pop_back();\\n            }\\n            stk.push_back(i);\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            int left = prevS[i];                            // left boundary\\n            int right = nextS[i] == -1 ? n : nextS[i];      // right boundary\\n            \\n            int len = right - left - 1;                     // length of subarray formed with a[i] as minimum\\n            \\n            if (a[i] > (threshold / ((double) len)))\\n                return len;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n\\n**TC: O(N)**\\n\\n**Similar questions**\\n\\n1. https://leetcode.com/problems/next-greater-element-i/\\n2. https://leetcode.com/problems/largest-rectangle-in-histogram/\\n3. https://leetcode.com/problems/sum-of-subarray-minimums/",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& a, int threshold) {\\n        int n = a.size();\\n        \\n        vector<int> stk;                            // used as a stack\\n        vector<int> nextS(n, -1), prevS(n, -1);     // used for storing next and previous smaller elements\\n                \\n        // firstly, let\\'s find out the next smaller elements\\n        for(int i = 0; i < n; i++) {\\n            while (!stk.empty() && a[i] < a[stk.back()]) {\\n                nextS[stk.back()] = i;\\n                stk.pop_back();\\n            }\\n            stk.push_back(i);\\n        }\\n\\n        // clear up our stack\\n        stk.clear();\\n        \\n        // now, let\\'s find out the previous smaller elements for each index\\n        for(int i = n-1; i >= 0; i--) {\\n            while (!stk.empty() && a[i] < a[stk.back()]) {\\n                prevS[stk.back()] = i;\\n                stk.pop_back();\\n            }\\n            stk.push_back(i);\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            int left = prevS[i];                            // left boundary\\n            int right = nextS[i] == -1 ? n : nextS[i];      // right boundary\\n            \\n            int len = right - left - 1;                     // length of subarray formed with a[i] as minimum\\n            \\n            if (a[i] > (threshold / ((double) len)))\\n                return len;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259305,
                "title": "full-explanation-c-python-java-code-with-comment-stack-o-n",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\nThe question says that we need to find any such subarray which has the property that all the elements in that **subarray are > threshold / k**.\\n\\nThe gist of the above statement is that we need to find the subarray minimum and we need to expand that subarray as max as possible so as to have as less threshold / k as possible.\\n\\n**Approch:-**\\n* We consider the current element as the minimum element and try to find out the prev smaller and next smaller elements.\\n* Once we know that, we can calculate the max.\\n* subarray length K which will allow us to get least threshold / k.\\n**Please Upvote if you like**\\n**Time Complaxity :-** `O(N)`\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        vector<long long> lr(n, n), rl(n, -1);\\n        \\n        vector<int> s;\\n        for(int i = 0; i < n; ++i) {\\n            while(!s.empty() and nums[i] < nums[s.back()]) {\\n                lr[s.back()] = i;\\n                s.pop_back();\\n            }\\n            s.push_back(i);\\n        }\\n        s.clear();\\n        for(int i = n - 1; ~i; --i) {\\n            while(!s.empty() and nums[i] < nums[s.back()]) {\\n                rl[s.back()] = i;\\n                s.pop_back();\\n            }\\n            s.push_back(i);\\n        }\\n        \\n        for(int i = 0; i < n; ++i) {\\n            long long length = lr[i] - rl[i] - 1;\\n            if(1LL * nums[i] * length > threshold) return length;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n// please upvote if you like\\n```\\n\\n**Python:-**\\n```\\ndef validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        nums = [0] + nums + [0]\\n        stack = [0]\\n        for i in range(1,len(nums)):\\n            while nums[i] < nums[stack[-1]]:\\n                tmp = nums[stack.pop()]\\n                if tmp > threshold / (i - stack[-1] - 1):\\n                    return i - stack[-1] - 1\\n            stack.append(i)\\n        return -1\\n```\\n\\n**Java:-**\\n\\n1. If the minimun value of A min(A) > threshold / len(A) then A is one of the answer.\\n2. If any element x <= threshold / len(A), A cannot be the answer. We call x a bad point.\\n3. A can be divide into segments by these bad points.\\n\\nWe can find those segments and recursively validate each one.\\n**Code:-**\\n```\\npublic int validSubarraySize(int[] nums, int threshold) {\\n        int n = nums.length;\\n        return dfs(nums, 0, n - 1, threshold);\\n    }\\n    \\n    private int dfs(int[] nums, int l, int r, int t) {\\n        if(l > r) {\\n            return -1;\\n        }\\n        if(l == r) {\\n            return nums[l] > t ? 1 : -1;\\n        }\\n        \\n        int n = r - l + 1;\\n        for(int i = l; i <= r; ) {\\n            if(nums[i] <= t / n) {\\n                i++;\\n                continue;\\n            }\\n            int j = i;\\n            int min = Integer.MAX_VALUE;\\n            while(i <= r && nums[i] > t / n) {\\n                min = Math.min(min, nums[i]);\\n                i++;\\n            }\\n            \\n            if(min > t / (i - j)) {\\n                return i - j;\\n            }\\n            \\n            int res = dfs(nums, j, i - 1, t);\\n                \\n            if(res != -1) {\\n                return res;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n```\\n **For FuN \\uD83D\\uDE01\\uD83E\\uDD23\\uD83E\\uDD23**\\n![image](https://assets.leetcode.com/users/images/f8a18dcc-34bf-41c9-9527-554ce214bfd3_1657385854.0471494.png)\\n\\n![image](https://assets.leetcode.com/users/images/86ef909a-a3d6-41df-9cbe-3ba742da0d9e_1657390846.6467373.png)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        vector<long long> lr(n, n), rl(n, -1);\\n        \\n        vector<int> s;\\n        for(int i = 0; i < n; ++i) {\\n            while(!s.empty() and nums[i] < nums[s.back()]) {\\n                lr[s.back()] = i;\\n                s.pop_back();\\n            }\\n            s.push_back(i);\\n        }\\n        s.clear();\\n        for(int i = n - 1; ~i; --i) {\\n            while(!s.empty() and nums[i] < nums[s.back()]) {\\n                rl[s.back()] = i;\\n                s.pop_back();\\n            }\\n            s.push_back(i);\\n        }\\n        \\n        for(int i = 0; i < n; ++i) {\\n            long long length = lr[i] - rl[i] - 1;\\n            if(1LL * nums[i] * length > threshold) return length;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n// please upvote if you like\\n```\n```\\ndef validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        nums = [0] + nums + [0]\\n        stack = [0]\\n        for i in range(1,len(nums)):\\n            while nums[i] < nums[stack[-1]]:\\n                tmp = nums[stack.pop()]\\n                if tmp > threshold / (i - stack[-1] - 1):\\n                    return i - stack[-1] - 1\\n            stack.append(i)\\n        return -1\\n```\n```\\npublic int validSubarraySize(int[] nums, int threshold) {\\n        int n = nums.length;\\n        return dfs(nums, 0, n - 1, threshold);\\n    }\\n    \\n    private int dfs(int[] nums, int l, int r, int t) {\\n        if(l > r) {\\n            return -1;\\n        }\\n        if(l == r) {\\n            return nums[l] > t ? 1 : -1;\\n        }\\n        \\n        int n = r - l + 1;\\n        for(int i = l; i <= r; ) {\\n            if(nums[i] <= t / n) {\\n                i++;\\n                continue;\\n            }\\n            int j = i;\\n            int min = Integer.MAX_VALUE;\\n            while(i <= r && nums[i] > t / n) {\\n                min = Math.min(min, nums[i]);\\n                i++;\\n            }\\n            \\n            if(min > t / (i - j)) {\\n                return i - j;\\n            }\\n            \\n            int res = dfs(nums, j, i - 1, t);\\n                \\n            if(res != -1) {\\n                return res;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259557,
                "title": "monostack",
                "content": "This problem screams monostrack; figuring out the logic is quite difficult nonetheless.\\n\\nI came up with the initial solution below, and afterwards I realized that we can simplify it.\\n\\n#### Simplified Solution\\nThis is an equivalent to the initial solution below, take a look at the explanations there.\\n\\nHere, we avoid the conversion and use indexes instead of counters to get the subarray size.\\n\\n**C++**\\n```cpp\\nint validSubarraySize(vector<int>& nums, int threshold) {\\n    vector<int> st;\\n    nums.push_back(0);\\n    for (int i = 0; i < nums.size(); ++i) {\\n        while (!st.empty() && nums[i] < nums[st.back()]) {\\n            int val = nums[st.back()]; st.pop_back();\\n            int j = st.empty() ? -1 : st.back();\\n            if (val > threshold / (i - j - 1))\\n                return i - j - 1;\\n        }\\n        st.push_back(i);\\n    }\\n    return -1;\\n}\\n```\\n\\n#### Initial Solution\\nFirst, we calculate `k` for each element `nums[i]`, so that `threshold / k < nums[i]`. That tells us the minimum size of the subarray that includes `nums[i]`.\\n\\nThen, we build a monotonically decreasing stack using these subarray sizes. For each size, we also store the count of smaller and equal sizes before it (including the current one).\\n\\nAs we insert a new size into the stack, we remove all smaller sizes and accumulate the count `cnt`. If the count is equal or greater than a size, we found our subarray.\\n\\nThis example shows the stack before inserting the last size. The count for size `6` is also `6`, thus we found a valid subarray. Note that subarray of size `8` would be also valid.\\n\\n![image](https://assets.leetcode.com/users/images/24e2d9a6-c53f-4175-88fb-2407052790dd_1657482687.8966675.png)\\n\\n**C++**\\n```cpp\\nint validSubarraySize(vector<int>& nums, int threshold) {\\n    for (int i = 0; i < nums.size(); ++i)\\n        nums[i] = threshold / nums[i] + 1;\\n    nums.push_back(INT_MAX);\\n    vector<array<int, 2>> st;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        int cnt = 0;\\n        while (!st.empty() && st.back()[0] <= nums[i]) {\\n            cnt += st.back()[1];\\n            if (cnt >= st.back()[0])\\n                return cnt;\\n            st.pop_back();\\n        }\\n        st.push_back({nums[i], cnt + 1});\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint validSubarraySize(vector<int>& nums, int threshold) {\\n    vector<int> st;\\n    nums.push_back(0);\\n    for (int i = 0; i < nums.size(); ++i) {\\n        while (!st.empty() && nums[i] < nums[st.back()]) {\\n            int val = nums[st.back()]; st.pop_back();\\n            int j = st.empty() ? -1 : st.back();\\n            if (val > threshold / (i - j - 1))\\n                return i - j - 1;\\n        }\\n        st.push_back(i);\\n    }\\n    return -1;\\n}\\n```\n```cpp\\nint validSubarraySize(vector<int>& nums, int threshold) {\\n    for (int i = 0; i < nums.size(); ++i)\\n        nums[i] = threshold / nums[i] + 1;\\n    nums.push_back(INT_MAX);\\n    vector<array<int, 2>> st;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        int cnt = 0;\\n        while (!st.empty() && st.back()[0] <= nums[i]) {\\n            cnt += st.back()[1];\\n            if (cnt >= st.back()[0])\\n                return cnt;\\n            st.pop_back();\\n        }\\n        st.push_back({nums[i], cnt + 1});\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2259188,
                "title": "python-sorting-dsu-w-size-no-stack-detailed-explanation",
                "content": "* First Observation:\\n    * For each value `nums[i]`, if it is in a valid subarray, then its length `k` should larger than `threshold / nums[i]`. (By simply rewriting the inequality `nums[i] > threshold / k`)\\n    * Take the first test case as example. `nums = [1, 3, 4, 3, 1]`, so the subarray length that contains every `nums[i]` should **strictly** larger than `[6, 2, 1.5, 2, 6]`, i.e. **at least** `[7, 3, 2, 3, 7]`. (This can be simply calculated by `threshold // nums[i] + 1`)\\n\\n* Second Observation:\\n    * Let `ks` be the smallest valid `k`\\'s that we calculated above. If there is a valid subarray contains index `i`, then its length should be at least `ks[i]`. Consider the following algorithm:\\n        * Sort the indicies `i` by `ks[i]`.\\n        * Let `X` be an empty set.\\n        * Start from the index `i` that has smallest `k`. In every loop:\\n            * Add `i` into `X`.\\n            * Check if there is a continuous subarray with length `>= ks[i]` that can be comprised of the indices from `X`.\\n\\n    * Take the first test case as example. In this case, `ks = [7, 3, 2, 3, 7]`. The list is 0-based. \\n        * In first loop, `i = 2` and `ks[i] = 2`. Add index `2` into the valid indices. `X = {2}` and we cannot find a continuous subarray with length `>= 2`\\n        * In second loop, `i = 1` and `ks[i] = 3`. Add index `1` into the valid indices. `X = {1, 2}` and we cannot find a continuous subarray with length `>= 3`\\n        * In third loop, `i = 3` and `ks[i] = 3`. Add index `3` into the valid indices. `X = {1, 2, 3}` and we can find a continuous subarray with length of 3. So we find a valid answer.\\n\\n* Third Observation:\\n    * How to find the current continuous subarray efficiently? We can easily find that every time when we insert a new index `i` into `X`, we only care about the subarray that can be extended from index `i`. Because it is the only place that can cause a new \"connection\".\\n    * Consider the following implementation of DSU. We use a dictionary `sizes` to maintain the size of every group. When we merge `y` into `x`, we update `sizes` by adding `sizes[y]` into `sizes[x]`, and vice versa.\\n```\\nclass UnionFind:\\n    def __init__(self):\\n        self.parents = {}\\n        self.sizes = {}\\n\\n    def find_parent(self, x):\\n        if self.parents[x] != x:\\n            self.parents[x] = self.find_parent(self.parents[x])\\n        return self.parents[x]\\n\\n    def union(self, x, y):\\n        x, y = self.find_parent(x), self.find_parent(y)\\n        if x == y:\\n            return \\n        if self.sizes[x] > self.sizes[y]:\\n            self.parents[y] = x\\n            self.sizes[x] += self.sizes[y]\\n        else:\\n            self.parents[x] = y\\n            self.sizes[y] += self.sizes[x]\\n```\\n\\n* Total time complexity: `O(N log N)`: `O(N log N)` for sorting, `O(N)` for `N` DSU operations (`O(1)` each by implenting path compression and union by size). Can be improved more if using bucket sort.\\n\\n* My code:\\n\\n```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        \\n        N = len(nums)\\n        ks = []\\n        for idx, num in enumerate(nums):\\n            ks.append((threshold // num + 1, idx))\\n        ks.sort()\\n        \\n        class UnionFind:\\n            def __init__(self):\\n                self.parents = {}\\n                self.sizes = {}\\n                \\n            def insert(self, x):\\n                if x not in self.parents:\\n                    self.parents[x] = x\\n                    self.sizes[x] = 1\\n                \\n            def find_parent(self, x):\\n                if self.parents[x] != x:\\n                    self.parents[x] = self.find_parent(self.parents[x])\\n                return self.parents[x]\\n            \\n            def union(self, x, y):\\n                x, y = self.find_parent(x), self.find_parent(y)\\n                if x == y:\\n                    return \\n                if self.sizes[x] > self.sizes[y]:\\n                    self.parents[y] = x\\n                    self.sizes[x] += self.sizes[y]\\n                else:\\n                    self.parents[x] = y\\n                    self.sizes[y] += self.sizes[x]\\n        \\n        uf = UnionFind()\\n        for k, idx in ks:\\n            uf.insert(idx)\\n            if idx - 1 in uf.parents:\\n                uf.union(idx, idx - 1)\\n            if idx + 1 in uf.parents:\\n                uf.union(idx, idx + 1)\\n            if uf.sizes[uf.find_parent(idx)] >= k:\\n                return k\\n        return -1\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self):\\n        self.parents = {}\\n        self.sizes = {}\\n\\n    def find_parent(self, x):\\n        if self.parents[x] != x:\\n            self.parents[x] = self.find_parent(self.parents[x])\\n        return self.parents[x]\\n\\n    def union(self, x, y):\\n        x, y = self.find_parent(x), self.find_parent(y)\\n        if x == y:\\n            return \\n        if self.sizes[x] > self.sizes[y]:\\n            self.parents[y] = x\\n            self.sizes[x] += self.sizes[y]\\n        else:\\n            self.parents[x] = y\\n            self.sizes[y] += self.sizes[x]\\n```\n```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        \\n        N = len(nums)\\n        ks = []\\n        for idx, num in enumerate(nums):\\n            ks.append((threshold // num + 1, idx))\\n        ks.sort()\\n        \\n        class UnionFind:\\n            def __init__(self):\\n                self.parents = {}\\n                self.sizes = {}\\n                \\n            def insert(self, x):\\n                if x not in self.parents:\\n                    self.parents[x] = x\\n                    self.sizes[x] = 1\\n                \\n            def find_parent(self, x):\\n                if self.parents[x] != x:\\n                    self.parents[x] = self.find_parent(self.parents[x])\\n                return self.parents[x]\\n            \\n            def union(self, x, y):\\n                x, y = self.find_parent(x), self.find_parent(y)\\n                if x == y:\\n                    return \\n                if self.sizes[x] > self.sizes[y]:\\n                    self.parents[y] = x\\n                    self.sizes[x] += self.sizes[y]\\n                else:\\n                    self.parents[x] = y\\n                    self.sizes[y] += self.sizes[x]\\n        \\n        uf = UnionFind()\\n        for k, idx in ks:\\n            uf.insert(idx)\\n            if idx - 1 in uf.parents:\\n                uf.union(idx, idx - 1)\\n            if idx + 1 in uf.parents:\\n                uf.union(idx, idx + 1)\\n            if uf.sizes[uf.find_parent(idx)] >= k:\\n                return k\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260048,
                "title": "java-solution-using-monotonic-stack-with-explanation",
                "content": "Approach:\\n1. Create two arrays for next smaller and previous smaller for every elements of nums\\n2. Use next smaller element stack approach to fill the arrays.\\n3. Find the length of every element of nums from its previous smaller to next smaller.\\n4. divide the threshold by length and if it is greater than quotient return length else -1.\\n\\n```\\nclass Solution {\\n    public int validSubarraySize(int[] nums, int threshold) {\\n        int n = nums.length;\\n        int[] next_small = new int[n];\\n        int[] prev_small = new int[n];\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(0);\\n        Arrays.fill(next_small, n);\\n        Arrays.fill(prev_small, -1);\\n        for(int i=1;i<n;i++){\\n            while(!stack.isEmpty() && nums[stack.peek()] >= nums[i]){\\n                stack.pop();\\n            }    \\n            if(stack.size()!=0){\\n                prev_small[i] = stack.peek();\\n            }\\n            stack.push(i);\\n        }\\n        stack = new Stack<>();\\n        stack.push(n-1);\\n        for(int i=n-2;i>=0;i--){\\n            while(!stack.isEmpty() && nums[stack.peek()] >= nums[i]){\\n                stack.pop();\\n            }    \\n            if(stack.size()!=0){\\n                next_small[i] = stack.peek();\\n            }\\n            stack.push(i);\\n        }\\n        for(int i=0;i<n;i++){\\n            int len = next_small[i] - prev_small[i] - 1;\\n            if(threshold/(double)len < nums[i]){\\n                return len;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nupvote if you like.",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int validSubarraySize(int[] nums, int threshold) {\\n        int n = nums.length;\\n        int[] next_small = new int[n];\\n        int[] prev_small = new int[n];\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(0);\\n        Arrays.fill(next_small, n);\\n        Arrays.fill(prev_small, -1);\\n        for(int i=1;i<n;i++){\\n            while(!stack.isEmpty() && nums[stack.peek()] >= nums[i]){\\n                stack.pop();\\n            }    \\n            if(stack.size()!=0){\\n                prev_small[i] = stack.peek();\\n            }\\n            stack.push(i);\\n        }\\n        stack = new Stack<>();\\n        stack.push(n-1);\\n        for(int i=n-2;i>=0;i--){\\n            while(!stack.isEmpty() && nums[stack.peek()] >= nums[i]){\\n                stack.pop();\\n            }    \\n            if(stack.size()!=0){\\n                next_small[i] = stack.peek();\\n            }\\n            stack.push(i);\\n        }\\n        for(int i=0;i<n;i++){\\n            int len = next_small[i] - prev_small[i] - 1;\\n            if(threshold/(double)len < nums[i]){\\n                return len;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259360,
                "title": "python-stack-no-left-right",
                "content": "Very similar to 1856. The subarray is kind of determined by the minimum element while we want to extend our subarray as longer as possible.\\nhttps://leetcode.com/problems/maximum-subarray-min-product/\\n```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        nums = [0] + nums + [0]\\n        stack = [0]\\n        for i in range(1,len(nums)):\\n            while nums[i] < nums[stack[-1]]:\\n                tmp = nums[stack.pop()]\\n                if tmp > threshold / (i - stack[-1] - 1):\\n                    return i - stack[-1] - 1\\n            stack.append(i)\\n        return -1\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        nums = [0] + nums + [0]\\n        stack = [0]\\n        for i in range(1,len(nums)):\\n            while nums[i] < nums[stack[-1]]:\\n                tmp = nums[stack.pop()]\\n                if tmp > threshold / (i - stack[-1] - 1):\\n                    return i - stack[-1] - 1\\n            stack.append(i)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259163,
                "title": "c-stack-o-n",
                "content": "[](http://)Find next smaller on left and right just like [https://leetcode.com/problems/largest-rectangle-in-histogram/](https://leetcode.com/problems/largest-rectangle-in-histogram/)\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& h, int t) {\\n        vector<int> l(h.size()),r(h.size());\\n        stack<int> st;\\n        for(int i=0;i<h.size();i++){                               // for smaller element on left\\n            while(!st.empty() && h[st.top()]>=h[i]) st.pop();\\n            if(st.empty()) l[i]=-1;\\n            else l[i]=st.top();\\n            st.push(i);\\n        }\\n        int n=h.size();\\n        st=stack<int>();\\n        for(int i=n-1;i>=0;i--){                             // for smaller element on right\\n            while(!st.empty() && h[st.top()]>=h[i]) st.pop();\\n            if(st.empty()) r[i]=n;\\n            else r[i]=st.top();\\n            st.push(i);\\n        }\\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++){\\n            int k = (r[i]-l[i]-1);       // length for which the current element is smaller\\n            double z = (1.0*t)/(1.0*k);       \\n            if(1.0*h[i]>z) return k;         // if condition satisfies for smaller element then just return length\\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int validSubarraySize(vector<int>& h, int t) {\\n        vector<int> l(h.size()),r(h.size());\\n        stack<int> st;\\n        for(int i=0;i<h.size();i++){                               // for smaller element on left\\n            while(!st.empty() && h[st.top()]>=h[i]) st.pop();\\n            if(st.empty()) l[i]=-1;\\n            else l[i]=st.top();\\n            st.push(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2260689,
                "title": "python3-stack-9-lines-t-m-986-ms-28-mb",
                "content": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n                            # Stack elements are the array\\'s indices idx, and montonic with respect to nums[idx].\\n                            # When the index of the nearest smaller value to nums[idx] comes to the top of the \\n                            # stack, we check whether the threshold criterion is satisfied. If so, we are done.\\n                            #  If not, we continue. Return -1 if we reach the end of nums without a winner.\\n\\t\\t\\t\\t\\t\\t\\t\\n        nums.append(0)\\n        stack = deque()\\n\\n        for idx in range(len(nums)):\\n\\n            while stack and nums[idx] <= nums[stack[-1]]:           \\n                n = nums[stack.pop()]                               # n is the next smaller value for nums[idx]\\n                k = idx if not stack else idx - stack[-1] -1        \\n                if n > threshold //k: return k                      # threshold criterion. if n passes, all\\n                                                                    # elements of the interval pass\\n            stack.append(idx)\\n\\n        return -1",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n                            # Stack elements are the array\\'s indices idx, and montonic with respect to nums[idx].\\n                            # When the index of the nearest smaller value to nums[idx] comes to the top of the \\n                            # stack, we check whether the threshold criterion is satisfied. If so, we are done.\\n                            #  If not, we continue. Return -1 if we reach the end of nums without a winner.\\n\\t\\t\\t\\t\\t\\t\\t\\n        nums.append(0)\\n        stack = deque()\\n\\n        for idx in range(len(nums)):\\n\\n            while stack and nums[idx] <= nums[stack[-1]]:           \\n                n = nums[stack.pop()]                               # n is the next smaller value for nums[idx]\\n                k = idx if not stack else idx - stack[-1] -1        \\n                if n > threshold //k: return k                      # threshold criterion. if n passes, all\\n                                                                    # elements of the interval pass\\n            stack.append(idx)\\n\\n        return -1",
                "codeTag": "Java"
            },
            {
                "id": 2260176,
                "title": "c-diviede-and-conquer-easy-codes",
                "content": "1. Get the current subarray length and calculate the `minValue = threshold/len`.\\n2. Iterate the subarray.  If  `element <= minValue` then we know that any subarray should not contain this element. This is because any subarray of the current subarray must has less length than the current one, which means the `minValue` of any subarray of the current one would be bigger than the  `minValue` of the current subarray.\\n3.  If  `element <= minValue`, then divide the current subarray to `[left, curIdx-1]` and`[curIdx+1, right]`, and continue the process, until we reach the end of any subarray and all elements in that subarray are less than the `minValue`.\\n\\nTime Complexity: O(nlogn)\\nSpace Complexity: O(logn) for the max depth of `dfs`\\n\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int th) {\\n        int res = dfs(nums, th, 0, nums.size()-1);\\n        return res ? res : -1;\\n    }\\n    \\n    int dfs(vector<int>& nums, int th, int l, int r) {\\n        if (l > r) return 0; // no more subarray\\n        \\n        int minv = th/(r-l+1);\\n        for (int i = l; i <= r; i++) {\\n            if (nums[i] <= minv) {\\n                int subres = dfs(nums, th, l, i-1); // check the subarray [left, i-1]\\n                if (subres) return subres;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tsubres = dfs(nums, th, i+1, r); // check the subarray [i+1, right]\\n                if (subres) return subres;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\treturn 0;\\n            }\\n        }\\n        return r-l+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int th) {\\n        int res = dfs(nums, th, 0, nums.size()-1);\\n        return res ? res : -1;\\n    }\\n    \\n    int dfs(vector<int>& nums, int th, int l, int r) {\\n        if (l > r) return 0; // no more subarray\\n        \\n        int minv = th/(r-l+1);\\n        for (int i = l; i <= r; i++) {\\n            if (nums[i] <= minv) {\\n                int subres = dfs(nums, th, l, i-1); // check the subarray [left, i-1]\\n                if (subres) return subres;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tsubres = dfs(nums, th, i+1, r); // check the subarray [i+1, right]\\n                if (subres) return subres;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\treturn 0;\\n            }\\n        }\\n        return r-l+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263280,
                "title": "c-next-smaller-element-on-left-and-right",
                "content": "* For every element in nums , find the index of next smaller element on left and right.\\n\\n* Then assuming nums[i] to be smallest number in `(left[i],right[i])` -> excluding endpoints , we check if the smallest number > threshold / k , then k will be our answer. \\n\\n\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        stack<int> st ;\\n        vector<int>left(nums.size(),-1),right(nums.size(),nums.size()) ;\\n        \\n        //build next smaller element on left\\n        for(int i = 0 ; i < nums.size() ; ++i ){\\n            while(st.size() and nums[i] <= nums[st.top()]) st.pop() ;\\n            if(st.size()) left[i] = st.top() ;\\n            st.push(i);\\n        }\\n        \\n        while(st.size()) st.pop();\\n        //build next smaller element on right\\n        for(int i = nums.size() - 1 ; i >= 0 ; --i ){\\n            while(st.size() and nums[i] <= nums[st.top()]) st.pop() ;\\n            if(st.size()) right[i] = st.top() ;\\n            st.push(i);\\n        }\\n        \\n        //evaluate answer\\n        for(int i = 0 ; i < nums.size() ; ++i ){\\n            int k = right[i] - left[i] - 1 ;\\n            if(k *1LL* nums[i] *1LL > threshold * 1LL) return k ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        stack<int> st ;\\n        vector<int>left(nums.size(),-1),right(nums.size(),nums.size()) ;\\n        \\n        //build next smaller element on left\\n        for(int i = 0 ; i < nums.size() ; ++i ){\\n            while(st.size() and nums[i] <= nums[st.top()]) st.pop() ;\\n            if(st.size()) left[i] = st.top() ;\\n            st.push(i);\\n        }\\n        \\n        while(st.size()) st.pop();\\n        //build next smaller element on right\\n        for(int i = nums.size() - 1 ; i >= 0 ; --i ){\\n            while(st.size() and nums[i] <= nums[st.top()]) st.pop() ;\\n            if(st.size()) right[i] = st.top() ;\\n            st.push(i);\\n        }\\n        \\n        //evaluate answer\\n        for(int i = 0 ; i < nums.size() ; ++i ){\\n            int k = right[i] - left[i] - 1 ;\\n            if(k *1LL* nums[i] *1LL > threshold * 1LL) return k ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259371,
                "title": "c-fast-optimized",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Time complexity: O(n)**\\n```\\nconst int N=1e5+100;\\nclass Solution {\\npublic:\\n    int fa[N],sz[N],mx;bool vis[N];\\n\\t\\n    int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}\\n\\t\\n    void merge(int x,int y){\\n        if(find(x)!=find(y)){\\n            sz[find(x)]+=sz[find(y)];\\n            mx=max(mx,sz[find(x)]);\\n            fa[find(y)]=find(x);\\n        }\\n    }\\n\\t\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        for(int i=0;i<nums.size();i++)fa[i]=i,sz[i]=1,vis[i]=0;\\n        mx=1;\\n        vector<int>p(nums.size());iota(p.begin(),p.end(),0);\\n\\t\\t\\n        sort(p.begin(),p.end(),[&](int i,int j){return nums[i]>nums[j];});\\n\\t\\t\\n        for(auto x:p){\\n            if(x&&vis[x-1])merge(x,x-1);\\n            if(vis[x+1])merge(x,x+1);\\n            if(nums[x]>threshold/mx)return mx;\\n            vis[x]=1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nconst int N=1e5+100;\\nclass Solution {\\npublic:\\n    int fa[N],sz[N],mx;bool vis[N];\\n\\t\\n    int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}\\n\\t\\n    void merge(int x,int y){\\n        if(find(x)!=find(y)){\\n            sz[find(x)]+=sz[find(y)];\\n            mx=max(mx,sz[find(x)]);\\n            fa[find(y)]=find(x);\\n        }\\n    }\\n\\t\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        for(int i=0;i<nums.size();i++)fa[i]=i,sz[i]=1,vis[i]=0;\\n        mx=1;\\n        vector<int>p(nums.size());iota(p.begin(),p.end(),0);\\n\\t\\t\\n        sort(p.begin(),p.end(),[&](int i,int j){return nums[i]>nums[j];});\\n\\t\\t\\n        for(auto x:p){\\n            if(x&&vis[x-1])merge(x,x-1);\\n            if(vis[x+1])merge(x,x+1);\\n            if(nums[x]>threshold/mx)return mx;\\n            vis[x]=1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259190,
                "title": "stack-o-n-c",
                "content": "Just find the length of the greatest segment a number is maximum of this can be easily done by using stack and finding next smaller to the left and right\\nand for every length check if the condition satisfies\\n\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        vector<long long> lr(n, n), rl(n, -1);\\n        \\n        vector<int> s;\\n        for(int i = 0; i < n; ++i) {\\n            while(!s.empty() and nums[i] < nums[s.back()]) {\\n                lr[s.back()] = i;\\n                s.pop_back();\\n            }\\n            s.push_back(i);\\n        }\\n        s.clear();\\n        for(int i = n - 1; ~i; --i) {\\n            while(!s.empty() and nums[i] < nums[s.back()]) {\\n                rl[s.back()] = i;\\n                s.pop_back();\\n            }\\n            s.push_back(i);\\n        }\\n        \\n        for(int i = 0; i < n; ++i) {\\n            long long length = lr[i] - rl[i] - 1;\\n            if(1LL * nums[i] * length > threshold) return length;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        vector<long long> lr(n, n), rl(n, -1);\\n        \\n        vector<int> s;\\n        for(int i = 0; i < n; ++i) {\\n            while(!s.empty() and nums[i] < nums[s.back()]) {\\n                lr[s.back()] = i;\\n                s.pop_back();\\n            }\\n            s.push_back(i);\\n        }\\n        s.clear();\\n        for(int i = n - 1; ~i; --i) {\\n            while(!s.empty() and nums[i] < nums[s.back()]) {\\n                rl[s.back()] = i;\\n                s.pop_back();\\n            }\\n            s.push_back(i);\\n        }\\n        \\n        for(int i = 0; i < n; ++i) {\\n            long long length = lr[i] - rl[i] - 1;\\n            if(1LL * nums[i] * length > threshold) return length;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260718,
                "title": "java-heap-treeset-concise-easy",
                "content": "I wish biweekly is not that early in the morning :( I can\\'t attend. \\nIt is def not the optimal solution but given that I was timing myself, I went with what\\'s the easiest to implement.\\nThere are definitely ways to optimize this more.\\n\\n#### Ideas\\n- For each num, we will find the minimum size required.\\n- If that number is greater than the size of the array, we add its index to `dead` treeset.\\n- If not, we add it to a maxheap sorted by min size needed.\\n- Go through all the elements from the heap, call `treeset.higher() and lower()` to get the best length.\\n- If this length is less than what is required for the current index, add this to the dead treeset.\\n- Repeat until we find something that works, otherwise return `-1`.\\n\\n#### Time Complexity O(nlogn)\\n```Java\\nclass Solution {\\n    public int validSubarraySize(int[] nums, int threshold) {\\n        int n  = nums.length;\\n        int[] min = new int[n];\\n        TreeSet<Integer> dead = new TreeSet<>(Set.of(n, -1)); // base case\\n        PriorityQueue<Integer> maxheap = new PriorityQueue<>(Comparator.comparingInt(o -> -min[o]));\\n        for (int i = 0; i < n; i++){\\n            min[i]=threshold/nums[i]+1;\\n            if (min[i]>nums.length){\\n                dead.add(i); // dead, this element should never appear in the answer \\n            }else{\\n                maxheap.offer(i);\\n            }\\n        }\\n        while(!maxheap.isEmpty()){\\n            int cur = maxheap.poll();\\n            if (dead.higher(cur)-dead.lower(cur)-1<min[cur]){\\n                dead.add(cur);  // widest open range < minimum required length, this index is also bad.\\n            }else{\\n                return min[cur]; // otherwise we\\'ve found it!\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```Java\\nclass Solution {\\n    public int validSubarraySize(int[] nums, int threshold) {\\n        int n  = nums.length;\\n        int[] min = new int[n];\\n        TreeSet<Integer> dead = new TreeSet<>(Set.of(n, -1)); // base case\\n        PriorityQueue<Integer> maxheap = new PriorityQueue<>(Comparator.comparingInt(o -> -min[o]));\\n        for (int i = 0; i < n; i++){\\n            min[i]=threshold/nums[i]+1;\\n            if (min[i]>nums.length){\\n                dead.add(i); // dead, this element should never appear in the answer \\n            }else{\\n                maxheap.offer(i);\\n            }\\n        }\\n        while(!maxheap.isEmpty()){\\n            int cur = maxheap.poll();\\n            if (dead.higher(cur)-dead.lower(cur)-1<min[cur]){\\n                dead.add(cur);  // widest open range < minimum required length, this index is also bad.\\n            }else{\\n                return min[cur]; // otherwise we\\'ve found it!\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259362,
                "title": "easy-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&nums,int i,int j,int k){\\n        if(i > j)\\n            return -1;\\n        if(i == j){\\n            if(nums[i] > k)\\n                return 1;\\n            else\\n                return -1;\\n        }\\n        int n = j-i+1;\\n        double x = (double)k/(double)n;\\n        int l = i;\\n        while(l <= j && nums[l] > x){\\n            l++;\\n        }\\n        if(l > j)\\n            return n;\\n        // cout<<ans<<\" \";\\n        return max(helper(nums,i,l-1,k),helper(nums,l+1,j,k));\\n    }\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        return helper(nums,0,nums.size()-1,threshold);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&nums,int i,int j,int k){\\n        if(i > j)\\n            return -1;\\n        if(i == j){\\n            if(nums[i] > k)\\n                return 1;\\n            else\\n                return -1;\\n        }\\n        int n = j-i+1;\\n        double x = (double)k/(double)n;\\n        int l = i;\\n        while(l <= j && nums[l] > x){\\n            l++;\\n        }\\n        if(l > j)\\n            return n;\\n        // cout<<ans<<\" \";\\n        return max(helper(nums,i,l-1,k),helper(nums,l+1,j,k));\\n    }\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        return helper(nums,0,nums.size()-1,threshold);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2401933,
                "title": "subarray-with-element-greater-than-threshold-easy-solution-with-monotonic-stack",
                "content": "### initialise right most element with n but why ?\\n###  reason : right[n-1] - left[0] - 1 => n - (-1) - 1 = n \\n```\\n\\nclass Solution {\\n    vector<int> LeftSmaller(vector<int> arr)\\n    {\\n        int n = arr.size();\\n        vector<int> left(n,-1);\\n        stack<int> st;\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!st.empty() && arr[st.top()]>=arr[i])\\n            {\\n                st.pop();\\n            }\\n            \\n            left[i] = st.empty() ? -1 : st.top();\\n            st.push(i);\\n        }\\n        return left;\\n    }\\n    \\n    vector<int> RightSmaller(vector<int> arr)\\n    {\\n        int n = arr.size();\\n        vector<int> right(n,-1);\\n        stack<int> st;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty() && arr[st.top()]>=arr[i])\\n            {\\n                st.pop();\\n            }\\n            \\n            right[i] = st.empty() ? n : st.top(); \\n            st.push(i);\\n        }\\n        return right;\\n    }\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        \\n        int n = nums.size();\\n        vector<int> arr(nums.begin(),nums.end());\\n        vector<int> left =  LeftSmaller(arr);\\n        vector<int> right = RightSmaller(arr);\\n    \\n        for(int i=0;i<n;i++)\\n        {\\n          if(arr[i] > threshold/(right[i]-left[i]-1))\\n          {\\n              return (right[i] - left[i] - 1);\\n          }\\n        }\\n       return -1;\\n    }\\n};\\n```\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n\\nclass Solution {\\n    vector<int> LeftSmaller(vector<int> arr)\\n    {\\n        int n = arr.size();\\n        vector<int> left(n,-1);\\n        stack<int> st;\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!st.empty() && arr[st.top()]>=arr[i])\\n            {\\n                st.pop();\\n            }\\n            \\n            left[i] = st.empty() ? -1 : st.top();\\n            st.push(i);\\n        }\\n        return left;\\n    }\\n    \\n    vector<int> RightSmaller(vector<int> arr)\\n    {\\n        int n = arr.size();\\n        vector<int> right(n,-1);\\n        stack<int> st;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty() && arr[st.top()]>=arr[i])\\n            {\\n                st.pop();\\n            }\\n            \\n            right[i] = st.empty() ? n : st.top(); \\n            st.push(i);\\n        }\\n        return right;\\n    }\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        \\n        int n = nums.size();\\n        vector<int> arr(nums.begin(),nums.end());\\n        vector<int> left =  LeftSmaller(arr);\\n        vector<int> right = RightSmaller(arr);\\n    \\n        for(int i=0;i<n;i++)\\n        {\\n          if(arr[i] > threshold/(right[i]-left[i]-1))\\n          {\\n              return (right[i] - left[i] - 1);\\n          }\\n        }\\n       return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333674,
                "title": "c-dsu-solution",
                "content": "The first approach which can come to your mind is to naively iterate over all the subarrays and check if every element is greater than `threshold / k`. Although this algorithm works, it\\'s unacceptably slow. There are <img src=\"https://latex.codecogs.com/svg.image?O(n^2)\"> subarrays each having <img src=\"https://latex.codecogs.com/svg.image?O(n)\"> elements, where <img src=\"https://latex.codecogs.com/svg.image?n=nums.length\">. Time complexity of this algorithm is <img src=\"https://latex.codecogs.com/svg.image?O(n^3)\">.\\n\\nHow we can improve the complexity?\\n\\nLet\\'s rephrase the problem. Instead of finding a subarray of length `k` such that **every** element in the subarray `> threshold / k` we will find a subarray such that the **minimum** element in the subarray `> threshold / k`. It\\'s easy to see that these two formulations are equivalent. (Let <img src=\"https://latex.codecogs.com/svg.image?m\"> be the minimum element of the subarray. If every element is greater than some number <img src=\"https://latex.codecogs.com/svg.image?x\">, then <img src=\"https://latex.codecogs.com/svg.image?m>x\">. Every element is greater than or equal to the minimum element, so if the <img src=\"https://latex.codecogs.com/svg.image?m>x\">, then all elements are greater than <img src=\"https://latex.codecogs.com/svg.image?x\">.)\\n\\nHere is a faster algorithm. Iterate over all the subarrays and check if their minimum element is greater than `threshold / k`. There are still <img src=\"https://latex.codecogs.com/svg.image?O(n^2)\"> subarrays but now we check only one element for each subarray. Time complexity is <img src=\"https://latex.codecogs.com/svg.image?O(n^2)\">. This is however also too slow for the problem constraints.\\n\\nIn this algorithm, we consider all the subarrays but not all of them are beneficial to consider. For example, if there is a subarray `[10, 8, 7, 3, 4, 2, 9]` we don\\'t need to consider subarray  `[7, 3, 4, 2]`. The minimum element of both subarrays is 2, but the length of the first one is 7 and of the second one is 4. If `2 > threshold / 4` then `2 > threshold / 7`. This means that if subarray `[7, 3, 4, 2]` satisfies the condition, then subarray `[10, 8, 7, 3, 4, 2, 9]` satisfies it either. Among several subarrays with the same minimum element, we need to consider only the longest one.\\n\\nNow we can come up with the following algorithm.\\n\\n* Start with an array of <img src=\"https://latex.codecogs.com/svg.image?n\"> empty positions.\\n* Consider the elements in non-increasing order and write them to their positions in the array.\\n* Maintain the consecutive segments of the added elements and the sizes of these segments. It can be done using [disjoint-set data structure](https://en.wikipedia.org/wiki/Disjoint-set_data_structure). When we add the element in position <img src=\"https://latex.codecogs.com/svg.image?i\">, create the segment consisting of one element, unite this segment with the segment containing position <img src=\"https://latex.codecogs.com/svg.image?i-1\"> (if such position exists and is not empty) and with the segment containing position <img src=\"https://latex.codecogs.com/svg.image?i+1\"> (if such position exists and is not empty).\\n* Check if `nums[i] > threshold / k`, where `k` is the size of the segment containing position  <img src=\"https://latex.codecogs.com/svg.image?i\">.\\n\\n![image](https://assets.leetcode.com/users/images/a95558fb-2868-4802-af5f-606f2bd872cb_1658774597.5952272.png)\\n\\nThe picture illustrates the work of the algorithm on array `[6, 5, 6, 5, 8]` with `threshold = 21`.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> p, sz;\\n    int find(int v)\\n    {\\n        return p[v] == v ? v : p[v] = find(p[v]);\\n    }\\n    void unite(int u, int v)\\n    {\\n        u = find(u);\\n        v = find(v);\\n        if(u == v)\\n            return;\\n        if(sz[u] > sz[v])\\n            swap(u, v);\\n        p[u] = v;\\n        sz[v] += sz[u];\\n    }\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        p.assign(n, -1);\\n        sz.assign(n, 1);\\n        vector<int> idxes(n);\\n        iota(idxes.begin(), idxes.end(), 0);\\n        sort(idxes.begin(), idxes.end(), [&](int i, int j){return nums[i] > nums[j];});\\n        for(int i: idxes)\\n        {\\n\\t\\t\\t// create a segment\\n            p[i] = i;\\n            // unite with the element to the left if it exists\\n            if(i - 1 >= 0 && p[i - 1] != -1)\\n                unite(i - 1, i);\\n            // unite with the element to the right if it exists\\n            if(i + 1 < n && p[i + 1] != -1)\\n                unite(i, i + 1);\\n            int k = sz[find(i)];\\n            // check if (minimum element in the segment) > threshold / k\\n            if((long long)nums[i] * k > threshold)\\n                return k;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> p, sz;\\n    int find(int v)\\n    {\\n        return p[v] == v ? v : p[v] = find(p[v]);\\n    }\\n    void unite(int u, int v)\\n    {\\n        u = find(u);\\n        v = find(v);\\n        if(u == v)\\n            return;\\n        if(sz[u] > sz[v])\\n            swap(u, v);\\n        p[u] = v;\\n        sz[v] += sz[u];\\n    }\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        p.assign(n, -1);\\n        sz.assign(n, 1);\\n        vector<int> idxes(n);\\n        iota(idxes.begin(), idxes.end(), 0);\\n        sort(idxes.begin(), idxes.end(), [&](int i, int j){return nums[i] > nums[j];});\\n        for(int i: idxes)\\n        {\\n\\t\\t\\t// create a segment\\n            p[i] = i;\\n            // unite with the element to the left if it exists\\n            if(i - 1 >= 0 && p[i - 1] != -1)\\n                unite(i - 1, i);\\n            // unite with the element to the right if it exists\\n            if(i + 1 < n && p[i + 1] != -1)\\n                unite(i, i + 1);\\n            int k = sz[find(i)];\\n            // check if (minimum element in the segment) > threshold / k\\n            if((long long)nums[i] * k > threshold)\\n                return k;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2275797,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Monotonic Stack***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        \\n        int n = nums.size();\\n        \\n        // find the index of next smaller for every element on left\\n        \\n        vector<int> left_smaller(n, -1);\\n       \\n        stack<int> st;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // remove the index of greater element from stack\\n            \\n            while(!st.empty() && nums[st.top()] >= nums[i])\\n            {\\n                st.pop();\\n            }\\n            \\n            // if no smaller element on left\\n            \\n            if(st.empty())  \\n            {\\n                left_smaller[i] = -1;\\n            }\\n            \\n            // if smaller element is present on left\\n            \\n            else\\n            {\\n                left_smaller[i] = st.top();\\n            }\\n            \\n            // push the index of curr element\\n            \\n            st.push(i);\\n        }\\n        \\n        // empty the stack for finding the next smaller on right\\n        \\n        while(!st.empty())\\n        {\\n            st.pop();\\n        }\\n        \\n        // find the index of next smaller on right\\n        \\n        vector<int> right_smaller(n, n);\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            // remove the index of greater element from stack\\n            \\n            while(!st.empty() && nums[st.top()] >= nums[i])\\n            {\\n                st.pop();\\n            }\\n            \\n            // if no smaller element on right\\n            \\n            if(st.empty())\\n            {\\n                right_smaller[i] = n;\\n            }\\n            \\n            // if smaller element is present on right\\n            \\n            else\\n            {\\n                right_smaller[i] = st.top();\\n            }\\n            \\n            // push the index of curr element\\n            \\n            st.push(i);\\n        }\\n        \\n        // now find the size of subarray, which will contains all the elements greater than (threshold / size of subarray)\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // find size of subarray, considering nums[i] as minimum of subarray\\n            \\n            int k = right_smaller[i] - left_smaller[i] - 1;\\n            \\n            // find the minimum value required for subarray, by doing (threshold / k)\\n            \\n            double min_value_required = (double) threshold / k;\\n            \\n            // check that if minimum of subarray(nums[i]) is greater than min_value_required, then size of subarray is found, return size(k)\\n            \\n            // if minimum of subarray(nums[i]) is greater than min_value_required, then every element of subarray will be greater than min_value_required\\n            \\n            if(nums[i] > min_value_required)\\n            {\\n                return k;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        \\n        int n = nums.size();\\n        \\n        // find the index of next smaller for every element on left\\n        \\n        vector<int> left_smaller(n, -1);\\n       \\n        stack<int> st;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // remove the index of greater element from stack\\n            \\n            while(!st.empty() && nums[st.top()] >= nums[i])\\n            {\\n                st.pop();\\n            }\\n            \\n            // if no smaller element on left\\n            \\n            if(st.empty())  \\n            {\\n                left_smaller[i] = -1;\\n            }\\n            \\n            // if smaller element is present on left\\n            \\n            else\\n            {\\n                left_smaller[i] = st.top();\\n            }\\n            \\n            // push the index of curr element\\n            \\n            st.push(i);\\n        }\\n        \\n        // empty the stack for finding the next smaller on right\\n        \\n        while(!st.empty())\\n        {\\n            st.pop();\\n        }\\n        \\n        // find the index of next smaller on right\\n        \\n        vector<int> right_smaller(n, n);\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            // remove the index of greater element from stack\\n            \\n            while(!st.empty() && nums[st.top()] >= nums[i])\\n            {\\n                st.pop();\\n            }\\n            \\n            // if no smaller element on right\\n            \\n            if(st.empty())\\n            {\\n                right_smaller[i] = n;\\n            }\\n            \\n            // if smaller element is present on right\\n            \\n            else\\n            {\\n                right_smaller[i] = st.top();\\n            }\\n            \\n            // push the index of curr element\\n            \\n            st.push(i);\\n        }\\n        \\n        // now find the size of subarray, which will contains all the elements greater than (threshold / size of subarray)\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // find size of subarray, considering nums[i] as minimum of subarray\\n            \\n            int k = right_smaller[i] - left_smaller[i] - 1;\\n            \\n            // find the minimum value required for subarray, by doing (threshold / k)\\n            \\n            double min_value_required = (double) threshold / k;\\n            \\n            // check that if minimum of subarray(nums[i]) is greater than min_value_required, then size of subarray is found, return size(k)\\n            \\n            // if minimum of subarray(nums[i]) is greater than min_value_required, then every element of subarray will be greater than min_value_required\\n            \\n            if(nums[i] > min_value_required)\\n            {\\n                return k;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259795,
                "title": "o-n-solution-detail-explanation",
                "content": "Let call `minK[i]` = minimum k satisfy `k*nums[i] > threshold`, so  `minK[i]` is the minimum length of subarray contain `nums[i]` satisfy that `nums[i]*minK[i] > threshold`. So `minK[i] = threshold/nums[i] + 1`; For example:\\n\\nnums = [1,3,4,3,1], threshold = 6 => minK = [7, 3, 2, 3, 7] \\n\\nit mean  nums[0] = 1 have to be in the subarray that has at least minK[0] = 7 elements\\nit mean  nums[1] = 3 have to be in the subarray that has at least minK[1] = 3 elements\\n...\\nnums[i]  have to be in the subarray that has at least minK[i] elements.\\n\\nThe idea is that at position i, we need to find the longest subarray containing nums[i] and satisfy all of the elements in this subarray that have minK < minK[i]. It means that all of the element in this subarray has nums > threshold/minK[i] because \\n(minK[j] <= minK[i])  so nums[j] > threshold/minK[j] >  threshold/minK[i] \\n\\nTo be simple, we need to find j1 and j2 so that:\\n- j1 <= i <= j2\\n- minK[i] >= minK[j] with all j1 <= j <= j2\\n- j2 - j1+1 = length of subarray is maximum\\n\\nAfter that if j2-j1+1 >= minK[i] so result can be minK[i];\\n\\nLet call j1 = left[i] is the most left element that minK[i] >= minK[left[i] -> i]\\nLet call j2 = right[i] is the most right element that minK[i] >= minK[i -> right[i]]\\n\\nTo find `left` and `right` arrays I use stack technical. \\nleft[i] is the most left element that minK[i] >= minK[from left[i] to i] so\\nleft[i]-1 will the first element that has minK greater than minK[i], so if minK[i] > minK[j] (j < i) we only need the element minK[i] in stack, because if minK[i1] (with i1>i) greater than minK[i] it definitely greater than minK[j]\\n\\n```\\n for(int i = 1; i < n; i++) {\\n            while(!st.empty() && minK[i] >= minK[st.back()])\\n                st.pop_back();\\n            if(st.empty())\\n                left[i] = 0;\\n            else\\n                left[i] = st.back() + 1;\\n            st.push_back(i);\\n  }\\n```\\n\\nSimilar for calculating the `right` array\\n\\nFull code:\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++)\\n            nums[i] = (threshold / nums[i]) + 1;\\n        \\n        vector<int> left(n, 0), right(n, 0);\\n        \\n        stack<int> st;\\n        left[0] = 0;\\n        st.push(0);\\n        for(int i = 1; i < n; i++) {\\n            while(!st.empty() && nums[i] >= nums[st.top()])\\n                st.pop();\\n            if(st.empty())\\n                left[i] = 0;\\n            else\\n                left[i] = st.top() + 1;\\n            st.push(i);\\n        }\\n        \\n        st = stack<int>{};\\n        \\n        right[n-1] = n-1;\\n        st.push(n-1);\\n        for(int i = n-2; i >= 0; i--) {\\n            while(!st.empty() && nums[i] >= nums[st.top()])\\n                st.pop();\\n            if(st.empty())\\n                right[i] = n-1;\\n            else\\n                right[i] = st.top() - 1;\\n            st.push(i);\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n            if(right[i]-left[i] + 1 >= nums[i])\\n                return nums[i];\\n        return -1;\\n    }\\n};\\n```\\n\\nTime complexity: O(N)\\nSpace: O(N)\\n\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n for(int i = 1; i < n; i++) {\\n            while(!st.empty() && minK[i] >= minK[st.back()])\\n                st.pop_back();\\n            if(st.empty())\\n                left[i] = 0;\\n            else\\n                left[i] = st.back() + 1;\\n            st.push_back(i);\\n  }\\n```\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++)\\n            nums[i] = (threshold / nums[i]) + 1;\\n        \\n        vector<int> left(n, 0), right(n, 0);\\n        \\n        stack<int> st;\\n        left[0] = 0;\\n        st.push(0);\\n        for(int i = 1; i < n; i++) {\\n            while(!st.empty() && nums[i] >= nums[st.top()])\\n                st.pop();\\n            if(st.empty())\\n                left[i] = 0;\\n            else\\n                left[i] = st.top() + 1;\\n            st.push(i);\\n        }\\n        \\n        st = stack<int>{};\\n        \\n        right[n-1] = n-1;\\n        st.push(n-1);\\n        for(int i = n-2; i >= 0; i--) {\\n            while(!st.empty() && nums[i] >= nums[st.top()])\\n                st.pop();\\n            if(st.empty())\\n                right[i] = n-1;\\n            else\\n                right[i] = st.top() - 1;\\n            st.push(i);\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n            if(right[i]-left[i] + 1 >= nums[i])\\n                return nums[i];\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259715,
                "title": "easy-solution-c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&nums,int i,int j,int k){\\n        if(i > j)\\n            return -1;\\n        if(i == j){\\n            if(nums[i] > k)\\n                return 1;\\n            else\\n                return -1;\\n        }\\n        int n = j-i+1;\\n        double x = (double)k/(double)n;\\n        int l = i;\\n        while(l <= j && nums[l] > x){\\n            l++;\\n        }\\n        if(l > j)\\n            return n;\\n        return max(helper(nums,i,l-1,k),helper(nums,l+1,j,k));\\n    }\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        return helper(nums,0,nums.size()-1,threshold);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&nums,int i,int j,int k){\\n        if(i > j)\\n            return -1;\\n        if(i == j){\\n            if(nums[i] > k)\\n                return 1;\\n            else\\n                return -1;\\n        }\\n        int n = j-i+1;\\n        double x = (double)k/(double)n;\\n        int l = i;\\n        while(l <= j && nums[l] > x){\\n            l++;\\n        }\\n        if(l > j)\\n            return n;\\n        return max(helper(nums,i,l-1,k),helper(nums,l+1,j,k));\\n    }\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        return helper(nums,0,nums.size()-1,threshold);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259325,
                "title": "c-monotonic-stack",
                "content": "Desired size of an subarray should be threshold/nums[i] + 1;\\n\\nThen using monotonic stack obtain the answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int th) {\\n        int n = nums.size();\\n        \\n        vector<int> val(n);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            val[i] = th/nums[i] + 1;\\n        }\\n        \\n        vector<int> left(n),right(n);\\n        stack<pair<int,int>> stk1,stk2;\\n        \\n        for(int i=0,j;i<n;i++)\\n        {\\n            while(!stk1.empty() and val[i]>=stk1.top().first)\\n                    stk1.pop();\\n                \\n                if(stk1.empty())\\n                    left[i] = 0;\\n                else\\n                    left[i] = stk1.top().second+1;\\n                \\n                stk1.push({val[i],i});\\n            \\n            j = n-1-i;\\n            \\n            while(!stk2.empty() and val[j]>=stk2.top().first)\\n                stk2.pop();\\n            \\n            if(stk2.empty())\\n                    right[j] = n-1;\\n                else\\n                    right[j] = stk2.top().second-1;\\n                \\n                stk2.push({val[j],j});\\n            \\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(right[i]-left[i]+1 >= val[i])\\n                return val[i];\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int th) {\\n        int n = nums.size();\\n        \\n        vector<int> val(n);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            val[i] = th/nums[i] + 1;\\n        }\\n        \\n        vector<int> left(n),right(n);\\n        stack<pair<int,int>> stk1,stk2;\\n        \\n        for(int i=0,j;i<n;i++)\\n        {\\n            while(!stk1.empty() and val[i]>=stk1.top().first)\\n                    stk1.pop();\\n                \\n                if(stk1.empty())\\n                    left[i] = 0;\\n                else\\n                    left[i] = stk1.top().second+1;\\n                \\n                stk1.push({val[i],i});\\n            \\n            j = n-1-i;\\n            \\n            while(!stk2.empty() and val[j]>=stk2.top().first)\\n                stk2.pop();\\n            \\n            if(stk2.empty())\\n                    right[j] = n-1;\\n                else\\n                    right[j] = stk2.top().second-1;\\n                \\n                stk2.push({val[j],j});\\n            \\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(right[i]-left[i]+1 >= val[i])\\n                return val[i];\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259193,
                "title": "python-o-nlogn-segments-or-union-find",
                "content": "### Using segments\\nEach time we remove the number with the minimum value. This will create some non-adjacent segments. If after each removing, we found that `new_minimum > threshold * max_segment_len`, then we found an answer of `max_segment_len`.\\n\\nWe maintain two lists:\\n\\n* A segment list with start and end indices.\\n* A segment length list with the length of each non-adjacent segment.\\n\\nWe use `SortedList` for `O(log n)` finding and `O(log n)` updating.\\n\\nThere\\'s a special number `0` added at the end (or beginning) of the original array to deal with the special case that no number needs to be removed and the answer is `len(nums)`.\\n\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        nums.append(0)\\n        n = len(nums)\\n        segments = SortedList([[0, n-1]])\\n        seg_len = SortedList([n])\\n        candidates = deque(sorted((x, i) for i, x in enumerate(nums)))\\n        sorted_nums = sorted(nums)\\n        while candidates:\\n            x, i = candidates.popleft()\\n            if not candidates:\\n                break\\n            min_num = candidates[0][0]\\n            j = segments.bisect_right([i, math.inf]) - 1\\n            s = segments.pop(j)\\n            s_len = s[1] - s[0] + 1\\n            seg_len.remove(s_len)\\n            if s[0] != s[1]:\\n                if i == s[0]:\\n                    segments.add([s[0]+1, s[1]])\\n                    seg_len.add(s_len-1)\\n                elif i == s[1]:\\n                    segments.add([s[0], s[1] - 1])\\n                    seg_len.add(s_len-1)\\n                else:\\n                    segments.add([s[0], i-1])\\n                    segments.add([i+1, s[1]])\\n                    seg_len.add(i - s[0])\\n                    seg_len.add(s[1] - i)\\n            max_seg_len = seg_len[-1]\\n            if min_num > threshold / max_seg_len:\\n                return max_seg_len\\n        return -1\\n```\\n\\n### Using UnionFind\\n\\nSimilar to the previous approach, but in reversed steps.\\n\\nWe begin with no segments. Each time we add a unadded number with the maximum value and merge with adjacent segments. Now we can use UnionFind to do the merge and calculate the sizes of segments.\\n\\n```\\nclass UnionFind:\\n    def __init__(self):\\n        self.p = dict()\\n        self.s = defaultdict(lambda: 1)\\n\\n    def find(self, v):\\n        if v not in self.p:\\n            self.p[v] = v\\n        if self.p[v] != v:\\n            self.p[v] = self.find(self.p[v])\\n        return self.p[v]\\n\\n    def union(self, u, v):\\n        pu = self.find(u)\\n        pv = self.find(v)\\n        if pu != pv:\\n            su = self.size(u)\\n            sv = self.size(v)\\n            if su < sv:\\n                self.p[pu] = pv\\n                self.s[pv] = su + sv\\n            else:\\n                self.p[pv] = pu\\n                self.s[pu] = su + sv\\n            return True\\n        return False\\n    \\n    def size(self, v):\\n        return self.s[self.find(v)]\\n\\n\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        candidates = sorted(((x, i) for i, x in enumerate(nums)), key=lambda t: -t[0])\\n        uf = UnionFind()\\n        max_seg_len = 0\\n        seen = set()\\n        for x, i in candidates:\\n            if i-1 in seen:\\n                uf.union(i, i-1)\\n            if i+1 in seen:\\n                uf.union(i, i+1)\\n            seen.add(i)\\n            max_seg_len = max(max_seg_len, uf.size(i))\\n            if x > threshold / max_seg_len:\\n                return max_seg_len\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        nums.append(0)\\n        n = len(nums)\\n        segments = SortedList([[0, n-1]])\\n        seg_len = SortedList([n])\\n        candidates = deque(sorted((x, i) for i, x in enumerate(nums)))\\n        sorted_nums = sorted(nums)\\n        while candidates:\\n            x, i = candidates.popleft()\\n            if not candidates:\\n                break\\n            min_num = candidates[0][0]\\n            j = segments.bisect_right([i, math.inf]) - 1\\n            s = segments.pop(j)\\n            s_len = s[1] - s[0] + 1\\n            seg_len.remove(s_len)\\n            if s[0] != s[1]:\\n                if i == s[0]:\\n                    segments.add([s[0]+1, s[1]])\\n                    seg_len.add(s_len-1)\\n                elif i == s[1]:\\n                    segments.add([s[0], s[1] - 1])\\n                    seg_len.add(s_len-1)\\n                else:\\n                    segments.add([s[0], i-1])\\n                    segments.add([i+1, s[1]])\\n                    seg_len.add(i - s[0])\\n                    seg_len.add(s[1] - i)\\n            max_seg_len = seg_len[-1]\\n            if min_num > threshold / max_seg_len:\\n                return max_seg_len\\n        return -1\\n```\n```\\nclass UnionFind:\\n    def __init__(self):\\n        self.p = dict()\\n        self.s = defaultdict(lambda: 1)\\n\\n    def find(self, v):\\n        if v not in self.p:\\n            self.p[v] = v\\n        if self.p[v] != v:\\n            self.p[v] = self.find(self.p[v])\\n        return self.p[v]\\n\\n    def union(self, u, v):\\n        pu = self.find(u)\\n        pv = self.find(v)\\n        if pu != pv:\\n            su = self.size(u)\\n            sv = self.size(v)\\n            if su < sv:\\n                self.p[pu] = pv\\n                self.s[pv] = su + sv\\n            else:\\n                self.p[pv] = pu\\n                self.s[pu] = su + sv\\n            return True\\n        return False\\n    \\n    def size(self, v):\\n        return self.s[self.find(v)]\\n\\n\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        candidates = sorted(((x, i) for i, x in enumerate(nums)), key=lambda t: -t[0])\\n        uf = UnionFind()\\n        max_seg_len = 0\\n        seen = set()\\n        for x, i in candidates:\\n            if i-1 in seen:\\n                uf.union(i, i-1)\\n            if i+1 in seen:\\n                uf.union(i, i+1)\\n            seen.add(i)\\n            max_seg_len = max(max_seg_len, uf.size(i))\\n            if x > threshold / max_seg_len:\\n                return max_seg_len\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196257,
                "title": "java-solution-using-disjoint-set-union-dsu",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class Pair implements Comparable<Pair>{\\n        int val; int idx;\\n        Pair(int val, int idx){\\n            this.val=val; this.idx=idx;\\n        }\\n\\n        public int compareTo(Pair p){\\n            return this.val-p.val;\\n        }\\n    }\\n\\n    class DSU{\\n        int par[];  int size[];\\n        int mx; \\n        DSU(int n){\\n            mx=1;\\n            par = new int[n];            \\n            size = new int[n];\\n            for(int i=0; i<n; i++){\\n                par[i]=i;\\n            }\\n            Arrays.fill(size,1);\\n        }\\n\\n        int parent(int x){\\n            if(par[x]==x) return x;\\n            return par[x]=parent(par[x]);\\n        }\\n\\n        void merge(int x, int y){\\n            x = parent(x);\\n            y = parent(y);\\n\\n            if(size[x]>size[y]){\\n                int temp=size[x];\\n                size[x]=size[y];\\n                size[y]=temp;\\n            }\\n\\n            size[y]+=size[x];\\n            par[x]=y;\\n            mx=Math.max(mx,size[y]);\\n        }\\n    }\\n\\n    public int validSubarraySize(int[] nums, int threshold) {\\n        int n=nums.length;\\n        DSU dsu = new DSU(n);\\n        Pair arr[] = new Pair[n];\\n        for(int i=0; i<n; i++){\\n            arr[i]=new Pair(nums[i],i);\\n        }       \\n        Arrays.sort(arr); \\n        boolean activated[] = new boolean[n];\\n        int k=1;\\n        for(int j=n-1; j>=0 && k<=n;){\\n            double minThresh = (double)threshold/k;\\n            while(j>=0 && arr[j].val>minThresh){\\n                activated[arr[j].idx]=true;\\n                if(arr[j].idx-1>=0 && activated[arr[j].idx-1]){\\n                    dsu.merge(arr[j].idx,arr[j].idx-1);\\n                }\\n                if(arr[j].idx+1<n && activated[arr[j].idx+1]){\\n                    dsu.merge(arr[j].idx,arr[j].idx+1);\\n                }\\n                j--;\\n            }\\n            if(j<n-1 && dsu.mx>=k) return k;\\n            k++;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    class Pair implements Comparable<Pair>{\\n        int val; int idx;\\n        Pair(int val, int idx){\\n            this.val=val; this.idx=idx;\\n        }\\n\\n        public int compareTo(Pair p){\\n            return this.val-p.val;\\n        }\\n    }\\n\\n    class DSU{\\n        int par[];  int size[];\\n        int mx; \\n        DSU(int n){\\n            mx=1;\\n            par = new int[n];            \\n            size = new int[n];\\n            for(int i=0; i<n; i++){\\n                par[i]=i;\\n            }\\n            Arrays.fill(size,1);\\n        }\\n\\n        int parent(int x){\\n            if(par[x]==x) return x;\\n            return par[x]=parent(par[x]);\\n        }\\n\\n        void merge(int x, int y){\\n            x = parent(x);\\n            y = parent(y);\\n\\n            if(size[x]>size[y]){\\n                int temp=size[x];\\n                size[x]=size[y];\\n                size[y]=temp;\\n            }\\n\\n            size[y]+=size[x];\\n            par[x]=y;\\n            mx=Math.max(mx,size[y]);\\n        }\\n    }\\n\\n    public int validSubarraySize(int[] nums, int threshold) {\\n        int n=nums.length;\\n        DSU dsu = new DSU(n);\\n        Pair arr[] = new Pair[n];\\n        for(int i=0; i<n; i++){\\n            arr[i]=new Pair(nums[i],i);\\n        }       \\n        Arrays.sort(arr); \\n        boolean activated[] = new boolean[n];\\n        int k=1;\\n        for(int j=n-1; j>=0 && k<=n;){\\n            double minThresh = (double)threshold/k;\\n            while(j>=0 && arr[j].val>minThresh){\\n                activated[arr[j].idx]=true;\\n                if(arr[j].idx-1>=0 && activated[arr[j].idx-1]){\\n                    dsu.merge(arr[j].idx,arr[j].idx-1);\\n                }\\n                if(arr[j].idx+1<n && activated[arr[j].idx+1]){\\n                    dsu.merge(arr[j].idx,arr[j].idx+1);\\n                }\\n                j--;\\n            }\\n            if(j<n-1 && dsu.mx>=k) return k;\\n            k++;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696908,
                "title": "divide-and-conquer-segment-tree",
                "content": "The idea is very simple,\\nSuppose our array is Like this `[...................X..............]` of size `k`.\\nWhere,` X `is the minimum element in this array and ` X <= threshold/k`, \\nNow if` X `is not a good fit for array of size K, then it also will not be a good fit for size `k - 1, k-2` and so on;\\nSo its better to remove` X `from this array.\\n\\nLet `X ` index be `Ind`\\nSo we will partition the array into two parts, \\nLeft = `[0 to Ind-1]` and right  =` [Ind+1, k]` ans solve for this subarray\\n\\n\\nNow the problem is finding minimum value in subarray is costly task and take `O(n)` worst case\\nSo it\\'s better to do some optimization, hence we use segmentTree to find minimum in range L to R in `O(logn)`\\n\\nOverall complexity of this solution in worst case will be` O(nlogn)`\\n```\\nclass SegTree{\\n    vector<pair<int,int>> tree;\\n    int sz = 2;\\n    public:\\n    \\n    SegTree(){};\\n    \\n    SegTree(vector<int> &arr){\\n        while(sz < arr.size()) sz*=2;\\n        tree.resize(sz*2, {INT_MAX, -1});\\n        \\n        for(int i=0; i<arr.size(); i++){\\n            tree[sz+i-1] = {arr[i], i};\\n        }\\n        \\n        for(int i=sz-2; i>=0; i--){\\n            pair<int,int> leftc = tree[2*i+1];\\n            pair<int,int> rightc = tree[2*i+2];\\n            if(leftc.first < rightc.first){\\n                tree[i] = leftc;\\n            }\\n            else tree[i] = rightc;\\n        }\\n    }\\n    \\n    pair<int,int> query(int l, int r, int tl, int tr, int node){\\n        if(l > tr || r < tl) return {INT_MAX, -1};\\n        \\n        if(tl >= l && tr <= r) return tree[node];\\n        \\n        \\n        int mid = tl+(tr - tl)/2;\\n        pair<int,int> left = query(l, r, tl, mid, 2*node+1);        \\n        pair<int,int> right = query(l, r, mid+1, tr, 2*node+2);\\n        \\n        if(left.first < right.first) return left;\\n        else return right;\\n    }\\n    \\n    pair<int,int> query(int l, int r){\\n        return query(l, r, 0, sz-1, 0);\\n    }\\n    \\n    \\n};\\n\\nclass Solution {\\n    SegTree tree;\\npublic:\\n    int solve(vector<int> &arr, int l, int r, int th){\\n        \\n        if(r < l) return -1;\\n         \\n        double sz = r-l+1;\\n        \\n        pair<int,int> mn = tree.query(l, r);\\n        \\n        if(mn.first > th/sz) return r-l+1;\\n        \\n        int ans = solve(arr, l, mn.second-1, th);\\n        if(ans != -1) return ans;\\n        \\n        ans = solve(arr, mn.second+1, r, th);\\n        return ans;  \\n    }\\n    \\n    int validSubarraySize(vector<int>& nums, int th) {\\n        \\n        tree = SegTree(nums);\\n        return solve(nums, 0, nums.size()-1, th);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Divide and Conquer",
                    "Tree"
                ],
                "code": "```\\nclass SegTree{\\n    vector<pair<int,int>> tree;\\n    int sz = 2;\\n    public:\\n    \\n    SegTree(){};\\n    \\n    SegTree(vector<int> &arr){\\n        while(sz < arr.size()) sz*=2;\\n        tree.resize(sz*2, {INT_MAX, -1});\\n        \\n        for(int i=0; i<arr.size(); i++){\\n            tree[sz+i-1] = {arr[i], i};\\n        }\\n        \\n        for(int i=sz-2; i>=0; i--){\\n            pair<int,int> leftc = tree[2*i+1];\\n            pair<int,int> rightc = tree[2*i+2];\\n            if(leftc.first < rightc.first){\\n                tree[i] = leftc;\\n            }\\n            else tree[i] = rightc;\\n        }\\n    }\\n    \\n    pair<int,int> query(int l, int r, int tl, int tr, int node){\\n        if(l > tr || r < tl) return {INT_MAX, -1};\\n        \\n        if(tl >= l && tr <= r) return tree[node];\\n        \\n        \\n        int mid = tl+(tr - tl)/2;\\n        pair<int,int> left = query(l, r, tl, mid, 2*node+1);        \\n        pair<int,int> right = query(l, r, mid+1, tr, 2*node+2);\\n        \\n        if(left.first < right.first) return left;\\n        else return right;\\n    }\\n    \\n    pair<int,int> query(int l, int r){\\n        return query(l, r, 0, sz-1, 0);\\n    }\\n    \\n    \\n};\\n\\nclass Solution {\\n    SegTree tree;\\npublic:\\n    int solve(vector<int> &arr, int l, int r, int th){\\n        \\n        if(r < l) return -1;\\n         \\n        double sz = r-l+1;\\n        \\n        pair<int,int> mn = tree.query(l, r);\\n        \\n        if(mn.first > th/sz) return r-l+1;\\n        \\n        int ans = solve(arr, l, mn.second-1, th);\\n        if(ans != -1) return ans;\\n        \\n        ans = solve(arr, mn.second+1, r, th);\\n        return ans;  \\n    }\\n    \\n    int validSubarraySize(vector<int>& nums, int th) {\\n        \\n        tree = SegTree(nums);\\n        return solve(nums, 0, nums.size()-1, th);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669614,
                "title": "c-monotonic-stack",
                "content": "```\\nclass Solution {\\n    // Next smaller element in the left\\n    vector<int> NSEL(vector<int> &nums) {\\n        int n = nums.size();\\n        stack<int> stk;\\n        vector<int> nsel(n);\\n        for(int i = 0; i < n; i++) {\\n            while(!stk.empty() && nums[stk.top()] >= nums[i])\\n                stk.pop();\\n            if(stk.size() == 0)\\n                nsel[i] = -1;\\n            else \\n                nsel[i] = stk.top();\\n            stk.push(i);\\n        }\\n        return nsel;\\n    }\\n\\n    // Next smaller element in the right\\n    vector<int> NSER(vector<int> &nums) {\\n        int n = nums.size();\\n        stack<int> stk;\\n        vector<int> nser(n);\\n        for(int i = n-1; i >= 0; i--) {\\n            while(!stk.empty() && nums[stk.top()] >= nums[i])\\n                stk.pop();\\n            if(stk.size() == 0)\\n                nser[i] = n;\\n            else \\n                nser[i] = stk.top();\\n            stk.push(i);\\n        }\\n        return nser;\\n    }\\n    \\n    \\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        vector<int> nsel = NSEL(nums);\\n        vector<int> nser = NSER(nums);\\n        \\n        int len = -1;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            int l = nsel[i], r = nser[i];\\n            // suppose nums[i] is minimum in this subarray\\n            if(threshold/(r-l-1)<nums[i])\\n                len = max(len, r-l-1);\\n        }\\n        \\n        return len;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    // Next smaller element in the left\\n    vector<int> NSEL(vector<int> &nums) {\\n        int n = nums.size();\\n        stack<int> stk;\\n        vector<int> nsel(n);\\n        for(int i = 0; i < n; i++) {\\n            while(!stk.empty() && nums[stk.top()] >= nums[i])\\n                stk.pop();\\n            if(stk.size() == 0)\\n                nsel[i] = -1;\\n            else \\n                nsel[i] = stk.top();\\n            stk.push(i);\\n        }\\n        return nsel;\\n    }\\n\\n    // Next smaller element in the right\\n    vector<int> NSER(vector<int> &nums) {\\n        int n = nums.size();\\n        stack<int> stk;\\n        vector<int> nser(n);\\n        for(int i = n-1; i >= 0; i--) {\\n            while(!stk.empty() && nums[stk.top()] >= nums[i])\\n                stk.pop();\\n            if(stk.size() == 0)\\n                nser[i] = n;\\n            else \\n                nser[i] = stk.top();\\n            stk.push(i);\\n        }\\n        return nser;\\n    }\\n    \\n    \\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        vector<int> nsel = NSEL(nums);\\n        vector<int> nser = NSER(nums);\\n        \\n        int len = -1;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            int l = nsel[i], r = nser[i];\\n            // suppose nums[i] is minimum in this subarray\\n            if(threshold/(r-l-1)<nums[i])\\n                len = max(len, r-l-1);\\n        }\\n        \\n        return len;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498386,
                "title": "c-simple-c-code",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold)\\n    {\\n        int n = nums.size();\\n        vector<int> left(n+1), right(n+1);\\n        stack<int> l, r;\\n        for(int i = 0; i < n; i++)\\n        {\\n            while(!l.empty() && nums[i] <= nums[l.top()])\\n                l.pop();\\n            if(!l.empty())\\n                left[i] = l.top();\\n            else\\n                left[i] = -1;\\n            l.push(i);\\n        }\\n        //cout << 1 << \" \";\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            while(!r.empty() && nums[i] <= nums[r.top()])\\n                r.pop();\\n            if(!r.empty())\\n                right[i] = r.top();\\n            else\\n                right[i] = n;\\n            r.push(i);\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            int k = right[i]-left[i]-1;\\n            double limit = (double)threshold/(double)k;\\n            if(nums[i] > limit)\\n                return k;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold)\\n    {\\n        int n = nums.size();\\n        vector<int> left(n+1), right(n+1);\\n        stack<int> l, r;\\n        for(int i = 0; i < n; i++)\\n        {\\n            while(!l.empty() && nums[i] <= nums[l.top()])\\n                l.pop();\\n            if(!l.empty())\\n                left[i] = l.top();\\n            else\\n                left[i] = -1;\\n            l.push(i);\\n        }\\n        //cout << 1 << \" \";\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            while(!r.empty() && nums[i] <= nums[r.top()])\\n                r.pop();\\n            if(!r.empty())\\n                right[i] = r.top();\\n            else\\n                right[i] = n;\\n            r.push(i);\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            int k = right[i]-left[i]-1;\\n            double limit = (double)threshold/(double)k;\\n            if(nums[i] > limit)\\n                return k;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2283016,
                "title": "beginner-friendly-solution-monotonic-stack-easy-implementation",
                "content": "We just simply check that for each element at index i, we are having it as minimum in what amount of length of subarray, which can be found very easily using monotonic stack. We are finding leftSmaller and rightSmaller, as if for those elements not in subarray from ```rightSmaller to leftSmaller``` and is smaller than the given no. then it will encounter a greater length than ```rightSmaller - leftSmaller``` as it will go till  and beyound index i for finding leftSmaller which increases the length of subarray and decreasing the ```threshold/length of subarray```.\\n\\n```\\n\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    vector<ll> leftSmaller(vector<ll> nums){\\n        \\n        ll n = nums.size();\\n        stack<ll> st;\\n        vector<ll> left(n, -1);\\n        for(int i=0; i<n; i++){\\n            \\n            while(!st.empty() && nums[st.top()]>=nums[i]) st.pop();\\n            \\n            left[i] = (st.empty()) ? -1 : st.top();\\n            st.push(i);\\n            \\n        }\\n        \\n        return left;\\n    }\\n    \\n    vector<ll> rightSmaller(vector<ll> nums){\\n        \\n        ll n = nums.size();\\n        stack<ll> st;\\n        vector<ll> right(n, n);\\n        for(int i=n-1; i>=0; i--){\\n            while(!st.empty() && nums[st.top()]>=nums[i]) st.pop();\\n            right[i] = (st.empty()) ? n : st.top();\\n            st.push(i);\\n            \\n        }\\n        \\n        return right;\\n    }\\n    \\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        \\n        int n = nums.size();\\n        \\n        vector<ll> num(nums.begin(), nums.end());\\n        vector<ll> left = leftSmaller(num), right = rightSmaller(num);\\n        \\n        for(int i=0; i<n; i++){\\n            if(num[i]> threshold/(right[i]-left[i]-1)) return right[i]-left[i]-1;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```rightSmaller to leftSmaller```\n```rightSmaller - leftSmaller```\n```threshold/length of subarray```\n```\\n\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    vector<ll> leftSmaller(vector<ll> nums){\\n        \\n        ll n = nums.size();\\n        stack<ll> st;\\n        vector<ll> left(n, -1);\\n        for(int i=0; i<n; i++){\\n            \\n            while(!st.empty() && nums[st.top()]>=nums[i]) st.pop();\\n            \\n            left[i] = (st.empty()) ? -1 : st.top();\\n            st.push(i);\\n            \\n        }\\n        \\n        return left;\\n    }\\n    \\n    vector<ll> rightSmaller(vector<ll> nums){\\n        \\n        ll n = nums.size();\\n        stack<ll> st;\\n        vector<ll> right(n, n);\\n        for(int i=n-1; i>=0; i--){\\n            while(!st.empty() && nums[st.top()]>=nums[i]) st.pop();\\n            right[i] = (st.empty()) ? n : st.top();\\n            st.push(i);\\n            \\n        }\\n        \\n        return right;\\n    }\\n    \\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        \\n        int n = nums.size();\\n        \\n        vector<ll> num(nums.begin(), nums.end());\\n        vector<ll> left = leftSmaller(num), right = rightSmaller(num);\\n        \\n        for(int i=0; i<n; i++){\\n            if(num[i]> threshold/(right[i]-left[i]-1)) return right[i]-left[i]-1;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2274331,
                "title": "python-o-n-monotonic-stack-explanation",
                "content": "For the answer to be entire array, the min element should be < threshold/N\\n\\nFor an element to be the min element in one such valid array, the subarray where this element should be min should have k such that `element > threshold/k`\\n\\nSo, if we find what is the k for each element, where the element is min. we can check above condition and return true if one such exists\\n\\nSo at each element, we need to know the min on left and min on right. Because these are the boundaries where the current element is min.\\n\\nThis screams for Monotonic Stack - Increasing\\n\\nIn the increasing monotonic stack, when the current is less than top of stack. That means the top of stack is min TILL current. And top of stack is min TILL 2nd top.\\nSo current and 2nd top are our right and left boundaries, So now we have our k. Check the formula, if true, return the length.\\n\\n```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        stack = []\\n        n = len(nums)\\n        i = 0\\n        while i <= n:\\n            while stack and (i == n or nums[stack[-1]] > nums[i]):\\n                right = stack.pop(-1)\\n                left = stack[-1] if stack else -1\\n                k = i - left - 1\\n                if nums[right] > threshold/k:\\n                    return k\\n            stack.append(i)\\n            i += 1\\n        return -1\\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        stack = []\\n        n = len(nums)\\n        i = 0\\n        while i <= n:\\n            while stack and (i == n or nums[stack[-1]] > nums[i]):\\n                right = stack.pop(-1)\\n                left = stack[-1] if stack else -1\\n                k = i - left - 1\\n                if nums[right] > threshold/k:\\n                    return k\\n            stack.append(i)\\n            i += 1\\n        return -1\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270096,
                "title": "python3-monotonic-stack",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/04944f0a6a1f4d50ee6efd64fabfc227724cdc7a) for solutions of biweekly 82. \\n\\n```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        stack = []\\n        for hi, x in enumerate(nums + [0]): \\n            while stack and stack[-1][1] > x: \\n                val = stack.pop()[1]\\n                lo = stack[-1][0] if stack else -1 \\n                if val > threshold // (hi - lo - 1): return hi - lo - 1\\n            stack.append((hi, x))\\n        return -1 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        stack = []\\n        for hi, x in enumerate(nums + [0]): \\n            while stack and stack[-1][1] > x: \\n                val = stack.pop()[1]\\n                lo = stack[-1][0] if stack else -1 \\n                if val > threshold // (hi - lo - 1): return hi - lo - 1\\n            stack.append((hi, x))\\n        return -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261981,
                "title": "stack-o-n-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int th) {\\n        int n=nums.size();\\n        vector<int>nsl(n,n);\\n        stack<int>st;\\n        st.push(n-1);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            while(st.size()>0&&nums[st.top()]>=nums[i])st.pop();\\n            if(st.size()==0)nsl[i]=n;\\n            else nsl[i]=st.top();\\n            st.push(i);\\n        }\\n        while(st.size()>0)st.pop();\\n        \\n        vector<int>nsr(n,-1);\\n        st.push(0);\\n        for(int i=0;i<n;i++)\\n        {\\n            while(st.size()>0&&nums[st.top()]>=nums[i])st.pop();\\n            if(st.size()==0)nsr[i]=-1;\\n            else nsr[i]=st.top();\\n            st.push(i);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int k=nsl[i]-nsr[i]-1;\\n            if(nums[i]>th/k)return k;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int th) {\\n        int n=nums.size();\\n        vector<int>nsl(n,n);\\n        stack<int>st;\\n        st.push(n-1);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            while(st.size()>0&&nums[st.top()]>=nums[i])st.pop();\\n            if(st.size()==0)nsl[i]=n;\\n            else nsl[i]=st.top();\\n            st.push(i);\\n        }\\n        while(st.size()>0)st.pop();\\n        \\n        vector<int>nsr(n,-1);\\n        st.push(0);\\n        for(int i=0;i<n;i++)\\n        {\\n            while(st.size()>0&&nums[st.top()]>=nums[i])st.pop();\\n            if(st.size()==0)nsr[i]=-1;\\n            else nsr[i]=st.top();\\n            st.push(i);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int k=nsl[i]-nsr[i]-1;\\n            if(nums[i]>th/k)return k;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261906,
                "title": "java-mono-stack-solution",
                "content": "```\\nclass Solution {\\n    \\n    public int validSubarraySize(int[] nums, int threshold) {\\n        \\n        int n = nums.length;\\n        int ans = -1;\\n        \\n        var nse = nextSmall(nums);\\n        var pse = prevSmall(nums);\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            int len = nse[i] - pse[i] - 1 ;\\n            \\n            if(nums[i] > threshold / len )\\n                ans = Math.max(ans , len);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int [] prevSmall(int []a){\\n        int []ps=new int[a.length];\\n        Stack<Integer>st=new Stack<>();\\n        \\n        for(int i=0;i<a.length;i++){\\n            while(!st.isEmpty() && a[i]<=a[st.peek()])\\n                st.pop();\\n            if(st.isEmpty())ps[i]=-1;\\n            else ps[i]=st.peek();\\n            \\n            st.push(i);\\n        }\\n        \\n        return ps;\\n    }\\n    \\n    private int [] nextSmall(int []a){\\n        int []ns=new int[a.length];\\n        Stack<Integer>st=new Stack<>();\\n        \\n        for(int i=a.length-1;i>=0;i--){\\n            while(!st.isEmpty() && a[i]<=a[st.peek()])\\n                st.pop();\\n            if(st.isEmpty())ns[i]=a.length;\\n            else ns[i]=st.peek();\\n            \\n            st.push(i);\\n        }\\n        \\n        return ns;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int validSubarraySize(int[] nums, int threshold) {\\n        \\n        int n = nums.length;\\n        int ans = -1;\\n        \\n        var nse = nextSmall(nums);\\n        var pse = prevSmall(nums);\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            int len = nse[i] - pse[i] - 1 ;\\n            \\n            if(nums[i] > threshold / len )\\n                ans = Math.max(ans , len);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int [] prevSmall(int []a){\\n        int []ps=new int[a.length];\\n        Stack<Integer>st=new Stack<>();\\n        \\n        for(int i=0;i<a.length;i++){\\n            while(!st.isEmpty() && a[i]<=a[st.peek()])\\n                st.pop();\\n            if(st.isEmpty())ps[i]=-1;\\n            else ps[i]=st.peek();\\n            \\n            st.push(i);\\n        }\\n        \\n        return ps;\\n    }\\n    \\n    private int [] nextSmall(int []a){\\n        int []ns=new int[a.length];\\n        Stack<Integer>st=new Stack<>();\\n        \\n        for(int i=a.length-1;i>=0;i--){\\n            while(!st.isEmpty() && a[i]<=a[st.peek()])\\n                st.pop();\\n            if(st.isEmpty())ns[i]=a.length;\\n            else ns[i]=st.peek();\\n            \\n            st.push(i);\\n        }\\n        \\n        return ns;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260934,
                "title": "python3-finding-next-smaller-element-on-the-left-and-right",
                "content": "For nums[i], if we know its next smaller element on the left and on the right, then nums[i] is the smallest item between left and right. And this is the biggest subarray with nums[i] being the smallest value. Calculate threshold / w for this subarray.\\nDo the same thing for all nums.\\n\\nWe can use 2 stacks to find next smaller element on the left and on the right respectively. But this can also be done using 1 stack in one-pass.\\n\\n```\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        nums.append(0)\\n        stack = [-1]\\n        for i in range(len(nums)):\\n            while nums[stack[-1]]>nums[i]:\\n                w = i-stack[-2]-1\\n                if nums[stack.pop()] > threshold / w:\\n                    return w\\n            stack.append(i)\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        nums.append(0)\\n        stack = [-1]\\n        for i in range(len(nums)):\\n            while nums[stack[-1]]>nums[i]:\\n                w = i-stack[-2]-1\\n                if nums[stack.pop()] > threshold / w:\\n                    return w\\n            stack.append(i)\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2260608,
                "title": "simple-java-solution-using-recursion-beats-100-detailed-explanation",
                "content": "The idea is to find a k length subarray that each element in the subarray > threshold/k, so first, **to make the threshold/k small**, we want to choose a **larger k**,  I will choose **the whole array** with **k=nums.length** and see if it is right. We can use the **start** and **end** as the border of the subarray.\\nThen if in the subarray we find that an element **nums[i]<=cur** which means that we cannot choose this element in the subarray **because once we want to decrease the size k, the cur will be greater and if we continue choosing this element in the subarray, it will still be less than cur.**\\nThus the approach is that\\n\\t1. give the start and end pointers for the subarray\\n\\t2. Iterate the element in the subarray (nums[start,end]) if there is an element nums[i]<=cur, we can seperate the range into **[start,i-1]** and **[i+1,end]**\\n\\t3. keep going until we find a res or return -1\\n\\n```\\nclass Solution {\\n    // find the possible value k that meets the condition\\n    private int count(int[] nums, int threshold, int start, int end){\\n        if(start>end) return -1;\\n\\t\\t// cur is the value that element in [start,end] should all > cur\\n        int cur = threshold/(end-start+1);\\n\\t\\t// Iterate the subarray and find if there is an element that <=cur\\n        for(int i=start; i<=end; i++){\\n            if(nums[i]<=cur){\\n                int left = count(nums,threshold,start,i-1);\\n                int right = count(nums,threshold,i+1,end);\\n                if(left!=-1) return left;\\n                else return right;\\n            }\\n        }\\n        // if all the  element > cur which means [start,end] is a right subarray so k=end-start+1\\n        return end-start+1;\\n    }\\n    public int validSubarraySize(int[] nums, int threshold) {\\n        int n = nums.length;\\n        return count(nums,threshold,0,n-1);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    // find the possible value k that meets the condition\\n    private int count(int[] nums, int threshold, int start, int end){\\n        if(start>end) return -1;\\n\\t\\t// cur is the value that element in [start,end] should all > cur\\n        int cur = threshold/(end-start+1);\\n\\t\\t// Iterate the subarray and find if there is an element that <=cur\\n        for(int i=start; i<=end; i++){\\n            if(nums[i]<=cur){\\n                int left = count(nums,threshold,start,i-1);\\n                int right = count(nums,threshold,i+1,end);\\n                if(left!=-1) return left;\\n                else return right;\\n            }\\n        }\\n        // if all the  element > cur which means [start,end] is a right subarray so k=end-start+1\\n        return end-start+1;\\n    }\\n    public int validSubarraySize(int[] nums, int threshold) {\\n        int n = nums.length;\\n        return count(nums,threshold,0,n-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260341,
                "title": "simplest-c-solution-beats-100-o-nlogn-tc-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(int i,int j,vector<int>&nums,int v){\\n\\t   //self explanatory\\n        if(i>j)return -1;\\n\\t\\t\\n        //subarray size\\n        int n=j-i+1;\\n\\t\\t//value which each element in subarray shoud exceed\\n        int mnm=v/n;\\n\\t\\t//starting index of subarray\\n        int init=i;\\n        bool flag=false;\\n        for(int k=i;k<=j;k++){\\n            if(nums[k]<=mnm){\\n\\t\\t\\t    //since nums[k] is not able to exceed smaller value because of larger subarray\\n\\t\\t\\t\\t//it can\\'t become part of smaller subarray as mnm value will increase\\n\\t\\t\\t\\t//check if left part has any answer\\n                int ans=helper(init,k-1,nums,v);\\n                if(ans!=-1)return ans;\\n\\t\\t\\t\\t//set init value k+1 ignoring the nums[k];\\n                init=k+1;\\n                flag=true;\\n            }\\n        }\\n\\t\\t//if we found any smaller value and have not returned any answer we need to check\\n\\t\\t//on last subarray( last hope)\\n        if(flag)\\n        return helper(init,j,nums,v);\\n\\t\\t//else if every value has greater value than mnm return current subarray size\\n        return n;\\n    }\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        return helper(0,nums.size()-1,nums,threshold);\\n    }\\n};\\n```\\n\\nHope it helps you!!",
                "solutionTags": [
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int i,int j,vector<int>&nums,int v){\\n\\t   //self explanatory\\n        if(i>j)return -1;\\n\\t\\t\\n        //subarray size\\n        int n=j-i+1;\\n\\t\\t//value which each element in subarray shoud exceed\\n        int mnm=v/n;\\n\\t\\t//starting index of subarray\\n        int init=i;\\n        bool flag=false;\\n        for(int k=i;k<=j;k++){\\n            if(nums[k]<=mnm){\\n\\t\\t\\t    //since nums[k] is not able to exceed smaller value because of larger subarray\\n\\t\\t\\t\\t//it can\\'t become part of smaller subarray as mnm value will increase\\n\\t\\t\\t\\t//check if left part has any answer\\n                int ans=helper(init,k-1,nums,v);\\n                if(ans!=-1)return ans;\\n\\t\\t\\t\\t//set init value k+1 ignoring the nums[k];\\n                init=k+1;\\n                flag=true;\\n            }\\n        }\\n\\t\\t//if we found any smaller value and have not returned any answer we need to check\\n\\t\\t//on last subarray( last hope)\\n        if(flag)\\n        return helper(init,j,nums,v);\\n\\t\\t//else if every value has greater value than mnm return current subarray size\\n        return n;\\n    }\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        return helper(0,nums.size()-1,nums,threshold);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260267,
                "title": "python-3-hint-solution",
                "content": "Again, hard needs hint...\\n\\n```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], t: int) -> int:\\n        n = len(nums)\\n        if t / n >= max(nums):\\n            return -1\\n        \\n        left = list(range(n))\\n        right = list(range(n))\\n\\n        # leftmost boundary for the subarray for each index\\n        stack = []\\n        for i in range(n):\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                left[i] = left[stack.pop()]\\n            stack.append(i)\\n            \\n        # rightmost boundary for the subarray for each index\\n        stack = []\\n        for i in reversed(range(n)):\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                right[i] = right[stack.pop()]\\n            stack.append(i)\\n\\n        # get size of subarray and if eligible then output\\n        for i in range(n):\\n            size = right[i] - left[i] + 1\\n            if nums[i] > t / size:\\n                return size\\n        \\n        return -1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Monotonic Queue"
                ],
                "code": "Again, hard needs hint...\\n\\n```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], t: int) -> int:\\n        n = len(nums)\\n        if t / n >= max(nums):\\n            return -1\\n        \\n        left = list(range(n))\\n        right = list(range(n))\\n\\n        # leftmost boundary for the subarray for each index\\n        stack = []\\n        for i in range(n):\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                left[i] = left[stack.pop()]\\n            stack.append(i)\\n            \\n        # rightmost boundary for the subarray for each index\\n        stack = []\\n        for i in reversed(range(n)):\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                right[i] = right[stack.pop()]\\n            stack.append(i)\\n\\n        # get size of subarray and if eligible then output\\n        for i in range(n):\\n            size = right[i] - left[i] + 1\\n            if nums[i] > t / size:\\n                return size\\n        \\n        return -1",
                "codeTag": "Java"
            },
            {
                "id": 2260036,
                "title": "c-just-find-the-range-in-which-current-element-is-minimum-stack",
                "content": "```\\n/* \\n    Time: O(n)\\n    Space: O(n)\\n    Tag: Monotonic Stack\\n    Difficulty: M\\n*/\\n\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int> &nums, int threshold) {\\n\\t\\n\\t\\t// Finding the range in which current element is minimum using concept of Next Smaller Left and Next Smaller Right Element using stack\\n        vector<int> nsl(nums.size()), nsr(nums.size());\\n        stack<pair<int, int>> st;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            while (!st.empty() && st.top().first >= nums[i]) st.pop();\\n            if (st.empty())\\n                nsl[i] = -1;\\n            else\\n                nsl[i] = st.top().second;\\n            st.push({nums[i], i});\\n        }\\n\\n        while (!st.empty()) st.pop();\\n\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            while (!st.empty() && st.top().first >= nums[i]) st.pop();\\n            if (st.empty())\\n                nsr[i] = nums.size();\\n            else\\n                nsr[i] = st.top().second;\\n            st.push({nums[i], i});\\n        }\\n\\t\\t\\n\\t\\t// Then find the largest smallest value for a subarray of length k\\n        vector<int> t(nums.size() + 1, -1);\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            t[nsr[i] - nsl[i] - 1] = max(t[nsr[i] - nsl[i] - 1], nums[i]);\\n        }\\n\\t\\t\\n\\t\\t// Now check for every k, if there is a subarray minimum which stasfy the required condition\\n        for (int i = 1; i <= nums.size(); i++) {\\n            if (t[i] > (threshold / i)) return i;\\n        }\\n\\t\\t\\n\\t\\t// If no such k found return -1\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n/* \\n    Time: O(n)\\n    Space: O(n)\\n    Tag: Monotonic Stack\\n    Difficulty: M\\n*/\\n\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int> &nums, int threshold) {\\n\\t\\n\\t\\t// Finding the range in which current element is minimum using concept of Next Smaller Left and Next Smaller Right Element using stack\\n        vector<int> nsl(nums.size()), nsr(nums.size());\\n        stack<pair<int, int>> st;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            while (!st.empty() && st.top().first >= nums[i]) st.pop();\\n            if (st.empty())\\n                nsl[i] = -1;\\n            else\\n                nsl[i] = st.top().second;\\n            st.push({nums[i], i});\\n        }\\n\\n        while (!st.empty()) st.pop();\\n\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            while (!st.empty() && st.top().first >= nums[i]) st.pop();\\n            if (st.empty())\\n                nsr[i] = nums.size();\\n            else\\n                nsr[i] = st.top().second;\\n            st.push({nums[i], i});\\n        }\\n\\t\\t\\n\\t\\t// Then find the largest smallest value for a subarray of length k\\n        vector<int> t(nums.size() + 1, -1);\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            t[nsr[i] - nsl[i] - 1] = max(t[nsr[i] - nsl[i] - 1], nums[i]);\\n        }\\n\\t\\t\\n\\t\\t// Now check for every k, if there is a subarray minimum which stasfy the required condition\\n        for (int i = 1; i <= nums.size(); i++) {\\n            if (t[i] > (threshold / i)) return i;\\n        }\\n\\t\\t\\n\\t\\t// If no such k found return -1\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259963,
                "title": "simple-java-solution-using-monotonic-stack-beats-100",
                "content": "the idea is that if the smallest element in the sub-array meets the condition, all the other elements in the sub-array will meet the condition as well.\\nThis reduces the question to identifying the length of sub-array for each elelment where it is the smallest. \\nThis is well known question which can be solved using monotonic stack.\\n\\nAdditionally, if you find an element which is greater than `threshold`, simply return 1 as this element on it\\'s own, i.e sub-array of length 1 including this element, will satisfy the condition.\\n\\n```\\nclass Solution {\\n    public int validSubarraySize(int[] nums, int threshold) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        stack.push(-1);\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            if (nums[i] > threshold) {\\n                return 1;\\n            }\\n\\n            while(stack.peek() != -1 && nums[stack.peek()] > nums[i]) {\\n                int id = stack.pop();\\n                \\n                int len = i - stack.peek() - 1;\\n                if (nums[id] > threshold / len) {\\n                    return len;\\n                }\\n            }\\n            \\n            stack.push(i);\\n        }\\n        \\n        while(stack.peek() != -1) {\\n            int id = stack.pop();\\n            \\n            int len = nums.length - stack.peek() - 1;\\n            if (nums[id] > threshold / len) {\\n                return len;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int validSubarraySize(int[] nums, int threshold) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        stack.push(-1);\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            if (nums[i] > threshold) {\\n                return 1;\\n            }\\n\\n            while(stack.peek() != -1 && nums[stack.peek()] > nums[i]) {\\n                int id = stack.pop();\\n                \\n                int len = i - stack.peek() - 1;\\n                if (nums[id] > threshold / len) {\\n                    return len;\\n                }\\n            }\\n            \\n            stack.push(i);\\n        }\\n        \\n        while(stack.peek() != -1) {\\n            int id = stack.pop();\\n            \\n            int len = nums.length - stack.peek() - 1;\\n            if (nums[id] > threshold / len) {\\n                return len;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259913,
                "title": "video-explanation-with-intuition",
                "content": "https://www.youtube.com/watch?v=j7hXhjuwqaY",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=j7hXhjuwqaY",
                "codeTag": "Unknown"
            },
            {
                "id": 2259865,
                "title": "c-monotonic-stack-cleanest-code-easy-to-understand",
                "content": "Please upvote\\nSuppose the element under consideration is the **ith** element,then find its leftmost ***prevsmaller*** element and its rightmost ***nextsmaller*** element,so it means that our ith element is the smallest in this range.\\nLets say prevsmaller is at **l** and nextsmaller is at **r**,so our ith element is the smallest in the range **[l+1..........r-1].**\\nThen find out the length of this range and calculate ***threshold/length***\\nIf our **ith** element is bigger than threshold/length,even after being the smallest element in the range [l+1......r-1] then all the other elements in this range [l+!.....r-1] must be greater than threshold/k,hence we can return this subarray\\'s length.\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n=nums.size();\\n        vector<int> nextsmaller(n,n);\\n        stack<int> st;\\n        for(int i=0;i<n;i++){\\n            while(!st.empty() and nums[st.top()]>nums[i]){\\n                nextsmaller[st.top()]=i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        while(st.empty()==false){\\n            st.pop();\\n        }\\n        vector<int> prevsmaller(n,-1);\\n        for(int i=n-1;i>=0;i--){\\n            while(!st.empty() and nums[i]<=nums[st.top()]){\\n                prevsmaller[st.top()]=i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        for(int i=0;i<n;i++){\\n\\t\\t//for each index we are finding whats the next smaller and prev smaller\\n\\t\\t//so this element must be the smallest in this range then\\n\\t\\t//so if this element is the smallest in the range and alos greater than threshold/k then we can return the length of this subarray\\n            int l=prevsmaller[i];\\n            int r=nextsmaller[i];\\n            int len=r-l+1;\\n            len-=2;\\n            int cp=threshold/len;\\n            if(nums[i]>cp){\\n                return len;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n=nums.size();\\n        vector<int> nextsmaller(n,n);\\n        stack<int> st;\\n        for(int i=0;i<n;i++){\\n            while(!st.empty() and nums[st.top()]>nums[i]){\\n                nextsmaller[st.top()]=i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        while(st.empty()==false){\\n            st.pop();\\n        }\\n        vector<int> prevsmaller(n,-1);\\n        for(int i=n-1;i>=0;i--){\\n            while(!st.empty() and nums[i]<=nums[st.top()]){\\n                prevsmaller[st.top()]=i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        for(int i=0;i<n;i++){\\n\\t\\t//for each index we are finding whats the next smaller and prev smaller\\n\\t\\t//so this element must be the smallest in this range then\\n\\t\\t//so if this element is the smallest in the range and alos greater than threshold/k then we can return the length of this subarray\\n            int l=prevsmaller[i];\\n            int r=nextsmaller[i];\\n            int len=r-l+1;\\n            len-=2;\\n            int cp=threshold/len;\\n            if(nums[i]>cp){\\n                return len;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259631,
                "title": "intuitive-o-n-time-o-1-space-python",
                "content": "Define a function to validate an answer, as well as count the max length that we can achieve (in case it is invalid, we can still get some useful information).\\n\\nStart testing possible answers from the biggest. \\n* if it is valid, return it as the answer\\n* if it is not, then we directly test the max length that we can achieve. Why? When we test a smaller answer, the threshold becomes bigger, so it is impossible for us to achieve a longer length than the previous max. \\n\\nIn this way, we reduce the time complexity to O(N).\\nSpace complexity: O(1)\\n\\n```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n\\n        def validate(k: int) -> (bool, int):\\n            thr = threshold / k\\n            lmn = cnt = 0\\n            for n in nums:\\n                if n > thr:\\n                    cnt += 1\\n                    if cnt == k:\\n                        return True, None\\n                    lmn = max(cnt, lmn)\\n                else:\\n                    cnt = 0\\n            return False, lmn\\n\\n        m = len(nums)\\n        while m:\\n            bl, x = validate(m)\\n            if bl:\\n                return m\\n            else:\\n                m = x\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n\\n        def validate(k: int) -> (bool, int):\\n            thr = threshold / k\\n            lmn = cnt = 0\\n            for n in nums:\\n                if n > thr:\\n                    cnt += 1\\n                    if cnt == k:\\n                        return True, None\\n                    lmn = max(cnt, lmn)\\n                else:\\n                    cnt = 0\\n            return False, lmn\\n\\n        m = len(nums)\\n        while m:\\n            bl, x = validate(m)\\n            if bl:\\n                return m\\n            else:\\n                m = x\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259185,
                "title": "c-mono-stack",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        stack<int> stk; \\n        for (int i = 0, ii = 0; i <= nums.size(); stk.push(i++)) \\n            while (stk.size() && (i == nums.size() || nums[stk.top()] >= nums[i])) {\\n                int val = nums[stk.top()]; stk.pop(); \\n                if (stk.size()) ii = stk.top(); \\n                else ii = -1; \\n                if (val > threshold/(i-ii-1)) return i-ii-1; \\n            }\\n        return -1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        stack<int> stk; \\n        for (int i = 0, ii = 0; i <= nums.size(); stk.push(i++)) \\n            while (stk.size() && (i == nums.size() || nums[stk.top()] >= nums[i])) {\\n                int val = nums[stk.top()]; stk.pop(); \\n                if (stk.size()) ii = stk.top(); \\n                else ii = -1; \\n                if (val > threshold/(i-ii-1)) return i-ii-1; \\n            }\\n        return -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259161,
                "title": "python-3-monotonic-stack",
                "content": "For each number, find the range it serves as the minimum using monotonic stack. Then calculate whether threshold / length of its range < its value.\\n\\n```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        mi = min(nums)\\n        n = len(nums)\\n        \\n        stk = []\\n        dp_r = [-1] * n\\n        for i in range(n):\\n            while stk and stk[-1][0] > nums[i]:\\n                _, j = stk.pop()\\n                dp_r[j] = i - 1\\n            stk.append([nums[i], i])\\n        for i in range(len(stk)):\\n            dp_r[stk[i][1]] = n - 1\\n        \\n        stk = []\\n        dp_l = [-1] * n\\n        for i in range(n - 1, -1, -1):\\n            while stk and stk[-1][0] > nums[i]:\\n                _, j = stk.pop()\\n                dp_l[j] = i + 1\\n            stk.append([nums[i], i])\\n        for i in range(len(stk)):\\n            dp_l[stk[i][1]] = 0\\n        \\n        for i in range(n):\\n            if nums[i] > threshold / (dp_r[i] - dp_l[i] + 1):\\n                return dp_r[i] - dp_l[i] + 1\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        mi = min(nums)\\n        n = len(nums)\\n        \\n        stk = []\\n        dp_r = [-1] * n\\n        for i in range(n):\\n            while stk and stk[-1][0] > nums[i]:\\n                _, j = stk.pop()\\n                dp_r[j] = i - 1\\n            stk.append([nums[i], i])\\n        for i in range(len(stk)):\\n            dp_r[stk[i][1]] = n - 1\\n        \\n        stk = []\\n        dp_l = [-1] * n\\n        for i in range(n - 1, -1, -1):\\n            while stk and stk[-1][0] > nums[i]:\\n                _, j = stk.pop()\\n                dp_l[j] = i + 1\\n            stk.append([nums[i], i])\\n        for i in range(len(stk)):\\n            dp_l[stk[i][1]] = 0\\n        \\n        for i in range(n):\\n            if nums[i] > threshold / (dp_r[i] - dp_l[i] + 1):\\n                return dp_r[i] - dp_l[i] + 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070652,
                "title": "c-union-find",
                "content": "This is my solution using Union Find. If you find this implementation useful, please upvote. Thank you for reading.\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int find(vector<int> &parent, int p ){\\n        if(parent[p] != p){\\n            parent[p] =find(parent, parent[p]);\\n        }\\n        return parent[p];\\n    }\\n    void merge(int u, int v, vector<int> &parent, vector<int> &sz){\\n        int p_u = find(parent, u);\\n        int p_v = find(parent, v);\\n        if(p_u == p_v){\\n            return;\\n        }\\n        if(sz[p_u] >= sz[p_v]){\\n            parent[p_v] = p_u;\\n            sz[p_u] += sz[p_v];\\n        }\\n        else{\\n            parent[p_u] = p_v;\\n            sz[p_v] += sz[p_u];\\n        }\\n    }\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        vector<int> parent(n, 0);\\n        vector<int> sz(n, 1);\\n        for(int i=0; i<n; i++){\\n            parent[i] = i;\\n        }\\n        vector<pair<int, int>> contain;\\n        for(int i=0; i<n; i++){\\n            contain.push_back({nums[i], i}); \\n        }\\n        sort(contain.begin(), contain.end());\\n      \\n        for(int i= n-1; i>=0; i--){\\n            int k = threshold /contain[i].first;\\n            if(k == 0){\\n                k++;\\n            }\\n            if(contain[i].first <= threshold / k){\\n                k ++;\\n            }\\n            int index = contain[i].second;\\n            if(index >= 1){\\n                if(nums[index-1] > (threshold / k)){\\n                    merge(index-1, index, parent, sz);\\n                }\\n            }\\n            if(index < n-1){\\n                if(nums[index+1] > (threshold/k)){\\n                    merge(index+1, index, parent, sz);\\n                }\\n            }\\n            if(sz[find(parent, index)] >= k){\\n                return k;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int find(vector<int> &parent, int p ){\\n        if(parent[p] != p){\\n            parent[p] =find(parent, parent[p]);\\n        }\\n        return parent[p];\\n    }\\n    void merge(int u, int v, vector<int> &parent, vector<int> &sz){\\n        int p_u = find(parent, u);\\n        int p_v = find(parent, v);\\n        if(p_u == p_v){\\n            return;\\n        }\\n        if(sz[p_u] >= sz[p_v]){\\n            parent[p_v] = p_u;\\n            sz[p_u] += sz[p_v];\\n        }\\n        else{\\n            parent[p_u] = p_v;\\n            sz[p_v] += sz[p_u];\\n        }\\n    }\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        vector<int> parent(n, 0);\\n        vector<int> sz(n, 1);\\n        for(int i=0; i<n; i++){\\n            parent[i] = i;\\n        }\\n        vector<pair<int, int>> contain;\\n        for(int i=0; i<n; i++){\\n            contain.push_back({nums[i], i}); \\n        }\\n        sort(contain.begin(), contain.end());\\n      \\n        for(int i= n-1; i>=0; i--){\\n            int k = threshold /contain[i].first;\\n            if(k == 0){\\n                k++;\\n            }\\n            if(contain[i].first <= threshold / k){\\n                k ++;\\n            }\\n            int index = contain[i].second;\\n            if(index >= 1){\\n                if(nums[index-1] > (threshold / k)){\\n                    merge(index-1, index, parent, sz);\\n                }\\n            }\\n            if(index < n-1){\\n                if(nums[index+1] > (threshold/k)){\\n                    merge(index+1, index, parent, sz);\\n                }\\n            }\\n            if(sz[find(parent, index)] >= k){\\n                return k;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043724,
                "title": "c-with-explanation",
                "content": "# Intuition\\n1. use two monotonic stack to find out \"Next Lesser Element(NLE)\" of right side and left side \\n2. when we find the NLE of left side and right side. we can know the subarray with minimum value nums[i] and its length\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        stack<pair<int, int>> sRight; //{value, index}, next right lesser idx \\n        stack<pair<int, int>> sLeft; //{value, index}, next left lesser idx \\n        vector<int> vRight(n,-1);\\n        vector<int> vLeft(n, -1);\\n        sRight.push({nums[0], 0});\\n        for(int i=1; i<n; i++)\\n        {\\n            int target = nums[i];\\n            while(!sRight.empty())\\n            {\\n                pair<int, int> pTop = sRight.top();\\n                if(target >= pTop.first)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    sRight.pop();\\n                    vRight[pTop.second] = i - pTop.second -1;\\n\\n                }\\n            }\\n            sRight.push({target, i});\\n        }\\n\\n        sLeft.push({nums[n-1], n-1});\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            int target = nums[i];\\n            while(!sLeft.empty())\\n            {\\n                pair<int, int> pTop = sLeft.top();\\n                if(target >= pTop.first)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    sLeft.pop();\\n                    vLeft[pTop.second] = pTop.second - i -1;\\n                }\\n            }\\n            sLeft.push({target, i});\\n        }        \\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int iLeft = vLeft[i];\\n            if(iLeft == -1) iLeft = i;\\n\\n            int iRight = vRight[i];\\n            if(iRight == -1) iRight = n-1-i;\\n\\n            int iLength = iLeft+iRight+1;\\n            if(nums[i] > threshold/iLength) return iLength;\\n            \\n        }\\n\\n     \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        stack<pair<int, int>> sRight; //{value, index}, next right lesser idx \\n        stack<pair<int, int>> sLeft; //{value, index}, next left lesser idx \\n        vector<int> vRight(n,-1);\\n        vector<int> vLeft(n, -1);\\n        sRight.push({nums[0], 0});\\n        for(int i=1; i<n; i++)\\n        {\\n            int target = nums[i];\\n            while(!sRight.empty())\\n            {\\n                pair<int, int> pTop = sRight.top();\\n                if(target >= pTop.first)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    sRight.pop();\\n                    vRight[pTop.second] = i - pTop.second -1;\\n\\n                }\\n            }\\n            sRight.push({target, i});\\n        }\\n\\n        sLeft.push({nums[n-1], n-1});\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            int target = nums[i];\\n            while(!sLeft.empty())\\n            {\\n                pair<int, int> pTop = sLeft.top();\\n                if(target >= pTop.first)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    sLeft.pop();\\n                    vLeft[pTop.second] = pTop.second - i -1;\\n                }\\n            }\\n            sLeft.push({target, i});\\n        }        \\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int iLeft = vLeft[i];\\n            if(iLeft == -1) iLeft = i;\\n\\n            int iRight = vRight[i];\\n            if(iRight == -1) iRight = n-1-i;\\n\\n            int iLength = iLeft+iRight+1;\\n            if(nums[i] > threshold/iLength) return iLength;\\n            \\n        }\\n\\n     \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799774,
                "title": "c-stack-next-smaller-and-previous-smaller",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int th) {\\n        int n = nums.size();\\n        vector<int> left(n),right(n);\\n        stack<int> st;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.size()==0)\\n            {\\n                st.push(i);\\n                left[i] = -1;\\n            }\\n            else if(nums[st.top()]<nums[i])\\n            {\\n                left[i] = st.top();\\n                st.push(i);\\n            }\\n            else\\n            {\\n                while(!st.empty() && nums[st.top()]>=nums[i])\\n                st.pop();\\n                if(st.size()==0)\\n                left[i] = -1;\\n                else\\n                left[i] = st.top();\\n                st.push(i);\\n            }\\n        }\\n        while(!st.empty())\\n        st.pop();\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(st.size()==0)\\n            {\\n                st.push(i);\\n                right[i] = n;\\n            }\\n            else if(nums[st.top()]<nums[i])\\n            {\\n                right[i] = st.top();\\n                st.push(i);\\n            }\\n            else\\n            {\\n                while(!st.empty() && nums[st.top()]>=nums[i])\\n                st.pop();\\n                if(st.size()==0)\\n                right[i] = n;\\n                else\\n                right[i] = st.top();\\n                st.push(i);\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int a1 = left[i];\\n            int a2 = right[i];\\n            int len = right[i]-left[i]-1;\\n            if(nums[i]>th/len)\\n            return len;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int th) {\\n        int n = nums.size();\\n        vector<int> left(n),right(n);\\n        stack<int> st;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.size()==0)\\n            {\\n                st.push(i);\\n                left[i] = -1;\\n            }\\n            else if(nums[st.top()]<nums[i])\\n            {\\n                left[i] = st.top();\\n                st.push(i);\\n            }\\n            else\\n            {\\n                while(!st.empty() && nums[st.top()]>=nums[i])\\n                st.pop();\\n                if(st.size()==0)\\n                left[i] = -1;\\n                else\\n                left[i] = st.top();\\n                st.push(i);\\n            }\\n        }\\n        while(!st.empty())\\n        st.pop();\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(st.size()==0)\\n            {\\n                st.push(i);\\n                right[i] = n;\\n            }\\n            else if(nums[st.top()]<nums[i])\\n            {\\n                right[i] = st.top();\\n                st.push(i);\\n            }\\n            else\\n            {\\n                while(!st.empty() && nums[st.top()]>=nums[i])\\n                st.pop();\\n                if(st.size()==0)\\n                right[i] = n;\\n                else\\n                right[i] = st.top();\\n                st.push(i);\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int a1 = left[i];\\n            int a2 = right[i];\\n            int len = right[i]-left[i]-1;\\n            if(nums[i]>th/len)\\n            return len;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713554,
                "title": "unique-o-n-approach-using-monotonic-stack",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. we will create a new array where arr[i] = (old_arr[i]+1)/threshorld = k means you need atleast length k if you want to include i\\'th element.  For origional old_arr = [1,3,4,3,1] and threshold = 6, the arr = [7,3,2,3,7]. \\n2. Now for every element y in arr, you find the max possible length of subarray passing through y and has maximum element = y. You can do this by finding the nearest index l such that l<i && arr[l] > arr[i] and nearest  index r such that r>i && arr[r] > arr[i]. then the lenth of subarray = r-i + i-l - 1. You can do this using monotonic stack. \\n3. if you find any such element y , you return the length . \\n\\n# Complexity\\n- Time and space complexity: O(N) \\n\\n# Code\\n```\\nclass Solution {\\n    public int validSubarraySize(int[] arr, int threshold) {\\n        int n= arr.length;\\n        for(int i=0;i<n;i++)arr[i]= threshold/arr[i]+1;\\n        System.out.println(Arrays.toString(arr));\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        int[] greaterOnLeft = new int[n];\\n        for(int i=0;i<n;i++){\\n            while(!dq.isEmpty() && arr[dq.peek()] <= arr[i])dq.pop();\\n            greaterOnLeft[i] = dq.isEmpty()?(i+1):(i-dq.peek());\\n            dq.push(i);\\n        }        \\n        dq = new ArrayDeque<>();\\n        for(int i=n-1;i>=0;i--){\\n            while(!dq.isEmpty() && arr[dq.peek()] <= arr[i])dq.pop();\\n            int greaterOnRight = dq.isEmpty()?(n-i):(dq.peek() - i);\\n            int curr = greaterOnRight + greaterOnLeft[i] - 1;\\n            if(curr >= arr[i] && curr <=n)return curr;\\n            dq.push(i);\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int validSubarraySize(int[] arr, int threshold) {\\n        int n= arr.length;\\n        for(int i=0;i<n;i++)arr[i]= threshold/arr[i]+1;\\n        System.out.println(Arrays.toString(arr));\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        int[] greaterOnLeft = new int[n];\\n        for(int i=0;i<n;i++){\\n            while(!dq.isEmpty() && arr[dq.peek()] <= arr[i])dq.pop();\\n            greaterOnLeft[i] = dq.isEmpty()?(i+1):(i-dq.peek());\\n            dq.push(i);\\n        }        \\n        dq = new ArrayDeque<>();\\n        for(int i=n-1;i>=0;i--){\\n            while(!dq.isEmpty() && arr[dq.peek()] <= arr[i])dq.pop();\\n            int greaterOnRight = dq.isEmpty()?(n-i):(dq.peek() - i);\\n            int curr = greaterOnRight + greaterOnLeft[i] - 1;\\n            if(curr >= arr[i] && curr <=n)return curr;\\n            dq.push(i);\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692934,
                "title": "simple-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& v, int t) {\\n        int n = v.size();\\n        vector<int> nextmin(n);\\n        vector<int> prevmin(n);\\n        stack<int> st;\\n        for(int i=n-1;i>=0;i--){\\n            while(!st.empty()&&v[st.top()]>=v[i]){\\n                st.pop();\\n            }\\n            if(st.empty()){\\n                nextmin[i] = -1;\\n            }\\n            else{\\n                nextmin[i] = st.top();\\n            }\\n            st.push(i);\\n        }\\n        while(!st.empty()){\\n            st.pop();\\n        }\\n        // cout<<st.size()<<\" \\\\n\";\\n        for(int i=0;i<n;i++){\\n            while(!st.empty()&&v[st.top()]>=v[i]){\\n                st.pop();\\n            }\\n            if(st.empty()){\\n                prevmin[i] = -1;\\n            }\\n            else{\\n                prevmin[i] = st.top();\\n            }\\n            st.push(i);\\n        }\\n        // for(int i=0;i<n;i++){\\n        //     cout<<v[i]<<\" \"<<prevmin[i]<<\" \"<<nextmin[i]<<\"\\\\n\";\\n        // }\\n        int mx=-1;\\n        for(int i=0;i<n;i++){\\n            int right = nextmin[i]==-1?n-i:nextmin[i]-i;\\n            int left = prevmin[i]==-1?i:i-prevmin[i]-1;\\n            int len = right+left;\\n            // cout<<v[i]<<\" \"<<len<<\" \\\\n\";\\n            if(len*1LL*v[i]>t){\\n                mx = max(mx,len);\\n            }\\n        }\\n        return mx;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& v, int t) {\\n        int n = v.size();\\n        vector<int> nextmin(n);\\n        vector<int> prevmin(n);\\n        stack<int> st;\\n        for(int i=n-1;i>=0;i--){\\n            while(!st.empty()&&v[st.top()]>=v[i]){\\n                st.pop();\\n            }\\n            if(st.empty()){\\n                nextmin[i] = -1;\\n            }\\n            else{\\n                nextmin[i] = st.top();\\n            }\\n            st.push(i);\\n        }\\n        while(!st.empty()){\\n            st.pop();\\n        }\\n        // cout<<st.size()<<\" \\\\n\";\\n        for(int i=0;i<n;i++){\\n            while(!st.empty()&&v[st.top()]>=v[i]){\\n                st.pop();\\n            }\\n            if(st.empty()){\\n                prevmin[i] = -1;\\n            }\\n            else{\\n                prevmin[i] = st.top();\\n            }\\n            st.push(i);\\n        }\\n        // for(int i=0;i<n;i++){\\n        //     cout<<v[i]<<\" \"<<prevmin[i]<<\" \"<<nextmin[i]<<\"\\\\n\";\\n        // }\\n        int mx=-1;\\n        for(int i=0;i<n;i++){\\n            int right = nextmin[i]==-1?n-i:nextmin[i]-i;\\n            int left = prevmin[i]==-1?i:i-prevmin[i]-1;\\n            int len = right+left;\\n            // cout<<v[i]<<\" \"<<len<<\" \\\\n\";\\n            if(len*1LL*v[i]>t){\\n                mx = max(mx,len);\\n            }\\n        }\\n        return mx;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3656666,
                "title": "python-nsl-and-nsr-explained",
                "content": "It was quite hard for me to figure out the solution so I looked into the hints and as the hint #1 mentions -> ***For all elements to be greater than the threshold/length, the minimum element in the subarray must be greater than the threshold/length.***\\n\\nIf you read it a couple of times, you\\'ll say that it is an obvious statement. \\n\\nBut this statement also tells us that it would be easier to find the subarray length (if there exists a valid subarray that satisfies the condition), if we can find the minimum possible element of that subarray. Because, if we find the minimum element that satisfies the condition, then all elements in that subarray will also satisfy the condition.\\n\\nThis step shouldn\\'t be that difficult. Because we can loop over the given list and at each iteration, we can take the current index as the index of minimum element in the subarray.\\n\\nBut the difficult part is to efficiently find the length of the subarray that contains the current element and in that subarray, the current element is  also the minimum element.\\n\\nSo, now we have a new sub-problem -> \\n\\n\\tGiven an array. \\n\\tTake an element at index \"x\" and consider it to be the minimum element of a subarray. \\n\\tReturn the maximum length of that subarray\\n\\t\\n\\tExample -> nums = [1,3,4,3,1]\\n\\n\\tLet\\'s take the element \"1\" at index 0 as the minimum.\\n\\t\\n\\tThe subarray will be [1,3,4,3,1] because in this subarray, minimum element is \"1\"\\n\\t\\n\\tSimilarly, if we take element \"3\" at index = 1 as the minimum,\\n\\tthen subarray will be [3,4,3] because minimum element is \"3\"\\n\\t\\nDid you notice something? When we considered \"3\" as the minimum element\\nThen, on the left side, we couldn\\'t extend since there was \"1\" on the left which is already smaller than 3.\\n\\nBut on the right, we could extend to \"4\" and also to \"3\" because both are >= 3\\n\\nWe had to stop at \"1\" on the right because again, it is smaller than \"3\"\\n\\nIt means, if we take an element as minimum element of a subarray, then we can extend to left until we find a smaller element than it.\\nSimilarly, we can extend to right until we find a smaller element.\\n\\nAnd there are two ways to find this smaller element on left or right.\\n\\nFirst is the Brute Force Way where we have two nested for loops -> O(N^2)\\n\\nThe second is the Stack way where we can find the Nearest Smaller Element on Left & Nearest Smaller Element on Right -> O(N)\\n\\nIn this problem, the length of the list can be up to 10^5 so ofcourse O(N^2) solution will give TLE.\\n\\nHence, we have to use the Stack approach to find the NSL and NSR for the input list.\\n\\n\\tExample - \\n\\t\\n\\tnums = [1,3,4,3,1]\\n\\tNSL  = [-1, 0, 1, 0, -1]\\n\\tNSR  = [5, 4, 3, 4, 5]\\n\\t\\n\\t\\n\\tSo, lets loop over \"nums\"\\n\\t\\n\\tIn first iteration, we have index = 0 at which we have element = \"1\"\\n\\t\\n\\tThe Index of Nearest Smaller Element on Left is NSL[0] => -1\\n\\tThe Index of Nearest Smaller Element on Right is NSR[0] -> 5\\n\\t\\n\\tSo, the length of the subarray where \"1\" is minimum will be:\\n\\t\\t\\n\\t\\t= 5 - (-1) - 1 \\n\\t\\t= 5 + 1 - 1\\n\\t\\t= 5\\n\\t\\t\\n\\tSo, we now know that there is a subarray of length \"5\" with mininum element as nums[0]\\n\\t\\nNow read the very first line of this solution -\\n\\t\\n\\t\"For all elements to be greater than the threshold/length, \\n\\tthe minimum element in the subarray must be greater than the threshold/length\"\\n\\t\\nIt means, if nums[0] is greater than threshold / length\\nThen all elements in this subarray of length \"5\" also satisfy this condition.\\n\\t\\nHere, nums[0] = 1 and threshold / length = 6 / 5 => 1.2\\n\\t\\nSince 1 is not greater than 1.2, this subarray does not satisfy this condition.\\n\\t\\n\\tSo, we move to next element, that is nums[1] => 3\\n\\t\\n\\tFor nums[1], NSL[1] => 0 and NSR[1] => 4\\n\\t\\n\\tSo length of subarray where \"3\" is minimum element -> 4 - 0 - 1 => 3\\n\\t\\n\\tNow we check condition. Thershold is 6 and length of subarray (k) is 3\\n\\t\\n\\tthreshold / k => 2\\n\\t\\n\\tWe see that 3 is indeed > 2 \\n\\t\\n\\tSo it means, this subarray of length 3 with \"3\" as its minimum element is a valid subarray\\n\\t\\nHence, we return \"3\".\\n\\n\\n\\n```\\ndef validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        # Length of the list\\n        n = len(nums)\\n        \\n        \\n        # Nearest Smaller on Left\\n        NSL = [-1] * n\\n        stack = []\\n        \\n        for i in range(n):\\n            while stack and nums[stack[-1]] >= nums[i]: stack.pop()\\n                \\n            if stack: NSL[i] = stack[-1]\\n                \\n            stack.append(i)\\n            \\n        # Nearest Smaller on Right\\n        NSR = [n] * n\\n        stack = []\\n        \\n        for i in range(n - 1, -1, -1):\\n            while stack and nums[stack[-1]] >= nums[i]: stack.pop()\\n                \\n            if stack: NSR[i] = stack[-1]\\n                \\n            stack.append(i)\\n        \\n        # Now that we have NSL and NSR data HOW IS THIS HELPFUL?\\n        # If we take each element and consider it as minimum in any subarray\\n        # Then, we can easily get the length of that subarray by simply\\n        # checking the left and right boundaries to which the subarray will extend\\n        # Those boundaries are simply nearest smaller elements on left and right\\n        for i in range(n):\\n            # Left boundary\\n            leftBoundary = NSL[i]\\n            \\n            # Right boundary\\n            rightBoundary = NSR[i]\\n            \\n            # Length of the Subarray\\n            subarrayLength = rightBoundary - leftBoundary - 1\\n            \\n            # Check the condition\\n            if nums[i] > (threshold / subarrayLength): return subarrayLength\\n\\t\\t\\n\\t\\t# Such a subarray does not exist\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\ndef validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        # Length of the list\\n        n = len(nums)\\n        \\n        \\n        # Nearest Smaller on Left\\n        NSL = [-1] * n\\n        stack = []\\n        \\n        for i in range(n):\\n            while stack and nums[stack[-1]] >= nums[i]: stack.pop()\\n                \\n            if stack: NSL[i] = stack[-1]\\n                \\n            stack.append(i)\\n            \\n        # Nearest Smaller on Right\\n        NSR = [n] * n\\n        stack = []\\n        \\n        for i in range(n - 1, -1, -1):\\n            while stack and nums[stack[-1]] >= nums[i]: stack.pop()\\n                \\n            if stack: NSR[i] = stack[-1]\\n                \\n            stack.append(i)\\n        \\n        # Now that we have NSL and NSR data HOW IS THIS HELPFUL?\\n        # If we take each element and consider it as minimum in any subarray\\n        # Then, we can easily get the length of that subarray by simply\\n        # checking the left and right boundaries to which the subarray will extend\\n        # Those boundaries are simply nearest smaller elements on left and right\\n        for i in range(n):\\n            # Left boundary\\n            leftBoundary = NSL[i]\\n            \\n            # Right boundary\\n            rightBoundary = NSR[i]\\n            \\n            # Length of the Subarray\\n            subarrayLength = rightBoundary - leftBoundary - 1\\n            \\n            # Check the condition\\n            if nums[i] > (threshold / subarrayLength): return subarrayLength\\n\\t\\t\\n\\t\\t# Such a subarray does not exist\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3644936,
                "title": "java-solution-with-detailed-explanation-linear-time",
                "content": "# Intuition\\nFInd subarray with current element as the minimum. if minimum element passes the threshold test, the rest will.\\n\\n# Approach\\nTo find the subarray range with every element as the min, use monotonic stacks.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int validSubarraySize(int[] nums, int threshold) {\\n\\n        int n = nums.length;\\n\\n        Stack<Integer> stack = new Stack<>();\\n        int rightIndex[] = new int[n];\\n        Arrays.fill(rightIndex, n);\\n        for (int i = 0; i < n; ++i) {\\n            while (!stack.isEmpty() && nums[stack.peek()] > nums[i]) {\\n                rightIndex[stack.pop()] = i;\\n            }\\n            stack.add(i);\\n        }\\n        \\n        int leftIndex[] = new int[n];\\n        Arrays.fill(leftIndex, -1);\\n        stack.clear();\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (!stack.isEmpty() && nums[stack.peek()] > nums[i])\\n                leftIndex[stack.pop()] = i;\\n            stack.add(i);\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            int leftBound = leftIndex[i], rightBound = rightIndex[i];\\n            int leftCount = i - leftBound - 1, rightCount = rightBound - i - 1;\\n            if(nums[i] * (leftCount + rightCount + 1) > threshold){\\n                return leftCount + rightCount + 1;\\n            }\\n        }\\n        return -1;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int validSubarraySize(int[] nums, int threshold) {\\n\\n        int n = nums.length;\\n\\n        Stack<Integer> stack = new Stack<>();\\n        int rightIndex[] = new int[n];\\n        Arrays.fill(rightIndex, n);\\n        for (int i = 0; i < n; ++i) {\\n            while (!stack.isEmpty() && nums[stack.peek()] > nums[i]) {\\n                rightIndex[stack.pop()] = i;\\n            }\\n            stack.add(i);\\n        }\\n        \\n        int leftIndex[] = new int[n];\\n        Arrays.fill(leftIndex, -1);\\n        stack.clear();\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (!stack.isEmpty() && nums[stack.peek()] > nums[i])\\n                leftIndex[stack.pop()] = i;\\n            stack.add(i);\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            int leftBound = leftIndex[i], rightBound = rightIndex[i];\\n            int leftCount = i - leftBound - 1, rightCount = rightBound - i - 1;\\n            if(nums[i] * (leftCount + rightCount + 1) > threshold){\\n                return leftCount + rightCount + 1;\\n            }\\n        }\\n        return -1;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501564,
                "title": "simple-solution-using-next-greater-element-to-right-and-left",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int thresh) {\\n        int n=nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=(thresh/nums[i])+1;\\n        }\\n        \\n        \\n        vector<int>next(n,n);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i+1]>nums[i])next[i]=i+1;\\n            else\\n            {\\n                int k=next[i+1];\\n                while(k!=n && nums[i]>=nums[k])\\n                {\\n                    k=next[k];\\n                }\\n                next[i]=k;\\n            }\\n            if(next[i]-i>=nums[i])return nums[i];\\n        }\\n        \\n        \\n        vector<int>prev(n,-1);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i-1]>nums[i])prev[i]=i-1;\\n            else\\n            {\\n                int k=prev[i-1];\\n                while(k!=-1 && nums[i]>=nums[k])\\n                {\\n                    k=prev[k];\\n                }\\n                prev[i]=k;\\n            }\\n            if(i-prev[i]>=nums[i])return nums[i];\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int left=prev[i];\\n            int right=next[i];\\n            if(next[i]-prev[i]-1>=nums[i])return nums[i];\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int thresh) {\\n        int n=nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=(thresh/nums[i])+1;\\n        }\\n        \\n        \\n        vector<int>next(n,n);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i+1]>nums[i])next[i]=i+1;\\n            else\\n            {\\n                int k=next[i+1];\\n                while(k!=n && nums[i]>=nums[k])\\n                {\\n                    k=next[k];\\n                }\\n                next[i]=k;\\n            }\\n            if(next[i]-i>=nums[i])return nums[i];\\n        }\\n        \\n        \\n        vector<int>prev(n,-1);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i-1]>nums[i])prev[i]=i-1;\\n            else\\n            {\\n                int k=prev[i-1];\\n                while(k!=-1 && nums[i]>=nums[k])\\n                {\\n                    k=prev[k];\\n                }\\n                prev[i]=k;\\n            }\\n            if(i-prev[i]>=nums[i])return nums[i];\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int left=prev[i];\\n            int right=next[i];\\n            if(next[i]-prev[i]-1>=nums[i])return nums[i];\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445488,
                "title": "python-simple-stack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def validSubarraySize(self, nums, threshold):\\n        nums.append(0)\\n\\n        stack = []\\n\\n        for i in range(len(nums)):\\n            while stack and nums[stack[-1]] >= nums[i]:\\n              n = nums[stack.pop()]\\n              size = i if not stack else i-stack[-1]-1\\n              if n > threshold/size: return size\\n\\n            stack.append(i)\\n\\n        return -1\\n\\n        \\n\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validSubarraySize(self, nums, threshold):\\n        nums.append(0)\\n\\n        stack = []\\n\\n        for i in range(len(nums)):\\n            while stack and nums[stack[-1]] >= nums[i]:\\n              n = nums[stack.pop()]\\n              size = i if not stack else i-stack[-1]-1\\n              if n > threshold/size: return size\\n\\n            stack.append(i)\\n\\n        return -1\\n\\n        \\n\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442667,
                "title": "python-dsu-sorting",
                "content": "Time Complexity - O(n * log(n))\\nWe check for each k from 1 to n. Initially it looks like it will time out but we can optimize it to linear time by checking only those elements which are greater than threshold/k , any element once checked need not be checked again as threshold/k will keep decreasing as k increases.\\nActivated array means number at that index is activated (can form answer for all k till now).\\nNext we maintain a size array and take union with both adjacent elements if they were previously activated.If size returned by union function>=k, then k can be an answer.\\nOtherwise return -1\\n\\nCode:\\n```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        n=len(nums)\\n        parent=[i for i in range(n)]\\n        size=[1]*n\\n        activated=[0]*n\\n        def find(x):\\n            if x!=parent[x]:\\n                parent[x]=find(parent[x])\\n            return parent[x]\\n        def union(x,y):\\n            r1,r2=find(x),find(y)\\n            if r1!=r2:\\n                parent[r2]=r1\\n                size[r1]+=size[r2]\\n                size[r2]=size[r1]\\n            return size[r1]\\n        nums=[(val,i) for i,val in enumerate(nums)]\\n        nums=deque(sorted(nums,reverse=True))\\n        for k in range(1,n+1):\\n            mmax=threshold//k\\n            while nums[0][0]>mmax:\\n                val,idx=nums.popleft()\\n                activated[idx]=1\\n                size1,size2=1,1\\n                if idx>0 and activated[idx-1]:\\n                    size1=union(idx-1,idx)\\n                if idx<n-1 and activated[idx+1]:\\n                    size2=union(idx,idx+1)\\n                if max(size1,size2)>=k: return k\\n        return -1\\n            \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        n=len(nums)\\n        parent=[i for i in range(n)]\\n        size=[1]*n\\n        activated=[0]*n\\n        def find(x):\\n            if x!=parent[x]:\\n                parent[x]=find(parent[x])\\n            return parent[x]\\n        def union(x,y):\\n            r1,r2=find(x),find(y)\\n            if r1!=r2:\\n                parent[r2]=r1\\n                size[r1]+=size[r2]\\n                size[r2]=size[r1]\\n            return size[r1]\\n        nums=[(val,i) for i,val in enumerate(nums)]\\n        nums=deque(sorted(nums,reverse=True))\\n        for k in range(1,n+1):\\n            mmax=threshold//k\\n            while nums[0][0]>mmax:\\n                val,idx=nums.popleft()\\n                activated[idx]=1\\n                size1,size2=1,1\\n                if idx>0 and activated[idx-1]:\\n                    size1=union(idx-1,idx)\\n                if idx<n-1 and activated[idx+1]:\\n                    size2=union(idx,idx+1)\\n                if max(size1,size2)>=k: return k\\n        return -1\\n            \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434529,
                "title": "detailed-explained-o-n-log-n-approach-using-segment-tree",
                "content": "# Intuition\\n- For each subarray we need to check if any element is present with `value <= (threshold / sizeof(subarray))`\\n- If any such element is present then the subarray is not valid.\\n- Crucial part of this is to find such element **Time Complexity** will be **$$O(N)$$**.\\n- Also, there are `((N * (N + 1)) / 2)` subarrays are possible. So, overall T.C. may go upto **$$O(N^3)$$**.\\n- That\\'s the worst because of given constraints. $$(N <= 10^5)$$\\n- So, at max T.C. can be $$O(N)$$ or $$O(N * Log(N))$$\\n\\n## Optimization Step\\n- Rather to search an element with `value <= (threshold / size)` we find **minimum element** and check if it is `> (threshold / k)` or not.\\n- If it is `> (threshold / k)` then definitely the subarray is a valid answer since minimum element of this subarray is `> (threshold / k)`.\\n- Now here optimization cames up using **Segement Tree**. We can **use Segement Tree** to search for something in a range **with $$O(Log(N))$$ Time complexity**.\\n- Now still one may raise question that since ~$$N^2$$ subarrays are possible then T.C. will be ~$$O(N^2 * Log(N))$$.\\n- So we further optimize by following intuition,\\n    1. We will not go for $$N^2$$ subarrays, rather we start from given array as our answer.\\n    2. We try to find an element with `value <= (threshold / size)`. If found then this subarray is not a valid answer. But if this subarray is a valid answer then we return `size` from this step itself.\\n    3. Now if this subarray is not valid then we must found an `index` such that because of that `index` this subarray is not valid.\\n    4. Now, we apply this algorithm to subarrays `[i, (index - 1)]` and `[(index + 1), j]` considering whole subarray as `[i, j]` elements of the array.\\n\\n- This leads to decrease the **Time Complexity to $$O(N * Log(N))$$**.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Build segement tree on the given array such that it returns the **minimum element index** for the given range `[i, j]`.\\n- Start considering whole array as answer and apply steps 1-4 to find a valid subarray.\\n- store and return the answer.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N * Log(N))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(3 * N)$$ + $$O(N)$$\\n- $$O(3 * N)$$ is the space used for segment tree and $$O(N)$$ space is the stack space used because for sorted array tree will be either left-intended or right-intended. Hence, at max $$O(N)$$ stack space may be used.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    \\n    int segTree[300001];\\n    \\n    int buildTree(int l, int h, vector<int>& nums, int pos){\\n        if(l > h)\\n            return -1;\\n        if(l == h)\\n            return segTree[pos] = l;\\n        \\n        int mid = ((l + h) / 2);\\n        \\n        int left = buildTree(l, mid, nums, ((2 * pos) + 1));\\n        int right = buildTree((mid + 1), h, nums, ((2 * pos) + 2));\\n        \\n        if((right == -1) or (nums[left] < nums[right]))\\n            return segTree[pos] = left;\\n        else\\n            return segTree[pos] = right;\\n    }\\n    \\n    int findMin(int l, int h, int lb, int ub, int pos, vector<int>& nums){\\n        if(((l == lb) and (h == ub)) or (lb == ub))\\n            return segTree[pos];\\n        \\n        int mid = ((lb + ub) / 2);\\n        if(l > mid)\\n            return findMin(l, h, mid + 1, ub, ((2 * pos) + 2), nums);\\n        else if(h <= mid)\\n            return findMin(l, h, lb, mid, ((2 * pos) + 1), nums);\\n        \\n        int left = findMin(l, mid, lb, mid, ((2 * pos) + 1), nums);\\n        int right = findMin(mid + 1, h, (mid + 1), ub, ((2 * pos) + 2), nums);\\n\\n        return ((nums[left] < nums[right]) ? left : right);\\n    }\\n    \\n    int solve(int l, int h, vector<int>& nums, int& threshold){\\n        if(l > h)\\n            return -1;\\n        if(l == h)\\n            return ((nums[l] > threshold) ? 1 : -1);\\n        \\n        int mini = findMin(l, h, 0, (nums.size() - 1), 0, nums);\\n        \\n        if(nums[mini] > ((ll)(threshold) / (h - l + 1)))\\n            return (h - l + 1);\\n        \\n        int left = solve(l, (mini - 1), nums, threshold);\\n        int right = solve((mini + 1), h, nums, threshold);\\n        \\n        return max(left, right);\\n    }\\n    \\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        buildTree(0, (nums.size() - 1), nums, 0);\\n        return solve(0, (nums.size() - 1), nums, threshold);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    \\n    int segTree[300001];\\n    \\n    int buildTree(int l, int h, vector<int>& nums, int pos){\\n        if(l > h)\\n            return -1;\\n        if(l == h)\\n            return segTree[pos] = l;\\n        \\n        int mid = ((l + h) / 2);\\n        \\n        int left = buildTree(l, mid, nums, ((2 * pos) + 1));\\n        int right = buildTree((mid + 1), h, nums, ((2 * pos) + 2));\\n        \\n        if((right == -1) or (nums[left] < nums[right]))\\n            return segTree[pos] = left;\\n        else\\n            return segTree[pos] = right;\\n    }\\n    \\n    int findMin(int l, int h, int lb, int ub, int pos, vector<int>& nums){\\n        if(((l == lb) and (h == ub)) or (lb == ub))\\n            return segTree[pos];\\n        \\n        int mid = ((lb + ub) / 2);\\n        if(l > mid)\\n            return findMin(l, h, mid + 1, ub, ((2 * pos) + 2), nums);\\n        else if(h <= mid)\\n            return findMin(l, h, lb, mid, ((2 * pos) + 1), nums);\\n        \\n        int left = findMin(l, mid, lb, mid, ((2 * pos) + 1), nums);\\n        int right = findMin(mid + 1, h, (mid + 1), ub, ((2 * pos) + 2), nums);\\n\\n        return ((nums[left] < nums[right]) ? left : right);\\n    }\\n    \\n    int solve(int l, int h, vector<int>& nums, int& threshold){\\n        if(l > h)\\n            return -1;\\n        if(l == h)\\n            return ((nums[l] > threshold) ? 1 : -1);\\n        \\n        int mini = findMin(l, h, 0, (nums.size() - 1), 0, nums);\\n        \\n        if(nums[mini] > ((ll)(threshold) / (h - l + 1)))\\n            return (h - l + 1);\\n        \\n        int left = solve(l, (mini - 1), nums, threshold);\\n        int right = solve((mini + 1), h, nums, threshold);\\n        \\n        return max(left, right);\\n    }\\n    \\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        buildTree(0, (nums.size() - 1), nums, 0);\\n        return solve(0, (nums.size() - 1), nums, threshold);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367767,
                "title": "monotonic-stack-similar-to-leetcode-84-largest-histogram",
                "content": "\\t\\tin the subarray, every element is larger than threshold / k <=> smallest element is larger than threshold/ k\\n        smallest > threshold / k\\n        smallest * k > threshold\\n        \\n        similar to largest histogram problem \\n        https://leetcode.com/problems/largest-rectangle-in-histogram/\\n        https://leetcode.com/problems/maximum-score-of-a-good-subarray/\\n```\\nclass Solution {\\n    public int validSubarraySize(int[] nums, int threshold) {\\n        Deque<Integer> deque = new ArrayDeque<>();\\n        int n = nums.length;\\n        for(int i = 0; i <= n; i++){\\n            while(!deque.isEmpty() && (i == n || nums[deque.peek()] > nums[i])){\\n                int index = deque.pop();\\n                long curr = 0;\\n                if(deque.isEmpty()){\\n                    curr = nums[index] * (long)i;\\n                    if(curr > threshold) return i;\\n                }else{\\n                    curr = nums[index] * ((long)i - deque.peek() - 1);\\n                    if(curr > threshold) return i - deque.peek() - 1;\\n                }\\n            }\\n            deque.push(i);\\n        }\\n        return -1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int validSubarraySize(int[] nums, int threshold) {\\n        Deque<Integer> deque = new ArrayDeque<>();\\n        int n = nums.length;\\n        for(int i = 0; i <= n; i++){\\n            while(!deque.isEmpty() && (i == n || nums[deque.peek()] > nums[i])){\\n                int index = deque.pop();\\n                long curr = 0;\\n                if(deque.isEmpty()){\\n                    curr = nums[index] * (long)i;\\n                    if(curr > threshold) return i;\\n                }else{\\n                    curr = nums[index] * ((long)i - deque.peek() - 1);\\n                    if(curr > threshold) return i - deque.peek() - 1;\\n                }\\n            }\\n            deque.push(i);\\n        }\\n        return -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364525,
                "title": "find-subarray-with-elements-greater-than-varying-threshold",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first idea for how to solve this problem would be to go through all possible subarrays of length k and check if each element in each subarray is greater than threshold/k\\nHowever, this approach would have a time complexity of O(nk), which is not efficient for large input sizes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach for solving this problem\\xA0is to use two stacks to figure out where each element in the input array is on the left and right. Once we know the leftmost and rightmost indices for each element, we can check each element to find the first subarray that meets the condition.\\n\\nWe use a stack to keep track of the indices of elements that haven\\'t found their right index. This lets us figure out the leftmost and rightmost indices. We start by putting the index of the first element on the stack and going through the array one by one. For each element, we take the next element off the stack if it\\'s bigger than the current element and change the rightmost index of the next element to the current index. Then, we move the current index to the top of the stack.\\n\\nFor the rightmost indices, we use a similar method, but we go through the array in the opposite order.\\n\\nOnce we know the leftmost and rightmost indices, we can look at each element to find the first subarray that meets the condition. We use the leftmost and rightmost indices for each element to figure out how long the subarray is. If the average of the subarray is more than the threshold, we return the length of the subarray.\\n\\nWe return -1 if we\\'ve gone through the whole array and haven\\'t found a subarray that meets the condition.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThis method takes O(n) time because we have to go through the entire array of inputs twice: once to find the leftmost and rightmost indices and again to check each element.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nhis method uses O(n) space because we need to store two arrays, each of size n, to store the leftmost and rightmost indices of each element in the input array. Also, we need to use two stacks, each of which can be as big as n, to figure out the leftmost and rightmost indices. So, the total amount of space needed is O(3n) or O(n).\\n\\n# Code\\n```\\nclass Solution(object):\\n    def validSubarraySize(self, nums, threshold):\\n        # Get the length of the input array\\n        n = len(nums)\\n        # Create arrays to store the leftmost and rightmost indices of each element\\n        # such that the subarray between them has all elements greater than the current element\\n        lr = [n] * n\\n        rl = [-1] * n\\n\\n        # Use a stack to calculate lr\\n        s = []\\n        for i in range(n):\\n            # Pop elements from the stack while they are greater than the current element\\n            while s and nums[i] < nums[s[-1]]:\\n                lr[s[-1]] = i\\n                s.pop()\\n            # Push the current index onto the stack\\n            s.append(i)\\n\\n        # Use a stack to calculate rl\\n        s = []\\n        for i in range(n - 1, -1, -1):\\n            # Pop elements from the stack while they are greater than the current element\\n            while s and nums[i] < nums[s[-1]]:\\n                rl[s[-1]] = i\\n                s.pop()\\n            # Push the current index onto the stack\\n            s.append(i)\\n\\n        # Check each element to find the first subarray with an average greater than threshold\\n        for i in range(n):\\n            # Calculate the length of the subarray\\n            length = lr[i] - rl[i] - 1\\n            # Check if the subarray meets the condition\\n            if nums[i] * length > threshold:\\n                # Return the length of the subarray\\n                return length\\n\\n        # No subarray meets the condition\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def validSubarraySize(self, nums, threshold):\\n        # Get the length of the input array\\n        n = len(nums)\\n        # Create arrays to store the leftmost and rightmost indices of each element\\n        # such that the subarray between them has all elements greater than the current element\\n        lr = [n] * n\\n        rl = [-1] * n\\n\\n        # Use a stack to calculate lr\\n        s = []\\n        for i in range(n):\\n            # Pop elements from the stack while they are greater than the current element\\n            while s and nums[i] < nums[s[-1]]:\\n                lr[s[-1]] = i\\n                s.pop()\\n            # Push the current index onto the stack\\n            s.append(i)\\n\\n        # Use a stack to calculate rl\\n        s = []\\n        for i in range(n - 1, -1, -1):\\n            # Pop elements from the stack while they are greater than the current element\\n            while s and nums[i] < nums[s[-1]]:\\n                rl[s[-1]] = i\\n                s.pop()\\n            # Push the current index onto the stack\\n            s.append(i)\\n\\n        # Check each element to find the first subarray with an average greater than threshold\\n        for i in range(n):\\n            # Calculate the length of the subarray\\n            length = lr[i] - rl[i] - 1\\n            # Check if the subarray meets the condition\\n            if nums[i] * length > threshold:\\n                # Return the length of the subarray\\n                return length\\n\\n        # No subarray meets the condition\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334848,
                "title": "python-o-nlogn-union-set-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLarger elements have smaller K, we can remove them from large to small, and mark them as removed, if we have a removed region of length >= K, we have an answer, if all elements are removed, return no answer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the elements and mark index as removed, update K to be the minimal length required (which is monotonic increasing since the elements are decresing), then merge with left and right index if they are also removed, then check the length of the removed region.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSort: $$O(nlongn)$$\\nUnionSet: each find / union takes at most $$O(logn)$$ for at most n elements, so the time complexity is $$O(nlogn)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nunionSet with element counter: $$O(n)$$\\nset to store removed indexes: $$O(n)$$\\ntotal: $$O(n)$$\\n# Code\\n```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], lmt: int) -> int:\\n        d = [i for i in range(nums)]\\n        cnt = [1] * len(nums)\\n        vs = set()\\n        \\n        def find(x):\\n            tmp = d[x]\\n            while tmp != d[tmp]:\\n                tmp = d[tmp]\\n            d[x] = tmp\\n            return d[x]\\n        \\n        def union(x, y):\\n            p1, p2 = find(x), find(y)\\n            cnt[p1] += cnt[p2]\\n            d[p2] = p1\\n        \\n        crtK = 1\\n        for (v, i) in sorted([(v, i) for i, v in enumerate(nums)], reverse=True):\\n            crtK = max(crtK, math.ceil((lmt+0.1) / v))\\n            vs.add(i)\\n            if i - 1 in vs:\\n                union(i, i - 1)\\n            if i + 1 in vs:\\n                union(i, i + 1)\\n            if cnt[find(i)] >= crtK:\\n                return crtK\\n        return -1\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], lmt: int) -> int:\\n        d = [i for i in range(nums)]\\n        cnt = [1] * len(nums)\\n        vs = set()\\n        \\n        def find(x):\\n            tmp = d[x]\\n            while tmp != d[tmp]:\\n                tmp = d[tmp]\\n            d[x] = tmp\\n            return d[x]\\n        \\n        def union(x, y):\\n            p1, p2 = find(x), find(y)\\n            cnt[p1] += cnt[p2]\\n            d[p2] = p1\\n        \\n        crtK = 1\\n        for (v, i) in sorted([(v, i) for i, v in enumerate(nums)], reverse=True):\\n            crtK = max(crtK, math.ceil((lmt+0.1) / v))\\n            vs.add(i)\\n            if i - 1 in vs:\\n                union(i, i - 1)\\n            if i + 1 in vs:\\n                union(i, i + 1)\\n            if cnt[find(i)] >= crtK:\\n                return crtK\\n        return -1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326563,
                "title": "solution-using-a-stack-to-find-the-smallest-element-in-each-direction-step-by-step-with-example",
                "content": "# Intuition\\nOur strategy will be to calculate the next smaller element of each element in both the right and the left direction. This will give us the max size of the window of elements where this element is the smallest element in the window. Then we find if there is a window such that the smallest element is > threshold / k\\n\\nIn a plot, this is equivalent to trying to find peaks. Example 1 (nums = [1, 3, 4, 3, 1]) is plotted below with a horizontal line goint through the peak that is made from the second element - the peak goes from element 1 to element 3 (since the next smallest element is the last element).\\n\\n![Screenshot 2023-03-21 at 1.28.41 PM.png](https://assets.leetcode.com/users/images/3f13fbd7-bfc2-48b1-8c2c-3a1332a517c7_1679441355.0747392.png)\\n\\n# Approach\\n1. calculate next smaller element from left to right\\n2. calculate next smaller element from right to left\\n3. for each element determine the max window size where this element is the smallest\\n4. for window sizes 1 to nums.length find the min element of that window\\n5. for each k = window size see if the smallest element is greater than threshold / k\\n6. if so return k\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/*\\nOur strategy will be to calculate the next smaller element of each element in both\\nthe right and the left direction. This will give us the max size of the window of \\nelements where this element is the smallest element in the window. Then we find if\\nthere is a window such that the smallest element is > threshold / k\\n\\nTry plotting a graph of example two to see this better (we are finding peaks in the graph). \\n\\nThe steps to achieve this are:\\n1. calculate next smaller element from left to right\\n2. calculate next smaller element from right to left\\n3. for each element determine the max window size where this element is the smallest\\n4. for window sizes 1 to nums.length find the min element of that window\\n5. for each k = window size see if the smallest element is greater than threshold / k\\n6. if so return k\\n\\nThis solution is time complexity O(N) and space complexity O(N)\\n\\nBelow   ex. 1        nums = [1, 3, 4, 3, 1]\\n                threshold = 6\\n        ex. 2        nums = [6, 5, 6, 5, 8]\\n                threshold = 7\\n*/\\n\\nclass Solution {\\n    public int validSubarraySize(int[] nums, int threshold) {\\n        if(nums.length == 0)\\n            return -1;\\n\\n        Stack<Integer> s = new Stack();\\n        int[] right = new int[nums.length];\\n        int[] left = new int[nums.length];\\n        int[] winMin = new int[nums.length];\\n\\n        //1. calculate index of next smaller element to the right\\n        //  for ex. 1 [5, 4, 3, 4, 5]\\n        //  for ex. 2 [1, 5, 3, 5, 5]\\n        s.push(0);\\n        for(int i = 1; i < nums.length; i++) {\\n            if(nums[i] >= nums[s.peek()])\\n                s.push(i);\\n            else {\\n                while(!s.isEmpty() && nums[s.peek()] > nums[i]) {\\n                    int n = s.pop();\\n                    right[n] = i;\\n                }\\n                s.push(i);\\n            }\\n        }\\n        while(!s.isEmpty()) { \\n            int n = s.pop();\\n            right[n] = nums.length;\\n        }\\n\\n        //2. calculate next smaller element from right to left\\n        // for ex 1: [-1, 0, 1, 0, -1]\\n        // for ex 2: [-1, -1, 1, -1, 3]\\n        s.push(nums.length - 1);\\n        for(int i = nums.length - 2; i >= 0; i--) {\\n            if(!s.isEmpty() && nums[i] > nums[s.peek()])\\n                s.push(i);\\n            else { \\n                while(!s.isEmpty() && nums[s.peek()] > nums[i]) {\\n                    int n = s.pop();\\n                    left[n] = i;\\n                }\\n                s.push(i);\\n            }\\n        }\\n        while(!s.isEmpty()) { \\n            int n = s.pop();\\n            left[n] = -1;\\n        }\\n\\n        //  3. for each element determine the max window size where this element is the smallest\\n        //     for ex. 2:  \\n        //      left   = [-1, -1, 1, -1, 3]\\n        //      right  = [1,   5, 3,  5, 6]\\n        //          First calculate the maximum window where this element is the smallest element of the window.\\n        //          This is done by adding the number of indecies to the left of this element \\n        //              where this element is the smallest and the number to the right. Be careful to subtract\\n        //              1 since the current index is added twice\\n        //          For the 0th element:\\n        //              window size = (0 - (-1)) + (1 - 0) - 1 = - 1 = 1 + 1 - 1 = 1\\n        //          For the 1st element:\\n        //              window size = (1 - (-1)) + (5 - 1) - 1 = 2 + 4 - 1 = 5\\n        //          For the 2nd element:\\n        //              window size = (2 - 1) + (3 - 2) - 1 = 1 + 1 - 1 = 1\\n        //          For the 3rd element:\\n        //              window size = (3 - (-1)) + (4 - 3) - 1 = 4 + 2 - 1 = 5\\n        //          For the last element: \\n        //              window size = (4 - 3) + (5 - 4) - 1 = 1 + 1 - 1 = 1\\n        //          \\n        //          Then, based on the window size determine if this is the max smallest element of all windows \\n        //              this size element 0 denotes the window size 1 element n-1 window size n (step 4):\\n        //      winMin = [8, 0, 0, 0, 5] -> 0s denote that we did not find a window of that size that is smaller\\n        //                                  than the previous window of that size (i.e. we can trivially shorten\\n        //                                  the next larger window, so the actual resultin this case it would be 5\\n        //                                  for all 0s). \\n        for(int i=0; i<nums.length; i++) {\\n            int winSize = (i - left[i]) + (right[i] - i) - 1;\\n            if(winMin[winSize - 1] == 0 || nums[i] > winMin[winSize - 1])\\n                winMin[winSize - 1] = nums[i];\\n        }\\n\\n        //5. for each k = window size see if the smallest element is greater than threshold / k\\n        int prevMin = winMin[nums.length-1];\\n        for(int k=nums.length-1; k>=0; k--) { \\n            int smallestNumInWindow = Math.max(prevMin, winMin[k]);\\n            if(smallestNumInWindow > threshold / (k+1))\\n                return k+1;\\n        }\\n\\n        //No window of size k found such that every element is greater than threshold/k\\n        return -1; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nOur strategy will be to calculate the next smaller element of each element in both\\nthe right and the left direction. This will give us the max size of the window of \\nelements where this element is the smallest element in the window. Then we find if\\nthere is a window such that the smallest element is > threshold / k\\n\\nTry plotting a graph of example two to see this better (we are finding peaks in the graph). \\n\\nThe steps to achieve this are:\\n1. calculate next smaller element from left to right\\n2. calculate next smaller element from right to left\\n3. for each element determine the max window size where this element is the smallest\\n4. for window sizes 1 to nums.length find the min element of that window\\n5. for each k = window size see if the smallest element is greater than threshold / k\\n6. if so return k\\n\\nThis solution is time complexity O(N) and space complexity O(N)\\n\\nBelow   ex. 1        nums = [1, 3, 4, 3, 1]\\n                threshold = 6\\n        ex. 2        nums = [6, 5, 6, 5, 8]\\n                threshold = 7\\n*/\\n\\nclass Solution {\\n    public int validSubarraySize(int[] nums, int threshold) {\\n        if(nums.length == 0)\\n            return -1;\\n\\n        Stack<Integer> s = new Stack();\\n        int[] right = new int[nums.length];\\n        int[] left = new int[nums.length];\\n        int[] winMin = new int[nums.length];\\n\\n        //1. calculate index of next smaller element to the right\\n        //  for ex. 1 [5, 4, 3, 4, 5]\\n        //  for ex. 2 [1, 5, 3, 5, 5]\\n        s.push(0);\\n        for(int i = 1; i < nums.length; i++) {\\n            if(nums[i] >= nums[s.peek()])\\n                s.push(i);\\n            else {\\n                while(!s.isEmpty() && nums[s.peek()] > nums[i]) {\\n                    int n = s.pop();\\n                    right[n] = i;\\n                }\\n                s.push(i);\\n            }\\n        }\\n        while(!s.isEmpty()) { \\n            int n = s.pop();\\n            right[n] = nums.length;\\n        }\\n\\n        //2. calculate next smaller element from right to left\\n        // for ex 1: [-1, 0, 1, 0, -1]\\n        // for ex 2: [-1, -1, 1, -1, 3]\\n        s.push(nums.length - 1);\\n        for(int i = nums.length - 2; i >= 0; i--) {\\n            if(!s.isEmpty() && nums[i] > nums[s.peek()])\\n                s.push(i);\\n            else { \\n                while(!s.isEmpty() && nums[s.peek()] > nums[i]) {\\n                    int n = s.pop();\\n                    left[n] = i;\\n                }\\n                s.push(i);\\n            }\\n        }\\n        while(!s.isEmpty()) { \\n            int n = s.pop();\\n            left[n] = -1;\\n        }\\n\\n        //  3. for each element determine the max window size where this element is the smallest\\n        //     for ex. 2:  \\n        //      left   = [-1, -1, 1, -1, 3]\\n        //      right  = [1,   5, 3,  5, 6]\\n        //          First calculate the maximum window where this element is the smallest element of the window.\\n        //          This is done by adding the number of indecies to the left of this element \\n        //              where this element is the smallest and the number to the right. Be careful to subtract\\n        //              1 since the current index is added twice\\n        //          For the 0th element:\\n        //              window size = (0 - (-1)) + (1 - 0) - 1 = - 1 = 1 + 1 - 1 = 1\\n        //          For the 1st element:\\n        //              window size = (1 - (-1)) + (5 - 1) - 1 = 2 + 4 - 1 = 5\\n        //          For the 2nd element:\\n        //              window size = (2 - 1) + (3 - 2) - 1 = 1 + 1 - 1 = 1\\n        //          For the 3rd element:\\n        //              window size = (3 - (-1)) + (4 - 3) - 1 = 4 + 2 - 1 = 5\\n        //          For the last element: \\n        //              window size = (4 - 3) + (5 - 4) - 1 = 1 + 1 - 1 = 1\\n        //          \\n        //          Then, based on the window size determine if this is the max smallest element of all windows \\n        //              this size element 0 denotes the window size 1 element n-1 window size n (step 4):\\n        //      winMin = [8, 0, 0, 0, 5] -> 0s denote that we did not find a window of that size that is smaller\\n        //                                  than the previous window of that size (i.e. we can trivially shorten\\n        //                                  the next larger window, so the actual resultin this case it would be 5\\n        //                                  for all 0s). \\n        for(int i=0; i<nums.length; i++) {\\n            int winSize = (i - left[i]) + (right[i] - i) - 1;\\n            if(winMin[winSize - 1] == 0 || nums[i] > winMin[winSize - 1])\\n                winMin[winSize - 1] = nums[i];\\n        }\\n\\n        //5. for each k = window size see if the smallest element is greater than threshold / k\\n        int prevMin = winMin[nums.length-1];\\n        for(int k=nums.length-1; k>=0; k--) { \\n            int smallestNumInWindow = Math.max(prevMin, winMin[k]);\\n            if(smallestNumInWindow > threshold / (k+1))\\n                return k+1;\\n        }\\n\\n        //No window of size k found such that every element is greater than threshold/k\\n        return -1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318234,
                "title": "c-using-monotonic-stack",
                "content": "Just use the hints \\n\\n```\\npublic class Solution {\\n    public int ValidSubarraySize(int[] nums, int threshold) {\\n        Stack<int> st=new Stack<int>();\\n        int min=int.MinValue;\\n        int n=nums.Length;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.Count>0 && nums[i]>nums[st.Peek()])\\n            {\\n                st.Push(i);\\n            }\\n            else{\\n                while(st.Count>0 && nums[st.Peek()]>=nums[i])\\n                {\\n                    decimal prevmin=(decimal)nums[st.Pop()];\\n                    int k=i-(st.Count>0 ? st.Peek() : -1)-1;\\n                    if (prevmin>((decimal)threshold/k))\\n                        return k;\\n                }\\n                st.Push(i);\\n            }\\n        }\\n        \\n        while(st.Count>0 )\\n        {\\n                    decimal prevmin=(decimal)nums[st.Pop()];\\n                    int k=n-(st.Count>0 ? st.Peek() : -1)-1;\\n                    if (prevmin>((decimal)threshold/k))\\n                        return k;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int ValidSubarraySize(int[] nums, int threshold) {\\n        Stack<int> st=new Stack<int>();\\n        int min=int.MinValue;\\n        int n=nums.Length;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.Count>0 && nums[i]>nums[st.Peek()])\\n            {\\n                st.Push(i);\\n            }\\n            else{\\n                while(st.Count>0 && nums[st.Peek()]>=nums[i])\\n                {\\n                    decimal prevmin=(decimal)nums[st.Pop()];\\n                    int k=i-(st.Count>0 ? st.Peek() : -1)-1;\\n                    if (prevmin>((decimal)threshold/k))\\n                        return k;\\n                }\\n                st.Push(i);\\n            }\\n        }\\n        \\n        while(st.Count>0 )\\n        {\\n                    decimal prevmin=(decimal)nums[st.Pop()];\\n                    int k=n-(st.Count>0 ? st.Peek() : -1)-1;\\n                    if (prevmin>((decimal)threshold/k))\\n                        return k;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311328,
                "title": "c-mono-stack-95-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int t) {\\n        stack<int> stk;\\n        float th=t;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            while(stk.size()  && nums[i]<=nums[stk.top()]){\\n                int mid=stk.top();\\n                stk.pop();\\n                int ans=((stk.size())?stk.top():nums.size())-i-1;\\n                if(nums[mid]>th/ans) return ans;\\n            }\\n            stk.push(i);\\n        }\\n        int x=-1;\\n        while(stk.size()){\\n            int mid=stk.top();\\n            \\n            stk.pop();\\n            int ans=((stk.size())?stk.top():nums.size())-x-1;\\n            if(nums[mid]>th/ans) return ans;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int t) {\\n        stack<int> stk;\\n        float th=t;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            while(stk.size()  && nums[i]<=nums[stk.top()]){\\n                int mid=stk.top();\\n                stk.pop();\\n                int ans=((stk.size())?stk.top():nums.size())-i-1;\\n                if(nums[mid]>th/ans) return ans;\\n            }\\n            stk.push(i);\\n        }\\n        int x=-1;\\n        while(stk.size()){\\n            int mid=stk.top();\\n            \\n            stk.pop();\\n            int ans=((stk.size())?stk.top():nums.size())-x-1;\\n            if(nums[mid]>th/ans) return ans;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268237,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn valid_subarray_size(nums: Vec<i32>, threshold: i32) -> i32 {\\n        let mut st = vec![];\\n        let mut nums = nums;\\n        nums.push(0);\\n        for i in 0..nums.len() {\\n            while !st.is_empty() && nums[i] < nums[st[st.len() - 1]] {\\n                let val = nums[st[st.len() - 1]];\\n                st.pop();\\n                let j = if st.is_empty() { -1 } else { st[st.len() - 1] as i32 };\\n                if val > threshold / (i as i32 - j - 1) {\\n                    return i as i32 - j - 1;\\n                }\\n            }\\n            st.push(i);\\n        }\\n        -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn valid_subarray_size(nums: Vec<i32>, threshold: i32) -> i32 {\\n        let mut st = vec![];\\n        let mut nums = nums;\\n        nums.push(0);\\n        for i in 0..nums.len() {\\n            while !st.is_empty() && nums[i] < nums[st[st.len() - 1]] {\\n                let val = nums[st[st.len() - 1]];\\n                st.pop();\\n                let j = if st.is_empty() { -1 } else { st[st.len() - 1] as i32 };\\n                if val > threshold / (i as i32 - j - 1) {\\n                    return i as i32 - j - 1;\\n                }\\n            }\\n            st.push(i);\\n        }\\n        -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3257665,
                "title": "c-monotonic-stack",
                "content": "for eath nums[i], find the longest subarray where nums[i] is the minimum. \\n\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        const int n = nums.size();\\n        auto leftLens = leftLen(nums), rightLens = rightLen(nums);\\n        vector<int> vlen(n);\\n        for(int i=0;i<n;i++) vlen[i] = leftLens[i] + 1 + rightLens[i];\\n        for(int i=0;i<n;i++){\\n            int k = vlen[i];\\n            if(nums[i] > threshold/k) return k;\\n        }\\n        return -1;\\n    }\\n\\n    vector<int> leftLen(vector<int>& v){\\n        vector<int> leftLens;\\n        stack<int> st;\\n        for(int i=0;i<v.size();i++){\\n            while(!st.empty() && v[st.top()] >= v[i]) st.pop();\\n            int leftLen = i;\\n            if(!st.empty()) leftLen -= 1+st.top();\\n            leftLens.push_back(leftLen); \\n            st.push(i);\\n        }\\n        return leftLens;\\n    }\\n\\n    vector<int> rightLen(vector<int>& v){\\n        reverse(v.begin(), v.end());\\n        auto res = leftLen(v);\\n        reverse(v.begin(), v.end());\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        const int n = nums.size();\\n        auto leftLens = leftLen(nums), rightLens = rightLen(nums);\\n        vector<int> vlen(n);\\n        for(int i=0;i<n;i++) vlen[i] = leftLens[i] + 1 + rightLens[i];\\n        for(int i=0;i<n;i++){\\n            int k = vlen[i];\\n            if(nums[i] > threshold/k) return k;\\n        }\\n        return -1;\\n    }\\n\\n    vector<int> leftLen(vector<int>& v){\\n        vector<int> leftLens;\\n        stack<int> st;\\n        for(int i=0;i<v.size();i++){\\n            while(!st.empty() && v[st.top()] >= v[i]) st.pop();\\n            int leftLen = i;\\n            if(!st.empty()) leftLen -= 1+st.top();\\n            leftLens.push_back(leftLen); \\n            st.push(i);\\n        }\\n        return leftLens;\\n    }\\n\\n    vector<int> rightLen(vector<int>& v){\\n        reverse(v.begin(), v.end());\\n        auto res = leftLen(v);\\n        reverse(v.begin(), v.end());\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197447,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int limit) {\\n\\n        int n=nums.size();\\n\\n        vector<int> ls(n,-1);\\n        vector<int> rs(n,n);\\n\\n        stack<pair<int,int>> st;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n\\n            while(!st.empty() and st.top().first>=nums[i])\\n            {\\n                st.pop();\\n            }\\n\\n            if(!st.empty())\\n            {\\n                ls[i]=st.top().second;\\n            }\\n\\n            st.push({nums[i],i});\\n\\n        }\\n\\n        while(!st.empty()){st.pop();}\\n\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            \\n            while(!st.empty() and st.top().first>=nums[i])\\n            {\\n                st.pop();\\n            }\\n\\n            if(!st.empty())\\n            {\\n                rs[i]=st.top().second;\\n            }\\n\\n            st.push({nums[i],i});\\n\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n\\n            int right=rs[i]-i-1;\\n            int left=i-ls[i]-1;\\n\\n            int length=1+right+left;\\n\\n            int val=limit/length;\\n\\n            if(val<nums[i])\\n            {\\n                return length;\\n            }\\n\\n        }\\n\\n    return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int limit) {\\n\\n        int n=nums.size();\\n\\n        vector<int> ls(n,-1);\\n        vector<int> rs(n,n);\\n\\n        stack<pair<int,int>> st;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n\\n            while(!st.empty() and st.top().first>=nums[i])\\n            {\\n                st.pop();\\n            }\\n\\n            if(!st.empty())\\n            {\\n                ls[i]=st.top().second;\\n            }\\n\\n            st.push({nums[i],i});\\n\\n        }\\n\\n        while(!st.empty()){st.pop();}\\n\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            \\n            while(!st.empty() and st.top().first>=nums[i])\\n            {\\n                st.pop();\\n            }\\n\\n            if(!st.empty())\\n            {\\n                rs[i]=st.top().second;\\n            }\\n\\n            st.push({nums[i],i});\\n\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n\\n            int right=rs[i]-i-1;\\n            int left=i-ls[i]-1;\\n\\n            int length=1+right+left;\\n\\n            int val=limit/length;\\n\\n            if(val<nums[i])\\n            {\\n                return length;\\n            }\\n\\n        }\\n\\n    return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024829,
                "title": "union-find-full-explanation-python",
                "content": "**Intuition**\\nThere are two obvious conditions:\\n`if max(nums) > threshold: return 1`\\n`if max(nums) <= threshold/len(nums): return -1`\\n\\nif we have some group of elements, eg {5,0,1,4,3},\\n**How to find the length of largest continuous sequence?**, {3,4,5} => 3\\nWe can use the **Union Find** data structure to union neighbour elements and keep track of size of all the disjoint sets.\\n\\n**Approach**\\nLets reverse sort nums (keep track of index for each element).\\ninitially set `k = 1` and start iterating nums (largest element first)\\nif `nums[i]*k <= threshold`, **k must increase**, set `k = threshold//x + 1`\\nin this manner `k` is minimised.\\n\\nAs you iterate, keep applying the union operation on neighbouring index elements (if you have already come across neighbours)\\n\\nif the current element belongs to a group whose size >= k, then return k.\\n\\n**Time: O(n log n)\\nSpace: O(n)**\\n```\\ndef validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n    parents = dict()\\n    size = [1]*len(nums)\\n\\n    def find(i):\\n        if parents[i] != i:\\n            parents[i] = find(parents[i])\\n        return parents[i]\\n    def union(i, j):\\n        if j not in parents:\\n            return 1\\n        p_i = find(i); p_j = find(j)\\n        parents[p_j] = p_i\\n        size[p_i] += size[p_j]\\n        return size[p_i]\\n    \\n    nums = sorted([[x,i] for i,x in enumerate(nums)], reverse=True)\\n    k = 1\\n    for x,i in nums:            \\n        if k*x <= threshold:\\n            k = threshold//x + 1\\n\\n        parents[i] = i\\n        if max(union(i, i+1), union(i, i-1)) >= k:\\n            return k\\n    \\n    return -1  \\n```",
                "solutionTags": [
                    "Python",
                    "Union Find",
                    "Sorting"
                ],
                "code": "```\\ndef validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n    parents = dict()\\n    size = [1]*len(nums)\\n\\n    def find(i):\\n        if parents[i] != i:\\n            parents[i] = find(parents[i])\\n        return parents[i]\\n    def union(i, j):\\n        if j not in parents:\\n            return 1\\n        p_i = find(i); p_j = find(j)\\n        parents[p_j] = p_i\\n        size[p_i] += size[p_j]\\n        return size[p_i]\\n    \\n    nums = sorted([[x,i] for i,x in enumerate(nums)], reverse=True)\\n    k = 1\\n    for x,i in nums:            \\n        if k*x <= threshold:\\n            k = threshold//x + 1\\n\\n        parents[i] = i\\n        if max(union(i, i+1), union(i, i-1)) >= k:\\n            return k\\n    \\n    return -1  \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2877536,
                "title": "python-monotonic-stack",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n# Code\\n```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n\\n        nums.append(0)\\n        nums.insert(0,0)\\n        stack = []\\n\\n        for i in range(len(nums)):\\n\\n            while stack and nums[stack[-1]] > nums[i]:\\n                h = nums[stack.pop()]\\n                if not stack:\\n                    continue\\n                k = i-stack[-1]-1\\n                if h > threshold//k:\\n                    return k\\n            stack.append(i)\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n\\n        nums.append(0)\\n        nums.insert(0,0)\\n        stack = []\\n\\n        for i in range(len(nums)):\\n\\n            while stack and nums[stack[-1]] > nums[i]:\\n                h = nums[stack.pop()]\\n                if not stack:\\n                    continue\\n                k = i-stack[-1]-1\\n                if h > threshold//k:\\n                    return k\\n            stack.append(i)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869318,
                "title": "c-monotonic-stack-using-nsl-nsr",
                "content": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int N = nums.size();\\n        vector<int> NSL(N,-1);\\n        stack<int> St;\\n        for(int i=N-1;i>=0;i--){\\n            while(!St.empty() && nums[i] < nums[St.top()]){\\n                int ele = St.top();\\n                St.pop();\\n                \\n                NSL[ele] = i;\\n            }\\n            St.push(i);\\n        }\\n      \\n        while(!St.empty()) St.pop();\\n        \\n        vector<int> NSR(N,N);\\n        for(int i=0;i<N;i++){\\n            while(!St.empty() && nums[i] < nums[St.top()]){\\n                int ele = St.top();\\n                St.pop();\\n                \\n                NSR[ele] = i;\\n            }\\n            St.push(i);\\n        }\\n    \\n        for(int i=0;i<N;i++){\\n            int len = NSR[i]-NSL[i]-1; //length of subarray for which nums[i] is smallest\\n            int ele = threshold/len; //calculating per nums[i] threshold\\n            \\n            if(nums[i] > ele) return len; // if nums[i]>threshold then all others will be larger too \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int N = nums.size();\\n        vector<int> NSL(N,-1);\\n        stack<int> St;\\n        for(int i=N-1;i>=0;i--){\\n            while(!St.empty() && nums[i] < nums[St.top()]){\\n                int ele = St.top();\\n                St.pop();\\n                \\n                NSL[ele] = i;\\n            }\\n            St.push(i);\\n        }\\n      \\n        while(!St.empty()) St.pop();\\n        \\n        vector<int> NSR(N,N);\\n        for(int i=0;i<N;i++){\\n            while(!St.empty() && nums[i] < nums[St.top()]){\\n                int ele = St.top();\\n                St.pop();\\n                \\n                NSR[ele] = i;\\n            }\\n            St.push(i);\\n        }\\n    \\n        for(int i=0;i<N;i++){\\n            int len = NSR[i]-NSL[i]-1; //length of subarray for which nums[i] is smallest\\n            int ele = threshold/len; //calculating per nums[i] threshold\\n            \\n            if(nums[i] > ele) return len; // if nums[i]>threshold then all others will be larger too \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797465,
                "title": "simple-c-soln-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        \\n        if(nums.size()>threshold)\\n            return nums.size();\\n        \\n        int n=nums.size();\\n        \\n        vector<int> right(n,n-1),left(n,0);\\n        stack<pair<int,int>> mad,sad;\\n        for(int i=(n-1);i>=0;i--)\\n        {\\n            if(!mad.empty())\\n            {\\n                while(!mad.empty())\\n                {\\n                    if(nums[i]<=mad.top().first)\\n                    {\\n                        mad.pop();\\n                    }\\n                    else{\\n                        right[i]=mad.top().second-1;\\n                        mad.push({nums[i],i});\\n                        break;\\n                    }\\n                }\\n                if(mad.empty())\\n                {\\n                    mad.push({nums[i],i});\\n                }\\n            }\\n            else{\\n                mad.push({nums[i],i});\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(!sad.empty())\\n            {\\n                while(!sad.empty())\\n                {\\n                    if(nums[i]<=sad.top().first)\\n                    {\\n                        sad.pop();\\n                    }\\n                    else{\\n                        left[i]=sad.top().second+1;\\n                        sad.push({nums[i],i});\\n                        break;\\n                    }\\n                }\\n                \\n                if(sad.empty())\\n                {\\n                    sad.push({nums[i],i});\\n                }\\n                \\n                \\n            }\\n            else{\\n                sad.push({nums[i],i});\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int v=right[i]-left[i]+1;\\n            int q=threshold/v;\\n            if(nums[i]>q)\\n                return v;\\n        }\\n        \\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        \\n        if(nums.size()>threshold)\\n            return nums.size();\\n        \\n        int n=nums.size();\\n        \\n        vector<int> right(n,n-1),left(n,0);\\n        stack<pair<int,int>> mad,sad;\\n        for(int i=(n-1);i>=0;i--)\\n        {\\n            if(!mad.empty())\\n            {\\n                while(!mad.empty())\\n                {\\n                    if(nums[i]<=mad.top().first)\\n                    {\\n                        mad.pop();\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2760939,
                "title": "clean-java-solution-using-stack-approach",
                "content": "#### BruteForce\\nThe bruteforce way is to create all subarrays and then find the subarray which satisfies the condition. \\nTime it takes to create all subarrays is O(n^2). Inside every subarray creation loop we may also want to check the min of each subarray and verify if the \\n[min(subarray) > [threshold / subarray.length)]. This takes another O(n) time complexity. So in total it will be O(n^3).\\n\\n#### Stack\\nIn the above process, what we really care about is the min of each subarray and length of the subarray. We do not care about other elements present inside the subarrays. We can optimise the above approach using Stack based solution. \\nFor every index i in nums, find the prevSmaller element and nextSmaller index. With those values, we can find the \\n   **The max length of the subarray including the current element as min**\\n\\n```\\nclass Solution {\\n    public int validSubarraySize(int[] nums, int threshold) {\\n        int[] prevLow = buildPrevLowestIndex(nums);\\n        int[] nextLow = buildNextLowestIndex(nums);\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            int minValue = nums[i];\\n            int totalLengthWithCurrentMinValue = nextLow[i] - prevLow[i] - 1;\\n            if (minValue > threshold / totalLengthWithCurrentMinValue) {\\n                return totalLengthWithCurrentMinValue;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public int[] buildPrevLowestIndex(int[] nums) {\\n        Stack<Integer> stack = new Stack<>();\\n        int index = nums.length - 1;\\n        int[] prevLowIndex = new int[nums.length];\\n\\n        Arrays.fill(prevLowIndex, -1);\\n        while (index >= 0) {\\n            while (!stack.isEmpty() && nums[stack.peek()] > nums[index]) {\\n                prevLowIndex[stack.peek()] = index;\\n                stack.pop();\\n            }\\n            stack.push(index);\\n            index--;\\n        }\\n        return prevLowIndex;\\n    }\\n\\n    public int[] buildNextLowestIndex(int[] nums) {\\n        Stack<Integer> stack = new Stack<>();\\n        int[] nextLowestIndexes = new int[nums.length];\\n        Arrays.fill(nextLowestIndexes, nums.length);\\n        int index = 0;\\n        stack.push(index);\\n        while (index < nums.length) {\\n            while (!stack.isEmpty() && nums[stack.peek()] > nums[index]) {\\n                nextLowestIndexes[stack.peek()] = index;\\n                stack.pop();\\n            }\\n            stack.push(index);\\n            index++;\\n        }\\n        return nextLowestIndexes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int validSubarraySize(int[] nums, int threshold) {\\n        int[] prevLow = buildPrevLowestIndex(nums);\\n        int[] nextLow = buildNextLowestIndex(nums);\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            int minValue = nums[i];\\n            int totalLengthWithCurrentMinValue = nextLow[i] - prevLow[i] - 1;\\n            if (minValue > threshold / totalLengthWithCurrentMinValue) {\\n                return totalLengthWithCurrentMinValue;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public int[] buildPrevLowestIndex(int[] nums) {\\n        Stack<Integer> stack = new Stack<>();\\n        int index = nums.length - 1;\\n        int[] prevLowIndex = new int[nums.length];\\n\\n        Arrays.fill(prevLowIndex, -1);\\n        while (index >= 0) {\\n            while (!stack.isEmpty() && nums[stack.peek()] > nums[index]) {\\n                prevLowIndex[stack.peek()] = index;\\n                stack.pop();\\n            }\\n            stack.push(index);\\n            index--;\\n        }\\n        return prevLowIndex;\\n    }\\n\\n    public int[] buildNextLowestIndex(int[] nums) {\\n        Stack<Integer> stack = new Stack<>();\\n        int[] nextLowestIndexes = new int[nums.length];\\n        Arrays.fill(nextLowestIndexes, nums.length);\\n        int index = 0;\\n        stack.push(index);\\n        while (index < nums.length) {\\n            while (!stack.isEmpty() && nums[stack.peek()] > nums[index]) {\\n                nextLowestIndexes[stack.peek()] = index;\\n                stack.pop();\\n            }\\n            stack.push(index);\\n            index++;\\n        }\\n        return nextLowestIndexes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736439,
                "title": "monotonic-stack-fenwick-tree",
                "content": "should be n * logn * logn in the worst case \\n```\\n#define N 100005\\nclass Solution {\\npublic:\\n    int a[N+1];\\n    int n;\\n    \\n    int lowbit(int x) {return x&(-x);}\\n    \\n    int query(int x) {\\n        int ans = 0x3f3f3f3f;\\n        while(x >= 1) {\\n            ans = min(ans, a[x]);\\n            x -= lowbit(x);\\n        }\\n        return ans;\\n    }\\n    \\n    void update(int x, int val) {\\n        while(x <= n) {\\n            a[x] = val;\\n            int l = lowbit(x);\\n            for (int i = 1; i < l; i <<= 1) {\\n                a[x] = min(a[x-i], a[x]);\\n            }\\n            x += l;\\n        }\\n    }\\n    \\n    \\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        vector<int> q;\\n        vector<int> l;\\n        n = nums.size()+3;\\n        int idx = -1;\\n        fill(a, a+N+1, 0x3f3f3f3f);\\n        int m = 0x3f3f3f3f;\\n        for (int i = 0; i <nums.size(); i++) {\\n            while(!q.empty() and nums[q.back()] >= nums[i]) {\\n                q.pop_back();\\n                l.pop_back();\\n                update(l.size()+1, 0x3f3f3f3f);\\n            }\\n            int tmp = threshold/nums[i]+(threshold<nums[i]?0:1)+(q.empty()?0:q.back());\\n            l.push_back(tmp);\\n            update(l.size(), tmp);\\n            m = query(l.size());\\n            q.push_back(i);\\n            if (i >= m) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n        if (idx != -1) {\\n           for (int i = 0; i < q.size(); i++) {\\n                if (l[i] == m) return idx - (i==0?-1:q[i-1]);\\n            } \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define N 100005\\nclass Solution {\\npublic:\\n    int a[N+1];\\n    int n;\\n    \\n    int lowbit(int x) {return x&(-x);}\\n    \\n    int query(int x) {\\n        int ans = 0x3f3f3f3f;\\n        while(x >= 1) {\\n            ans = min(ans, a[x]);\\n            x -= lowbit(x);\\n        }\\n        return ans;\\n    }\\n    \\n    void update(int x, int val) {\\n        while(x <= n) {\\n            a[x] = val;\\n            int l = lowbit(x);\\n            for (int i = 1; i < l; i <<= 1) {\\n                a[x] = min(a[x-i], a[x]);\\n            }\\n            x += l;\\n        }\\n    }\\n    \\n    \\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        vector<int> q;\\n        vector<int> l;\\n        n = nums.size()+3;\\n        int idx = -1;\\n        fill(a, a+N+1, 0x3f3f3f3f);\\n        int m = 0x3f3f3f3f;\\n        for (int i = 0; i <nums.size(); i++) {\\n            while(!q.empty() and nums[q.back()] >= nums[i]) {\\n                q.pop_back();\\n                l.pop_back();\\n                update(l.size()+1, 0x3f3f3f3f);\\n            }\\n            int tmp = threshold/nums[i]+(threshold<nums[i]?0:1)+(q.empty()?0:q.back());\\n            l.push_back(tmp);\\n            update(l.size(), tmp);\\n            m = query(l.size());\\n            q.push_back(i);\\n            if (i >= m) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n        if (idx != -1) {\\n           for (int i = 0; i < q.size(); i++) {\\n                if (l[i] == m) return idx - (i==0?-1:q[i-1]);\\n            } \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703918,
                "title": "c-monotonic-stack-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int N = nums.size();\\n        vector<int> left(N,-1);\\n        stack<int> St;\\n        for(int i=N-1;i>=0;i--){\\n            while(!St.empty() && nums[i] < nums[St.top()]){\\n                int ele = St.top();\\n                St.pop();\\n                \\n                left[ele] = i;\\n            }\\n            St.push(i);\\n        }\\n      \\n        while(!St.empty()) St.pop();\\n        \\n        vector<int> right(N,N);\\n        for(int i=0;i<N;i++){\\n            while(!St.empty() && nums[i] < nums[St.top()]){\\n                int ele = St.top();\\n                St.pop();\\n                \\n                right[ele] = i;\\n            }\\n            St.push(i);\\n        }\\n    \\n        for(int i=0;i<N;i++){\\n            int len = right[i]-left[i]-1;\\n            int ele = threshold/len;\\n            \\n            if(nums[i] > ele) return len;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int N = nums.size();\\n        vector<int> left(N,-1);\\n        stack<int> St;\\n        for(int i=N-1;i>=0;i--){\\n            while(!St.empty() && nums[i] < nums[St.top()]){\\n                int ele = St.top();\\n                St.pop();\\n                \\n                left[ele] = i;\\n            }\\n            St.push(i);\\n        }\\n      \\n        while(!St.empty()) St.pop();\\n        \\n        vector<int> right(N,N);\\n        for(int i=0;i<N;i++){\\n            while(!St.empty() && nums[i] < nums[St.top()]){\\n                int ele = St.top();\\n                St.pop();\\n                \\n                right[ele] = i;\\n            }\\n            St.push(i);\\n        }\\n    \\n        for(int i=0;i<N;i++){\\n            int len = right[i]-left[i]-1;\\n            int ele = threshold/len;\\n            \\n            if(nums[i] > ele) return len;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699953,
                "title": "cpp-simple-monotonic-stack",
                "content": "Check for every element (say ```ar[i]```), what is the size of the longest subarray where it is the smallest element. Let the size be ```k```. If ```ar[i]```*```k```>=```threshold```, we found a subarray, so return its size, else return -1.\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n#define pb push_back\\n#define mii map<int, int>\\n#define mll map<ll, ll>\\n#define pii pair<int, int>\\n#define pic pair<int, char>\\n#define pdd pair<double, double>\\n#define pll pair<ll, ll>\\n#define vvi vector<vector<int>>\\n#define ull unsigned long long int\\n#define mod 1000000007\\n#define ll long long int\\n\\nclass Solution {\\n   public:\\n    int validSubarraySize(vector<int>& ar, int threshold) {\\n        ll n=ar.size();\\n        vector<int> leftSmall(n,-1),rightSmall(n,n);\\n        stack<int> stk;\\n        for(int i=0;i<n;i++){\\n            while (stk.size() && ar[stk.top()]>=ar[i]){\\n                rightSmall[stk.top()]=i;\\n                stk.pop();\\n            }\\n            if(stk.size()) leftSmall[i]=stk.top();\\n            stk.push(i);\\n        }\\n        for(int i=0;i<n;i++){\\n            ll k=rightSmall[i]-leftSmall[i]-1;\\n            if(ar[i]*k>threshold){\\n                return k;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```ar[i]```\n```k```\n```ar[i]```\n```k```\n```threshold```\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n#define pb push_back\\n#define mii map<int, int>\\n#define mll map<ll, ll>\\n#define pii pair<int, int>\\n#define pic pair<int, char>\\n#define pdd pair<double, double>\\n#define pll pair<ll, ll>\\n#define vvi vector<vector<int>>\\n#define ull unsigned long long int\\n#define mod 1000000007\\n#define ll long long int\\n\\nclass Solution {\\n   public:\\n    int validSubarraySize(vector<int>& ar, int threshold) {\\n        ll n=ar.size();\\n        vector<int> leftSmall(n,-1),rightSmall(n,n);\\n        stack<int> stk;\\n        for(int i=0;i<n;i++){\\n            while (stk.size() && ar[stk.top()]>=ar[i]){\\n                rightSmall[stk.top()]=i;\\n                stk.pop();\\n            }\\n            if(stk.size()) leftSmall[i]=stk.top();\\n            stk.push(i);\\n        }\\n        for(int i=0;i<n;i++){\\n            ll k=rightSmall[i]-leftSmall[i]-1;\\n            if(ar[i]*k>threshold){\\n                return k;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2692203,
                "title": "c-monotonic-stack-o-n-space-and-time",
                "content": "# Intuition\\nUse monotonic stack to find number of elements greater than current element to the left and right.\\n\\n# Approach\\nUse prefix and suffix array to store number of elements greater than current element on the left and right and add them and check for the given condition.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n=nums.size(),count;\\n        vector<int> pref(n),suf(n);\\n        stack<pair<int,int>> s;\\n        for(int i=0;i<n;i++){\\n            count=1;\\n            while(!s.empty() && s.top().first>=nums[i]){\\n                count+=pref[s.top().second];\\n                s.pop();\\n            }\\n            pref[i]=count;\\n            s.push({nums[i],i});\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            count=1;\\n            while(!s.empty() && s.top().first>=nums[i]){\\n                count+=suf[s.top().second];\\n                s.pop();\\n            }\\n            suf[i]=count;\\n            s.push({nums[i],i});\\n        }\\n        for(int i=0;i<n;i++){\\n            count=pref[i]+suf[i]-1;\\n            if((double)threshold/(double)count<(double)nums[i]) return count;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n=nums.size(),count;\\n        vector<int> pref(n),suf(n);\\n        stack<pair<int,int>> s;\\n        for(int i=0;i<n;i++){\\n            count=1;\\n            while(!s.empty() && s.top().first>=nums[i]){\\n                count+=pref[s.top().second];\\n                s.pop();\\n            }\\n            pref[i]=count;\\n            s.push({nums[i],i});\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            count=1;\\n            while(!s.empty() && s.top().first>=nums[i]){\\n                count+=suf[s.top().second];\\n                s.pop();\\n            }\\n            suf[i]=count;\\n            s.push({nums[i],i});\\n        }\\n        for(int i=0;i<n;i++){\\n            count=pref[i]+suf[i]-1;\\n            if((double)threshold/(double)count<(double)nums[i]) return count;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674276,
                "title": "c-monotonic-stack-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        stack<pair<int,int>> stk; //idx, num\\n        int n = nums.size();\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int start =i;\\n            while(!stk.empty() && nums[i]<stk.top().second){\\n                auto& [idx, num] = stk.top();\\n                int len = i-idx;\\n                if(num>threshold/len){\\n                    return len;\\n                }\\n                start = idx;\\n                stk.pop();\\n            }\\n            \\n            stk.push({start,nums[i]});\\n        }\\n        \\n        while(!stk.empty()){\\n            auto& [idx, num] = stk.top();\\n            int len = n-idx;\\n            if(num>threshold/len){\\n                return len;\\n            }\\n            stk.pop();\\n        }\\n        \\n        return -1;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        stack<pair<int,int>> stk; //idx, num\\n        int n = nums.size();\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int start =i;\\n            while(!stk.empty() && nums[i]<stk.top().second){\\n                auto& [idx, num] = stk.top();\\n                int len = i-idx;\\n                if(num>threshold/len){\\n                    return len;\\n                }\\n                start = idx;\\n                stk.pop();\\n            }\\n            \\n            stk.push({start,nums[i]});\\n        }\\n        \\n        while(!stk.empty()){\\n            auto& [idx, num] = stk.top();\\n            int len = n-idx;\\n            if(num>threshold/len){\\n                return len;\\n            }\\n            stk.pop();\\n        }\\n        \\n        return -1;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673809,
                "title": "c-sort-segment-tree",
                "content": "```\\nconst int N = 100010;\\n\\nclass Solution {\\n    struct Node\\n    {\\n        int ma = 0;\\n        int lv = 0, rv = 0;\\n    } tr[N << 2];\\n    \\n    void modify(int u, int l, int r, int x, int v)\\n    {\\n        if (l == r) \\n        {\\n            tr[u].ma = v;\\n            tr[u].lv = tr[u].rv = v;\\n            return;\\n        }\\n        int mid = (l + r) / 2;\\n        if (x <= mid) modify(u << 1, l, mid, x, v);\\n        else modify(u << 1 | 1, mid + 1, r, x, v);\\n        pushup(u, l, r);\\n    }\\n    \\n    void pushup(int u, int l, int r)\\n    {\\n        int mid = (l + r) / 2;\\n        Node &rt = tr[u], &ls = tr[u << 1], &rs = tr[u << 1 | 1];\\n        rt.lv = ls.lv, rt.rv = rs.rv;\\n        if (ls.ma == mid - l + 1) rt.lv += rs.lv;\\n        if (rs.ma == r - mid) rt.rv += ls.rv;\\n        rt.ma = max(max(ls.ma, rs.ma), ls.rv + rs.lv);\\n    }\\npublic:\\n    \\n    /*\\n    1 1 3 3 4\\n    */\\n    int validSubarraySize(vector<int>& arr, int t) {\\n        vector<int> q;\\n        int n = arr.size();\\n        for (int i = 0; i < n; ++ i) q.push_back(i);\\n        sort(q.begin(), q.end(), [&](int a, int b)\\n             {\\n                 return arr[a] > arr[b]; \\n             });\\n        \\n        // enumerate k\\n        for (int k = 1, i = 0; k <= n; ++ k) // key observation: monotonic relation\\n        {\\n            while (i < n && arr[q[i]] * k > t)  \\n            {\\n                modify(1, 0, n - 1, q[i], 1);\\n                i ++ ;\\n            }\\n            if (tr[1].ma >= k)\\n            {\\n                return k;\\n            }\\n        }\\n        \\n        return -1; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int N = 100010;\\n\\nclass Solution {\\n    struct Node\\n    {\\n        int ma = 0;\\n        int lv = 0, rv = 0;\\n    } tr[N << 2];\\n    \\n    void modify(int u, int l, int r, int x, int v)\\n    {\\n        if (l == r) \\n        {\\n            tr[u].ma = v;\\n            tr[u].lv = tr[u].rv = v;\\n            return;\\n        }\\n        int mid = (l + r) / 2;\\n        if (x <= mid) modify(u << 1, l, mid, x, v);\\n        else modify(u << 1 | 1, mid + 1, r, x, v);\\n        pushup(u, l, r);\\n    }\\n    \\n    void pushup(int u, int l, int r)\\n    {\\n        int mid = (l + r) / 2;\\n        Node &rt = tr[u], &ls = tr[u << 1], &rs = tr[u << 1 | 1];\\n        rt.lv = ls.lv, rt.rv = rs.rv;\\n        if (ls.ma == mid - l + 1) rt.lv += rs.lv;\\n        if (rs.ma == r - mid) rt.rv += ls.rv;\\n        rt.ma = max(max(ls.ma, rs.ma), ls.rv + rs.lv);\\n    }\\npublic:\\n    \\n    /*\\n    1 1 3 3 4\\n    */\\n    int validSubarraySize(vector<int>& arr, int t) {\\n        vector<int> q;\\n        int n = arr.size();\\n        for (int i = 0; i < n; ++ i) q.push_back(i);\\n        sort(q.begin(), q.end(), [&](int a, int b)\\n             {\\n                 return arr[a] > arr[b]; \\n             });\\n        \\n        // enumerate k\\n        for (int k = 1, i = 0; k <= n; ++ k) // key observation: monotonic relation\\n        {\\n            while (i < n && arr[q[i]] * k > t)  \\n            {\\n                modify(1, 0, n - 1, q[i], 1);\\n                i ++ ;\\n            }\\n            if (tr[1].ma >= k)\\n            {\\n                return k;\\n            }\\n        }\\n        \\n        return -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672064,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) \\n    {\\n        int n = nums.size();\\n        \\n        vector<int> pre_small(n,-1), next_small(n,-1);\\n        \\n        stack<int> st;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            while(!st.empty() && nums[st.top()] > nums[i])\\n            {\\n                next_small[st.top()] = i;\\n                \\n                st.pop();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            st.pop();\\n        }\\n        \\n         \\n        for(int i=n-1; i>= 0; i--)\\n        {\\n            while(!st.empty() && nums[st.top()] > nums[i])\\n            {\\n                pre_small[st.top()] = i;\\n                \\n                st.pop();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int left = pre_small[i];\\n            int right = next_small[i] == -1? n : next_small[i];\\n            \\n            int len = right -left -1;\\n            \\n            if(nums[i] > threshold /len)\\n            {\\n                return len;\\n            }\\n        }\\n        \\n        return -1;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) \\n    {\\n        int n = nums.size();\\n        \\n        vector<int> pre_small(n,-1), next_small(n,-1);\\n        \\n        stack<int> st;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            while(!st.empty() && nums[st.top()] > nums[i])\\n            {\\n                next_small[st.top()] = i;\\n                \\n                st.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2658856,
                "title": "length-of-largest-area-under-histogram",
                "content": "If you think for a while, the question is just largest area under histogram. But not necessarily largest area, one just need to find any area under histogram which is greater than the threshold, and return the length aspect of that area.\\n\\n//in the code below, ```ar``` is the area. Once we find any area which is greater than threshold, we return its length.\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        stack<int> s;\\n        s.push(0);\\n        int ar, x;\\n        for(int i = 1; i < nums.size(); i++) {\\n            while(!s.empty() && nums[i] <= nums[s.top()]) {\\n                x = s.top();\\n                s.pop();\\n                if(s.empty()) {\\n                    ar = i*nums[x];\\n                    if(ar > threshold) return i;\\n                }\\n                else {\\n                    ar = (i - s.top() - 1)*nums[x];\\n                    if(ar > threshold) return (i - s.top() - 1);\\n                }\\n            }\\n            s.push(i);\\n        }\\n        while(!s.empty()) {\\n            x = s.top();\\n            s.pop();\\n            if(s.empty()) {\\n                ar = nums.size()*nums[x];\\n                if(ar > threshold) return nums.size();\\n            }\\n            else {\\n                ar = (nums.size() - s.top() - 1)*nums[x];\\n                if(ar > threshold) return (nums.size() - s.top() - 1);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```ar```\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        stack<int> s;\\n        s.push(0);\\n        int ar, x;\\n        for(int i = 1; i < nums.size(); i++) {\\n            while(!s.empty() && nums[i] <= nums[s.top()]) {\\n                x = s.top();\\n                s.pop();\\n                if(s.empty()) {\\n                    ar = i*nums[x];\\n                    if(ar > threshold) return i;\\n                }\\n                else {\\n                    ar = (i - s.top() - 1)*nums[x];\\n                    if(ar > threshold) return (i - s.top() - 1);\\n                }\\n            }\\n            s.push(i);\\n        }\\n        while(!s.empty()) {\\n            x = s.top();\\n            s.pop();\\n            if(s.empty()) {\\n                ar = nums.size()*nums[x];\\n                if(ar > threshold) return nums.size();\\n            }\\n            else {\\n                ar = (nums.size() - s.top() - 1)*nums[x];\\n                if(ar > threshold) return (nums.size() - s.top() - 1);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647117,
                "title": "python-solution-faster-90",
                "content": "\\n\\n\\tclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        \\n        N = len(nums)\\n        ks = []\\n        for idx, num in enumerate(nums):\\n            ks.append((threshold // num + 1, idx))\\n        ks.sort()\\n        \\n        class UnionFind:\\n            def __init__(self):\\n                self.parents = {}\\n                self.sizes = {}\\n                \\n            def insert(self, x):\\n                if x not in self.parents:\\n                    self.parents[x] = x\\n                    self.sizes[x] = 1\\n                \\n            def find_parent(self, x):\\n                if self.parents[x] != x:\\n                    self.parents[x] = self.find_parent(self.parents[x])\\n                return self.parents[x]\\n            \\n            def union(self, x, y):\\n                x, y = self.find_parent(x), self.find_parent(y)\\n                if x == y:\\n                    return \\n                if self.sizes[x] > self.sizes[y]:\\n                    self.parents[y] = x\\n                    self.sizes[x] += self.sizes[y]\\n                else:\\n                    self.parents[x] = y\\n                    self.sizes[y] += self.sizes[x]\\n        \\n        uf = UnionFind()\\n        for k, idx in ks:\\n            uf.insert(idx)\\n            if idx - 1 in uf.parents:\\n                uf.union(idx, idx - 1)\\n            if idx + 1 in uf.parents:\\n                uf.union(idx, idx + 1)\\n            if uf.sizes[uf.find_parent(idx)] >= k:\\n                return k\\n        return -1",
                "solutionTags": [],
                "code": "class Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        \\n        N = len(nums)\\n        ks = []\\n        for idx, num in enumerate(nums):\\n            ks.append((threshold // num + 1, idx))\\n        ks.sort()\\n        \\n        class UnionFind:\\n            def __init__(self):\\n                self.parents = {}",
                "codeTag": "Java"
            },
            {
                "id": 2621533,
                "title": "python-solution-using-stack",
                "content": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        sz = len(nums)\\n        stack, leftNum = [], [0] * sz\\n        for i in range(sz):\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                stack.pop()\\n            leftNum[i] = i - stack[-1] - 1 if stack else i\\n            if (leftNum[i] + 1) * nums[i] > threshold:\\n                return int(leftNum[i] + 1)\\n            stack.append(i)\\n        while stack:\\n            stack.pop()\\n        for i in range(sz - 1, -1, -1):\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                stack.pop()\\n            leftNum[i] += (stack[-1] - i) if stack else (sz - i)\\n            if leftNum[i] * nums[i] > threshold:\\n                return int(leftNum[i])\\n            stack.append(i)\\n        return -1\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        sz = len(nums)\\n        stack, leftNum = [], [0] * sz\\n        for i in range(sz):\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                stack.pop()\\n            leftNum[i] = i - stack[-1] - 1 if stack else i\\n            if (leftNum[i] + 1) * nums[i] > threshold:\\n                return int(leftNum[i] + 1)\\n            stack.append(i)\\n        while stack:\\n            stack.pop()\\n        for i in range(sz - 1, -1, -1):\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                stack.pop()\\n            leftNum[i] += (stack[-1] - i) if stack else (sz - i)\\n            if leftNum[i] * nums[i] > threshold:\\n                return int(leftNum[i])\\n            stack.append(i)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593021,
                "title": "c-solution-o-n-time-o-n-space-stack-same-as-84-largest-rectangle-in-histogram",
                "content": "```\\nclass Solution {\\n    /*\\n    This Problem is the same as\\n    84. Largest Rectangle in Histogram\\n    https://leetcode.com/problems/largest-rectangle-in-histogram/\\n    */\\npublic:\\n    static int validSubarraySize(const vector<int>& h, const int threshold) {\\n        const int n = size(h);\\n        vector<int64_t> l(n, 0);\\n        stack<int> s;\\n        for (int i = 0; i < n; ++i) {\\n            while (!s.empty() && h[s.top()] >= h[i])\\n                s.pop();\\n            l[i] = s.empty() ? i : i - s.top() - 1;\\n            if ((l[i] + 1) * h[i] > threshold)\\n                return int(l[i] + 1);\\n            s.push(i);\\n        }\\n        while (!s.empty())\\n            s.pop();\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (!s.empty() && h[s.top()] >= h[i])\\n                s.pop();\\n            l[i] += s.empty() ? n - i : s.top() - i;\\n            if (l[i] * h[i] > threshold)\\n                return int(l[i]);\\n            s.push(i);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    This Problem is the same as\\n    84. Largest Rectangle in Histogram\\n    https://leetcode.com/problems/largest-rectangle-in-histogram/\\n    */\\npublic:\\n    static int validSubarraySize(const vector<int>& h, const int threshold) {\\n        const int n = size(h);\\n        vector<int64_t> l(n, 0);\\n        stack<int> s;\\n        for (int i = 0; i < n; ++i) {\\n            while (!s.empty() && h[s.top()] >= h[i])\\n                s.pop();\\n            l[i] = s.empty() ? i : i - s.top() - 1;\\n            if ((l[i] + 1) * h[i] > threshold)\\n                return int(l[i] + 1);\\n            s.push(i);\\n        }\\n        while (!s.empty())\\n            s.pop();\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (!s.empty() && h[s.top()] >= h[i])\\n                s.pop();\\n            l[i] += s.empty() ? n - i : s.top() - i;\\n            if (l[i] * h[i] > threshold)\\n                return int(l[i]);\\n            s.push(i);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462816,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int validSubarraySize(int[] nums, int threshold){\\n        int n = nums.length;\\n        int[] minimumWindow = new int[n];\\n        for(int i=0;i<n;i++){\\n            minimumWindow[i] = threshold/nums[i] + 1;\\n        }\\n        int[] rightNextGreaterElement = rightNextGreaterElement(minimumWindow);\\n        int[] leftNextGreaterElement = leftNextGreaterElement(minimumWindow);\\n        for(int i=0;i<n;i++){\\n            if(rightNextGreaterElement[i]-leftNextGreaterElement[i]-1>=minimumWindow[i])\\n                return minimumWindow[i];\\n        }\\n        return -1;\\n    }\\n\\n    \\n    private int[] rightNextGreaterElement(int[] arr){\\n        ArrayDeque<Pair> stack = new ArrayDeque<>();\\n        int[] nextGreaterElements = new int[arr.length];\\n        for(int i=0;i<arr.length;i++){\\n            while(!stack.isEmpty() && stack.peek().value<arr[i])\\n                nextGreaterElements[stack.pop().index] = i;\\n            stack.push(new Pair(arr[i],i));\\n        }\\n        while(!stack.isEmpty()) nextGreaterElements[stack.pop().index] = arr.length;\\n        return nextGreaterElements;\\n    }\\n    private int[] leftNextGreaterElement(int[] arr){\\n        ArrayDeque<Pair> stack = new ArrayDeque<>();\\n        int[] nextGreaterElements = new int[arr.length];\\n        for(int i=arr.length-1;i>=0;i--){\\n            while(!stack.isEmpty() && stack.peek().value<arr[i])\\n                nextGreaterElements[stack.pop().index] = i;\\n            stack.push(new Pair(arr[i],i));\\n        }\\n        while(!stack.isEmpty()) nextGreaterElements[stack.pop().index] = -1;\\n        return nextGreaterElements;\\n    }\\n}\\nclass Pair{\\n    int value;\\n    int index;\\n\\n    public Pair(int value, int index) {\\n        this.value = value;\\n        this.index = index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int validSubarraySize(int[] nums, int threshold){\\n        int n = nums.length;\\n        int[] minimumWindow = new int[n];\\n        for(int i=0;i<n;i++){\\n            minimumWindow[i] = threshold/nums[i] + 1;\\n        }\\n        int[] rightNextGreaterElement = rightNextGreaterElement(minimumWindow);\\n        int[] leftNextGreaterElement = leftNextGreaterElement(minimumWindow);\\n        for(int i=0;i<n;i++){\\n            if(rightNextGreaterElement[i]-leftNextGreaterElement[i]-1>=minimumWindow[i])\\n                return minimumWindow[i];\\n        }\\n        return -1;\\n    }\\n\\n    \\n    private int[] rightNextGreaterElement(int[] arr){\\n        ArrayDeque<Pair> stack = new ArrayDeque<>();\\n        int[] nextGreaterElements = new int[arr.length];\\n        for(int i=0;i<arr.length;i++){\\n            while(!stack.isEmpty() && stack.peek().value<arr[i])\\n                nextGreaterElements[stack.pop().index] = i;\\n            stack.push(new Pair(arr[i],i));\\n        }\\n        while(!stack.isEmpty()) nextGreaterElements[stack.pop().index] = arr.length;\\n        return nextGreaterElements;\\n    }\\n    private int[] leftNextGreaterElement(int[] arr){\\n        ArrayDeque<Pair> stack = new ArrayDeque<>();\\n        int[] nextGreaterElements = new int[arr.length];\\n        for(int i=arr.length-1;i>=0;i--){\\n            while(!stack.isEmpty() && stack.peek().value<arr[i])\\n                nextGreaterElements[stack.pop().index] = i;\\n            stack.push(new Pair(arr[i],i));\\n        }\\n        while(!stack.isEmpty()) nextGreaterElements[stack.pop().index] = -1;\\n        return nextGreaterElements;\\n    }\\n}\\nclass Pair{\\n    int value;\\n    int index;\\n\\n    public Pair(int value, int index) {\\n        this.value = value;\\n        this.index = index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461092,
                "title": "c-o-n-using-question-largest-area-in-histogram-lc-84",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void prev_smaller(vector<int> &nums, vector<int> &ans)\\n{\\n    stack<int> st;\\n    st.push(-1);\\n\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        int cur = nums[i];\\n\\n        while (st.top() != -1 && cur <= nums[st.top()])\\n        {\\n            st.pop();\\n        }\\n\\n        ans[i] = st.top();\\n        st.push(i);\\n    }\\n}\\n\\nvoid next_smaller(vector<int> &nums, vector<int> &ans)\\n{\\n    stack<int> st;\\n    st.push(-1);\\n\\n    for (int i = nums.size() - 1; i >= 0; i--)\\n    {\\n        int cur = nums[i];\\n\\n        while (st.top() != -1 && cur <= nums[st.top()])\\n        {\\n            st.pop();\\n        }\\n\\n        ans[i] = st.top();\\n        st.push(i);\\n    }\\n}\\n\\n    \\n   \\nint validSubarraySize(vector<int> &nums, int threshold)\\n{\\n    int n = nums.size();\\n\\n    vector<int> prev_s(nums.size(), 0);\\n    vector<int> next_s(nums.size(), 0);\\n\\n    next_smaller(nums, next_s);\\n    prev_smaller(nums, prev_s);\\n\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        if (next_s[i] == -1)\\n            next_s[i] = n;\\n\\n        int k = next_s[i] - prev_s[i] - 1;\\n\\n        int coff = threshold / k;\\n\\n        if (nums[i] > coff)\\n        {\\n            return k;\\n        }\\n    }\\n\\n    return -1;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void prev_smaller(vector<int> &nums, vector<int> &ans)\\n{\\n    stack<int> st;\\n    st.push(-1);\\n\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        int cur = nums[i];\\n\\n        while (st.top() != -1 && cur <= nums[st.top()])\\n        {\\n            st.pop();\\n        }\\n\\n        ans[i] = st.top();\\n        st.push(i);\\n    }\\n}\\n\\nvoid next_smaller(vector<int> &nums, vector<int> &ans)\\n{\\n    stack<int> st;\\n    st.push(-1);\\n\\n    for (int i = nums.size() - 1; i >= 0; i--)\\n    {\\n        int cur = nums[i];\\n\\n        while (st.top() != -1 && cur <= nums[st.top()])\\n        {\\n            st.pop();\\n        }\\n\\n        ans[i] = st.top();\\n        st.push(i);\\n    }\\n}\\n\\n    \\n   \\nint validSubarraySize(vector<int> &nums, int threshold)\\n{\\n    int n = nums.size();\\n\\n    vector<int> prev_s(nums.size(), 0);\\n    vector<int> next_s(nums.size(), 0);\\n\\n    next_smaller(nums, next_s);\\n    prev_smaller(nums, prev_s);\\n\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        if (next_s[i] == -1)\\n            next_s[i] = n;\\n\\n        int k = next_s[i] - prev_s[i] - 1;\\n\\n        int coff = threshold / k;\\n\\n        if (nums[i] > coff)\\n        {\\n            return k;\\n        }\\n    }\\n\\n    return -1;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2443208,
                "title": "python-monotonically-increasing-stack-o-n",
                "content": "\\n\\n```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        n = len(nums)\\n        \\n\\t\\t\"\"\"\\n\\t\\tIf no. of elements > threshold, on taking the entire array\\n\\t\\tthreshold / n => 0 while is less than minimum possible value (1)\\n\\t\\tin array.\\n\\t\\t\"\"\"\\n        if n > threshold:\\n            return n\\n\\n\\t\\t\"\"\"\\n\\t\\tAppending 0 so that we empty the stack in last iteration and wont have \\n\\t\\tto handle that case explicitly.\\n\\t\\t\"\"\"\\n        nums.append(0)\\n\\t\\t\\n        stack = []\\n        for i in range(n + 1):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tWe match the current number with all previously occurred larger numbers.\\n\\t\\t\\t1. Calculate the length of subarray if it started from that number and\\n\\t\\t\\tended at current\\n\\t\\t\\t2. If the subarray matches given condition, return.\\n\\t\\t\\t\"\"\"\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                crr = nums[stack.pop()]\\n                j = stack[-1] + 1 if stack else 0\\n                k = i - j                                       # 1\\n                if threshold / k < crr:                         # 2\\n                    return k                                    # 2\\n\\n            stack.append(i)\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        n = len(nums)\\n        \\n\\t\\t\"\"\"\\n\\t\\tIf no. of elements > threshold, on taking the entire array\\n\\t\\tthreshold / n => 0 while is less than minimum possible value (1)\\n\\t\\tin array.\\n\\t\\t\"\"\"\\n        if n > threshold:\\n            return n\\n\\n\\t\\t\"\"\"\\n\\t\\tAppending 0 so that we empty the stack in last iteration and wont have \\n\\t\\tto handle that case explicitly.\\n\\t\\t\"\"\"\\n        nums.append(0)\\n\\t\\t\\n        stack = []\\n        for i in range(n + 1):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tWe match the current number with all previously occurred larger numbers.\\n\\t\\t\\t1. Calculate the length of subarray if it started from that number and\\n\\t\\t\\tended at current\\n\\t\\t\\t2. If the subarray matches given condition, return.\\n\\t\\t\\t\"\"\"\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                crr = nums[stack.pop()]\\n                j = stack[-1] + 1 if stack else 0\\n                k = i - j                                       # 1\\n                if threshold / k < crr:                         # 2\\n                    return k                                    # 2\\n\\n            stack.append(i)\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431717,
                "title": "o-n-using-stack",
                "content": "\\tSimple O(n2) approach would be to find each sub array and get its min and then check its score.\\n\\t\\n\\tSo the the task of finding subarrays will always push u towards O(n2). \\n\\tSo think about each sub array with respect to element. \\n\\tEach element can be the minimum of the subarray of longest length of what ?\\n\\tThis is what my logic does first using Stacks\\n\\tThen a simple loop for each element for its longest corresponding sub array where the same element is the minimum\\n\\t\\n\\t//\\n\\tpublic static void solve(int[] arr, int th) {\\n\\t\\tStack<Integer> Right_S = new Stack<>();\\n\\t\\tint[] End = new int[arr.length];\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\twhile (!Right_S.isEmpty() && arr[Right_S.peek()] > arr[i]) {\\n\\t\\t\\t\\tint idx = Right_S.pop();\\n\\t\\t\\t\\tEnd[idx] = i - 1;\\n\\t\\t\\t}\\n\\t\\t\\tRight_S.add(i);\\n\\t\\t}\\n\\n\\t\\twhile (!Right_S.isEmpty()) {\\n\\t\\t\\tint idx = Right_S.pop();\\n\\t\\t\\tEnd[idx] = arr.length - 1;\\n\\t\\t}\\n\\n\\t\\tint[] Start = new int[arr.length];\\n\\t\\tfor (int i = arr.length - 1; i >= 0; i--) {\\n\\t\\t\\twhile (!Right_S.isEmpty() && arr[Right_S.peek()] > arr[i]) {\\n\\t\\t\\t\\tint idx = Right_S.pop();\\n\\t\\t\\t\\tStart[idx] = i + 1;\\n\\t\\t\\t}\\n\\t\\t\\tRight_S.add(i);\\n\\t\\t}\\n\\t\\twhile (!Right_S.isEmpty()) {\\n\\t\\t\\tint idx = Right_S.pop();\\n\\t\\t\\tStart[idx] = 0;\\n\\t\\t}\\n\\t\\tint ans = -1;\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tint len = End[i] - Start[i] + 1;\\n\\n\\t\\t\\tif (arr[i] * len > th) {\\n\\t\\t\\t\\tSystem.out.println(Start[i] + \"-\" + End[i] + \"==\" + arr[i]);\\n\\n\\t\\t\\t\\tans = Math.max(ans, len);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(ans);\\n\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\tSimple O(n2) approach would be to find each sub array and get its min and then check its score.\\n\\t\\n\\tSo the the task of finding subarrays will always push u towards O(n2). \\n\\tSo think about each sub array with respect to element. \\n\\tEach element can be the minimum of the subarray of longest length of what ?\\n\\tThis is what my logic does first using Stacks\\n\\tThen a simple loop for each element for its longest corresponding sub array where the same element is the minimum\\n\\t\\n\\t//\\n\\tpublic static void solve(int[] arr, int th) {\\n\\t\\tStack<Integer> Right_S = new Stack<>();\\n\\t\\tint[] End = new int[arr.length];\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\twhile (!Right_S.isEmpty() && arr[Right_S.peek()] > arr[i]) {\\n\\t\\t\\t\\tint idx = Right_S.pop();\\n\\t\\t\\t\\tEnd[idx] = i - 1;\\n\\t\\t\\t}\\n\\t\\t\\tRight_S.add(i);\\n\\t\\t}\\n\\n\\t\\twhile (!Right_S.isEmpty()) {\\n\\t\\t\\tint idx = Right_S.pop();\\n\\t\\t\\tEnd[idx] = arr.length - 1;\\n\\t\\t}\\n\\n\\t\\tint[] Start = new int[arr.length];\\n\\t\\tfor (int i = arr.length - 1; i >= 0; i--) {\\n\\t\\t\\twhile (!Right_S.isEmpty() && arr[Right_S.peek()] > arr[i]) {\\n\\t\\t\\t\\tint idx = Right_S.pop();\\n\\t\\t\\t\\tStart[idx] = i + 1;\\n\\t\\t\\t}\\n\\t\\t\\tRight_S.add(i);\\n\\t\\t}\\n\\t\\twhile (!Right_S.isEmpty()) {\\n\\t\\t\\tint idx = Right_S.pop();\\n\\t\\t\\tStart[idx] = 0;\\n\\t\\t}\\n\\t\\tint ans = -1;\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tint len = End[i] - Start[i] + 1;\\n\\n\\t\\t\\tif (arr[i] * len > th) {\\n\\t\\t\\t\\tSystem.out.println(Start[i] + \"-\" + End[i] + \"==\" + arr[i]);\\n\\n\\t\\t\\t\\tans = Math.max(ans, len);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(ans);\\n\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2377005,
                "title": "c-solution-using-monotonic-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> get(vector<int>& divRequired) {\\n        int n = divRequired.size();\\n        vector<int> st;\\n        vector<int> sol(n);\\n        for (int i = 0; i < n; i++) {\\n            while (!st.empty() && divRequired[st.back()] <= divRequired[i]) {\\n                st.pop_back();\\n            }\\n            if (st.empty()) {\\n                sol[i] = 0;\\n            } else {\\n                sol[i] = st.back() + 1;\\n            }\\n            st.push_back(i);\\n        }\\n        return sol;\\n    }\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        vector<int> divRequired(n);\\n        auto getDivRequired = [&] (int value) -> int {\\n            int low = 1;\\n            int high = n;\\n            int sol = n + 1;\\n            while (low <= high) {\\n                int mid = (low + high) / 2;\\n                if ((double) threshold / mid < value) {\\n                    sol = mid;\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            }\\n            return sol;\\n        };\\n        for (int i = 0; i < n; i++) {\\n            divRequired[i] = getDivRequired(nums[i]);\\n        }\\n        int sol = -1;\\n        vector<int> left = get(divRequired);\\n        reverse(divRequired.begin(), divRequired.end());\\n        vector<int> right = get(divRequired);\\n        reverse(divRequired.begin(), divRequired.end());\\n        for (int i = 0; i < n; i++) {\\n            if (divRequired[i] == n + 1) continue;\\n            int l = left[i];\\n            int r = n - 1 - right[n - 1 - i];\\n            if (r - l + 1 >= divRequired[i]) {\\n                sol = r - l + 1;\\n                break;\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> get(vector<int>& divRequired) {\\n        int n = divRequired.size();\\n        vector<int> st;\\n        vector<int> sol(n);\\n        for (int i = 0; i < n; i++) {\\n            while (!st.empty() && divRequired[st.back()] <= divRequired[i]) {\\n                st.pop_back();\\n            }\\n            if (st.empty()) {\\n                sol[i] = 0;\\n            } else {\\n                sol[i] = st.back() + 1;\\n            }\\n            st.push_back(i);\\n        }\\n        return sol;\\n    }\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        vector<int> divRequired(n);\\n        auto getDivRequired = [&] (int value) -> int {\\n            int low = 1;\\n            int high = n;\\n            int sol = n + 1;\\n            while (low <= high) {\\n                int mid = (low + high) / 2;\\n                if ((double) threshold / mid < value) {\\n                    sol = mid;\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            }\\n            return sol;\\n        };\\n        for (int i = 0; i < n; i++) {\\n            divRequired[i] = getDivRequired(nums[i]);\\n        }\\n        int sol = -1;\\n        vector<int> left = get(divRequired);\\n        reverse(divRequired.begin(), divRequired.end());\\n        vector<int> right = get(divRequired);\\n        reverse(divRequired.begin(), divRequired.end());\\n        for (int i = 0; i < n; i++) {\\n            if (divRequired[i] == n + 1) continue;\\n            int l = left[i];\\n            int r = n - 1 - right[n - 1 - i];\\n            if (r - l + 1 >= divRequired[i]) {\\n                sol = r - l + 1;\\n                break;\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346947,
                "title": "java-easy-to-understand-monotonic-stack-o-n-time-o-n-space",
                "content": "**Approach** - \\n1. Consider any number in the array. What can be the length of the subarray with this number as the minimum? We go towards the left and towards the right, and as soon as we encounter a smaller number we stop, calculate the length and try to satisfy the condition.\\n2. Now assume, the array is already sorted. For any particular number at index \\'i\\', the length is `nums.length - i` and the minimum number is `nums[i]` itself. We can thus easily check for the given condition in one pass.\\n3. To reduce the first point into the second point, we use a monotonic stack.\\n4. For every element, we check the for the index of the first number smaller than it while going in the left direction. Since this new element is the minimum from that index, we update that index. For all the elements popped out of the stack, we check the condition. After traversing the entire array once, we empty the stack one by one while simultaneously checking the condition.\\n\\n```\\nclass Solution {\\n    public int validSubarraySize(int[] nums, int threshold) {\\n\\t\\t\\n\\t\\t/**\\n\\t\\t* Each pair stores two pieces of information - \\n\\t\\t* Key: The leftmost index from where this element is the minimum\\n\\t\\t* Value: The element itself\\n\\t\\t*/\\n        Stack<Pair<Integer, Integer>> stack = new Stack<>();\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            // Initially the leftmost index from where this element is the minimum is i itself.\\n\\t\\t\\tint index = i;\\n\\t\\t\\t\\n            while(!stack.isEmpty() && stack.peek().getValue() > nums[i]) { // removing all previous greater elements\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// index of the previously greater element. The current element will start covering ground from here.\\n                index = stack.peek().getKey(); \\n                int num = stack.pop().getValue();\\n                \\n                int length = i - index;\\n                if(satisfies(num, length, threshold)) return length;\\n            }\\n            \\n\\t\\t\\t// Pushing the new element with the updated index value\\n            stack.push(new Pair<>(index, nums[i]));\\n        }\\n        \\n\\t\\t// Emptying out the stack\\n        while(!stack.isEmpty()) {\\n            int index = stack.peek().getKey();\\n            int num = stack.pop().getValue();\\n            \\n            int length = nums.length - index;\\n            if(satisfies(num, length, threshold)) return length;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n\\t// abstracted out the condition check in a separate function\\n    boolean satisfies(int min, int length, int threshold) {\\n        return ((double)(threshold) / length) < min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int validSubarraySize(int[] nums, int threshold) {\\n\\t\\t\\n\\t\\t/**\\n\\t\\t* Each pair stores two pieces of information - \\n\\t\\t* Key: The leftmost index from where this element is the minimum\\n\\t\\t* Value: The element itself\\n\\t\\t*/\\n        Stack<Pair<Integer, Integer>> stack = new Stack<>();\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            // Initially the leftmost index from where this element is the minimum is i itself.\\n\\t\\t\\tint index = i;\\n\\t\\t\\t\\n            while(!stack.isEmpty() && stack.peek().getValue() > nums[i]) { // removing all previous greater elements\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// index of the previously greater element. The current element will start covering ground from here.\\n                index = stack.peek().getKey(); \\n                int num = stack.pop().getValue();\\n                \\n                int length = i - index;\\n                if(satisfies(num, length, threshold)) return length;\\n            }\\n            \\n\\t\\t\\t// Pushing the new element with the updated index value\\n            stack.push(new Pair<>(index, nums[i]));\\n        }\\n        \\n\\t\\t// Emptying out the stack\\n        while(!stack.isEmpty()) {\\n            int index = stack.peek().getKey();\\n            int num = stack.pop().getValue();\\n            \\n            int length = nums.length - index;\\n            if(satisfies(num, length, threshold)) return length;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n\\t// abstracted out the condition check in a separate function\\n    boolean satisfies(int min, int length, int threshold) {\\n        return ((double)(threshold) / length) < min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346909,
                "title": "python-3-monotonic-stack",
                "content": "\\tclass Solution:\\n\\t\\tdef validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n\\t\\t\\tl,n=[],len(nums)\\n\\t\\t\\tstack=[]\\n\\t\\t\\tfor i,x in enumerate(nums):\\n\\t\\t\\t\\twhile stack and nums[stack[-1]]>=x:\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\tif stack:\\n\\t\\t\\t\\t\\tl.append(stack[-1])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tl.append(-1)\\n\\t\\t\\t\\tstack.append(i)\\n\\t\\t\\tstack=[]\\n\\t\\t\\tfor i in range(n-1,-1,-1):\\n\\t\\t\\t\\twhile stack and nums[stack[-1]]>=nums[i]:\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\tif stack:\\n\\t\\t\\t\\t\\tk=stack[-1]-l[i]-1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tk=n-l[i]-1\\n\\t\\t\\t\\tif k*nums[i]>threshold:\\n\\t\\t\\t\\t\\treturn k\\n\\t\\t\\t\\tstack.append(i)\\n\\t\\t\\treturn -1",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n\\t\\t\\tl,n=[],len(nums)\\n\\t\\t\\tstack=[]\\n\\t\\t\\tfor i,x in enumerate(nums):\\n\\t\\t\\t\\twhile stack and nums[stack[-1]]>=x:\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\tif stack:\\n\\t\\t\\t\\t\\tl.append(stack[-1])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tl.append(-1)\\n\\t\\t\\t\\tstack.append(i)\\n\\t\\t\\tstack=[]\\n\\t\\t\\tfor i in range(n-1,-1,-1):\\n\\t\\t\\t\\twhile stack and nums[stack[-1]]>=nums[i]:\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\tif stack:\\n\\t\\t\\t\\t\\tk=stack[-1]-l[i]-1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tk=n-l[i]-1\\n\\t\\t\\t\\tif k*nums[i]>threshold:\\n\\t\\t\\t\\t\\treturn k\\n\\t\\t\\t\\tstack.append(i)\\n\\t\\t\\treturn -1",
                "codeTag": "Java"
            },
            {
                "id": 2335534,
                "title": "python-monostack",
                "content": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], t: int) -> int:\\n        stack = []\\n        nums.append(0)\\n        for i in range(len(nums)):\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                curr = nums[stack.pop()]\\n                j = stack[-1] + 1 if stack else 0\\n                k = i - j\\n                if curr > t // k:\\n                    return k\\n            stack.append(i)\\n\\n        return -1",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], t: int) -> int:\\n        stack = []\\n        nums.append(0)\\n        for i in range(len(nums)):\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                curr = nums[stack.pop()]\\n                j = stack[-1] + 1 if stack else 0\\n                k = i - j\\n                if curr > t // k:\\n                    return k\\n            stack.append(i)\\n\\n        return -1",
                "codeTag": "Java"
            },
            {
                "id": 2331305,
                "title": "python-dsu-union-find",
                "content": "```\\nclass DSU:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [1] * n\\n        self.highest_rank = 1\\n    \\n    def find(self, i):\\n        if i == self.parent[i]:\\n            return i\\n        self.parent[i] = self.find(self.parent[i])\\n        return self.parent[i]\\n    \\n    def union(self, x, y):\\n        xparent = self.find(x)\\n        yparent = self.find(y)\\n        \\n        if xparent != yparent:\\n            \\n            xrank = self.rank[xparent]\\n            yrank = self.rank[yparent]\\n            \\n            if xrank > yrank:\\n                self.parent[yparent] = xparent\\n                self.rank[xparent] += self.rank[yparent]\\n            else:\\n                self.parent[xparent] = yparent\\n                self.rank[yparent] += self.rank[xparent] # adding rank\\n            \\n            self.highest_rank = max(self.rank[xparent], self.rank[yparent])\\n    \\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        dsu = DSU(len(nums))        \\n        arr = sorted([(n, i) for i, n in enumerate(nums)], reverse = True)\\n        seen = set()\\n        for a, i in arr:\\n            seen.add(i)\\n            if i + 1 in seen:\\n                dsu.union(i, i + 1)\\n            if i - 1 in seen:\\n                dsu.union(i, i - 1)\\n            \\n            if dsu.highest_rank > threshold // a:\\n                return dsu.highest_rank\\n        return -1",
                "solutionTags": [],
                "code": "```\\nclass DSU:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [1] * n\\n        self.highest_rank = 1\\n    \\n    def find(self, i):\\n        if i == self.parent[i]:\\n            return i\\n        self.parent[i] = self.find(self.parent[i])\\n        return self.parent[i]\\n    \\n    def union(self, x, y):\\n        xparent = self.find(x)\\n        yparent = self.find(y)\\n        \\n        if xparent != yparent:\\n            \\n            xrank = self.rank[xparent]\\n            yrank = self.rank[yparent]\\n            \\n            if xrank > yrank:\\n                self.parent[yparent] = xparent\\n                self.rank[xparent] += self.rank[yparent]\\n            else:\\n                self.parent[xparent] = yparent\\n                self.rank[yparent] += self.rank[xparent] # adding rank\\n            \\n            self.highest_rank = max(self.rank[xparent], self.rank[yparent])\\n    \\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        dsu = DSU(len(nums))        \\n        arr = sorted([(n, i) for i, n in enumerate(nums)], reverse = True)\\n        seen = set()\\n        for a, i in arr:\\n            seen.add(i)\\n            if i + 1 in seen:\\n                dsu.union(i, i + 1)\\n            if i - 1 in seen:\\n                dsu.union(i, i - 1)\\n            \\n            if dsu.highest_rank > threshold // a:\\n                return dsu.highest_rank\\n        return -1",
                "codeTag": "Java"
            },
            {
                "id": 2328931,
                "title": "short-python3-implementation-in-linear-time-faster-than-83",
                "content": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        nums.append(0)\\n        stack = [(0, -1)]\\n        for i, v in enumerate(nums):\\n            while len(stack) > 1 and v <= stack[-1][0]:\\n                if stack[-1][0] > threshold / (i - 1 - stack[-2][1]):\\n                    return i - 1 - stack[-2][1]\\n                stack.pop()\\n            stack.append((v, i))\\n        return -1\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        nums.append(0)\\n        stack = [(0, -1)]\\n        for i, v in enumerate(nums):\\n            while len(stack) > 1 and v <= stack[-1][0]:\\n                if stack[-1][0] > threshold / (i - 1 - stack[-2][1]):\\n                    return i - 1 - stack[-2][1]\\n                stack.pop()\\n            stack.append((v, i))\\n        return -1\\n",
                "codeTag": "Java"
            },
            {
                "id": 2322852,
                "title": "c-o-nlogn-solution-using-range-max-query-sparsetable-binary-search",
                "content": "```\\ntypedef long long int64;\\n\\n// credit: tourist\\ntemplate <typename T, class F = function<T(const T&, const T&)>>\\nstruct SparseTable {\\n    int n;\\n    std::vector<vector<T>> mat;\\n    F combine;\\n\\n    SparseTable(const std::vector<T>& a, const F& f) : combine(f) {\\n        n = static_cast<int>(a.size());\\n        int max_log = 32 - __builtin_clz(n);\\n        mat.resize(max_log);\\n        mat[0] = a;\\n        for (int j = 1; j < max_log; j++) {\\n            mat[j].resize(n - (1 << j) + 1);\\n            for (int i = 0; i <= n - (1 << j); i++) {\\n                mat[j][i] = combine(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);\\n            }\\n        }\\n    }\\n\\n    T get(int from, int to) const {\\n        assert(0 <= from && from <= to && to <= n - 1);\\n        int lg = 32 - __builtin_clz(to - from + 1) - 1;\\n        return combine(mat[lg][from], mat[lg][to - (1 << lg) + 1]);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        vector<int64> size(n);\\n        // here we are storing the minimum k for which the subarray as to be for \\n\\t\\t// the current element to be greater than the threshold / k\\n\\t\\tfor (int i = 0; i < n; ++i)\\n            size[i] = ((int64) nums[i] + threshold) / nums[i];\\n\\t\\t// we can use SparseTable to store the values and answer queries in O(1)\\n        SparseTable<int64> ST(size, [&](auto &a, auto &b) { return max(a, b); });\\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\t// for each index, we use 2 binary searches\\n\\t\\t\\t// we use the needed size for current index as a pivot\\n\\t\\t\\t// first binary search is to find the left most index such that from\\n\\t\\t\\t// that index to current index, we just need the subarray to be x length\\n\\t\\t\\t// the second binary search does the same for the right side\\n\\t\\t\\t// then we find the total length: Left + 1 + Right (the 1 is including current element)\\n\\t\\t\\t// if the length is >= to current necessary length, x, then we return that\\n\\t\\t\\t// otherwise we continue checking\\n            int x = size[i];\\n            int lo = 0, hi = i - 1, Left = 0, Right = 0;\\n            while (lo <= hi) {\\n                int mid = lo + hi >> 1;\\n                if (ST.get(mid, i - 1) <= x) {\\n                    Left = i - mid;\\n                    hi = mid - 1;\\n                } else {\\n                    lo = mid + 1;\\n                }\\n            }\\n            lo = i + 1, hi = n - 1;\\n            while (lo <= hi) {\\n                int mid = lo + hi >> 1;\\n                if (ST.get(i + 1, mid) <= x) {\\n                    Right = mid - i;\\n                    lo = mid + 1;\\n                } else {\\n                    hi = mid - 1;\\n                }\\n            }\\n            int tot = Left + 1 + Right;\\n            if (tot >= x) return x;\\n        }\\n\\t\\t// if we can\\'t find an answer, we should return -1\\n        return -1;\\n    }\\n};\\n```\\nTime Complexity: O(N * 2logN)\\nSpace Complexity: O(N * log N)\\nThis problem used to be solvable using similar idea but with segment tree but after they improved on the testcases the segment tree approach will TLE.\\nAlso, I know that this might not be the best approach in terms of space or time for this given problem but it\\'s better to see other distinct solutions.",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\ntypedef long long int64;\\n\\n// credit: tourist\\ntemplate <typename T, class F = function<T(const T&, const T&)>>\\nstruct SparseTable {\\n    int n;\\n    std::vector<vector<T>> mat;\\n    F combine;\\n\\n    SparseTable(const std::vector<T>& a, const F& f) : combine(f) {\\n        n = static_cast<int>(a.size());\\n        int max_log = 32 - __builtin_clz(n);\\n        mat.resize(max_log);\\n        mat[0] = a;\\n        for (int j = 1; j < max_log; j++) {\\n            mat[j].resize(n - (1 << j) + 1);\\n            for (int i = 0; i <= n - (1 << j); i++) {\\n                mat[j][i] = combine(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);\\n            }\\n        }\\n    }\\n\\n    T get(int from, int to) const {\\n        assert(0 <= from && from <= to && to <= n - 1);\\n        int lg = 32 - __builtin_clz(to - from + 1) - 1;\\n        return combine(mat[lg][from], mat[lg][to - (1 << lg) + 1]);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        vector<int64> size(n);\\n        // here we are storing the minimum k for which the subarray as to be for \\n\\t\\t// the current element to be greater than the threshold / k\\n\\t\\tfor (int i = 0; i < n; ++i)\\n            size[i] = ((int64) nums[i] + threshold) / nums[i];\\n\\t\\t// we can use SparseTable to store the values and answer queries in O(1)\\n        SparseTable<int64> ST(size, [&](auto &a, auto &b) { return max(a, b); });\\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\t// for each index, we use 2 binary searches\\n\\t\\t\\t// we use the needed size for current index as a pivot\\n\\t\\t\\t// first binary search is to find the left most index such that from\\n\\t\\t\\t// that index to current index, we just need the subarray to be x length\\n\\t\\t\\t// the second binary search does the same for the right side\\n\\t\\t\\t// then we find the total length: Left + 1 + Right (the 1 is including current element)\\n\\t\\t\\t// if the length is >= to current necessary length, x, then we return that\\n\\t\\t\\t// otherwise we continue checking\\n            int x = size[i];\\n            int lo = 0, hi = i - 1, Left = 0, Right = 0;\\n            while (lo <= hi) {\\n                int mid = lo + hi >> 1;\\n                if (ST.get(mid, i - 1) <= x) {\\n                    Left = i - mid;\\n                    hi = mid - 1;\\n                } else {\\n                    lo = mid + 1;\\n                }\\n            }\\n            lo = i + 1, hi = n - 1;\\n            while (lo <= hi) {\\n                int mid = lo + hi >> 1;\\n                if (ST.get(i + 1, mid) <= x) {\\n                    Right = mid - i;\\n                    lo = mid + 1;\\n                } else {\\n                    hi = mid - 1;\\n                }\\n            }\\n            int tot = Left + 1 + Right;\\n            if (tot >= x) return x;\\n        }\\n\\t\\t// if we can\\'t find an answer, we should return -1\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313357,
                "title": "c-monostack-same-with-largest-rectangle-in-histogram",
                "content": "the idea is exact the same with lc 84  Largest Rectangle in Histogram, for every number in nums, we need to calculate the largest width if we use this number as the lowest height, we can use a hashmap to record that, code is very similar to lc84 \\n\\n\\tint validSubarraySize(vector<int>& nums, int threshold) {\\n        unordered_map<int,int> mp;    //height: width\\n        vector<int> stk;\\n        nums.push_back(0);\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            while(!stk.empty()&&nums[stk.back()]>nums[i])\\n            {\\n                int t = stk.back();stk.pop_back();\\n                int k = stk.empty()?i:i-stk.back()-1;\\n                mp[nums[t]] = max(mp[nums[t]], k);\\n            }\\n            stk.push_back(i);\\n        }\\n        \\n        for(auto&iter:mp)\\n        {\\n\\t\\t\\t// height==0 or width == 0 should be ignored\\n            if(iter.first==0||iter.second==0)continue;\\n            if(double(iter.first)>double(threshold)/iter.second)\\n                return iter.second;\\n        }\\n        return -1;\\n    }",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "the idea is exact the same with lc 84  Largest Rectangle in Histogram, for every number in nums, we need to calculate the largest width if we use this number as the lowest height, we can use a hashmap to record that, code is very similar to lc84 \\n\\n\\tint validSubarraySize(vector<int>& nums, int threshold) {\\n        unordered_map<int,int> mp;    //height: width\\n        vector<int> stk;\\n        nums.push_back(0);\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            while(!stk.empty()&&nums[stk.back()]>nums[i])\\n            {\\n                int t = stk.back();stk.pop_back();\\n                int k = stk.empty()?i:i-stk.back()-1;\\n                mp[nums[t]] = max(mp[nums[t]], k);\\n            }\\n            stk.push_back(i);\\n        }\\n        \\n        for(auto&iter:mp)\\n        {\\n\\t\\t\\t// height==0 or width == 0 should be ignored\\n            if(iter.first==0||iter.second==0)continue;\\n            if(double(iter.first)>double(threshold)/iter.second)\\n                return iter.second;\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2312100,
                "title": "python-fast-solution-runtime-91-memory-91",
                "content": "**Solution**\\n\\n\\tfrom typing import List\\n\\tfrom heapq import heappush, heappop\\n\\n\\n\\tclass Solution:\\n\\t\\tdef validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n\\t\\t\\tp_d = dict()  # position dict : [Start counting  position, this num position]\\n\\t\\t\\tc = []  # dict.key sort\\n\\t\\t\\tnums.append(0.5)  # for finishing\\n\\n\\t\\t\\tfor i, value in enumerate(nums):\\n\\t\\t\\t\\tvalue = threshold // value + 1\\n\\t\\t\\t\\twhile c and value > c[0]:\\n\\t\\t\\t\\t\\tle = heappop(c)\\n\\t\\t\\t\\t\\tif p_d.pop(le)[0] + le <= i:\\n\\t\\t\\t\\t\\t\\treturn le\\n\\t\\t\\t\\tif value not in p_d.keys():\\n\\t\\t\\t\\t\\tp_d[value] = [0 if not c else p_d[c[0]][1] + 1, i]\\n\\t\\t\\t\\t\\theappush(c, value)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tp_d[value][1] = i\\n\\t\\t\\treturn -1\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Solution**\\n\\n\\tfrom typing import List\\n\\tfrom heapq import heappush, heappop\\n\\n\\n\\tclass Solution:\\n\\t\\tdef validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n\\t\\t\\tp_d = dict()  # position dict : [Start counting  position, this num position]\\n\\t\\t\\tc = []  # dict.key sort\\n\\t\\t\\tnums.append(0.5)  # for finishing\\n\\n\\t\\t\\tfor i, value in enumerate(nums):\\n\\t\\t\\t\\tvalue = threshold // value + 1\\n\\t\\t\\t\\twhile c and value > c[0]:\\n\\t\\t\\t\\t\\tle = heappop(c)\\n\\t\\t\\t\\t\\tif p_d.pop(le)[0] + le <= i:\\n\\t\\t\\t\\t\\t\\treturn le\\n\\t\\t\\t\\tif value not in p_d.keys():\\n\\t\\t\\t\\t\\tp_d[value] = [0 if not c else p_d[c[0]][1] + 1, i]\\n\\t\\t\\t\\t\\theappush(c, value)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tp_d[value][1] = i\\n\\t\\t\\treturn -1\\n",
                "codeTag": "Java"
            },
            {
                "id": 2295756,
                "title": "c-o-n-stack",
                "content": "class Solution {\\npublic:\\n\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        vector<int> nsl(n),nsr(n);\\n        stack<int> st,stk;\\n        nsr[n-1]=n;\\n        st.push(n-1);\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            while((!st.empty()) && nums[st.top()]>=nums[i])\\n                st.pop();\\n            \\n            if(st.empty())\\n                nsr[i]=n;\\n            else\\n                nsr[i]=st.top();\\n            \\n            st.push(i);\\n        }\\n        \\n        nsl[0]=-1;\\n        stk.push(0);\\n        for(int i=1; i<n; i++)\\n        {\\n            while((!stk.empty()) && nums[stk.top()]>=nums[i])\\n                stk.pop();\\n            \\n            if(stk.empty())\\n                nsl[i]=-1;\\n            else\\n                nsl[i]=stk.top();\\n            \\n            stk.push(i);\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int len = nsr[i]-nsl[i]-1;\\n            int mn = nums[i];\\n            if(mn>(threshold/len))\\n                return len;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        vector<int> nsl(n),nsr(n);\\n        stack<int> st,stk;\\n        nsr[n-1]=n;\\n        st.push(n-1);\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            while((!st.empty()) && nums[st.top()]>=nums[i])\\n                st.pop();\\n            \\n            if(st.empty())\\n                nsr[i]=n;\\n            else\\n                nsr[i]=st.top();\\n            \\n            st.push(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2295697,
                "title": "java-monostack-solution",
                "content": "This task is very similar to https://leetcode.com/problems/largest-rectangle-in-histogram/\\nWe can consider threshold as rectangle histogram square. So we need to find square > threshold\\n```\\npublic int validSubarraySize(int[] nums, int threshold) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int subArraySize = -1;\\n        for (int i = 0; i <= nums.length; i++) {\\n            while (!stack.isEmpty() && (i == nums.length || nums[stack.peek()] > nums[i])) {\\n                int height = nums[stack.pop()];\\n                int width = stack.isEmpty() ? i : i - stack.peek() - 1;\\n                if (height * width > threshold) return width;\\n            }\\n            stack.push(i);\\n        }\\n        return subArraySize;\\n    }\\n```",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```\\npublic int validSubarraySize(int[] nums, int threshold) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int subArraySize = -1;\\n        for (int i = 0; i <= nums.length; i++) {\\n            while (!stack.isEmpty() && (i == nums.length || nums[stack.peek()] > nums[i])) {\\n                int height = nums[stack.pop()];\\n                int width = stack.isEmpty() ? i : i - stack.peek() - 1;\\n                if (height * width > threshold) return width;\\n            }\\n            stack.push(i);\\n        }\\n        return subArraySize;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2292252,
                "title": "java-stack-o-n-15-lines-8ms",
                "content": "from votrubac\\'s C++ code  https://leetcode.com/problems/subarray-with-elements-greater-than-varying-threshold/discuss/2259557/Monostack\\nChanges:\\n1. Stack replaced with array, it\\'s much faster.  stack 191 ms, array 8 ms.\\n2. Divider replaced with multiplication.\\n\\n```\\n    public int validSubarraySize(int[] nums, int threshold) {\\n        int n = nums.length;\\n        int[] s = new int[n+1];\\n        s[0] = -1;\\n        int pos = 0;\\n        for(int i = 0; i<=n; i++){\\n            while(pos>0 && (i==n || nums[i]<nums[s[pos]])){\\n                int l = i - 1 - s[pos-1];\\n                if(l*nums[s[pos--]]>threshold) return l;\\n            }\\n            s[++pos]=i;\\n        }\\n        return -1;\\n    }    \\n```",
                "solutionTags": [],
                "code": "```\\n    public int validSubarraySize(int[] nums, int threshold) {\\n        int n = nums.length;\\n        int[] s = new int[n+1];\\n        s[0] = -1;\\n        int pos = 0;\\n        for(int i = 0; i<=n; i++){\\n            while(pos>0 && (i==n || nums[i]<nums[s[pos]])){\\n                int l = i - 1 - s[pos-1];\\n                if(l*nums[s[pos--]]>threshold) return l;\\n            }\\n            s[++pos]=i;\\n        }\\n        return -1;\\n    }    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2290566,
                "title": "java-monotonic-stack-faster-than-96-71-less-thatn-65-27",
                "content": "```\\nclass Solution {\\n    public int validSubarraySize(int[] nums, int threshold) {\\n        int top = -1;\\n        int[] pos = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            \\n            // greater than ...\\n            // EX: 6/4 = 1.5 -> 2\\n            // EX: 6/3 = 2   -> 3\\n            // -> Always plus 1 and use \">=\"\\n            int level = threshold/nums[i]+1;\\n            \\n            // Keep descending order\\n            while (top >= 0 && level > nums[top]) {\\n                \\n                // Calculate length\\n                int len = i-(top == 0 ? -1 : pos[top-1])-1;\\n                if (len >= nums[top--]) return nums[top+1];\\n            }\\n            pos[++top] = i;\\n            nums[top] = level;\\n        }\\n        while (top >= 0) {\\n            int len = nums.length-(top == 0 ? -1 : pos[top-1])-1;\\n            if (len >= nums[top--]) return nums[top+1];\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int validSubarraySize(int[] nums, int threshold) {\\n        int top = -1;\\n        int[] pos = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            \\n            // greater than ...\\n            // EX: 6/4 = 1.5 -> 2\\n            // EX: 6/3 = 2   -> 3\\n            // -> Always plus 1 and use \">=\"\\n            int level = threshold/nums[i]+1;\\n            \\n            // Keep descending order\\n            while (top >= 0 && level > nums[top]) {\\n                \\n                // Calculate length\\n                int len = i-(top == 0 ? -1 : pos[top-1])-1;\\n                if (len >= nums[top--]) return nums[top+1];\\n            }\\n            pos[++top] = i;\\n            nums[top] = level;\\n        }\\n        while (top >= 0) {\\n            int len = nums.length-(top == 0 ? -1 : pos[top-1])-1;\\n            if (len >= nums[top--]) return nums[top+1];\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2286366,
                "title": "c-dsu",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>fa,cnt;\\n    int findFather(int x)\\n    {\\n        if(fa[x]==x)return x;\\n        return fa[x]=findFather(fa[x]);\\n    }\\n    void Union(int x,int y)\\n    {\\n        x=fa[x],y=fa[y];\\n        int cnt_x=cnt[x],cnt_y=cnt[y];\\n        cnt[x]+=cnt_y,cnt[y]+=cnt_x;\\n        fa[y]=x;\\n    }\\n    int validSubarraySize(vector<int>& nums, int threshold) \\n    {\\n        int n=nums.size();\\n        fa.resize(n),cnt.resize(n);\\n        for(int i=0;i<n;i++)fa[i]=i,cnt[i]=1;\\n        vector<int>record(n);\\n        vector<pair<int,int>>at_least(n);\\n        for(int i=0;i<n;i++)at_least[i]={ceil(1.0*(threshold+1)/nums[i]),i};\\n        for(int i=0;i<n;i++)record[i]=at_least[i].first;\\n        sort(at_least.begin(),at_least.end());\\n        for(auto &x:at_least)\\n        {\\n            int len=x.first,idx=x.second;\\n            if(idx-1>=0&&(findFather(idx-1)!=findFather(idx))&&record[idx-1]<=len)Union(idx,idx-1);\\n            if(idx+1<n&&(findFather(idx+1)!=findFather(idx))&&record[idx+1]<=len)Union(idx,idx+1);\\n            if(cnt[fa[idx]]>=len)return len;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>fa,cnt;\\n    int findFather(int x)\\n    {\\n        if(fa[x]==x)return x;\\n        return fa[x]=findFather(fa[x]);\\n    }\\n    void Union(int x,int y)\\n    {\\n        x=fa[x],y=fa[y];\\n        int cnt_x=cnt[x],cnt_y=cnt[y];\\n        cnt[x]+=cnt_y,cnt[y]+=cnt_x;\\n        fa[y]=x;\\n    }\\n    int validSubarraySize(vector<int>& nums, int threshold) \\n    {\\n        int n=nums.size();\\n        fa.resize(n),cnt.resize(n);\\n        for(int i=0;i<n;i++)fa[i]=i,cnt[i]=1;\\n        vector<int>record(n);\\n        vector<pair<int,int>>at_least(n);\\n        for(int i=0;i<n;i++)at_least[i]={ceil(1.0*(threshold+1)/nums[i]),i};\\n        for(int i=0;i<n;i++)record[i]=at_least[i].first;\\n        sort(at_least.begin(),at_least.end());\\n        for(auto &x:at_least)\\n        {\\n            int len=x.first,idx=x.second;\\n            if(idx-1>=0&&(findFather(idx-1)!=findFather(idx))&&record[idx-1]<=len)Union(idx,idx-1);\\n            if(idx+1<n&&(findFather(idx+1)!=findFather(idx))&&record[idx+1]<=len)Union(idx,idx+1);\\n            if(cnt[fa[idx]]>=len)return len;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285595,
                "title": "python-typescript-stack-devide-and-conquer",
                "content": "## Stack approach O(n)\\n**Intuition :** Greedily, for each element `x`, find the longest array containing `x` , if whose length times x is greater than threshold we return the answer (This can easily by done by using stack to find next/previous greater smaller element)\\n**Python** :\\n```python\\ndef validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        nums = [0] + nums + [0]\\n        left = []\\n        s = []\\n        for i,num in enumerate(nums):\\n            while s and nums[s[-1]] >= num:\\n                j = s.pop()\\n                if (i-left[j]) * nums[j] > threshold:\\n                    return i-left[j]\\n            left.append(s and s[-1]+1 or 0)\\n            s.append(i)\\n        return -1\\n ```\\n \\n ## Devide and conquer O(nlogn)\\n **Intuition**: Same idea, the expected subarary must include at most one element of the given array, with divide and conquer. The middle element of at least one divided subarray would be contained by the expected subarray. Traverse from the mid to the left, find the furthest element in the right half that is greather than or equal to the smaller element of the part [left..mid], if `min * length > threshold` return the answer. \\n**Typescript**(devide and conquer):\\n```typescript\\nfunction validSubarraySize(A: number[], threshold: number): number {\\n  let res = -1;\\n  function find(i:number, j:number){\\n    let m = (i+j)>>1; \\n    let t = 1 / 0 , r = m+1;\\n    for (let k = m ; k >= i ; k--){\\n      t = Math.min(t, A[k]) ; \\n      while (r <= j && A[r] >= t) r++ ; \\n      if (t * (r-k) > threshold) res = Math.max(res, r-k) ; \\n    }\\n    for (; r <= j ; r++){\\n        t = Math.min(t, A[r]) ;\\n        if (t * (r-i) > threshold) res = Math.max(res, r-i) ; \\n    }\\n    if (i < j)\\n        find(i,m), find(m+1,j) ; \\n  }\\n  find(0, A.length-1) ; \\n  return res ;\\n};\\n```",
                "solutionTags": [],
                "code": "```python\\ndef validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        nums = [0] + nums + [0]\\n        left = []\\n        s = []\\n        for i,num in enumerate(nums):\\n            while s and nums[s[-1]] >= num:\\n                j = s.pop()\\n                if (i-left[j]) * nums[j] > threshold:\\n                    return i-left[j]\\n            left.append(s and s[-1]+1 or 0)\\n            s.append(i)\\n        return -1\\n ```\n```typescript\\nfunction validSubarraySize(A: number[], threshold: number): number {\\n  let res = -1;\\n  function find(i:number, j:number){\\n    let m = (i+j)>>1; \\n    let t = 1 / 0 , r = m+1;\\n    for (let k = m ; k >= i ; k--){\\n      t = Math.min(t, A[k]) ; \\n      while (r <= j && A[r] >= t) r++ ; \\n      if (t * (r-k) > threshold) res = Math.max(res, r-k) ; \\n    }\\n    for (; r <= j ; r++){\\n        t = Math.min(t, A[r]) ;\\n        if (t * (r-i) > threshold) res = Math.max(res, r-i) ; \\n    }\\n    if (i < j)\\n        find(i,m), find(m+1,j) ; \\n  }\\n  find(0, A.length-1) ; \\n  return res ;\\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2284172,
                "title": "simple-c-monotonic-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int sz=nums.size();\\n        //here we are finding the smaller element to every ith element in left and right side so that we can get a window where all element are greater than equal to ith element.\\n        //left and right smaller element position can easily be find out by monotonic stack.\\n        vector<int> left_smaller(sz,-1);\\n        stack<int> st;\\n        for(int i=0;i<sz;i++){\\n            while(!st.empty()&&nums[st.top()]>=nums[i])st.pop();\\n            if(!st.empty())left_smaller[i]=st.top();\\n            st.push(i);\\n        }\\n        while(!st.empty())st.pop();\\n        vector<int> right_smaller(sz,sz);\\n        for(int i=sz-1;i>=0;i--){\\n            while(!st.empty()&&nums[st.top()]>=nums[i]){\\n                st.pop();\\n            }\\n            if(!st.empty())right_smaller[i]=st.top();\\n           \\n            st.push(i);\\n        }\\n        for(int i=0;i<sz;i++){\\n            int k=right_smaller[i]-left_smaller[i]-1;//size of window where every element is greater than equal to ith element.\\n            double val=(double)(threshold)/k;\\n            if(nums[i]>val)return k;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int sz=nums.size();\\n        //here we are finding the smaller element to every ith element in left and right side so that we can get a window where all element are greater than equal to ith element.\\n        //left and right smaller element position can easily be find out by monotonic stack.\\n        vector<int> left_smaller(sz,-1);\\n        stack<int> st;\\n        for(int i=0;i<sz;i++){\\n            while(!st.empty()&&nums[st.top()]>=nums[i])st.pop();\\n            if(!st.empty())left_smaller[i]=st.top();\\n            st.push(i);\\n        }\\n        while(!st.empty())st.pop();\\n        vector<int> right_smaller(sz,sz);\\n        for(int i=sz-1;i>=0;i--){\\n            while(!st.empty()&&nums[st.top()]>=nums[i]){\\n                st.pop();\\n            }\\n            if(!st.empty())right_smaller[i]=st.top();\\n           \\n            st.push(i);\\n        }\\n        for(int i=0;i<sz;i++){\\n            int k=right_smaller[i]-left_smaller[i]-1;//size of window where every element is greater than equal to ith element.\\n            double val=(double)(threshold)/k;\\n            if(nums[i]>val)return k;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283122,
                "title": "linear-time-solution-using-stacks-and-2-passes-on-input-array",
                "content": "For each element in the input array we need to find maximum length sub-array including this element where it is the smallest element. For example for input array [1,3,4,3,1], if we want to calculate sub-array for second element 3 then we can see that max length sub-array whose all elements are >= 3 is from index 1 to 3.\\nIn order to find this for each element we can use stack and use one forward pass for finding first right element bigger than it and reverse pass for finding first left element bigger than it.\\nThen for satisfying threshold condition on each element we need to check that for each element if max sub-array size with it as the smallest element is > (threshold/element). If any such element exists then all other elements in that sub-array will automatically satisfy the threshold constraint as they all will be bigger than this element and this size can be returned as a valid answer. Code below:\\n\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        vector<int> left(nums.size(), -1), right(nums.size(), -1);\\n        stack<int> s;\\n        right[nums.size()-1] = nums.size()-1;\\n        s.push(0);\\n        for(int i = 1; i < nums.size(); i++){\\n            while(!s.empty() && nums[s.top()] > nums[i]){\\n                right[s.top()] = i;\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n        if(!s.empty()){\\n            int v = s.top();\\n            s.pop();\\n            while(!s.empty()){\\n                right[s.top()] = v;\\n                s.pop();\\n            }    \\n        }\\n        \\n        left[0] = 0;\\n        s.push(nums.size()-1);\\n        for(int i = nums.size()-1; i >= 0; i--){\\n            while(!s.empty() && nums[s.top()] > nums[i]){\\n                left[s.top()] = i;\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n        if(!s.empty()){\\n            int v = s.top();\\n            s.pop();\\n            while(!s.empty()){\\n                left[s.top()] = v;\\n                s.pop();\\n            }    \\n        }\\n        \\n        int size = -1;\\n        for(int i = 0; i < nums.size(); i++){\\n            int r = right[i];\\n            if(right[i] < nums.size()-1 || nums[i] > nums[nums.size()-1]){\\n                r = right[i]-1;\\n            }\\n            int l = left[i];\\n            if(left[i] > 0 || nums[i] > nums[0]){\\n                l = left[i]+1;\\n            }\\n            int k = r-l+1;\\n            if(k > ceil(threshold/nums[i])){\\n                size = k;\\n                break;\\n            }\\n        }\\n        return size;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        vector<int> left(nums.size(), -1), right(nums.size(), -1);\\n        stack<int> s;\\n        right[nums.size()-1] = nums.size()-1;\\n        s.push(0);\\n        for(int i = 1; i < nums.size(); i++){\\n            while(!s.empty() && nums[s.top()] > nums[i]){\\n                right[s.top()] = i;\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n        if(!s.empty()){\\n            int v = s.top();\\n            s.pop();\\n            while(!s.empty()){\\n                right[s.top()] = v;\\n                s.pop();\\n            }    \\n        }\\n        \\n        left[0] = 0;\\n        s.push(nums.size()-1);\\n        for(int i = nums.size()-1; i >= 0; i--){\\n            while(!s.empty() && nums[s.top()] > nums[i]){\\n                left[s.top()] = i;\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n        if(!s.empty()){\\n            int v = s.top();\\n            s.pop();\\n            while(!s.empty()){\\n                left[s.top()] = v;\\n                s.pop();\\n            }    \\n        }\\n        \\n        int size = -1;\\n        for(int i = 0; i < nums.size(); i++){\\n            int r = right[i];\\n            if(right[i] < nums.size()-1 || nums[i] > nums[nums.size()-1]){\\n                r = right[i]-1;\\n            }\\n            int l = left[i];\\n            if(left[i] > 0 || nums[i] > nums[0]){\\n                l = left[i]+1;\\n            }\\n            int k = r-l+1;\\n            if(k > ceil(threshold/nums[i])){\\n                size = k;\\n                break;\\n            }\\n        }\\n        return size;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2275091,
                "title": "c-impressive-move-next-greater-previous-greater",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pi(vector<int>& heights)\\n    {   int n=heights.size();\\n        stack<pair<int, int> > s;\\n        vector<int> ans(n);\\n        \\n         for (int i = 0; i < n; i++) {\\n          int next = heights[i];\\n          \\n         \\n         while (!s.empty() && s.top().first <=next) {\\n            s.pop();}\\n         if (s.empty()) {s.push({ next, i });ans[i]=-1;continue;}    \\n         if(s.top().first > next){ans[i]=s.top().second;}    \\n         s.push({ next, i });    \\n         }\\n        \\n     return ans;\\n    }\\n    \\n   vector<int> ni(vector<int>& heights)\\n    {   int si=heights.size();\\n        stack<pair<int, int> > s;\\n        vector<int> ans(si);\\n        \\n         for (int i = si-1; i >=0; i--) {\\n          int next = heights[i];\\n         \\n         while (!s.empty() && s.top().first<=next) {\\n            s.pop();}\\n         if (s.empty()) {s.push({ next, i });ans[i]=si;continue;}    \\n         if(s.top().first > next){ans[i]=s.top().second;}    \\n         s.push({ next, i });    \\n         }\\n        \\n     return ans;\\n    }\\n    \\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        \\n        vector<int> arr(nums.size());\\n        int n = nums.size();\\n        \\n       for(int i=0;i<nums.size();i=i+1)\\n       {\\n           arr[i] = (threshold/nums[i]) + 1;\\n       }\\n        \\n      vector<int> ns = ni(arr);\\n      vector<int> ps = pi(arr);\\n         \\n      vector<int> ans(n);\\n        \\n        \\n      for(int i=0;i<n;i=i+1)\\n      {\\n          ans[i] = ns[i] - ps[i] -1;\\n          if(ans[i]>=arr[i]){return arr[i];}\\n      }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pi(vector<int>& heights)\\n    {   int n=heights.size();\\n        stack<pair<int, int> > s;\\n        vector<int> ans(n);\\n        \\n         for (int i = 0; i < n; i++) {\\n          int next = heights[i];\\n          \\n         \\n         while (!s.empty() && s.top().first <=next) {\\n            s.pop();}\\n         if (s.empty()) {s.push({ next, i });ans[i]=-1;continue;}    \\n         if(s.top().first > next){ans[i]=s.top().second;}    \\n         s.push({ next, i });    \\n         }\\n        \\n     return ans;\\n    }\\n    \\n   vector<int> ni(vector<int>& heights)\\n    {   int si=heights.size();\\n        stack<pair<int, int> > s;\\n        vector<int> ans(si);\\n        \\n         for (int i = si-1; i >=0; i--) {\\n          int next = heights[i];\\n         \\n         while (!s.empty() && s.top().first<=next) {\\n            s.pop();}\\n         if (s.empty()) {s.push({ next, i });ans[i]=si;continue;}    \\n         if(s.top().first > next){ans[i]=s.top().second;}    \\n         s.push({ next, i });    \\n         }\\n        \\n     return ans;\\n    }\\n    \\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        \\n        vector<int> arr(nums.size());\\n        int n = nums.size();\\n        \\n       for(int i=0;i<nums.size();i=i+1)\\n       {\\n           arr[i] = (threshold/nums[i]) + 1;\\n       }\\n        \\n      vector<int> ns = ni(arr);\\n      vector<int> ps = pi(arr);\\n         \\n      vector<int> ans(n);\\n        \\n        \\n      for(int i=0;i<n;i=i+1)\\n      {\\n          ans[i] = ns[i] - ps[i] -1;\\n          if(ans[i]>=arr[i]){return arr[i];}\\n      }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269754,
                "title": "solution-using-monotonic-stack-c",
                "content": "```\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> next_smaller(vector<int> &nums, int n)\\n    {\\n        vector<int> vec1(n, n);\\n        stack<int> st;\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            if (!st.empty())\\n            {\\n                while (!st.empty() && nums[st.top()] >= nums[i])\\n                {\\n\\n                    st.pop();\\n                }\\n                if (!st.empty() && nums[st.top()] < nums[i])\\n                {\\n                    vec1[i] = st.top();\\n                }\\n            }\\n            st.push(i);\\n        }\\n\\n        return vec1;\\n    }\\n\\n    vector<int> prev_smaller(vector<int> &nums, int n)\\n    {\\n        vector<int> vec1(n, -1);\\n        stack<int> st;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (!st.empty())\\n            {\\n                while (!st.empty() && nums[st.top()] >= nums[i])\\n                {\\n\\n                    st.pop();\\n                }\\n                if (!st.empty() && nums[st.top()] < nums[i])\\n                {\\n                    vec1[i] = st.top();\\n                }\\n            }\\n            st.push(i);\\n        }\\n\\n        return vec1;\\n    }\\n\\n    int validSubarraySize(vector<int> &nums, int t)\\n    {\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (nums[i] > t)\\n                return 1;\\n        }\\n        if (*max_element(nums.begin(), nums.end()) <= t / n)\\n            return -1;\\n        vector<int> vec1 = next_smaller(nums, n);\\n        vector<int> vec2 = prev_smaller(nums, n);\\n        int k = -1;\\n        for (int i = 0; i < n; i++)\\n        {\\n            k = vec1[i] - vec2[i]-1;\\n            \\n                if (nums[i] > t / k)\\n                    return k;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> next_smaller(vector<int> &nums, int n)\\n    {\\n        vector<int> vec1(n, n);\\n        stack<int> st;\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            if (!st.empty())\\n            {\\n                while (!st.empty() && nums[st.top()] >= nums[i])\\n                {\\n\\n                    st.pop();\\n                }\\n                if (!st.empty() && nums[st.top()] < nums[i])\\n                {\\n                    vec1[i] = st.top();\\n                }\\n            }\\n            st.push(i);\\n        }\\n\\n        return vec1;\\n    }\\n\\n    vector<int> prev_smaller(vector<int> &nums, int n)\\n    {\\n        vector<int> vec1(n, -1);\\n        stack<int> st;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (!st.empty())\\n            {\\n                while (!st.empty() && nums[st.top()] >= nums[i])\\n                {\\n\\n                    st.pop();\\n                }\\n                if (!st.empty() && nums[st.top()] < nums[i])\\n                {\\n                    vec1[i] = st.top();\\n                }\\n            }\\n            st.push(i);\\n        }\\n\\n        return vec1;\\n    }\\n\\n    int validSubarraySize(vector<int> &nums, int t)\\n    {\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (nums[i] > t)\\n                return 1;\\n        }\\n        if (*max_element(nums.begin(), nums.end()) <= t / n)\\n            return -1;\\n        vector<int> vec1 = next_smaller(nums, n);\\n        vector<int> vec2 = prev_smaller(nums, n);\\n        int k = -1;\\n        for (int i = 0; i < n; i++)\\n        {\\n            k = vec1[i] - vec2[i]-1;\\n            \\n                if (nums[i] > t / k)\\n                    return k;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269466,
                "title": "javascript-monotonous-increasing-array-based-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} threshold\\n * @return {number}\\n */\\nvar validSubarraySize = function(nums, threshold) {\\n    /*\\n    Approach: Use monotonous increasing array\\n    */\\n    let stack=[];\\n    for(let i=0;i<nums.length;i++){\\n        let start = i;\\n        while(stack.length>0 && stack[stack.length-1][0]>nums[i]){\\n            let popped = stack.pop();\\n            let min = popped[0];\\n            let len = i-popped[1];\\n            if(min>threshold/len){\\n                return len;\\n            }\\n            start = popped[1];\\n        }\\n        stack.push([nums[i],start]);\\n    }\\n    let end = nums.length-1;\\n    for(let i=0;i<stack.length;i++){\\n        let len = end - stack[i][1] +1;\\n        let min = stack[i][0];\\n        if(min>threshold/len){\\n            return len;\\n        }\\n    }\\n    return -1;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} threshold\\n * @return {number}\\n */\\nvar validSubarraySize = function(nums, threshold) {\\n    /*\\n    Approach: Use monotonous increasing array\\n    */\\n    let stack=[];\\n    for(let i=0;i<nums.length;i++){\\n        let start = i;\\n        while(stack.length>0 && stack[stack.length-1][0]>nums[i]){\\n            let popped = stack.pop();\\n            let min = popped[0];\\n            let len = i-popped[1];\\n            if(min>threshold/len){\\n                return len;\\n            }\\n            start = popped[1];\\n        }\\n        stack.push([nums[i],start]);\\n    }\\n    let end = nums.length-1;\\n    for(let i=0;i<stack.length;i++){\\n        let len = end - stack[i][1] +1;\\n        let min = stack[i][0];\\n        if(min>threshold/len){\\n            return len;\\n        }\\n    }\\n    return -1;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2269453,
                "title": "o-n-c-based-on-next-smaller-left-and-right-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n\\t//function for finding next smaller element index on right\\n    vector<int> nextSmallerRight(vector<int>& nums){\\n        stack<int> st;\\n        int n=nums.size();\\n        \\n        vector<int> vec;\\n        for(int i=n-1;i>=0;i--){\\n            if(st.empty()){\\n                vec.push_back(n);\\n            }else{\\n                if(nums[st.top()]<nums[i]){\\n                    vec.push_back(st.top());\\n                }else{\\n                    while(!st.empty()&&nums[st.top()]>=nums[i]){\\n                        st.pop();\\n                    }\\n                    \\n                    if(st.empty()){\\n                        vec.push_back(n);\\n                    }else{\\n                        vec.push_back(st.top());\\n                    }    \\n                }\\n            }    \\n         st.push(i);   \\n        }\\n        reverse(vec.begin(),vec.end());\\n        return vec;\\n    }\\n    \\n\\t //function for finding next smaller element index on left\\n     vector<int> nextSmallerLeft(vector<int>& nums){\\n        stack<int> st;\\n        int n=nums.size();\\n        \\n        vector<int> vec;\\n        for(int i=0;i<n;i++){\\n            if(st.empty()){\\n                vec.push_back(-1);\\n            }else{\\n                if(nums[st.top()]<nums[i]){\\n                    vec.push_back(st.top());\\n                }else{\\n                    while(!st.empty()&&nums[st.top()]>=nums[i]){\\n                        st.pop();\\n                    }\\n                    \\n                    if(st.empty()){\\n                        vec.push_back(-1);\\n                    }else{\\n                        vec.push_back(st.top());\\n                    }\\n                }\\n            }    \\n         st.push(i);   \\n        }\\n        // reverse(vec.begin(),vec.end());\\n        return vec;\\n    }\\n    int validSubarraySize(vector<int>& nums, int th) {\\n        vector<int> nsl=nextSmallerLeft(nums); //next smaller left (nsl)\\n        vector<int> nsr=nextSmallerRight(nums); //next smaller right (nsr)\\n        \\t\\t\\n\\t\\t//according to question th/k < element \\n\\t\\t//so th/element < k \\n\\t\\t//k is length of subarray whose all element greater than or equal nums[i]\\n        for(int i=0;i<nums.size();i++){\\n            if(th/nums[i]<(nsr[i]-nsl[i]-1)){\\n               return  th/nums[i]+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t//function for finding next smaller element index on right\\n    vector<int> nextSmallerRight(vector<int>& nums){\\n        stack<int> st;\\n        int n=nums.size();\\n        \\n        vector<int> vec;\\n        for(int i=n-1;i>=0;i--){\\n            if(st.empty()){\\n                vec.push_back(n);\\n            }else{\\n                if(nums[st.top()]<nums[i]){\\n                    vec.push_back(st.top());\\n                }else{\\n                    while(!st.empty()&&nums[st.top()]>=nums[i]){\\n                        st.pop();\\n                    }\\n                    \\n                    if(st.empty()){\\n                        vec.push_back(n);\\n                    }else{\\n                        vec.push_back(st.top());\\n                    }    \\n                }\\n            }    \\n         st.push(i);   \\n        }\\n        reverse(vec.begin(),vec.end());\\n        return vec;\\n    }\\n    \\n\\t //function for finding next smaller element index on left\\n     vector<int> nextSmallerLeft(vector<int>& nums){\\n        stack<int> st;\\n        int n=nums.size();\\n        \\n        vector<int> vec;\\n        for(int i=0;i<n;i++){\\n            if(st.empty()){\\n                vec.push_back(-1);\\n            }else{\\n                if(nums[st.top()]<nums[i]){\\n                    vec.push_back(st.top());\\n                }else{\\n                    while(!st.empty()&&nums[st.top()]>=nums[i]){\\n                        st.pop();\\n                    }\\n                    \\n                    if(st.empty()){\\n                        vec.push_back(-1);\\n                    }else{\\n                        vec.push_back(st.top());\\n                    }\\n                }\\n            }    \\n         st.push(i);   \\n        }\\n        // reverse(vec.begin(),vec.end());\\n        return vec;\\n    }\\n    int validSubarraySize(vector<int>& nums, int th) {\\n        vector<int> nsl=nextSmallerLeft(nums); //next smaller left (nsl)\\n        vector<int> nsr=nextSmallerRight(nums); //next smaller right (nsr)\\n        \\t\\t\\n\\t\\t//according to question th/k < element \\n\\t\\t//so th/element < k \\n\\t\\t//k is length of subarray whose all element greater than or equal nums[i]\\n        for(int i=0;i<nums.size();i++){\\n            if(th/nums[i]<(nsr[i]-nsl[i]-1)){\\n               return  th/nums[i]+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269088,
                "title": "c-o-n-next-smaller-element-stack",
                "content": "```\\npublic:\\n    int validSubarraySize(vector<int>& nums, int t) {\\n        int n=nums.size();\\n        vector<int> l(n);\\n        vector<int> r(n);\\n        stack<pair<int,int>> st1;\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!st1.empty() && st1.top().first>=nums[i])\\n                st1.pop();\\n            if(st1.empty())\\n                l[i]=-1;\\n            else\\n                l[i]=st1.top().second;\\n            st1.push({nums[i],i});\\n        }\\n        stack<pair<int,int>> st2;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st2.empty() && st2.top().first>=nums[i])\\n                st2.pop();\\n            if(st2.empty())\\n                r[i]=n;\\n            else\\n                r[i]=st2.top().second;\\n            st2.push({nums[i],i});\\n        }\\n        // for(auto i:l)\\n        //     cout<<i<<\" \";\\n        // cout<<endl;\\n        // for(auto i:r)\\n        //     cout<<i<<\" \";\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            int k=t/nums[i];\\n            int s=r[i]-l[i]-1;\\n            if(s>=k+1)\\n                ans=min(ans,k+1);\\n        }\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\npublic:\\n    int validSubarraySize(vector<int>& nums, int t) {\\n        int n=nums.size();\\n        vector<int> l(n);\\n        vector<int> r(n);\\n        stack<pair<int,int>> st1;\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!st1.empty() && st1.top().first>=nums[i])\\n                st1.pop();\\n            if(st1.empty())\\n                l[i]=-1;\\n            else\\n                l[i]=st1.top().second;\\n            st1.push({nums[i],i});\\n        }\\n        stack<pair<int,int>> st2;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st2.empty() && st2.top().first>=nums[i])\\n                st2.pop();\\n            if(st2.empty())\\n                r[i]=n;\\n            else\\n                r[i]=st2.top().second;\\n            st2.push({nums[i],i});\\n        }\\n        // for(auto i:l)\\n        //     cout<<i<<\" \";\\n        // cout<<endl;\\n        // for(auto i:r)\\n        //     cout<<i<<\" \";\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            int k=t/nums[i];\\n            int s=r[i]-l[i]-1;\\n            if(s>=k+1)\\n                ans=min(ans,k+1);\\n        }\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};",
                "codeTag": "C++"
            },
            {
                "id": 2268960,
                "title": "c-monotonic-stack",
                "content": "For each <code>nums[i]</code>, find the range <code>range[i]</code> where it is the minimum value through two monotonic stacks, then check whether <code>range[i] &gt; (threshold / nums[i])</code>\\n\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        vector<int> range(n);\\n        stack<int> s, t;\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            while (!s.empty() && nums[s.top()] >= nums[i])\\n                s.pop();\\n            if (s.empty())\\n                range[i] = n;\\n            else\\n                range[i] = s.top();\\n            s.push(i);\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n            while (!t.empty() && nums[t.top()] >= nums[i])\\n                t.pop();\\n            if (t.empty())\\n                range[i] -= 0;\\n            else\\n                range[i] -= (t.top() + 1);\\n            t.push(i);\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n            double c = (double)threshold / nums[i];\\n            if (range[i] > c)\\n                return range[i];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        vector<int> range(n);\\n        stack<int> s, t;\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            while (!s.empty() && nums[s.top()] >= nums[i])\\n                s.pop();\\n            if (s.empty())\\n                range[i] = n;\\n            else\\n                range[i] = s.top();\\n            s.push(i);\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n            while (!t.empty() && nums[t.top()] >= nums[i])\\n                t.pop();\\n            if (t.empty())\\n                range[i] -= 0;\\n            else\\n                range[i] -= (t.top() + 1);\\n            t.push(i);\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n            double c = (double)threshold / nums[i];\\n            if (range[i] > c)\\n                return range[i];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268310,
                "title": "stack-find-left-min-find-right-min",
                "content": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        stack=[]\\n        right=[-1 for i in range(len(nums))]\\n        left=[-1 for i in range(len(nums))]\\n        for i in range(len(nums)):\\n            while(stack and stack[-1][1]>nums[i]):\\n                ind,val=stack.pop()\\n                right[ind]=i\\n            stack.append([i,nums[i]])\\n        #print(right)\\n        stack=[]\\n        rev=nums[::-1]\\n        for i in range(len(rev)):\\n            while(stack and stack[-1][1]>rev[i]):\\n                ind,val=stack.pop()\\n                left[ind]=i\\n            stack.append([i,rev[i]])\\n        left=left[::-1]\\n        \\n        for i in range(len(left)):\\n            if left[i]!=-1:\\n                left[i]=len(left)-1-left[i]\\n        #print(left)\\n        \\n        for i in range(len(nums)):\\n            l,r=left[i],right[i]\\n            if l==-1:\\n                l=0\\n            else:\\n                l=min(l+1,len(nums)-1)\\n            if r==-1:\\n                r=len(nums)-1\\n            else:\\n                r=max(r-1,0)\\n            \\n            totalLen=(r-l+1)\\n            temp=threshold/totalLen\\n            if nums[i]>temp:\\n                return totalLen\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        stack=[]\\n        right=[-1 for i in range(len(nums))]\\n        left=[-1 for i in range(len(nums))]\\n        for i in range(len(nums)):\\n            while(stack and stack[-1][1]>nums[i]):\\n                ind,val=stack.pop()\\n                right[ind]=i\\n            stack.append([i,nums[i]])\\n        #print(right)\\n        stack=[]\\n        rev=nums[::-1]\\n        for i in range(len(rev)):\\n            while(stack and stack[-1][1]>rev[i]):\\n                ind,val=stack.pop()\\n                left[ind]=i\\n            stack.append([i,rev[i]])\\n        left=left[::-1]\\n        \\n        for i in range(len(left)):\\n            if left[i]!=-1:\\n                left[i]=len(left)-1-left[i]\\n        #print(left)\\n        \\n        for i in range(len(nums)):\\n            l,r=left[i],right[i]\\n            if l==-1:\\n                l=0\\n            else:\\n                l=min(l+1,len(nums)-1)\\n            if r==-1:\\n                r=len(nums)-1\\n            else:\\n                r=max(r-1,0)\\n            \\n            totalLen=(r-l+1)\\n            temp=threshold/totalLen\\n            if nums[i]>temp:\\n                return totalLen\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267239,
                "title": "can-anyone-tell-me-why-this-is-happening",
                "content": "\\n\\n![image](https://assets.leetcode.com/users/images/fa6685b7-eac7-4071-a907-aaf7af182ed2_1657528126.9411504.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        stack<int> st ;\\n        vector<int>left(nums.size(),-1),right(nums.size(),nums.size()) ;\\n        \\n        //build next smaller element on left\\n        for(int i = 0 ; i < nums.size() ; ++i ){\\n            while(st.size() and nums[i] <= nums[st.top()]) st.pop() ;\\n            if(st.size()) left[i] = st.top() ;\\n            st.push(i);\\n        }\\n        \\n        while(st.size()) st.pop();\\n        //build next smaller element on right\\n        for(int i = nums.size() - 1 ; i >= 0 ; --i ){\\n            while(st.size() and nums[i] <= nums[st.top()]) st.pop() ;\\n            if(st.size()) right[i] = st.top() ;\\n            st.push(i);\\n        }\\n        \\n        //evaluate answer\\n        for(int i = 0 ; i < nums.size() ; ++i ){\\n            int k = right[i] - left[i] - 1 ;\\n            if(k *1LL* nums[i] *1LL > threshold * 1LL) return k ;\\n        }\\n        return -1 ;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        stack<int> st ;\\n        vector<int>left(nums.size(),-1),right(nums.size(),nums.size()) ;\\n        \\n        //build next smaller element on left\\n        for(int i = 0 ; i < nums.size() ; ++i ){\\n            while(st.size() and nums[i] <= nums[st.top()]) st.pop() ;\\n            if(st.size()) left[i] = st.top() ;\\n            st.push(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2266038,
                "title": "c-union-find",
                "content": "```\\nreference: \\nhttps://www.bilibili.com/video/BV1s94y197XG?spm_id_from=333.337.search-card.all.click&vd_source=bfa6992d87ca52dd825f32026f176e7a \\n#include <bits/stdc++.h>\\nusing namespace std;\\nconst int N = 1e5 + 10;\\nint A[N], sz[N], max_N;\\nclass Solution {\\npublic:\\n\\tvoid init(int n) {\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tA[i] = i;\\n\\t\\t\\tsz[i] = 1;\\n\\t\\t}\\n\\t\\tmax_N = 0;\\n\\t}\\n\\n\\tint find(int i) {\\n\\t\\tif (A[i] == i) return i;\\n\\t\\treturn A[i] = find(A[i]);\\n\\t}\\n\\t\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        init(nums.size() + 1);\\n\\t\\tnums.push_back(0);\\n\\t\\tvector<int> c;\\n\\t\\tc.resize(nums.size());\\n\\t\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\t\\tc[i] = i;\\n\\t\\t}\\n\\t\\tsort(c.begin(), c.end(), [&](int a, int b) -> bool {\\n\\t\\t\\treturn nums[a] > nums[b];\\n\\t\\t});\\n\\t\\tfor (int i = 1, j = 0; i < c.size(); i++) {\\n\\t\\t\\twhile (j < c.size() - 1 &&  nums[c[j]] > threshold / i) {\\n\\t\\t\\t\\tint curr = c[j];\\n\\t\\t\\t\\tint next = find(c[j] + 1);\\n\\t\\t\\t\\tsz[next] += sz[curr];\\n\\t\\t\\t\\tA[curr] = next;\\n\\t\\t\\t\\tif (sz[next] - 1  >= i) {\\n\\t\\t\\t\\t\\treturn i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nreference: \\nhttps://www.bilibili.com/video/BV1s94y197XG?spm_id_from=333.337.search-card.all.click&vd_source=bfa6992d87ca52dd825f32026f176e7a \\n#include <bits/stdc++.h>\\nusing namespace std;\\nconst int N = 1e5 + 10;\\nint A[N], sz[N], max_N;\\nclass Solution {\\npublic:\\n\\tvoid init(int n) {\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tA[i] = i;\\n\\t\\t\\tsz[i] = 1;\\n\\t\\t}\\n\\t\\tmax_N = 0;\\n\\t}\\n\\n\\tint find(int i) {\\n\\t\\tif (A[i] == i) return i;\\n\\t\\treturn A[i] = find(A[i]);\\n\\t}\\n\\t\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        init(nums.size() + 1);\\n\\t\\tnums.push_back(0);\\n\\t\\tvector<int> c;\\n\\t\\tc.resize(nums.size());\\n\\t\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\t\\tc[i] = i;\\n\\t\\t}\\n\\t\\tsort(c.begin(), c.end(), [&](int a, int b) -> bool {\\n\\t\\t\\treturn nums[a] > nums[b];\\n\\t\\t});\\n\\t\\tfor (int i = 1, j = 0; i < c.size(); i++) {\\n\\t\\t\\twhile (j < c.size() - 1 &&  nums[c[j]] > threshold / i) {\\n\\t\\t\\t\\tint curr = c[j];\\n\\t\\t\\t\\tint next = find(c[j] + 1);\\n\\t\\t\\t\\tsz[next] += sz[curr];\\n\\t\\t\\t\\tA[curr] = next;\\n\\t\\t\\t\\tif (sz[next] - 1  >= i) {\\n\\t\\t\\t\\t\\treturn i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2265848,
                "title": "python-mono-stack-solution",
                "content": "```\\nWe can have a mononic increasing stack.\\n\\nfor the element with index idx, we pop the element n if nums[stack[-1]]>nums[i].\\n\\nThe next element greater than n is nums[idx-1] on the right. \\nOtherwise, n should NOT be the popped out from the stack.\\n\\nThe next element greater than n is nums[stack[-1]] on the left.\\nAs a result, n is minimum between the index of stack[-1] and idx-1 (both inclusive).\\n\\nIf n>x//(idx-stack[-1]-1), we have a subarray as nums[stack[-1]:idx].\\n\\n```\\n\\nThe following is python implementaion\\n```\\ndef validSubarraySize(self, nums: List[int], x: int) -> int:\\n\\tnums.append(0)\\n\\tstack = []\\n\\tfor idx in range(len(nums)):\\n\\t\\twhile stack and nums[stack[-1]]>nums[idx]:\\n\\t\\t\\tn = nums[stack.pop()]\\n\\t\\t\\tk = idx\\n\\t\\t\\tif stack:\\n\\t\\t\\t\\tk = idx-stack[-1]-1\\n\\t\\t\\t\\t# n is the maximun if we have empty stack\\n\\t\\t\\tif n>x//k:\\n\\t\\t\\t\\treturn k\\n\\t\\tstack.append(idx)\\n\\n\\treturn -1\\n```",
                "solutionTags": [],
                "code": "```\\nWe can have a mononic increasing stack.\\n\\nfor the element with index idx, we pop the element n if nums[stack[-1]]>nums[i].\\n\\nThe next element greater than n is nums[idx-1] on the right. \\nOtherwise, n should NOT be the popped out from the stack.\\n\\nThe next element greater than n is nums[stack[-1]] on the left.\\nAs a result, n is minimum between the index of stack[-1] and idx-1 (both inclusive).\\n\\nIf n>x//(idx-stack[-1]-1), we have a subarray as nums[stack[-1]:idx].\\n\\n```\n```\\ndef validSubarraySize(self, nums: List[int], x: int) -> int:\\n\\tnums.append(0)\\n\\tstack = []\\n\\tfor idx in range(len(nums)):\\n\\t\\twhile stack and nums[stack[-1]]>nums[idx]:\\n\\t\\t\\tn = nums[stack.pop()]\\n\\t\\t\\tk = idx\\n\\t\\t\\tif stack:\\n\\t\\t\\t\\tk = idx-stack[-1]-1\\n\\t\\t\\t\\t# n is the maximun if we have empty stack\\n\\t\\t\\tif n>x//k:\\n\\t\\t\\t\\treturn k\\n\\t\\tstack.append(idx)\\n\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2264885,
                "title": "c-o-n-solutions-using-nextsmaller-element",
                "content": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        stack<int> st;\\n        vector<int> nextgreater(n,n), leftgreater(n,-1);\\n        for(int i=0;i<n;i++){\\n            while(!st.empty() && nums[st.top()]>nums[i]) nextgreater[st.top()] = i, st.pop();\\n            st.push(i);\\n        }\\n\\n        while(!st.empty()) st.pop();\\n        for(int i=n-1;i>=0;i--){\\n            while(!st.empty() && nums[st.top()]>nums[i]) leftgreater[st.top()] = i, st.pop();\\n            st.push(i);\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int lind = leftgreater[i];\\n            int rind = nextgreater[i];\\n            lind++;\\n            rind--;\\n            long long int len = rind-lind+1;\\n            long long int cur = nums[i];\\n            if(cur*len>threshold){\\n                //cout << cur << \" \" << len << endl;\\n                return len;\\n            } \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        stack<int> st;\\n        vector<int> nextgreater(n,n), leftgreater(n,-1);\\n        for(int i=0;i<n;i++){\\n            while(!st.empty() && nums[st.top()]>nums[i]) nextgreater[st.top()] = i, st.pop();\\n            st.push(i);\\n        }\\n\\n        while(!st.empty()) st.pop();\\n        for(int i=n-1;i>=0;i--){\\n            while(!st.empty() && nums[st.top()]>nums[i]) leftgreater[st.top()] = i, st.pop();\\n            st.push(i);\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int lind = leftgreater[i];\\n            int rind = nextgreater[i];\\n            lind++;\\n            rind--;\\n            long long int len = rind-lind+1;\\n            long long int cur = nums[i];\\n            if(cur*len>threshold){\\n                //cout << cur << \" \" << len << endl;\\n                return len;\\n            } \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2264717,
                "title": "segment-tree-based-divide-and-conquer-python-o-n-log-n",
                "content": "```\\nclass ST:\\n    def __init__(self, vals):\\n        self.n = len(vals)\\n        n = self.n\\n        self.min_tree = [0] * n + vals\\n        for i in range(n-1, 0,-1):\\n            self.min_tree[i] = min(self.min_tree[2*i:2*i+2])\\n    \\n    def get(self, l, r):\\n        l += self.n\\n        r += self.n\\n        res = math.inf\\n        while l < r:\\n            if l % 2 == 1:\\n                res = min(res, self.min_tree[l])\\n                l += 1\\n            if r % 2 == 1:\\n                r -= 1\\n                res = min(res, self.min_tree[r])\\n            l //= 2\\n            r //= 2\\n        return res\\n            \\n        \\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        sg = ST(nums)\\n        \\n        cs = defaultdict(list)\\n        \\n        n = len(nums)\\n        l = 0 \\n        r = n \\n        \\n        q = deque([(l,r)])\\n        \\n        for i, num in enumerate(nums):\\n            cs[num].append(i)\\n            \\n        v = set()\\n        \\n        while q:\\n            l, r = q.popleft()\\n            if l >= r or min(l,r) < 0 or (l,r) in v:\\n                continue\\n            v.add((l,r))\\n            cur_min =  sg.get(l, r)\\n            \\n            \\n            if cur_min * (r-l) > threshold:\\n                return r - l\\n            else:\\n                min_idx = cs[cur_min][bisect_left(cs[cur_min], l)]\\n                q.append((l, min_idx))\\n                q.append((min_idx+1, r))\\n                \\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer",
                    "Tree"
                ],
                "code": "```\\nclass ST:\\n    def __init__(self, vals):\\n        self.n = len(vals)\\n        n = self.n\\n        self.min_tree = [0] * n + vals\\n        for i in range(n-1, 0,-1):\\n            self.min_tree[i] = min(self.min_tree[2*i:2*i+2])\\n    \\n    def get(self, l, r):\\n        l += self.n\\n        r += self.n\\n        res = math.inf\\n        while l < r:\\n            if l % 2 == 1:\\n                res = min(res, self.min_tree[l])\\n                l += 1\\n            if r % 2 == 1:\\n                r -= 1\\n                res = min(res, self.min_tree[r])\\n            l //= 2\\n            r //= 2\\n        return res\\n            \\n        \\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        sg = ST(nums)\\n        \\n        cs = defaultdict(list)\\n        \\n        n = len(nums)\\n        l = 0 \\n        r = n \\n        \\n        q = deque([(l,r)])\\n        \\n        for i, num in enumerate(nums):\\n            cs[num].append(i)\\n            \\n        v = set()\\n        \\n        while q:\\n            l, r = q.popleft()\\n            if l >= r or min(l,r) < 0 or (l,r) in v:\\n                continue\\n            v.add((l,r))\\n            cur_min =  sg.get(l, r)\\n            \\n            \\n            if cur_min * (r-l) > threshold:\\n                return r - l\\n            else:\\n                min_idx = cs[cur_min][bisect_left(cs[cur_min], l)]\\n                q.append((l, min_idx))\\n                q.append((min_idx+1, r))\\n                \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264566,
                "title": "c-solution-with-monotonic-stack-o-n-one-pass-with-explanation-easy-to-understand",
                "content": "For nums[i] to be in a valid subarray, the length of the subarray needs to be at least ```req_len = threshold / nums[i] + 1;```\\n\\nFor each nums[i], we find the number of elements on its left that is bigger than itself and push into the stack [ref. LC 907], and find the number of elements on its right that is bigger than itself when popping it out of the stack. Putting together, we then compare the total length with the ```req_len``` and see if the criteria is met.\\n```\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        // stk is {index, left_len_with_self}\\n        stack<vector<int>> stk{};\\n        for (int i = 0; i < nums.size(); ++i) {\\n            while (stk.size() && nums[stk.top()[0]] > nums[i]) {\\n                vector<int> n = stk.top();\\n                int rlen = i - 1 - (n[0] + 1) + 1;\\n\\t\\t\\t\\t// why these rlen elems can also be included?\\n                // because by definition if any one of them say nums[j] are smaller\\n                // than nums[top()[0]] then n would have been popped\\n                // when nums[j] is being pushed into stack\\n                if (rlen + n[1] >= threshold / nums[n[0]] + 1)\\n                    return rlen + n[1];\\n                stk.pop();\\n            }\\n            int llen = stk.size() ? i - stk.top()[0] : 1;\\n            stk.push({i, llen});\\n        }\\n        // continue to pop as all elements were judged when they are popped\\n        while (stk.size()) {\\n            vector<int> n = stk.top();\\n            int rlen = nums.size() - 1 - (n[0] + 1) + 1;\\n            if (rlen + n[1] >= threshold / nums[n[0]] + 1)\\n                return rlen + n[1];\\n            stk.pop();\\n        }\\n        return -1;\\n    }\\n\\t",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```req_len = threshold / nums[i] + 1;```\n```req_len```",
                "codeTag": "Unknown"
            },
            {
                "id": 2263672,
                "title": "c-monotonic-stack-next-smaller-element-easy-understanding",
                "content": "```\\n int validSubarraySize(vector<int>& nums, int t) {\\n        \\n        // the intuition is we have to use nxt smaller element every time\\n        \\n        // frm left and right using stack \\n        \\n        int n=nums.size();\\n        \\n        stack<int> stk;\\n        \\n        vector<int> left(n) , right(n );\\n       \\n        \\n      \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            while(!stk.empty() && nums[i]<=nums[stk.top()])\\n            {\\n                stk.pop();\\n            }\\n            \\n            if(stk.empty())\\n            {\\n                left[i]=0;\\n            }\\n            else\\n            {\\n                left[i]=stk.top()+1;\\n            }\\n            \\n            stk.push(i);\\n        }\\n        \\n      while(!stk.empty())\\n      {\\n          stk.pop();\\n      }\\n        \\n    \\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!stk.empty() && nums[i]<=nums[stk.top()])\\n            {\\n                stk.pop();\\n            }\\n            \\n            if(stk.empty())\\n            {\\n                right[i]=n-1;\\n            }\\n            else\\n            {\\n                right[i]=stk.top()-1;\\n            }\\n            \\n            stk.push(i);\\n        }\\n        \\n        int max_len=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            int len = right[i]-left[i]+1;\\n            double val = (1.0 * t)/(1.0 * len);\\n            if( (1.0 * nums[i])>(val))\\n            {\\n                max_len=max(max_len , len);\\n            }\\n        }\\n        \\n        return max_len ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n int validSubarraySize(vector<int>& nums, int t) {\\n        \\n        // the intuition is we have to use nxt smaller element every time\\n        \\n        // frm left and right using stack \\n        \\n        int n=nums.size();\\n        \\n        stack<int> stk;\\n        \\n        vector<int> left(n) , right(n );\\n       \\n        \\n      \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            while(!stk.empty() && nums[i]<=nums[stk.top()])\\n            {\\n                stk.pop();\\n            }\\n            \\n            if(stk.empty())\\n            {\\n                left[i]=0;\\n            }\\n            else\\n            {\\n                left[i]=stk.top()+1;\\n            }\\n            \\n            stk.push(i);\\n        }\\n        \\n      while(!stk.empty())\\n      {\\n          stk.pop();\\n      }\\n        \\n    \\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!stk.empty() && nums[i]<=nums[stk.top()])\\n            {\\n                stk.pop();\\n            }\\n            \\n            if(stk.empty())\\n            {\\n                right[i]=n-1;\\n            }\\n            else\\n            {\\n                right[i]=stk.top()-1;\\n            }\\n            \\n            stk.push(i);\\n        }\\n        \\n        int max_len=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            int len = right[i]-left[i]+1;\\n            double val = (1.0 * t)/(1.0 * len);\\n            if( (1.0 * nums[i])>(val))\\n            {\\n                max_len=max(max_len , len);\\n            }\\n        }\\n        \\n        return max_len ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2263577,
                "title": "can-somebody-tell-me-what-s-wrong-with-my-code",
                "content": "It passed 62 out of 64 test cases\\nfailed at 63rd test case\\n\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n```\\n        \\n        int n = nums.size();\\n        \\n        int st = -1, en = n;\\n        \\n        for(int i=0;i<nums.size() && i<=en ;i++) {\\n            \\n            if(st==-1) {\\n                en = min(n,threshold/nums[i] + 1 + i - 1);\\n                \\n                if(en==n) {\\n                    st = -1;\\n                }\\n                else {\\n                    st = i;\\n                }\\n                \\n            }\\n            \\n            else {\\n                \\n                int tempLen = threshold/nums[i] + 1;\\n                \\n                int left = i - st + 1;\\n                int right = tempLen - left;\\n                \\n                if(right<0)\\n                    continue;\\n                \\n                en = max(en,i+right);\\n                en = min(en,n);\\n                \\n                if(en==n) {\\n                    st = -1;\\n                }\\n                \\n            }\\n            \\n            \\n        }\\n        \\n        if(en==n)\\n            return -1;\\n        \\n        // cout<<st<<\" \"<<en;\\n        \\n        return en-st+1;\\n        \\n    }\\n};``",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263476,
                "title": "python-mono-stack-o-n",
                "content": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        n = len(nums)\\n        pre=[-1]*n\\n        nxt = [n]*n\\n        #increasing stack\\n        st=[]\\n        for i in range(n):\\n            while st and nums[st[-1]]>nums[i]:\\n                nxt[st.pop()] = i\\n            \\n            if st:\\n                pre[i] = st[-1] if nums[i]!=nums[st[-1]] else pre[st[-1]]\\n            st.append(i)\\n        \\n        for i in range(n):\\n            ln = nxt[i]-pre[i]-1\\n            if nums[i]>threshold/ln:\\n                return ln\\n        return -1\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        n = len(nums)\\n        pre=[-1]*n\\n        nxt = [n]*n\\n        #increasing stack\\n        st=[]\\n        for i in range(n):\\n            while st and nums[st[-1]]>nums[i]:\\n                nxt[st.pop()] = i\\n            \\n            if st:\\n                pre[i] = st[-1] if nums[i]!=nums[st[-1]] else pre[st[-1]]\\n            st.append(i)\\n        \\n        for i in range(n):\\n            ln = nxt[i]-pre[i]-1\\n            if nums[i]>threshold/ln:\\n                return ln\\n        return -1\\n",
                "codeTag": "Java"
            },
            {
                "id": 2263321,
                "title": "c-o-n-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        vector<pair<int, int>> stack;\\n        int i, j;\\n        \\n        vector<int> right(n);\\n        for(i = 0; i < n; i++){\\n            while(!stack.empty() && stack.back().first > nums[i]){\\n                right[stack.back().second] = i - stack.back().second;\\n                stack.pop_back();\\n            }\\n            stack.push_back(make_pair(nums[i], i));\\n        }\\n        \\n        while(!stack.empty()){\\n            right[stack.back().second] = n - stack.back().second;\\n            stack.pop_back();\\n        }\\n        \\n        vector<int> left(n);\\n        for(i = n - 1; i >= 0; i--){\\n            while(!stack.empty() && stack.back().first > nums[i]){\\n                left[stack.back().second] = stack.back().second - i;\\n                stack.pop_back();\\n            }\\n            stack.push_back(make_pair(nums[i], i));\\n        }\\n        \\n        while(!stack.empty()){\\n            left[stack.back().second] = stack.back().second + 1;\\n            stack.pop_back();\\n        }\\n        \\n        for(i = 0; i < n; i++){\\n            j = left[i] + right[i] - 1;\\n            if((threshold / j) < nums[i]){\\n                return j;\\n            }    \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        vector<pair<int, int>> stack;\\n        int i, j;\\n        \\n        vector<int> right(n);\\n        for(i = 0; i < n; i++){\\n            while(!stack.empty() && stack.back().first > nums[i]){\\n                right[stack.back().second] = i - stack.back().second;\\n                stack.pop_back();\\n            }\\n            stack.push_back(make_pair(nums[i], i));\\n        }\\n        \\n        while(!stack.empty()){\\n            right[stack.back().second] = n - stack.back().second;\\n            stack.pop_back();\\n        }\\n        \\n        vector<int> left(n);\\n        for(i = n - 1; i >= 0; i--){\\n            while(!stack.empty() && stack.back().first > nums[i]){\\n                left[stack.back().second] = stack.back().second - i;\\n                stack.pop_back();\\n            }\\n            stack.push_back(make_pair(nums[i], i));\\n        }\\n        \\n        while(!stack.empty()){\\n            left[stack.back().second] = stack.back().second + 1;\\n            stack.pop_back();\\n        }\\n        \\n        for(i = 0; i < n; i++){\\n            j = left[i] + right[i] - 1;\\n            if((threshold / j) < nums[i]){\\n                return j;\\n            }    \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263209,
                "title": "stack-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> temp1,temp2;\\n    int validSubarraySize(vector<int>& nums, int t) {\\n        util(nums);\\n        util1(nums);\\n        \\n        vector<int> temp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(temp1[i].first==-1 && temp2[i].first==-1)\\n                temp.push_back(n);\\n            else if(temp1[i].first==-1)\\n                temp.push_back(i+1 +temp2[i].second-i-1);\\n            else if(temp2[i].first==-1)\\n                temp.push_back(n-i+i-temp1[i].second-1);\\n            else\\n                temp.push_back(temp2[i].second-temp1[i].second-1);\\n            }\\n        \\n        for(int i=0;i<nums.size();i++){\\n           double d=t/temp[i];\\n            double p=(double)nums[i];\\n            if(p>d)\\n                return temp[i];\\n        }\\n        return -1;\\n    }\\n    \\n    void util(vector<int> & nums){\\n        stack<pair<int,int>> st;\\n        for(int i=0;i<nums.size();i++){\\n            if(st.empty()){\\n                st.push({nums[i],i});\\n                temp1.push_back({-1,-1});\\n                continue;\\n            }\\n            while(st.empty()==false && st.top().first>=nums[i])\\n                st.pop();\\n            if(st.empty()){\\n                 temp1.push_back({-1,-1});\\n            }\\n            else\\n                temp1.push_back(st.top());\\n            st.push({nums[i],i});\\n        }\\n    }\\n    \\n     void util1(vector<int> & nums){\\n        stack<pair<int,int>> st;\\n        for(int i=nums.size()-1;i>-1;i--){\\n            if(st.empty()){\\n                st.push({nums[i],i});\\n                temp2.push_back({-1,-1});\\n                continue;\\n            }\\n            while(st.empty()==false && st.top().first>=nums[i])\\n                st.pop();\\n            if(st.empty())\\n                 temp2.push_back({-1,-1});\\n            else\\n                temp2.push_back(st.top());\\n            st.push({nums[i],i});\\n        }\\n         reverse(temp2.begin(),temp2.end());\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> temp1,temp2;\\n    int validSubarraySize(vector<int>& nums, int t) {\\n        util(nums);\\n        util1(nums);\\n        \\n        vector<int> temp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(temp1[i].first==-1 && temp2[i].first==-1)\\n                temp.push_back(n);\\n            else if(temp1[i].first==-1)\\n                temp.push_back(i+1 +temp2[i].second-i-1);\\n            else if(temp2[i].first==-1)\\n                temp.push_back(n-i+i-temp1[i].second-1);\\n            else\\n                temp.push_back(temp2[i].second-temp1[i].second-1);\\n            }\\n        \\n        for(int i=0;i<nums.size();i++){\\n           double d=t/temp[i];\\n            double p=(double)nums[i];\\n            if(p>d)\\n                return temp[i];\\n        }\\n        return -1;\\n    }\\n    \\n    void util(vector<int> & nums){\\n        stack<pair<int,int>> st;\\n        for(int i=0;i<nums.size();i++){\\n            if(st.empty()){\\n                st.push({nums[i],i});\\n                temp1.push_back({-1,-1});\\n                continue;\\n            }\\n            while(st.empty()==false && st.top().first>=nums[i])\\n                st.pop();\\n            if(st.empty()){\\n                 temp1.push_back({-1,-1});\\n            }\\n            else\\n                temp1.push_back(st.top());\\n            st.push({nums[i],i});\\n        }\\n    }\\n    \\n     void util1(vector<int> & nums){\\n        stack<pair<int,int>> st;\\n        for(int i=nums.size()-1;i>-1;i--){\\n            if(st.empty()){\\n                st.push({nums[i],i});\\n                temp2.push_back({-1,-1});\\n                continue;\\n            }\\n            while(st.empty()==false && st.top().first>=nums[i])\\n                st.pop();\\n            if(st.empty())\\n                 temp2.push_back({-1,-1});\\n            else\\n                temp2.push_back(st.top());\\n            st.push({nums[i],i});\\n        }\\n         reverse(temp2.begin(),temp2.end());\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263200,
                "title": "python-binary-search-monotonic-stack-o-nlogn",
                "content": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        def lowerbound(num):\\n            low, high = 1, len(nums)\\n            if num <= threshold/high:\\n                return high + 1\\n            while low < high:\\n                m = (low + high)//2\\n                if num > threshold/m:\\n                    high = m\\n                else:\\n                    low = m + 1\\n            return low\\n        n = len(nums)\\n        levels = [n+1] + list(map(lowerbound, nums)) + [n+1]\\n        stack = []\\n        for i in range(len(levels)):\\n            while stack and levels[stack[-1]] < levels[i]:\\n                top = levels[stack.pop()]\\n                if i-stack[-1]-1>=top:\\n                    return top\\n            stack.append(i)\\n        return -1",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        def lowerbound(num):\\n            low, high = 1, len(nums)\\n            if num <= threshold/high:\\n                return high + 1\\n            while low < high:\\n                m = (low + high)//2\\n                if num > threshold/m:\\n                    high = m\\n                else:\\n                    low = m + 1\\n            return low\\n        n = len(nums)\\n        levels = [n+1] + list(map(lowerbound, nums)) + [n+1]\\n        stack = []\\n        for i in range(len(levels)):\\n            while stack and levels[stack[-1]] < levels[i]:\\n                top = levels[stack.pop()]\\n                if i-stack[-1]-1>=top:\\n                    return top\\n            stack.append(i)\\n        return -1",
                "codeTag": "Java"
            },
            {
                "id": 2263035,
                "title": "c-solution-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int t) {\\n        vector<int> counts;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int count=1;\\n            int j=i-1;\\n            int k=calculate(nums[i],t);\\n            while(j>=0&&calculate(nums[j],t)<=k)\\n            {\\n                count += counts[j];\\n                j -= counts[j];\\n            }\\n            counts.push_back(count);\\n        }\\n        \\n        vector<int> rcounts;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            int rcount=1;\\n            int j=i+1;\\n            int k=calculate(nums[i],t);\\n            while(j<=nums.size()-1 && calculate(nums[j],t)<=k)\\n            {\\n                rcount += rcounts[nums.size()-1-j];\\n                j += rcounts[nums.size()-1-j];\\n            }\\n            if(rcount+counts[i]>k)\\n                return k;\\n            else\\n                rcounts.push_back(rcount);\\n        }\\n        return -1;\\n        \\n    }\\n    int calculate(int num, int t)\\n    {\\n        int k = t/num + 1;\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int t) {\\n        vector<int> counts;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int count=1;\\n            int j=i-1;\\n            int k=calculate(nums[i],t);\\n            while(j>=0&&calculate(nums[j],t)<=k)\\n            {\\n                count += counts[j];\\n                j -= counts[j];\\n            }\\n            counts.push_back(count);\\n        }\\n        \\n        vector<int> rcounts;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            int rcount=1;\\n            int j=i+1;\\n            int k=calculate(nums[i],t);\\n            while(j<=nums.size()-1 && calculate(nums[j],t)<=k)\\n            {\\n                rcount += rcounts[nums.size()-1-j];\\n                j += rcounts[nums.size()-1-j];\\n            }\\n            if(rcount+counts[i]>k)\\n                return k;\\n            else\\n                rcounts.push_back(rcount);\\n        }\\n        return -1;\\n        \\n    }\\n    int calculate(int num, int t)\\n    {\\n        int k = t/num + 1;\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263034,
                "title": "go-golang-monotonic-stack",
                "content": "```\\nfunc validSubarraySizeMonoStack(nums []int,threshold int) int{\\n    st:=[]int{}\\n    nums=append(nums,0)\\n    for i :=range nums{\\n        for len(st)>0 && nums[i] < nums[st[len(st)-1]] {\\n            val := nums[st[len(st)-1]]\\n            st = st[:len(st)-1]\\n            j:=-1\\n            if len(st)>0{\\n                j=st[len(st)-1]\\n            }\\n            if  val > threshold / (i - j - 1){\\n                return i - j - 1\\n            }\\n        }\\n        st=append(st,i)\\n    }\\n    return -1\\n}",
                "solutionTags": [
                    "Go",
                    "Stack"
                ],
                "code": "```\\nfunc validSubarraySizeMonoStack(nums []int,threshold int) int{\\n    st:=[]int{}\\n    nums=append(nums,0)\\n    for i :=range nums{\\n        for len(st)>0 && nums[i] < nums[st[len(st)-1]] {\\n            val := nums[st[len(st)-1]]\\n            st = st[:len(st)-1]\\n            j:=-1\\n            if len(st)>0{\\n                j=st[len(st)-1]\\n            }\\n            if  val > threshold / (i - j - 1){\\n                return i - j - 1\\n            }\\n        }\\n        st=append(st,i)\\n    }\\n    return -1\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2262905,
                "title": "using-next-greater-element-stack-extended-solution-java",
                "content": "***Little Maths: \\nelem > threshold/k\\nk == length of subarray\\nk > threshold/elem*\\n\\n```\\nclass Solution {\\n    int ceil(int n, int d){\\n        return (n/d) + 1;\\n    }\\n    public int validSubarraySize(int[] nums, int threshold) {\\n        \\n        int n = nums.length;\\n        int[] arr = new int[n];\\n        \\n        for(int i = 0; i < n; i++){\\n            int v = ceil(threshold, nums[i]);\\n            // System.out.println(v);\\n            arr[i] = v;\\n        }\\n        \\n        int[] left_max = new int[n];\\n        int[] right_max = new int[n];\\n        \\n        Arrays.fill(right_max, n);\\n        Arrays.fill(left_max, -1);\\n        \\n        Stack<int[]> st = new Stack<>();\\n        // checking for right\\n        for(int i = 0; i < n; i++){\\n            while(st.size() > 0 && st.peek()[1] < arr[i]){\\n                  int[] a = st.pop();\\n                  right_max[a[0]] = i;\\n             } \\n            st.push(new int[]{i, arr[i]});\\n        }\\n              \\n        st.clear();\\n        for(int i = n - 1; i >= 0; i--){\\n            while(st.size() > 0 && st.peek()[1] < arr[i]){\\n                  int[] a = st.pop();\\n                  left_max[a[0]] = i;\\n             } \\n            st.push(new int[]{i, arr[i]});\\n        }\\n        \\n        // (right_max[i] - 1) - (left_max[i] - 1) + 1 === length of subarray\\n        // right_max[i] = index of element just greater than ith ele\\n        // left_max[i] = index of element just greater than i-th ele\\n        \\n        for(int i = 0; i < n; i++){\\n            int v = arr[i];\\n            if(right_max[i] - left_max[i] - 1 >= v) return v;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ceil(int n, int d){\\n        return (n/d) + 1;\\n    }\\n    public int validSubarraySize(int[] nums, int threshold) {\\n        \\n        int n = nums.length;\\n        int[] arr = new int[n];\\n        \\n        for(int i = 0; i < n; i++){\\n            int v = ceil(threshold, nums[i]);\\n            // System.out.println(v);\\n            arr[i] = v;\\n        }\\n        \\n        int[] left_max = new int[n];\\n        int[] right_max = new int[n];\\n        \\n        Arrays.fill(right_max, n);\\n        Arrays.fill(left_max, -1);\\n        \\n        Stack<int[]> st = new Stack<>();\\n        // checking for right\\n        for(int i = 0; i < n; i++){\\n            while(st.size() > 0 && st.peek()[1] < arr[i]){\\n                  int[] a = st.pop();\\n                  right_max[a[0]] = i;\\n             } \\n            st.push(new int[]{i, arr[i]});\\n        }\\n              \\n        st.clear();\\n        for(int i = n - 1; i >= 0; i--){\\n            while(st.size() > 0 && st.peek()[1] < arr[i]){\\n                  int[] a = st.pop();\\n                  left_max[a[0]] = i;\\n             } \\n            st.push(new int[]{i, arr[i]});\\n        }\\n        \\n        // (right_max[i] - 1) - (left_max[i] - 1) + 1 === length of subarray\\n        // right_max[i] = index of element just greater than ith ele\\n        // left_max[i] = index of element just greater than i-th ele\\n        \\n        for(int i = 0; i < n; i++){\\n            int v = arr[i];\\n            if(right_max[i] - left_max[i] - 1 >= v) return v;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262478,
                "title": "python-go-monostack-o-n",
                "content": "*Python* solution\\n\\n```python\\ndef validSubarraySize(self, nums, threshold):\\n    A, nums = [0], [0] + nums + [0]\\n    for r, num in enumerate(nums):\\n        while nums[A[-1]] > num:\\n            if (n := r - A[-2] - 1) * nums[A.pop()] > threshold: return n\\n        A.append(r)\\n    return -1\\n```\\n\\n*Go* solution in 124ms\\n\\n```go\\ntype stack []int\\n\\nfunc (s stack) top() int    { return s[len(s)-1] }\\nfunc (s stack) penul() int  { return s[len(s)-2] }\\nfunc (s *stack) push(x int) { *s = append(*s, x) }\\nfunc (s *stack) pop() int {\\n\\tvar (\\n\\t\\ti = len(*s) - 1\\n\\t\\tx = (*s)[i]\\n\\t)\\n\\t*s = (*s)[:i]\\n\\treturn x\\n}\\n\\nfunc validSubarraySize(nums []int, threshold int) int {\\n\\tA := stack{0}\\n\\tnums = append([]int{0}, append(nums, 0)...)\\n\\tfor r, num := range nums {\\n\\t\\tfor nums[A.top()] > num {\\n\\t\\t\\tif n := r - A.penul() - 1; n*nums[A.pop()] > threshold {\\n\\t\\t\\t\\treturn n\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tA.push(r)\\n\\t}\\n\\treturn -1\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef validSubarraySize(self, nums, threshold):\\n    A, nums = [0], [0] + nums + [0]\\n    for r, num in enumerate(nums):\\n        while nums[A[-1]] > num:\\n            if (n := r - A[-2] - 1) * nums[A.pop()] > threshold: return n\\n        A.append(r)\\n    return -1\\n```\n```go\\ntype stack []int\\n\\nfunc (s stack) top() int    { return s[len(s)-1] }\\nfunc (s stack) penul() int  { return s[len(s)-2] }\\nfunc (s *stack) push(x int) { *s = append(*s, x) }\\nfunc (s *stack) pop() int {\\n\\tvar (\\n\\t\\ti = len(*s) - 1\\n\\t\\tx = (*s)[i]\\n\\t)\\n\\t*s = (*s)[:i]\\n\\treturn x\\n}\\n\\nfunc validSubarraySize(nums []int, threshold int) int {\\n\\tA := stack{0}\\n\\tnums = append([]int{0}, append(nums, 0)...)\\n\\tfor r, num := range nums {\\n\\t\\tfor nums[A.top()] > num {\\n\\t\\t\\tif n := r - A.penul() - 1; n*nums[A.pop()] > threshold {\\n\\t\\t\\t\\treturn n\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tA.push(r)\\n\\t}\\n\\treturn -1\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2262270,
                "title": "easy-efficient-short-solution",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n    typedef long double ld;\\n    typedef pair<ll, ll> pi;\\n#define vi(x) vector<x>\\n#define pb push_back\\n    const ll mod = 1e9 + 7;\\n    const char nl = \\'\\\\n\\';\\npublic:\\n    int validSubarraySize(vector<int>& v, int t) {\\n        ll sz = v.size();\\n        vi(ll)pre(sz, -1), nxt(sz, sz), st;\\n        for (ll i = 0;i < sz;++i) {\\n            while (!st.empty() && v[st.back()] > v[i]) {\\n                nxt[st.back()] = i;\\n                st.pop_back();\\n            }\\n            st.pb(i);\\n        }\\n        st.clear();\\n        for (ll i = sz - 1;i > -1;--i) {\\n            while (!st.empty() && v[st.back()] > v[i]) {\\n                pre[st.back()] = i;\\n                st.pop_back();\\n            }\\n            st.pb(i);\\n        }\\n        st.clear();\\n        ll res = -1;\\n        for (ll i = 0;i < sz;++i) {\\n            ll range = nxt[i] - pre[i] - 1;\\n            if (range > 0 && v[i] > (t / range)) {\\n                res = range;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n    typedef long double ld;\\n    typedef pair<ll, ll> pi;\\n#define vi(x) vector<x>\\n#define pb push_back\\n    const ll mod = 1e9 + 7;\\n    const char nl = \\'\\\\n\\';\\npublic:\\n    int validSubarraySize(vector<int>& v, int t) {\\n        ll sz = v.size();\\n        vi(ll)pre(sz, -1), nxt(sz, sz), st;\\n        for (ll i = 0;i < sz;++i) {\\n            while (!st.empty() && v[st.back()] > v[i]) {\\n                nxt[st.back()] = i;\\n                st.pop_back();\\n            }\\n            st.pb(i);\\n        }\\n        st.clear();\\n        for (ll i = sz - 1;i > -1;--i) {\\n            while (!st.empty() && v[st.back()] > v[i]) {\\n                pre[st.back()] = i;\\n                st.pop_back();\\n            }\\n            st.pb(i);\\n        }\\n        st.clear();\\n        ll res = -1;\\n        for (ll i = 0;i < sz;++i) {\\n            ll range = nxt[i] - pre[i] - 1;\\n            if (range > 0 && v[i] > (t / range)) {\\n                res = range;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262226,
                "title": "c-clean-one-pass-monotonic-stack",
                "content": "* Find the longest subarray such that the value of each element is greater than a certain element value.\\n* We use monotonic stack to maintain all element are increasing order.\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        stack<int> st;\\n        for (int i = 0; i <= n; ++i) {\\n            while (!st.empty() and (i == n or nums[st.top()] > nums[i])) {\\n                int j = st.top(); st.pop(); // minimum value of current window\\n                int left = st.empty() ? -1 : st.top(); // window left boudary, and i is right boundary\\n                int len = i-left-1;\\n                double t = threshold*1.0/len*1.0;\\n                if (nums[j] > t) return len;\\n            }\\n            st.push(i);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        stack<int> st;\\n        for (int i = 0; i <= n; ++i) {\\n            while (!st.empty() and (i == n or nums[st.top()] > nums[i])) {\\n                int j = st.top(); st.pop(); // minimum value of current window\\n                int left = st.empty() ? -1 : st.top(); // window left boudary, and i is right boundary\\n                int len = i-left-1;\\n                double t = threshold*1.0/len*1.0;\\n                if (nums[j] > t) return len;\\n            }\\n            st.push(i);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261083,
                "title": "easy-to-understand-analysis-and-a-stack-based-solution-and-union-find-solution",
                "content": "Let S be a subarray of nums with length k\\n    \\n    every y in S is such that  y > threshold / k <==> min S > threshold / k\\n    \\n    As threshold is fixed, the larger k is, the easier the above condition is fulfilled\\n    \\n2. Procedure:\\n    \\n    - 1. for each element y in nums, we try to find the longest subarray such that \\n         it contains y as the smallest element. [We could use Monotonic Stack or Disjoint Set for this step]\\n    - 2. check if y > threshold / k. if so, return k\\n    - 3. return -1\\n\\n\\nA brute force solution with a friend video explanation:\\n```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], t: int) -> int:\\n        # 1. prep\\n        n = len(nums)\\n        left = [i for i in range(n)]\\n        right = [i for i in range(n)]\\n        \\n        # 2. left bdrs\\n        stack = []\\n        for i in range(n):\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                left[i] = left[stack.pop()]\\n            stack.append(i)\\n            \\n        # 3. right bdrs\\n        stack = []\\n        for i in range(n-1, -1, -1):\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                right[i] = right[stack.pop()]\\n            stack.append(i)\\n        \\n        # 4. check\\n        for i in range(n):\\n            size = right[i] - left[i] + 1\\n            if nums[i] > t / size:\\n                return size\\n        return -1       \\n```\\n\\n[stack-based solution Video Explanation](https://youtu.be/HNte-4TzJEI;);\\nand\\n[union-find based solution Video Explanation](https://youtu.be/srCQXkpAVQ0;)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], t: int) -> int:\\n        # 1. prep\\n        n = len(nums)\\n        left = [i for i in range(n)]\\n        right = [i for i in range(n)]\\n        \\n        # 2. left bdrs\\n        stack = []\\n        for i in range(n):\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                left[i] = left[stack.pop()]\\n            stack.append(i)\\n            \\n        # 3. right bdrs\\n        stack = []\\n        for i in range(n-1, -1, -1):\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                right[i] = right[stack.pop()]\\n            stack.append(i)\\n        \\n        # 4. check\\n        for i in range(n):\\n            size = right[i] - left[i] + 1\\n            if nums[i] > t / size:\\n                return size\\n        return -1       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260516,
                "title": "simple-step-by-step-explanation-c-just-read-it-once-completely-and-try-to-do-by-yourself-also",
                "content": "Just have patience and keep on reading this, definetely you will get the solution. Let\\'s say we have threshold 3790 and the array \\n[818,232,595,418,608,229,37,330,876,774,931,939,479,884,354,328]\\n\\nNow one way is to check for all k starting from 1,2,.......n\\nIn this way what we have to do is - \\nif k==1, threshold/k = 3790/1 = 3790 so the elements should be greater than this.\\nwe will check for the elements greater than 3790 if there is one present in the array then k==1 \\nis the answer and we will simply return 1 else we will check for next value of K.\\nNow this solution will take about n^2 time complexity which will give tle.\\n\\nSo, let\\'s think in opposite way, let say for each elements we find the minimum subarray length we want. Let me clear this with an example.\\nLet\\'s take the first element of the array mentioned above which is 818. now try to find the minimum length of array such that we can include 818. so let\\'s find threshold/818 instead of threshold/k. Now threshold/818 = 3790/818 = 4.633 . \\nNow what this 4.633 signifies that if I want to consider 818 in any subarray , the length of that subarray must be greater than 4.633, so we will take 5 to be the minimum length for this element. Again we check for the next element which is 232 , so 3790/232 = 16.33 , that means we will need minimum 17 elements in the subarray to consider 232 in that subarray.\\nIn the same way find this number for the whole array. We can do this in O(N) complexity.\\n\\nint n = nums.size();\\n        int dp[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            int x = threshold/nums[i];\\n            x++; // because the elements should be less than threshold/k not equality is not there.\\n            dp[i] = x;\\n        }\\n\\t\\n     \\n\\t\\n\\tAfter doing this operation, we have the dp array like - \\n\\t[5,17,7,10,7,17,103,12,5,5,5,5,8,5,11,12] for the elements\\n\\tof array respectively.\\n\\t\\nNow observe one thing let say ith element has dp[i] = 5 and jth has dp[j] = 6, so can we consider \\'j\\' element  in the subarray of \\'i\\' ? see what the dp array tells us is the minimum number of elements needed to consider a particular element in a subarray, so if we take an array of length 5 with jth element in it, that will violate the condition of elements>threshold/k value. as for jth element we need minimum 6 elements in the subarray to fulfil this condition.\\nNow if ith element needs 5 elements while the jth needs 6 we can\\'t consider jth element in the ith subarray.because may be we have chosen the subarray of length 5 for ith element but if we consider jth element in this subarray , it will break the condition of the elements being greater than threshold/k. If you don\\'t understand this please read this paragraph again.\\n\\nNow our problem breaks into yet another problem. For a particular element we can take all the elements on their left and right which has value in dp array less than value of that array.\\nfor example for the third element of the array , array[2] = 595 , also dp[2] = 7 so we need minimum of  7 elements , now if the elements on the left of this in the dp array which are less than/equal to 7 plus the elements on the right of this dp array which are less than/equal to\\n7 plus this element is greater than equal to 7 we can say that 7 can be the required k.\\nHere for i = 2 , i.e. array[i] = 595 , dp[i] = 7 ,  elements less than 7 in dp array on left is 0 , elements less than 7 in dp array on right is again 0 , so this can\\'t be the answer. so, our next\\ntask is to find the elements greater than a particular element on the left as well as on the right in the dp array so that the elements between the next greater element and this element\\ncan be considered in the subarray. we can find this simply using stack. \\nwe will take a left array to store the entries greater than dp[i] for all i, if we didn\\'t find any such element we will store -1.\\n\\n       vector<int> left(n);\\n        left[0] = -1;\\n        stack<pair<int,int>> st;\\n        st.push({dp[0] , 0});\\n        for(int i=1;i<n;i++)\\n        {\\n            while(!st.empty() && st.top().first<=dp[i])\\n                st.pop();\\n            \\n            if(st.empty())\\n                left[i] = -1;\\n            else\\n                left[i] = st.top().second;\\n            \\n            st.push({dp[i],i});\\n        }\\n\\t\\t\\n\\t   left array after this operation will be - \\n\\t\\t[-1 ,  -1 , 1 , 1 , 3 , -1 , -1 , 6 , 7 ,7 ,7 ,7 , 7 , 12 , 7, 6]\\n\\t\\t\\nsimilarly we will do for the right array. After this we have dp , left, right array. now dp array\\ntells us the min no. of elements in the subarray to  consider that particular element. Now we will check  whether a particular element can be considered in any subarray or not. For this we will iterate through dp array and will check for each element i, no. of elements less than/equal to dp[i] on the left  because we will consider those elements in the subarray of array[i] . how can we get that? from left array. If left[i] == -1 , this implies all the elements before i can be considered , and if it\\'s some finite value then (i-left[i]-1) elements can be taken, \\nso int l = left[i]==-1 ? 1 : (i-left[i]-1);\\n*Note - we take i-left[i]-1 because left[i] stores the element \\nof next greater element but only want lesser elements so, we have to do -1*\\n Similarly we will get elements on right less than dp[i] as - \\n int r = right[i]==-1?n-i-1 : (right[i]-i-1)\\n \\n one example to better understand is - the fifth element  of the above given array which is \\n array[4] = 608, dp[4] = 7 , so we need a min of 7 elements, let\\'s check can we get that, \\n see in the dp array the element just greater than 7 on left is at index 3 which is dp[3] = 10.\\n so number of favourable elements on left is *between* index 3 and 4 i.e. 4-3-1 = 0. so, l = 0;\\n Also,the element just greater than 7 on right is at index 5 which is dp[5] = 17.\\n so number of favourable elements on right is *between* index 4 and 5 i.e. 5-4-1 = 0. so, r = 0;\\n so total favourable = l+r+1 // (+1 for the fourth index itself) fav = 1 but needed is 7. so this can\\'t be the answer. \\n \\n Now the total elements which we can consider in this  subarray is l+r+1 (+1 is for that element itself), and minimum length needed is dp[i] , so if l+r+1>=dp[i] \\n this can be the result and we will return dp[i] ,  else we will iterate to the next element of the array.\\nIf we didn\\'t find any such subarray we will return -1.Try this method on the sample examples yourself.\\n \\n This is My C++ Implementation-\\n \\n ```\\n class Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        \\n        int n = nums.size();\\n        int dp[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            int x = threshold/nums[i];\\n            x++;\\n            dp[i] = x;\\n        }\\n        \\n        vector<int> left(n);\\n        left[0] = -1;\\n        stack<pair<int,int>> st;\\n        st.push({dp[0] , 0});\\n        for(int i=1;i<n;i++)\\n        {\\n            while(!st.empty() && st.top().first<=dp[i])\\n                st.pop();\\n            \\n            if(st.empty())\\n                left[i] = -1;\\n            else\\n                left[i] = st.top().second;\\n            \\n            st.push({dp[i],i});\\n        }\\n        \\n        vector<int> right(n);\\n        right[n-1] = -1;\\n        while(!st.empty())\\n            st.pop();\\n        \\n        st.push({dp[n-1],n-1});\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            while(!st.empty() && st.top().first<=dp[i])\\n                st.pop();\\n            \\n            if(st.empty())\\n                right[i] = -1;\\n            else\\n                right[i] = st.top().second;\\n            st.push({dp[i],i});\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int req = dp[i];\\n            int l = left[i]==-1 ? i : (i-left[i]-1);\\n            int r = right[i]==-1 ? n-i-1 : (right[i]-i-1);\\n            if(l+r+1 >= req)\\n                return dp[i];\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```\\n\\nComment down for any query.\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        \\n        int n = nums.size();\\n        int dp[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            int x = threshold/nums[i];\\n            x++;\\n            dp[i] = x;\\n        }\\n        \\n        vector<int> left(n);\\n        left[0] = -1;\\n        stack<pair<int,int>> st;\\n        st.push({dp[0] , 0});\\n        for(int i=1;i<n;i++)\\n        {\\n            while(!st.empty() && st.top().first<=dp[i])\\n                st.pop();\\n            \\n            if(st.empty())\\n                left[i] = -1;\\n            else\\n                left[i] = st.top().second;\\n            \\n            st.push({dp[i],i});\\n        }\\n        \\n        vector<int> right(n);\\n        right[n-1] = -1;\\n        while(!st.empty())\\n            st.pop();\\n        \\n        st.push({dp[n-1],n-1});\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            while(!st.empty() && st.top().first<=dp[i])\\n                st.pop();\\n            \\n            if(st.empty())\\n                right[i] = -1;\\n            else\\n                right[i] = st.top().second;\\n            st.push({dp[i],i});\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int req = dp[i];\\n            int l = left[i]==-1 ? i : (i-left[i]-1);\\n            int r = right[i]==-1 ? n-i-1 : (right[i]-i-1);\\n            if(l+r+1 >= req)\\n                return dp[i];\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260449,
                "title": "python-monotone-stack-easty-to-understand",
                "content": "for each subarray, the critical element is the minimal one, so only need to compare its values with the threshold/length;\\nfor each item in the array, we find the largest subarray with the item as the minimal, so by the monotone stack, we get the left and right extension; and combine together to get the length.\\n\\n\\n```\\n def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        n=len(nums)\\n        left=[-1]*n ## to the left, strictly smaller than i-th item\\n        right=[n]*n \\n        st=[]\\n        for i,c in enumerate(nums):\\n            while st and nums[st[-1]]>=c:\\n                st.pop()\\n            if st:\\n                left[i]=st[-1]\\n            st.append(i)\\n        st=[]\\n        for i in range(n-1,-1,-1):\\n            while st and nums[st[-1]]>=nums[i]:\\n                st.pop()\\n            if st:\\n                right[i]=st[-1]\\n            st.append(i)\\n        for i in range(n):\\n            st=left[i]+1\\n            ed=right[i]-1\\n            L=ed-st+1\\n            if nums[i]>threshold/L:\\n                return L\\n        return -1\\n",
                "solutionTags": [],
                "code": "for each subarray, the critical element is the minimal one, so only need to compare its values with the threshold/length;\\nfor each item in the array, we find the largest subarray with the item as the minimal, so by the monotone stack, we get the left and right extension; and combine together to get the length.\\n\\n\\n```\\n def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n        n=len(nums)\\n        left=[-1]*n ## to the left, strictly smaller than i-th item\\n        right=[n]*n \\n        st=[]\\n        for i,c in enumerate(nums):\\n            while st and nums[st[-1]]>=c:\\n                st.pop()\\n            if st:\\n                left[i]=st[-1]\\n            st.append(i)\\n        st=[]\\n        for i in range(n-1,-1,-1):\\n            while st and nums[st[-1]]>=nums[i]:\\n                st.pop()\\n            if st:\\n                right[i]=st[-1]\\n            st.append(i)\\n        for i in range(n):\\n            st=left[i]+1\\n            ed=right[i]-1\\n            L=ed-st+1\\n            if nums[i]>threshold/L:\\n                return L\\n        return -1\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2260370,
                "title": "my-solutions",
                "content": "**1. Use the Disjoint Set**\\n```\\n/**\\n * let `n` be the length of the vector `nums`\\n *\\n * the algorithm is as following,\\n * 1. sort the vector `nums` along with the information of each element\\'s index\\n *    from the greatest element ot the least one\\n * 2. employ a disjoint set of size `n`\\n * 3. iterate the sorted `nums`, if the adjacent element,\\n *    the left one and the right one if any,\\n *    is greater than the current element, union these two elements\\n *    if the current element is greater than `threshold / group`,\\n *    where `group` is the size of the elements which are in the same group\\n *    as the current element in the disjoint set,\\n *    that means any element of the group is greater than `threshold / group`\\n *    because the current element is the least one of the group.\\n *    the `group` is the answer, return it.\\n * 4. when the loop of the step `3` finishes, that means no valid answers are found,\\n *    return -1\\n *\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n private:\\n  class DisjointSet {\\n   public:\\n    DisjointSet(const int n) : parents_(n), groups_(n, 1) {\\n      iota(parents_.begin(), parents_.end(), 0);\\n    }\\n    \\n    int find(const int i) {\\n      if (i == parents_[i]) {\\n        return i;\\n      }\\n      \\n      parents_[i] = find(parents_[i]);\\n      return parents_[i];\\n    }\\n    \\n    bool do_union(const int i, const int j) {\\n      const int parent_i = find(i);\\n      const int parent_j = find(j);\\n      if (parent_i == parent_j) {\\n        return false;\\n      }\\n      \\n      const int final_group = groups_[parent_i] + groups_[parent_j];\\n      if (groups_[parent_i] < groups_[parent_j]) {\\n        parents_[parent_i] = parent_j;\\n        groups_[parent_j] = final_group;\\n        groups_[parent_i] = 0;\\n      } else {\\n        parents_[parent_j] = parent_i;\\n        groups_[parent_i] = final_group;\\n        groups_[parent_j] = 0;\\n      }\\n      return true;\\n    }\\n    \\n    int group(const int i) {\\n      return groups_[find(i)];\\n    }\\n    \\n   private:\\n    vector<int> parents_;\\n    vector<int> groups_;\\n  };\\n  \\n public:\\n  int validSubarraySize(const vector<int> &nums, const int threshold) {\\n    const int n = static_cast<int>(nums.size());\\n    int indices[n];\\n    iota(indices, indices + n, 0);\\n    sort(indices, indices + n, [&nums](const int lhs, const int rhs) -> bool {\\n      return nums[lhs] > nums[rhs];\\n    });\\n    \\n    DisjointSet ds(n);\\n    for (int i = 0; i < n; ++i) {\\n      const int index = indices[i];\\n      if (index > 0 && nums[index - 1] >= nums[index]) {\\n        ds.do_union(index, index - 1);\\n      }\\n      if (index + 1 < n && nums[index + 1] >= nums[index]) {\\n        ds.do_union(index, index + 1);\\n      }\\n      \\n      const int group = ds.group(index);\\n      if (nums[index] > threshold / group) {\\n        return group;\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```\\n**2. Use the monotonous stack**\\n```\\n/**\\n * let `n` be the length of the vector `nums`\\n * the monotonous stack is employed.\\n *\\n * the algorithm is as following,\\n * iterate every element `nums[i]` of the array `nums`,\\n * 1. find the maximum `j` such that `j` < `i` and `nums[j]` < `nums[i]`\\n * 2. find the minimum `k` such that `k` > `i` and `nums[k]` < `nums[i]`\\n * 3. the element `nums[i]` is the minimum element of\\n *    the subarray `nums[j + 1: k)`, j + 1 inclusive, k exclusive.\\n *    the length `length` of the subarray is `(k - (j + 1))`\\n *    if nums[i] > threshold / length, `length` is the answer, return it\\n * if the loop finishes, that means no valid answers are found,\\n * return -1\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  int validSubarraySize(const vector<int> &nums, const int threshold) {\\n    const int n = static_cast<int>(nums.size());\\n    int left[n];\\n    memset(left, -1, sizeof(left));\\n    /**\\n     * a monotonously-increasing stack is employed,\\n     * the element of which is the index of the vector `nums`\\n     */\\n    stack<int> st;\\n    for (int i = n - 1; i > -1; --i) {\\n      while (!st.empty() && nums[st.top()] > nums[i]) {\\n        left[st.top()] = i;\\n        st.pop();\\n      }\\n      st.emplace(i);\\n    }\\n    \\n    int right[n];\\n    fill(right, right + n, n);\\n    st = stack<int>{};\\n    for (int i = 0; i < n; ++i) {\\n      while (!st.empty() && nums[st.top()] > nums[i]) {\\n        right[st.top()] = i;\\n        st.pop();\\n      }\\n      st.emplace(i);\\n    }\\n    \\n    for (int i = 0; i < n; ++i) {\\n      const int length = right[i] - left[i] - 1;\\n      if (nums[i] > threshold / length) {\\n        return length;\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```\\n**3. Use the DP**\\n```\\n/**\\n * let `n` be the length of the vector `nums`\\n * the dp solution is employed.\\n *\\n * the algorithm is as following,\\n * iterate every element `nums[i]` of the array `nums`,\\n * 1. find the minimum `j` such that `j` <= `i` and\\n *    for every index `l`, where `j` <= `l` <= `i`, `nums[l]` >= `nums[i]`\\n * 2. find the maximum `k` such that `k` >= `i` and\\n *    for every index `l`, where `i` <= `l` <= `k`, `nums[l]` >= `nums[i]`\\n * 3. the element `nums[i]` is the minimum element of\\n *    the subarray `nums[j: k + 1)`, j inclusive, k + 1 exclusive.\\n *    the length `length` of the subarray is `(k + 1 - j)`\\n *    if nums[i] > threshold / length, `length` is the answer, return it\\n * if the loop finishes, that means no valid answers are found,\\n * return -1\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  int validSubarraySize(const vector<int> &nums, const int threshold) {\\n    const int n = static_cast<int>(nums.size());\\n    int left[n];\\n    memset(left, 0, sizeof(left));\\n    for (int i = 0; i < n; ++i) {\\n      left[i] = i;\\n      while (left[i] > 0 && nums[left[i] - 1] >= nums[i]) {\\n        left[i] = left[left[i] - 1];\\n      }\\n    }\\n    \\n    int right[n];\\n    memset(right, 0, sizeof(right));\\n    for (int i = n - 1; i > -1; --i) {\\n      right[i] = i;\\n      while (right[i] + 1 < n && nums[right[i] + 1] >= nums[i]) {\\n        right[i] = right[right[i] + 1];\\n      }\\n    }\\n    \\n    for (int i = 0; i < n; ++i) {\\n      const int length = right[i] - left[i] + 1;\\n      if (nums[i] > threshold / length) {\\n        return length;\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * let `n` be the length of the vector `nums`\\n *\\n * the algorithm is as following,\\n * 1. sort the vector `nums` along with the information of each element\\'s index\\n *    from the greatest element ot the least one\\n * 2. employ a disjoint set of size `n`\\n * 3. iterate the sorted `nums`, if the adjacent element,\\n *    the left one and the right one if any,\\n *    is greater than the current element, union these two elements\\n *    if the current element is greater than `threshold / group`,\\n *    where `group` is the size of the elements which are in the same group\\n *    as the current element in the disjoint set,\\n *    that means any element of the group is greater than `threshold / group`\\n *    because the current element is the least one of the group.\\n *    the `group` is the answer, return it.\\n * 4. when the loop of the step `3` finishes, that means no valid answers are found,\\n *    return -1\\n *\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n private:\\n  class DisjointSet {\\n   public:\\n    DisjointSet(const int n) : parents_(n), groups_(n, 1) {\\n      iota(parents_.begin(), parents_.end(), 0);\\n    }\\n    \\n    int find(const int i) {\\n      if (i == parents_[i]) {\\n        return i;\\n      }\\n      \\n      parents_[i] = find(parents_[i]);\\n      return parents_[i];\\n    }\\n    \\n    bool do_union(const int i, const int j) {\\n      const int parent_i = find(i);\\n      const int parent_j = find(j);\\n      if (parent_i == parent_j) {\\n        return false;\\n      }\\n      \\n      const int final_group = groups_[parent_i] + groups_[parent_j];\\n      if (groups_[parent_i] < groups_[parent_j]) {\\n        parents_[parent_i] = parent_j;\\n        groups_[parent_j] = final_group;\\n        groups_[parent_i] = 0;\\n      } else {\\n        parents_[parent_j] = parent_i;\\n        groups_[parent_i] = final_group;\\n        groups_[parent_j] = 0;\\n      }\\n      return true;\\n    }\\n    \\n    int group(const int i) {\\n      return groups_[find(i)];\\n    }\\n    \\n   private:\\n    vector<int> parents_;\\n    vector<int> groups_;\\n  };\\n  \\n public:\\n  int validSubarraySize(const vector<int> &nums, const int threshold) {\\n    const int n = static_cast<int>(nums.size());\\n    int indices[n];\\n    iota(indices, indices + n, 0);\\n    sort(indices, indices + n, [&nums](const int lhs, const int rhs) -> bool {\\n      return nums[lhs] > nums[rhs];\\n    });\\n    \\n    DisjointSet ds(n);\\n    for (int i = 0; i < n; ++i) {\\n      const int index = indices[i];\\n      if (index > 0 && nums[index - 1] >= nums[index]) {\\n        ds.do_union(index, index - 1);\\n      }\\n      if (index + 1 < n && nums[index + 1] >= nums[index]) {\\n        ds.do_union(index, index + 1);\\n      }\\n      \\n      const int group = ds.group(index);\\n      if (nums[index] > threshold / group) {\\n        return group;\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```\n```\\n/**\\n * let `n` be the length of the vector `nums`\\n * the monotonous stack is employed.\\n *\\n * the algorithm is as following,\\n * iterate every element `nums[i]` of the array `nums`,\\n * 1. find the maximum `j` such that `j` < `i` and `nums[j]` < `nums[i]`\\n * 2. find the minimum `k` such that `k` > `i` and `nums[k]` < `nums[i]`\\n * 3. the element `nums[i]` is the minimum element of\\n *    the subarray `nums[j + 1: k)`, j + 1 inclusive, k exclusive.\\n *    the length `length` of the subarray is `(k - (j + 1))`\\n *    if nums[i] > threshold / length, `length` is the answer, return it\\n * if the loop finishes, that means no valid answers are found,\\n * return -1\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  int validSubarraySize(const vector<int> &nums, const int threshold) {\\n    const int n = static_cast<int>(nums.size());\\n    int left[n];\\n    memset(left, -1, sizeof(left));\\n    /**\\n     * a monotonously-increasing stack is employed,\\n     * the element of which is the index of the vector `nums`\\n     */\\n    stack<int> st;\\n    for (int i = n - 1; i > -1; --i) {\\n      while (!st.empty() && nums[st.top()] > nums[i]) {\\n        left[st.top()] = i;\\n        st.pop();\\n      }\\n      st.emplace(i);\\n    }\\n    \\n    int right[n];\\n    fill(right, right + n, n);\\n    st = stack<int>{};\\n    for (int i = 0; i < n; ++i) {\\n      while (!st.empty() && nums[st.top()] > nums[i]) {\\n        right[st.top()] = i;\\n        st.pop();\\n      }\\n      st.emplace(i);\\n    }\\n    \\n    for (int i = 0; i < n; ++i) {\\n      const int length = right[i] - left[i] - 1;\\n      if (nums[i] > threshold / length) {\\n        return length;\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```\n```\\n/**\\n * let `n` be the length of the vector `nums`\\n * the dp solution is employed.\\n *\\n * the algorithm is as following,\\n * iterate every element `nums[i]` of the array `nums`,\\n * 1. find the minimum `j` such that `j` <= `i` and\\n *    for every index `l`, where `j` <= `l` <= `i`, `nums[l]` >= `nums[i]`\\n * 2. find the maximum `k` such that `k` >= `i` and\\n *    for every index `l`, where `i` <= `l` <= `k`, `nums[l]` >= `nums[i]`\\n * 3. the element `nums[i]` is the minimum element of\\n *    the subarray `nums[j: k + 1)`, j inclusive, k + 1 exclusive.\\n *    the length `length` of the subarray is `(k + 1 - j)`\\n *    if nums[i] > threshold / length, `length` is the answer, return it\\n * if the loop finishes, that means no valid answers are found,\\n * return -1\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  int validSubarraySize(const vector<int> &nums, const int threshold) {\\n    const int n = static_cast<int>(nums.size());\\n    int left[n];\\n    memset(left, 0, sizeof(left));\\n    for (int i = 0; i < n; ++i) {\\n      left[i] = i;\\n      while (left[i] > 0 && nums[left[i] - 1] >= nums[i]) {\\n        left[i] = left[left[i] - 1];\\n      }\\n    }\\n    \\n    int right[n];\\n    memset(right, 0, sizeof(right));\\n    for (int i = n - 1; i > -1; --i) {\\n      right[i] = i;\\n      while (right[i] + 1 < n && nums[right[i] + 1] >= nums[i]) {\\n        right[i] = right[right[i] + 1];\\n      }\\n    }\\n    \\n    for (int i = 0; i < n; ++i) {\\n      const int length = right[i] - left[i] + 1;\\n      if (nums[i] > threshold / length) {\\n        return length;\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260362,
                "title": "c-o-n-solution-monotonic-stacks",
                "content": "1. For each nums[i], counting the interval length len[i] between the first left smaller number and the first right smaller number with using stack.\\n2. The nums[i] should be the smallest number in the interval with max length len[i].\\n3. Found i such that (threshold/len[i]) < nums[i], then one of the anwser is len[i].\\n\\nps. the code will find the interval like [l, r), and the result length may be -1 (if there are the same numbers), but it\\'s ok due to the correct length also be computed at another edge:\\n```\\n\\tnums:   1, 3, 4, 3, 1\\n\\tleft:  -1, 1, 3, 3, 1\\n\\tright: -1, 1, 3, 1, -1\\n\\t len:   5, 3, 1, 2, 4\\n```\\n\\n\\u2035\\u2035\\u2035\\n\\n\\tclass Solution {\\n\\t\\t#define pii pair<int, int>\\n\\t\\t#define F first\\n\\t\\t#define S second\\n\\tpublic:\\n\\t\\tint validSubarraySize(vector<int>& nums, int th) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<int> l(n), r(n), len(n);\\n\\n\\t\\t\\tnums.push_back(-1);\\n\\t\\t\\tstack<pii> st;\\n\\t\\t\\tst.push({-1, -1});\\n\\t\\t\\tfor(int i=0; i<=n; i++){\\n\\t\\t\\t\\twhile(!st.empty() && nums[i] < st.top().F){\\n\\t\\t\\t\\t\\tauto [p, ind] = st.top(); st.pop();\\n\\t\\t\\t\\t\\tl[ind] = st.top().F;\\n\\t\\t\\t\\t\\tr[ind] = nums[i];\\n\\t\\t\\t\\t\\tlen[ind] = i - st.top().S - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tst.push({nums[i], i});\\n\\t\\t\\t}\\n\\t\\t\\t/*\\n\\t\\t\\tcout << \"l=\" << endl;\\n\\t\\t\\tfor(auto i : l) cout << i << \" \";\\n\\t\\t\\tcout << endl;\\n\\n\\t\\t\\tcout << \"r=\" << endl;\\n\\t\\t\\tfor(auto i : r) cout << i << \" \";\\n\\t\\t\\tcout << endl;\\n\\n\\t\\t\\tcout << \"len=\" << endl;\\n\\t\\t\\tfor(auto i : len) cout << i << \" \";\\n\\t\\t\\tcout << endl;\\n\\t\\t\\t*/\\n\\t\\t\\tint ans = -1;\\n\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\tif(th/len[i] < nums[i]) return len[i];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\u2035\\u2035\\u2035\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tnums:   1, 3, 4, 3, 1\\n\\tleft:  -1, 1, 3, 3, 1\\n\\tright: -1, 1, 3, 1, -1\\n\\t len:   5, 3, 1, 2, 4\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2260306,
                "title": "c-o-n-solution-using-2-stacks",
                "content": "```\\nint validSubarraySize(vector<int>& nums, int threshold) \\n{\\n\\tvector<pair<int,int>> s1,s2;\\n\\tint n=nums.size(),r1[n],r2[n];\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\twhile(!s1.empty()&&nums[i]<=s1.back().first) s1.pop_back();\\n\\t\\tr1[i]=s1.empty() ? -1 : s1.back().second;\\n\\t\\ts1.push_back({nums[i],i});\\n\\n\\t\\twhile(!s2.empty()&&nums[n-i-1]<=s2.back().first) s2.pop_back();\\n\\t\\tr2[n-i-1]=s2.empty() ? n : r2[n-i-1]=s2.back().second;\\n\\n\\t\\ts2.push_back({nums[n-i-1],n-i-1});\\n\\t}\\n\\tfor(int i=0;i<n;i++)\\n\\t\\tif(nums[i]>threshold/(r2[i]-r1[i]-1)) return r2[i]-r1[i]-1;\\n\\n\\treturn -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint validSubarraySize(vector<int>& nums, int threshold) \\n{\\n\\tvector<pair<int,int>> s1,s2;\\n\\tint n=nums.size(),r1[n],r2[n];\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\twhile(!s1.empty()&&nums[i]<=s1.back().first) s1.pop_back();\\n\\t\\tr1[i]=s1.empty() ? -1 : s1.back().second;\\n\\t\\ts1.push_back({nums[i],i});\\n\\n\\t\\twhile(!s2.empty()&&nums[n-i-1]<=s2.back().first) s2.pop_back();\\n\\t\\tr2[n-i-1]=s2.empty() ? n : r2[n-i-1]=s2.back().second;\\n\\n\\t\\ts2.push_back({nums[n-i-1],n-i-1});\\n\\t}\\n\\tfor(int i=0;i<n;i++)\\n\\t\\tif(nums[i]>threshold/(r2[i]-r1[i]-1)) return r2[i]-r1[i]-1;\\n\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2260174,
                "title": "c-o-n-solution-100-efficient-easy",
                "content": "// 1. find left smallest element index and right smallest element index for each element \\n2. calculate length \\n3. if(element*length>threshold ) return length\\n\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        vector<long long> r(n, n), l(n, -1);\\n        \\n        stack<int> s;\\n        for(int i = n-1; i >=0; --i) {\\n            while(!s.empty() and nums[i] <=nums[s.top()]) {\\n                s.pop();\\n            }\\n            if(s.empty())\\n            {\\n                 r[i]=n;\\n            }\\n            else\\n            {\\n                 r[i]=s.top();\\n                 \\n            }\\n            //cout<<r[i]<<\" \";\\n            s.push(i);\\n        }\\n       // s.clear();\\n        stack<int>st;\\n        for(int i = 0; i<n; ++i) {\\n          while(!st.empty() and nums[i] <=nums[st.top()]) {\\n               \\n                st.pop();\\n            }\\n            if(st.empty())\\n            {\\n                l[i]=-1;\\n            }\\n            else{\\n                l[i]=st.top();\\n                \\n            }\\n            st.push(i);\\n        }\\n        \\n        for(int i = 0; i < n; ++i) {\\n            long long length = r[i] - l[i] - 1;\\n            if(1LL * nums[i] * length > threshold) return length;\\n        }\\n        \\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        vector<long long> r(n, n), l(n, -1);\\n        \\n        stack<int> s;\\n        for(int i = n-1; i >=0; --i) {\\n            while(!s.empty() and nums[i] <=nums[s.top()]) {\\n                s.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2260118,
                "title": "c-o-n-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& v, int t) {\\n        int len=v.size();\\n        for(auto &a:v){\\n            a=(t/a)+1;\\n        }\\n\\t\\t\\n        vector<int> ng(len, len), pg(len, -1);\\n\\t\\t\\n        stack<int> s;//monotonic decreasing stack\\n        s.push(0);\\n        for(int x=1;x<len;x++){\\n            while(s.size() and v[s.top()]<v[x]){\\n                ng[s.top()]=x;\\n                s.pop();\\n            }\\n            s.push(x);\\n        }\\n\\t\\t\\n        stack<int> s1;//monotonic increasing stack\\n        s1.push(len-1);\\n        for(int x=len-2;x>=0;x--){\\n            while(s1.size() and v[s1.top()]<v[x]){\\n                pg[s1.top()]=x;\\n                s1.pop();\\n            }\\n            s1.push(x);\\n        }\\n\\n        for(int x=0;x<len;x++){\\n            int res=ng[x]-pg[x]-1;\\n            if(res>=v[x]){\\n                return res;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& v, int t) {\\n        int len=v.size();\\n        for(auto &a:v){\\n            a=(t/a)+1;\\n        }\\n\\t\\t\\n        vector<int> ng(len, len), pg(len, -1);\\n\\t\\t\\n        stack<int> s;//monotonic decreasing stack\\n        s.push(0);\\n        for(int x=1;x<len;x++){\\n            while(s.size() and v[s.top()]<v[x]){\\n                ng[s.top()]=x;\\n                s.pop();\\n            }\\n            s.push(x);\\n        }\\n\\t\\t\\n        stack<int> s1;//monotonic increasing stack\\n        s1.push(len-1);\\n        for(int x=len-2;x>=0;x--){\\n            while(s1.size() and v[s1.top()]<v[x]){\\n                pg[s1.top()]=x;\\n                s1.pop();\\n            }\\n            s1.push(x);\\n        }\\n\\n        for(int x=0;x<len;x++){\\n            int res=ng[x]-pg[x]-1;\\n            if(res>=v[x]){\\n                return res;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260041,
                "title": "c-easy-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int thre) {\\n        int n=nums.size();\\n        vector<int>nextSma(n,0);\\n        vector<int>prevSma(n,0);\\n        stack<int>s;\\n        s.push(n-1);\\n        nextSma[n-1]=n;\\n        for(int i=n-2;i>=0;i--){\\n            while(!s.empty()&&nums[i]<=nums[s.top()]){\\n                s.pop();\\n            }\\n            nextSma[i]=s.empty()?n:s.top();\\n            s.push(i);\\n        }\\n        stack<int>s1;\\n        for(int i=n-1;i>=0;i--){\\n            while(!s1.empty()&&nums[i]<nums[s1.top()]){\\n                prevSma[s1.top()]=i;\\n                s1.pop();\\n            }\\n            s1.push(i);\\n        }\\n        \\n        while(!s1.empty()){prevSma[s1.top()]=-1;s1.pop();}\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int next=nextSma[i]-i;\\n            int prev=i-prevSma[i];\\n            if((next+prev-1)>0&&(nums[i]>(thre/(next+prev-1)))){ans=next+prev-1;break;}\\n        }\\n        return ans==0?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int thre) {\\n        int n=nums.size();\\n        vector<int>nextSma(n,0);\\n        vector<int>prevSma(n,0);\\n        stack<int>s;\\n        s.push(n-1);\\n        nextSma[n-1]=n;\\n        for(int i=n-2;i>=0;i--){\\n            while(!s.empty()&&nums[i]<=nums[s.top()]){\\n                s.pop();\\n            }\\n            nextSma[i]=s.empty()?n:s.top();\\n            s.push(i);\\n        }\\n        stack<int>s1;\\n        for(int i=n-1;i>=0;i--){\\n            while(!s1.empty()&&nums[i]<nums[s1.top()]){\\n                prevSma[s1.top()]=i;\\n                s1.pop();\\n            }\\n            s1.push(i);\\n        }\\n        \\n        while(!s1.empty()){prevSma[s1.top()]=-1;s1.pop();}\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int next=nextSma[i]-i;\\n            int prev=i-prevSma[i];\\n            if((next+prev-1)>0&&(nums[i]>(thre/(next+prev-1)))){ans=next+prev-1;break;}\\n        }\\n        return ans==0?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259819,
                "title": "waiting-for-lee",
                "content": "I was waiting for lee to post answer but don\\'t know where he is",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2259802,
                "title": "video-editorial",
                "content": "Video Link:- https://www.youtube.com/watch?v=3TBJAr1ZARE",
                "solutionTags": [],
                "code": "Video Link:- https://www.youtube.com/watch?v=3TBJAr1ZARE",
                "codeTag": "Unknown"
            },
            {
                "id": 2259800,
                "title": "c-union-find-combine-the-left-and-right-sides-from-the-sorted-array",
                "content": "Not a optimal solutoin but demonstarte some ideas. \\n\\n```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        vector< pair<int, int> > vec;\\n        for (int i = 0; i < nums.size(); ++i)\\n        {\\n            vec.push_back( {nums[i], i} );\\n        }\\n        sort(vec.begin(), vec.end());\\n        vector<int> pos(n, 0);\\n       \\n        \\n        reverse(vec.begin(), vec.end());\\n         for (int i = 0; i < vec.size(); ++i)\\n        {\\n            pos[ vec[i].second ] = i;\\n        }\\n        vector<int> reps(n, -1);\\n        vector<int> cnts(n + 1, 1);\\n        \\n        int index = 0;\\n        for (int i = 1; i <= n; ++i)\\n        {\\n            int val = threshold / i;            \\n            while (index < n && vec[index].first > val)\\n            {\\n                int t = vec[index].second;                \\n                int left = 0, right = 0;                \\n                if (t - 1 >= 0 && nums[t - 1] > val && pos[t] > pos[t - 1]) \\n                {                    \\n                    left = cnts[ FindRep(reps, t - 1) ];\\n                    Union(reps, t, t - 1);\\n                }\\n                if (t + 1 < n && nums[t + 1] > val && pos[t] > pos[t + 1]) \\n                {                    \\n                    right = cnts[ FindRep(reps, t + 1) ];\\n                    Union(reps, t, t + 1);\\n                }\\n                int rep = FindRep(reps, t);\\n                cnts[rep] = left + right + 1;               \\n                if (cnts[rep] >= i) return i;\\n                ++index;\\n               \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    int FindRep(vector<int>& reps, int i)\\n    {\\n        if (reps[i] == -1) return i;\\n        int ret = FindRep(reps, reps[i]);\\n        return ret;\\n    }\\n    \\n    void Union(vector<int>& reps, int i, int t)\\n    {\\n        int iRep = FindRep(reps, i);\\n        int tRep = FindRep(reps, t);\\n        if (tRep != iRep)\\n        {\\n            reps[tRep] = iRep;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int validSubarraySize(vector<int>& nums, int threshold) {\\n        int n = nums.size();\\n        vector< pair<int, int> > vec;\\n        for (int i = 0; i < nums.size(); ++i)\\n        {\\n            vec.push_back( {nums[i], i} );\\n        }\\n        sort(vec.begin(), vec.end());\\n        vector<int> pos(n, 0);\\n       \\n        \\n        reverse(vec.begin(), vec.end());\\n         for (int i = 0; i < vec.size(); ++i)\\n        {\\n            pos[ vec[i].second ] = i;\\n        }\\n        vector<int> reps(n, -1);\\n        vector<int> cnts(n + 1, 1);\\n        \\n        int index = 0;\\n        for (int i = 1; i <= n; ++i)\\n        {\\n            int val = threshold / i;            \\n            while (index < n && vec[index].first > val)\\n            {\\n                int t = vec[index].second;                \\n                int left = 0, right = 0;                \\n                if (t - 1 >= 0 && nums[t - 1] > val && pos[t] > pos[t - 1]) \\n                {                    \\n                    left = cnts[ FindRep(reps, t - 1) ];\\n                    Union(reps, t, t - 1);\\n                }\\n                if (t + 1 < n && nums[t + 1] > val && pos[t] > pos[t + 1]) \\n                {                    \\n                    right = cnts[ FindRep(reps, t + 1) ];\\n                    Union(reps, t, t + 1);\\n                }\\n                int rep = FindRep(reps, t);\\n                cnts[rep] = left + right + 1;               \\n                if (cnts[rep] >= i) return i;\\n                ++index;\\n               \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    int FindRep(vector<int>& reps, int i)\\n    {\\n        if (reps[i] == -1) return i;\\n        int ret = FindRep(reps, reps[i]);\\n        return ret;\\n    }\\n    \\n    void Union(vector<int>& reps, int i, int t)\\n    {\\n        int iRep = FindRep(reps, i);\\n        int tRep = FindRep(reps, t);\\n        if (tRep != iRep)\\n        {\\n            reps[tRep] = iRep;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2010834,
                "content": [
                    {
                        "username": "AMIT_GEEK",
                        "content": "class Solution {\\npublic:\\n    bool check(vector<int>nums,int g,int k)\\n    {\\n        if(k==0)return false;\\n        g=g/k;\\n          multiset<int>s;\\n          for(int i=0;i<k;i++)\\n          {\\n              s.insert(nums[i]);\\n          }\\n          if(*(s.begin())>g)return true;\\n          for(int i=k;i<nums.size();i++)\\n          {\\n              s.insert(nums[i]);\\n              s.erase(nums[i-k]);\\n              cout<<*s.begin()<<\" \";\\n              if(*(s.begin())>g)return true;\\n\\n          }\\n          cout<<endl;\\n          return false;\\n    }\\n    int validSubarraySize(vector<int>& nums, int th) {\\n        int n=nums.size();\\n        int l=0,h=n,ans=-1;\\n        while(l<=h)\\n        {\\n            int mid=l+(h-l)/2;\\n            \\n            if(check(nums,th,mid))\\n            {\\n                h=mid-1;\\n                ans=mid;\\n            }\\n            else\\n            l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\ncan anyone explain why above solution is not  working, only getting 49/68 tc passed\\n"
                    },
                    {
                        "username": "vikramu9td",
                        "content": "Consider this testcase: [1,1,1,1,8] threshold = 7. Try to do a dry run on your code and you\\'ll realise where it went wrong"
                    },
                    {
                        "username": "Pleasechoose",
                        "content": "class Solution(object):\\n    def validSubarraySize(self, nums, threshold):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type threshold: int\\n        :rtype: int\\n        \"\"\"\\n\\n        nums.sort(reverse=True)\\n\\n        i=0\\n        while(i < len(nums)):\\n            if nums[i] <= threshold/(i+1):\\n                i = i+1\\n            else:\\n                return i+1\\n        \\n        return -1\\n\\nWhat\\'s wrong with this logic?\\n"
                    }
                ]
            },
            {
                "id": 1950421,
                "content": [
                    {
                        "username": "AMIT_GEEK",
                        "content": "class Solution {\\npublic:\\n    bool check(vector<int>nums,int g,int k)\\n    {\\n        if(k==0)return false;\\n        g=g/k;\\n          multiset<int>s;\\n          for(int i=0;i<k;i++)\\n          {\\n              s.insert(nums[i]);\\n          }\\n          if(*(s.begin())>g)return true;\\n          for(int i=k;i<nums.size();i++)\\n          {\\n              s.insert(nums[i]);\\n              s.erase(nums[i-k]);\\n              cout<<*s.begin()<<\" \";\\n              if(*(s.begin())>g)return true;\\n\\n          }\\n          cout<<endl;\\n          return false;\\n    }\\n    int validSubarraySize(vector<int>& nums, int th) {\\n        int n=nums.size();\\n        int l=0,h=n,ans=-1;\\n        while(l<=h)\\n        {\\n            int mid=l+(h-l)/2;\\n            \\n            if(check(nums,th,mid))\\n            {\\n                h=mid-1;\\n                ans=mid;\\n            }\\n            else\\n            l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\ncan anyone explain why above solution is not  working, only getting 49/68 tc passed\\n"
                    },
                    {
                        "username": "vikramu9td",
                        "content": "Consider this testcase: [1,1,1,1,8] threshold = 7. Try to do a dry run on your code and you\\'ll realise where it went wrong"
                    },
                    {
                        "username": "Pleasechoose",
                        "content": "class Solution(object):\\n    def validSubarraySize(self, nums, threshold):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type threshold: int\\n        :rtype: int\\n        \"\"\"\\n\\n        nums.sort(reverse=True)\\n\\n        i=0\\n        while(i < len(nums)):\\n            if nums[i] <= threshold/(i+1):\\n                i = i+1\\n            else:\\n                return i+1\\n        \\n        return -1\\n\\nWhat\\'s wrong with this logic?\\n"
                    }
                ]
            }
        ]
    }
]